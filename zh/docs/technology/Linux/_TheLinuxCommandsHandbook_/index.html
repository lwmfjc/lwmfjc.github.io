<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="TheLinuxCommandsHandbook"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lwmfjc.github.io/zh/docs/technology/Linux/_TheLinuxCommandsHandbook_/"><meta property="og:site_name" content="随记"><meta property="og:title" content="_TheLinuxCommandsHandbook_"><meta property="og:description" content="TheLinuxCommandsHandbook"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2024-12-31T21:52:35+08:00"><meta property="article:modified_time" content="2024-12-31T21:52:35+08:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Command"><title>_TheLinuxCommandsHandbook_ | 随记</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://lwmfjc.github.io/zh/docs/technology/Linux/_TheLinuxCommandsHandbook_/><link rel=stylesheet href=/book.min.61c2259501b059453d6e3b0551df29ef9de07bb5236b73baae9ac80bb6f5e94c.css integrity="sha256-YcIllQGwWUU9bjsFUd8p753ge7Uja3O6rprIC7b16Uw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.c87452e37255ee77575a34e3531259c26d0519527dfa19257a77c39285875fd8.js integrity="sha256-yHRS43JV7ndXWjTjUxJZwm0FGVJ9+hklenfDkoWHX9g=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>随记</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><a href=/zh/docs/technology/>技术</a><ul><li><input type=checkbox id=section-d2e5dc71fe2274ddaa089e125f33ae58 class=toggle>
<label for=section-d2e5dc71fe2274ddaa089e125f33ae58 class="flex justify-between"><a role=button>My SQL</a></label><ul><li><input type=checkbox id=section-14acbe73a39f7c2e8d055bbdbab560d6 class=toggle>
<label for=section-14acbe73a39f7c2e8d055bbdbab560d6 class="flex justify-between"><a role=button>_MySQL是怎样运行的_</a></label><ul><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/08/>08数据的家--MySQL的数据目录</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/07/>07B+数索引的使用</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/06/>06B+树索引</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/05/>05InnoDB数据页结构</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/04/>04InnoDB记录存储结构</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/03/>03字符集和比较规则</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/02/>02启动选项和系统变量</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/01/>01初识MySQL</a></li></ul></li><li><input type=checkbox id=section-522269efe4a436e18b16a29ff12d542d class=toggle>
<label for=section-522269efe4a436e18b16a29ff12d542d class="flex justify-between"><a role=button>高性能 My SQL</a></label><ul><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83/>封面-版权</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC9%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96/>第9章操作系统和硬件优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC8%E7%AB%A0%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/>第8章优化服务器设置</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC7%E7%AB%A0MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/>第7章MySQL高级特性</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC6%E7%AB%A0%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>第6章查询性能优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC5%E7%AB%A0%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/>第5章创建高性能的索引</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC4%E7%AB%A0Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/>第4章Schema与数据类型优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC3%E7%AB%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/>第3章服务器性能剖析</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC2%E7%AB%A0MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/>第2章MySQL基准测试</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC1%E7%AB%A0MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2/>第1章MySQL架构与历史</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC16%E7%AB%A0MySQL%E7%94%A8%E6%88%B7%E5%B7%A5%E5%85%B7/>第16章MySQL用户工具</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC15%E7%AB%A0%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/>第15章备份与恢复</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC14%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82%E4%BC%98%E5%8C%96/>第14章应用层优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC13%E7%AB%A0%E4%BA%91%E7%AB%AF%E7%9A%84MySQL/>第13章云端的MySQL</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC12%E7%AB%A0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/>第12章高可用性</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC11%E7%AB%A0%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84MySQL/>第11章可扩展的MySQL</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC10%E7%AB%A0%E5%A4%8D%E5%88%B6/>第10章复制</a></li></ul></li><li><input type=checkbox id=section-33ad04dc8d65b11ab6b2d2e0964c3c89 class=toggle>
<label for=section-33ad04dc8d65b11ab6b2d2e0964c3c89 class="flex justify-between"><a role=button>进阶(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MySQL/bl_sgg_/96-00/>mysql高阶_sgg 96-00</a></li></ul></li></ul></li><li><input type=checkbox id=section-1dd4601389ea65ef400f95373226aee0 class=toggle checked>
<label for=section-1dd4601389ea65ef400f95373226aee0 class="flex justify-between"><a role=button>Linux</a></label><ul><li><input type=checkbox id=section-eb3a110e9a221e46d625b63087e91152 class=toggle>
<label for=section-eb3a110e9a221e46d625b63087e91152 class="flex justify-between"><a role=button>SHELL编程(learnLinuxTV)_</a></label><ul><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/16-18/>16-18</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/12-15/>12-15</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/11DataStreams/>11DataStreams</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/07-10/>07-10</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/06ExitCode/>06ExitCode</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/05If/>05If</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/01-04/>01-04</a></li></ul></li><li><input type=checkbox id=section-cd7838d42e3d9f745d945ce90940f02e class=toggle>
<label for=section-cd7838d42e3d9f745d945ce90940f02e class="flex justify-between"><a role=button>韩顺平老师_</a></label><ul><li><a href=/zh/docs/technology/Linux/hanshunping_/52-x/>52-X</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/40-51/>linux_韩老师_40-51</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/28-39/>linux_韩老师_28-39</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/21-27/>linux_韩老师_21-33</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/12-20/>linux_韩老师_12-20</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/07-11/>linux_韩老师_07-11</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/01-06/>linux_韩老师_01-06</a></li></ul></li><li><a href=/zh/docs/technology/Linux/_TheLinuxCommandsHandbook_/ class=active>_TheLinuxCommandsHandbook_</a></li><li><a href=/zh/docs/technology/Linux/basic/>基本操作</a></li><li><a href=/zh/docs/technology/Linux/create_clone/>vmware上linux主机的安装和克隆</a></li></ul></li><li><input type=checkbox id=section-9f56b27db6873dfaab68a13a9088b050 class=toggle>
<label for=section-9f56b27db6873dfaab68a13a9088b050 class="flex justify-between"><a role=button>Reg Exp</a></label><ul><li><input type=checkbox id=section-e7092def48f35456be32e3b6257559e4 class=toggle>
<label for=section-e7092def48f35456be32e3b6257559e4 class="flex justify-between"><a role=button>基础(CoreySchafer)_</a></label><ul><li><a href=/zh/docs/technology/RegExp/baseCoreySchafer_/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class=toggle>
<label for=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class="flex justify-between"><a role=button>Hugo</a></label><ul><li><input type=checkbox id=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class=toggle>
<label for=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class="flex justify-between"><a role=button>主题</a></label><ul><li><a href=/zh/docs/technology/Hugo/themes/PaperMod/01/>使用PaperMode</a></li></ul></li><li><input type=checkbox id=section-d72f299b202b2766d1efe5fb807ed184 class=toggle>
<label for=section-d72f299b202b2766d1efe5fb807ed184 class="flex justify-between"><a role=button>基础(Giraffe学院)_</a></label><ul><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced20-23/>hugo进阶学习20-23</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced17-19/>hugo进阶学习17-19</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced11-16/>hugo进阶学习11-15</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced01-10/>hugo进阶学习01-10</a></li></ul></li></ul></li><li><input type=checkbox id=section-43be5f3c9fb2465efc746ae00240e4b3 class=toggle>
<label for=section-43be5f3c9fb2465efc746ae00240e4b3 class="flex justify-between"><a role=button>Obsidian</a></label><ul><li><a href=/zh/docs/technology/Obsidian/border-theme/>border-theme背景图片问题</a></li><li><a href=/zh/docs/technology/Obsidian/obsidian-theme/>obsidian-theme</a></li><li><a href=/zh/docs/technology/Obsidian/plugin/>plugin</a></li></ul></li><li><input type=checkbox id=section-7123c56777444b2f7157631dd88ad8f6 class=toggle>
<label for=section-7123c56777444b2f7157631dd88ad8f6 class="flex justify-between"><a role=button>Redis</a></label><ul><li><input type=checkbox id=section-e6cea4f92582460cfa10699a07a10e32 class=toggle>
<label for=section-e6cea4f92582460cfa10699a07a10e32 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/19-A/>redis_尚硅谷_19-A</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/18/>redis_尚硅谷_18</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/12-17/>redis_尚硅谷_12-17</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/06-11/>redis_尚硅谷_06-11</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/01-05/>redis_尚硅谷_01-05</a></li></ul></li><li><a href=/zh/docs/technology/Redis/rsync-use/>rsync使用</a></li><li><a href=/zh/docs/technology/Redis/redis-cluster/>redis集群搭建</a></li></ul></li><li><input type=checkbox id=section-a94b8d7740a71c28fc6e0f89885b2468 class=toggle>
<label for=section-a94b8d7740a71c28fc6e0f89885b2468 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><input type=checkbox id=section-64c6733376d70496ded44b4ef3db6718 class=toggle>
<label for=section-64c6733376d70496ded44b4ef3db6718 class="flex justify-between"><a role=button>_深入理解Java虚拟机_</a></label><ul><li><a href=/zh/docs/technology/JVM/_understanding_the_jvm_/03/>03垃圾收集器与内存分配策略</a></li></ul></li></ul></li><li><input type=checkbox id=section-e8f515fe7fc71d283363385aa363c2dd class=toggle>
<label for=section-e8f515fe7fc71d283363385aa363c2dd class="flex justify-between"><a role=button>其他</a></label><ul><li><a href=/zh/docs/technology/Other/kaoshi/>科目</a></li><li><a href=/zh/docs/technology/Other/pc_base/>电脑基础操作</a></li></ul></li><li><input type=checkbox id=section-f54112ca99b135fbc484938888b1f1a2 class=toggle>
<label for=section-f54112ca99b135fbc484938888b1f1a2 class="flex justify-between"><a href=/zh/docs/technology/Review/>面试</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/>JavaGuide</a><ul><li><input type=checkbox id=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class=toggle>
<label for=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class="flex justify-between"><a role=button>数据库</a></label><ul><li><input type=checkbox id=section-e7660273cef85dff1f39af04a42bd062 class=toggle>
<label for=section-e7660273cef85dff1f39af04a42bd062 class="flex justify-between"><a role=button>MySQL</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0606lymysql-query-execution-plan/>mysql执行计划</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0611lymysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0610lymysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0609lyindex-invalidation-caused-by-implicit-conversion/>MySQL中的隐式转换造成的索引失效</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0608lysome-thoughts-on-database-storage-time/>MySQL数据库时间类型数据存储建议</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0605lyhow-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0604lyinnodb-implementation-of-mvcc/>innodb引擎对MVCC的实现</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0603lytransaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0602lymysql-logs/>日志</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0601lymysql-index/>索引</a></li></ul></li><li><input type=checkbox id=section-680d077436e58b0cad0a63ed8edb5f53 class=toggle>
<label for=section-680d077436e58b0cad0a63ed8edb5f53 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/diagram/>redis问题图解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0703ly3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0704lyredis-memory-fragmentation/>redis内存碎片</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0702lyredis-spec-data-structure/>redis特殊数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0701lyredis-base-data-structures/>redis基本数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0706lyredis-questions-02/>redis面试题02</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0705lyredis-questions-01/>redis面试题01</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0503lysql-question-01/>sql常见面试题总结01</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0504lysql-syntax-summary/>sql语法基础知识总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0502lycharactor-set/>字符集详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0501lybasis/>数据库基础</a></li></ul></li><li><input type=checkbox id=section-a1b717b4079938cc0efe574541b240b8 class=toggle>
<label for=section-a1b717b4079938cc0efe574541b240b8 class="flex justify-between"><a role=button>系统设计</a></label><ul><li><input type=checkbox id=section-9eaf95f03abf595bfdf838c4b4cdb2ef class=toggle>
<label for=section-9eaf95f03abf595bfdf838c4b4cdb2ef class="flex justify-between"><a role=button>安全</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly06ly_sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly05ly_design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly04ly_sso-intro/>sso单点登录</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly03ly_jwt-advantages-disadvantages/>jwt身份认证优缺点</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly02ly_jwt-intro/>jwt-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly01ly_basis-of-authority-certification/>认证授权基础概念详解</a></li></ul></li><li><input type=checkbox id=section-79417049c90714c6ddbf18a3c3958148 class=toggle>
<label for=section-79417049c90714c6ddbf18a3c3958148 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/unit-test/>单元测试</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/software-engineering/>软件工程简明教程</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/restful/>restFul</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/web-real-time-message-push/>web-real-time-message-push</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/schedule-task/>Java定时任务详解</a></li></ul></li><li><input type=checkbox id=section-0a9533f3005d615c696f74456e46d269 class=toggle>
<label for=section-0a9533f3005d615c696f74456e46d269 class="flex justify-between"><a role=button>高可用</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly05ly_performance-test/>性能测试入门</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly04ly_timout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly03ly_limit-request/>服务限流详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly02ly_redundancy/>冗余设计</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly01ly_high-availability-system-design/>高可用系统设计指南</a></li></ul></li><li><input type=checkbox id=section-e36f94f48e5027e7cbd39b7f7bbc249c class=toggle>
<label for=section-e36f94f48e5027e7cbd39b7f7bbc249c class="flex justify-between"><a role=button>高性能</a></label><ul><li><input type=checkbox id=section-581624dd7aa25a150f706312689ba446 class=toggle>
<label for=section-581624dd7aa25a150f706312689ba446 class="flex justify-between"><a role=button>RocketMQ</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-questions/>rocketmq常见面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-intro/>rocketmq介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/base/>message-queue</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly02ly_cdn/>cdn</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly01ly_read-and-write-separation-and-library-subtable/>数据库读写分离&分库分表详解</a></li></ul></li><li><input type=checkbox id=section-a6916634f1b5324076467df4cc9ac3b5 class=toggle>
<label for=section-a6916634f1b5324076467df4cc9ac3b5 class="flex justify-between"><a role=button>分布式系统</a></label><ul><li><input type=checkbox id=section-0c8e62b6137b614e01882e2a88ea5daf class=toggle>
<label for=section-0c8e62b6137b614e01882e2a88ea5daf class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/raft-algorithm/>raft算法</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/paxos-algorithm/>paxos算法</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/cap_base-theorem/>CAP&amp;BASE 理论</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly08ly_zookeeper-in-action/>zookeeper实战</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly07ly_zookeeper-plus/>zookeeper进阶</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly06ly_zookeeper-intro/>zookeeper介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly04ly_rpc-http/>rpc_http</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly05ly_rpc-intro/>rpc基础及面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly03ly_distributed-lock/>分布式锁</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly02ly_distributed-id/>分布式id</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly01ly_api-gateway/>api网关</a></li></ul></li><li><input type=checkbox id=section-ce3cbb53c62f67624e4ab24a5a14298a class=toggle>
<label for=section-ce3cbb53c62f67624e4ab24a5a14298a class="flex justify-between"><a role=button>框架</a></label><ul><li><input type=checkbox id=section-dbe480810d1877286936b38cdb5e9229 class=toggle>
<label for=section-dbe480810d1877286936b38cdb5e9229 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><input type=checkbox id=section-30b916f2071579e2468767a2562433d9 class=toggle>
<label for=section-30b916f2071579e2468767a2562433d9 class="flex justify-between"><a role=button>原理</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle3/>Mybatis原理系列(3)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle2/>Mybatis原理系列(2)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle1/>Mybatis原理系列(1)</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/MyBatis-interview/>Mybatis面试</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/conditional_on_class/>ConditionalOnClass实践</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly05ly_springboot-auto-assembly/>SpringBoot自动装配原理</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly04ly_spring-design-patterns/>spring 设计模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly03ly_spring-transaction/>Spring事务详情</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly02ly_spring-annotations/>Spring/SpringBoot常用注解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/>spring 常见面试题总结</a></li></ul></li><li><input type=checkbox id=section-1f6733a85e33dcc22aabbf820e3ef963 class=toggle>
<label for=section-1f6733a85e33dcc22aabbf820e3ef963 class="flex justify-between"><a role=button>开发工具</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/git/>git</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/maven/>maven</a></li></ul></li><li><input type=checkbox id=section-c01151f806b917cd0ecc4cffa72c3402 class=toggle>
<label for=section-c01151f806b917cd0ecc4cffa72c3402 class="flex justify-between"><a role=button>Java基础</a></label><ul><li><input type=checkbox id=section-26625a0c4c0bffef02640966ca545537 class=toggle>
<label for=section-26625a0c4c0bffef02640966ca545537 class="flex justify-between"><a role=button>并发</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly030301lyatomicpre/>Atomic预备知识</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0311lycompletablefuture-intro/>completablefuture-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0310lythreadlocal/>ThreadLocal详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0309lyatomic-classes/>Atomic原子类介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0308lyaqs-details/>aqs详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0307lyconcurrent-collections/>java常见并发容器</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0306lythread-pool-best/>线程池最佳实践</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0305lyjava-thread-pool/>java线程池详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0304lyjmm/>java内存模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0303lyconcurrent-03/>并发03</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03122lylock_escalation/>锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated2/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03121lyobject-concurrent/>对象内存布局和对象头</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0302lyconcurrent-02/>并发02</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0301lyconcurrent-01/>并发01</a></li></ul></li><li><input type=checkbox id=section-8f747d8f024fbfe2b392a25696e01266 class=toggle>
<label for=section-8f747d8f024fbfe2b392a25696e01266 class="flex justify-between"><a role=button>IO</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0203lyio-model/>io模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0202lyio-design-patterns/>io设计模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0201lyio/>io基础</a></li></ul></li><li><input type=checkbox id=section-7d26c3d37b0e4678a1ec776265992903 class=toggle>
<label for=section-7d26c3d37b0e4678a1ec776265992903 class="flex justify-between"><a role=button>集合</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0105lysource-code-concurrenthashmap/>ConcurrentHashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0106lysource-code-hashmap/>HashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0104lysource-code-ArrayList/>ArrayList源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0103lycollections-precautions-for-use/>集合使用注意事项</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0102lycollection_2/>集合_2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0101lycollection_1/>集合_1</a></li></ul></li><li><input type=checkbox id=section-7027a9bc1d603892e7826da81b333f38 class=toggle>
<label for=section-7027a9bc1d603892e7826da81b333f38 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0011lysyntactic_sugar/>语法糖</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0010lyjava_spi/>java_spi</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0009lyunsafe_class/>unsafe类</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0008lybig_decimal/>big_decimal</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0007lyproxy_pattern/>Java代理模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0006lyreflex/>java-reflex</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0005lyserialize/>Java序列化详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0004lypassbyvalue/>为什么Java中只有值传递</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0003lyjava_guide_basic_3/>javaGuide基础3</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0002lyjava_guide_basic_2/>javaGuide基础2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0001lyjava_guide_basic_1/>javaGuide基础1</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0408lyjdk-monitoring-and-troubleshooting-tools/>jvm监控和故障处理工具 总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0406lyjvm-params/>jvm参数</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0403lyclass-structure/>类文件结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0405lyclassloader-detail/>类加载器详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0404lyclassloader-process/>类加载过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0402lygarbage-collection/>java垃圾回收</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0407lyjvm-intro/>jvm-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0401lymemory-area/>memory-area</a></li></ul></li><li><input type=checkbox id=section-04d967d6579d47b35ececb3d233024f1 class=toggle>
<label for=section-04d967d6579d47b35ececb3d233024f1 class="flex justify-between"><a role=button>计算机基础</a></label><ul><li><input type=checkbox id=section-316b43351a75a19ac6dec86ad1a48c45 class=toggle>
<label for=section-316b43351a75a19ac6dec86ad1a48c45 class="flex justify-between"><a role=button>数据结构</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/heap/>堆</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li></ul></li></ul></li><li><input type=checkbox id=section-09d19e9c6f50e4706fe8b6d358c441ce class=toggle>
<label for=section-09d19e9c6f50e4706fe8b6d358c441ce class="flex justify-between"><a role=button>Ssm</a></label><ul><li><a href=/zh/docs/technology/Review/ssm/scope_transaction/>作用域及事务</a></li></ul></li><li><input type=checkbox id=section-11f3d4afcbd3591ad3ee5d79993e29d7 class=toggle>
<label for=section-11f3d4afcbd3591ad3ee5d79993e29d7 class="flex justify-between"><a role=button>Java基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Review/basics/member_variables_and_local_variables/>成员变量与局部变量</a></li><li><a href=/zh/docs/technology/Review/basics/recursion_and_iteration/>递归与迭代</a></li><li><a href=/zh/docs/technology/Review/basics/method_parameter_passing_mechanism/>方法的参数传递机制</a></li><li><a href=/zh/docs/technology/Review/basics/class_and_instance_initialization/>类、实例初始化</a></li><li><a href=/zh/docs/technology/Review/basics/singleton_design_pattern/>单例设计模式</a></li><li><a href=/zh/docs/technology/Review/basics/self_incrementing_variable/>自增变量</a></li></ul></li></ul></li><li><input type=checkbox id=section-2fa8d2f95840b0143e19fcee5ee1ad97 class=toggle>
<label for=section-2fa8d2f95840b0143e19fcee5ee1ad97 class="flex justify-between"><a role=button>SpringCloud</a></label><ul><li><input type=checkbox id=section-b7a5506013de8d65cad1cac0f659f728 class=toggle>
<label for=section-b7a5506013de8d65cad1cac0f659f728 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/springCloud/bl_zhouyang_/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-5057ba12f456498454476dc11b58648b class=toggle>
<label for=section-5057ba12f456498454476dc11b58648b class="flex justify-between"><a role=button>Git</a></label><ul><li><input type=checkbox id=section-55d261358c84b4996ac8d7851d37ccf8 class=toggle>
<label for=section-55d261358c84b4996ac8d7851d37ccf8 class="flex justify-between"><a role=button>基础(尚硅谷视频)_</a></label><ul><li><a href=/zh/docs/technology/Git/git_sgg_/19-26/>19-26_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg_/09-18/>09-18_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg_/01-08/>01-08_git_尚硅谷</a></li></ul></li></ul></li><li><input type=checkbox id=section-d8f59257917ebff8da82fd22583ae10c class=toggle>
<label for=section-d8f59257917ebff8da82fd22583ae10c class="flex justify-between"><a role=button>Maven</a></label><ul><li><input type=checkbox id=section-9b52bdf229c64237c3a478dc6a533410 class=toggle>
<label for=section-9b52bdf229c64237c3a478dc6a533410 class="flex justify-between"><a role=button>进阶(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/advance_dljd_/01-21/>01-21 maven多模块管理_动力节点</a></li></ul></li><li><input type=checkbox id=section-3b2851b4ae70cae160ce8f24dba7236a class=toggle>
<label for=section-3b2851b4ae70cae160ce8f24dba7236a class="flex justify-between"><a role=button>基础(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/base_dljd_/31-43/>31-43 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd_/17-30/>17-30 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd_/01-16/>01-16 maven基础_动力节点</a></li></ul></li></ul></li><li><input type=checkbox id=section-d2ff9acb1ec90bec89f165361ced2010 class=toggle>
<label for=section-d2ff9acb1ec90bec89f165361ced2010 class="flex justify-between"><a role=button>算法</a></label><ul><li><input type=checkbox id=section-d1faa468beb89fe27a31308721f74c82 class=toggle>
<label for=section-d1faa468beb89fe27a31308721f74c82 class="flex justify-between"><a role=button>_算法(第四版)_</a></label><ul><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/3.2.1/>算法红皮书 3.2.1</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/3.1.1-3.1.7/>算法红皮书 3.1.1-3.1.7</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.5/>算法红皮书 2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.4/>算法红皮书 2.4</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.1.2-2.1.3/>算法红皮书 2.1.2-2.1.3</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.1.1/>算法红皮书 2.1.1</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.5.1-1.5.3/>算法红皮书 1.5.1-1.5.3</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.4.1-1.4.10/>算法红皮书 1.4.1-1.4.10</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.3.3.1-1.3.4/>算法红皮书1.3.3.1-1.3.4</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.3.1.1-1.3.2.5/>算法红皮书 1.3.1.1-1.3.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.2.1-1.2.5/>算法红皮书 1.2.1-1.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.1.6-1.1.11/>算法红皮书 1.1.6-1.1.11</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.1.1-1.1.5/>算法红皮书 1.1.1-1.1.5</a></li></ul></li></ul></li><li><input type=checkbox id=section-b414f13e51dbc5e90231aa49f06e7237 class=toggle>
<label for=section-b414f13e51dbc5e90231aa49f06e7237 class="flex justify-between"><a role=button>My Batis Plus</a></label><ul><li><input type=checkbox id=section-0e4fa61015701c3d99296175840aa5d3 class=toggle>
<label for=section-0e4fa61015701c3d99296175840aa5d3 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/40-57/>mybatis-plus-sgg-40-57</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/19-39/>mybatis-plus-sgg-19-39</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/12-18/>mybatis-plus-sgg-12-18</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/01-11/>mybatis-plus-sgg-01-11</a></li></ul></li><li><a href=/zh/docs/technology/MyBatis-Plus/official/hello/>官方的hello-world</a></li></ul></li><li><input type=checkbox id=section-1e5a67821c47d147a096480c75e0d7c4 class=toggle>
<label for=section-1e5a67821c47d147a096480c75e0d7c4 class="flex justify-between"><a role=button>Flowable</a></label><ul><li><input type=checkbox id=section-0a06ca67446b7a26392adaea7b2dc30f class=toggle>
<label for=section-0a06ca67446b7a26392adaea7b2dc30f class="flex justify-between"><a role=button>基础(波哥)_</a></label><ul><li><a href=/zh/docs/technology/Flowable/boge_blbl_/03-others/>boge-03-其他</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_6/>boge-02-flowable进阶_6</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_5/>boge-02-flowable进阶_5</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_4/>boge-02-flowable进阶_4</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_3/>boge-02-flowable进阶_3</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_2/>boge-02-flowable进阶_2</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_1/>boge-02-flowable进阶_1</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/01-base/>boge-01-flowable基础</a></li></ul></li><li><input type=checkbox id=section-6019d9043956834af14f96c2f7dcd5ca class=toggle>
<label for=section-6019d9043956834af14f96c2f7dcd5ca class="flex justify-between"><a role=button>官方文档</a></label><ul><li><a href=/zh/docs/technology/Flowable/offical/05/>Flowable-05-spring-boot</a></li><li><a href=/zh/docs/technology/Flowable/offical/04/>Flowable-04-spring</a></li><li><a href=/zh/docs/technology/Flowable/offical/03/>Flowable-03-api</a></li><li><a href=/zh/docs/technology/Flowable/offical/02/>Flowable-02-Configuration</a></li><li><a href=/zh/docs/technology/Flowable/offical/01/>Flowable-01-GettingStarted</a></li></ul></li><li><a href=/zh/docs/technology/Flowable/zsx_design/01/>zsx_flowable_design01</a></li></ul></li><li><input type=checkbox id=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class=toggle>
<label for=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class="flex justify-between"><a role=button>Rocket Mq</a></label><ul><li><input type=checkbox id=section-8c49e88e8756a0a7b3e45abde3117dd5 class=toggle>
<label for=section-8c49e88e8756a0a7b3e45abde3117dd5 class="flex justify-between"><a role=button>基础(黑马)_</a></label><ul><li><a href=/zh/docs/technology/RocketMQ/heima_/05advance/>05高级功能</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/04case/>04案例</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/03messagetype/>03收发消息</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/02buildcluster/>02双主双从集群搭建</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/01base/>01rocketmq学习</a></li></ul></li></ul></li><li><input type=checkbox id=section-dcbf6163d9f750f7cc3b9417d1386331 class=toggle>
<label for=section-dcbf6163d9f750f7cc3b9417d1386331 class="flex justify-between"><a role=button>Interview</a></label><ul><li><input type=checkbox id=section-c8fd55079fae864a8c659fb14cbb379e class=toggle>
<label for=section-c8fd55079fae864a8c659fb14cbb379e class="flex justify-between"><a role=button>Cs Basics</a></label><ul><li><input type=checkbox id=section-ac5cd91bf1acc2a16a9dbdfa9c17f629 class=toggle>
<label for=section-ac5cd91bf1acc2a16a9dbdfa9c17f629 class="flex justify-between"><a role=button>Algorithms</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/common-data-structures-leetcode-recommendations/>常见数据结构经典LeetCode题目推荐</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/linkedlist-algorithm-problems/>几道常见的链表算法题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/string-algorithm-problems/>几道常见的字符串算法题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/the-sword-refers-to-offer/>剑指offer部分编程题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/classical-algorithm-problems-recommendations/>经典算法思想总结（含LeetCode题目推荐）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/10-classical-sorting-algorithms/>十大经典排序算法总结</a></li></ul></li><li><input type=checkbox id=section-f435ca39dd71dd7765b81dd8ec05c344 class=toggle>
<label for=section-f435ca39dd71dd7765b81dd8ec05c344 class="flex justify-between"><a role=button>Data Structure</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/heap/>Index</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/bloom-filter/>布隆过滤器</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/red-black-tree/>红黑树</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li><li><input type=checkbox id=section-fa182df3abee2343aa6c977c2a75dda2 class=toggle>
<label for=section-fa182df3abee2343aa6c977c2a75dda2 class="flex justify-between"><a role=button>Network</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/network/computer-network-xiexiren-summary/>《计算机网络》（谢希仁）内容总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/arp/>ARP 协议详解(网络层)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/dns/>DNS 域名系统详解（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http1.0-vs-http1.1/>HTTP 1.0 vs HTTP 1.1（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http-vs-https/>HTTP vs HTTPS（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http-status-codes/>HTTP 常见状态码总结（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/nat/>NAT 协议详解（网络层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/osi-and-tcp-ip-model/>OSI 和 TCP/IP 网络分层模型详解（基础）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/tcp-reliability-guarantee/>TCP 传输可靠性保障（传输层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/tcp-connection-and-disconnection/>TCP 三次握手和四次挥手（传输层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/the-whole-process-of-accessing-web-pages/>访问网页的全过程（知识串联）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/other-network-questions/>计算机网络常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/other-network-questions2/>计算机网络常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/network-attack-means/>网络攻击常见手段总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/application-layer-protocol/>应用层常见协议总结（应用层）</a></li></ul></li><li><input type=checkbox id=section-76856ab8063b8754553c166410441284 class=toggle>
<label for=section-76856ab8063b8754553c166410441284 class="flex justify-between"><a role=button>Operating System</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/linux-intro/>Linux 基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/shell-intro/>Shell 编程基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-01/>操作系统常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-02/>操作系统常见面试题总结(下)</a></li></ul></li></ul></li><li><input type=checkbox id=section-fa219a2fa1e454bccf1abf45b7e68c8e class=toggle>
<label for=section-fa219a2fa1e454bccf1abf45b7e68c8e class="flex justify-between"><a role=button>Database</a></label><ul><li><input type=checkbox id=section-1e90eaf849a2719b2603214b93639e7c class=toggle>
<label for=section-1e90eaf849a2719b2603214b93639e7c class="flex justify-between"><a role=button>Elasticsearch</a></label><ul><li><a href=/zh/docs/technology/Interview/database/elasticsearch/elasticsearch-questions-01/>Elasticsearch常见面试题总结(付费)</a></li></ul></li><li><input type=checkbox id=section-36fcdf6608f26e92ce7bb1e95612ca73 class=toggle>
<label for=section-36fcdf6608f26e92ce7bb1e95612ca73 class="flex justify-between"><a role=button>Mongodb</a></label><ul><li><a href=/zh/docs/technology/Interview/database/mongodb/mongodb-questions-01/>MongoDB常见面试题总结（上）</a></li><li><a href=/zh/docs/technology/Interview/database/mongodb/mongodb-questions-02/>MongoDB常见面试题总结（下）</a></li></ul></li><li><input type=checkbox id=section-1681ed9defad2064b37ff3e603cd509c class=toggle>
<label for=section-1681ed9defad2064b37ff3e603cd509c class="flex justify-between"><a role=button>Mysql</a></label><ul><li><a href=/zh/docs/technology/Interview/database/mysql/innodb-implementation-of-mvcc/>InnoDB存储引擎对MVCC的实现</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-query-cache/>MySQL查询缓存详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/some-thoughts-on-database-storage-time/>MySQL日期类型选择建议</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-logs/>MySQL三大日志(binlog、redo log和undo log)详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/transaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-index/>MySQL索引详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/index-invalidation-caused-by-implicit-conversion/>MySQL隐式转换造成索引失效</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-query-execution-plan/>MySQL执行计划分析</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-auto-increment-primary-key-continuous/>MySQL自增主键一定是连续的吗</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/how-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/a-thousand-lines-of-mysql-study-notes/>一千行 MySQL 学习笔记</a></li></ul></li><li><input type=checkbox id=section-7b494a9accb20a42d3eb50307ebf95b8 class=toggle>
<label for=section-7b494a9accb20a42d3eb50307ebf95b8 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Interview/database/redis/3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-data-structures-02/>Redis 3 种特殊数据类型详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-data-structures-01/>Redis 5 种基本数据类型详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-questions-01/>Redis常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-questions-02/>Redis常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-common-blocking-problems-summary/>Redis常见阻塞原因总结</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-persistence/>Redis持久化机制详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-cluster/>Redis集群详解(付费)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-memory-fragmentation/>Redis内存碎片详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-skiplist/>Redis为什么用跳表实现有序集合</a></li><li><a href=/zh/docs/technology/Interview/database/redis/cache-basics/>缓存基础常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-delayed-task/>如何基于Redis实现延时任务</a></li></ul></li><li><input type=checkbox id=section-0b495945d7d1c7bace636f2809188369 class=toggle>
<label for=section-0b495945d7d1c7bace636f2809188369 class="flex justify-between"><a role=button>SQL</a></label><ul><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-01/>SQL常见面试题总结（1）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-02/>SQL常见面试题总结（2）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-03/>SQL常见面试题总结（3）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-04/>SQL常见面试题总结（4）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-05/>SQL常见面试题总结（5）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-syntax-summary/>SQL语法基础知识总结</a></li></ul></li><li><a href=/zh/docs/technology/Interview/database/nosql/>NoSQL基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/database/basis/>数据库基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/database/character-set/>字符集详解</a></li></ul></li><li><input type=checkbox id=section-9bc7f274474a2d4825bfb7e0f835ec9f class=toggle>
<label for=section-9bc7f274474a2d4825bfb7e0f835ec9f class="flex justify-between"><a role=button>Distributed System</a></label><ul><li><input type=checkbox id=section-4aa0a804a8f6d6d2745a8f9d92dbae63 class=toggle>
<label for=section-4aa0a804a8f6d6d2745a8f9d92dbae63 class="flex justify-between"><a role=button>Distributed Process Coordination</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-in-action/>ZooKeeper 实战</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus/>ZooKeeper相关概念总结(进阶)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro/>ZooKeeper相关概念总结(入门)</a></li></ul></li><li><input type=checkbox id=section-917636e43923e143cb27e958ae247d83 class=toggle>
<label for=section-917636e43923e143cb27e958ae247d83 class="flex justify-between"><a role=button>Protocol</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/cap-and-base-theorem/>CAP & BASE理论详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/gossip-protocl/>Gossip 协议详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/paxos-algorithm/>Paxos 算法详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/raft-algorithm/>Raft 算法详解</a></li></ul></li><li><input type=checkbox id=section-5f212fdd6451198aab8e6d9d1c28c4d2 class=toggle>
<label for=section-5f212fdd6451198aab8e6d9d1c28c4d2 class="flex justify-between"><a role=button>Rpc</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/dubbo/>Dubbo常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/rpc-intro/>RPC基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/httprpc/>有了 HTTP 协议，为什么还要有 RPC ？</a></li></ul></li><li><a href=/zh/docs/technology/Interview/distributed-system/api-gateway/>API网关基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/spring-cloud-gateway-questions/>Spring Cloud Gateway常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-id/>分布式ID介绍&实现方案总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-id-design/>分布式ID设计指南</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-configuration-center/>分布式配置中心常见问题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-transaction/>分布式事务常见解决方案总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-lock-implementations/>分布式锁常见实现方案总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-lock/>分布式锁介绍</a></li></ul></li><li><input type=checkbox id=section-20eb042d5085894960b2b40cdde1bd95 class=toggle>
<label for=section-20eb042d5085894960b2b40cdde1bd95 class="flex justify-between"><a role=button>High Availability</a></label><ul><li><a href=/zh/docs/technology/Interview/high-availability/timeout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/limit-request/>服务限流详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/high-availability-system-design/>高可用系统设计指南</a></li><li><a href=/zh/docs/technology/Interview/high-availability/fallback-and-circuit-breaker/>降级&熔断详解(付费)</a></li><li><a href=/zh/docs/technology/Interview/high-availability/redundancy/>冗余设计详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/performance-test/>性能测试入门</a></li></ul></li><li><input type=checkbox id=section-d863e9c02108d739d2116dee6c3f0df2 class=toggle>
<label for=section-d863e9c02108d739d2116dee6c3f0df2 class="flex justify-between"><a role=button>High Performance</a></label><ul><li><a href=/zh/docs/technology/Interview/high-performance/cdn/>CDN工作原理详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/disruptor-questions/>Disruptor常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/kafka-questions-01/>Kafka常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/rabbitmq-questions/>RabbitMQ常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/rocketmq-questions/>RocketMQ常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/sql-optimization/>常见SQL优化手段总结（付费）</a></li><li><a href=/zh/docs/technology/Interview/high-performance/read-and-write-separation-and-library-subtable/>读写分离和分库分表详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/load-balancing/>负载均衡原理及算法详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/deep-pagination-optimization/>深度分页介绍及优化建议</a></li><li><a href=/zh/docs/technology/Interview/high-performance/data-cold-hot-separation/>数据冷热分离详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/message-queue/>消息队列基础知识总结</a></li></ul></li><li><input type=checkbox id=section-2874dffbab1645c0b90b66f58878baeb class=toggle>
<label for=section-2874dffbab1645c0b90b66f58878baeb class="flex justify-between"><a role=button>High Quality Technical Articles</a></label><ul><li><input type=checkbox id=section-043c9e2ae521f883513d71615d921b93 class=toggle>
<label for=section-043c9e2ae521f883513d71615d921b93 class="flex justify-between"><a role=button>Advanced Programmer</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant/>程序员的技术成长战略</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/programmer-quickly-learn-new-technology/>程序员如何快速学习新技术</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/seven-tips-for-becoming-an-advanced-programmer/>给想成长为高级别开发同学的七条建议</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work/>工作五年之后，对技术和业务的思考</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/meituan-three-year-summary-lesson-10/>美团三年，总结的10条血泪教训</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road/>十年大厂成长之路</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/20-bad-habits-of-bad-programmers/>糟糕程序员的 20 个坏习惯</a></li></ul></li><li><input type=checkbox id=section-5a7311ea7fe807f97a6fa93dffde10b6 class=toggle>
<label for=section-5a7311ea7fe807f97a6fa93dffde10b6 class="flex justify-between"><a role=button>Interview</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/some-secrets-about-alibaba-interview/>阿里技术面试的一些秘密</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/technical-preliminary-preparation/>从面试官和候选者的角度谈如何准备技术初试</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/summary-of-spring-recruitment/>普通人的春招总结（阿里、腾讯offer）</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology/>如何在技术初试中考察程序员的技术能力</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/screen-candidates-for-packaging/>如何甄别应聘者的包装程度</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/my-personal-experience-in-2021/>校招进入飞书的个人经验</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer/>一位大龄程序员所经历的面试的历炼和思考</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-of-get-offer-from-over-20-big-companies/>斩获 20+ 大厂 offer 的面试经验分享</a></li></ul></li><li><input type=checkbox id=section-bf0bb8140b840e0af3c2632b6b73e609 class=toggle>
<label for=section-bf0bb8140b840e0af3c2632b6b73e609 class="flex justify-between"><a role=button>Personal Experience</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/four-year-work-in-tencent-summary/>从校招入职腾讯的四年工作总结</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao/>滴滴和头条两年后端工作经验分享</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/huawei-od-275-days/>华为 OD 275 天后，我进了腾讯！</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/8-years-programmer-work-summary/>一个中科大差生的 8 年程序员工作总结</a></li></ul></li><li><input type=checkbox id=section-8166233fd6553926230055376f2b97f6 class=toggle>
<label for=section-8166233fd6553926230055376f2b97f6 class="flex justify-between"><a role=button>Programmer</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/efficient-book-publishing-and-practice-guide/>程序员高效出书避坑和实践指南</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/how-do-programmers-publish-a-technical-book/>程序员怎样出版一本技术书</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/high-value-certifications-for-programmers/>程序员最该拿的几种高含金量证书</a></li></ul></li><li><input type=checkbox id=section-b607a393d7717c448e31e58c8972bbba class=toggle>
<label for=section-b607a393d7717c448e31e58c8972bbba class="flex justify-between"><a role=button>Work</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/32-tips-improving-career/>32条总结教你提升职场经验</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/employee-performance/>聊聊大厂的绩效考核</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/get-into-work-mode-quickly-when-you-join-a-company/>新入职一家公司如何快速进入工作状态</a></li></ul></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/readme/>Index</a></li></ul></li><li><input type=checkbox id=section-5680a0cf00b09d8470dc67fa0a170b89 class=toggle>
<label for=section-5680a0cf00b09d8470dc67fa0a170b89 class="flex justify-between"><a role=button>Java</a></label><ul><li><input type=checkbox id=section-6e2eabf08cfe622d9921e3edfa11e55a class=toggle>
<label for=section-6e2eabf08cfe622d9921e3edfa11e55a class="flex justify-between"><a role=button>Basis</a></label><ul><li><a href=/zh/docs/technology/Interview/java/basis/java-keyword-summary/>Index</a></li><li><a href=/zh/docs/technology/Interview/java/basis/bigdecimal/>BigDecimal 详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/spi/>Java SPI 机制详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/proxy/>Java 代理模式详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/reflection/>Java 反射机制详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/unsafe/>Java 魔法类 Unsafe 详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/serialization/>Java 序列化详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/syntactic-sugar/>Java 语法糖详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/why-there-only-value-passing-in-java/>Java 值传递详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-01/>Java基础常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-03/>Java基础常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-02/>Java基础常见面试题总结(中)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/generics-and-wildcards/>泛型&通配符详解</a></li></ul></li><li><input type=checkbox id=section-b9f81b31813c0f4b2cd6e884ad0c0511 class=toggle>
<label for=section-b9f81b31813c0f4b2cd6e884ad0c0511 class="flex justify-between"><a role=button>Collection</a></label><ul><li><a href=/zh/docs/technology/Interview/java/collection/arrayblockingqueue-source-code/>ArrayBlockingQueue 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/arraylist-source-code/>ArrayList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/concurrent-hash-map-source-code/>ConcurrentHashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/copyonwritearraylist-source-code/>CopyOnWriteArrayList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/delayqueue-source-code/>DelayQueue 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/hashmap-source-code/>HashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-questions-01/>Java集合常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-questions-02/>Java集合常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-precautions-for-use/>Java集合使用注意事项总结</a></li><li><a href=/zh/docs/technology/Interview/java/collection/linkedhashmap-source-code/>LinkedHashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/linkedlist-source-code/>LinkedList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/priorityqueue-source-code/>PriorityQueue 源码分析（付费）</a></li></ul></li><li><input type=checkbox id=section-8cc9034354bdd549787a43bea3c7c40c class=toggle>
<label for=section-8cc9034354bdd549787a43bea3c7c40c class="flex justify-between"><a role=button>Concurrent</a></label><ul><li><a href=/zh/docs/technology/Interview/java/concurrent/aqs/>AQS 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/atomic-classes/>Atomic 原子类总结</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/cas/>CAS 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/completablefuture-intro/>CompletableFuture 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-collections/>Java 常见并发容器总结</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-thread-pool-summary/>Java 线程池详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-thread-pool-best-practices/>Java 线程池最佳实践</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-01/>Java并发常见面试题总结（上）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-03/>Java并发常见面试题总结（下）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-02/>Java并发常见面试题总结（中）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/jmm/>JMM（Java 内存模型）详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/threadlocal/>ThreadLocal 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/reentrantlock/>从ReentrantLock的实现看AQS的原理及应用</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/optimistic-lock-and-pessimistic-lock/>乐观锁和悲观锁详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/virtual-thread/>虚拟线程常见问题总结</a></li></ul></li><li><input type=checkbox id=section-498d2cde022f952a6751a7ebd2a53aeb class=toggle>
<label for=section-498d2cde022f952a6751a7ebd2a53aeb class="flex justify-between"><a role=button>Io</a></label><ul><li><a href=/zh/docs/technology/Interview/java/io/io-basis/>Java IO 基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/java/io/io-model/>Java IO 模型详解</a></li><li><a href=/zh/docs/technology/Interview/java/io/io-design-patterns/>Java IO 设计模式总结</a></li><li><a href=/zh/docs/technology/Interview/java/io/nio-basis/>Java NIO 核心知识总结</a></li></ul></li><li><input type=checkbox id=section-9ee5b42dd6a7edc6e1c0a1c88bde9426 class=toggle>
<label for=section-9ee5b42dd6a7edc6e1c0a1c88bde9426 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/technology/Interview/java/jvm/memory-area/>Java内存区域详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jdk-monitoring-and-troubleshooting-tools/>JDK监控和故障处理工具总结</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-garbage-collection/>JVM垃圾回收详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-in-action/>JVM线上问题排查和性能调优案例</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-intro/>大白话带你认识 JVM</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/class-loading-process/>类加载过程详解</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/classloader/>类加载器详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/class-file-structure/>类文件结构详解</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-parameters-intro/>最重要的JVM参数总结</a></li></ul></li><li><input type=checkbox id=section-aad47cdb4b5f179b406c6cf1c6282621 class=toggle>
<label for=section-aad47cdb4b5f179b406c6cf1c6282621 class="flex justify-between"><a role=button>New Features</a></label><ul><li><a href=/zh/docs/technology/Interview/java/new-features/java8-tutorial-translate/>Index</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java10/>Java 10 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java11/>Java 11 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java12-13/>Java 12 & 13 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java14-15/>Java 14 & 15 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java16/>Java 16 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java17/>Java 17 新特性概览（重要）</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java18/>Java 18 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java19/>Java 19 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java20/>Java 20 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java21/>Java 21 新特性概览(重要)</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java22-23/>Java 22 & 23 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java9/>Java 9 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java8-common-new-features/>Java8 新特性实战</a></li></ul></li></ul></li><li><input type=checkbox id=section-f77457e1ea013328645923186d400509 class=toggle>
<label for=section-f77457e1ea013328645923186d400509 class="flex justify-between"><a role=button>System Design</a></label><ul><li><input type=checkbox id=section-a9a8bf9713340a4888a6db9d8f8eda42 class=toggle>
<label for=section-a9a8bf9713340a4888a6db9d8f8eda42 class="flex justify-between"><a role=button>Basis</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/basis/RESTfulAPI/>RestFul API 简明教程</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/unit-test/>单元测试到底是什么？应该怎么做？</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/software-engineering/>软件工程简明教程</a></li></ul></li><li><input type=checkbox id=section-3bbccee656befcd0673c7a7ef7393710 class=toggle>
<label for=section-3bbccee656befcd0673c7a7ef7393710 class="flex justify-between"><a role=button>Framework</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/async1/>Async 注解原理分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/Async/>Async 注解原理分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/ioc-and-aop/>IoC & AOP详解（快速搞懂）</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/mybatis/mybatis-interview/>MyBatis常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/netty/>Netty常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/springboot-source-code/>Spring Boot核心源码解读（付费）</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-transaction/>Spring 事务详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-design-patterns-summary/>Spring 中的设计模式详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-common-annotations/>Spring&amp;SpringBoot常用注解总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-boot-auto-assembly-principles/>SpringBoot 自动装配原理详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/springboot-knowledge-and-questions-summary/>SpringBoot常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-knowledge-and-questions-summary/>Spring常见面试题总结</a></li></ul></li><li><input type=checkbox id=section-2baa7507d4a9ede0d38490ad77045e56 class=toggle>
<label for=section-2baa7507d4a9ede0d38490ad77045e56 class="flex justify-between"><a role=button>Security</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/security/jwt-intro/>JWT 基础概念详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/advantages-and-disadvantages-of-jwt/>JWT 身份认证优缺点分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/sso-intro/>SSO 单点登录详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/encryption-algorithms/>常见加密算法总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/basis-of-authority-certification/>认证授权基础概念详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/data-desensitization/>数据脱敏方案总结</a></li></ul></li><li><a href=/zh/docs/technology/Interview/system-design/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/>Index</a></li><li><a href=/zh/docs/technology/Interview/system-design/schedule-task/>Java 定时任务详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/web-real-time-message-push/>Web 实时消息推送详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/design-pattern/>设计模式常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/system-design-questions/>系统设计常见面试题总结(付费)</a></li></ul></li><li><input type=checkbox id=section-b12b3763d379141770d4fa07f12c73ec class=toggle>
<label for=section-b12b3763d379141770d4fa07f12c73ec class="flex justify-between"><a role=button>Tools</a></label><ul><li><input type=checkbox id=section-b6832c2bda30f11dca94b5d9440b112e class=toggle>
<label for=section-b6832c2bda30f11dca94b5d9440b112e class="flex justify-between"><a role=button>Docker</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/docker/docker-intro/>Docker核心概念总结</a></li><li><a href=/zh/docs/technology/Interview/tools/docker/docker-in-action/>Docker实战</a></li></ul></li><li><input type=checkbox id=section-e383b654b47946dea2499bcb3c4bac31 class=toggle>
<label for=section-e383b654b47946dea2499bcb3c4bac31 class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/git/github-tips/>Github实用小技巧总结</a></li><li><a href=/zh/docs/technology/Interview/tools/git/git-intro/>Git核心概念总结</a></li></ul></li><li><input type=checkbox id=section-05546e7a7af454a542b00fa4a34f43a5 class=toggle>
<label for=section-05546e7a7af454a542b00fa4a34f43a5 class="flex justify-between"><a role=button>Gradle</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/gradle/gradle-core-concepts/>Gradle核心概念总结</a></li></ul></li><li><input type=checkbox id=section-139d2af6b95c327fa03497bf63e3a4f4 class=toggle>
<label for=section-139d2af6b95c327fa03497bf63e3a4f4 class="flex justify-between"><a role=button>Maven</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/maven/maven-core-concepts/>Maven核心概念总结</a></li><li><a href=/zh/docs/technology/Interview/tools/maven/maven-best-practices/>Maven最佳实践</a></li></ul></li></ul></li></ul></li><li><a href=/zh/docs/technology/Markdown/_SuperTutorial_/>Markdown超级教程</a></li></ul></li><li class=book-section-flat><a href=/zh/docs/problem/>问题解决</a><ul><li><input type=checkbox id=section-ab4f1dd893a7409a00858148e98c245c class=toggle>
<label for=section-ab4f1dd893a7409a00858148e98c245c class="flex justify-between"><a role=button>Other</a></label><ul><li><a href=/zh/docs/problem/Other/01/>如何搜索</a></li></ul></li><li><input type=checkbox id=section-ef3324c710f7241c89fc009a5f576fbc class=toggle>
<label for=section-ef3324c710f7241c89fc009a5f576fbc class="flex justify-between"><a role=button>Linux</a></label><ul><li><a href=/zh/docs/problem/Linux/20230919/>Linux操作符问题</a></li><li><a href=/zh/docs/problem/Linux/20230819/>Debian问题处理3</a></li><li><a href=/zh/docs/problem/Linux/20230817/>Debian问题处理2</a></li><li><a href=/zh/docs/problem/Linux/20230815/>Debian问题处理1</a></li><li><a href=/zh/docs/problem/Linux/20230803/>安卓手机及平板安装linuxDeploy的问题简记</a></li><li><a href=/zh/docs/problem/Linux/20230523/>zsh卸载后root无法登录及vm扩容centos7报错处理</a></li><li><a href=/zh/docs/problem/Linux/20221101/>post</a></li></ul></li><li><input type=checkbox id=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class=toggle>
<label for=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/problem/JVM/20230526/>JDK代理和CGLIB代理</a></li><li><a href=/zh/docs/problem/JVM/2023052302/>linux中调试open jdk</a></li></ul></li><li><input type=checkbox id=section-a028a45b205904a783d0c60e8a184391 class=toggle>
<label for=section-a028a45b205904a783d0c60e8a184391 class="flex justify-between"><a role=button>Hexo</a></label><ul><li><a href=/zh/docs/problem/Hexo/01/>hexo在线查看pdf</a></li></ul></li><li><input type=checkbox id=section-1c55bf7a5578a7de17cc1ee45681106b class=toggle>
<label for=section-1c55bf7a5578a7de17cc1ee45681106b class="flex justify-between"><a role=button>Idea</a></label><ul><li><a href=/zh/docs/problem/Idea/01/>问题01</a></li></ul></li><li><input type=checkbox id=section-66dd985e53d8e0b78efdab983762411c class=toggle>
<label for=section-66dd985e53d8e0b78efdab983762411c class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/problem/Git/01/>git使用ssh连不上</a></li></ul></li><li><input type=checkbox id=section-9440d21f7eb9f8cf7f45b16969ab18dc class=toggle>
<label for=section-9440d21f7eb9f8cf7f45b16969ab18dc class="flex justify-between"><a role=button>Hugo</a></label><ul><li><a href=/zh/docs/problem/Hugo/p1/>hugo踩坑</a></li><li><a href=/zh/docs/problem/Hugo/01a/>图片测试(hugo踩坑)</a></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/life/>生活</a><ul><li><input type=checkbox id=section-c7f767205668758142bb8053263cc14f class=toggle>
<label for=section-c7f767205668758142bb8053263cc14f class="flex justify-between"><a role=button>往日归档</a></label><ul><li><a href=/zh/docs/life/archive/20231026/>成就</a></li><li><a href=/zh/docs/life/archive/20231013/>沉没</a></li><li><a href=/zh/docs/life/archive/20230913/>鲇鱼后思</a></li><li><a href=/zh/docs/life/archive/20230912/>病愈 有感</a></li><li><a href=/zh/docs/life/archive/20220724/>人为什么要结婚(找对象)</a></li><li><a href=/zh/docs/life/archive/20220416/>《作酒》有感</a></li><li><a href=/zh/docs/life/archive/20121226/>2021年最后一个周日</a></li><li><a href=/zh/docs/life/archive/20231021/>沉沦</a></li></ul></li><li><a href=/zh/docs/life/20250103/>随想</a></li><li><a href=/zh/docs/life/dailyExcerpt/>每日摘抄</a></li><li><a href=/zh/docs/life/20240626/>知命不惧 日日自新</a></li><li><a href=/zh/docs/life/20231227/>起床临感</a></li><li><a href=/zh/docs/life/20231101/>20231101</a></li></ul></li><li class=book-section-flat><span>文化</span><ul><li><input type=checkbox id=section-ab50087f003d55e32dba86fb838050b9 class=toggle>
<label for=section-ab50087f003d55e32dba86fb838050b9 class="flex justify-between"><a role=button>如何阅读一本书</a></label><ul><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E9%99%84%E5%BD%95/>附录</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AE%80%E4%BB%8B-%E5%BA%8F%E8%A8%80/>简介-序言</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%B8%80%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E5%B1%82%E6%AC%A1/>第一篇 阅读的层次</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E5%9B%9B%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E6%9C%80%E7%BB%88%E7%9B%AE%E6%A0%87/>第四篇 阅读的最终目标</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%B8%89%E7%AF%87_%E9%98%85%E8%AF%BB%E4%B8%8D%E5%90%8C%E8%AF%BB%E7%89%A9%E7%9A%84%E6%96%B9%E6%B3%95/>第三篇 阅读不同读物的方法</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%BA%8C%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1_%E5%88%86%E6%9E%90%E9%98%85%E8%AF%BB/>第二篇 阅读的第三个层次：分析阅读</a></li></ul></li><li><input type=checkbox id=section-3c72e7201480f45e35bf243c48374c4a class=toggle>
<label for=section-3c72e7201480f45e35bf243c48374c4a class="flex justify-between"><a role=button>古代天文历法讲座</a></label><ul><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E9%99%84%E5%BD%95-%E9%99%84%E8%A1%A8-%E5%90%8E%E8%AE%B0/>附录-附表-后记</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC6%E8%AE%B2-%E7%AC%AC7%E8%AE%B2/>第6讲-第7讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC4%E8%AE%B2-%E7%AC%AC5%E8%AE%B2/>第4讲-第5讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC1%E8%AE%B2-%E7%AC%AC3%E8%AE%B2/>第1讲-第3讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%89%88%E6%9D%83-%E5%BA%8F-%E5%89%8D%E8%A8%80/>版权-序-前言</a></li></ul></li><li><input type=checkbox id=section-9d5fdf0456d3af9d5079c94a509d2900 class=toggle>
<label for=section-9d5fdf0456d3af9d5079c94a509d2900 class="flex justify-between"><a role=button>置身事内</a></label><ul><li><a href=/zh/docs/culture/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/%E4%B8%8B%E7%AF%87/>下篇</a></li><li><a href=/zh/docs/culture/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/%E4%B8%8A%E7%AF%87/>上篇</a></li></ul></li><li><input type=checkbox id=section-2968790b5f933a15ae8f870afe7ff8b9 class=toggle>
<label for=section-2968790b5f933a15ae8f870afe7ff8b9 class="flex justify-between"><a role=button>中国通史(吕思勉)</a></label><ul><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8B%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%96%87%E5%8C%96%E5%8F%B2/>下编-中国文化史</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8A%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%8F%B2/>上编-中国政治史</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83-%E8%AF%BB%E5%90%8E-%E8%87%AA%E5%BA%8F/>封面-版权-读后-自序</a></li></ul></li><li><input type=checkbox id=section-2caf93f41e261fb08fbc8abd7e4170d5 class=toggle>
<label for=section-2caf93f41e261fb08fbc8abd7e4170d5 class="flex justify-between"><a role=button>论语</a></label><ul><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/01%E5%AD%A6%E5%A4%A9%E7%AC%AC%E4%B8%80/>01学天第一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/02%E4%B8%BA%E6%94%BF%E7%AC%AC%E4%BA%8C/>02为政第二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/03%E5%85%AB%E4%BD%BE%E7%AC%AC%E4%B8%89/>03八佾第三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/04%E9%87%8C%E4%BB%81%E7%AC%AC%E5%9B%9B/>04里仁第四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AC%AC%E4%BA%94/>05公治长第五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/06%E9%9B%8D%E4%B9%9F%E7%AC%AC%E5%85%AD/>06雍也第六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/07%E8%BF%B0%E8%80%8C%E7%AC%AC%E4%B8%83/>07述而第七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/08%E6%B3%B0%E4%BC%AF%E7%AC%AC%E5%85%AB/>08泰伯第八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/09%E5%AD%90%E7%BD%95%E7%AC%AC%E4%B9%9D/>09子罕第九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/10%E4%B9%A1%E5%85%9A%E7%AC%AC%E5%8D%81/>10乡党第十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/11%E5%85%88%E8%BF%9B%E7%AC%AC%E5%8D%81%E4%B8%80/>11先进第十一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/12%E9%A2%9C%E6%B8%8A%E7%AC%AC%E5%8D%81%E4%BA%8C/>12颜渊第十二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/13%E5%AD%90%E8%B7%AF%E7%AC%AC%E5%8D%81%E4%B8%89/>13子路第十三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/14%E5%AE%AA%E9%97%AE%E7%AC%AC%E5%8D%81%E5%9B%9B/>14宪问第十四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AC%AC%E5%8D%81%E4%BA%94/>15卫灵公第十五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/16%E5%AD%A3%E6%B0%8F%E7%AC%AC%E5%8D%81%E5%85%AD/>16季氏第十六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/17%E9%98%B3%E8%B4%A7%E7%AC%AC%E5%8D%81%E4%B8%83/>17阳货第十七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/18%E5%BE%AE%E5%AD%90%E7%AC%AC%E5%8D%81%E5%85%AB/>18微子第十八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/19%E5%AD%90%E5%BC%A0%E7%AC%AC%E5%8D%81%E4%B9%9D/>19子张第十九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/20%E5%B0%A7%E6%97%A5%E7%AC%AC%E4%BA%8C%E5%8D%81/>20尧日第二十</a></li></ul></li><li><input type=checkbox id=section-77e618b9fdc931e63e2343a70dbe6630 class=toggle>
<label for=section-77e618b9fdc931e63e2343a70dbe6630 class="flex justify-between"><a role=button>资治通鉴</a></label><ul><li><input type=checkbox id=section-196ebc38f91a63032ca3483e389aa4c5 class=toggle>
<label for=section-196ebc38f91a63032ca3483e389aa4c5 class="flex justify-between"><a role=button>周纪</a></label><ul><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/>基本知识</a></li><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/001%E5%91%A8%E7%BA%AA%E4%B8%80/>001周纪一</a></li></ul></li></ul></li><li><input type=checkbox id=section-5aa85019131e2605fa7465dc987f590d class=toggle>
<label for=section-5aa85019131e2605fa7465dc987f590d class="flex justify-between"><a role=button>增广贤文</a></label><ul></ul></li><li><input type=checkbox id=section-36af101672fdef38bd3af078cbe1e845 class=toggle>
<label for=section-36af101672fdef38bd3af078cbe1e845 class="flex justify-between"><a role=button>天纪</a></label><ul></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/test/>测试</a><ul><li><a href=/zh/docs/test/mytest/>test</a></li><li><a href=/zh/docs/test/hello2/>pdfTest</a></li></ul></li></ul><ul><li><a href=/zh/posts/>博客</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>_TheLinuxCommandsHandbook_</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#command意义>Command意义</a></li><li><a href=#系统-unix和windows>系统-Unix和Windows</a></li><li><a href=#freesoftware开源>FreeSoftware，开源</a></li><li><a href=#trueunix>TrueUNIX</a></li><li><a href=#shell>shell</a></li><li><a href=#setup-and-installing>setup and installing</a><ul><li><a href=#windowssubsystem>WindowsSubsystem</a></li></ul></li><li><a href=#the-linux-handbook电子书内容>The Linux Handbook(电子书内容)</a><ul><li><a href=#preface>Preface</a></li><li><a href=#introduction-to-linux>Introduction to Linux</a></li><li><a href=#man>man</a></li><li><a href=#ls>ls</a></li><li><a href=#cd>cd</a></li><li><a href=#pwd>pwd</a></li><li><a href=#mkdir>mkdir</a></li><li><a href=#rmdir>rmdir</a></li><li><a href=#mv>mv</a></li><li><a href=#cp>cp</a></li><li><a href=#open>open</a></li><li><a href=#touch>touch</a></li><li><a href=#find>find</a></li><li><a href=#ln>ln</a></li><li><a href=#gzip>gzip</a></li><li><a href=#gunzip>gunzip</a></li><li><a href=#tar>tar</a></li><li><a href=#alias>alias</a></li><li><a href=#cat>cat</a></li><li><a href=#less>less</a></li><li><a href=#tail>tail</a></li><li><a href=#wc>wc</a></li><li><a href=#grep>grep</a></li><li><a href=#sort>sort</a></li><li><a href=#uniq>uniq</a></li><li><a href=#diff>diff</a></li><li><a href=#echo>echo</a></li><li><a href=#chown>chown</a></li><li><a href=#chmod>chmod</a></li><li><a href=#umask>umask</a></li><li><a href=#du>du</a></li><li><a href=#df>df</a></li><li><a href=#basename>basename</a></li><li><a href=#dirname>dirname</a></li><li><a href=#ps>ps</a></li><li><a href=#top>top</a></li><li><a href=#kill>kill</a></li><li><a href=#killall>killall</a></li><li><a href=#jobs>jobs</a></li><li><a href=#bg>bg</a></li><li><a href=#fg>fg</a></li><li><a href=#type>type</a></li><li><a href=#which>which</a></li><li><a href=#nohup>nohup</a></li><li><a href=#xargs>xargs</a></li><li><a href=#vim>vim</a></li><li><a href=#emacs>emacs</a></li><li><a href=#nano>nano</a></li><li><a href=#whoami>whoami</a></li><li><a href=#who>who</a></li><li><a href=#su>su</a></li><li><a href=#sudo>sudo</a></li><li><a href=#passwd>passwd</a></li><li><a href=#ping>ping</a></li><li><a href=#traceroute>traceroute</a></li><li><a href=#clear>clear</a></li><li><a href=#history>history</a></li><li><a href=#export>export</a></li><li><a href=#crontab>crontab</a></li><li><a href=#uname>uname</a></li><li><a href=#env>env</a></li><li><a href=#printenv>printenv</a></li><li><a href=#conclusion>Conclusion</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><blockquote><p>《TheLinuxCommandsHandbook》结合视频 <a href="https://www.youtube.com/watch?v=ZtqBQ68cfJc">https://www.youtube.com/watch?v=ZtqBQ68cfJc</a> 看的</p></blockquote><h1 id=command意义>Command意义
<a class=anchor href=#command%e6%84%8f%e4%b9%89>#</a></h1><p>更快，自动化，在任何Linux上工作，有些工作的基本需求</p><h1 id=系统-unix和windows>系统-Unix和Windows
<a class=anchor href=#%e7%b3%bb%e7%bb%9f-unix%e5%92%8cwindows>#</a></h1><p>绿色-开源<br>红色-闭源<br>黄色-混合<br><img src=img/ly-20241226190213859.png alt></p><p>图片中的Linux只是类Unix，而不是真正的Unix</p><h1 id=freesoftware开源>FreeSoftware，开源
<a class=anchor href=#freesoftware%e5%bc%80%e6%ba%90>#</a></h1><p>GNU与Linux</p><blockquote><p>Linux只是一个<strong>操作系统内核</strong>而已，而GNU提供了大量的自由软件来丰富在其之上各种应用程序。<br>绝大多数基于Linux内核的操作系统使用了大量的<strong>GNU软件</strong>，包括了一个shell程序、工具、程序库、编译器及工具，还有许多其他程序<br><strong>我们常说的Linux，准确地来讲，应该是叫“GNU/Linux”</strong>。虽然，我们没有为GNU和Linux的开发做出什么贡献，但是我们可以为GNU和Linux的宣传和应用做出微薄的努力，至少我们能够准确地去向其他人解释清楚GNU、Linux以及GNU/Linux之间的区别。让我们一起为GNU/Linux的推广贡献出自己的力量！</p></blockquote><p>内核，用来连接硬件和软件的</p><h1 id=trueunix>TrueUNIX
<a class=anchor href=#trueunix>#</a></h1><p>Unix一开始是收费的，后面出现Unix-like（类Unix），和Unix标准兼容。<br>Linux不是真正的Unix，而是类Unix。<br>Linux本身只是一个内核，连接<strong>硬件</strong>和<strong>软件</strong><br>LinuxDistributions，Linux发行版(1000多种)<br>Linux内核是一些GUN工具，文档，包管理器，桌面环境窗口管理，和系统一些其他东西组成的一个系统<br><img src=img/ly-20241226190213859.png alt></p><p>有开源的和不开源的，Linux(LinuxGUN)完全开源</p><h1 id=shell>shell
<a class=anchor href=#shell>#</a></h1><p>windows（powershell）<br>把<strong>命令</strong>交给系统<br>terminal（最古老时是一个硬件）&ndash;屏幕+带键盘的物理设备，如今是一个软件<br>默认情况下，<strong>Ubuntu和大多数Linux发行版</strong>是<strong>bashshell</strong>，还有zsh</p><h1 id=setup-and-installing>setup and installing
<a class=anchor href=#setup-and-installing>#</a></h1><p>如果有Mac或者其他Linux发行版，则不需要额外操作。（作者在Mac里装了Ubuntu虚拟机）</p><h2 id=windowssubsystem>WindowsSubsystem
<a class=anchor href=#windowssubsystem>#</a></h2><p><code>wsl --install</code><br>默认是Ubuntu</p><h1 id=the-linux-handbook电子书内容>The Linux Handbook(电子书内容)
<a class=anchor href=#the-linux-handbook%e7%94%b5%e5%ad%90%e4%b9%a6%e5%86%85%e5%ae%b9>#</a></h1><p><strong>Linux 手册</strong></p><h2 id=preface>Preface
<a class=anchor href=#preface>#</a></h2><p><strong>前言</strong></p><p>The Linux Handbook follows the 80/20 rule: learn in 20% of the time the 80% of a topic.<br>Linux 手册遵循 80/20 规则：用 20% 的时间学习某个主题的 80%。</p><p>In particular, the goal is to get you up to speed quickly with Linux.<br>具体来说，我们的目标是让您快速熟悉 Linux。</p><p>This book is written by Flavio. I <strong>publish programming tutorials</strong> on my blog <a href=https://flaviocopes.com>flaviocopes.com</a> and I organize a yearly bootcamp at <a href=https://bootcamp.dev>bootcamp.dev</a>.<br>这本书的作者是弗拉维奥。我在博客<a href=https://flaviocopes.com>flaviocopes.com</a>上<strong>发布编程教程</strong>，并在<a href=https://bootcamp.dev>bootcamp.dev</a>组织年度训练营。</p><p>You can reach me on Twitter <a href=https://twitter.com/flaviocopes>@flaviocopes</a>.<br>您可以通过 Twitter <a href=https://twitter.com/flaviocopes>@flaviocopes</a>联系我。</p><p>Enjoy!<br>享受！</p><h2 id=introduction-to-linux>Introduction to Linux
<a class=anchor href=#introduction-to-linux>#</a></h2><p><strong>Linux简介</strong></p><p>Linux is an operating system, like macOS or Windows.<br>Linux 是一个操作系统，就像 macOS 或 Windows 一样。</p><p>It is also the most popular Open Source and free, as in freedom, operating system.<br>它也是最流行的开源和免费操作系统。</p><p>It powers the vast majority of the servers that compose the Internet. It&rsquo;s the base upon which everything is built upon. But not just that. Android is based on
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>m</mi><mi>o</mi><mi>d</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>e</mi><mi>d</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>o</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">a modified version of</annotation></semantics></math></span>
Linux.<br>它为组成互联网的绝大多数服务器提供动力。它是一切事物建立的基础。但不仅如此。 Android 基于 Linux（的修改版本）。</p><p>The Linux &ldquo;core&rdquo;
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>d</mi><mo>∗</mo><mi>k</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">called *kernel*</annotation></semantics></math></span>
was born in 1991 in Finland, and it went a really long way from its humble beginnings. It went on to be the kernel of the GNU Operating System, creating the duo GNU/Linux.<br>Linux“核心”（称为<em>kernel</em> ）于 1991 年在芬兰诞生，从最初的卑微开始，它已经走过了漫长的道路。它后来成为 GNU 操作系统的内核，创造了 GNU/Linux 双核。</p><p>There&rsquo;s one thing about Linux that corporations like Microsoft and Apple, or Google, will never be able to offer: the freedom to do whatever you want with your computer.<br>Linux 有一点是 Microsoft、Apple 或 Google 等公司永远无法提供的：用计算机做任何你想做的事情的自由。</p><p>They&rsquo;re actually going in the opposite direction, building walled gardens, especially on the mobile side.<br>他们实际上正在朝相反的方向前进，建造围墙花园，尤其是在移动端。</p><p>Linux is the ultimate freedom.<br>Linux 是终极的自由。</p><p>It is developed by volunteers, some paid by companies that rely on it, some independently, but there&rsquo;s no single commercial company that can dictate what goes into Linux, or the project priorities.<br>它是由志愿者开发的，有些是由依赖它的公司付费的，有些是独立开发的，但没有任何一家商业公司可以决定 Linux 的内容或项目的优先级。</p><p>Linux can also be used as your day to day computer. I use macOS because I really enjoy the applications, the design and I also used to be an iOS and Mac apps developer, but before using it I used Linux as my main computer Operating System.<br>Linux 也可以用作您的日常计算机。我使用 macOS 是因为我真的很喜欢它的应用程序和设计，而且我也曾经是一名 iOS 和 Mac 应用程序开发人员，但在使用它之前我使用 Linux 作为我的主要计算机操作系统。</p><p>No one can dictate which apps you can run, or &ldquo;call home&rdquo; with apps that track you, your position, and more.<br>没有人可以规定您可以运行哪些应用程序，或者使用跟踪您、您的位置等的应用程序“打电话回家”。</p><p>Linux is also special because there&rsquo;s not just &ldquo;one Linux&rdquo;, like it happens on Windows or macOS. Instead, we have <strong>distributions</strong>.<br>Linux 也很特别，因为它不像 Windows 或 macOS 那样只有“一个 Linux”。相反，我们有<strong>发行版</strong>。</p><p>A &ldquo;distro&rdquo; is made by a company or organization and packages the Linux core with additional programs and tooling.<br>“发行版”由公司或组织制作，并将 Linux 核心与附加程序和工具打包在一起。</p><p>For example you have Debian, Red Hat, and Ubuntu, probably the most popular.<br>例如，您有 Debian、Red Hat 和 Ubuntu，它们可能是最受欢迎的。</p><p>Many, many more exist. You can create your own distribution, too. But most likely you&rsquo;ll use a popular one, one that has lots of users and a community of people around it, so you can do what you need to do without losing too much time reinventing the wheel and figuring out answers to common problems.<br>还存在很多很多。您也可以创建自己的发行版。但您很可能会使用一种流行的产品，它拥有大量用户和周围的人员社区，因此您可以做您需要做的事情，而不会浪费太多时间重新发明轮子并找出常见问题的答案。</p><p>Some desktop computers and laptops ship with Linux preinstalled. Or you can install it on your Windows-based computer, or on a Mac.<br>一些台式计算机和笔记本电脑预装了 Linux。或者您可以将其安装在基于 Windows 的计算机或 Mac 上。</p><p>But you don&rsquo;t need to disrupt your existing computer just to get an idea of how Linux works.<br>但您不需要仅仅为了了解 Linux 的工作原理而破坏现有的计算机。</p><p>I don&rsquo;t have a Linux computer.<br>我没有 Linux 计算机。</p><p>If you use a Mac you need to know that under the hood macOS is a UNIX Operating System, and it shares a lot of the same ideas and software that a GNU/Linux system uses, because GNU/Linux is a free alternative to UNIX.<br>如果您使用 Mac，您需要知道 macOS 在本质上是一个 UNIX 操作系统，它与 GNU/Linux 系统使用许多相同的想法和软件，因为 GNU/Linux 是 UNIX 的免费替代品。</p><blockquote><p><a href=https://en.wikipedia.org/wiki/Unix>UNIX</a> is an umbrella term that groups many operating systems used in big corporations and institutions, starting from the 70&rsquo;s<br><a href=https://en.wikipedia.org/wiki/Unix>UNIX</a>是一个涵盖性术语，涵盖了从 70 年代开始在大公司和机构中使用的许多操作系统</p></blockquote><p>The macOS terminal gives you access to the same exact commands I&rsquo;ll describe in the rest of this handbook.<br>macOS 终端使您可以访问我将在本手册的其余部分中描述的相同命令。</p><p>Microsoft has an official <a href=https://docs.microsoft.com/en-us/windows/wsl/install-win10>Windows Subsystem for Linux</a> which you can
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>d</mi><mi>s</mi><mi>h</mi><mi>o</mi><mi>u</mi><mi>l</mi><mi>d</mi><mtext> ⁣</mtext></mrow><annotation encoding="application/x-tex">and should\!</annotation></semantics></math></span>
install on Windows. This will give you the ability to run Linux in a very easy way on your PC.<br>Microsoft 有一个<a href=https://docs.microsoft.com/en-us/windows/wsl/install-win10>适用于 Linux 的官方 Windows 子系统</a>，您可以（并且应该！）将其安装在 Windows 上。这将使您能够在 PC 上以非常简单的方式运行 Linux。</p><p>But the vast majority of the time you will run a Linux computer in the cloud via a VPS
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>i</mi><mi>r</mi><mi>t</mi><mi>u</mi><mi>a</mi><mi>l</mi><mi>P</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>S</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">Virtual Private Server</annotation></semantics></math></span>
like DigitalOcean.<br>但绝大多数时候，您将通过 DigitalOcean 等 VPS（虚拟专用服务器）在云中运行 Linux 计算机。</p><p>A shell is a command interpreter that exposes to the user an interface to work with the underlying operating system.<br>shell 是一个命令解释器，它向用户公开一个与底层操作系统一起工作的界面。</p><p>It allows you to execute operations using text and commands, and it provides users advanced features like being able to create scripts.<br>它允许您使用文本和命令执行操作，并为用户提供高级功能，例如能够创建脚本。</p><p>This is important: shells let you perform things in a more optimized way than a GUI
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>r</mi><mi>a</mi><mi>p</mi><mi>h</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>U</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>f</mi><mi>a</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Graphical User Interface</annotation></semantics></math></span>
could ever possibly let you do. Command line tools can offer many different configuration options without being too complex to use.<br>这很重要：shell 可以让您以比 GUI（图形用户界面）更优化的方式执行操作。命令行工具可以提供许多不同的配置选项，而且不会太复杂而无法使用。</p><p>There are many different kind of shells. This post focuses on Unix shells, the ones that you will find commonly on Linux and macOS computers.<br>有许多不同种类的贝壳。本文重点介绍 Unix shell，即 Linux 和 macOS 计算机上常见的 shell。</p><p>Many different kind of shells were created for those systems over time, and a few of them dominate the space: Bash, Csh, Zsh, Fish and many more!<br>随着时间的推移，为这些系统创建了许多不同类型的 shell，其中一些占据了主导地位：Bash、Csh、Zsh、Fish 等等！</p><p>All shells originate from the Bourne Shell, called <code>sh</code>. &ldquo;Bourne&rdquo; because its creator was Steve Bourne.<br>所有 shell 都源自 Bourne Shell，称为<code>sh</code> 。 “伯恩”是因为它的创造者是史蒂夫·伯恩。</p><p>Bash means <em>Bourne-again shell</em>. <code>sh</code> was proprietary and not open source, and Bash was created in 1989 to create a free alternative for the GNU project and the Free Software Foundation. Since projects had to pay to use the Bourne shell, Bash became very popular.<br>Bash 的意思是<em>Bourne-again shell</em> 。 <code>sh</code>是专有的而不是开源的，Bash 于 1989 年创建，旨在为 GNU 项目和自由软件基金会创建免费的替代方案。由于项目必须付费才能使用 Bourne shell，因此 Bash 变得非常流行。</p><p>If you use a Mac, try opening your Mac terminal. That by default is running ZSH.
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>r</mi><mo separator="true">,</mo><mi>p</mi><mi>r</mi><mi>e</mi><mo>−</mo><mi>C</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>a</mi><mo separator="true">,</mo><mi>B</mi><mi>a</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">or, pre-Catalina, Bash</annotation></semantics></math></span><br>如果您使用 Mac，请尝试打开 Mac 终端。默认情况下运行的是 ZSH。 （或者，Catalina 之前的 Bash）</p><p>You can set up your system to run any kind of shell, for example I use the Fish shell.<br>您可以将系统设置为运行任何类型的 shell，例如我使用 Fish shell。</p><p>Each single shell has its own unique features and advanced usage, but they all share a common functionality: they can let you execute programs, and they can be programmed.<br>每个 shell 都有自己独特的功能和高级用法，但它们都有一个共同的功能：它们可以让您执行程序，并且可以进行编程。</p><p>In the rest of this handbook we&rsquo;ll see in detail the most common commands you will use.<br>在本手册的其余部分，我们将详细介绍您将使用的最常用命令。</p><h2 id=man>man
<a class=anchor href=#man>#</a></h2><p>The first command I want to introduce is a command that will help you understand all the other commands.<br>我想介绍的第一个命令将帮助您理解所有其他命令。</p><p>Every time I don&rsquo;t know how to use a command, I type <code>man &lt;command></code> to get the manual:<br>每次我不知道如何使用命令时，我都会输入<code>man &lt;command></code>来获取手册：</p><p><img src=img/000001.png alt></p><p>This is a man
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi><mo>∗</mo><mi>m</mi><mi>a</mi><mi>n</mi><mi>u</mi><mi>a</mi><mi>l</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">from *manual*</annotation></semantics></math></span>
page. Man pages are an essential tool to learn, as a developer. They contain so much information that sometimes it&rsquo;s almost too much.<br>这是一个 man（来自<em>手册</em>）页面。手册页是开发人员学习的重要工具。它们包含太多信息，有时几乎太多了。</p><p>The above screenshot is just 1 of 14 screens of explanation for the <code>ls</code> command.<br>上面的屏幕截图只是<code>ls</code>命令解释的 14 个屏幕之一。</p><p>Most of the times when I&rsquo;m in need to learn a command quickly I use this site called <strong>tldr pages</strong>: <a href=https://tldr.sh/>https://tldr.sh/</a>. It&rsquo;s a command you can install, then you run it like this: <code>tldr &lt;command></code>, which gives you a very quick overview of a command, with some handy examples of common usage scenarios:<br>大多数时候，当我需要快速学习命令时，我会使用这个名为<strong>tldr 页面</strong>的网站： <a href=https://tldr.sh/>https://tldr.sh/</a> 。这是一个可以安装的命令，然后像这样运行它： <code>tldr &lt;command></code> ，它可以让您快速了解命令，并提供一些常见使用场景的方便示例：</p><p><img src=img/000055.png alt></p><p>This is not a substitute for <code>man</code>, but a handy tool to avoid losing yourself in the huge amount of information present in a man page. Then you can use the man page to explore all the different options and parameters you can use on a command.<br>这并不是<code>man</code>的替代品，而是一个方便的工具，可以避免在手册页中的大量信息中迷失方向。然后，您可以使用手册页来探索可在命令上使用的所有不同选项和参数。</p><h2 id=ls>ls
<a class=anchor href=#ls>#</a></h2><p>Inside a folder you can list all the files that the folder contains using the <code>ls</code> command:<br>在文件夹内，您可以使用<code>ls</code>命令列出该文件夹包含的所有文件：</p><pre><code>ls
</code></pre><p>If you add a folder name or path, it will print that folder contents:<br>如果您添加文件夹名称或路径，它将打印该文件夹内容：</p><pre><code>ls /bin
</code></pre><p><img src=img/000110.png alt></p><p><code>ls</code> accepts a lot of options. One of my favorite options combinations is <code>-al</code>. Try it:<br><code>ls</code>接受很多选项。我最喜欢的选项组合之一是<code>-al</code> 。尝试一下：</p><pre><code>ls -al /bin
</code></pre><p><img src=img/000109.png alt></p><p>compared to the plain <code>ls</code>, this returns much more information.<br>与普通的<code>ls</code>相比，这会返回更多信息。</p><p>You have, from left to right:<br>你有，从左到右：</p><ul><li>the file permissions
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>f</mi><mi>y</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>y</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>s</mi><mi>u</mi><mi>p</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>s</mi><mi>A</mi><mi>C</mi><mi>L</mi><mi>s</mi><mo separator="true">,</mo><mi>y</mi><mi>o</mi><mi>u</mi><mi>g</mi><mi>e</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>A</mi><mi>C</mi><mi>L</mi><mi>f</mi><mi>l</mi><mi>a</mi><mi>g</mi><mi>a</mi><mi>s</mi><mi>w</mi><mi>e</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">and if your system supports ACLs, you get an ACL flag as well</annotation></semantics></math></span><br>文件权限（如果您的系统支持 ACL，您也会获得 ACL 标志）</li><li>the number of links to that file<br>该文件的链接数</li><li>the owner of the file<br>文件的所有者</li><li>the group of the file<br>文件组</li><li>the file size in bytes<br>文件大小（以字节为单位）</li><li>the file modified datetime<br>文件修改日期时间</li><li>the file name<br>文件名</li></ul><p>This set of data is generated by the <code>l</code> option. The <code>a</code> option instead also shows the hidden files.<br>这组数据是由<code>l</code>选项生成的。 <code>a</code>选项还显示隐藏文件。</p><p>Hidden files are files that start with a dot
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`.`</annotation></semantics></math></span>
.<br>隐藏文件是以点
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex"> `.` </annotation></semantics></math></span>
开头的文件。</p><h2 id=cd>cd
<a class=anchor href=#cd>#</a></h2><p>Once you have a folder, you can move into it using the <code>cd</code> command. <code>cd</code> means <strong>c</strong>hange <strong>d</strong>irectory. You invoke it specifying a folder to move into. You can specify a folder name, or an entire path.<br>有了文件夹后，您可以使用<code>cd</code>命令进入该文件夹。 <code>cd</code>表示<strong>更改****目录</strong>。您可以调用它并指定要移入的文件夹。您可以指定文件夹名称或整个路径。</p><p>Example:<br>例子：</p><pre><code>mkdir fruits    cd     fruits
</code></pre><p>Now you are into the <code>fruits</code> folder.<br>现在您已进入<code>fruits</code>文件夹。</p><p>You can use the <code>..</code> special path to indicate the parent folder:<br>您可以使用<code>..</code>特殊路径来指示父文件夹：</p><pre><code>cd     ..     #back to the home folder    
</code></pre><p>The # character indicates the start of the comment, which lasts for the entire line after it&rsquo;s found.<br># 字符表示注释的开始，它在找到后持续整行。</p><p>You can use it to form a path:<br>您可以使用它来形成路径：</p><pre><code>mkdir fruits
mkdir cars    cd     fruits    cd     ../cars
</code></pre><p>There is another special path indicator which is <code>.</code>, and indicates the <strong>current</strong> folder.<br>还有另一个特殊的路径指示器是<code>.</code> ，并表示<strong>当前</strong>文件夹。</p><p>You can also use absolute paths, which start from the root folder <code>/</code>:<br>您还可以使用绝对路径，从根文件夹<code>/</code>开始：</p><pre><code>cd     /etc
</code></pre><blockquote><p>This command works on Linux, macOS, WSL, and anywhere you have a UNIX environment<br>此命令适用于 Linux、macOS、WSL 以及任何拥有 UNIX 环境的地方</p></blockquote><h2 id=pwd>pwd
<a class=anchor href=#pwd>#</a></h2><p>Whenever you feel lost in the filesystem, call the <code>pwd</code> command to know where you are:<br>每当您在文件系统中感到迷失时，请调用<code>pwd</code>命令来了解您所在的位置：</p><pre><code>pwd    
</code></pre><p>It will print the current folder path.<br>它将打印当前文件夹路径。</p><h2 id=mkdir>mkdir
<a class=anchor href=#mkdir>#</a></h2><p>You create folders using the <code>mkdir</code> command:<br>您可以使用<code>mkdir</code>命令创建文件夹：</p><pre><code>mkdir fruits
</code></pre><p>You can create multiple folders with one command:<br>您可以使用一个命令创建多个文件夹：</p><pre><code>mkdir dogs cars
</code></pre><p>You can also create multiple nested folders by adding the <code>-p</code> option:<br>您还可以通过添加<code>-p</code>选项来创建多个嵌套文件夹：</p><pre><code>mkdir -p fruits/apples
</code></pre><p>Options in UNIX commands commonly take this form. You add them right after the command name, and they change how the command behaves. You can often combine multiple options, too.<br>UNIX 命令中的选项通常采用这种形式。您可以将它们添加到命令名称之后，它们会更改命令的行为方式。您通常也可以组合多个选项。</p><p>You can find which options a command supports by typing <code>man &lt;commandname></code>. Try now with <code>man mkdir</code> for example
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi mathvariant="normal">‘</mi><mi>q</mi><mi mathvariant="normal">‘</mi><mi>k</mi><mi>e</mi><mi>y</mi><mi>t</mi><mi>o</mi><mi>e</mi><mi>s</mi><mi>c</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>m</mi><mi>a</mi><mi>n</mi><mi>p</mi><mi>a</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">press the `q` key to esc the man page</annotation></semantics></math></span>
. Man pages are the amazing built-in help for UNIX.<br>您可以通过键入<code>man &lt;commandname></code>来查找命令支持哪些选项。例如，现在尝试使用<code>man mkdir</code> （按<code>q</code>键退出手册页）。手册页是 UNIX 令人惊叹的内置帮助。</p><h2 id=rmdir>rmdir
<a class=anchor href=#rmdir>#</a></h2><p>Just as you can create a folder using <code>mkdir</code>, you can delete a folder using <code>rmdir</code>:<br>正如您可以使用<code>mkdir</code>创建文件夹一样，您可以使用<code>rmdir</code>删除文件夹：</p><pre><code>mkdir fruits
rmdir fruits
</code></pre><p>You can also delete multiple folders at once:<br>您还可以一次删除多个文件夹：</p><pre><code>mkdir fruits cars
rmdir fruits cars
</code></pre><p>The folder you delete must be empty.<br>您删除的文件夹必须是空的。</p><p>To delete folders with files in them, we&rsquo;ll use the more generic <code>rm</code> command which deletes files and folders, using the <code>-rf</code> options:<br>要删除其中包含文件的文件夹，我们将使用更通用的<code>rm</code>命令来删除文件和文件夹，并使用<code>-rf</code>选项：</p><pre><code>rm -rf fruits cars
</code></pre><p>Be careful as this command does not ask for confirmation and it will immediately remove anything you ask it to remove.<br>请小心，因为此命令不会要求确认，并且它会立即删除您要求其删除的任何内容。</p><p>There is no <strong>bin</strong> when removing files from the command line, and recovering lost files can be hard.<br>从命令行删除文件时没有<strong>bin</strong> ，并且恢复丢失的文件可能很困难。</p><h2 id=mv>mv
<a class=anchor href=#mv>#</a></h2><p>Once you have a file, you can move it around using the <code>mv</code> command. You specify the file current path, and its new path:<br>一旦有了文件，就可以使用<code>mv</code>命令移动它。您指定文件的当前路径及其新路径：</p><pre><code>touch pear
mv pear new_pear
</code></pre><p>The <code>pear</code> file is now moved to <code>new_pear</code>. This is how you <strong>rename</strong> files and folders.<br><code>pear</code>文件现在已移至<code>new_pear</code> 。这就是<strong>重命名</strong>文件和文件夹的方法。</p><p>If the last parameter is a folder, the file located at the first parameter path is going to be moved into that folder. In this case, you can specify a list of files and they will all be moved in the folder path identified by the last parameter:<br>如果最后一个参数是文件夹，则位于第一个参数路径的文件将被移动到该文件夹​​中。在这种情况下，您可以指定文件列表，它们将全部移动到最后一个参数标识的文件夹路径中：</p><pre><code>touch pear
touch apple
mkdir fruits
mv pear apple fruits     #pear and apple moved to the fruits folder    
</code></pre><h2 id=cp>cp
<a class=anchor href=#cp>#</a></h2><p>You can copy a file using the <code>cp</code> command:<br>您可以使用<code>cp</code>命令复制文件：</p><pre><code>touch     test    
cp apple another_apple
</code></pre><p>To copy folders you need to add the <code>-r</code> option to recursively copy the whole folder contents:<br>要复制文件夹，您需要添加<code>-r</code>选项以递归复制整个文件夹内容：</p><pre><code>mkdir fruits
cp -r fruits cars
</code></pre><h2 id=open>open
<a class=anchor href=#open>#</a></h2><p>The <code>open</code> command lets you open a file using this syntax:<br><code>open</code>命令允许您使用以下语法打开文件：</p><pre><code>open &lt;filename&gt;
</code></pre><p>You can also open a directory, which on macOS opens the Finder app with the current directory open:<br>您还可以打开一个目录，在 macOS 上，该目录会打开 Finder 应用程序并打开当前目录：</p><pre><code>open &lt;directory name&gt;
</code></pre><p>I use it all the time to open the current directory:<br>我一直用它来打开当前目录：</p><pre><code>open .
</code></pre><blockquote><p>The special <code>.</code> symbol points to the current directory, as <code>..</code> points to the parent directory<br>特别的<code>.</code>符号指向当前目录，as <code>..</code>指向父目录</p></blockquote><p>The same command can also be be used to run an application:<br>相同的命令也可用于运行应用程序：</p><pre><code>open &lt;application name&gt;
</code></pre><h2 id=touch>touch
<a class=anchor href=#touch>#</a></h2><p>You can create an empty file using the <code>touch</code> command:<br>您可以使用<code>touch</code>命令创建一个空文件：</p><pre><code>touch apple
</code></pre><p>If the file already exists, it opens the file in write mode, and the timestamp of the file is updated.<br>如果文件已存在，则以写入模式打开文件，并更新文件的时间戳。</p><h2 id=find>find
<a class=anchor href=#find>#</a></h2><p>The <code>find</code> command can be used to find files or folders matching a particular search pattern. It searches recursively.<br><code>find</code>命令可用于查找与特定搜索模式匹配的文件或文件夹。它递归地搜索。</p><p>Let&rsquo;s learn it by example.<br>让我们通过例子来学习一下。</p><p>Find all the files under the current tree that have the <code>.js</code> extension and print the relative path of each file matching:<br>查找当前树下所有具有<code>.js</code>扩展名的文件，并打印每个匹配文件的相对路径：</p><pre><code>find . -name     '*.js'    
</code></pre><p>It&rsquo;s important to use quotes around special characters like <code>*</code> to avoid the shell interpreting them.<br>在<code>*</code>等特殊字符周围使用引号很重要，以避免 shell 解释它们。</p><p>Find directories under the current tree matching the name &ldquo;src&rdquo;:<br>在当前树下查找与名称“src”匹配的目录：</p><pre><code>find . -    type     d -name src
</code></pre><p>Use <code>-type f</code> to search only files, or <code>-type l</code> to only search symbolic links.<br>使用<code>-type f</code>仅搜索文件，或使用<code>-type l</code>仅搜索符号链接。</p><p><code>-name</code> is case sensitive. use <code>-iname</code> to perform a case-insensitive search.<br><code>-name</code>区分大小写。使用<code>-iname</code>执行不区分大小写的搜索。</p><p>You can search under multiple root trees:<br>您可以在多个根树下搜索：</p><pre><code>find folder1 folder2 -name filename.txt
</code></pre><p>Find directories under the current tree matching the name &ldquo;node_modules&rdquo; or &lsquo;public&rsquo;:<br>在当前树下查找与名称“node_modules”或“public”匹配的目录：</p><pre><code>find . -    type     d -name node_modules -or -name public
</code></pre><p>You can also exclude a path, using <code>-not -path</code>:<br>您还可以使用<code>-not -path</code>排除路径：</p><pre><code>find . -    type     d -name     '*.md'     -not -path     'node_modules/*'    
</code></pre><p>You can search files that have more than 100 characters
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">bytes</annotation></semantics></math></span>
in them:<br>您可以搜索包含超过 100 个字符（字节）的文件：</p><pre><code>find . -    type     f -size +100c
</code></pre><p>Search files bigger than 100KB but smaller than 1MB:<br>搜索大于 100KB 但小于 1MB 的文件：</p><pre><code>find . -    type     f -size +100k -size -1M
</code></pre><p>Search files edited more than 3 days ago<br>搜索 3 天前编辑的文件</p><pre><code>find . -    type     f -mtime +3
</code></pre><p>Search files edited in the last 24 hours<br>搜索过去 24 小时内编辑的文件</p><pre><code>find . -    type     f -mtime -1
</code></pre><p>You can delete all the files matching a search by adding the <code>-delete</code> option. This deletes all the files edited in the last 24 hours:<br>您可以通过添加<code>-delete</code>选项来删除与搜索匹配的所有文件。这将删除过去 24 小时内编辑的所有文件：</p><pre><code>find . -    type     f -mtime -1 -delete
</code></pre><p>You can execute a command on each result of the search. In this example we run <code>cat</code> to print the file content:<br>您可以对每个搜索结果执行命令。在此示例中，我们运行<code>cat</code>来打印文件内容：</p><pre><code>find . -    type     f -    exec     cat {} \;
</code></pre><p>notice the terminating <code>\;</code>. <code>{}</code> is filled with the file name at execution time.<br>注意终止<code>\;</code> 。 <code>{}</code>填充执行时的文件名。</p><h2 id=ln>ln
<a class=anchor href=#ln>#</a></h2><p>The <code>ln</code> command is part of the Linux file system commands.<br><code>ln</code>命令是 Linux 文件系统命令的一部分。</p><p>It&rsquo;s used to create links. What is a link? It&rsquo;s like a pointer to another file. A file that points to another file. You might be familiar with Windows shortcuts. They&rsquo;re similar.<br>它用于创建链接。什么是链接？它就像一个指向另一个文件的指针。一个文件指向另一个文件。您可能熟悉 Windows 快捷方式。他们很相似。</p><p>We have 2 types of links: <strong>hard links</strong> and <strong>soft links</strong>.<br>我们有两种类型的链接：<strong>硬链接</strong>和<strong>软链接</strong>。</p><p>Hard links are rarely used. They have a few limitations: you can&rsquo;t link to directories, and you can&rsquo;t link to external filesystems
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>k</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">disks</annotation></semantics></math></span>
.<br>硬链接很少使用。它们有一些限制：您不能链接到目录，也不能链接到外部文件系统（磁盘）。</p><p>A hard link is created using<br>使用以下命令创建硬链接</p><pre><code>ln &lt;original&gt; &lt;link&gt;
</code></pre><p>For example, say you have a file called recipes.txt. You can create a hard link to it using:<br>例如，假设您有一个名为recipes.txt 的文件。您可以使用以下方法创建指向它的硬链接：</p><pre><code>ln recipes.txt newrecipes.txt
</code></pre><p>The new hard link you created is indistinguishable from a regular file:<br>您创建的新硬链接与常规文件没有区别：</p><p><img src=img/000003.png alt></p><p>Now any time you edit any of those files, the content will be updated for both.<br>现在，每当您编辑这些文件中的任何一个时，这两个文件的内容都会更新。</p><p>If you delete the original file, the link will still contain the original file content, as that&rsquo;s not removed until there is one hard link pointing to it.<br>如果您删除原始文件，该链接仍将包含原始文件内容，因为只有在有一个硬链接指向它时，该链接才会被删除。</p><p><img src=img/000002.png alt></p><p>Soft links are different. They are more powerful as you can link to other filesystems and to directories, but when the original is removed, the link will be broken.<br>软链接则不同。它们更强大，因为您可以链接到其他文件系统和目录，但是当删除原始文件系统和目录时，链接将被破坏。</p><p>You create soft links using the <code>-s</code> option of <code>ln</code>:<br>您可以使用<code>ln</code>的<code>-s</code>选项创建软链接：</p><pre><code>ln -s &lt;original&gt; &lt;link&gt;
</code></pre><p>For example, say you have a file called recipes.txt. You can create a soft link to it using:<br>例如，假设您有一个名为recipes.txt 的文件。您可以使用以下方法创建指向它的软链接：</p><pre><code>ln -s recipes.txt newrecipes.txt
</code></pre><p>In this case you can see there&rsquo;s a special <code>l</code> flag when you list the file using <code>ls -al</code>, and the file name has a <code>@</code> at the end, and it&rsquo;s colored differently if you have colors enabled:<br>在这种情况下，当您使用<code>ls -al</code>列出文件时，您可以看到有一个特殊的<code>l</code>标志，并且文件名末尾有一个<code>@</code> ，如果启用了颜色，则其颜色会有所不同：</p><p><img src=img/000005.png alt></p><p>Now if you delete the original file, the links will be broken, and the shell will tell you &ldquo;No such file or directory&rdquo; if you try to access it:<br>现在，如果您删除原始文件，链接将被破坏，并且如果您尝试访问它，shell 会告诉您“没有这样的文件或目录”：</p><p><img src=img/000004.png alt></p><h2 id=gzip>gzip
<a class=anchor href=#gzip>#</a></h2><p>You can compress a file using the gzip compression protocol named <a href=https://en.wikipedia.org/wiki/LZ77_and_LZ78>LZ77</a> using the <code>gzip</code> command.<br>您可以使用<code>gzip</code>命令使用名为<a href=https://en.wikipedia.org/wiki/LZ77_and_LZ78>LZ77</a>的 gzip 压缩协议来压缩文件。</p><p>Here&rsquo;s the simplest usage:<br>这是最简单的用法：</p><pre><code>gzip filename
</code></pre><p>This will compress the file, and append a <code>.gz</code> extension to it. The original file is deleted. To prevent this, you can use the <code>-c</code> option and use output redirection to write the output to the <code>filename.gz</code> file:<br>这将压缩该文件，并为其附加<code>.gz</code>扩展名。原始文件被删除。为了防止这种情况，您可以使用<code>-c</code>选项并使用输出重定向将输出写入<code>filename.gz</code>文件：</p><pre><code>gzip -c filename &gt; filename.gz
</code></pre><blockquote><p>The <code>-c</code> option specifies that output will go to the standard output stream, leaving the original file intact<br><code>-c</code>选项指定输出将转到标准输出流，保持原始文件不变</p></blockquote><p>Or you can use the <code>-k</code> option:<br>或者您可以使用<code>-k</code>选项：</p><pre><code>gzip -k filename
</code></pre><p>There are various levels of compression. The more the compression, the longer it will take to compress
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>d</mi><mi>d</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">and decompress</annotation></semantics></math></span>
. Levels range from 1
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>s</mi><mi>t</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">fastest, worst compression</annotation></semantics></math></span>
to 9
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>l</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo separator="true">,</mo><mi>b</mi><mi>e</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">slowest, better compression</annotation></semantics></math></span>
, and the default is 6.<br>压缩有多种级别。压缩越多，压缩（和解压缩）所需的时间就越长。级别范围从 1（最快、最差压缩）到 9（最慢、更好压缩），默认值为 6。</p><p>You can choose a specific level with the <code>-&lt;NUMBER></code> option:<br>您可以使用<code>-&lt;NUMBER></code>选项选择特定级别：</p><pre><code>gzip -1 filename
</code></pre><p>You can compress multiple files by listing them:<br>您可以通过列出多个文件来压缩它们：</p><pre><code>gzip filename1 filename2
</code></pre><p>You can compress all the files in a directory, recursively, using the <code>-r</code> option:<br>您可以使用<code>-r</code>选项递归地压缩目录中的所有文件：</p><pre><code>gzip -r a_folder
</code></pre><p>The <code>-v</code> option prints the compression percentage information. Here&rsquo;s an example of it being used along with the <code>-k</code>
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><mi>e</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">keep</annotation></semantics></math></span>
option:<br><code>-v</code>选项打印压缩百分比信息。下面是它与<code>-k</code> （保留）选项一起使用的示例：</p><p><img src=img/000091.png alt></p><p><code>gzip</code> can also be used to decompress a file, using the <code>-d</code> option:<br><code>gzip</code>还可以用于解压缩文件，使用<code>-d</code>选项：</p><pre><code>gzip -d filename.gz
</code></pre><h2 id=gunzip>gunzip
<a class=anchor href=#gunzip>#</a></h2><p>The <code>gunzip</code> command is basically equivalent to the <code>gzip</code> command, except the <code>-d</code> option is always enabled by default.<br><code>gunzip</code>命令基本上等同于<code>gzip</code>命令，只是默认情况下始终启用<code>-d</code>选项。</p><p>The command can be invoked in this way:<br>该命令可以通过以下方式调用：</p><pre><code>gunzip filename.gz
</code></pre><p>This will gunzip and will remove the <code>.gz</code> extension, putting the result in the <code>filename</code> file. If that file exists, it will overwrite that.<br>这将进行gunzip并删除<code>.gz</code>扩展名，将结果放入<code>filename</code>文件中。如果该文件存在，它将覆盖该文件。</p><p>You can extract to a different filename using output redirection using the <code>-c</code> option:<br>您可以使用<code>-c</code>选项使用输出重定向来提取到不同的文件名：</p><pre><code>gunzip -c filename.gz &gt; anotherfilename
</code></pre><h2 id=tar>tar
<a class=anchor href=#tar>#</a></h2><p>The <code>tar</code> command is used to create an archive, grouping multiple files in a single file.<br><code>tar</code>命令用于创建存档，将多个文件分组到一个文件中。</p><p>Its name comes from the past and means <em>tape archive</em>. Back when archives were stored on tapes.<br>它的名字来源于过去，意思是<em>磁带存档</em>。回到档案存储在磁带上的时代。</p><p>This command creates an archive named <code>archive.tar</code> with the content of <code>file1</code> and <code>file2</code>:<br>此命令创建一个名为<code>archive.tar</code>的存档，其中包含<code>file1</code>和<code>file2</code>的内容：</p><pre><code>tar -cf archive.tar file1 file2
</code></pre><blockquote><p>The <code>c</code> option stands for <em>create</em>. The <code>f</code> option is used to write to file the archive.<br><code>c</code>选项代表<em>create</em> 。 <code>f</code>选项用于写入存档。</p></blockquote><p>To extract files from an archive in the current folder, use:<br>要从当前文件夹中的存档中提取文件，请使用：</p><pre><code>tar -xf archive.tar
</code></pre><blockquote><p>the <code>x</code> option stands for <em>extract</em><br><code>x</code>选项代表<em>提取</em></p></blockquote><p>and to extract them to a specific directory, use:<br>并将它们提取到特定目录，请使用：</p><pre><code>tar -xf archive.tar -C directory
</code></pre><p>You can also just list the files contained in an archive:<br>您还可以只列出存档中包含的文件：</p><p><img src=img/000094.png alt></p><p><code>tar</code> is often used to create a <strong>compressed archive</strong>, gzipping the archive.<br><code>tar</code>通常用于创建<strong>压缩档案</strong>，对档案进行 gzip 压缩。</p><p>This is done using the <code>z</code> option:<br>这是使用<code>z</code>选项完成的：</p><pre><code>tar -czf archive.tar.gz file1 file2
</code></pre><p>This is just like creating a tar archive, and then running <code>gzip</code> on it.<br>这就像创建一个 tar 存档，然后在其上运行<code>gzip</code>一样。</p><p>To unarchive a gzipped archive, you can use <code>gunzip</code>, or <code>gzip -d</code>, and then unarchive it, but <code>tar -xf</code> will recognize it&rsquo;s a gzipped archive, and do it for you:<br>要取消归档 gzip 压缩档案，您可以使用<code>gunzip</code>或<code>gzip -d</code> ，然后将其取消归档，但<code>tar -xf</code>会识别出它是 gzip 压缩档案，并为您执行此操作：</p><pre><code>tar -xf archive.tar.gz
</code></pre><h2 id=alias>alias
<a class=anchor href=#alias>#</a></h2><p>It&rsquo;s common to always run a program with a set of options you like using.<br>总是使用一组您喜欢使用的选项来运行程序是很常见的。</p><p>For example, take the <code>ls</code> command. By default it prints very little information:<br>例如，使用<code>ls</code>命令。默认情况下它打印很少的信息：</p><p><img src=img/000012.png alt></p><p>while using the <code>-al</code> option it will print something more useful, including the file modification date, the size, the owner, and the permissions, also listing hidden files (files starting with a <code>.</code>:<br>使用<code>-al</code>选项时，它将打印更有用的内容，包括文件修改日期、大小、所有者和权限，还列出隐藏文件（以<code>.</code>开头的文件：</p><p><img src=img/000013.png alt></p><p>You can create a new command, for example I like to call it <code>ll</code>, that is an alias to <code>ls -al</code>.<br>您可以创建一个新命令，例如我喜欢将其称为<code>ll</code> ，这是<code>ls -al</code>的别名。</p><p>You do it in this way:<br>你可以这样做：</p><pre><code>alias     ll=    'ls -al'    
</code></pre><p>Once you do, you can call <code>ll</code> just like it was a regular UNIX command:<br>完成后，您可以像调用常规 UNIX 命令一样调用<code>ll</code> ：</p><p><img src=img/000014.png alt></p><p>Now calling <code>alias</code> without any option will list the aliases defined:<br>现在不带任何选项调用<code>alias</code>将列出定义的别名：</p><p><img src=img/000015.png alt></p><p>The alias will work until the terminal session is closed.<br>该别名将一直有效，直到终端会话关闭。</p><p>To make it permanent, you need to add it to the shell configuration, which could be <code>~/.bashrc</code> or <code>~/.profile</code> or <code>~/.bash_profile</code> if you use the Bash shell, depending on the use case.<br>为了使其永久化，您需要将其添加到 shell 配置中，如果您使用 Bash shell，则可以是<code>~/.bashrc</code>或<code>~/.profile</code>或<code>~/.bash_profile</code> ，具体取决于用例。</p><p>Be careful with quotes if you have variables in the command: using double quotes the variable is resolved at definition time, using single quotes it&rsquo;s resolved at invocation time. Those 2 are different:<br>如果命令中有变量，请小心使用引号：使用双引号，变量在定义时解析，使用单引号，变量在调用时解析。这两个是不同的：</p><pre><code>alias     lsthis=    &quot;ls     $PWD    &quot;        alias     lscurrent=    'ls $PWD'    
</code></pre><p>$PWD refers to the current folder the shell is into. If you now navigate away to a new folder, <code>lscurrent</code> lists the files in the new folder, <code>lsthis</code> still lists the files in the folder you were when you defined the alias.<br>$PWD 指 shell 所在的当前文件夹。如果您现在导航到新文件夹， <code>lscurrent</code>会列出新文件夹中的文件， <code>lsthis</code>仍会列出您定义别名时所在文件夹中的文件。</p><h2 id=cat>cat
<a class=anchor href=#cat>#</a></h2><p>Similar to <code>tail</code> in some way, we have <code>cat</code>. Except <code>cat</code> can also add content to a file, and this makes it super powerful.<br>在某种程度上与<code>tail</code>类似，我们有<code>cat</code> 。除了<code>cat</code>还可以向文件添加内容，这使得它超级强大。</p><p>In its simplest usage, <code>cat</code> prints a file&rsquo;s content to the standard output:<br>在最简单的用法中， <code>cat</code>将文件的内容打印到标准输出：</p><pre><code>cat file
</code></pre><p>You can print the content of multiple files:<br>您可以打印多个文件的内容：</p><pre><code>cat file1 file2
</code></pre><p>and using the output redirection operator <code>></code> you can concatenate the content of multiple files into a new file:<br>并使用输出重定向运算符<code>></code>您可以将多个文件的内容连接到一个新文件中：</p><pre><code>cat file1 file2 &gt; file3
</code></pre><p>Using <code>>></code> you can append the content of multiple files into a new file, creating it if it does not exist:<br>使用<code>>></code>您可以将多个文件的内容附加到一个新文件中，如果它不存在则创建它：</p><pre><code>cat file1 file2 &gt;&gt; file3
</code></pre><p>When watching source code files it&rsquo;s great to see the line numbers, and you can have <code>cat</code> print them using the <code>-n</code> option:<br>当观看源代码文件时，很高兴看到行号，并且您可以使用<code>-n</code>选项让<code>cat</code>打印它们：</p><pre><code>cat -n file1
</code></pre><p>You can only add a number to non-blank lines using <code>-b</code>, or you can also remove all the multiple empty lines using <code>-s</code>.<br>您只能使用<code>-b</code>将数字添加到非空行，也可以使用<code>-s</code>删除所有多个空行。</p><p><code>cat</code> is often used in combination with the pipe operator <code>|</code> to feed a file content as input to another command: <code>cat file1 | anothercommand</code>.<br><code>cat</code>通常与管道运算符<code>|</code>结合使用将文件内容作为另一个命令的输入： <code>cat file1 | anothercommand</code> 。</p><h2 id=less>less
<a class=anchor href=#less>#</a></h2><p>The <code>less</code> command is one I use a lot. It shows you the content stored inside a file, in a nice and interactive UI.<br><code>less</code>命令是我经常使用的命令。它以漂亮的交互式用户界面向您显示文件中存储的内容。</p><p>Usage: <code>less &lt;filename></code>.<br>用法： <code>less &lt;filename></code> 。</p><p><img src=img/000111.png alt></p><p>Once you are inside a <code>less</code> session, you can quit by pressing <code>q</code>.<br>一旦进入<code>less</code>会话，您可以按<code>q</code>退出。</p><p>You can navigate the file contents using the <code>up</code> and <code>down</code> keys, or using the <code>space bar</code> and <code>b</code> to navigate page by page. You can also jump to the end of the file pressing <code>G</code> and jump back to the start pressing <code>g</code>.<br>您可以使用<code>up</code>和<code>down</code>键导航文件内容，或使用<code>space bar</code>和<code>b</code>逐页导航。您还可以按<code>G</code>跳转到文件末尾，然后按<code>g</code>跳回开头。</p><p>You can search contents inside the file by pressing <code>/</code> and typing a word to search. This searches <em>forward</em>. You can search backwards using the <code>?</code> symbol and typing a word.<br>您可以通过按<code>/</code>并键入要搜索的单词来搜索文件内的内容。这<em>向前</em>搜索。您可以使用<code>?</code>向后搜索符号并输入一个单词。</p><p>This command just visualises the file&rsquo;s content. You can directly open an editor by pressing <code>v</code>. It will use the system editor, which in most cases is <code>vim</code>.<br>该命令只是可视化文件的内容。您可以通过按<code>v</code>直接打开编辑器。它将使用系统编辑器，在大多数情况下是<code>vim</code> 。</p><p>Pressing the <code>F</code> key enters <em>follow mode</em>, or <em>watch mode</em>. When the file is changed by someone else, like from another program, you get to see the changes <em>live</em>. By default this is not happening, and you only see the file version at the time you opened it. You need to press <code>ctrl-C</code> to quit this mode. In this case the behaviour is similar to running the <code>tail -f &lt;filename></code> command.<br>按<code>F</code>键进入<em>跟随模式</em>或<em>监视模式</em>。当其他人（例如从另一个程序）更改文件时，您可以<em>实时</em>看到更改。默认情况下，这种情况不会发生，您只能看到打开文件时的文件版本。您需要按<code>ctrl-C</code>退出此模式。在这种情况下，行为类似于运行<code>tail -f &lt;filename></code>命令。</p><p>You can open multiple files, and navigate through them using <code>:n</code>
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>g</mi><mi>o</mi><mi>t</mi><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">to go to the next file</annotation></semantics></math></span>
and <code>:p</code>
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>o</mi><mi>g</mi><mi>o</mi><mi>t</mi><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>v</mi><mi>i</mi><mi>o</mi><mi>u</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">to go to the previous</annotation></semantics></math></span>
.<br>您可以打开多个文件，并使用<code>:n</code> （转到下一个文件）和<code>:p</code> （转到上一个文件）浏览它们。</p><h2 id=tail>tail
<a class=anchor href=#tail>#</a></h2><p>The best use case of tail in my opinion is when called with the <code>-f</code> option. It opens the file at the end, and watches for file changes. Any time there is new content in the file, it is printed in the window. This is great for watching log files, for example:<br>我认为 tail 的最佳用例是使用<code>-f</code>选项调用时。它在末尾打开文件，并监视文件更改。每当文件中有新内容时，都会将其打印在窗口中。这对于查看日志文件非常有用，例如：</p><pre><code>tail -f /var/    log    /system.log
</code></pre><p>To exit, press <code>ctrl-C</code>.<br>要退出，请按<code>ctrl-C</code> 。</p><p>You can print the last 10 lines in a file:<br>您可以打印文件中的最后 10 行：</p><pre><code>tail -n 10 &lt;filename&gt;
</code></pre><p>You can print the whole file content starting from a specific line using <code>+</code> before the line number:<br>您可以在行号之前使用<code>+</code>打印从特定行开始的整个文件内容：</p><pre><code>tail -n +10 &lt;filename&gt;
</code></pre><p><code>tail</code> can do much more and as always my advice is to check <code>man tail</code>.<br><code>tail</code>可以做更多事情，一如既往，我的建议是检查<code>man tail</code> 。</p><h2 id=wc>wc
<a class=anchor href=#wc>#</a></h2><p>The <code>wc</code> command gives us useful information about a file or input it receives via pipes.<br><code>wc</code>命令为我们提供有关文件或通过管道接收的输入的有用信息。</p><pre><code>echo         test     &gt;&gt; test.txt
wc test.txt
1       1       5 test.txt
</code></pre><p>Example via pipes, we can count the output of running the <code>ls -al</code> command:<br>通过管道示例，我们可以计算运行<code>ls -al</code>命令的输出：</p><pre><code>ls -al | wc
6      47     284
</code></pre><p>The first column returned is the number of lines. The second is the number of words. The third is the number of bytes.<br>返回的第一列是行数。第二是字数。第三个是字节数。</p><p>We can tell it to just count the lines:<br>我们可以告诉它只计算行数：</p><pre><code>wc -l test.txt
</code></pre><p>or just the words:<br>或者只是这样的话：</p><pre><code>wc -w test.txt
</code></pre><p>or just the bytes:<br>或者只是字节：</p><pre><code>wc -c test.txt
</code></pre><p>Bytes in ASCII charsets equate to characters, but with non-ASCII charsets, the number of characters might differ because some characters might take multiple bytes, for example this happens in Unicode.<br>ASCII 字符集中的字节等同于字符，但对于非 ASCII 字符集，字符数可能会有所不同，因为某些字符可能占用多个字节，例如在 Unicode 中就会发生这种情况。</p><p>In this case the <code>-m</code> flag will help getting the correct value:<br>在这种情况下， <code>-m</code>标志将有助于获取正确的值：</p><pre><code>wc -m test.txt
</code></pre><h2 id=grep>grep
<a class=anchor href=#grep>#</a></h2><p>The <code>grep</code> command is a very useful tool, that when you master will help you tremendously in your day to day.<br><code>grep</code>命令是一个非常有用的工具，当你掌握它时，它将对你的日常工作有很大帮助。</p><blockquote><p>If you&rsquo;re wondering, <code>grep</code> stands for <em>global regular expression print</em><br>如果您想知道， <code>grep</code>代表<em>全局正则表达式打印</em></p></blockquote><p>You can use <code>grep</code> to search in files, or combine it with pipes to filter the output of another command.<br>您可以使用<code>grep</code>在文件中搜索，或将其与管道结合起来过滤另一个命令的输出。</p><p>For example here&rsquo;s how we can find the occurences of the <code>document.getElementById</code> line in the <code>index.md</code> file:<br>例如，我们如何在<code>index.md</code>文件中查找<code>document.getElementById</code>行的出现：</p><pre><code>grep document.getElementById index.md
</code></pre><p><img src=img/000051.png alt></p><p>Using the <code>-n</code> option it will show the line numbers:<br>使用<code>-n</code>选项它将显示行号：</p><pre><code>grep -n document.getElementById index.md
</code></pre><p><img src=img/000050.png alt></p><p>One very useful thing is to tell grep to print 2 lines before, and 2 lines after the matched line, to give us more context. That&rsquo;s done using the <code>-C</code> option, which accepts a number of lines:<br>一件非常有用的事情是告诉 grep 在匹配行之前打印 2 行，在匹配行之后打印 2 行，以便为我们提供更多上下文。这是使用<code>-C</code>选项完成的，它接受多行：</p><pre><code>grep -nC 2 document.getElementById index.md
</code></pre><p><img src=img/000053.png alt></p><p>Search is case sensitive by default. Use the <code>-i</code> flag to make it insensitive.<br>默认情况下，搜索区分大小写。使用<code>-i</code>标志使其不敏感。</p><p>As mentioned, you can use grep to filter the output of another command. We can replicate the same functionality as above using:<br>如前所述，您可以使用 grep 来过滤另一个命令的输出。我们可以使用以下方法复制与上面相同的功能：</p><pre><code>less index.md | grep -n document.getElementById
</code></pre><p><img src=img/000052.png alt></p><p>The search string can be a regular expression, and this makes <code>grep</code> very powerful.<br>搜索字符串可以是正则表达式，这使得<code>grep</code>非常强大。</p><p>Another thing you might find very useful is to invert the result, excluding the lines that match a particular string, using the <code>-v</code> option:<br>您可能会发现非常有用的另一件事是使用<code>-v</code>选项反转结果，排除与特定字符串匹配的行：</p><p><img src=img/000054.png alt></p><h2 id=sort>sort
<a class=anchor href=#sort>#</a></h2><p>Suppose you have a text file which contains the names of dogs:<br>假设您有一个包含狗的名字的文本文件：</p><p><img src=img/000062.png alt></p><p>This list is unordered.<br>该列表是无序的。</p><p>The <code>sort</code> command helps us sorting them by name:<br><code>sort</code>命令帮助我们按名称对它们进行排序：</p><p><img src=img/000063.png alt></p><p>Use the <code>r</code> option to reverse the order:<br>使用<code>r</code>选项反转顺序：</p><p><img src=img/000064.png alt></p><p>Sorting by default is case sensitive, and alphabetic. Use the <code>--ignore-case</code> option to sort case insensitive, and the <code>-n</code> option to sort using a numeric order.<br>默认情况下排序区分大小写并按字母顺序。使用<code>--ignore-case</code>选项不区分大小写进行排序，使用<code>-n</code>选项按数字顺序排序。</p><p>If the file contains duplicate lines:<br>如果文件包含重复行：</p><p><img src=img/000065.png alt></p><p>You can use the <code>-u</code> option to remove them:<br>您可以使用<code>-u</code>选项来删除它们：</p><p><img src=img/000066.png alt></p><p><code>sort</code> does not just works on files, as many UNIX commands it also works with pipes, so you can use on the output of another command, for example you can order the files returned by <code>ls</code> with:<br><code>sort</code>不仅仅适用于文件，因为许多 UNIX 命令也适用于管道，因此您可以在另一个命令的输出上使用，例如您可以使用以下命令对<code>ls</code>返回的文件进行排序：</p><pre><code>ls | sort
</code></pre><p><code>sort</code> is very powerful and has lots more options, which you can explore calling <code>man sort</code>.<br><code>sort</code>非常强大，并且有更多选项，您可以调用<code>man sort</code>来探索。</p><p><img src=img/000067.png alt></p><h2 id=uniq>uniq
<a class=anchor href=#uniq>#</a></h2><p><code>uniq</code> is a command useful to sort lines of text.<br><code>uniq</code>是一个用于对文本行进行排序的命令。</p><p>You can get those lines from a file, or using pipes from the output of another command:<br>您可以从文件中获取这些行，或使用管道从另一个命令的输出中获取这些行：</p><pre><code>uniq dogs.txt

ls | uniq
</code></pre><p>You need to consider this key thing: <code>uniq</code> will only detect adjacent duplicate lines.<br>您需要考虑这一关键事项： <code>uniq</code>只会检测相邻的重复行。</p><p>This implies that you will most likely use it along with <code>sort</code>:<br>这意味着您很可能将它与<code>sort</code>一起使用：</p><pre><code>sort dogs.txt | uniq
</code></pre><p>The <code>sort</code> command has its own way to remove duplicates with the <code>-u</code>
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo><mi>u</mi><mi>n</mi><mi>i</mi><mi>q</mi><mi>u</mi><mi>e</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">*unique*</annotation></semantics></math></span>
option. But <code>uniq</code> has more power.<br><code>sort</code>命令有自己的方法来使用<code>-u</code>
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo><mi>u</mi><mi>n</mi><mi>i</mi><mi>q</mi><mi>u</mi><mi>e</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex"> *unique* </annotation></semantics></math></span>
选项删除重复项。但<code>uniq</code>的力量更大。</p><p>By default it removes duplicate lines:<br>默认情况下它会删除重复的行：</p><p><img src=img/000072.png alt></p><p>You can tell it to only display duplicate lines, for example, with the <code>-d</code> option:<br>您可以告诉它只显示重复的行，例如，使用<code>-d</code>选项：</p><pre><code>sort dogs.txt | uniq -d
</code></pre><p><img src=img/000068.png alt></p><p>You can use the <code>-u</code> option to only display non-duplicate lines:<br>您可以使用<code>-u</code>选项仅显示非重复行：</p><p><img src=img/000071.png alt></p><p>You can count the occurrences of each line with the <code>-c</code> option:<br>您可以使用<code>-c</code>选项计算每行的出现次数：</p><p><img src=img/000069.png alt></p><p>Use the special combination:<br>使用特殊组合：</p><pre><code>sort dogs.txt | uniq -c | sort -nr
</code></pre><p>to then sort those lines by most frequent:<br>然后按最常见的顺序对这些行进行排序：</p><p><img src=img/000070.png alt></p><h2 id=diff>diff
<a class=anchor href=#diff>#</a></h2><p><code>diff</code> is a handy command. Suppose you have 2 files, which contain almost the same information, but you can&rsquo;t find the difference between the two.<br><code>diff</code>是一个方便的命令。假设你有2个文件，它们包含几乎相同的信息，但你找不到两者之间的差异。</p><p><code>diff</code> will process the files and will tell you what&rsquo;s the difference.<br><code>diff</code>将处理文件并告诉您有什么区别。</p><p>Suppose you have 2 files: <code>dogs.txt</code> and <code>moredogs.txt</code>. The difference is that <code>moredogs.txt</code> contains one more dog name:<br>假设您有 2 个文件： <code>dogs.txt</code>和<code>moredogs.txt</code> 。不同之处在于<code>moredogs.txt</code>多了一个狗的名字：</p><p><img src=img/000073.png alt></p><p><code>diff dogs.txt moredogs.txt</code> will tell you the second file has one more line, line 3 with the line <code>Vanille</code>:<br><code>diff dogs.txt moredogs.txt</code>会告诉你第二个文件还有一行，第 3 行带有<code>Vanille</code>行：</p><p><img src=img/000074.png alt></p><p>If you invert the order of the files, it will tell you that the second file is missing line 3, whose content is <code>Vanille</code>:<br>如果你颠倒文件的顺序，它会告诉你第二个文件缺少第3行，其内容是<code>Vanille</code> ：</p><p><img src=img/000075.png alt></p><p>Using the <code>-y</code> option will compare the 2 files line by line:<br>使用<code>-y</code>选项将逐行比较两个文件：</p><p><img src=img/000076.png alt></p><p>The <code>-u</code> option however will be more familiar to you, because that&rsquo;s the same used by the Git version control system to display differences between versions:<br>不过，您会更熟悉<code>-u</code>选项，因为 Git 版本控制系统使用该选项来显示版本之间的差异：</p><p><img src=img/000077.png alt></p><p>Comparing directories works in the same way. You must use the <code>-r</code> option to compare recursively
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>o</mi><mi>s</mi><mi>u</mi><mi>b</mi><mi>d</mi><mi>i</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">going into subdirectories</annotation></semantics></math></span>
:<br>比较目录的工作方式相同。您必须使用<code>-r</code>选项进行递归比较（进入子目录）：</p><p><img src=img/000078.png alt></p><p>In case you&rsquo;re interested in which files differ, rather than the content, use the <code>r</code> and <code>q</code> options:<br>如果您对哪些文件不同而不是内容感兴趣，请使用<code>r</code>和<code>q</code>选项：</p><p><img src=img/000079.png alt></p><p>There are many more options you can explore in the man page running <code>man diff</code>:<br>您可以在运行<code>man diff</code>手册页中探索更多选项：</p><p><img src=img/000080.png alt></p><h2 id=echo>echo
<a class=anchor href=#echo>#</a></h2><p>The <code>echo</code> command does one simple job: it prints to the output the argument passed to it.<br><code>echo</code>命令执行一项简单的工作：它将传递给它的参数打印到输出。</p><p>This example:<br>这个例子：</p><pre><code>echo         &quot;hello&quot;    
</code></pre><p>will print <code>hello</code> to the terminal.<br>将向终端打印<code>hello</code> 。</p><p>We can append the output to a file:<br>我们可以将输出附加到文件中：</p><pre><code>echo         &quot;hello&quot;     &gt;&gt; output.txt
</code></pre><p>We can interpolate environment variables:<br>我们可以插入环境变量：</p><pre><code>echo         &quot;The path variable is     $PATH    &quot;    
</code></pre><p><img src=img/000016.png alt></p><p>Beware that special characters need to be escaped with a backslash <code>\</code>. <code>$</code> for example:<br>请注意，特殊字符需要使用反斜杠<code>\</code>进行转义。 <code>$</code>例如：</p><p><img src=img/000021.png alt></p><p>This is just the start. We can do some nice things when it comes to interacting with the shell features.<br>这只是开始。在与 shell 功能交互时，我们可以做一些不错的事情。</p><p>We can echo the files in the current folder:<br>我们可以回显当前文件夹中的文件：</p><pre><code>echo     *
</code></pre><p>We can echo the files in the current folder that start with the letter <code>o</code>:<br>我们可以回显当前文件夹中以字母<code>o</code>开头的文件：</p><pre><code>echo     o*
</code></pre><p>Any valid Bash
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>y</mi><mi>s</mi><mi>h</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi>y</mi><mi>o</mi><mi>u</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>u</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">or any shell you are using</annotation></semantics></math></span>
command and feature can be used here.<br>任何有效的 Bash（或您正在使用的任何 shell）命令和功能都可以在此处使用。</p><p>You can print your home folder path:<br>您可以打印您的主文件夹路径：</p><pre><code>echo     ~
</code></pre><p><img src=img/000017.png alt></p><p>You can also execute commands, and print the result to the standard output
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>r</mi><mi>t</mi><mi>o</mi><mi>f</mi><mi>i</mi><mi>l</mi><mi>e</mi><mo separator="true">,</mo><mi>a</mi><mi>s</mi><mi>y</mi><mi>o</mi><mi>u</mi><mi>s</mi><mi>a</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">or to file, as you saw</annotation></semantics></math></span>
:<br>您还可以执行命令，并将结果打印到标准输出（或打印到文件，如您所见）：</p><pre><code>echo     $(ls -al)
</code></pre><p><img src=img/000019.png alt></p><p>Note that whitespace is not preserved by default. You need to wrap the command in double quotes to do so:<br>请注意，默认情况下不保留空格。您需要将命令用双引号括起来才能执行此操作：</p><p><img src=img/000020.png alt></p><p>You can generate a list of strings, for example ranges:<br>您可以生成字符串列表，例如范围：</p><pre><code>echo     {1..5}
</code></pre><p><img src=img/000018.png alt></p><h2 id=chown>chown
<a class=anchor href=#chown>#</a></h2><p>Every file/directory in an Operating System like Linux or macOS
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi>U</mi><mi>N</mi><mi>I</mi><mi>X</mi><mi>s</mi><mi>y</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">and every UNIX systems in general</annotation></semantics></math></span>
has an <strong>owner</strong>.<br>Linux 或 macOS（以及一般的每个 UNIX 系统）等操作系统中的每个文件/目录都有一个<strong>所有者</strong>。</p><p>The owner of a file can do everything with it. It can decide the fate of that file.<br>文件的所有者可以用它做任何事情。它可以决定该文件的命运。</p><p>The owner
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>d</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi mathvariant="normal">‘</mi><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">‘</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">and the `root` user</annotation></semantics></math></span>
can change the owner to another user, too, using the <code>chown</code> command:<br>所有者（和<code>root</code>用户）也可以使用<code>chown</code>命令将所有者更改为其他用户：</p><pre><code>chown &lt;owner&gt; &lt;file&gt;
</code></pre><p>Like this:<br>像这样：</p><pre><code>chown flavio test.txt
</code></pre><p>For example if you have a file that&rsquo;s owned by <code>root</code>, you can&rsquo;t write to it as another user:<br>例如，如果您有一个归<code>root</code>所有的文件，则无法以其他用户身份写入该文件：</p><p><img src=img/000037.png alt></p><p>You can use <code>chown</code> to transfer the ownership to you:<br>您可以使用<code>chown</code>将所有权转移给您：</p><p><img src=img/000038.png alt></p><p>It&rsquo;s rather common to have the need to change the ownership of a directory, and recursively all the files contained, plus all the subdirectories and the files contained in them, too.<br>需要更改目录的所有权以及递归地更改其中包含的所有文件以及所有子目录和其中包含的文件的所有权是相当常见的。</p><p>You can do so using the <code>-R</code> flag:<br>您可以使用<code>-R</code>标志来执行此操作：</p><pre><code>chown -R &lt;owner&gt; &lt;file&gt;
</code></pre><p>Files/directories don&rsquo;t just have an owner, they also have a <strong>group</strong>. Through this command you can change that simultaneously while you change the owner:<br>文件/目录不仅有一个所有者，它们还有一个<strong>组</strong>。通过此命令，您可以在更改所有者的同时更改它：</p><pre><code>chown &lt;owner&gt;:&lt;group&gt; &lt;file&gt;
</code></pre><p>Example:<br>例子：</p><pre><code>chown flavio:users test.txt
</code></pre><p>You can also just change the group of a file using the <code>chgrp</code> command:<br>您还可以使用<code>chgrp</code>命令更改文件组：</p><pre><code>chgrp &lt;group&gt; &lt;filename&gt;
</code></pre><h2 id=chmod>chmod
<a class=anchor href=#chmod>#</a></h2><p>Every file in the Linux / macOS Operating Systems
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>d</mi><mi>U</mi><mi>N</mi><mi>I</mi><mi>X</mi><mi>s</mi><mi>y</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>m</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>r</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">and UNIX systems in general</annotation></semantics></math></span>
has 3 permissions: Read, write, execute.<br>Linux / macOS 操作系统（以及一般的 UNIX 系统）中的每个文件都有 3 个权限：读、写、执行。</p><p>Go into a folder, and run the <code>ls -al</code> command.<br>进入文件夹，然后运行<code>ls -al</code>命令。</p><p><img src=img/000039.png alt></p><p>The weird strings you see on each file line, like <code>drwxr-xr-x</code>, define the permissions of the file or folder.<br>您在每个文件行上看到的奇怪字符串（例如<code>drwxr-xr-x</code> ）定义了文件或文件夹的权限。</p><p>Let&rsquo;s dissect it.<br>我们来剖析一下。</p><p>The first letter indicates the type of file:<br>第一个字母表示文件类型：</p><ul><li><code>-</code> means it&rsquo;s a normal file<br><code>-</code>表示这是一个普通文件</li><li><code>d</code> means it&rsquo;s a directory<br><code>d</code>表示它是一个目录</li><li><code>l</code> means it&rsquo;s a link<br><code>l</code>表示这是一个链接</li></ul><p>Then you have 3 sets of values:<br>然后你有 3 组值：</p><ul><li>The first set represents the permissions of the <strong>owner</strong> of the file<br>第一组代表文件<strong>所有者</strong>的权限</li><li>The second set represents the permissions of the members of the <strong>group</strong> the file is associated to<br>第二组表示文件关联的<strong>组</strong>成员的权限</li><li>The third set represents the permissions of the <strong>everyone else</strong><br>第三组代表<strong>其他人</strong>的权限</li></ul><p>Those sets are composed by 3 values. <code>rwx</code> means that specific <em>persona</em> has read, write and execution access. Anything that is removed is swapped with a <code>-</code>, which lets you form various combinations of values and relative permissions: <code>rw-</code>, <code>r--</code>, <code>r-x</code>, and so on.<br>这些集合由 3 个值组成。 <code>rwx</code>表示特定<em>角色</em>具有读、写和执行访问权限。任何删除的内容都会与<code>-</code>交换，这使您可以形成值和相对权限的各种组合： <code>rw-</code> 、 <code>r--</code> 、 <code>rx</code>等。</p><p>You can change the permissions given to a file using the <code>chmod</code> command.<br>您可以使用<code>chmod</code>命令更改赋予文件的权限。</p><p><code>chmod</code> can be used in 2 ways. The first is using symbolic arguments, the second is using numeric arguments. Let&rsquo;s start with symbols first, which is more intuitive.<br><code>chmod</code>有两种使用方式。第一个是使用符号参数，第二个是使用数字参数。我们先从符号开始，这样更直观。</p><p>You type <code>chmod</code> followed by a space, and a letter:<br>您输入<code>chmod</code>后跟一个空格和一个字母：</p><ul><li><code>a</code> stands for <em>all</em><br><code>a</code>代表<em>全部</em></li><li><code>u</code> stands for <em>user</em><br><code>u</code>代表<em>用户</em></li><li><code>g</code> stands for <em>group</em><br><code>g</code>代表<em>组</em></li><li><code>o</code> stands for <em>others</em><br><code>o</code>代表<em>其他</em></li></ul><p>Then you type either <code>+</code> or <code>-</code> to add a permission, or to remove it. Then you enter one or more permissions symbols
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>r</mi><mi mathvariant="normal">‘</mi><mo separator="true">,</mo><mi mathvariant="normal">‘</mi><mi>w</mi><mi mathvariant="normal">‘</mi><mo separator="true">,</mo><mi mathvariant="normal">‘</mi><mi>x</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`r`, `w`, `x`</annotation></semantics></math></span>
.<br>然后输入<code>+</code>或<code>-</code>来添加或删除权限。然后输入一个或多个权限符号（ <code>r</code> 、 <code>w</code> 、 <code>x</code> ）。</p><p>All followed by the file or folder name.<br>全部后跟文件或文件夹名称。</p><p>Here are some examples:<br>以下是一些示例：</p><pre><code>chmod a+r filename     #everyone can now read    
chmod a+rw filename     #everyone can now read and write    
chmod o-rwx filename     #others (not the owner, not in the same group of the file) cannot read, write or execute the file    
</code></pre><p>You can apply the same permissions to multiple personas by adding multiple letters before the <code>+</code>/<code>-</code>:<br>您可以通过<code>-</code> <code>+</code>之前添加多个字母来将相同的权限应用于多个角色：</p><pre><code>chmod og-r filename     #other and group can't read any more    
</code></pre><p>In case you are editing a folder, you can apply the permissions to every file contained in that folder using the <code>-r</code>
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>i</mi><mi>v</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">recursive</annotation></semantics></math></span>
flag.<br>如果您正在编辑文件夹，则可以使用<code>-r</code> （递归）标志将权限应用于该文件夹中包含的每个文件。</p><p>Numeric arguments are faster but I find them hard to remember when you are not using them day to day. You use a digit that represents the permissions of the persona. This number value can be a maximum of 7, and it&rsquo;s calculated in this way:<br>数字参数速度更快，但我发现当你不每天使用它们时很难记住它们。您使用代表角色权限的数字。该数值最大可为 7，计算方法如下：</p><ul><li><code>1</code> if has execution permission<br><code>1</code>是否有执行权限</li><li><code>2</code> if has write permission<br><code>2</code>是否有写权限</li><li><code>4</code> if has read permission<br><code>4</code>是否有读权限</li></ul><p>This gives us 4 combinations:<br>这给了我们 4 种组合：</p><ul><li><code>0</code> no permissions<br><code>0</code>无权限</li><li><code>1</code> can execute<br><code>1</code>可以执行</li><li><code>2</code> can write<br><code>2</code>可以写</li><li><code>3</code> can write, execute<br><code>3</code>可以写入、执行</li><li><code>4</code> can read<br><code>4</code>可以阅读</li><li><code>5</code> can read, execute<br><code>5</code>可以读取、执行</li><li><code>6</code> can read, write<br><code>6</code>可以读、写</li><li><code>7</code> can read, write and execute<br><code>7</code>可以读、写、执行</li></ul><p>We use them in pairs of 3, to set the permissions of all the 3 groups altogether:<br>我们将它们 3 个成对使用，以总共设置所有 3 个组的权限：</p><pre><code>chmod 777 filename
chmod 755 filename
chmod 644 filename
</code></pre><h2 id=umask>umask
<a class=anchor href=#umask>#</a></h2><p>When you create a file, you don&rsquo;t have to decide permissions up front. Permissions have defaults.<br>创建文件时，您不必预先决定权限。权限有默认值。</p><p>Those defaults can be controlled and modified using the <code>umask</code> command.<br>可以使用<code>umask</code>命令控制和修改这些默认值。</p><p>Typing <code>umask</code> with no arguments will show you the current umask, in this case <code>0022</code>:<br>不带参数输入<code>umask</code>将显示当前的 umask，在本例中为<code>0022</code> ：</p><p><img src=img/000048.png alt></p><p>What does <code>0022</code> mean? That&rsquo;s an octal value that represent the permissions.<br><code>0022</code>是什么意思？这是代表权限的八进制值。</p><p>Another common value is <code>0002</code>.<br>另一个常见的值是<code>0002</code> 。</p><p>Use <code>umask -S</code> to see a human-readable notation:<br>使用<code>umask -S</code>查看人类可读的符号：</p><p><img src=img/000049.png alt></p><p>In this case, the user
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>u</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`u`</annotation></semantics></math></span>
, owner of the file, has read, write and execution permissions on files.<br>在这种情况下，文件的所有者用户
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>u</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex"> `u` </annotation></semantics></math></span>
拥有文件的读、写和执行权限。</p><p>Other users belonging to the same group
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>g</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`g`</annotation></semantics></math></span>
have read and execution permission, same as all the other users
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>o</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`o`</annotation></semantics></math></span>
.<br>属于同一组的其他用户
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>g</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex"> `g` </annotation></semantics></math></span>
具有读取和执行权限，与所有其他用户
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>o</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex"> `o` </annotation></semantics></math></span>
相同。</p><p>In the numeric notation, we typically change the last 3 digits.<br>在数字表示法中，我们通常更改最后 3 位数字。</p><p>Here&rsquo;s a list that gives a meaning to the number:<br>这是一个给出数字含义的列表：</p><ul><li><code>0</code> read, write, execute<br><code>0</code>读、写、执行</li><li><code>1</code> read and write<br><code>1</code>读写</li><li><code>2</code> read and execute<br><code>2</code>读取并执行</li><li><code>3</code> read only<br><code>3</code>只读</li><li><code>4</code> write and execute<br><code>4</code>写入并执行</li><li><code>5</code> write only<br><code>5</code>只写</li><li><code>6</code> execute only<br><code>6</code>只执行</li><li><code>7</code> no permissions<br><code>7</code>无权限</li></ul><p>Note that this numeric notation differs from the one we use in <code>chmod</code>.<br>请注意，此数字表示法与我们在<code>chmod</code>中使用的数字表示法不同。</p><p>We can set a new value for the mask setting the value in numeric format:<br>我们可以为掩码设置一个新值，以数字格式设置该值：</p><pre><code>umask     002
</code></pre><p>or you can change a specific role&rsquo;s permission:<br>或者您可以更改特定角色的权限：</p><pre><code>umask     g+r
</code></pre><h2 id=du>du
<a class=anchor href=#du>#</a></h2><p>The <code>du</code> command will calculate the size of a directory as a whole:<br><code>du</code>命令将计算整个目录的大小：</p><pre><code>du
</code></pre><p><img src=img/000043.png alt></p><p>The <code>32</code> number here is a value expressed in bytes.<br>这里的<code>32</code>数字是一个以字节表示的值。</p><p>Running <code>du *</code> will calculate the size of each file individually:<br>运行<code>du *</code>将单独计算每个文件的大小：</p><p><img src=img/000044.png alt></p><p>You can set <code>du</code> to display values in MegaBytes using <code>du -m</code>, and GigaBytes using <code>du -g</code>.<br>您可以使用<code>du -m</code>将<code>du</code>设置为以兆字节为单位显示值，并使用<code>du -g</code>将 du 设置为以千兆字节为单位显示值。</p><p>The <code>-h</code> option will show a human-readable notation for sizes, adapting to the size:<br><code>-h</code>选项将显示人类可读的大小符号，以适应大小：</p><p><img src=img/000045.png alt></p><p>Adding the <code>-a</code> option will print the size of each file in the directories, too:<br>添加<code>-a</code>选项也会打印目录中每个文件的大小：</p><p><img src=img/000046.png alt></p><p>A handy thing is to sort the directories by size:<br>一个方便的事情是按大小对目录进行排序：</p><pre><code>du -h &lt;directory&gt; | sort -nr
</code></pre><p>and then piping to <code>head</code> to only get the first 10 results:<br>然后通过管道连接到<code>head</code>只获取前 10 个结果：</p><p><img src=img/000047.png alt></p><h2 id=df>df
<a class=anchor href=#df>#</a></h2><p>The <code>df</code> command is used to get disk usage information.<br><code>df</code>命令用于获取磁盘使用信息。</p><p>Its basic form will print information about the volumes mounted:<br>其基本形式将打印有关已安装卷的信息：</p><p><img src=img/000086.png alt></p><p>Using the <code>-h</code> option
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>d</mi><mi>f</mi><mo>−</mo><mi>h</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`df -h`</annotation></semantics></math></span>
will show those values in a human-readable format:<br>使用<code>-h</code>选项
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>d</mi><mi>f</mi><mo>−</mo><mi>h</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex"> `df -h` </annotation></semantics></math></span>
将以人类可读的格式显示这些值：</p><p><img src=img/000087.png alt></p><p>You can also specify a file or directory name to get information about the specific volume it lives on:<br>您还可以指定文件或目录名称来获取有关其所在特定卷的信息：</p><p><img src=img/000088.png alt></p><h2 id=basename>basename
<a class=anchor href=#basename>#</a></h2><p>Suppose you have a path to a file, for example <code>/Users/flavio/test.txt</code>.<br>假设您有一个文件的路径，例如<code>/Users/flavio/test.txt</code> 。</p><p>Running<br>跑步</p><pre><code>basename /Users/flavio/test.txt
</code></pre><p>will return the <code>test.txt</code> string:<br>将返回<code>test.txt</code>字符串：</p><p><img src=img/000104.png alt></p><p>If you run <code>basename</code> on a path string that points to a directory, you will get the last segment of the path. In this example, <code>/Users/flavio</code> is a directory:<br>如果您在指向目录的路径字符串上运行<code>basename</code> ，您将获得路径的最后一段。在此示例中， <code>/Users/flavio</code>是一个目录：</p><p><img src=img/000105.png alt></p><h2 id=dirname>dirname
<a class=anchor href=#dirname>#</a></h2><p>Suppose you have a path to a file, for example <code>/Users/flavio/test.txt</code>.<br>假设您有一个文件的路径，例如<code>/Users/flavio/test.txt</code> 。</p><p>Running<br>跑步</p><pre><code>dirname /Users/flavio/test.txt
</code></pre><p>will return the <code>/Users/flavio</code> string:<br>将返回<code>/Users/flavio</code>字符串：</p><p><img src=img/000106.png alt></p><h2 id=ps>ps
<a class=anchor href=#ps>#</a></h2><p>Your computer is running, at all times, tons of different processes.<br>您的计算机始终运行着大量不同的进程。</p><p>You can inspect them all using the <code>ps</code> command:<br>您可以使用<code>ps</code>命令检查它们：</p><p><img src=img/000006.png alt></p><p>This is the list of user-initiated processes currently running in the current session.<br>这是当前会话中当前运行的用户启动进程的列表。</p><p>Here I have a few <code>fish</code> shell instances, mostly opened by VS Code inside the editor, and an instances of Hugo running the development preview of a site.<br>这里我有一些<code>fish</code> shell 实例，大部分是通过编辑器内的 VS Code 打开的，还有一个运行网站开发预览的 Hugo 实例。</p><p>Those are just the commands assigned to the current user. To list <strong>all</strong> processes we need to pass some options to <code>ps</code>.<br>这些只是分配给当前用户的命令。要列出<strong>所有</strong>进程，我们需要将一些选项传递给<code>ps</code> 。</p><p>The most common I use is <code>ps ax</code>:<br>我最常用的是<code>ps ax</code> ：</p><p><img src=img/000007.png alt></p><blockquote><p>The <code>a</code> option is used to also list other users processes, not just our own. <code>x</code> shows processes not linked to any terminal
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>o</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>b</mi><mi>y</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>g</mi><mi>h</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">not initiated by users through a terminal</annotation></semantics></math></span>
.<br><code>a</code>选项还用于列出其他用户进程，而不仅仅是我们自己的进程。 <code>x</code>显示未链接到任何终端的进程（不是由用户通过终端启动的）。</p></blockquote><p>As you can see, the longer commands are cut. Use the command <code>ps axww</code> to continue the command listing on a new line instead of cutting it:<br>正如您所看到的，较长的命令被删除了。使用命令<code>ps axww</code>在新行上继续列出命令而不是剪切它：</p><p><img src=img/000008.png alt></p><blockquote><p>We need to specify <code>w</code> 2 times to apply this setting, it&rsquo;s not a typo.<br>我们需要指定<code>w</code> 2 次才能应用此设置，这不是拼写错误。</p></blockquote><p>You can search for a specific process combining <code>grep</code> with a pipe, like this:<br>您可以将<code>grep</code>与管道结合起来搜索特定进程，如下所示：</p><pre><code>ps axww | grep     &quot;Visual Studio Code&quot;    
</code></pre><p><img src=img/000009.png alt></p><p>The columns returned by <code>ps</code> represent some key information.<br><code>ps</code>返回的列代表一些关键信息。</p><p>The first information is <code>PID</code>, the process ID. This is key when you want to reference this process in another command, for example to kill it.<br>第一个信息是<code>PID</code> ，即进程 ID。当您想在另一个命令中引用此进程（例如杀死它）时，这是关键。</p><p>Then we have <code>TT</code> that tells us the terminal id used.<br>然后我们有<code>TT</code>告诉我们所使用的终端 ID。</p><p>Then <code>STAT</code> tells us the state of the process:<br>然后<code>STAT</code>告诉我们进程的状态：</p><p><code>I</code> a process that is idle
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>l</mi><mi>e</mi><mi>e</mi><mi>p</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi>r</mi><mi>t</mi><mi>h</mi><mi>a</mi><mi>n</mi><mi>a</mi><mi>b</mi><mi>o</mi><mi>u</mi><mi>t</mi><mn>20</mn><mi>s</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>d</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">sleeping for longer than about 20 seconds</annotation></semantics></math></span>
<code>R</code> a runnable process <code>S</code> a process that is sleeping for less than about 20 seconds <code>T</code> a stopped process <code>U</code> a process in uninterruptible wait <code>Z</code> a dead process
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∗</mo><mi>z</mi><mi>o</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>e</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">a *zombie*</annotation></semantics></math></span><br><code>I</code>一个空闲进程（休眠时间超过约 20 秒） <code>R</code>一个可运行的进程 <code>S</code>睡眠时间少于 20 秒的进程 <code>T</code>已停止的进程 <code>U</code>进程处于不间断等待状态 <code>Z</code>死进程（<em>僵尸</em>）</p><p>If you have more than one letter, the second represents further information, which can be very technical.<br>如果您有多个字母，第二个字母代表更多信息，这可能非常技术性。</p><p>It&rsquo;s common to have <code>+</code> which indicates the process is in the foreground in its terminal. <code>s</code> means the process is a <a href=https://unix.stackexchange.com/questions/18166/what-are-session-leaders-in-ps>session leader</a>.<br>通常有<code>+</code>表示该进程位于终端的前台。 <code>s</code>表示该进程是<a href=https://unix.stackexchange.com/questions/18166/what-are-session-leaders-in-ps>会话领导者</a>。</p><p><code>TIME</code> tells us how long the process has been running.<br><code>TIME</code>告诉我们该进程已经运行了多长时间。</p><h2 id=top>top
<a class=anchor href=#top>#</a></h2><p>A quick guide to the <code>top</code> command, used to list the processes running in real time<br><code>top</code>命令快速指南，用于列出实时运行的进程</p><p>The <code>top</code> command is used to display dynamic real-time information about running processes in the system.<br><code>top</code>命令用于显示系统中正在运行的进程的动态实时信息。</p><p>It&rsquo;s really handy to understand what is going on.<br>了解正在发生的事情真的很方便。</p><p>Its usage is simple, you just type <code>top</code>, and the terminal will be fully immersed in this new view:<br>它的用法很简单，你只需输入<code>top</code> ，终端就会完全沉浸在这个新视图中：</p><p><img src=img/000010.png alt></p><p>The process is long-running. To quit, you can type the <code>q</code> letter or <code>ctrl-C</code>.<br>该过程是长期运行的。要退出，您可以输入<code>q</code>字母或<code>ctrl-C</code> 。</p><p>There&rsquo;s a lot of information being given to us: the number of processes, how many are running or sleeping, the system load, the CPU usage, and a lot more.<br>我们获得了很多信息：进程数、正在运行或休眠的进程数、系统负载、CPU 使用率等等。</p><p>Below, the list of processes taking the most memory and CPU is constantly updated.<br>下面，占用最多内存和 CPU 的进程列表不断更新。</p><p>By default, as you can see from the <code>%CPU</code> column highlighted, they are sorted by the CPU used.<br>默认情况下，正如您从突出显示的<code>%CPU</code>列中看到的那样，它们按使用的 CPU 排序。</p><p>You can add a flag to sort processes by memory utilized:<br>您可以添加一个标志来按内存使用情况对进程进行排序：</p><pre><code>top -o mem
</code></pre><h2 id=kill>kill
<a class=anchor href=#kill>#</a></h2><p>Linux processes can receive <strong>signals</strong> and react to them.<br>Linux 进程可以接收<strong>信号</strong>并对信号做出反应。</p><p>That&rsquo;s one way we can interact with running programs.<br>这是我们与正在运行的程序交互的一种方式。</p><p>The <code>kill</code> program can send a variety of signals to a program.<br><code>kill</code>程序可以向程序发送各种信号。</p><p>It&rsquo;s not just used to terminate a program, like the name would suggest, but that&rsquo;s its main job.<br>正如其名称所暗示的那样，它不仅仅用于终止程序，但这才是它的主要工作。</p><p>We use it in this way:<br>我们这样使用它：</p><pre><code>kill     &lt;PID&gt;
</code></pre><p>By default, this sends the <code>TERM</code> signal to the process id specified.<br>默认情况下，这会将<code>TERM</code>信号发送到指定的进程 ID。</p><p>We can use flags to send other signals, including:<br>我们可以使用标志来发送其他信号，包括：</p><pre><code>kill     -HUP &lt;PID&gt;    kill     -INT &lt;PID&gt;    kill     -KILL &lt;PID&gt;    kill     -TERM &lt;PID&gt;    kill     -CONT &lt;PID&gt;    kill     -STOP &lt;PID&gt;
</code></pre><p><code>HUP</code> means <strong>hang up</strong>. It&rsquo;s sent automatically when a terminal window that started a process is closed before terminating the process.<br><code>HUP</code>意思是<strong>挂断</strong>。当启动进程的终端窗口在终止进程之前关闭时，它会自动发送。</p><p><code>INT</code> means <strong>interrupt</strong>, and it sends the same signal used when we press <code>ctrl-C</code> in the terminal, which usually terminates the process.<br><code>INT</code>表示<strong>中断</strong>，它发送的信号与我们在终端中按<code>ctrl-C</code>时使用的信号相同，这通常会终止进程。</p><p><code>KILL</code> is not sent to the process, but to the operating system kernel, which immediately stops and terminates the process.<br><code>KILL</code>不是发送给进程，而是发送给操作系统内核，操作系统内核会立即停止并终止进程。</p><p><code>TERM</code> means <strong>terminate</strong>. The process will receive it and terminate itself. It&rsquo;s the default signal sent by <code>kill</code>.<br><code>TERM</code>意思是<strong>终止</strong>。该进程将收到它并自行终止。这是<code>kill</code>发送的默认信号。</p><p><code>CONT</code> means <strong>continue</strong>. It can be used to resume a stopped process.<br><code>CONT</code>表示<strong>继续</strong>。它可用于恢复停止的进程。</p><p><code>STOP</code> is not sent to the process, but to the operating system kernel, which immediately stops
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>u</mi><mi>t</mi><mi>d</mi><mi>o</mi><mi>e</mi><mi>s</mi><mi>n</mi><mi>o</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">but does not terminate</annotation></semantics></math></span>
the process.<br><code>STOP</code>不会发送到进程，而是发送到操作系统内核，操作系统内核会立即停止（但不会终止）进程。</p><p>You might see numbers used instead, like <code>kill -1 &lt;PID></code>. In this case,<br>您可能会看到使用数字，例如<code>kill -1 &lt;PID></code> 。在这种情况下，</p><p><code>1</code> corresponds to <code>HUP</code>. <code>2</code> corresponds to <code>INT</code>. <code>9</code> corresponds to <code>KILL</code>. <code>15</code> corresponds to <code>TERM</code>. <code>18</code> corresponds to <code>CONT</code>. <code>15</code> corresponds to <code>STOP</code>.<br><code>1</code>对应于<code>HUP</code> 。 <code>2</code>对应于<code>INT</code> 。 <code>9</code>对应于<code>KILL</code> 。 <code>15</code>对应于<code>TERM</code> 。 <code>18</code>对应于<code>CONT</code> 。 <code>15</code>对应于<code>STOP</code> 。</p><h2 id=killall>killall
<a class=anchor href=#killall>#</a></h2><p>Similar to the <code>kill</code> command, <code>killall</code> instead of sending a signal to a specific process id will send the signal to multiple processes at once.<br>与<code>kill</code>命令类似， <code>killall</code>不是向特定进程id发送信号，而是一次向多个进程发送信号。</p><p>This is the syntax:<br>这是语法：</p><pre><code>killall &lt;name&gt;
</code></pre><p>where <code>name</code> is the name of a program. For example you can have multiple instances of the <code>top</code> program running, and <code>killall top</code> will terminate them all.<br>其中<code>name</code>是程序的名称。例如，您可以运行多个<code>top</code>程序实例， <code>killall top</code>将终止它们。</p><p>You can specify the signal, like with <code>kill</code>
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>d</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi mathvariant="normal">‘</mi><mi>k</mi><mi>i</mi><mi>l</mi><mi>l</mi><mi mathvariant="normal">‘</mi><mi>t</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>a</mi><mi>l</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>m</mi><mi>o</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>b</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>s</mi><mi>p</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>c</mi><mi>k</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>s</mi><mi>o</mi><mi>f</mi><mi>s</mi><mi>i</mi><mi>g</mi><mi>n</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>w</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">and check the `kill` tutorial to read more about the specific kinds of signals we can send</annotation></semantics></math></span>
, for example:<br>您可以指定信号，就像使用<code>kill</code>一样（并查看<code>kill</code>教程以了解有关我们可以发送的特定类型信号的更多信息），例如：</p><pre><code>killall -HUP top
</code></pre><h2 id=jobs>jobs
<a class=anchor href=#jobs>#</a></h2><p>When we run a command in Linux / macOS, we can set it to run in the background using the <code>&</code> symbol after the command. For example we can run <code>top</code> in the background:<br>当我们在Linux / macOS中运行命令时，我们可以使用命令后面的<code>&</code>符号将其设置为在后台运行。例如我们可以在后台运行<code>top</code> ：</p><pre><code>top &amp;
</code></pre><p>This is very handy for long-running programs.<br>这对于长时间运行的程序非常方便。</p><p>We can get back to that program using the <code>fg</code> command. This works fine if we just have one job in the background, otherwise we need to use the job number: <code>fg 1</code>, <code>fg 2</code> and so on. To get the job number, we use the <code>jobs</code> command.<br>我们可以使用<code>fg</code>命令返回该程序。如果我们在后台只有一项作业，那么这很好用，否则我们需要使用作业编号： <code>fg 1</code> 、 <code>fg 2</code>等等。要获取作业编号，我们使用<code>jobs</code>命令。</p><p>Say we run <code>top &</code> and then <code>top -o mem &</code>, so we have 2 top instances running. <code>jobs</code> will tell us this:<br>假设我们运行<code>top &</code>然后运行<code>top -o mem &</code> ，所以我们有 2 个 top 实例正在运行。 <code>jobs</code>会告诉我们这一点：</p><p><img src=img/000011.png alt></p><p>Now we can switch back to one of those using <code>fg &lt;jobid></code>. To stop the program again we can hit <code>cmd-Z</code>.<br>现在我们可以切换回使用<code>fg &lt;jobid></code>的其中之一。要再次停止程序，我们可以点击<code>cmd-Z</code> 。</p><p>Running <code>jobs -l</code> will also print the process id of each job.<br>运行<code>jobs -l</code>还将打印每个作业的进程 ID。</p><h2 id=bg>bg
<a class=anchor href=#bg>#</a></h2><p>When a command is running you can suspend it using <code>ctrl-Z</code>.<br>当命令正在运行时，您可以使用<code>ctrl-Z</code>暂停它。</p><p>The command will immediately stop, and you get back to the shell terminal.<br>该命令将立即停止，您将返回到 shell 终端。</p><p>You can resume the execution of the command in the background, so it will keep running but it will not prevent you from doing other work in the terminal.<br>您可以在后台恢复该命令的执行，因此它将继续运行，但不会阻止您在终端中执行其他工作。</p><p>In this example I have 2 commands stopped:<br>在此示例中，我停止了 2 个命令：</p><p><img src=img/000022.png alt></p><p>I can run <code>bg 1</code> to resume in the background the execution of the job #1.<br>我可以运行<code>bg 1</code>在后台恢复作业 #1 的执行。</p><p>I could have also said <code>bg</code> without any option, as the default is to pick the job #1 in the list.<br>我也可以说<code>bg</code>而不带任何选项，因为默认是选择列表中的作业#1。</p><h2 id=fg>fg
<a class=anchor href=#fg>#</a></h2><p>When a command is running in the background, because you started it with <code>&</code> at the end (example: <code>top &</code> or because you put it in the background with the <code>bg</code> command, you can put it to the foreground using <code>fg</code>.<br>当命令在后台运行时，因为您以<code>&</code>结尾（例如： <code>top &</code>或因为您使用<code>bg</code>命令将其置于后台，所以可以使用<code>fg</code>将其置于前台。</p><p>Running<br>跑步</p><pre><code>fg    
</code></pre><p>will resume to the foreground the last job that was suspended.<br>将恢复到前台上次暂停的作业。</p><p>You can also specify which job you want to resume to the foreground passing the job number, which you can get using the <code>jobs</code> command.<br>您还可以通过作业编号指定要恢复到前台的作业，可以使用<code>jobs</code>命令获取作业编号。</p><p><img src=img/000023.png alt></p><p>Running <code>fg 2</code> will resume job #2:<br>运行<code>fg 2</code>将恢复作业#2：</p><p><img src=img/000024.png alt></p><h2 id=type>type
<a class=anchor href=#type>#</a></h2><p>A command can be one of those 4 types:<br>命令可以是以下 4 种类型之一：</p><ul><li>an executable<br>一个可执行文件</li><li>a shell built-in program<br>shell 内置程序</li><li>a shell function<br>一个外壳函数</li><li>an alias<br>别名</li></ul><p>The <code>type</code> command can help figure out this, in case we want to know or we&rsquo;re just curious. It will tell you how the command will be interpreted.<br><code>type</code>命令可以帮助弄清楚这一点，以防我们想知道或者只是好奇。它会告诉您如何解释该命令。</p><p>The output will depend on the shell used. This is Bash:<br>输出将取决于所使用的 shell。这是巴什：</p><p><img src=img/000025.png alt></p><p>This is Zsh:<br>这是 Zsh：</p><p><img src=img/000026.png alt></p><p>This is Fish:<br>这是鱼：</p><p><img src=img/000027.png alt></p><p>One of the most interesting things here is that for aliases it will tell you what is aliasing to. You can see the <code>ll</code> alias, in the case of Bash and Zsh, but Fish provides it by default, so it will tell you it&rsquo;s a built-in shell function.<br>这里最有趣的事情之一是，对于别名，它会告诉您别名是什么。在 Bash 和 Zsh 中，您可以看到<code>ll</code>别名，但 Fish 默认提供它，因此它会告诉您这是一个内置的 shell 函数。</p><h2 id=which>which
<a class=anchor href=#which>#</a></h2><p>Suppose you have a command you can execute, because it&rsquo;s in the shell path, but you want to know where it is located.<br>假设您有一个可以执行的命令，因为它位于 shell 路径中，但您想知道它所在的位置。</p><p>You can do so using <code>which</code>. The command will return the path to the command specified:<br>您可以使用<code>which</code>来执行此操作。该命令将返回指定命令的路径：</p><p><img src=img/000028.png alt></p><p><code>which</code> will only work for executables stored on disk, not aliases or built-in shell functions.<br><code>which</code>适用于存储在磁盘上的可执行文件，不适用于别名或内置 shell 函数。</p><h2 id=nohup>nohup
<a class=anchor href=#nohup>#</a></h2><p>Sometimes you have to run a long-lived process on a remote machine, and then you need to disconnect.<br>有时您必须在远程计算机上运行长期进程，然后需要断开连接。</p><p>Or you simply want to prevent the command to be halted if there&rsquo;s any network issue between you and the server.<br>或者您只是想防止命令在您和服务器之间出现任何网络问题时停止。</p><p>The way to make a command run even after you log out or close the session to a server is to use the <code>nohup</code> command.<br>即使在注销或关闭服务器会话后仍运行命令的方法是使用<code>nohup</code>命令。</p><p>Use <code>nohup &lt;command></code> to let the process continue working even after you log out.<br>使用<code>nohup &lt;command></code>让进程在您注销后继续工作。</p><h2 id=xargs>xargs
<a class=anchor href=#xargs>#</a></h2><p>The <code>xargs</code> command is used in a UNIX shell to convert input from standard input into arguments to a command.<br><code>xargs</code>命令在 UNIX shell 中用于将输入从标准输入转换为命令的参数。</p><p>In other words, through the use of <code>xargs</code> the output of a command is used as the input of another command.<br>换句话说，通过使用<code>xargs</code>一个命令的输出被用作另一个命令的输入。</p><p>Here&rsquo;s the syntax you will use:<br>这是您将使用的语法：</p><pre><code>command1 | xargs command2
</code></pre><p>We use a pipe
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`|`</annotation></semantics></math></span>
to pass the output to <code>xargs</code>. That will take care of running the <code>command2</code> command, using the output of <code>command1</code> as its argument
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span>
.<br>我们使用管道
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex"> `|` </annotation></semantics></math></span>
将输出传递给<code>xargs</code> 。这将负责运行<code>command2</code>命令，并使用<code>command1</code>的输出作为其参数。</p><p>Let&rsquo;s do a simple example. You want to remove some specific files from a directory. Those files are listed inside a text file.<br>我们来做一个简单的例子。您想要从目录中删除某些特定文件。这些文件列在文本文件中。</p><p>We have 3 files: <code>file1</code>, <code>file2</code>, <code>file3</code>.<br>我们有 3 个文件： <code>file1</code> 、 <code>file2</code> 、 <code>file3</code> 。</p><p>In <code>todelete.txt</code> we have a list of files we want to delete, in this example <code>file1</code> and <code>file3</code>:<br>在<code>todelete.txt</code>中，我们有一个要删除的文件列表，在本例中为<code>file1</code>和<code>file3</code> ：</p><p><img src=img/000081.png alt></p><p>We will channel the output of <code>cat todelete.txt</code> to the <code>rm</code> command, through <code>xargs</code>.<br>我们将通过<code>xargs</code>将<code>cat todelete.txt</code>的输出引导到<code>rm</code>命令。</p><p>In this way:<br>这样：</p><pre><code>cat todelete.txt | xargs rm
</code></pre><p>That&rsquo;s the result, the files we listed are now deleted:<br>这就是结果，我们列出的文件现在已被删除：</p><p><img src=img/000082.png alt></p><p>The way it works is that <code>xargs</code> will run <code>rm</code> 2 times, one for each line returned by <code>cat</code>.<br>它的工作方式是<code>xargs</code>将运行<code>rm</code> 2 次， <code>cat</code>返回的每一行运行一次。</p><p>This is the simplest usage of <code>xargs</code>. There are several options we can use.<br>这是<code>xargs</code>最简单的用法。我们可以使用多种选项。</p><p>One of the most useful in my opinion, especially when starting to learn <code>xargs</code>, is <code>-p</code>. Using this option will make <code>xargs</code> print a confirmation prompt with the action it&rsquo;s going to take:<br>我认为最有用的之一是<code>-p</code> ，尤其是在开始学习<code>xargs</code>时。使用此选项将使<code>xargs</code>打印一条确认提示，其中包含将要采取的操作：</p><p><img src=img/000083.png alt></p><p>The <code>-n</code> option lets you tell <code>xargs</code> to perform one iteration at a time, so you can individually confirm them with <code>-p</code>. Here we tell <code>xargs</code> to perform one iteration at a time with <code>-n1</code>:<br><code>-n</code>选项允许您告诉<code>xargs</code>一次执行一次迭代，因此您可以使用<code>-p</code>单独确认它们。在这里，我们告诉<code>xargs</code>使用<code>-n1</code>一次执行一次迭代：</p><p><img src=img/000084.png alt></p><p>The <code>-I</code> option is another widely used one. It allows you to get the output into a placeholder, and then you can do various things.<br><code>-I</code>选项是另一个广泛使用的选项。它允许您将输出放入占位符中，然后您可以执行各种操作。</p><p>One of them is to run multiple commands:<br>其中之一是运行多个命令：</p><pre><code>command1 | xargs -I % /bin/bash -c     'command2 %; command3 %'    
</code></pre><p><img src=img/000085.png alt></p><blockquote><p>You can swap the <code>%</code> symbol I used above with anything else, it&rsquo;s a variable<br>您可以将我上面使用的<code>%</code>符号替换为其他符号，它是一个变量</p></blockquote><h2 id=vim>vim
<a class=anchor href=#vim>#</a></h2><p><code>vim</code> is a <strong>very</strong> popular file editor, especially among programmers. It&rsquo;s actively developed and frequently updated, and there&rsquo;s a very big community around it. There&rsquo;s even a <a href=https://vimconf.org/>Vim conference</a>!<br><code>vim</code>是一种<strong>非常</strong>流行的文件编辑器，尤其是在程序员中。它得到了积极的开发和频繁的更新，并且有一个非常大的社区。甚至还有<a href=https://vimconf.org/>Vim 会议</a>！</p><p><code>vi</code> in modern systems is just an alias to <code>vim</code>, which means <code>vi</code> i<code>m</code>proved.<br>现代系统中的<code>vi</code>只是<code>vim</code>的别名，这意味着<code>vi</code> i <code>m</code>被证明。</p><p>You start it by running <code>vi</code> on the command line.<br>您可以通过在命令行上运行<code>vi</code>来启动它。</p><p><img src=img/000114.png alt></p><p>You can specify a filename at invocation time to edit that specific file:<br>您可以在调用时指定文件名来编辑该特定文件：</p><pre><code>vi test.txt
</code></pre><p><img src=img/000113.png alt></p><p>You have to know that Vim has 2 main modes:<br>你要知道 Vim 有 2 个主要模式：</p><ul><li><em>command</em>
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>r</mi><mo>∗</mo><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">or *normal*</annotation></semantics></math></span>
mode<br><em>命令</em>（或<em>正常</em>）模式</li><li><em>insert</em> mode<br><em>插入</em>模式</li></ul><p>When you start the editor, you are in command mode. You can&rsquo;t enter text like you expect from a GUI-based editor. You have to enter <strong>insert mode</strong>. You can do this by pressing the <code>i</code> key. Once you do so, the <code>-- INSERT --</code> word appear at the bottom of the editor:<br>当您启动编辑器时，您处于命令模式。您无法像在基于 GUI 的编辑器中那样输入文本。您必须进入<strong>插入模式</strong>。您可以通过按<code>i</code>键来执行此操作。一旦你这样做了， <code>-- INSERT --</code>这个词就会出现在编辑器的底部：</p><p><img src=img/000115.png alt></p><p>Now you can start typing and filling the screen with the file contents:<br>现在您可以开始输入文件内容并在屏幕上填充：</p><p><img src=img/000116.png alt></p><p>You can move around the file with the arrow keys, or using the <code>h</code> - <code>j</code> - <code>k</code> - <code>l</code> keys. <code>h-l</code> for left-right, <code>j-k</code> for down-up.<br>您可以使用箭头键或使用<code>h</code> - <code>j</code> - <code>k</code> - <code>l</code>键在文件中移动。 <code>hl</code>代表左-右， <code>jk</code>代表下-上。</p><p>Once you are done editing you can press the <code>esc</code> key to exit insert mode, and go back to <strong>command mode</strong>.<br>完成编辑后，您可以按<code>esc</code>键退出插入模式，然后返回<strong>命令模式</strong>。</p><p><img src=img/000117.png alt></p><p>At this point you can navigate the file, but you can&rsquo;t add content to it
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>n</mi><mi>d</mi><mi>b</mi><mi>e</mi><mi>c</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi>u</mi><mi>l</mi><mi>w</mi><mi>h</mi><mi>i</mi><mi>c</mi><mi>h</mi><mi>k</mi><mi>e</mi><mi>y</mi><mi>s</mi><mi>y</mi><mi>o</mi><mi>u</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>y</mi><mi>m</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>b</mi><mi>e</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi>m</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">and be careful which keys you press as they might be commands</annotation></semantics></math></span>
.<br>此时，您可以导航该文件，但无法向其中添加内容（并且要小心按下的键，因为它们可能是命令）。</p><p>One thing you might want to do now is <strong>saving the file</strong>. You can do so by pressing <code>:</code>
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">colon</annotation></semantics></math></span>
, then <code>w</code>.<br>您现在可能想做的一件事是<strong>保存文件</strong>。您可以通过按<code>:</code>冒号），然后<code>w</code>来执行此操作。</p><p>You can <strong>save and quit</strong> pressing <code>:</code> then <code>w</code> and <code>q</code>: <code>:wq</code><br>您可以**保存并退出，**按<code>:</code>然后按<code>w</code>和<code>q</code> : <code>:wq</code></p><p>You can <strong>quit without saving</strong>, pressing <code>:</code> then <code>q</code> and <code>!</code>: <code>:q!</code><br>您可以<strong>退出而不保存</strong>，按<code>:</code>然后按<code>q</code>和<code>!</code> :: <code>:q!</code></p><p>You can <strong>undo</strong> and edit by going to command mode and pressing <code>u</code>. You can <strong>redo</strong>
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi>l</mi><mi>a</mi><mi>n</mi><mi>u</mi><mi>n</mi><mi>d</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">cancel an undo</annotation></semantics></math></span>
by pressing <code>ctrl-r</code>.<br>您可以通过进入命令模式并按<code>u</code><strong>来撤消</strong>和编辑。您可以按<code>ctrl-r</code><strong>重做</strong>（取消撤消）。</p><p>Those are the basics of working with Vim. From here starts a rabbit hole we can&rsquo;t go into in this little introduction.<br>这些是使用 Vim 的基础知识。从这里开始，我们无法在这个小介绍中进入一个兔子洞。</p><p>I will only mention those commands that will get you started editing with Vim:<br>我只会提到那些可以让你开始使用 Vim 进行编辑的命令：</p><ul><li>pressing the <code>x</code> key deletes the character currently highlighted<br>按<code>x</code>键删除当前突出显示的字符</li><li>pressing <code>A</code> goes at the end of the currently selected line<br>按<code>A</code>转到当前所选行的末尾</li><li>press <code>0</code> to go to the start of the line<br>按<code>0</code>转到行首</li><li>go to the first character of a word and press <code>d</code> followed by <code>w</code> to delete that word. If you follow it with <code>e</code> instead of <code>w</code>, the white space before the next word is preserved<br>转到单词的第一个字符，然后按<code>d</code>然后按<code>w</code>删除该单词。如果您使用<code>e</code>而不是<code>w</code> ，则保留下一个单词之前的空格</li><li>use a number between <code>d</code> and <code>w</code> to delete more than 1 word, for example use <code>d3w</code> to delete 3 words forward<br>使用<code>d</code>和<code>w</code>之间的数字删除 1 个以上的单词，例如使用<code>d3w</code>向前删除 3 个单词</li><li>press <code>d</code> followed by <code>d</code> to delete a whole entire line. Press <code>d</code> followed by <code>$</code> to delete the entire line from where the cursor is, until the end<br>按<code>d</code>然后按<code>d</code>可删除整行。按<code>d</code>后按<code>$</code>可删除从光标所在位置开始的整行，直到末尾</li></ul><p>To find out more about Vim I can recommend the <a href=https://vimhelp.org/vim_faq.txt.html>Vim FAQ</a> and especially running the <code>vimtutor</code> command, which should already be installed in your system and will greatly help you start your <code>vim</code> explorations.<br>要了解有关 Vim 的更多信息，我可以推荐<a href=https://vimhelp.org/vim_faq.txt.html>Vim FAQ</a> ，特别是运行<code>vimtutor</code>命令，该命令应该已经安装在您的系统中，并将极大地帮助您开始您的<code>vim</code>探索。</p><h2 id=emacs>emacs
<a class=anchor href=#emacs>#</a></h2><p><code>emacs</code> is an awesome editor and it&rsquo;s historically regarded as <em>the</em> editor for UNIX systems. Famously <code>vi</code> vs <code>emacs</code> flame wars and heated discussions caused many unproductive hours for developers around the world.<br><code>emacs</code>是一个很棒的编辑器，历来被认为是 UNIX 系统的<em>编辑</em>器。众所周知， <code>vi</code>与<code>emacs</code>的激烈争论和激烈的讨论导致世界各地的开发人员花费了很多时间，毫无成效。</p><p><code>emacs</code> is very powerful. Some people use it all day long as a kind of operating system
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>h</mi><mi>t</mi><mi>t</mi><mi>p</mi><mi>s</mi><mo>:</mo><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mi>n</mi><mi>e</mi><mi>w</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>y</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>m</mi><mo stretchy="false">?</mo><mi>i</mi><mi>d</mi><mo>=</mo><mn>19127258</mn><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>h</mi><mi>t</mi><mi>t</mi><mi>p</mi><mi>s</mi><mo>:</mo><mi mathvariant="normal">/</mi><mi mathvariant="normal">/</mi><mi>n</mi><mi>e</mi><mi>w</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>y</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi>b</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>m</mi><mo stretchy="false">?</mo><mi>i</mi><mi>d</mi><mo>=</mo><mn>19127258</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[https://news.ycombinator.com/item?id=19127258](https://news.ycombinator.com/item?id=19127258)</annotation></semantics></math></span>
. We&rsquo;ll just talk about the basics here.<br><code>emacs</code>非常强大。有些人整天把它当作一种操作系统来使用（ <a href="https://news.ycombinator.com/item?id=19127258">https://news.ycombinator.com/item?id=19127258</a> ）。我们在这里只讨论基础知识。</p><p>You can open a new emacs session simply by invoking <code>emacs</code>:<br>您只需调用<code>emacs</code>即可打开新的 emacs 会话：</p><p><img src=img/000118.png alt></p><blockquote><p>macOS users, stop a second now. If you are on Linux there are no problems, but macOS does not ship applications using GPLv3, and every built-in UNIX command that has been updated to GPLv3 has not been updated. While there is a little problem with the commands I listed up to now, in this case using an emacs version from 2007 is not exactly the same as using a version with 12 years of improvements and change. This is not a problem with Vim, which is up to date. To fix this, run <code>brew install emacs</code> and running <code>emacs</code> will use the new version from Homebrew
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>k</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>r</mi><mi>e</mi><mi>y</mi><mi>o</mi><mi>u</mi><mi>h</mi><mi>a</mi><mi>v</mi><mi>e</mi><mi>H</mi><mi>o</mi><mi>m</mi><mi>e</mi><mi>b</mi><mi>r</mi><mi>e</mi><mi>w</mi><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">make sure you have Homebrew installed</annotation></semantics></math></span><br>macOS 用户，请停下来。如果您使用的是 Linux，则没有问题，但 macOS 不提供使用 GPLv3 的应用程序，并且已更新到 GPLv3 的每个内置 UNIX 命令尚未更新。虽然我到目前为止列出的命令存在一些问题，但在这种情况下，使用 2007 年的 emacs 版本与使用经过 12 年改进和更改的版本并不完全相同。这对于 Vim 来说不是问题，它是最新的。要解决此问题，请运行<code>brew install emacs</code> ，并且运行<code>emacs</code>将使用Homebrew的新版本（确保您已安装Homebrew ）</p></blockquote><p>You can also edit an existing file calling <code>emacs &lt;filename></code>:<br>您还可以编辑调用<code>emacs &lt;filename></code>的现有文件：</p><p><img src=img/000119.png alt></p><p>You can start editing and once you are done, press <code>ctrl-x</code> followed by <code>ctrl-w</code>. You confirm the folder:<br>您可以开始编辑，完成后，按<code>ctrl-x</code> ，然后按<code>ctrl-w</code> 。您确认该文件夹：</p><p><img src=img/000120.png alt></p><p>and Emacs tell you the file exists, asking you if it should overwrite it:<br>Emacs 会告诉您该文件存在，并询问您是否应该覆盖它：</p><p><img src=img/000121.png alt></p><p>Answer <code>y</code>, and you get a confirmation of success:<br>回答<code>y</code> ，您将收到成功确认信息：</p><p><img src=img/000122.png alt></p><p>You can exit Emacs pressing <code>ctrl-x</code> followed by <code>ctrl-c</code>. Or <code>ctrl-x</code> followed by <code>c</code>
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mi>e</mi><mi>e</mi><mi>p</mi><mi mathvariant="normal">‘</mi><mi>c</mi><mi>t</mi><mi>r</mi><mi>l</mi><mi mathvariant="normal">‘</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">keep `ctrl` pressed</annotation></semantics></math></span>
.<br>您可以按<code>ctrl-x</code>然后按<code>ctrl-c</code>退出 Emacs。或者按<code>ctrl-x</code>后跟<code>c</code> （按住<code>ctrl</code>不放）。</p><p>There is a lot to know about Emacs. More than I am able to write in this little introduction. I encourage you to open Emacs and press <code>ctrl-h</code> <code>r</code> to open the built-in manual and <code>ctrl-h</code> <code>t</code> to open the official tutorial.<br>关于 Emacs 有很多东西需要了解。我在这个小小的介绍中无法写出更多内容。我鼓励你打开 Emacs 并按<code>ctrl-h</code> <code>r</code>打开内置手册，按<code>ctrl-h</code> <code>t</code>打开官方教程。</p><h2 id=nano>nano
<a class=anchor href=#nano>#</a></h2><p><code>nano</code> is a beginner friendly editor.<br><code>nano</code>是一个适合初学者的编辑器。</p><p>Run it using <code>nano &lt;filename></code>.<br>使用<code>nano &lt;filename></code>运行它。</p><p>You can directly type characters into the file without worrying about modes.<br>您可以直接在文件中键入字符，而不必担心模式。</p><p>You can quit without editing using <code>ctrl-X</code>. If you edited the file buffer, the editor will ask you for confirmation and you can save the edits, or discard them. The help at the bottom shows you the keyboard commands that let you work with the file:<br>您可以使用<code>ctrl-X</code>退出而不进行编辑。如果您编辑了文件缓冲区，编辑器将要求您确认，您可以保存编辑或放弃它们。底部的帮助显示了可让您使用该文件的键盘命令：</p><p><img src=img/000112.png alt></p><p><code>pico</code> is more or less the same, although <code>nano</code> is the GNU version of <code>pico</code> which at some point in history was not open source and the <code>nano</code> clone was made to satisfy the GNU operating system license requirements.<br><code>pico</code>或多或少是相同的，尽管<code>nano</code>是<code>pico</code>的 GNU 版本，在历史上的某个时刻它不是开源的，并且<code>nano</code>克隆是为了满足 GNU 操作系统许可要求而制作的。</p><h2 id=whoami>whoami
<a class=anchor href=#whoami>#</a></h2><p>Type <code>whoami</code> to print the user name currently logged in to the terminal session:<br>输入<code>whoami</code>以打印当前登录到终端会话的用户名：</p><p><img src=img/000033.png alt></p><blockquote><p>Note: this is different from the <code>who am i</code> command, which prints more information<br>注意：这与<code>who am i</code>命令不同，后者打印更多信息</p></blockquote><h2 id=who>who
<a class=anchor href=#who>#</a></h2><p>The <code>who</code> command displays the users logged in to the system.<br><code>who</code>命令显示登录到系统的用户。</p><p>Unless you&rsquo;re using a server multiple people have access to, chances are you will be the only user logged in, multiple times:<br>除非您使用的服务器可供多人访问，否则您很可能是唯一多次登录的用户：</p><p><img src=img/000029.png alt></p><p>Why multiple times? Because each shell opened will count as an access.<br>为什么要多次？因为每次打开的shell都会算作一次访问。</p><p>You can see the name of the terminal used, and the time/day the session was started.<br>您可以看到所使用的终端的名称以及会话开始的时间/日期。</p><p>The <code>-aH</code> flags will tell <code>who</code> to display more information, including the idle time and the process ID of the terminal:<br><code>-aH</code>标志将告诉<code>who</code>显示更多信息，包括空闲时间和终端的进程 ID：</p><p><img src=img/000030.png alt></p><p>The special <code>who am i</code> command will list the current terminal session details:<br>特殊的<code>who am i</code>命令将列出当前终端会话详细信息：</p><p><img src=img/000031.png alt></p><p><img src=img/000032.png alt></p><h2 id=su>su
<a class=anchor href=#su>#</a></h2><p>While you&rsquo;re logged in to the terminal shell with one user, you might have the need to switch to another user.<br>当您使用一个用户登录到终端 shell 时，您可能需要切换到另一用户。</p><p>For example you&rsquo;re logged in as root to perform some maintenance, but then you want to switch to a user account.<br>例如，您以 root 身份登录来执行一些维护，但随后您想要切换到用户帐户。</p><p>You can do so with the <code>su</code> command:<br>您可以使用<code>su</code>命令来执行此操作：</p><pre><code>su &lt;username&gt;
</code></pre><p>For example: <code>su flavio</code>.<br>例如： <code>su flavio</code> 。</p><p>If you&rsquo;re logged in as a user, running <code>su</code> without anything else will prompt to enter the <code>root</code> user password, as that&rsquo;s the default behavior.<br>如果您以用户身份登录，则运行<code>su</code>而不执行任何其他操作将提示输入<code>root</code>用户密码，因为这是默认行为。</p><p><img src=img/000035.png alt></p><p><code>su</code> will start a new shell as another user.<br><code>su</code>将以另一个用户身份启动一个新的 shell。</p><p>When you&rsquo;re done, typing <code>exit</code> in the shell will close that shell, and will return back to the current user&rsquo;s shell.<br>完成后，在 shell 中键入<code>exit</code>将关闭该 shell，并返回到当前用户的 shell。</p><h2 id=sudo>sudo
<a class=anchor href=#sudo>#</a></h2><p><code>sudo</code> is commonly used to run a command as root.<br><code>sudo</code>通常用于以 root 身份运行命令。</p><p>You must be enabled to use <code>sudo</code>, and once you do, you can run commands as root by entering your user&rsquo;s password
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo><mi>n</mi><mi>o</mi><mi>t</mi><mo>∗</mo><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>p</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">*not* the root user password</annotation></semantics></math></span>
.<br>您必须能够使用<code>sudo</code> ，一旦启用，您就可以通过输入用户密码（<em>而不是</em>root 用户密码）以 root 身份运行命令。</p><p>The permissions are highly configurable, which is great especially in a multi-user server environment, and some users can be granted access to running specific commands through <code>sudo</code>.<br>权限是高度可配置的，这在多用户服务器环境中尤其有用，并且可以通过<code>sudo</code>授予某些用户运行特定命令的访问权限。</p><p>For example you can edit a system configuration file:<br>例如，您可以编辑系统配置文件：</p><pre><code>sudo nano /etc/hosts
</code></pre><p>which would otherwise fail to save since you don&rsquo;t have the permissions for it.<br>否则将无法保存，因为您没有权限。</p><p>You can run <code>sudo -i</code> to start a shell as root:<br>您可以运行<code>sudo -i</code>以 root 身份启动 shell：</p><p><img src=img/000036.png alt></p><p>You can use <code>sudo</code> to run commands as any user. <code>root</code> is the default, but use the <code>-u</code> option to specify another user:<br>您可以使用<code>sudo</code>以任何用户身份运行命令。 <code>root</code>是默认用户，但使用<code>-u</code>选项指定另一个用户：</p><pre><code>sudo -u flavio ls /Users/flavio
</code></pre><h2 id=passwd>passwd
<a class=anchor href=#passwd>#</a></h2><p>Users in Linux have a password assigned. You can change the password using the <code>passwd</code> command.<br>Linux 中的用户已分配一个密码。您可以使用<code>passwd</code>命令更改密码。</p><p>There are two situations here.<br>这里有两种情况。</p><p>The first is when you want to change your password. In this case you type:<br>第一个是当您想要更改密码时。在这种情况下，您输入：</p><pre><code>passwd
</code></pre><p>and an interactive prompt will ask you for the old password, then it will ask you for the new one:<br>交互式提示会要求您输入旧密码，然后会要求您输入新密码：</p><p><img src=img/000040.png alt></p><p>When you&rsquo;re <code>root</code>
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>r</mi><mi>h</mi><mi>a</mi><mi>v</mi><mi>e</mi><mi>s</mi><mi>u</mi><mi>p</mi><mi>e</mi><mi>r</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>p</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>i</mi><mi>l</mi><mi>e</mi><mi>g</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">or have superuser privileges</annotation></semantics></math></span>
you can set the username of which you want to change the password:<br>当您是<code>root</code> （或具有超级用户权限）时，您可以设置要更改密码的用户名：</p><pre><code>passwd &lt;username&gt; &lt;new password&gt;
</code></pre><p>In this case you don&rsquo;t need to enter the old one.<br>在这种情况下，您无需输入旧的。</p><h2 id=ping>ping
<a class=anchor href=#ping>#</a></h2><p>The <code>ping</code> command pings a specific network host, on the local network or on the Internet.<br><code>ping</code>命令对本地网络或 Internet 上的特定网络主机执行 ping 操作。</p><p>You use it with the syntax <code>ping &lt;host></code> where <code>&lt;host></code> could be a domain name, or an IP address.<br>您可以使用语法<code>ping &lt;host></code>来使用它，其中<code>&lt;host></code>可以是域名或 IP 地址。</p><p>Here&rsquo;s an example pinging <code>google.com</code>:<br>以下是 ping <code>google.com</code>示例：</p><p><img src=img/000090.png alt></p><p>The commands sends a request to the server, and the server returns a response.<br>命令向服务器发送请求，服务器返回响应。</p><p><code>ping</code> keep sending the request every second, by default, and will keep running until you stop it with <code>ctrl-C</code>, unless you pass the number of times you want to try with the <code>-c</code> option: <code>ping -c 2 google.com</code>.<br>默认情况下， <code>ping</code>每秒都会发送请求，并且将继续运行，直到您使用<code>ctrl-C</code>停止它为止，除非您通过<code>-c</code>选项传递了您想要尝试的次数： <code>ping -c 2 google.com</code> 。</p><p>Once <code>ping</code> is stopped, it will print some statistics about the results: the percentage of packages lost, and statistics about the network performance.<br>一旦<code>ping</code>停止，它将打印一些有关结果的统计信息：丢失包的百分比以及有关网络性能的统计信息。</p><p>As you can see the screen prints the host IP address, and the time that it took to get the response back.<br>正如您所看到的，屏幕打印了主机 IP 地址以及获取响应所需的时间。</p><p>Not all servers support pinging, in case the requests times out:<br>并非所有服务器都支持 ping，以防请求超时：</p><p><img src=img/000089.png alt></p><p>Sometimes this is done on purpose, to &ldquo;hide&rdquo; the server, or just to reduce the load. The ping packets can also be filtered by firewalls.<br>有时这是故意这样做的，以“隐藏”服务器，或者只是为了减少负载。 ping 数据包也可以被防火墙过滤。</p><p><code>ping</code> works using the <strong>ICMP protocol</strong>
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>t</mi><mi>C</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>l</mi><mi>M</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>a</mi><mi>g</mi><mi>e</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>t</mi><mi>o</mi><mi>c</mi><mi>o</mi><mi>l</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">*Internet Control Message Protocol*</annotation></semantics></math></span>
, a network layer protocol just like TCP or UDP.<br><code>ping</code>使用<strong>ICMP 协议</strong>（<em>​​互联网控制消息协议</em>）进行工作，这是一种网络层协议，就像 TCP 或 UDP 一样。</p><p>The request sends a packet to the server with the <code>ECHO_REQUEST</code> message, and the server returns a <code>ECHO_REPLY</code> message. I won&rsquo;t go into details, but this is the basic concept.<br>请求向服务器发送带有<code>ECHO_REQUEST</code>消息的数据包，服务器返回<code>ECHO_REPLY</code>消息。我不会详细说明，但这是基本概念。</p><p>Pinging a host is useful to know if the host is reachable
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>p</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mi>p</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">supposing it implements ping</annotation></semantics></math></span>
, and how distant it is in terms of how long it takes to get back to you. Usually the nearest the server is geographically, the less time it will take to return back to you, for simple physical laws that cause a longer distance to introduce more delay in the cables.<br>对主机执行 Ping 操作有助于了解该主机是否可达（假设它实现了 ping），以及与您联系所需的时间有多远。通常，服务器在地理位置上越近，返回给您所需的时间就越短，因为简单的物理定律会导致距离较长，从而在电缆中引入更多延迟。</p><h2 id=traceroute>traceroute
<a class=anchor href=#traceroute>#</a></h2><p>When you try to reach a host on the Internet, you go through your home router, then you reach your ISP network, which in turn goes through its own upstream network router, and so on, until you finally reach the host.<br>当您尝试访问互联网上的主机时，您将通过家庭路由器，然后到达 ISP 网络，ISP 网络又通过其自己的上游网络路由器，依此类推，直到您最终到达主机。</p><p>Have you ever wanted to know what are the steps that your packets go through to do that?<br>您是否想知道您的数据包要经过哪些步骤才能做到这一点？</p><p>The <code>traceroute</code> command is made for this.<br><code>traceroute</code>命令就是为此而设计的。</p><p>You invoke<br>你调用</p><pre><code>traceroute &lt;host&gt;
</code></pre><p>and it will
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>l</mi><mi>o</mi><mi>w</mi><mi>l</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">slowly</annotation></semantics></math></span>
gather all the information while the packet travels.<br>它会在数据包传输过程中（慢慢地）收集所有信息。</p><p>In this example I tried reaching for my blog with <code>traceroute flaviocopes.com</code>:<br>在此示例中，我尝试使用<code>traceroute flaviocopes.com</code>访问我的博客：</p><p><img src=img/000092.png alt></p><p>Not every router travelled returns us information. In this case, <code>traceroute</code> prints <code>* * *</code>. Otherwise, we can see the hostname, the IP address, and some performance indicator.<br>并非每个经过的路由器都会向我们返回信息。在这种情况下， <code>traceroute</code>会打印<code>* * *</code> 。否则，我们可以看到主机名、IP 地址和一些性能指标。</p><p>For every router we can see 3 samples, which means traceroute tries by default 3 times to get you a good indication of the time needed to reach it. This is why it takes this long to execute <code>traceroute</code> compared to simply doing a <code>ping</code> to that host.<br>对于每个路由器，我们可以看到 3 个样本，这意味着默认情况下，traceroute 会尝试 3 次，以便您很好地了解到达该路由器所需的时间。这就是为什么与简单地对该主机执行<code>ping</code>相比，执行<code>traceroute</code>需要这么长时间。</p><p>You can customize this number with the <code>-q</code> option:<br>您可以使用<code>-q</code>选项自定义此数字：</p><pre><code>traceroute -q 1 flaviocopes.com
</code></pre><p><img src=img/000093.png alt></p><h2 id=clear>clear
<a class=anchor href=#clear>#</a></h2><p>Type <code>clear</code> to clear all the previous commands that were ran in the current terminal.<br>键入<code>clear</code>以清除当前终端中运行的所有先前命令。</p><p>The screen will clear and you will just see the prompt at the top:<br>屏幕将清除，您只会在顶部看到提示：</p><p><img src=img/000034.png alt></p><blockquote><p>Note: this command has a handy shortcut: <code>ctrl-L</code><br>注意：此命令有一个方便的快捷键： <code>ctrl-L</code></p></blockquote><p>Once you do that, you will lose access to scrolling to see the output of the previous commands entered.<br>一旦执行此操作，您将无法滚动查看先前输入的命令的输出。</p><p>So you might want to use <code>clear -x</code> instead, which still clears the screen, but lets you go back to see the previous work by scrolling up.<br>因此，您可能想使用<code>clear -x</code> ，它仍然会清除屏幕，但可以让您通过向上滚动返回查看之前的工作。</p><h2 id=history>history
<a class=anchor href=#history>#</a></h2><p>Every time we run a command, that&rsquo;s memorized in the history.<br>每次我们运行命令时，它都会被记录在历史记录中。</p><p>You can display all the history using:<br>您可以使用以下命令显示所有历史记录：</p><pre><code>history    
</code></pre><p>This shows the history with numbers:<br>这用数字显示了历史：</p><p><img src=img/000041.png alt></p><p>You can use the syntax <code>!&lt;command number></code> to repeat a command stored in the history, in the above example typing <code>!121</code> will repeat the <code>ls -al | wc -l</code> command.<br>您可以使用语法<code>!&lt;command number></code>来重复存储在历史记录中的命令，在上面的示例中键入<code>!121</code>将重复<code>ls -al | wc -l</code>命令。</p><p>Typically the last 500 commands are stored in the history.<br>通常，最后 500 个命令存储在历史记录中。</p><p>You can combine this with <code>grep</code> to find a command you ran:<br>您可以将其与<code>grep</code>结合起来查找您运行的命令：</p><pre><code>history     | grep docker
</code></pre><p><img src=img/000042.png alt></p><p>To clear the history, run <code>history -c</code><br>要清除历史记录，请运行<code>history -c</code></p><h2 id=export>export
<a class=anchor href=#export>#</a></h2><p>The <code>export</code> command is used to export variables to child processes.<br><code>export</code>命令用于将变量导出到子进程。</p><p>What does this mean?<br>这意味着什么？</p><p>Suppose you have a variable TEST defined in this way:<br>假设您有一个这样定义的变量 TEST：</p><pre><code>TEST=    &quot;test&quot;    
</code></pre><p>You can print its value using <code>echo $TEST</code>:<br>您可以使用<code>echo $TEST</code>打印其值：</p><p><img src=img/000095.png alt></p><p>But if you try defining a Bash script in a file <code>script.sh</code> with the above command:<br>但是，如果您尝试使用上述命令在<code>script.sh</code>文件中定义 Bash 脚本：</p><p><img src=img/000096.png alt></p><p>Then you set <code>chmod u+x script.sh</code> and you execute this script with <code>./script.sh</code>, the <code>echo $TEST</code> line will print nothing!<br>然后设置<code>chmod u+x script.sh</code>并使用<code>./script.sh</code>执行此脚本， <code>echo $TEST</code>行将不打印任何内容！</p><p>This is because in Bash the <code>TEST</code> variable was defined local to the shell. When executing a shell script or another command, a subshell is launched to execute it, which does not contain the current shell local variables.<br>这是因为在 Bash 中， <code>TEST</code>变量是在 shell 本地定义的。当执行 shell 脚本或其他命令时，会启动一个子 shell 来执行它，该子 shell 不包含当前 shell 局部变量。</p><p>To make the variable available there we need to define <code>TEST</code> not in this way:<br>为了使变量在那里可用，我们需要不以这种方式定义<code>TEST</code> ：</p><pre><code>TEST=    &quot;test&quot;    
</code></pre><p>but in this way:<br>但这样：</p><pre><code>export     TEST=    &quot;test&quot;    
</code></pre><p>Try that, and running <code>./script.sh</code> now should print &ldquo;test&rdquo;:<br>尝试一下，现在运行<code>./script.sh</code>应该打印“test”：</p><p><img src=img/000097.png alt></p><p>Sometimes you need to append something to a variable. It&rsquo;s often done with the <code>PATH</code> variable. You use this syntax:<br>有时您需要向变量附加一些内容。通常通过<code>PATH</code>变量来完成。您使用以下语法：</p><pre><code>export     PATH=    $PATH    :/new/path
</code></pre><p>It&rsquo;s common to use <code>export</code> when you create new variables in this way, but also when you create variables in the <code>.bash_profile</code> or <code>.bashrc</code> configuration files with Bash, or in <code>.zshenv</code> with Zsh.<br>当您以这种方式创建新变量时，以及当您使用 Bash 在<code>.bash_profile</code>或<code>.bashrc</code>配置文件中创建变量，或者使用 Zsh 在<code>.zshenv</code>中创建变量时，通常会使用<code>export</code> 。</p><p>To remove a variable, use the <code>-n</code> option:<br>要删除变量，请使用<code>-n</code>选项：</p><pre><code>export     -n TEST
</code></pre><p>Calling <code>export</code> without any option will list all the exported variables.<br>不带任何选项调用<code>export</code>将列出所有导出的变量。</p><h2 id=crontab>crontab
<a class=anchor href=#crontab>#</a></h2><p>Cron jobs are jobs that are scheduled to run at specific intervals. You might have a command perform something every hour, or every day, or every 2 weeks. Or on weekends. They are very powerful, especially on servers to perform maintenance and automations.<br>Cron 作业是计划以特定时间间隔运行的作业。您可能有一个命令每小时、每天或每两周执行一些操作。或者在周末。它们非常强大，特别是在服务器上执行维护和自动化。</p><p>The <code>crontab</code> command is the entry point to work with cron jobs.<br><code>crontab</code>命令是使用 cron 作业的入口点。</p><p>The first thing you can do is to explore which cron jobs are defined by you:<br>您可以做的第一件事是探索您定义了哪些 cron 作业：</p><pre><code>crontab -l
</code></pre><p>You might have none, like me:<br>你可能没有，就像我一样：</p><p><img src=img/000098.png alt></p><p>Run<br>跑步</p><pre><code>crontab -e
</code></pre><p>to edit the cron jobs, and add new ones.<br>编辑 cron 作业并添加新作业。</p><p>By default this opens with the default editor, which is usually <code>vim</code>. I like <code>nano</code> more, you can use this line to use a different editor:<br>默认情况下，它会使用默认编辑器打开，通常是<code>vim</code> 。我更喜欢<code>nano</code> ，你可以使用这一行来使用不同的编辑器：</p><pre><code>EDITOR=nano crontab -e
</code></pre><p>Now you can add one line for each cron job.<br>现在您可以为每个 cron 作业添加一行。</p><p>The syntax to define cron jobs is kind of scary. This is why I usually use a website to help me generate it without errors: <a href=https://crontab-generator.org/>https://crontab-generator.org/</a><br>定义 cron 作业的语法有点可怕。这就是为什么我通常使用一个网站来帮助我生成它而不会出现错误： <a href=https://crontab-generator.org/>https</a> ://crontab-generator.org/</p><p><img src=img/000099.png alt></p><p>You pick a time interval for the cron job, and you type the command to execute.<br>您为 cron 作业选择一个时间间隔，然后键入要执行的命令。</p><p>I chose to run a script located in <code>/Users/flavio/test.sh</code> every 12 hours. This is the crontab line I need to run:<br>我选择每 12 小时运行一次位于<code>/Users/flavio/test.sh</code>中的脚本。这是我需要运行的 crontab 行：</p><pre><code>* */12 * * * /Users/flavio/test.sh &gt;/dev/null 2&gt;&amp;1
</code></pre><p>I run <code>crontab -e</code>:<br>我运行<code>crontab -e</code> ：</p><pre><code>EDITOR=nano crontab -e
</code></pre><p>and I add that line, then I press <code>ctrl-X</code> and press <code>y</code> to save.<br>我添加该行，然后按<code>ctrl-X</code>并按<code>y</code>保存。</p><p>If all goes well, the cron job is set up:<br>如果一切顺利，则 cron 作业已设置：</p><p><img src=img/000100.png alt></p><p>Once this is done, you can see the list of active cron jobs by running:<br>完成此操作后，您可以通过运行以下命令查看活动 cron 作业的列表：</p><pre><code>crontab -l
</code></pre><p><img src=img/000101.png alt></p><p>You can remove a cron job running <code>crontab -e</code> again, removing the line and exiting the editor:<br>您可以删除再次运行<code>crontab -e</code> cron 作业，删除该行并退出编辑器：</p><p><img src=img/000102.png alt><img src=img/000103.png alt></p><h2 id=uname>uname
<a class=anchor href=#uname>#</a></h2><p>Calling <code>uname</code> without any options will return the Operating System codename:<br>不带任何选项调用<code>uname</code>将返回操作系统代号：</p><p><img src=img/000056.png alt></p><p>The <code>m</code> option shows the hardware name
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>x</mi><mn>8</mn><msub><mn>6</mn><mn>6</mn></msub><mn>4</mn><mi mathvariant="normal">‘</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi>e</mi><mi>x</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">`x86_64` in this example</annotation></semantics></math></span>
and the <code>p</code> option prints the processor architecture name
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>i</mi><mn>386</mn><mi mathvariant="normal">‘</mi><mi>i</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mi>e</mi><mi>x</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">`i386` in this example</annotation></semantics></math></span>
:<br><code>m</code>选项显示硬件名称（本例中为<code>x86_64</code> ）， <code>p</code>选项打印处理器架构名称（本例中为<code>i386</code> ）：</p><p><img src=img/000057.png alt></p><p>The <code>s</code> option prints the Operating System name. <code>r</code> prints the release, <code>v</code> prints the version:<br><code>s</code>选项打印操作系统名称。 <code>r</code>打印版本， <code>v</code>打印版本：</p><p><img src=img/000058.png alt></p><p>The <code>n</code> option prints the node network name:<br><code>n</code>选项打印节点网络名称：</p><p><img src=img/000059.png alt></p><p>The <code>a</code> option prints all the information available:<br><code>a</code>选项打印所有可用的信息：</p><p><img src=img/000060.png alt></p><p>On macOS you can also use the <code>sw_vers</code> command to print more information about the macOS Operating System. Note that this differs from the Darwin
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>h</mi><mi>e</mi><mi>K</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>e</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">the Kernel</annotation></semantics></math></span>
version, which above is <code>19.6.0</code>.<br>在 macOS 上，您还可以使用<code>sw_vers</code>命令打印有关 macOS 操作系统的更多信息。请注意，这与 Darwin（内核）版本不同，上面是<code>19.6.0</code> 。</p><blockquote><p>Darwin is the name of the kernel of macOS. The kernel is the &ldquo;core&rdquo; of the Operating System, while the Operating System as a whole is called macOS. In Linux, Linux is the kernel, GNU/Linux would be the Operating System name, although we all refer to it as &ldquo;Linux&rdquo;<br>Darwin 是 macOS 内核的名称。内核是操作系统的“核心”，而整个操作系统称为 macOS。在 Linux 中，Linux 是内核，GNU/Linux 是操作系统名称，尽管我们都将其称为“Linux”</p></blockquote><p><img src=img/000061.png alt></p><h2 id=env>env
<a class=anchor href=#env>#</a></h2><p>The <code>env</code> command can be used to pass environment variables without setting them on the outer environment
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>h</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mi>h</mi><mi>e</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">the current shell</annotation></semantics></math></span>
.<br><code>env</code>命令可用于传递环境变量，而无需在外部环境（当前 shell）上设置它们。</p><p>Suppose you want to run a Node.js app and set the <code>USER</code> variable to it.<br>假设您要运行 Node.js 应用程序并将<code>USER</code>变量设置为其。</p><p>You can run<br>你可以运行</p><pre><code>env USER=flavio node app.js
</code></pre><p>and the <code>USER</code> environment variable will be accessible from the Node.js app via the Node <code>process.env</code> interface.<br>并且可以通过 Node.js 应用程序通过 Node <code>process.env</code>接口访问<code>USER</code>环境变量。</p><p>You can also run the command clearing all the environment variables already set, using the <code>-i</code> option:<br>您还可以使用<code>-i</code>选项运行命令清除已设置的所有环境变量：</p><pre><code>env -i node app.js
</code></pre><p>In this case you will get an error saying <code>env: node: No such file or directory</code> because the <code>node</code> command is not reachable, as the <code>PATH</code> variable used by the shell to look up commands in the common paths is unset.<br>在这种情况下，您会收到一条错误消息 <code>env: node: No such file or directory</code> 因为<code>node</code>命令不可访问，因为 shell 用于在公共路径中查找命令的<code>PATH</code>变量未设置。</p><p>So you need to pass the full path to the <code>node</code> program:<br>因此需要将完整路径传递给<code>node</code>程序：</p><pre><code>env -i /usr/    local    /bin/node app.js
</code></pre><p>Try with a simple <code>app.js</code> file with this content:<br>尝试使用包含以下内容的简单<code>app.js</code>文件：</p><pre><code>console    .log(process.env.NAME)    console    .log(process.env.PATH)
</code></pre><p>You will see the output being<br>你会看到输出是</p><pre><code>undefined
undefined
</code></pre><p>You can pass an env variable:<br>您可以传递一个环境变量：</p><pre><code>env -i NAME=flavio node app.js
</code></pre><p>and the output will be<br>输出将是</p><pre><code>flavio
undefined
</code></pre><p>Removing the <code>-i</code> option will make <code>PATH</code> available again inside the program:<br>删除<code>-i</code>选项将使<code>PATH</code>在程序内再次可用：</p><p><img src=img/000108.png alt></p><p>The <code>env</code> command can also be used to print out all the environment variables, if ran with no options:<br>如果运行时没有选项， <code>env</code>命令还可以用于打印所有环境变量：</p><pre><code>env
</code></pre><p>it will return a list of the environment variables set, for example:<br>它将返回环境变量集的列表，例如：</p><pre><code>HOME=/Users/flavio
LOGNAME=flavio
PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Apple/usr/bin
PWD=/Users/flavio
SHELL=/usr/local/bin/fish
</code></pre><p>You can also make a variable inaccessible inside the program you run, using the <code>-u</code> option, for example this code removes the <code>HOME</code> variable from the command environment:<br>您还可以使用<code>-u</code>选项使变量在运行的程序内不可访问，例如以下代码从命令环境中删除<code>HOME</code>变量：</p><pre><code>env -u HOME node app.js
</code></pre><h2 id=printenv>printenv
<a class=anchor href=#printenv>#</a></h2><p>A quick guide to the <code>printenv</code> command, used to print the values of environment variables<br><code>printenv</code>命令快速指南，用于打印环境变量的值</p><p>In any shell there are a good number of environment variables, set either by the system, or by your own shell scripts and configuration.<br>在任何 shell 中都有大量的环境变量，这些变量可以由系统设置，也可以由您自己的 shell 脚本和配置设置。</p><p>You can print them all to the terminal using the <code>printenv</code> command. The output will be something like this:<br>您可以使用<code>printenv</code>命令将它们全部打印到终端。输出将是这样的：</p><pre><code>HOME=/Users/flavio
LOGNAME=flavio
PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Apple/usr/bin
PWD=/Users/flavio
SHELL=/usr/local/bin/fish
</code></pre><p>with a few more lines, usually.<br>通常还有几行。</p><p>You can append a variable name as a parameter, to only show that variable value:<br>您可以附加变量名称作为参数，以仅显示该变量值：</p><pre><code>printenv PATH
</code></pre><p><img src=img/000107.png alt></p><h2 id=conclusion>Conclusion
<a class=anchor href=#conclusion>#</a></h2><p><strong>结论</strong></p><p>Thanks a lot for reading this book.<br>非常感谢您阅读这本书。</p><p>For more, head over to <a href=https://flaviocopes.com>flaviocopes.com</a>.<br>如需了解更多信息，请访问<a href=https://flaviocopes.com>flaviocopes.com</a> 。</p><p>Send any feedback, errata or opinions at <a href=mailto:flavio@flaviocopes.com>flavio@flaviocopes.com</a><br>请将任何反馈、勘误表或意见发送至flavio@flaviocopes.com</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#command意义>Command意义</a></li><li><a href=#系统-unix和windows>系统-Unix和Windows</a></li><li><a href=#freesoftware开源>FreeSoftware，开源</a></li><li><a href=#trueunix>TrueUNIX</a></li><li><a href=#shell>shell</a></li><li><a href=#setup-and-installing>setup and installing</a><ul><li><a href=#windowssubsystem>WindowsSubsystem</a></li></ul></li><li><a href=#the-linux-handbook电子书内容>The Linux Handbook(电子书内容)</a><ul><li><a href=#preface>Preface</a></li><li><a href=#introduction-to-linux>Introduction to Linux</a></li><li><a href=#man>man</a></li><li><a href=#ls>ls</a></li><li><a href=#cd>cd</a></li><li><a href=#pwd>pwd</a></li><li><a href=#mkdir>mkdir</a></li><li><a href=#rmdir>rmdir</a></li><li><a href=#mv>mv</a></li><li><a href=#cp>cp</a></li><li><a href=#open>open</a></li><li><a href=#touch>touch</a></li><li><a href=#find>find</a></li><li><a href=#ln>ln</a></li><li><a href=#gzip>gzip</a></li><li><a href=#gunzip>gunzip</a></li><li><a href=#tar>tar</a></li><li><a href=#alias>alias</a></li><li><a href=#cat>cat</a></li><li><a href=#less>less</a></li><li><a href=#tail>tail</a></li><li><a href=#wc>wc</a></li><li><a href=#grep>grep</a></li><li><a href=#sort>sort</a></li><li><a href=#uniq>uniq</a></li><li><a href=#diff>diff</a></li><li><a href=#echo>echo</a></li><li><a href=#chown>chown</a></li><li><a href=#chmod>chmod</a></li><li><a href=#umask>umask</a></li><li><a href=#du>du</a></li><li><a href=#df>df</a></li><li><a href=#basename>basename</a></li><li><a href=#dirname>dirname</a></li><li><a href=#ps>ps</a></li><li><a href=#top>top</a></li><li><a href=#kill>kill</a></li><li><a href=#killall>killall</a></li><li><a href=#jobs>jobs</a></li><li><a href=#bg>bg</a></li><li><a href=#fg>fg</a></li><li><a href=#type>type</a></li><li><a href=#which>which</a></li><li><a href=#nohup>nohup</a></li><li><a href=#xargs>xargs</a></li><li><a href=#vim>vim</a></li><li><a href=#emacs>emacs</a></li><li><a href=#nano>nano</a></li><li><a href=#whoami>whoami</a></li><li><a href=#who>who</a></li><li><a href=#su>su</a></li><li><a href=#sudo>sudo</a></li><li><a href=#passwd>passwd</a></li><li><a href=#ping>ping</a></li><li><a href=#traceroute>traceroute</a></li><li><a href=#clear>clear</a></li><li><a href=#history>history</a></li><li><a href=#export>export</a></li><li><a href=#crontab>crontab</a></li><li><a href=#uname>uname</a></li><li><a href=#env>env</a></li><li><a href=#printenv>printenv</a></li><li><a href=#conclusion>Conclusion</a></li></ul></li></ul></nav></div></aside></main></body></html>