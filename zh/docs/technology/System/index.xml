<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SpringCloud on 随记</title><link>https://lwmfjc.github.io/zh/docs/technology/System/</link><description>Recent content in SpringCloud on 随记</description><generator>Hugo</generator><language>zh</language><atom:link href="https://lwmfjc.github.io/zh/docs/technology/System/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B0%81%E9%9D%A2-%E7%9B%AE%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B0%81%E9%9D%A2-%E7%9B%AE%E5%BD%95/</guid><description>&lt;p>&lt;img src="img/84a99ff609e9a3e1c3bea19467abeaed.jpeg" alt="" />&lt;/p>
&lt;p>｀．&lt;/p>
&lt;p>&lt;img src="img/262318a5c6fc43bf03c45143e4e828a3.jpeg" alt="" />&lt;/p>
&lt;p>兰镶尔 E. 布莱恩特&lt;/p>
&lt;p>(Randal E. Bryant)&lt;/p>
&lt;p>1981 年千麻省理工学院获得计算机博士学位 ，&lt;/p>
&lt;p>1984 年至今一直任教 千卡内基－梅隆大学。现任卡内基－梅隆大学计算机科学学院院长、教授，同时还受邀任教 千电子和计算机工程 系。他从事本科生和研究生计算机 系统方面课程的教学近 40 年。他和&lt;/p>
&lt;p>O&amp;rsquo;Hallaron 教授一起在卡内基－梅隆大学开设了15-&lt;/p>
&lt;p>213课程 ”计算机系统导论” ， 该课程即为本书的基础。他还是ACM院士、IEEE院士、美国国家工程院院士和美国 人文与科学研究院院 士。其研究成果被&lt;/p>
&lt;p>Intel 、IBM、Fujitsu 和Microsoft 等主要计算机制造商使用， 他还因研究获得过Semiconductor Research Corporation、ACM、IEEE颁发的多项大奖。&lt;/p>
&lt;p>&lt;img src="img/99e8488313965d2fbd0c5c8526568c26.jpeg" alt="" />&lt;/p>
&lt;p>大卫 R. 奥哈拉伦&lt;/p>
&lt;p>(David R. O&amp;rsquo;Hallaron)&lt;/p>
&lt;p>卡内基－梅隆大学电子和计算 机工程系教授 。在弗吉尼亚大学获得计算机科学的博士学位 ， 2007 年一2010 年为Intel 匹兹堡实验室主任。他教授本科生和研究生的计算机 系统方面的课程已有 20余年， 井和Bryant 教授一起开设了 ”计算机系统导论 ” 课程。曾获得CMU计算机学院颁发的Herbert Simon杰出教学奖。他主要从事计算机系统领域的研究 ， 与&lt;/p>
&lt;p>Quake项目成员一起获得过高性能计算领域中的最高 国际奖项—-G ordon Bell奖。他目前的工作重点是研究自动分级 ( autograding ) 概念， 即评价其他程序质量的程序。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC10%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7I_O/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC10%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7I_O/</guid><description>&lt;p>第 10 章&lt;/p>
&lt;p>C H A P T E R 10&lt;/p>
&lt;p>系统级 1 /0&lt;/p>
&lt;h3 id="输入扴出10-是在主存和外部设备例如磁盘驱动器终端和网络之间复制数据的过程输入操作是从-i-0-设备复制数据到主存-而输出操作是从主存复制数据到10-设备">
 输入／扴出(1/0 )是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。输入操作是从 I/ 0 设备复制数据到主存， 而输出操作是从主存复制数据到1/0 设备。
 &lt;a class="anchor" href="#%e8%be%93%e5%85%a5%e6%89%b4%e5%87%ba10-%e6%98%af%e5%9c%a8%e4%b8%bb%e5%ad%98%e5%92%8c%e5%a4%96%e9%83%a8%e8%ae%be%e5%a4%87%e4%be%8b%e5%a6%82%e7%a3%81%e7%9b%98%e9%a9%b1%e5%8a%a8%e5%99%a8%e7%bb%88%e7%ab%af%e5%92%8c%e7%bd%91%e7%bb%9c%e4%b9%8b%e9%97%b4%e5%a4%8d%e5%88%b6%e6%95%b0%e6%8d%ae%e7%9a%84%e8%bf%87%e7%a8%8b%e8%be%93%e5%85%a5%e6%93%8d%e4%bd%9c%e6%98%af%e4%bb%8e-i-0-%e8%ae%be%e5%a4%87%e5%a4%8d%e5%88%b6%e6%95%b0%e6%8d%ae%e5%88%b0%e4%b8%bb%e5%ad%98-%e8%80%8c%e8%be%93%e5%87%ba%e6%93%8d%e4%bd%9c%e6%98%af%e4%bb%8e%e4%b8%bb%e5%ad%98%e5%a4%8d%e5%88%b6%e6%95%b0%e6%8d%ae%e5%88%b010-%e8%ae%be%e5%a4%87">#&lt;/a>
&lt;/h3>
&lt;p>所有语言的运行时系统都 提供执行 1/ 0 的较高级别的工具。例如， ANSI C 提供标准1/ 0 库， 包含像 pr i n t f 和 s c a n f 这样执行带 缓冲区的 I/ 0 函数。C++ 语言用它的重载操作符＜＜（输入）和＞＞（输出）提供了类似的功能 。在 Lin ux 系统中， 是通过使用由内核提供的系统级 U nix I/ 0 函数来实现这些较高级别的 I/ 0 函数的。大多数时候，高 级别 1/ 0 函数工作良好， 没有必要直接使用 U nix I/ 0 。那么为什么还要麻烦地学习 U nix 1/ 0 呢？&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC11%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC11%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid><description>&lt;p>第 1 1 章&lt;/p>
&lt;h4 id="c-h-a-p-t-e-r-11">
 C H A P T E R 11
 &lt;a class="anchor" href="#c-h-a-p-t-e-r-11">#&lt;/a>
&lt;/h4>
&lt;p>网络编程&lt;/p>
&lt;h3 id="网络应用随处可见任何时候浏览-w-eb-发送-ema-il-信息或是玩在线游戏-你就正在使用网络应用程序有趣的-是-所有的网络应用都是基千相同的基本编程模型-有着相似的整体逻辑结构并且依赖相同的编程接口">
 网络应用随处可见。任何时候浏览 W eb 、发送 ema il 信息或是玩在线游戏， 你就正在使用网络应用程序。有趣的 是， 所有的网络应用都是基千相同的基本编程模型， 有着相似的整体逻辑结构，并且依赖相同的编程接口。
 &lt;a class="anchor" href="#%e7%bd%91%e7%bb%9c%e5%ba%94%e7%94%a8%e9%9a%8f%e5%a4%84%e5%8f%af%e8%a7%81%e4%bb%bb%e4%bd%95%e6%97%b6%e5%80%99%e6%b5%8f%e8%a7%88-w-eb-%e5%8f%91%e9%80%81-ema-il-%e4%bf%a1%e6%81%af%e6%88%96%e6%98%af%e7%8e%a9%e5%9c%a8%e7%ba%bf%e6%b8%b8%e6%88%8f-%e4%bd%a0%e5%b0%b1%e6%ad%a3%e5%9c%a8%e4%bd%bf%e7%94%a8%e7%bd%91%e7%bb%9c%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e6%9c%89%e8%b6%a3%e7%9a%84-%e6%98%af-%e6%89%80%e6%9c%89%e7%9a%84%e7%bd%91%e7%bb%9c%e5%ba%94%e7%94%a8%e9%83%bd%e6%98%af%e5%9f%ba%e5%8d%83%e7%9b%b8%e5%90%8c%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%9e%8b-%e6%9c%89%e7%9d%80%e7%9b%b8%e4%bc%bc%e7%9a%84%e6%95%b4%e4%bd%93%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84%e5%b9%b6%e4%b8%94%e4%be%9d%e8%b5%96%e7%9b%b8%e5%90%8c%e7%9a%84%e7%bc%96%e7%a8%8b%e6%8e%a5%e5%8f%a3">#&lt;/a>
&lt;/h3>
&lt;p>网络应用依 赖于很多在系统 研究中巳经学习过的概念。例如， 进程、信号、字节顺序、内存映射以及动态内存 分配， 都扮演着 重要的角色。还有一些新概念要掌握。我们需要理解基本的客户端－服务器编程模型 ， 以及如何编写使 用因特网提供的服务的客户端－服务器程序。最后 ， 我们将把所有这些概念结合起来， 开发一个虽小但功能齐全的 Web 服务器 ， 能够为真实的 Web 浏览器提供静态和动态的 文本和图形内容。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>1 客户端－服务器编程模型&lt;/p>
&lt;p>每个网络应用都是基千客户端－服务器模型的。采用这个模型，一个应用是由一个服 务器进 程和一个或者多个客户端 进程组 成。服务器管理某种资源， 并且通过操作这种资濒来为它的客户端提供某种服务。例如， 一个 Web 服务器管理着一组磁盘文件， 它会代表客户端进行检索和执行。一个 FT P 服务器管理着一组磁盘文件，它 会为客户端进行存储和检索。相似地 ， 一个电子邮件服务器管理着一些文件，它 为客户端进行读和更新。&lt;/p>
&lt;p>客户端－服务器模 型中的基本操作是 事务 ( t ra nsaction )( 见图 11-1) 。一个客户端－服务器事务由以下四步组成。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC12%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC12%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid><description>&lt;p>第 12 章&lt;/p>
&lt;p>C H A P T E R 12 . . . _&lt;/p>
&lt;p>并发编程&lt;/p>
&lt;p>正如我们在第 8 章学到的 ， 如果逻辑控制流在时间上重叠， 那么它们就是并发的 ( concu rr e nt ) 。这种常见的现象称为并发 ( co nc urr e ncy ) , 出现在计算机系统的许多不同层面上。硬件 异常处理程序、进程和 L in ux 信号处理程序都是 大家很熟悉的例子。&lt;/p>
&lt;p>到目前为止，我们主要将并发看做是一种操作系统内核用来运行多个应用程序的机 制。但是， 并发不仅仅局限 于内核。它也可以在应用程序中 扮演重要角色。例如，我 们已经看到 Linux 信号处理程序如何允许应用响应异步事件， 例如用户键入 C t rl + C , 或者程序访问虚拟内存的 一个未定义的区域。应用级并发在其他情况下 也是很有用的：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>访问慢速 1/0 设备。当一个应用正在等待来自慢速 1/ 0 设备（例如磁盘）的数据到达时，内 核会运行其他进程，使 CP U 保持繁忙。每个应用都可以按照类似的方式， 通过交替 执行 I/ 0 请求和其他有用的工作来利用并发。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</guid><description>&lt;p>第1章&lt;/p>
&lt;p>CHAPTER1&lt;/p>
&lt;p>计算机系统漫游&lt;/p>
&lt;p>计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有相似的硬件和软件组件，它们又执行着相似的功能。一些程序员希望深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的，以此来提高自身的技能。本书便是为这些读者而写的。&lt;/p>
&lt;p>现在就要开始一次有趣的漫游历程了。如果你全力投身学习本书中的概念，完全理解底层计算机系统以及它对应用程序的影响，那么你会步上成为为数不多的“大牛＂的道路。&lt;/p>
&lt;p>你将会学习一些实践技巧，比如如何避免由计算机表示数字的方式引起的奇怪的数字错误。你将学会怎样通过一些小窍门来优化自己的C代码，以充分利用现代处理器和存储器系统的设计。你将了解编译器是如何实现过程调用的，以及如何利用这些知识来避免缓冲区溢出错误带来的安全漏洞，这些弱点给网络和因特网软件带来了巨大的麻烦。你将学会如何识别和避免链接时那些令人讨厌的错误，它们困扰着普通的程序员。你将学会如何编写自己的Unixshell、自己的动态存储分配包，甚至于自己的Web服务器。你会认识并发带来的希望和陷阱，这个主题随着单个芯片上集成了多个处理器核变得越来越重要。&lt;/p>
&lt;p>在Kernighan和Ritchie的关于C编程语言的经典教材[61]中，他们通过图1-1中所示的hello程序来向读者介绍C。尽管hello程序非常简单，但是为了让它实现运行，系统的每个主要组成部分都需要协调工作。从某种意义上来说，本书的目的就是要帮助你了解当你在系统上执行hello程序时，系统发生了什么以及为什么会这样。&lt;/p>
&lt;p>codelintrolhello.c&lt;/p>
&lt;p>#include &amp;lt;stdio.h&amp;gt;&lt;/p>
&lt;p>int main()&lt;/p>
&lt;p>｛&lt;/p>
&lt;p>printf(&amp;ldquo;hello, world\n&amp;rdquo;); return O;&lt;/p>
&lt;p>｝&lt;/p>
&lt;p>code/intro/he/lo .c&lt;/p>
&lt;p>图 1-1 he ll o 程序（来源： [60])&lt;/p>
&lt;p>我们通过跟踪hello程序的生命周期来开始对系统的学习——从它被程序员创建开始，到在系统上运行，输出简单的消息，然后终止。我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的关键概念、专业术语和组成部分。后面的章节将围绕这些内容展开。&lt;/p>
&lt;h1 id="11">
 1.1
 &lt;a class="anchor" href="#11">#&lt;/a>
&lt;/h1>
&lt;h2 id="信息就是位上下文">
 信息就是位＋上下文
 &lt;a class="anchor" href="#%e4%bf%a1%e6%81%af%e5%b0%b1%e6%98%af%e4%bd%8d%e4%b8%8a%e4%b8%8b%e6%96%87">#&lt;/a>
&lt;/h2>
&lt;p>hello程序的生命周期是从一个源程序（或者说源文件）开始的，即程序员通过编辑器创&lt;/p>
&lt;p>建并保存的文本文件，文件名是hello.c。源程序实际上就是一个由值0和1组成的位（又称为比特）序列，8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。&lt;/p>
&lt;p>大部分的现代计算机系统都使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值e来表示每个字符。比如，图1-2中给出了hello.c程序的ASCII码表示。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>＃&lt;/th>
 &lt;th>i&lt;/th>
 &lt;th>n&lt;/th>
 &lt;th>C&lt;/th>
 &lt;th>1&lt;/th>
 &lt;th>u&lt;/th>
 &lt;th>d&lt;/th>
 &lt;th>e&lt;/th>
 &lt;th>SP&lt;/th>
 &lt;th>＜&lt;/th>
 &lt;th>s&lt;/th>
 &lt;th>t&lt;/th>
 &lt;th>d&lt;/th>
 &lt;th>i&lt;/th>
 &lt;th>。&lt;/th>
 &lt;th>&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>35&lt;/td>
 &lt;td>1 05&lt;/td>
 &lt;td>11 0&lt;/td>
 &lt;td>9 9&lt;/td>
 &lt;td>108&lt;/td>
 &lt;td>11 7&lt;/td>
 &lt;td>1 00&lt;/td>
 &lt;td>1 0 1&lt;/td>
 &lt;td>32&lt;/td>
 &lt;td>60&lt;/td>
 &lt;td>1 15&lt;/td>
 &lt;td>116&lt;/td>
 &lt;td>1 00&lt;/td>
 &lt;td>105&lt;/td>
 &lt;td>111&lt;/td>
 &lt;td>46&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>h&lt;/td>
 &lt;td>＞&lt;/td>
 &lt;td>\ n&lt;/td>
 &lt;td>\n&lt;/td>
 &lt;td>i&lt;/td>
 &lt;td>n&lt;/td>
 &lt;td>t&lt;/td>
 &lt;td>SP&lt;/td>
 &lt;td>m&lt;/td>
 &lt;td>a&lt;/td>
 &lt;td>i&lt;/td>
 &lt;td>n&lt;/td>
 &lt;td>（&lt;/td>
 &lt;td>）&lt;/td>
 &lt;td>\n&lt;/td>
 &lt;td>｛&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>10 4&lt;/td>
 &lt;td>62&lt;/td>
 &lt;td>10&lt;/td>
 &lt;td>1 0&lt;/td>
 &lt;td>105&lt;/td>
 &lt;td>11 0&lt;/td>
 &lt;td>116&lt;/td>
 &lt;td>32&lt;/td>
 &lt;td>109&lt;/td>
 &lt;td>97&lt;/td>
 &lt;td>105&lt;/td>
 &lt;td>110&lt;/td>
 &lt;td>40&lt;/td>
 &lt;td>41&lt;/td>
 &lt;td>10&lt;/td>
 &lt;td>123&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>\ n&lt;/td>
 &lt;td>SP&lt;/td>
 &lt;td>SP&lt;/td>
 &lt;td>SP&lt;/td>
 &lt;td>SP&lt;/td>
 &lt;td>p&lt;/td>
 &lt;td>r&lt;/td>
 &lt;td>i&lt;/td>
 &lt;td>n&lt;/td>
 &lt;td>t&lt;/td>
 &lt;td>f&lt;/td>
 &lt;td>（ II h e 1&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>1 0&lt;/td>
 &lt;td>32&lt;/td>
 &lt;td>32&lt;/td>
 &lt;td>3 2&lt;/td>
 &lt;td>3 2&lt;/td>
 &lt;td>112&lt;/td>
 &lt;td>114&lt;/td>
 &lt;td>105&lt;/td>
 &lt;td>110&lt;/td>
 &lt;td>116&lt;/td>
 &lt;td>10 2&lt;/td>
 &lt;td>40&lt;/td>
 &lt;td>34&lt;/td>
 &lt;td>104&lt;/td>
 &lt;td>101&lt;/td>
 &lt;td>108&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>1 。 SP ｀， 。 r 1 d ＼ n II ） \n SP&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC2%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC2%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</guid><description>&lt;p>第 2 章&lt;/p>
&lt;p>C H A P T E R 2&lt;/p>
&lt;p>信息的表示和处理&lt;/p>
&lt;p>现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称 为位( bit ) , 形成了数字革命的基础。大 家熟悉并使用了 10 00 多年的十进制（以10 为基数） 起源于印度， 在 12 世纪被阿拉伯数学家改进，并 在 13 世纪被意大利数学家 Leona rdo P isano ( 大约公元 11 70- 1250 , 更为大家所熟 知的名字是 Fibo nacci ) 带到西方。对 千有 10 个手指的人类来说，使用十进制表示法是很自然的事情，但是当构造存储和处理信息的机 器时，二进制值工作得更好。二值信号能够很容易地被表示、存储和传输，例如，可以表 示为穿孔卡片上有洞或无洞、导线上的高电压或低电压、或者顺时针或逆时针的磁场。对 二值信号进行存储和执行计算的电子电路非常简单和可靠，制造商能够在一个单独的硅片 上集成数百万甚至数十亿个这样的电路。&lt;/p>
&lt;p>孤立地讲， 单个的位不是非常有用。然而，当把位 组合在一起，再 加上某种解释( inter­ pretation) , 即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。比如， 使用一个二进制数字系统 ， 我们能 够用位组来编码非负数。通过使用标准的字符码， 我们能够对文档中的字母和符号进行编码。在本章中，我们将讨论这两种编码，以及负数 表示和实数近似值的编码。&lt;/p>
&lt;p>我们研究三种最重 要的数字表示。无符号 ( unsig ned ) 编码基千传统的 二进制表示法，&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</guid><description>&lt;p>第 3章
C H A P T E R 3
程序的机器级表示
计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写
存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集
和操作系统遵循的惯例，经过一系列的阶段生成机器代码。 GCCC语言编译器以汇编代码
的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后
GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。在本章中，我们会近
距离地观察机器代码，以及人类可读的表示汇编代码。
当我们用高级语言编程的时候（例如 C语言， Java语言更是如此），机器屏蔽了程序的细节，即机器级的实现。与此相反，当用汇编代码编程的时候（就像早期的计算），程序员必须指定程序用来执行计算的低级指令。高级语言提供的抽象级别比较高，大多数时候，在这种抽象级别上工作效率会更高，也更可靠。编译器提供的类型检查能帮助我们发现许多程序错误，并能够保证按照一致的方式来引用和处理数据。通常情况下，使用现代的优化编译器产生的代码至少与一个熟练的汇编语言程序员手工编写的代码一样有效。最大的优点是，用高级语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关的。
那么为什么我们还要花时间学习机器代码呢？即使编译器承担了生成汇编代码的大部分工作，对于严谨的程序员来说，能够阅读和理解汇编代码仍是一项很重要的技能。以适当的命令行选项调用编译器，编译器就会产生一个以汇编代码形式表示的输出文件。通过阅读这些汇编代码，我们能够理解编译器的优化能力，并分析代码中隐含的低效率。就像我们将在第 5章中体会到的那样，试图最大化一段关键代码性能的程序员，通常会尝试源代码的各种形式，每次编译并检查产生的汇编代码，从而了解程序将要运行的效率如何。此外，也有些时候，高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为。例如，第 12章会讲到，用线程包写并发程序时，了解不同的线程是如何共享程序数据或保持数据私有的，以及准确知道如何在哪里访问共享数据，都是很重要的。这些信息在机器代码级是可见的。另外再举一个例子，程序遭受攻击（使得恶意软件侵扰系统）的许多方式中，都涉及程序存储运行时控制信息的方式的细节。许多攻击利用了系统程序中的漏洞重写信息，从而获得了系统的控制权。了解这些漏洞是如何出现的，以及如何防御它们，需要具备程序机器级表示的知识。程序员学习汇编代码的需求随着时间的推移也发生了变化，开始时要求程序员能直接用汇编语言编写程序，现在则要求他们能够阅读和理解编译器产生的代码。
在本章中，我们将详细学习一种特别的汇编语言，了解如何将 C程序编译成这种形式的机器代码。阅读编译器产生的汇编代码，需要具备的技能不同千手工编写汇编代码。我们必须了解典型的编译器在将 C程序结构变换成机器代码时所做的转换。相对于 C代码表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换慢速操作，甚至将递归计算变换成迭代计算。源代码与对应的汇编代码的关系通常不太容易理解一一凉尤像要拼出的拼图与盒子上图片的设计有点不太一样。这是一种逆向工程 (reverse engineering)一一－通过研究系统和逆向工作，来试图了解系统的创建过程。在这里，系统是一个机器产生的汇编语言程序，而不是由人设计的某个东西。这简化了逆向工程的任务，因为产生的代码遵循比较规则的模式，而且我们可以做试验，让编译器产生许多不同程序的代码。本章提供了许多示例和大量的练习，来说明汇编语言和编译器的各个不同方面。精通细节是理解更深和更基本概念的先决条件。有人说：“我理解了一般规则，不愿意劳神去学习细节！”他们实际上是在自欺欺人。花时间研究这些示例、完成练习并对照提供的答案来检查你的答案，是非常关键的。
我们的表述基于 x86-64,它是现在笔记本电脑和台式机中最常见处理器的机器语言，也是驱动大型数据中心和超级计算机的最常见处理器的机器语言。这种语言的历史悠久，开始于 Intel公司 1978年的第一个 16位处理器，然后扩展为 32位，最近又扩展到 64位。一路以来，逐渐增加了很多特性，以更好地利用已有的半导体技术，以及满足市场需求。这些进步中很多是 Intel自己驱动的，但它的对手 AMD(Advanced Micro Devices)也作出了重要的贡献。演化的结果是得到一个相当奇特的设计，有些特性只有从历史的观点来看才有意义，它还具有提供后向兼容性的特性，而现代编译器和操作系统早已不再使用这些特性。我们将关注 GCC和 Linux使用的那些特性，这样可以避免 x86-64的大量复杂性和许多隐秘特性。
我们在技术讲解之前，先快速浏览 C语言、汇编代码以及机器代码之间的关系。然后介绍 x86-64的细节，从数据的表示和处理以及控制的实现开始。了解如何实现 C语言中的控制结构，如辽、 while和 switch语句。之后，我们会讲到过程的实现，包括程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储。接着，我们会考虑在机器级如何实现像数组、结构和联合这样的数据结构。有了这些机器级编程的背景知识，我们会讨论内存访问越界的问题，以及系统容易遭受缓冲区溢出攻击的问题。在这一部分的结尾，我们会给出一些用 GDB调试器检查机器级程序运行时行为的技巧。本章的最后展示了包含浮点数据和操作的代码的机器程序表示。
-IA32编程
IA32, x86-64的 32位前身，是 Intel在 1985年提出的。几十年来一直是 Intel的机器语言之选。今天出售的大多数 x86微处理器，以及这些机器上安装的大多数操作系统，都是为运行 x86-64设计的。不过，它们也可以向后兼容执行 IA32程序。所以，很多应用程序还是基于 IA32的。除此之外，由于硬件或系统软件的眼制，许多已有的系统不能够执行 x86-64。 IA32仍然是一种重要的机器语言。学习过 x86-64会使你很容易地学会 IA32机器语言。
计算机工业已经完成从 32位到 64位机器的过渡。 32位机器只能使用大概 4GB（沪字节）的随机访问存储器。存储器价格急剧下降，而我们对计算的需求和数据的大小持续增加，超越这个限制既经济上可行又有技术上的需要。当前的 64位机器能够使用多达 256TB(2 “字节）的内存空间，而且很容易就能扩展至 16EB(2“字节）。虽然很难想象一台机器需要这么大的内存，但是回想 20世纪 70和 80年代，当 32位机器开始普及的时候， 4GB的内存看上去也是超级大的。
我们的表述集中于以现代操作系统为目标，编译 C或类似编程语言时，生成的机器级程序类型。 x86-64有一些特性是为了支持遗留下来的微处理器早期编程风格，在此，我们不试图去描述这些特性，那时候大部分代码都是手工编写的，而程序员还在努力与 16位机器允许的有限地址空间奋战。
3. 1 历史观点 Intel处理器系列俗称 x86,经历了一个长期的、不断进化的发展过程。开始时，它是第
一代单芯片、 16位微处理器之一，由于当时集成电路技术水平十分有限，其中做了很多妥
协。以后，它不断地成长，利用进步的技术满足更高性能和支持更高级操作系统的需求。
以下列举了一些 Intel处理器的模型，以及它们的一些关键特性，特别是影响机器级
编程的特性。我们用实现这些处理器所需要的品体管数量来说明演变过程的复杂性。其
中， “K&amp;quot;表示 1000, &amp;ldquo;M&amp;quot;表示 1 000 000,而 “G&amp;quot;表示 1 000 000 000。
8086(1978年， 29K个晶体管）。它是第一代单芯片、 16位微处理器之一。 8088是 8086
的一个变种，在 8086上增加了一个 8位外部总线，构成最初的 IBM个人计算机的心脏。
IBM与当时还不强大的微软签订合同，开发 MS-DOS操作系统。最初的机器型号有 32 768字
节的内存和两个软驱（没有硬盘驱动器）。从体系结构上来说，这些机器只有 655 360字节的
地址空间地址只有 20位长（可寻址范围为 1 048 576字节），而操作系统保留了 393 216字
节自用。 1980年， Intel提出了 8087浮点协处理器 (45K个晶体管），它与一个 8086或 8088
处理器一同运行，执行浮点指令。 8087建立了 x86系列的浮点模型，通常被称为 “x87”。
80286(1982年， 134K个品体管）。增加了更多的寻址模式（现在巳经废弃了），构成
了 IBM PC-AT个人计算机的基础，这种计算机是 MS Windows最初的使用平台。
i386(1985年， 275K个晶体管）。将体系结构扩展到 32位。增加了平坦寻址模式 (flat
addressing model), Linux和最近版本的 Windows操作系统都是使用的这种模式。这是
Intel系列中第一台全面支持 Unix操作系统的机器。
i486(1989年， 1. 2M个晶体管）。改善了性能，同时将浮点单元集成到了处理器芯片
上，但是指令集没有明显的改变。
Pentium(l993年， 3. lM个晶体管）。改善了性能，不过只对指令集进行了小的扩展。
PentiumPro(l995年， 5 . 5M个晶体管）。引入全新的处理器设计，在内部被称为 P6
微体系结构。指令集中增加了一类”条件传送 (conditional move)&amp;ldquo;指令。
Pentium/MMX(1997年， 4. 5M个晶体管）。在 Pentium处理器中增加了一类新的处
理整数向量的指令。每个数据大小可以是 1、 2或 4字节。每个向掀总长 64位。
Pentium 11(1997年， 7M个晶体管）。 P6微体系结构的延伸。
Pentium 1110999年， 8. 2M个晶体管）。引入了 SSE,这是一类处理整数或浮点数向
量的指令。每个数据可以是 1、 2或 4个字节，打包成 128位的向量。由于芯片上包括了
二级高速缓存，这种芯片后来的版本最多使用了 24M个晶体管。
Pentium 4(2000年， 42M个晶体管）。 SSE扩展到了 SSE2，增加了新的数据类型（包括双精度浮点数），以及针对这些格式的 144条新指令。有了这些扩展，编译器可以使用 SSE指令（而不是 x87指令），来编译浮点代码。
Pentium 4E(2004年， 125M个晶体管）。增加了超线程 (hyperthreading)，这种技术可以在一个处理器上同时运行两个程序；还增加了 EM64T,它是 Intel对 AMD提出的对 IA32的 64位扩展的实现，我们称之为 x86-64。
Core 2(2006年， 291M个晶体管）。回归到类似千 P 6的微体系结构。 Intel的第一个多核微处理器，即多处理器实现在一个芯片上。但不支持超线程。 Core i7, Ne halem( 2 008年， 781M个晶体管）。既支持超线程，也有多核，最初的版本支持每个核上执行两个程序，每个芯片上最多四个核。 Core i7, Sandy Bridge(2011年， 1. 17G个晶体管）。引入了 AVX,这是对 SSE的扩展，支持把数据封装进 2 5 6位的向量。 Core i7, Ha sw ell(2013年， 1. 4G个晶体管）。将 AVX扩展至 AVX2，增加了更多的
指令和指令格式。
每个后继处理器的设计都是后向兼容的一较早版本上编译的代码可以在较新的处理
器上运行。正如我们看到的那样，为了保持这种进化传统，指令集中有许多非常奇怪的东西。 Intel处理器系列有好几个名字，包括 IA32,也就是 “Inte l 32位体系结构 (Intel Architecture 32-bit)&amp;quot;,以及最新的 lntel64,即 IA 3 2的 64位扩展，我们也称为 x86-64。最常用的名字是 “x86&amp;rdquo;,我们用它指代整个系列，也反映了直到 i486处理器命名的惯例。
m摩尔定律 (Moore&amp;rsquo;s Law)
如果我们画出各种不同的 Int e l处理器中晶体管的数量与它们出现的年份之间的图
(y轴为晶体管数量的对数值），我们能够看出，增长是很显著的。画一条拟合这些数据
的线，可以看到晶体管数量以每年大约 37％的速率增加，也就是说，晶体管数量每 26
个月就会翻一番。在 x86微处理器的历史上，这种增长已经持续了好几十年。
Intel微处理器的复杂性
LOE+ 10
LOE+ 09
Nehalem .
OEOEOE
080706 Pentium 4e～冬e2 Duo
lll+++
Pentium 4
I.OE+ 05
l.OE +04 1975 1980 1985 1990 1995 2000 2005 2010 2015
年份
1 9 6 5年， Gordon Moore, Intel公司的创始人，根据当时的芯片技术（那时他们能够在
一个芯片上制造有大约 64个晶体管的电路）做出推断，预测在未来 10年，芯片上的晶体
管数量每年都会翻一番。这个预测就称为摩尔定律。正如事实证明的那样，他的预测有点乐
观，而且短视。在超过 50年中，半导体工业一直能够使得晶体管数目每 1 8个月翻一倍。
对计算机技术的其他方面，也有类似的呈指数增长的情况出现，比如磁盘和半导体
存储器的存储容量。这些惊人的增长速度一直是计算机革命的主要驱动力。
这些年来，许多公司生产出了与 Intel处理器兼容的处理器，能够运行完全相同的机器级程序。其中，领头的是 AMD。数年来， AMD在技术上紧跟 Intel,执行的市场策略是：生产性能稍低但是价格更便宜的处理祥。 20 0 2年， AMD的处理器变得更加有竞争
力，它们率先突破了可商用微处理器的 1GHz的时钟速度屏障，并且引入了广泛采用的 IA32的 64位扩展 x86-64。虽然我们讲的是 Intel处理器，但是对千其竞争对手生产的与之兼容的处理器来说，这些表述也同样成立。
对于由 GCC编译器产生的、在 Linux操作系统平台上运行的程序，感兴趣的人大多并不关心 x86的复杂性。最初的 8086提供的内存模型和它在 80286中的扩展，到 i386的时候就都已经过时了。原来的 x87浮点指令到引入 SSE2以后就过时了。虽然在 x86-64程序中，我
们能看到历史发展的痕迹，但 x86中许多最晦涩难懂的特性已经不会出现了。
缅谈胆迁喽
3. 2 程序编码假设一个 C程序，有两个文件 pl.c和 p2.c。我们用 Unix命令行编译这些代码：
linux&amp;gt; gee -Og -op pt.e p2.e
命令 gee指的就是 GCC C编译器。因为这是 Linux上默认的编译器，我们也可以简单地用 cc来启动它。编译选项－Og e告诉编译器使用会生成符合原始 C代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。因此我们会使用－Og优化作为学习工具，然后当我们增加优化级别时，再看会发生什么。实际中，从得到的程序的性能考虑，较高级别的优化（例如，以选项－01或－02指定）被认为是较好的选择。
实际上 gee命令调用了一整套的程序，将源代码转化成可执行代码。首先， C预处理器扩展源代码，插入所有用＃ include命令指定的文件，并扩展所有用＃define声明指定的宏。其次，编译器产生两个源文件的汇编代码，名字分别为 pl. s和 p2.s。接下来，汇编器会将汇编代码转化成二进制目标代码文件 p1.o和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。最后，链接器将两个目标代码文件与实现库函数（例如 printf)的代码合并，并产生最终的可执行代码文件 p（由命令行指示符－op指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。我们会在第 7章更详细地介绍这些不同形式的机器代码之间的关系以及链接的过程。
3. 2. 1 机器级代码正如在 1. 9. 3节中讲过的那样，计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对千机器级编程来说，其中两种抽象尤为重要。第一种是由指令集体系结构或指令集架构 &amp;lt;Instruction Set Arehitecture, ISA)来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数 ISA,包括 x86-64,将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与 ISA指定的顺序执行的行为完全一致。第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来，这会在第 9章中讲到。在整个编译过程中，编译器会完成大部分的工作，将把用 C语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。能够理解汇编代码以及它与原始 C代码的联系，是理解计算机如何执行程序的关键一步。 x86-64的机器代码和原始的 C代码差别非常大。一些通常对 C语言程序员隐藏的处理器状态都是可见的：
·程序计数器（通常称为 “PC&amp;rdquo;,在 x86-64中用％ rip表示）给出将要执行的下一条指令在内存中的地址。
GCC版本 4.8引人了这个优化等级。较早的 GCC版本和其他一些非 G~U编译器不认识这个选项。对这样一些编译器，使用一级优化（由命令行标志 -01指定）可能是最好的选择，生成的代码能够符合原始程序的结构。
·整数寄存器文件包含 16个命名的位置，分别存储 64位的值。这些寄存器可以存储地址
（对应千 C语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其
他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
·条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或
数据流中的条件变化，比如说用来实现江和 while语句。
·一组向量寄存器可以存放一个或多个整数或浮点数值。
虽然 C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。 C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。即使是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至于不区分指针和整数。
程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如说用 malloc库函数分配的）。正如前面提到的，程序内存用虚拟地址来寻址。在任意给定的时刻，只有有限的一部分虚拟地址
被认为是合法的。例如， x86-64的虚拟地址是由 64位的字来表示的。在目前的实现中，这些地址的高 16位必须设置为 o,所以一个地址实际上能够指定的是 2“或 64TB范围内的一个字节。较为典型的程序只会访问几兆字节或几千兆字节的数据。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。
一条机器指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现（像算术表达式求值、循环或过程调用和返回这样的）程序结构。
四曰不断变化的生成代码的格式
在本书的表述中，我们给出的代码是由特定版本的 GCC在特定的命令行选项设置
下产生的。如果你在自己的机器上编译代码，很有可能用到其他的编译器或者不同版本
的 GCC,因而会产生不同的代码。支持 GCC的开源社区一直在修改代码产生器，试图
根据微处理器制造商提供的不断变化的代码规则，产生更有效的代码。
本书示例的目标是展示如何查看汇编代码，并将它反向映射到高级编程语言中的结
构。你需要将这些技术应用到你的特定的编译器产生的代码格式上。
3. 2. 2 代码示例
假设我们写了一个 C语言代码文件 mstore.c,包含如下的函数定义：
long mult2(long, long);
void multstore(long x, long y, long .dest) { long t = mult2(x, y);
.dest = t; }
在命令行上使用 ”-s&amp;quot;选项，就能看到 C语言编译器产生的汇编代码：
linux&amp;gt; gee -Og -S mstore.e
这会使 GCC运行编译器，产生一个汇编文件 mstore.s,但是不做其他进一步的工作。（通常情况下，它还会继续调用汇编器产生目标代码文件）。
汇编代码文件包含各种声明，包括下面几行：
multstore: pushq %rbx movq 1!.rdx, %rbx call mult2 movq %rax, (%rbx) popq %rbx ret
上面代码中每个缩进去的行都对应于一条机器指令。比如， pushq指令表示应该将寄存器％
rbx的内容压入程序栈中。这段代码中已经除去了所有关于局部变量名或数据类型的信息。
如果我们使用 ”-c&amp;quot;命令行选项， GCC会编译并汇编该代码：
linux&amp;gt; gee -Og -e mstore.e
这就会产生目标代码文件 mstore.o,它是二进制格式的，所以无法直接查看。 1368字节
的文件 mstore.o中有一段 14字节的序列，它的十六进制表示为：
53 48 89 d3 e8 00 00 00 00 48 89 03 Sb c3
这就是上面列出的汇编指令对应的目标代码。从中得到一个重要信息，即机器执行的程序只
是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC4%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC4%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</guid><description>&lt;p>第 4 章&lt;/p>
&lt;p>C H A P T E R 4 ·&lt;/p>
&lt;h2 id="处理器体系结构">
 处理器体系结构
 &lt;a class="anchor" href="#%e5%a4%84%e7%90%86%e5%99%a8%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>现代微处理器可以称得上是人类创造出的最复杂的系统之一。一块手指甲大小的硅片上，可以容纳一个完整的高性能处理器、大的高速缓存，以及用来连接到外部设备的逻辑电路。 从性能上来说 ， 今天在一块芯片上实现的处理器已经使 20 年前价值 1000 万美元、房间那么大的超级计算机相形见细了。即使是在像手机、导航系统和可编程恒温器这样的日常设备中的嵌入式处理器，也比早期计算机开发者所能想到的强大得多。&lt;/p>
&lt;p>到目前为止，我们看到的计算机系统只限于机器语言程序级。我们知道处理器必须执行一系列指令，每条指令执行某个简单操作，例如两个数相加。指令被编码为由一个或多 个字节序列组成的二进制格式。一个处理器支持的指令和指令的字节级编码称为它的指令 集体系 结构 (I nst ru ction-Set Architecture, ISA)。不同的处理器“ 家族”， 例如 In tel IA32 和 x86-64 、IBM/ Freescale Power 和 ARM 处理器家族， 都有不 同的 ISA。一个程序编译成在一种机器上运行，就不能在另一种机器上运行。另外，同一个家族里也有很多不同型 号的处 理器。虽然每个厂商制造的处理器性能和复杂性不断提高， 但是不同的型号在 ISA 级别上都保持着兼容。一些常见的处理器家族（例如x86-64) 中的处理器分别由多 个厂商提供。因此， ISA 在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编 译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出执行 这些指令的处理器。&lt;/p>
&lt;p>本章将简要介绍处理骈硬件的设计。我们将研究一个硬件系统执行某种 ISA 指令的方&lt;/p>
&lt;p>式。这会使你能更好地理解计算机是如何工作的，以及计算机制造商们面临的技术挑战。 一个很重要的 概念是 ， 现代处理器的实际工作方式可能跟 ISA 隐含的计算模型大相径庭。&lt;/p>
&lt;p>ISA 模型看上去应该是顺序指 令执行， 也就是先取出一条指令，等 到它执行完毕 ，再 开始下一条。然而，与一个时刻只执行一条指令相比，通过同时处理多条指令的不同部分，处 理器可以获得更高的性能。为了保证处理器能得到同顺序执行相同的结果，人们采用了一 些特殊的机制。在计算机科学中，用巧妙的方法在提高性能的同时又保待一个更简单、更 抽象模型的功能 ， 这种思想是众所周知的。在 Web 浏览器或平衡二叉树和哈希表这样的信息检索数据结构中使用缓存，就是这样的例子。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC5%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC5%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</guid><description>&lt;p>C H— _&lt;/p>
&lt;p>第 5 章&lt;/p>
&lt;p>_ A P T E R 5&lt;/p>
&lt;h1 id="优化程序性能">
 优化程序性能
 &lt;a class="anchor" href="#%e4%bc%98%e5%8c%96%e7%a8%8b%e5%ba%8f%e6%80%a7%e8%83%bd">#&lt;/a>
&lt;/h1>
&lt;p>写程序最主要的目标就是使它在所有可能的情况下都正确工作。一个运行得很快但是给出错误结果的程序没有任何用处。程序员必须写出清晰简洁的代码，这样做不仅是为了 自己能够看懂代码，也是为了在检查代码和今后需要修改代码时，其他人能够读懂和理解 代码。&lt;/p>
&lt;p>另一方面，在很多情况下，让程序运行得快也是一个重要的考虑因素。如果一个程序要实时地处理视频帧或者网络包，一个运行得很慢的程序就不能提供所需的功能。当一个 计算任务的 计算量非常 大，需 要执行数日或者数周， 那么哪怕只是让它运行得快 20 %也会产生重大的影响。本章会探讨如何使用几种不同类型的程序优化技术，使程序运行得 更快。&lt;/p>
&lt;p>编写高效程序需要做到以下几点：第一，我们必须选择一组适当的算法和数据结构。 第二，我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。对于这第 二点，理解优化编译器的能力和局限性是很重要的。编写程序方式中看上去只是一点小小 的变动，都 会引起编译器优化方式很大的变化。有些编程语言比其他语言容易优化。C 语言的有些特性，例如执行指针运算和强制类型转换的能力，使得编译器很难对它进行优 化。程序员经常能够以一种使编译器更容易产生高效代码的方式来编写他们的程序。第三 项技术针对处理运算量特别大的计算，将一个任务分成多个部分，这些部分可以在多核和 多处理器的 某种组合上并行地计算。我们会 把这种性能改进的方法推迟到第 12 章中去讲。即使是要利用并行性，每个并行的线程都以最高性能执行也是非常重要的，所以无论如何 本章所讲的内容也还是有意义的。&lt;/p>
&lt;p>在程序开发和优化的过程中，我们必须考虑代码使用的方式，以及影响它的关键因&lt;/p>
&lt;p>素。通常，程序员必须在实现和维护程序的简单性与它的运行速度之间做出权衡。在算法 级上，几分钟就能编写一个简单的插入排序，而一个高效的排序算法程序可能需要一天或更长的时间来实现和优化。在代码级上，许多低级别的优化往往会降低程序的可读性和模块性，使得程序容易出错，并且更难以修改或扩展。对于在性能重要的环境中反复执行的代码，进行大量的优化会比较合适。一个挑战就是尽管做了大量的变化，但还是要维护代码一定程度的简洁和可读性。&lt;/p>
&lt;p>我们描述许多提高代码性能的技术。理想的情况是，编译器能够接受我们编写的任何代码，并产生尽可能高效的、具有指定行为的机器级程序。现代编译器采用了复杂的分析 和优化形式，而且变得越来越好。然而，即使是最好的编译器也受到妨碍优化的因素(optimization blocker ) 的阻碍， 妨碍优化的因素就是程序行为中那些严重依赖于执行环境的方面。程序员必须编写容易优化的代码，以帮助编译器。&lt;/p>
&lt;p>程序优化的第一步就是消除不必要的工作，让代码尽可能有效地执行所期望的任务。这包括消除不必要的函数调用、条件测试和内存引用。这些优化不依赖于目标机器的任何 具体属性。&lt;/p>
&lt;p>为了使程序性能最大化，程序员和编译器都需要一个目标机器的模型，指明如何处理指&lt;/p>
&lt;p>令，以 及各个操作的时序特性。例如， 编译器必须知道时序信息， 才能够确定是用一条乘法指令， 还是用移位和加法的某种组合 。现代计算机用复杂的技术来处理机器级程序， 并行地执行许多指令，执行顺序还可能不同 千它们在程序中出现的顺序。程序员必须理解这些处理器是如何工作的， 从而调整他们的程序以获得最大的 速度。基千 Intel 和 AMD 处理器最近的设计 ， 我们提出了这种机器的一个高级模型。我们 还设计了一种图形数据流( data-flow) 表示法， 可以使处理器对指令的执行 形象化， 我们还可以 利用它预测程序的性能。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC6%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC6%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</guid><description>&lt;p>－－－&lt;/p>
&lt;p>第 6 章&lt;/p>
&lt;p>H A P T E R 6&lt;/p>
&lt;h4 id="存储器层次结构">
 存储器层次结构
 &lt;a class="anchor" href="#%e5%ad%98%e5%82%a8%e5%99%a8%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h4>
&lt;p>到目前 为止，在对系 统的研究中， 我们依赖千一 个简单的计算机系统 模型， C P U 执行指令，而 存储器系统为 CP U 存放指令和数据。在简单模型中， 存储器系统是一个线性的字节数组， 而 CP U 能够在一个常数时间内访问每个存储器位置。虽然迄今为止这都是一个有效的模型， 但是它没有反映现代系统 实际工作的方式。&lt;/p>
&lt;p>实际上， 存储器 系统( m em o r y s ys te m ) 是一个具有不同容量、成本和访问 时间的存储设备的层 次结构。CP U 寄存器保存着最常用的数据。靠近 C P U 的小的、快 速的 高速 缓存存储器 ( cache memor y) 作为一部分存储在相对慢速的 主存储器( main mem o r y ) 中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为 存储在通过网络连接的其他机器的磁盘或磁带上的数据的缓冲区域。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC7%E7%AB%A0-%E9%93%BE%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC7%E7%AB%A0-%E9%93%BE%E6%8E%A5/</guid><description>&lt;p>第 7 章&lt;/p>
&lt;ul>
&lt;li>
&lt;p>· · · 0 · H A . · P T · .E R 7&lt;/p>
&lt;p>链接&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>链接Clink ing ) 是将各种代码和数据片段收集并 组合成 为一个单一文件的过程， 这个文件可被加栽（复制）到内存并执行。链接可以 执行于编译 时( com pile time), 也就是在源代码被翻译成 机器代码时； 也可以执行千加 载 时 ( loa d time) , 也就是在程序被加栽 器( lo ad­ er ) 加载到内存并 执行时； 甚至执行 于运行 时( ru n time), 也就是由应用程序来执行。在早期的计算机系统中， 链接是手 动执行的。在现代系统中， 链接是由叫做链接器 Clinker ) 的程序自动 执行的 。&lt;/p>
&lt;p>链接器在软 件开发中扮演着一个关键的角色， 因为它们使得分 离 编译( separa te com­ pila t io n ) 成为可能。我们不用将一个 大型的应用程序组织为一个巨大的源文 件， 而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模 块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</guid><description>&lt;p>第 8 章&lt;/p>
&lt;p>C H A P T E R 8&lt;/p>
&lt;p>异常控制流&lt;/p>
&lt;p>从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列&lt;/p>
&lt;p>a0 , a , , &amp;hellip; , a ,, _1&lt;/p>
&lt;p>其中，每个 ak 是某个相应的指令 I k的地址。每次从 Qk 到 a k一 1 的过渡称为控 制 转移 ( co ntro l trans £er ) 。 这样的 控制转移 序列叫做处理器的控制流( flow of cont rol 或 cont ro l flow ) 。&lt;/p>
&lt;p>最简单的一种控制流 是一个“平滑的＂ 序列， 其中每个 L 和 I尸！在内存中都是相邻&lt;/p>
&lt;p>的。这种 平滑流的 突变（也就是 I尸］与 L 不相邻）通常是由诸如跳转 、调用和返回这样一些熟悉的 程序指令造成的 。这样一些指令都是必要的机制， 使得程序能够对由程序变扯表示的内部程序状 态中的 变化做出反应 。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid><description>&lt;p>第 9 章&lt;/p>
&lt;p>C H A P T E A 9 . .&lt;/p>
&lt;p>虚拟内存&lt;/p>
&lt;p>一个系统中 的进程是与其他进程共享 CPU 和主存资源的。然而， 共享主存会形成一些特殊的挑战。随着 对 CPU 需求的增长， 进程以 某种合理的平滑方式慢了下来。但是如果太多的 进程需要太多的内存， 那么它们中的一些就根本无法运行 。当一个程序没有空间可用时 ， 那就是它运气不好了。内存还很容易被破坏 。如果某个进程不小心写了另一个进程使用的内存 ， 它就可能以某种完全和程序逻辑无关 的令人迷惑的方式失 败。&lt;/p>
&lt;p>为了更加有效 地管理内存并且少出错， 现代系统提供了一种对主存的抽象概念， 叫做虚拟内存 CV M) 。虚拟内存 是硬件异常、硬件地址翻译 、主存 、磁盘文件和内核软件的完美交互 ， 它为每个进程提供了一个 大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力： 1 ) 它将主存看成是 一个存储在磁盘上的 地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过 这种方式 ， 它高效地使用了主存。2 ) 它为每个进程提 供了一致的地址空间，从 而简化了内存管理。3 ) 它保护了每个进程的地址空间不被其他进程破坏。&lt;/p>
&lt;p>虚拟内存是计算机系统最重要的概念之一。它成功的一个主要原因就是因为它是沉默地、自动 地工作的 ， 不需要应用程序员的任何干涉。既然虚拟内存在幕后工作得如此之好，为什么程序员还需要理解它呢？有以下儿个原因：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>虚拟内存是核心的。虚拟内存遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程的设 计中扮演着重要 角色。理解虚拟内存将帮助你更好地理解系统通常是如何工作的。&lt;/p>
&lt;p>. • 虚拟内存是强大的。虚拟内存给予应用程序强大的能力，可以创建和销毁内存片 ( ch unk ) 、将内存片映射到磁盘文件的 某个部分， 以及与其他进程共享内存。比如， 你知道可以通过读写内存位置读或者修改一个磁盘文件的内容吗？或者可以加载一 个文件的内容到内存中，而不需要进行任何显式地复制吗？理解虚拟内存将帮助你 利用它的强大功能在应用程序中添加动力。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C-2-6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C-2-6/</guid><description>&lt;p>第一部分&lt;/p>
&lt;p>尸&lt;/p>
&lt;p>心r&lt;/p>
&lt;p>程序结构和执行&lt;/p>
&lt;p>我们对计算机系统的探索是从学习计算机本身开始的，它由 处理器和存储器子系统组成。在核心部分，我们需要方法来表示 基本数据类型，比如整数和实数运算的近似值。然后，我们考虑 机器级指令如何操作这 样 的 数 据， 以 及 编译器 又如何 将 C 程 序 翻译成这样的指令。接下来，研究几种实现处理器的方法，帮助我 们更好地了解硬件资源如何被用来执行指令。一旦理解了编译器 和机器级代码 ， 我们 就 能 了 解如何通 过编写 C 程 序 以 及 编译 它 们来最大化程序的性能。本部分以存储器子系统的设计作为结束， 这是现代计算机系统最复杂的部分之一。&lt;/p>
&lt;p>本书的这一部分将领着你深入了解如何表示和执行应用程序。你将学会一些技巧，来帮助你写出安全、可靠且充分利用计算资 源的程序。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%92%8C%E9%80%9A%E4%BF%A1-10-12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%92%8C%E9%80%9A%E4%BF%A1-10-12/</guid><description>&lt;p>&lt;img src="img/3a5216eff04803609c99d1f3962e69ab.jpeg" alt="" />第三部分&lt;/p>
&lt;p>程序间的交互和通信&lt;/p>
&lt;p>我们学习计算机系统到现在，一直假设程序是独立运行的， 只包含最小 限度 的 输入 和 输 出 。 然 而 ， 在 现实 世界 里， 应 用 程 序利用 操作 系统提供的服 务 来 与 I/ 0 设 备 及 其他程序通信。&lt;/p>
&lt;p>本书 的 这 一部分将使你 了 解 U ni x 操作 系统提供 的基本 I/ 0 服务 ， 以及如何用这 些服务 来构 造 应 用 程 序 ， 例如 Web 客 户 端 和服务器， 它 们是 通过 Intern et 彼 此 通 信 的 。 你 将 学 习 编 写 诸 如 Web 服务器这样的 可 以 同 时 为 多 个 客 户 端提 供 服 务 的并 发 程 序。 编 写并发应用程序还能使程序在现代多核处理器上执行得更快。当学 完了这个部分，你将逐渐变成一个很牛的程序员，对计算机系统 以及它们对程序的影响有很成熟的理解。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-7-9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-7-9/</guid><description>&lt;p>霄＇&lt;/p>
&lt;p>第二部分&lt;/p>
&lt;p>在系统上运行程序&lt;/p>
&lt;p>&lt;img src="img/4eaf8efb7f8ecd98f51d4916974b5c33.jpeg" alt="" />继续我们对计算机系统的探索，进一步来看看构建和运行应 用程序的系统软件。链接器把程序的各个部分联合成一个文件， 处理器可以将这个文件加载到内存，并且执行它。现代操作系统 与硬件合作，为每个程序提供一种幻象，好像这个程序是在独占 地使用处 理器和 主存 ， 而 实际 上，在 任何 时 刻， 系 统 上 都 有 多 个程序在运行。&lt;/p>
&lt;p>&lt;img src="img/8bd1b1e7deb481acbd4a4bf003ec9f04.jpeg" alt="" />在本书的第一部分，你很好地理解了程序和硬件之间的交互 关系。本书的第二部分将拓宽你对系统的了解，使你牢固地掌握 程序和操作系统之间的交互关系。你将学习到如何使用操作系统 提供的 服 务 来 构 建 系 统 级 程 序， 例 如 U nix shell 和 动 态 内 存 分配包。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E9%99%84%E5%BD%95A-%E5%B0%81%E5%BA%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E9%99%84%E5%BD%95A-%E5%B0%81%E5%BA%95/</guid><description>&lt;p>附录 A&lt;/p>
&lt;h4 id="a-p-p-e-n-d-i-x-a">
 A P P E N D I X A
 &lt;a class="anchor" href="#a-p-p-e-n-d-i-x-a">#&lt;/a>
&lt;/h4>
&lt;p>错误处理&lt;/p>
&lt;h3 id="程序员应该总是检查系统级函数返回的错误代码有许多细微的方式会导致出现错-误只-有使用内核能够提供给我们的状态信息才能理解为什么有这样的错误不幸的是-程序员-往往不愿意进行错误检查-因为这使他们的代码变得-很庞大将-一行代码变成一个多行的条件语句错误检查也是很令人迷惑的因为不同的函数以不同的方式表示错误">
 程序员应该总是检查系统级函数返回的错误代码。有许多细微的方式会导致出现错 误，只 有使用内核能够提供给我们的状态信息才能理解为什么有这样的错误。不幸的是， 程序员 往往不愿意进行错误检查， 因为这使他们的代码变得 很庞大，将 一行代码变成一个多行的条件语句。错误检查也是很令人迷惑的，因为不同的函数以不同的方式表示错误。
 &lt;a class="anchor" href="#%e7%a8%8b%e5%ba%8f%e5%91%98%e5%ba%94%e8%af%a5%e6%80%bb%e6%98%af%e6%a3%80%e6%9f%a5%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e%e7%9a%84%e9%94%99%e8%af%af%e4%bb%a3%e7%a0%81%e6%9c%89%e8%ae%b8%e5%a4%9a%e7%bb%86%e5%be%ae%e7%9a%84%e6%96%b9%e5%bc%8f%e4%bc%9a%e5%af%bc%e8%87%b4%e5%87%ba%e7%8e%b0%e9%94%99-%e8%af%af%e5%8f%aa-%e6%9c%89%e4%bd%bf%e7%94%a8%e5%86%85%e6%a0%b8%e8%83%bd%e5%a4%9f%e6%8f%90%e4%be%9b%e7%bb%99%e6%88%91%e4%bb%ac%e7%9a%84%e7%8a%b6%e6%80%81%e4%bf%a1%e6%81%af%e6%89%8d%e8%83%bd%e7%90%86%e8%a7%a3%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9c%89%e8%bf%99%e6%a0%b7%e7%9a%84%e9%94%99%e8%af%af%e4%b8%8d%e5%b9%b8%e7%9a%84%e6%98%af-%e7%a8%8b%e5%ba%8f%e5%91%98-%e5%be%80%e5%be%80%e4%b8%8d%e6%84%bf%e6%84%8f%e8%bf%9b%e8%a1%8c%e9%94%99%e8%af%af%e6%a3%80%e6%9f%a5-%e5%9b%a0%e4%b8%ba%e8%bf%99%e4%bd%bf%e4%bb%96%e4%bb%ac%e7%9a%84%e4%bb%a3%e7%a0%81%e5%8f%98%e5%be%97-%e5%be%88%e5%ba%9e%e5%a4%a7%e5%b0%86-%e4%b8%80%e8%a1%8c%e4%bb%a3%e7%a0%81%e5%8f%98%e6%88%90%e4%b8%80%e4%b8%aa%e5%a4%9a%e8%a1%8c%e7%9a%84%e6%9d%a1%e4%bb%b6%e8%af%ad%e5%8f%a5%e9%94%99%e8%af%af%e6%a3%80%e6%9f%a5%e4%b9%9f%e6%98%af%e5%be%88%e4%bb%a4%e4%ba%ba%e8%bf%b7%e6%83%91%e7%9a%84%e5%9b%a0%e4%b8%ba%e4%b8%8d%e5%90%8c%e7%9a%84%e5%87%bd%e6%95%b0%e4%bb%a5%e4%b8%8d%e5%90%8c%e7%9a%84%e6%96%b9%e5%bc%8f%e8%a1%a8%e7%a4%ba%e9%94%99%e8%af%af">#&lt;/a>
&lt;/h3>
&lt;p>在编写本书时， 我们面临类似的问题。一方面， 我们希望代码示例阅读起来简洁简单；另一方面，我们又不希望给学生们一个错误的印象，以为可以省略错误检查。为了解 决这些问题， 我们采用了一种基于错误处理 包装函数 ( er ro r- ha ndling wra pper ) 的方法， 这是由 W. Richard Steve ns 在他的网络编程教材 [ 11 0] 中最先提出的。&lt;/p>
&lt;h3 id="其思想是-给-定某个基本的-系统级函数-f-oo--我们定义一个有相同参数只不过开头字母大写了的包装函数-foo包装函数调用基本函数并检查错误如果包装函数发现了错误那么它就打印一条信息并终止进程否则它返回到调用者注意如果没有错误-包装函数的行为与基本函数完全一样换句话说如果程序使用包装函数运行正确那么-我们把每个-包装函数的第一个字母小-写并重新编译也-能正确运行">
 其思想是 ，给 定某个基本的 系统级函数 f oo , 我们定义一个有相同参数、只不过开头字母大写了的包装函数 Foo。包装函数调用基本函数并检查错误。如果包装函数发现了错误，那么它就打印一条信息并终止进程。否则，它返回到调用者。注意，如果没有错误， 包装函数的行为与基本函数完全一样。换句话说，如果程序使用包装函数运行正确，那么 我们把每个 包装函数的第一个字母小 写并重新编译，也 能正确运行。
 &lt;a class="anchor" href="#%e5%85%b6%e6%80%9d%e6%83%b3%e6%98%af-%e7%bb%99-%e5%ae%9a%e6%9f%90%e4%b8%aa%e5%9f%ba%e6%9c%ac%e7%9a%84-%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%87%bd%e6%95%b0-f-oo--%e6%88%91%e4%bb%ac%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aa%e6%9c%89%e7%9b%b8%e5%90%8c%e5%8f%82%e6%95%b0%e5%8f%aa%e4%b8%8d%e8%bf%87%e5%bc%80%e5%a4%b4%e5%ad%97%e6%af%8d%e5%a4%a7%e5%86%99%e4%ba%86%e7%9a%84%e5%8c%85%e8%a3%85%e5%87%bd%e6%95%b0-foo%e5%8c%85%e8%a3%85%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e5%9f%ba%e6%9c%ac%e5%87%bd%e6%95%b0%e5%b9%b6%e6%a3%80%e6%9f%a5%e9%94%99%e8%af%af%e5%a6%82%e6%9e%9c%e5%8c%85%e8%a3%85%e5%87%bd%e6%95%b0%e5%8f%91%e7%8e%b0%e4%ba%86%e9%94%99%e8%af%af%e9%82%a3%e4%b9%88%e5%ae%83%e5%b0%b1%e6%89%93%e5%8d%b0%e4%b8%80%e6%9d%a1%e4%bf%a1%e6%81%af%e5%b9%b6%e7%bb%88%e6%ad%a2%e8%bf%9b%e7%a8%8b%e5%90%a6%e5%88%99%e5%ae%83%e8%bf%94%e5%9b%9e%e5%88%b0%e8%b0%83%e7%94%a8%e8%80%85%e6%b3%a8%e6%84%8f%e5%a6%82%e6%9e%9c%e6%b2%a1%e6%9c%89%e9%94%99%e8%af%af-%e5%8c%85%e8%a3%85%e5%87%bd%e6%95%b0%e7%9a%84%e8%a1%8c%e4%b8%ba%e4%b8%8e%e5%9f%ba%e6%9c%ac%e5%87%bd%e6%95%b0%e5%ae%8c%e5%85%a8%e4%b8%80%e6%a0%b7%e6%8d%a2%e5%8f%a5%e8%af%9d%e8%af%b4%e5%a6%82%e6%9e%9c%e7%a8%8b%e5%ba%8f%e4%bd%bf%e7%94%a8%e5%8c%85%e8%a3%85%e5%87%bd%e6%95%b0%e8%bf%90%e8%a1%8c%e6%ad%a3%e7%a1%ae%e9%82%a3%e4%b9%88-%e6%88%91%e4%bb%ac%e6%8a%8a%e6%af%8f%e4%b8%aa-%e5%8c%85%e8%a3%85%e5%87%bd%e6%95%b0%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%ad%97%e6%af%8d%e5%b0%8f-%e5%86%99%e5%b9%b6%e9%87%8d%e6%96%b0%e7%bc%96%e8%af%91%e4%b9%9f-%e8%83%bd%e6%ad%a3%e7%a1%ae%e8%bf%90%e8%a1%8c">#&lt;/a>
&lt;/h3>
&lt;p>包装函数被封装在一个源文件( c s a p p . c ) 中， 这个文件被编译 和链接到每个程序中。一个独立的 头文件Cc s a p p . h ) 中包含这些包装函数的 函数原型。&lt;/p></description></item></channel></rss>