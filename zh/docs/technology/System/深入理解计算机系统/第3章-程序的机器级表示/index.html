<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='第 3章
C H A P T E R 3
程序的机器级表示
计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写
存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集
和操作系统遵循的惯例，经过一系列的阶段生成机器代码。 GCCC语言编译器以汇编代码
的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后
GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。在本章中，我们会近
距离地观察机器代码，以及人类可读的表示汇编代码。
当我们用高级语言编程的时候（例如 C语言， Java语言更是如此），机器屏蔽了程序的细节，即机器级的实现。与此相反，当用汇编代码编程的时候（就像早期的计算），程序员必须指定程序用来执行计算的低级指令。高级语言提供的抽象级别比较高，大多数时候，在这种抽象级别上工作效率会更高，也更可靠。编译器提供的类型检查能帮助我们发现许多程序错误，并能够保证按照一致的方式来引用和处理数据。通常情况下，使用现代的优化编译器产生的代码至少与一个熟练的汇编语言程序员手工编写的代码一样有效。最大的优点是，用高级语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关的。
那么为什么我们还要花时间学习机器代码呢？即使编译器承担了生成汇编代码的大部分工作，对于严谨的程序员来说，能够阅读和理解汇编代码仍是一项很重要的技能。以适当的命令行选项调用编译器，编译器就会产生一个以汇编代码形式表示的输出文件。通过阅读这些汇编代码，我们能够理解编译器的优化能力，并分析代码中隐含的低效率。就像我们将在第 5章中体会到的那样，试图最大化一段关键代码性能的程序员，通常会尝试源代码的各种形式，每次编译并检查产生的汇编代码，从而了解程序将要运行的效率如何。此外，也有些时候，高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为。例如，第 12章会讲到，用线程包写并发程序时，了解不同的线程是如何共享程序数据或保持数据私有的，以及准确知道如何在哪里访问共享数据，都是很重要的。这些信息在机器代码级是可见的。另外再举一个例子，程序遭受攻击（使得恶意软件侵扰系统）的许多方式中，都涉及程序存储运行时控制信息的方式的细节。许多攻击利用了系统程序中的漏洞重写信息，从而获得了系统的控制权。了解这些漏洞是如何出现的，以及如何防御它们，需要具备程序机器级表示的知识。程序员学习汇编代码的需求随着时间的推移也发生了变化，开始时要求程序员能直接用汇编语言编写程序，现在则要求他们能够阅读和理解编译器产生的代码。
在本章中，我们将详细学习一种特别的汇编语言，了解如何将 C程序编译成这种形式的机器代码。阅读编译器产生的汇编代码，需要具备的技能不同千手工编写汇编代码。我们必须了解典型的编译器在将 C程序结构变换成机器代码时所做的转换。相对于 C代码表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换慢速操作，甚至将递归计算变换成迭代计算。源代码与对应的汇编代码的关系通常不太容易理解一一凉尤像要拼出的拼图与盒子上图片的设计有点不太一样。这是一种逆向工程 (reverse engineering)一一－通过研究系统和逆向工作，来试图了解系统的创建过程。在这里，系统是一个机器产生的汇编语言程序，而不是由人设计的某个东西。这简化了逆向工程的任务，因为产生的代码遵循比较规则的模式，而且我们可以做试验，让编译器产生许多不同程序的代码。本章提供了许多示例和大量的练习，来说明汇编语言和编译器的各个不同方面。精通细节是理解更深和更基本概念的先决条件。有人说：“我理解了一般规则，不愿意劳神去学习细节！”他们实际上是在自欺欺人。花时间研究这些示例、完成练习并对照提供的答案来检查你的答案，是非常关键的。
我们的表述基于 x86-64,它是现在笔记本电脑和台式机中最常见处理器的机器语言，也是驱动大型数据中心和超级计算机的最常见处理器的机器语言。这种语言的历史悠久，开始于 Intel公司 1978年的第一个 16位处理器，然后扩展为 32位，最近又扩展到 64位。一路以来，逐渐增加了很多特性，以更好地利用已有的半导体技术，以及满足市场需求。这些进步中很多是 Intel自己驱动的，但它的对手 AMD(Advanced Micro Devices)也作出了重要的贡献。演化的结果是得到一个相当奇特的设计，有些特性只有从历史的观点来看才有意义，它还具有提供后向兼容性的特性，而现代编译器和操作系统早已不再使用这些特性。我们将关注 GCC和 Linux使用的那些特性，这样可以避免 x86-64的大量复杂性和许多隐秘特性。
我们在技术讲解之前，先快速浏览 C语言、汇编代码以及机器代码之间的关系。然后介绍 x86-64的细节，从数据的表示和处理以及控制的实现开始。了解如何实现 C语言中的控制结构，如辽、 while和 switch语句。之后，我们会讲到过程的实现，包括程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储。接着，我们会考虑在机器级如何实现像数组、结构和联合这样的数据结构。有了这些机器级编程的背景知识，我们会讨论内存访问越界的问题，以及系统容易遭受缓冲区溢出攻击的问题。在这一部分的结尾，我们会给出一些用 GDB调试器检查机器级程序运行时行为的技巧。本章的最后展示了包含浮点数据和操作的代码的机器程序表示。
-IA32编程
IA32, x86-64的 32位前身，是 Intel在 1985年提出的。几十年来一直是 Intel的机器语言之选。今天出售的大多数 x86微处理器，以及这些机器上安装的大多数操作系统，都是为运行 x86-64设计的。不过，它们也可以向后兼容执行 IA32程序。所以，很多应用程序还是基于 IA32的。除此之外，由于硬件或系统软件的眼制，许多已有的系统不能够执行 x86-64。 IA32仍然是一种重要的机器语言。学习过 x86-64会使你很容易地学会 IA32机器语言。
计算机工业已经完成从 32位到 64位机器的过渡。 32位机器只能使用大概 4GB（沪字节）的随机访问存储器。存储器价格急剧下降，而我们对计算的需求和数据的大小持续增加，超越这个限制既经济上可行又有技术上的需要。当前的 64位机器能够使用多达 256TB(2 “字节）的内存空间，而且很容易就能扩展至 16EB(2“字节）。虽然很难想象一台机器需要这么大的内存，但是回想 20世纪 70和 80年代，当 32位机器开始普及的时候， 4GB的内存看上去也是超级大的。
我们的表述集中于以现代操作系统为目标，编译 C或类似编程语言时，生成的机器级程序类型。 x86-64有一些特性是为了支持遗留下来的微处理器早期编程风格，在此，我们不试图去描述这些特性，那时候大部分代码都是手工编写的，而程序员还在努力与 16位机器允许的有限地址空间奋战。
3. 1 历史观点 Intel处理器系列俗称 x86,经历了一个长期的、不断进化的发展过程。开始时，它是第
一代单芯片、 16位微处理器之一，由于当时集成电路技术水平十分有限，其中做了很多妥
协。以后，它不断地成长，利用进步的技术满足更高性能和支持更高级操作系统的需求。
以下列举了一些 Intel处理器的模型，以及它们的一些关键特性，特别是影响机器级
编程的特性。我们用实现这些处理器所需要的品体管数量来说明演变过程的复杂性。其
中， “K"表示 1000, &ldquo;M"表示 1 000 000,而 “G"表示 1 000 000 000。
8086(1978年， 29K个晶体管）。它是第一代单芯片、 16位微处理器之一。 8088是 8086
的一个变种，在 8086上增加了一个 8位外部总线，构成最初的 IBM个人计算机的心脏。
IBM与当时还不强大的微软签订合同，开发 MS-DOS操作系统。最初的机器型号有 32 768字
节的内存和两个软驱（没有硬盘驱动器）。从体系结构上来说，这些机器只有 655 360字节的
地址空间地址只有 20位长（可寻址范围为 1 048 576字节），而操作系统保留了 393 216字
节自用。 1980年， Intel提出了 8087浮点协处理器 (45K个晶体管），它与一个 8086或 8088
处理器一同运行，执行浮点指令。 8087建立了 x86系列的浮点模型，通常被称为 “x87”。
80286(1982年， 134K个品体管）。增加了更多的寻址模式（现在巳经废弃了），构成
了 IBM PC-AT个人计算机的基础，这种计算机是 MS Windows最初的使用平台。
i386(1985年， 275K个晶体管）。将体系结构扩展到 32位。增加了平坦寻址模式 (flat
addressing model), Linux和最近版本的 Windows操作系统都是使用的这种模式。这是
Intel系列中第一台全面支持 Unix操作系统的机器。
i486(1989年， 1. 2M个晶体管）。改善了性能，同时将浮点单元集成到了处理器芯片
上，但是指令集没有明显的改变。
Pentium(l993年， 3. lM个晶体管）。改善了性能，不过只对指令集进行了小的扩展。
PentiumPro(l995年， 5 . 5M个晶体管）。引入全新的处理器设计，在内部被称为 P6
微体系结构。指令集中增加了一类”条件传送 (conditional move)&ldquo;指令。
Pentium/MMX(1997年， 4. 5M个晶体管）。在 Pentium处理器中增加了一类新的处
理整数向量的指令。每个数据大小可以是 1、 2或 4字节。每个向掀总长 64位。
Pentium 11(1997年， 7M个晶体管）。 P6微体系结构的延伸。
Pentium 1110999年， 8. 2M个晶体管）。引入了 SSE,这是一类处理整数或浮点数向
量的指令。每个数据可以是 1、 2或 4个字节，打包成 128位的向量。由于芯片上包括了
二级高速缓存，这种芯片后来的版本最多使用了 24M个晶体管。
Pentium 4(2000年， 42M个晶体管）。 SSE扩展到了 SSE2，增加了新的数据类型（包括双精度浮点数），以及针对这些格式的 144条新指令。有了这些扩展，编译器可以使用 SSE指令（而不是 x87指令），来编译浮点代码。
Pentium 4E(2004年， 125M个晶体管）。增加了超线程 (hyperthreading)，这种技术可以在一个处理器上同时运行两个程序；还增加了 EM64T,它是 Intel对 AMD提出的对 IA32的 64位扩展的实现，我们称之为 x86-64。
Core 2(2006年， 291M个晶体管）。回归到类似千 P 6的微体系结构。 Intel的第一个多核微处理器，即多处理器实现在一个芯片上。但不支持超线程。 Core i7, Ne halem( 2 008年， 781M个晶体管）。既支持超线程，也有多核，最初的版本支持每个核上执行两个程序，每个芯片上最多四个核。 Core i7, Sandy Bridge(2011年， 1. 17G个晶体管）。引入了 AVX,这是对 SSE的扩展，支持把数据封装进 2 5 6位的向量。 Core i7, Ha sw ell(2013年， 1. 4G个晶体管）。将 AVX扩展至 AVX2，增加了更多的
指令和指令格式。
每个后继处理器的设计都是后向兼容的一较早版本上编译的代码可以在较新的处理
器上运行。正如我们看到的那样，为了保持这种进化传统，指令集中有许多非常奇怪的东西。 Intel处理器系列有好几个名字，包括 IA32,也就是 “Inte l 32位体系结构 (Intel Architecture 32-bit)",以及最新的 lntel64,即 IA 3 2的 64位扩展，我们也称为 x86-64。最常用的名字是 “x86&rdquo;,我们用它指代整个系列，也反映了直到 i486处理器命名的惯例。
m摩尔定律 (Moore&rsquo;s Law)
如果我们画出各种不同的 Int e l处理器中晶体管的数量与它们出现的年份之间的图
(y轴为晶体管数量的对数值），我们能够看出，增长是很显著的。画一条拟合这些数据
的线，可以看到晶体管数量以每年大约 37％的速率增加，也就是说，晶体管数量每 26
个月就会翻一番。在 x86微处理器的历史上，这种增长已经持续了好几十年。
Intel微处理器的复杂性
LOE+ 10
LOE+ 09
Nehalem .
OEOEOE
080706 Pentium 4e～冬e2 Duo
lll+++
Pentium 4
I.OE+ 05
l.OE +04 1975 1980 1985 1990 1995 2000 2005 2010 2015
年份
1 9 6 5年， Gordon Moore, Intel公司的创始人，根据当时的芯片技术（那时他们能够在
一个芯片上制造有大约 64个晶体管的电路）做出推断，预测在未来 10年，芯片上的晶体
管数量每年都会翻一番。这个预测就称为摩尔定律。正如事实证明的那样，他的预测有点乐
观，而且短视。在超过 50年中，半导体工业一直能够使得晶体管数目每 1 8个月翻一倍。
对计算机技术的其他方面，也有类似的呈指数增长的情况出现，比如磁盘和半导体
存储器的存储容量。这些惊人的增长速度一直是计算机革命的主要驱动力。
这些年来，许多公司生产出了与 Intel处理器兼容的处理器，能够运行完全相同的机器级程序。其中，领头的是 AMD。数年来， AMD在技术上紧跟 Intel,执行的市场策略是：生产性能稍低但是价格更便宜的处理祥。 20 0 2年， AMD的处理器变得更加有竞争
力，它们率先突破了可商用微处理器的 1GHz的时钟速度屏障，并且引入了广泛采用的 IA32的 64位扩展 x86-64。虽然我们讲的是 Intel处理器，但是对千其竞争对手生产的与之兼容的处理器来说，这些表述也同样成立。
对于由 GCC编译器产生的、在 Linux操作系统平台上运行的程序，感兴趣的人大多并不关心 x86的复杂性。最初的 8086提供的内存模型和它在 80286中的扩展，到 i386的时候就都已经过时了。原来的 x87浮点指令到引入 SSE2以后就过时了。虽然在 x86-64程序中，我
们能看到历史发展的痕迹，但 x86中许多最晦涩难懂的特性已经不会出现了。
缅谈胆迁喽
3. 2 程序编码假设一个 C程序，有两个文件 pl.c和 p2.c。我们用 Unix命令行编译这些代码：
linux> gee -Og -op pt.e p2.e
命令 gee指的就是 GCC C编译器。因为这是 Linux上默认的编译器，我们也可以简单地用 cc来启动它。编译选项－Og e告诉编译器使用会生成符合原始 C代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。因此我们会使用－Og优化作为学习工具，然后当我们增加优化级别时，再看会发生什么。实际中，从得到的程序的性能考虑，较高级别的优化（例如，以选项－01或－02指定）被认为是较好的选择。
实际上 gee命令调用了一整套的程序，将源代码转化成可执行代码。首先， C预处理器扩展源代码，插入所有用＃ include命令指定的文件，并扩展所有用＃define声明指定的宏。其次，编译器产生两个源文件的汇编代码，名字分别为 pl. s和 p2.s。接下来，汇编器会将汇编代码转化成二进制目标代码文件 p1.o和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。最后，链接器将两个目标代码文件与实现库函数（例如 printf)的代码合并，并产生最终的可执行代码文件 p（由命令行指示符－op指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。我们会在第 7章更详细地介绍这些不同形式的机器代码之间的关系以及链接的过程。
3. 2. 1 机器级代码正如在 1. 9. 3节中讲过的那样，计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对千机器级编程来说，其中两种抽象尤为重要。第一种是由指令集体系结构或指令集架构 <Instruction Set Arehitecture, ISA)来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数 ISA,包括 x86-64,将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与 ISA指定的顺序执行的行为完全一致。第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来，这会在第 9章中讲到。在整个编译过程中，编译器会完成大部分的工作，将把用 C语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。能够理解汇编代码以及它与原始 C代码的联系，是理解计算机如何执行程序的关键一步。 x86-64的机器代码和原始的 C代码差别非常大。一些通常对 C语言程序员隐藏的处理器状态都是可见的：
·程序计数器（通常称为 “PC&rdquo;,在 x86-64中用％ rip表示）给出将要执行的下一条指令在内存中的地址。
GCC版本 4.8引人了这个优化等级。较早的 GCC版本和其他一些非 G~U编译器不认识这个选项。对这样一些编译器，使用一级优化（由命令行标志 -01指定）可能是最好的选择，生成的代码能够符合原始程序的结构。
·整数寄存器文件包含 16个命名的位置，分别存储 64位的值。这些寄存器可以存储地址
（对应千 C语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其
他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
·条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或
数据流中的条件变化，比如说用来实现江和 while语句。
·一组向量寄存器可以存放一个或多个整数或浮点数值。
虽然 C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。 C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。即使是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至于不区分指针和整数。
程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如说用 malloc库函数分配的）。正如前面提到的，程序内存用虚拟地址来寻址。在任意给定的时刻，只有有限的一部分虚拟地址
被认为是合法的。例如， x86-64的虚拟地址是由 64位的字来表示的。在目前的实现中，这些地址的高 16位必须设置为 o,所以一个地址实际上能够指定的是 2“或 64TB范围内的一个字节。较为典型的程序只会访问几兆字节或几千兆字节的数据。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。
一条机器指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现（像算术表达式求值、循环或过程调用和返回这样的）程序结构。
四曰不断变化的生成代码的格式
在本书的表述中，我们给出的代码是由特定版本的 GCC在特定的命令行选项设置
下产生的。如果你在自己的机器上编译代码，很有可能用到其他的编译器或者不同版本
的 GCC,因而会产生不同的代码。支持 GCC的开源社区一直在修改代码产生器，试图
根据微处理器制造商提供的不断变化的代码规则，产生更有效的代码。
本书示例的目标是展示如何查看汇编代码，并将它反向映射到高级编程语言中的结
构。你需要将这些技术应用到你的特定的编译器产生的代码格式上。
3. 2. 2 代码示例
假设我们写了一个 C语言代码文件 mstore.c,包含如下的函数定义：
long mult2(long, long);
void multstore(long x, long y, long .dest) { long t = mult2(x, y);
.dest = t; }
在命令行上使用 ”-s"选项，就能看到 C语言编译器产生的汇编代码：
linux> gee -Og -S mstore.e
这会使 GCC运行编译器，产生一个汇编文件 mstore.s,但是不做其他进一步的工作。（通常情况下，它还会继续调用汇编器产生目标代码文件）。
汇编代码文件包含各种声明，包括下面几行：
multstore: pushq %rbx movq 1!.rdx, %rbx call mult2 movq %rax, (%rbx) popq %rbx ret
上面代码中每个缩进去的行都对应于一条机器指令。比如， pushq指令表示应该将寄存器％
rbx的内容压入程序栈中。这段代码中已经除去了所有关于局部变量名或数据类型的信息。
如果我们使用 ”-c"命令行选项， GCC会编译并汇编该代码：
linux> gee -Og -e mstore.e
这就会产生目标代码文件 mstore.o,它是二进制格式的，所以无法直接查看。 1368字节
的文件 mstore.o中有一段 14字节的序列，它的十六进制表示为：
53 48 89 d3 e8 00 00 00 00 48 89 03 Sb c3
这就是上面列出的汇编指令对应的目标代码。从中得到一个重要信息，即机器执行的程序只
是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"><meta property="og:site_name" content="随记"><meta property="og:title" content="随记"><meta property="og:description" content='第 3章 C H A P T E R 3 程序的机器级表示 计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写 存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集 和操作系统遵循的惯例，经过一系列的阶段生成机器代码。 GCCC语言编译器以汇编代码 的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。在本章中，我们会近 距离地观察机器代码，以及人类可读的表示汇编代码。 当我们用高级语言编程的时候（例如 C语言， Java语言更是如此），机器屏蔽了程序的细节，即机器级的实现。与此相反，当用汇编代码编程的时候（就像早期的计算），程序员必须指定程序用来执行计算的低级指令。高级语言提供的抽象级别比较高，大多数时候，在这种抽象级别上工作效率会更高，也更可靠。编译器提供的类型检查能帮助我们发现许多程序错误，并能够保证按照一致的方式来引用和处理数据。通常情况下，使用现代的优化编译器产生的代码至少与一个熟练的汇编语言程序员手工编写的代码一样有效。最大的优点是，用高级语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关的。 那么为什么我们还要花时间学习机器代码呢？即使编译器承担了生成汇编代码的大部分工作，对于严谨的程序员来说，能够阅读和理解汇编代码仍是一项很重要的技能。以适当的命令行选项调用编译器，编译器就会产生一个以汇编代码形式表示的输出文件。通过阅读这些汇编代码，我们能够理解编译器的优化能力，并分析代码中隐含的低效率。就像我们将在第 5章中体会到的那样，试图最大化一段关键代码性能的程序员，通常会尝试源代码的各种形式，每次编译并检查产生的汇编代码，从而了解程序将要运行的效率如何。此外，也有些时候，高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为。例如，第 12章会讲到，用线程包写并发程序时，了解不同的线程是如何共享程序数据或保持数据私有的，以及准确知道如何在哪里访问共享数据，都是很重要的。这些信息在机器代码级是可见的。另外再举一个例子，程序遭受攻击（使得恶意软件侵扰系统）的许多方式中，都涉及程序存储运行时控制信息的方式的细节。许多攻击利用了系统程序中的漏洞重写信息，从而获得了系统的控制权。了解这些漏洞是如何出现的，以及如何防御它们，需要具备程序机器级表示的知识。程序员学习汇编代码的需求随着时间的推移也发生了变化，开始时要求程序员能直接用汇编语言编写程序，现在则要求他们能够阅读和理解编译器产生的代码。 在本章中，我们将详细学习一种特别的汇编语言，了解如何将 C程序编译成这种形式的机器代码。阅读编译器产生的汇编代码，需要具备的技能不同千手工编写汇编代码。我们必须了解典型的编译器在将 C程序结构变换成机器代码时所做的转换。相对于 C代码表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换慢速操作，甚至将递归计算变换成迭代计算。源代码与对应的汇编代码的关系通常不太容易理解一一凉尤像要拼出的拼图与盒子上图片的设计有点不太一样。这是一种逆向工程 (reverse engineering)一一－通过研究系统和逆向工作，来试图了解系统的创建过程。在这里，系统是一个机器产生的汇编语言程序，而不是由人设计的某个东西。这简化了逆向工程的任务，因为产生的代码遵循比较规则的模式，而且我们可以做试验，让编译器产生许多不同程序的代码。本章提供了许多示例和大量的练习，来说明汇编语言和编译器的各个不同方面。精通细节是理解更深和更基本概念的先决条件。有人说：“我理解了一般规则，不愿意劳神去学习细节！”他们实际上是在自欺欺人。花时间研究这些示例、完成练习并对照提供的答案来检查你的答案，是非常关键的。 我们的表述基于 x86-64,它是现在笔记本电脑和台式机中最常见处理器的机器语言，也是驱动大型数据中心和超级计算机的最常见处理器的机器语言。这种语言的历史悠久，开始于 Intel公司 1978年的第一个 16位处理器，然后扩展为 32位，最近又扩展到 64位。一路以来，逐渐增加了很多特性，以更好地利用已有的半导体技术，以及满足市场需求。这些进步中很多是 Intel自己驱动的，但它的对手 AMD(Advanced Micro Devices)也作出了重要的贡献。演化的结果是得到一个相当奇特的设计，有些特性只有从历史的观点来看才有意义，它还具有提供后向兼容性的特性，而现代编译器和操作系统早已不再使用这些特性。我们将关注 GCC和 Linux使用的那些特性，这样可以避免 x86-64的大量复杂性和许多隐秘特性。 我们在技术讲解之前，先快速浏览 C语言、汇编代码以及机器代码之间的关系。然后介绍 x86-64的细节，从数据的表示和处理以及控制的实现开始。了解如何实现 C语言中的控制结构，如辽、 while和 switch语句。之后，我们会讲到过程的实现，包括程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储。接着，我们会考虑在机器级如何实现像数组、结构和联合这样的数据结构。有了这些机器级编程的背景知识，我们会讨论内存访问越界的问题，以及系统容易遭受缓冲区溢出攻击的问题。在这一部分的结尾，我们会给出一些用 GDB调试器检查机器级程序运行时行为的技巧。本章的最后展示了包含浮点数据和操作的代码的机器程序表示。 -IA32编程 IA32, x86-64的 32位前身，是 Intel在 1985年提出的。几十年来一直是 Intel的机器语言之选。今天出售的大多数 x86微处理器，以及这些机器上安装的大多数操作系统，都是为运行 x86-64设计的。不过，它们也可以向后兼容执行 IA32程序。所以，很多应用程序还是基于 IA32的。除此之外，由于硬件或系统软件的眼制，许多已有的系统不能够执行 x86-64。 IA32仍然是一种重要的机器语言。学习过 x86-64会使你很容易地学会 IA32机器语言。 计算机工业已经完成从 32位到 64位机器的过渡。 32位机器只能使用大概 4GB（沪字节）的随机访问存储器。存储器价格急剧下降，而我们对计算的需求和数据的大小持续增加，超越这个限制既经济上可行又有技术上的需要。当前的 64位机器能够使用多达 256TB(2 “字节）的内存空间，而且很容易就能扩展至 16EB(2“字节）。虽然很难想象一台机器需要这么大的内存，但是回想 20世纪 70和 80年代，当 32位机器开始普及的时候， 4GB的内存看上去也是超级大的。 我们的表述集中于以现代操作系统为目标，编译 C或类似编程语言时，生成的机器级程序类型。 x86-64有一些特性是为了支持遗留下来的微处理器早期编程风格，在此，我们不试图去描述这些特性，那时候大部分代码都是手工编写的，而程序员还在努力与 16位机器允许的有限地址空间奋战。 3. 1 历史观点 Intel处理器系列俗称 x86,经历了一个长期的、不断进化的发展过程。开始时，它是第 一代单芯片、 16位微处理器之一，由于当时集成电路技术水平十分有限，其中做了很多妥 协。以后，它不断地成长，利用进步的技术满足更高性能和支持更高级操作系统的需求。 以下列举了一些 Intel处理器的模型，以及它们的一些关键特性，特别是影响机器级 编程的特性。我们用实现这些处理器所需要的品体管数量来说明演变过程的复杂性。其 中， “K"表示 1000, “M"表示 1 000 000,而 “G"表示 1 000 000 000。 8086(1978年， 29K个晶体管）。它是第一代单芯片、 16位微处理器之一。 8088是 8086 的一个变种，在 8086上增加了一个 8位外部总线，构成最初的 IBM个人计算机的心脏。 IBM与当时还不强大的微软签订合同，开发 MS-DOS操作系统。最初的机器型号有 32 768字 节的内存和两个软驱（没有硬盘驱动器）。从体系结构上来说，这些机器只有 655 360字节的 地址空间地址只有 20位长（可寻址范围为 1 048 576字节），而操作系统保留了 393 216字 节自用。 1980年， Intel提出了 8087浮点协处理器 (45K个晶体管），它与一个 8086或 8088 处理器一同运行，执行浮点指令。 8087建立了 x86系列的浮点模型，通常被称为 “x87”。 80286(1982年， 134K个品体管）。增加了更多的寻址模式（现在巳经废弃了），构成 了 IBM PC-AT个人计算机的基础，这种计算机是 MS Windows最初的使用平台。 i386(1985年， 275K个晶体管）。将体系结构扩展到 32位。增加了平坦寻址模式 (flat addressing model), Linux和最近版本的 Windows操作系统都是使用的这种模式。这是 Intel系列中第一台全面支持 Unix操作系统的机器。 i486(1989年， 1. 2M个晶体管）。改善了性能，同时将浮点单元集成到了处理器芯片 上，但是指令集没有明显的改变。 Pentium(l993年， 3. lM个晶体管）。改善了性能，不过只对指令集进行了小的扩展。 PentiumPro(l995年， 5 . 5M个晶体管）。引入全新的处理器设计，在内部被称为 P6 微体系结构。指令集中增加了一类”条件传送 (conditional move)“指令。 Pentium/MMX(1997年， 4. 5M个晶体管）。在 Pentium处理器中增加了一类新的处 理整数向量的指令。每个数据大小可以是 1、 2或 4字节。每个向掀总长 64位。 Pentium 11(1997年， 7M个晶体管）。 P6微体系结构的延伸。 Pentium 1110999年， 8. 2M个晶体管）。引入了 SSE,这是一类处理整数或浮点数向 量的指令。每个数据可以是 1、 2或 4个字节，打包成 128位的向量。由于芯片上包括了 二级高速缓存，这种芯片后来的版本最多使用了 24M个晶体管。 Pentium 4(2000年， 42M个晶体管）。 SSE扩展到了 SSE2，增加了新的数据类型（包括双精度浮点数），以及针对这些格式的 144条新指令。有了这些扩展，编译器可以使用 SSE指令（而不是 x87指令），来编译浮点代码。 Pentium 4E(2004年， 125M个晶体管）。增加了超线程 (hyperthreading)，这种技术可以在一个处理器上同时运行两个程序；还增加了 EM64T,它是 Intel对 AMD提出的对 IA32的 64位扩展的实现，我们称之为 x86-64。 Core 2(2006年， 291M个晶体管）。回归到类似千 P 6的微体系结构。 Intel的第一个多核微处理器，即多处理器实现在一个芯片上。但不支持超线程。 Core i7, Ne halem( 2 008年， 781M个晶体管）。既支持超线程，也有多核，最初的版本支持每个核上执行两个程序，每个芯片上最多四个核。 Core i7, Sandy Bridge(2011年， 1. 17G个晶体管）。引入了 AVX,这是对 SSE的扩展，支持把数据封装进 2 5 6位的向量。 Core i7, Ha sw ell(2013年， 1. 4G个晶体管）。将 AVX扩展至 AVX2，增加了更多的 指令和指令格式。 每个后继处理器的设计都是后向兼容的一较早版本上编译的代码可以在较新的处理 器上运行。正如我们看到的那样，为了保持这种进化传统，指令集中有许多非常奇怪的东西。 Intel处理器系列有好几个名字，包括 IA32,也就是 “Inte l 32位体系结构 (Intel Architecture 32-bit)",以及最新的 lntel64,即 IA 3 2的 64位扩展，我们也称为 x86-64。最常用的名字是 “x86”,我们用它指代整个系列，也反映了直到 i486处理器命名的惯例。 m摩尔定律 (Moore’s Law) 如果我们画出各种不同的 Int e l处理器中晶体管的数量与它们出现的年份之间的图 (y轴为晶体管数量的对数值），我们能够看出，增长是很显著的。画一条拟合这些数据 的线，可以看到晶体管数量以每年大约 37％的速率增加，也就是说，晶体管数量每 26 个月就会翻一番。在 x86微处理器的历史上，这种增长已经持续了好几十年。 Intel微处理器的复杂性 LOE+ 10 LOE+ 09 Nehalem . OEOEOE 080706 Pentium 4e～冬e2 Duo lll+++ Pentium 4 I.OE+ 05 l.OE +04 1975 1980 1985 1990 1995 2000 2005 2010 2015 年份 1 9 6 5年， Gordon Moore, Intel公司的创始人，根据当时的芯片技术（那时他们能够在 一个芯片上制造有大约 64个晶体管的电路）做出推断，预测在未来 10年，芯片上的晶体 管数量每年都会翻一番。这个预测就称为摩尔定律。正如事实证明的那样，他的预测有点乐 观，而且短视。在超过 50年中，半导体工业一直能够使得晶体管数目每 1 8个月翻一倍。 对计算机技术的其他方面，也有类似的呈指数增长的情况出现，比如磁盘和半导体 存储器的存储容量。这些惊人的增长速度一直是计算机革命的主要驱动力。 这些年来，许多公司生产出了与 Intel处理器兼容的处理器，能够运行完全相同的机器级程序。其中，领头的是 AMD。数年来， AMD在技术上紧跟 Intel,执行的市场策略是：生产性能稍低但是价格更便宜的处理祥。 20 0 2年， AMD的处理器变得更加有竞争 力，它们率先突破了可商用微处理器的 1GHz的时钟速度屏障，并且引入了广泛采用的 IA32的 64位扩展 x86-64。虽然我们讲的是 Intel处理器，但是对千其竞争对手生产的与之兼容的处理器来说，这些表述也同样成立。 对于由 GCC编译器产生的、在 Linux操作系统平台上运行的程序，感兴趣的人大多并不关心 x86的复杂性。最初的 8086提供的内存模型和它在 80286中的扩展，到 i386的时候就都已经过时了。原来的 x87浮点指令到引入 SSE2以后就过时了。虽然在 x86-64程序中，我 们能看到历史发展的痕迹，但 x86中许多最晦涩难懂的特性已经不会出现了。 缅谈胆迁喽 3. 2 程序编码假设一个 C程序，有两个文件 pl.c和 p2.c。我们用 Unix命令行编译这些代码： linux> gee -Og -op pt.e p2.e 命令 gee指的就是 GCC C编译器。因为这是 Linux上默认的编译器，我们也可以简单地用 cc来启动它。编译选项－Og e告诉编译器使用会生成符合原始 C代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。因此我们会使用－Og优化作为学习工具，然后当我们增加优化级别时，再看会发生什么。实际中，从得到的程序的性能考虑，较高级别的优化（例如，以选项－01或－02指定）被认为是较好的选择。 实际上 gee命令调用了一整套的程序，将源代码转化成可执行代码。首先， C预处理器扩展源代码，插入所有用＃ include命令指定的文件，并扩展所有用＃define声明指定的宏。其次，编译器产生两个源文件的汇编代码，名字分别为 pl. s和 p2.s。接下来，汇编器会将汇编代码转化成二进制目标代码文件 p1.o和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。最后，链接器将两个目标代码文件与实现库函数（例如 printf)的代码合并，并产生最终的可执行代码文件 p（由命令行指示符－op指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。我们会在第 7章更详细地介绍这些不同形式的机器代码之间的关系以及链接的过程。 3. 2. 1 机器级代码正如在 1. 9. 3节中讲过的那样，计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对千机器级编程来说，其中两种抽象尤为重要。第一种是由指令集体系结构或指令集架构 <Instruction Set Arehitecture, ISA)来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数 ISA,包括 x86-64,将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与 ISA指定的顺序执行的行为完全一致。第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来，这会在第 9章中讲到。在整个编译过程中，编译器会完成大部分的工作，将把用 C语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。能够理解汇编代码以及它与原始 C代码的联系，是理解计算机如何执行程序的关键一步。 x86-64的机器代码和原始的 C代码差别非常大。一些通常对 C语言程序员隐藏的处理器状态都是可见的： ·程序计数器（通常称为 “PC”,在 x86-64中用％ rip表示）给出将要执行的下一条指令在内存中的地址。 GCC版本 4.8引人了这个优化等级。较早的 GCC版本和其他一些非 G~U编译器不认识这个选项。对这样一些编译器，使用一级优化（由命令行标志 -01指定）可能是最好的选择，生成的代码能够符合原始程序的结构。 ·整数寄存器文件包含 16个命名的位置，分别存储 64位的值。这些寄存器可以存储地址 （对应千 C语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其 他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。 ·条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或 数据流中的条件变化，比如说用来实现江和 while语句。 ·一组向量寄存器可以存放一个或多个整数或浮点数值。 虽然 C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。 C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。即使是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至于不区分指针和整数。 程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如说用 malloc库函数分配的）。正如前面提到的，程序内存用虚拟地址来寻址。在任意给定的时刻，只有有限的一部分虚拟地址 被认为是合法的。例如， x86-64的虚拟地址是由 64位的字来表示的。在目前的实现中，这些地址的高 16位必须设置为 o,所以一个地址实际上能够指定的是 2“或 64TB范围内的一个字节。较为典型的程序只会访问几兆字节或几千兆字节的数据。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。 一条机器指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现（像算术表达式求值、循环或过程调用和返回这样的）程序结构。 四曰不断变化的生成代码的格式 在本书的表述中，我们给出的代码是由特定版本的 GCC在特定的命令行选项设置 下产生的。如果你在自己的机器上编译代码，很有可能用到其他的编译器或者不同版本 的 GCC,因而会产生不同的代码。支持 GCC的开源社区一直在修改代码产生器，试图 根据微处理器制造商提供的不断变化的代码规则，产生更有效的代码。 本书示例的目标是展示如何查看汇编代码，并将它反向映射到高级编程语言中的结 构。你需要将这些技术应用到你的特定的编译器产生的代码格式上。 3. 2. 2 代码示例 假设我们写了一个 C语言代码文件 mstore.c,包含如下的函数定义： long mult2(long, long); void multstore(long x, long y, long .dest) { long t = mult2(x, y); .dest = t; } 在命令行上使用 ”-s"选项，就能看到 C语言编译器产生的汇编代码： linux> gee -Og -S mstore.e 这会使 GCC运行编译器，产生一个汇编文件 mstore.s,但是不做其他进一步的工作。（通常情况下，它还会继续调用汇编器产生目标代码文件）。 汇编代码文件包含各种声明，包括下面几行： multstore: pushq %rbx movq 1!.rdx, %rbx call mult2 movq %rax, (%rbx) popq %rbx ret 上面代码中每个缩进去的行都对应于一条机器指令。比如， pushq指令表示应该将寄存器％ rbx的内容压入程序栈中。这段代码中已经除去了所有关于局部变量名或数据类型的信息。 如果我们使用 ”-c"命令行选项， GCC会编译并汇编该代码： linux> gee -Og -e mstore.e 这就会产生目标代码文件 mstore.o,它是二进制格式的，所以无法直接查看。 1368字节 的文件 mstore.o中有一段 14字节的序列，它的十六进制表示为： 53 48 89 d3 e8 00 00 00 00 48 89 03 Sb c3 这就是上面列出的汇编指令对应的目标代码。从中得到一个重要信息，即机器执行的程序只 是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。'><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Index | 随记</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/><link rel=stylesheet href=/book.min.61c2259501b059453d6e3b0551df29ef9de07bb5236b73baae9ac80bb6f5e94c.css integrity="sha256-YcIllQGwWUU9bjsFUd8p753ge7Uja3O6rprIC7b16Uw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.d687cd9fc49cef6a7025c0e8e5d0bdcf3016b29d2746a7afbc3173365ceafb72.js integrity="sha256-1ofNn8Sc72pwJcDo5dC9zzAWsp0nRqevvDFzNlzq+3I=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>随记</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><a href=/zh/docs/technology/>技术</a><ul><li><input type=checkbox id=section-d2e5dc71fe2274ddaa089e125f33ae58 class=toggle>
<label for=section-d2e5dc71fe2274ddaa089e125f33ae58 class="flex justify-between"><a role=button>My SQL</a></label><ul><li><input type=checkbox id=section-b36f39b28986b079f4216fd3e38bfa3e class=toggle>
<label for=section-b36f39b28986b079f4216fd3e38bfa3e class="flex justify-between"><a role=button>My Sql是怎样运行的</a></label><ul><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC26%E7%AB%A0_%E5%86%99%E4%BD%9C%E6%9C%AC%E4%B9%A6%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>第26章_写作本书时用到的一些重要的参考资料</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC25%E7%AB%A0_%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E8%80%81%E5%A4%A7%E9%9A%BE-%E9%94%81/>第25章_工作面试老大难-锁</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC24%E7%AB%A0_%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%9A%E5%B9%85%E9%9D%A2%E5%AD%94-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC/>第24章_一条记录的多幅面孔-事务的隔离级别与MVCC</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC22%E7%AB%A0_%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%E4%B8%8A/>第22章_后悔了怎么办-undo日志(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC23%E7%AB%A0_%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%E4%B8%8B/>第23章_后悔了怎么办-undo日志(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC21%E7%AB%A0_%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%E4%B8%8B/>第21章_说过的话就一定要办到-redo日志(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC20%E7%AB%A0_%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%E4%B8%8A/>第20章_说过的话就一定要办到-redo日志(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC19%E7%AB%A0_%E4%BB%8E%E7%8C%AB%E7%88%B7%E8%A2%AB%E6%9D%80%E8%AF%B4%E8%B5%B7-%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/>第19章_从猫爷被杀说起-事务简介</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC18%E7%AB%A0_%E8%B0%83%E8%8A%82%E7%A3%81%E7%9B%98%E5%92%8CCPU%E7%9A%84%E7%9F%9B%E7%9B%BE-InnoDB%E7%9A%84BufferPool/>第18章_调节磁盘和CPU的矛盾-InnoDB的BufferPool</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC17%E7%AB%A0_%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-optimizer_trace%E8%A1%A8%E7%9A%84%E7%A5%9E%E5%99%A8%E5%8A%9F%E6%95%88/>第17章_神兵利器-optimizer_trace表的神器功效</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC16%E7%AB%A0_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8B/>第16章_查询优化的百科全书-Explain详解(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC15%E7%AB%A0_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8A/>第15章_查询优化的百科全书-Explain详解(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC14%E7%AB%A0_%E4%B8%8D%E5%A5%BD%E7%9C%8B%E5%B0%B1%E8%A6%81%E5%A4%9A%E6%95%B4%E5%AE%B9-MySQL%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96%E5%86%85%E5%90%AB%E5%85%B3%E4%BA%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%BA%8C%E4%B8%89%E4%BA%8B%E5%84%BF/>第14章_不好看就要多整容-MySQL基于规则的优化(内含关于子查询优化二三事儿)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC13%E7%AB%A0_%E5%85%B5%E9%A9%AC%E6%9C%AA%E5%8A%A8%E7%B2%AE%E8%8D%89%E5%85%88%E8%A1%8C-InnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E7%9A%84/>第13章_兵马未动粮草先行-InnoDB统计数据是如何收集的</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC12%E7%AB%A0_%E8%B0%81%E6%9C%80%E4%BE%BF%E5%AE%9C%E5%B0%B1%E9%80%89%E8%B0%81-MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/>第12章_谁最便宜就选谁-MySQL基于成本的优化</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC11%E7%AB%A0_%E4%B8%A4%E4%B8%AA%E8%A1%A8%E7%9A%84%E4%BA%B2%E5%AF%86%E6%8E%A5%E8%A7%A6-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/>第11章_两个表的亲密接触-连接的原理</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC10%E7%AB%A0_%E6%9D%A1%E6%9D%A1%E5%A4%A7%E8%B7%AF%E9%80%9A%E7%BD%97%E9%A9%AC-%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/>第10章_条条大路通罗马-单表访问方法</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC9%E7%AB%A0_%E5%AD%98%E6%94%BE%E9%A1%B5%E7%9A%84%E5%A4%A7%E6%B1%A0%E5%AD%90-InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/>第9章_存放页的大池子-InnoDB的表空间</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC8%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%B6-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/>第8章_数据的家-MySQL的数据目录</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC7%E7%AB%A0_%E5%A5%BD%E4%B8%9C%E8%A5%BF%E4%B9%9F%E5%BE%97%E5%85%88%E5%AD%A6%E4%BC%9A%E6%80%8E%E4%B9%88%E7%94%A8-B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/>第7章_好东西也得先学会怎么用-B+树索引的使用</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC6%E7%AB%A0_%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A7%98%E7%B1%8D-B+%E6%A0%91%E7%B4%A2%E5%BC%95/>第6章_快速查询的秘籍-B+树索引</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC5%E7%AB%A0-%E7%9B%9B%E6%94%BE%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%A7%E7%9B%92%E5%AD%90-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/>第5章_盛放记录的大盒子-InnoDB数据页结构</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC4%E7%AB%A0_%E4%BB%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E8%AF%B4%E8%B5%B7-InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/>第4章_从一条记录说起-InnoDB记录结构</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC3%E7%AB%A0_%E4%B9%B1%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/>第3章_乱码的前世今生-字符集和比较规则</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC2%E7%AB%A0_MySQL%E7%9A%84%E8%B0%83%E6%8E%A7%E6%8C%89%E9%92%AE-%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/>第2章_MySQL的调控按钮-启动选项和系统变量</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC1%E7%AB%A0_%E8%A3%85%E4%BD%9C%E8%87%AA%E5%B7%B1%E6%98%AF%E4%B8%AA%E5%B0%8F%E7%99%BD-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86MySQL/>第1章_装作自己是个小白-重新认识MySQL</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC0%E7%AB%A0_%E4%B8%87%E9%87%8C%E9%95%BF%E5%BE%81%E7%AC%AC%E4%B8%80%E6%AD%A5%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81-%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E7%9A%84%E9%98%85%E8%AF%BB%E6%9C%AC%E5%B0%8F%E5%86%8C/>第0章_万里长征第一步(非常重要)-如何愉快的阅读本小册</a></li></ul></li><li><input type=checkbox id=section-14acbe73a39f7c2e8d055bbdbab560d6 class=toggle>
<label for=section-14acbe73a39f7c2e8d055bbdbab560d6 class="flex justify-between"><a role=button>_MySQL是怎样运行的_</a></label><ul><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/08/>08数据的家--MySQL的数据目录</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/07/>07B+数索引的使用</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/06/>06B+树索引</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/05/>05InnoDB数据页结构</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/04/>04InnoDB记录存储结构</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/03/>03字符集和比较规则</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/02/>02启动选项和系统变量</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/01/>01初识MySQL</a></li></ul></li><li><input type=checkbox id=section-522269efe4a436e18b16a29ff12d542d class=toggle>
<label for=section-522269efe4a436e18b16a29ff12d542d class="flex justify-between"><a role=button>高性能 My SQL</a></label><ul><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83/>封面-版权</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC9%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96/>第9章操作系统和硬件优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC8%E7%AB%A0%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/>第8章优化服务器设置</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC7%E7%AB%A0MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/>第7章MySQL高级特性</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC6%E7%AB%A0%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>第6章查询性能优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC5%E7%AB%A0%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/>第5章创建高性能的索引</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC4%E7%AB%A0Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/>第4章Schema与数据类型优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC3%E7%AB%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/>第3章服务器性能剖析</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC2%E7%AB%A0MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/>第2章MySQL基准测试</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC1%E7%AB%A0MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2/>第1章MySQL架构与历史</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC16%E7%AB%A0MySQL%E7%94%A8%E6%88%B7%E5%B7%A5%E5%85%B7/>第16章MySQL用户工具</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC15%E7%AB%A0%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/>第15章备份与恢复</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC14%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82%E4%BC%98%E5%8C%96/>第14章应用层优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC13%E7%AB%A0%E4%BA%91%E7%AB%AF%E7%9A%84MySQL/>第13章云端的MySQL</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC12%E7%AB%A0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/>第12章高可用性</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC11%E7%AB%A0%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84MySQL/>第11章可扩展的MySQL</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC10%E7%AB%A0%E5%A4%8D%E5%88%B6/>第10章复制</a></li></ul></li><li><input type=checkbox id=section-33ad04dc8d65b11ab6b2d2e0964c3c89 class=toggle>
<label for=section-33ad04dc8d65b11ab6b2d2e0964c3c89 class="flex justify-between"><a role=button>进阶(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MySQL/bl_sgg_/96-00/>mysql高阶_sgg 96-00</a></li></ul></li></ul></li><li><input type=checkbox id=section-1dd4601389ea65ef400f95373226aee0 class=toggle>
<label for=section-1dd4601389ea65ef400f95373226aee0 class="flex justify-between"><a role=button>Linux</a></label><ul><li><input type=checkbox id=section-eb3a110e9a221e46d625b63087e91152 class=toggle>
<label for=section-eb3a110e9a221e46d625b63087e91152 class="flex justify-between"><a role=button>SHELL编程(learnLinuxTV)_</a></label><ul><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/16-18/>16-18</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/12-15/>12-15</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/11DataStreams/>11DataStreams</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/07-10/>07-10</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/06ExitCode/>06ExitCode</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/05If/>05If</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/01-04/>01-04</a></li></ul></li><li><input type=checkbox id=section-cd7838d42e3d9f745d945ce90940f02e class=toggle>
<label for=section-cd7838d42e3d9f745d945ce90940f02e class="flex justify-between"><a role=button>韩顺平老师_</a></label><ul><li><a href=/zh/docs/technology/Linux/hanshunping_/52-x/>52-X</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/40-51/>linux_韩老师_40-51</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/28-39/>linux_韩老师_28-39</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/21-27/>linux_韩老师_21-33</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/12-20/>linux_韩老师_12-20</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/07-11/>linux_韩老师_07-11</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/01-06/>linux_韩老师_01-06</a></li></ul></li><li><a href=/zh/docs/technology/Linux/_TheLinuxCommandsHandbook_/>_TheLinuxCommandsHandbook_</a></li><li><a href=/zh/docs/technology/Linux/basic/>基本操作</a></li><li><a href=/zh/docs/technology/Linux/create_clone/>vmware上linux主机的安装和克隆</a></li></ul></li><li><input type=checkbox id=section-9f56b27db6873dfaab68a13a9088b050 class=toggle>
<label for=section-9f56b27db6873dfaab68a13a9088b050 class="flex justify-between"><a role=button>Reg Exp</a></label><ul><li><input type=checkbox id=section-e7092def48f35456be32e3b6257559e4 class=toggle>
<label for=section-e7092def48f35456be32e3b6257559e4 class="flex justify-between"><a role=button>基础(CoreySchafer)_</a></label><ul><li><a href=/zh/docs/technology/RegExp/baseCoreySchafer_/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class=toggle>
<label for=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class="flex justify-between"><a role=button>Hugo</a></label><ul><li><input type=checkbox id=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class=toggle>
<label for=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class="flex justify-between"><a role=button>主题</a></label><ul><li><a href=/zh/docs/technology/Hugo/themes/PaperMod/01/>使用PaperMode</a></li></ul></li><li><input type=checkbox id=section-d72f299b202b2766d1efe5fb807ed184 class=toggle>
<label for=section-d72f299b202b2766d1efe5fb807ed184 class="flex justify-between"><a role=button>基础(Giraffe学院)_</a></label><ul><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced20-23/>hugo进阶学习20-23</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced17-19/>hugo进阶学习17-19</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced11-16/>hugo进阶学习11-15</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced01-10/>hugo进阶学习01-10</a></li></ul></li></ul></li><li><input type=checkbox id=section-43be5f3c9fb2465efc746ae00240e4b3 class=toggle>
<label for=section-43be5f3c9fb2465efc746ae00240e4b3 class="flex justify-between"><a role=button>Obsidian</a></label><ul><li><a href=/zh/docs/technology/Obsidian/border-theme/>border-theme背景图片问题</a></li><li><a href=/zh/docs/technology/Obsidian/obsidian-theme/>obsidian-theme</a></li><li><a href=/zh/docs/technology/Obsidian/plugin/>plugin</a></li></ul></li><li><input type=checkbox id=section-7123c56777444b2f7157631dd88ad8f6 class=toggle>
<label for=section-7123c56777444b2f7157631dd88ad8f6 class="flex justify-between"><a role=button>Redis</a></label><ul><li><input type=checkbox id=section-e6cea4f92582460cfa10699a07a10e32 class=toggle>
<label for=section-e6cea4f92582460cfa10699a07a10e32 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/19-A/>redis_尚硅谷_19-A</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/18/>redis_尚硅谷_18</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/12-17/>redis_尚硅谷_12-17</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/06-11/>redis_尚硅谷_06-11</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/01-05/>redis_尚硅谷_01-05</a></li></ul></li><li><a href=/zh/docs/technology/Redis/rsync-use/>rsync使用</a></li><li><a href=/zh/docs/technology/Redis/redis-cluster/>redis集群搭建</a></li></ul></li><li><input type=checkbox id=section-a94b8d7740a71c28fc6e0f89885b2468 class=toggle>
<label for=section-a94b8d7740a71c28fc6e0f89885b2468 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><input type=checkbox id=section-64c6733376d70496ded44b4ef3db6718 class=toggle>
<label for=section-64c6733376d70496ded44b4ef3db6718 class="flex justify-between"><a role=button>_深入理解Java虚拟机_</a></label><ul><li><a href=/zh/docs/technology/JVM/_understanding_the_jvm_/03/>03垃圾收集器与内存分配策略</a></li></ul></li></ul></li><li><input type=checkbox id=section-e8f515fe7fc71d283363385aa363c2dd class=toggle>
<label for=section-e8f515fe7fc71d283363385aa363c2dd class="flex justify-between"><a role=button>其他</a></label><ul><li><a href=/zh/docs/technology/Other/kaoshi/>科目</a></li><li><a href=/zh/docs/technology/Other/pc_base/>电脑基础操作</a></li></ul></li><li><input type=checkbox id=section-f54112ca99b135fbc484938888b1f1a2 class=toggle>
<label for=section-f54112ca99b135fbc484938888b1f1a2 class="flex justify-between"><a href=/zh/docs/technology/Review/>面试</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/>JavaGuide</a><ul><li><input type=checkbox id=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class=toggle>
<label for=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class="flex justify-between"><a role=button>数据库</a></label><ul><li><input type=checkbox id=section-e7660273cef85dff1f39af04a42bd062 class=toggle>
<label for=section-e7660273cef85dff1f39af04a42bd062 class="flex justify-between"><a role=button>MySQL</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0606lymysql-query-execution-plan/>mysql执行计划</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0611lymysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0610lymysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0609lyindex-invalidation-caused-by-implicit-conversion/>MySQL中的隐式转换造成的索引失效</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0608lysome-thoughts-on-database-storage-time/>MySQL数据库时间类型数据存储建议</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0605lyhow-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0604lyinnodb-implementation-of-mvcc/>innodb引擎对MVCC的实现</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0603lytransaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0602lymysql-logs/>日志</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0601lymysql-index/>索引</a></li></ul></li><li><input type=checkbox id=section-680d077436e58b0cad0a63ed8edb5f53 class=toggle>
<label for=section-680d077436e58b0cad0a63ed8edb5f53 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/diagram/>redis问题图解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0703ly3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0704lyredis-memory-fragmentation/>redis内存碎片</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0702lyredis-spec-data-structure/>redis特殊数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0701lyredis-base-data-structures/>redis基本数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0706lyredis-questions-02/>redis面试题02</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0705lyredis-questions-01/>redis面试题01</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0503lysql-question-01/>sql常见面试题总结01</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0504lysql-syntax-summary/>sql语法基础知识总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0502lycharactor-set/>字符集详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0501lybasis/>数据库基础</a></li></ul></li><li><input type=checkbox id=section-a1b717b4079938cc0efe574541b240b8 class=toggle>
<label for=section-a1b717b4079938cc0efe574541b240b8 class="flex justify-between"><a role=button>系统设计</a></label><ul><li><input type=checkbox id=section-9eaf95f03abf595bfdf838c4b4cdb2ef class=toggle>
<label for=section-9eaf95f03abf595bfdf838c4b4cdb2ef class="flex justify-between"><a role=button>安全</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly06ly_sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly05ly_design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly04ly_sso-intro/>sso单点登录</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly03ly_jwt-advantages-disadvantages/>jwt身份认证优缺点</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly02ly_jwt-intro/>jwt-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly01ly_basis-of-authority-certification/>认证授权基础概念详解</a></li></ul></li><li><input type=checkbox id=section-79417049c90714c6ddbf18a3c3958148 class=toggle>
<label for=section-79417049c90714c6ddbf18a3c3958148 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/unit-test/>单元测试</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/software-engineering/>软件工程简明教程</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/restful/>restFul</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/web-real-time-message-push/>web-real-time-message-push</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/schedule-task/>Java定时任务详解</a></li></ul></li><li><input type=checkbox id=section-0a9533f3005d615c696f74456e46d269 class=toggle>
<label for=section-0a9533f3005d615c696f74456e46d269 class="flex justify-between"><a role=button>高可用</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly05ly_performance-test/>性能测试入门</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly04ly_timout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly03ly_limit-request/>服务限流详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly02ly_redundancy/>冗余设计</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly01ly_high-availability-system-design/>高可用系统设计指南</a></li></ul></li><li><input type=checkbox id=section-e36f94f48e5027e7cbd39b7f7bbc249c class=toggle>
<label for=section-e36f94f48e5027e7cbd39b7f7bbc249c class="flex justify-between"><a role=button>高性能</a></label><ul><li><input type=checkbox id=section-581624dd7aa25a150f706312689ba446 class=toggle>
<label for=section-581624dd7aa25a150f706312689ba446 class="flex justify-between"><a role=button>RocketMQ</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-questions/>rocketmq常见面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-intro/>rocketmq介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/base/>message-queue</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly02ly_cdn/>cdn</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly01ly_read-and-write-separation-and-library-subtable/>数据库读写分离&分库分表详解</a></li></ul></li><li><input type=checkbox id=section-a6916634f1b5324076467df4cc9ac3b5 class=toggle>
<label for=section-a6916634f1b5324076467df4cc9ac3b5 class="flex justify-between"><a role=button>分布式系统</a></label><ul><li><input type=checkbox id=section-0c8e62b6137b614e01882e2a88ea5daf class=toggle>
<label for=section-0c8e62b6137b614e01882e2a88ea5daf class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/raft-algorithm/>raft算法</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/paxos-algorithm/>paxos算法</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/cap_base-theorem/>CAP&amp;BASE 理论</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly08ly_zookeeper-in-action/>zookeeper实战</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly07ly_zookeeper-plus/>zookeeper进阶</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly06ly_zookeeper-intro/>zookeeper介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly04ly_rpc-http/>rpc_http</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly05ly_rpc-intro/>rpc基础及面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly03ly_distributed-lock/>分布式锁</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly02ly_distributed-id/>分布式id</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly01ly_api-gateway/>api网关</a></li></ul></li><li><input type=checkbox id=section-ce3cbb53c62f67624e4ab24a5a14298a class=toggle>
<label for=section-ce3cbb53c62f67624e4ab24a5a14298a class="flex justify-between"><a role=button>框架</a></label><ul><li><input type=checkbox id=section-dbe480810d1877286936b38cdb5e9229 class=toggle>
<label for=section-dbe480810d1877286936b38cdb5e9229 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><input type=checkbox id=section-30b916f2071579e2468767a2562433d9 class=toggle>
<label for=section-30b916f2071579e2468767a2562433d9 class="flex justify-between"><a role=button>原理</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle3/>Mybatis原理系列(3)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle2/>Mybatis原理系列(2)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle1/>Mybatis原理系列(1)</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/MyBatis-interview/>Mybatis面试</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/conditional_on_class/>ConditionalOnClass实践</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly05ly_springboot-auto-assembly/>SpringBoot自动装配原理</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly04ly_spring-design-patterns/>spring 设计模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly03ly_spring-transaction/>Spring事务详情</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly02ly_spring-annotations/>Spring/SpringBoot常用注解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/>spring 常见面试题总结</a></li></ul></li><li><input type=checkbox id=section-1f6733a85e33dcc22aabbf820e3ef963 class=toggle>
<label for=section-1f6733a85e33dcc22aabbf820e3ef963 class="flex justify-between"><a role=button>开发工具</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/git/>git</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/maven/>maven</a></li></ul></li><li><input type=checkbox id=section-c01151f806b917cd0ecc4cffa72c3402 class=toggle>
<label for=section-c01151f806b917cd0ecc4cffa72c3402 class="flex justify-between"><a role=button>Java基础</a></label><ul><li><input type=checkbox id=section-26625a0c4c0bffef02640966ca545537 class=toggle>
<label for=section-26625a0c4c0bffef02640966ca545537 class="flex justify-between"><a role=button>并发</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly030301lyatomicpre/>Atomic预备知识</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0311lycompletablefuture-intro/>completablefuture-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0310lythreadlocal/>ThreadLocal详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0309lyatomic-classes/>Atomic原子类介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0308lyaqs-details/>aqs详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0307lyconcurrent-collections/>java常见并发容器</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0306lythread-pool-best/>线程池最佳实践</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0305lyjava-thread-pool/>java线程池详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0304lyjmm/>java内存模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0303lyconcurrent-03/>并发03</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03122lylock_escalation/>锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated2/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03121lyobject-concurrent/>对象内存布局和对象头</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0302lyconcurrent-02/>并发02</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0301lyconcurrent-01/>并发01</a></li></ul></li><li><input type=checkbox id=section-8f747d8f024fbfe2b392a25696e01266 class=toggle>
<label for=section-8f747d8f024fbfe2b392a25696e01266 class="flex justify-between"><a role=button>IO</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0203lyio-model/>io模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0202lyio-design-patterns/>io设计模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0201lyio/>io基础</a></li></ul></li><li><input type=checkbox id=section-7d26c3d37b0e4678a1ec776265992903 class=toggle>
<label for=section-7d26c3d37b0e4678a1ec776265992903 class="flex justify-between"><a role=button>集合</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0105lysource-code-concurrenthashmap/>ConcurrentHashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0106lysource-code-hashmap/>HashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0104lysource-code-ArrayList/>ArrayList源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0103lycollections-precautions-for-use/>集合使用注意事项</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0102lycollection_2/>集合_2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0101lycollection_1/>集合_1</a></li></ul></li><li><input type=checkbox id=section-7027a9bc1d603892e7826da81b333f38 class=toggle>
<label for=section-7027a9bc1d603892e7826da81b333f38 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0011lysyntactic_sugar/>语法糖</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0010lyjava_spi/>java_spi</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0009lyunsafe_class/>unsafe类</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0008lybig_decimal/>big_decimal</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0007lyproxy_pattern/>Java代理模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0006lyreflex/>java-reflex</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0005lyserialize/>Java序列化详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0004lypassbyvalue/>为什么Java中只有值传递</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0003lyjava_guide_basic_3/>javaGuide基础3</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0002lyjava_guide_basic_2/>javaGuide基础2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0001lyjava_guide_basic_1/>javaGuide基础1</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0408lyjdk-monitoring-and-troubleshooting-tools/>jvm监控和故障处理工具 总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0406lyjvm-params/>jvm参数</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0403lyclass-structure/>类文件结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0405lyclassloader-detail/>类加载器详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0404lyclassloader-process/>类加载过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0402lygarbage-collection/>java垃圾回收</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0407lyjvm-intro/>jvm-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0401lymemory-area/>memory-area</a></li></ul></li><li><input type=checkbox id=section-04d967d6579d47b35ececb3d233024f1 class=toggle>
<label for=section-04d967d6579d47b35ececb3d233024f1 class="flex justify-between"><a role=button>计算机基础</a></label><ul><li><input type=checkbox id=section-316b43351a75a19ac6dec86ad1a48c45 class=toggle>
<label for=section-316b43351a75a19ac6dec86ad1a48c45 class="flex justify-between"><a role=button>数据结构</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/heap/>堆</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li></ul></li></ul></li><li><input type=checkbox id=section-09d19e9c6f50e4706fe8b6d358c441ce class=toggle>
<label for=section-09d19e9c6f50e4706fe8b6d358c441ce class="flex justify-between"><a role=button>Ssm</a></label><ul><li><a href=/zh/docs/technology/Review/ssm/scope_transaction/>作用域及事务</a></li></ul></li><li><input type=checkbox id=section-11f3d4afcbd3591ad3ee5d79993e29d7 class=toggle>
<label for=section-11f3d4afcbd3591ad3ee5d79993e29d7 class="flex justify-between"><a role=button>Java基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Review/basics/member_variables_and_local_variables/>成员变量与局部变量</a></li><li><a href=/zh/docs/technology/Review/basics/recursion_and_iteration/>递归与迭代</a></li><li><a href=/zh/docs/technology/Review/basics/method_parameter_passing_mechanism/>方法的参数传递机制</a></li><li><a href=/zh/docs/technology/Review/basics/class_and_instance_initialization/>类、实例初始化</a></li><li><a href=/zh/docs/technology/Review/basics/singleton_design_pattern/>单例设计模式</a></li><li><a href=/zh/docs/technology/Review/basics/self_incrementing_variable/>自增变量</a></li></ul></li></ul></li><li><input type=checkbox id=section-2fa8d2f95840b0143e19fcee5ee1ad97 class=toggle>
<label for=section-2fa8d2f95840b0143e19fcee5ee1ad97 class="flex justify-between"><a role=button>SpringCloud</a></label><ul><li><input type=checkbox id=section-b7a5506013de8d65cad1cac0f659f728 class=toggle>
<label for=section-b7a5506013de8d65cad1cac0f659f728 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/springCloud/bl_zhouyang_/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-5057ba12f456498454476dc11b58648b class=toggle>
<label for=section-5057ba12f456498454476dc11b58648b class="flex justify-between"><a role=button>Git</a></label><ul><li><input type=checkbox id=section-55d261358c84b4996ac8d7851d37ccf8 class=toggle>
<label for=section-55d261358c84b4996ac8d7851d37ccf8 class="flex justify-between"><a role=button>基础(尚硅谷视频)_</a></label><ul><li><a href=/zh/docs/technology/Git/git_sgg_/19-26/>19-26_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg_/09-18/>09-18_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg_/01-08/>01-08_git_尚硅谷</a></li></ul></li></ul></li><li><input type=checkbox id=section-d8f59257917ebff8da82fd22583ae10c class=toggle>
<label for=section-d8f59257917ebff8da82fd22583ae10c class="flex justify-between"><a role=button>Maven</a></label><ul><li><input type=checkbox id=section-9b52bdf229c64237c3a478dc6a533410 class=toggle>
<label for=section-9b52bdf229c64237c3a478dc6a533410 class="flex justify-between"><a role=button>进阶(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/advance_dljd_/01-21/>01-21 maven多模块管理_动力节点</a></li></ul></li><li><input type=checkbox id=section-3b2851b4ae70cae160ce8f24dba7236a class=toggle>
<label for=section-3b2851b4ae70cae160ce8f24dba7236a class="flex justify-between"><a role=button>基础(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/base_dljd_/31-43/>31-43 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd_/17-30/>17-30 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd_/01-16/>01-16 maven基础_动力节点</a></li></ul></li></ul></li><li><input type=checkbox id=section-d2ff9acb1ec90bec89f165361ced2010 class=toggle>
<label for=section-d2ff9acb1ec90bec89f165361ced2010 class="flex justify-between"><a role=button>算法</a></label><ul><li><input type=checkbox id=section-d1faa468beb89fe27a31308721f74c82 class=toggle>
<label for=section-d1faa468beb89fe27a31308721f74c82 class="flex justify-between"><a role=button>_算法(第四版)_</a></label><ul><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/3.2.1/>算法红皮书 3.2.1</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/3.1.1-3.1.7/>算法红皮书 3.1.1-3.1.7</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.5/>算法红皮书 2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.4/>算法红皮书 2.4</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.1.2-2.1.3/>算法红皮书 2.1.2-2.1.3</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.1.1/>算法红皮书 2.1.1</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.5.1-1.5.3/>算法红皮书 1.5.1-1.5.3</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.4.1-1.4.10/>算法红皮书 1.4.1-1.4.10</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.3.3.1-1.3.4/>算法红皮书1.3.3.1-1.3.4</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.3.1.1-1.3.2.5/>算法红皮书 1.3.1.1-1.3.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.2.1-1.2.5/>算法红皮书 1.2.1-1.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.1.6-1.1.11/>算法红皮书 1.1.6-1.1.11</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.1.1-1.1.5/>算法红皮书 1.1.1-1.1.5</a></li></ul></li></ul></li><li><input type=checkbox id=section-b414f13e51dbc5e90231aa49f06e7237 class=toggle>
<label for=section-b414f13e51dbc5e90231aa49f06e7237 class="flex justify-between"><a role=button>My Batis Plus</a></label><ul><li><input type=checkbox id=section-0e4fa61015701c3d99296175840aa5d3 class=toggle>
<label for=section-0e4fa61015701c3d99296175840aa5d3 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/40-57/>mybatis-plus-sgg-40-57</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/19-39/>mybatis-plus-sgg-19-39</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/12-18/>mybatis-plus-sgg-12-18</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/01-11/>mybatis-plus-sgg-01-11</a></li></ul></li><li><a href=/zh/docs/technology/MyBatis-Plus/official/hello/>官方的hello-world</a></li></ul></li><li><input type=checkbox id=section-1e5a67821c47d147a096480c75e0d7c4 class=toggle>
<label for=section-1e5a67821c47d147a096480c75e0d7c4 class="flex justify-between"><a role=button>Flowable</a></label><ul><li><input type=checkbox id=section-0a06ca67446b7a26392adaea7b2dc30f class=toggle>
<label for=section-0a06ca67446b7a26392adaea7b2dc30f class="flex justify-between"><a role=button>基础(波哥)_</a></label><ul><li><a href=/zh/docs/technology/Flowable/boge_blbl_/03-others/>boge-03-其他</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_6/>boge-02-flowable进阶_6</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_5/>boge-02-flowable进阶_5</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_4/>boge-02-flowable进阶_4</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_3/>boge-02-flowable进阶_3</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_2/>boge-02-flowable进阶_2</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_1/>boge-02-flowable进阶_1</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/01-base/>boge-01-flowable基础</a></li></ul></li><li><input type=checkbox id=section-6019d9043956834af14f96c2f7dcd5ca class=toggle>
<label for=section-6019d9043956834af14f96c2f7dcd5ca class="flex justify-between"><a role=button>官方文档</a></label><ul><li><a href=/zh/docs/technology/Flowable/offical/05/>Flowable-05-spring-boot</a></li><li><a href=/zh/docs/technology/Flowable/offical/04/>Flowable-04-spring</a></li><li><a href=/zh/docs/technology/Flowable/offical/03/>Flowable-03-api</a></li><li><a href=/zh/docs/technology/Flowable/offical/02/>Flowable-02-Configuration</a></li><li><a href=/zh/docs/technology/Flowable/offical/01/>Flowable-01-GettingStarted</a></li></ul></li><li><a href=/zh/docs/technology/Flowable/zsx_design/01/>zsx_flowable_design01</a></li></ul></li><li><input type=checkbox id=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class=toggle>
<label for=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class="flex justify-between"><a role=button>Rocket Mq</a></label><ul><li><input type=checkbox id=section-8c49e88e8756a0a7b3e45abde3117dd5 class=toggle>
<label for=section-8c49e88e8756a0a7b3e45abde3117dd5 class="flex justify-between"><a role=button>基础(黑马)_</a></label><ul><li><a href=/zh/docs/technology/RocketMQ/heima_/05advance/>05高级功能</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/04case/>04案例</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/03messagetype/>03收发消息</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/02buildcluster/>02双主双从集群搭建</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/01base/>01rocketmq学习</a></li></ul></li></ul></li><li><input type=checkbox id=section-dcbf6163d9f750f7cc3b9417d1386331 class=toggle>
<label for=section-dcbf6163d9f750f7cc3b9417d1386331 class="flex justify-between"><a role=button>Interview</a></label><ul><li><input type=checkbox id=section-c8fd55079fae864a8c659fb14cbb379e class=toggle>
<label for=section-c8fd55079fae864a8c659fb14cbb379e class="flex justify-between"><a role=button>Cs Basics</a></label><ul><li><input type=checkbox id=section-ac5cd91bf1acc2a16a9dbdfa9c17f629 class=toggle>
<label for=section-ac5cd91bf1acc2a16a9dbdfa9c17f629 class="flex justify-between"><a role=button>Algorithms</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/common-data-structures-leetcode-recommendations/>常见数据结构经典LeetCode题目推荐</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/linkedlist-algorithm-problems/>几道常见的链表算法题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/string-algorithm-problems/>几道常见的字符串算法题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/the-sword-refers-to-offer/>剑指offer部分编程题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/classical-algorithm-problems-recommendations/>经典算法思想总结（含LeetCode题目推荐）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/10-classical-sorting-algorithms/>十大经典排序算法总结</a></li></ul></li><li><input type=checkbox id=section-f435ca39dd71dd7765b81dd8ec05c344 class=toggle>
<label for=section-f435ca39dd71dd7765b81dd8ec05c344 class="flex justify-between"><a role=button>Data Structure</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/heap/>Index</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/bloom-filter/>布隆过滤器</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/red-black-tree/>红黑树</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li><li><input type=checkbox id=section-fa182df3abee2343aa6c977c2a75dda2 class=toggle>
<label for=section-fa182df3abee2343aa6c977c2a75dda2 class="flex justify-between"><a role=button>Network</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/network/computer-network-xiexiren-summary/>《计算机网络》（谢希仁）内容总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/arp/>ARP 协议详解(网络层)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/dns/>DNS 域名系统详解（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http1.0-vs-http1.1/>HTTP 1.0 vs HTTP 1.1（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http-vs-https/>HTTP vs HTTPS（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http-status-codes/>HTTP 常见状态码总结（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/nat/>NAT 协议详解（网络层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/osi-and-tcp-ip-model/>OSI 和 TCP/IP 网络分层模型详解（基础）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/tcp-reliability-guarantee/>TCP 传输可靠性保障（传输层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/tcp-connection-and-disconnection/>TCP 三次握手和四次挥手（传输层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/the-whole-process-of-accessing-web-pages/>访问网页的全过程（知识串联）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/other-network-questions/>计算机网络常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/other-network-questions2/>计算机网络常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/network-attack-means/>网络攻击常见手段总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/application-layer-protocol/>应用层常见协议总结（应用层）</a></li></ul></li><li><input type=checkbox id=section-76856ab8063b8754553c166410441284 class=toggle>
<label for=section-76856ab8063b8754553c166410441284 class="flex justify-between"><a role=button>Operating System</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/linux-intro/>Linux 基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/shell-intro/>Shell 编程基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-01/>操作系统常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-02/>操作系统常见面试题总结(下)</a></li></ul></li></ul></li><li><input type=checkbox id=section-fa219a2fa1e454bccf1abf45b7e68c8e class=toggle>
<label for=section-fa219a2fa1e454bccf1abf45b7e68c8e class="flex justify-between"><a role=button>Database</a></label><ul><li><input type=checkbox id=section-1e90eaf849a2719b2603214b93639e7c class=toggle>
<label for=section-1e90eaf849a2719b2603214b93639e7c class="flex justify-between"><a role=button>Elasticsearch</a></label><ul><li><a href=/zh/docs/technology/Interview/database/elasticsearch/elasticsearch-questions-01/>Elasticsearch常见面试题总结(付费)</a></li></ul></li><li><input type=checkbox id=section-36fcdf6608f26e92ce7bb1e95612ca73 class=toggle>
<label for=section-36fcdf6608f26e92ce7bb1e95612ca73 class="flex justify-between"><a role=button>Mongodb</a></label><ul><li><a href=/zh/docs/technology/Interview/database/mongodb/mongodb-questions-01/>MongoDB常见面试题总结（上）</a></li><li><a href=/zh/docs/technology/Interview/database/mongodb/mongodb-questions-02/>MongoDB常见面试题总结（下）</a></li></ul></li><li><input type=checkbox id=section-1681ed9defad2064b37ff3e603cd509c class=toggle>
<label for=section-1681ed9defad2064b37ff3e603cd509c class="flex justify-between"><a role=button>Mysql</a></label><ul><li><a href=/zh/docs/technology/Interview/database/mysql/innodb-implementation-of-mvcc/>InnoDB存储引擎对MVCC的实现</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-query-cache/>MySQL查询缓存详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/some-thoughts-on-database-storage-time/>MySQL日期类型选择建议</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-logs/>MySQL三大日志(binlog、redo log和undo log)详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/transaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-index/>MySQL索引详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/index-invalidation-caused-by-implicit-conversion/>MySQL隐式转换造成索引失效</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-query-execution-plan/>MySQL执行计划分析</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-auto-increment-primary-key-continuous/>MySQL自增主键一定是连续的吗</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/how-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/a-thousand-lines-of-mysql-study-notes/>一千行 MySQL 学习笔记</a></li></ul></li><li><input type=checkbox id=section-7b494a9accb20a42d3eb50307ebf95b8 class=toggle>
<label for=section-7b494a9accb20a42d3eb50307ebf95b8 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Interview/database/redis/3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-data-structures-02/>Redis 3 种特殊数据类型详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-data-structures-01/>Redis 5 种基本数据类型详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-questions-01/>Redis常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-questions-02/>Redis常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-common-blocking-problems-summary/>Redis常见阻塞原因总结</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-persistence/>Redis持久化机制详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-cluster/>Redis集群详解(付费)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-memory-fragmentation/>Redis内存碎片详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-skiplist/>Redis为什么用跳表实现有序集合</a></li><li><a href=/zh/docs/technology/Interview/database/redis/cache-basics/>缓存基础常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-delayed-task/>如何基于Redis实现延时任务</a></li></ul></li><li><input type=checkbox id=section-0b495945d7d1c7bace636f2809188369 class=toggle>
<label for=section-0b495945d7d1c7bace636f2809188369 class="flex justify-between"><a role=button>SQL</a></label><ul><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-01/>SQL常见面试题总结（1）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-02/>SQL常见面试题总结（2）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-03/>SQL常见面试题总结（3）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-04/>SQL常见面试题总结（4）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-05/>SQL常见面试题总结（5）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-syntax-summary/>SQL语法基础知识总结</a></li></ul></li><li><a href=/zh/docs/technology/Interview/database/nosql/>NoSQL基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/database/basis/>数据库基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/database/character-set/>字符集详解</a></li></ul></li><li><input type=checkbox id=section-9bc7f274474a2d4825bfb7e0f835ec9f class=toggle>
<label for=section-9bc7f274474a2d4825bfb7e0f835ec9f class="flex justify-between"><a role=button>Distributed System</a></label><ul><li><input type=checkbox id=section-4aa0a804a8f6d6d2745a8f9d92dbae63 class=toggle>
<label for=section-4aa0a804a8f6d6d2745a8f9d92dbae63 class="flex justify-between"><a role=button>Distributed Process Coordination</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-in-action/>ZooKeeper 实战</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus/>ZooKeeper相关概念总结(进阶)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro/>ZooKeeper相关概念总结(入门)</a></li></ul></li><li><input type=checkbox id=section-917636e43923e143cb27e958ae247d83 class=toggle>
<label for=section-917636e43923e143cb27e958ae247d83 class="flex justify-between"><a role=button>Protocol</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/cap-and-base-theorem/>CAP & BASE理论详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/gossip-protocl/>Gossip 协议详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/paxos-algorithm/>Paxos 算法详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/raft-algorithm/>Raft 算法详解</a></li></ul></li><li><input type=checkbox id=section-5f212fdd6451198aab8e6d9d1c28c4d2 class=toggle>
<label for=section-5f212fdd6451198aab8e6d9d1c28c4d2 class="flex justify-between"><a role=button>Rpc</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/dubbo/>Dubbo常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/rpc-intro/>RPC基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/httprpc/>有了 HTTP 协议，为什么还要有 RPC ？</a></li></ul></li><li><a href=/zh/docs/technology/Interview/distributed-system/api-gateway/>API网关基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/spring-cloud-gateway-questions/>Spring Cloud Gateway常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-id/>分布式ID介绍&实现方案总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-id-design/>分布式ID设计指南</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-configuration-center/>分布式配置中心常见问题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-transaction/>分布式事务常见解决方案总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-lock-implementations/>分布式锁常见实现方案总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-lock/>分布式锁介绍</a></li></ul></li><li><input type=checkbox id=section-20eb042d5085894960b2b40cdde1bd95 class=toggle>
<label for=section-20eb042d5085894960b2b40cdde1bd95 class="flex justify-between"><a role=button>High Availability</a></label><ul><li><a href=/zh/docs/technology/Interview/high-availability/timeout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/limit-request/>服务限流详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/high-availability-system-design/>高可用系统设计指南</a></li><li><a href=/zh/docs/technology/Interview/high-availability/fallback-and-circuit-breaker/>降级&熔断详解(付费)</a></li><li><a href=/zh/docs/technology/Interview/high-availability/redundancy/>冗余设计详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/performance-test/>性能测试入门</a></li></ul></li><li><input type=checkbox id=section-d863e9c02108d739d2116dee6c3f0df2 class=toggle>
<label for=section-d863e9c02108d739d2116dee6c3f0df2 class="flex justify-between"><a role=button>High Performance</a></label><ul><li><a href=/zh/docs/technology/Interview/high-performance/cdn/>CDN工作原理详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/disruptor-questions/>Disruptor常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/kafka-questions-01/>Kafka常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/rabbitmq-questions/>RabbitMQ常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/rocketmq-questions/>RocketMQ常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/sql-optimization/>常见SQL优化手段总结（付费）</a></li><li><a href=/zh/docs/technology/Interview/high-performance/read-and-write-separation-and-library-subtable/>读写分离和分库分表详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/load-balancing/>负载均衡原理及算法详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/deep-pagination-optimization/>深度分页介绍及优化建议</a></li><li><a href=/zh/docs/technology/Interview/high-performance/data-cold-hot-separation/>数据冷热分离详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/message-queue/>消息队列基础知识总结</a></li></ul></li><li><input type=checkbox id=section-2874dffbab1645c0b90b66f58878baeb class=toggle>
<label for=section-2874dffbab1645c0b90b66f58878baeb class="flex justify-between"><a role=button>High Quality Technical Articles</a></label><ul><li><input type=checkbox id=section-043c9e2ae521f883513d71615d921b93 class=toggle>
<label for=section-043c9e2ae521f883513d71615d921b93 class="flex justify-between"><a role=button>Advanced Programmer</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant/>程序员的技术成长战略</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/programmer-quickly-learn-new-technology/>程序员如何快速学习新技术</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/seven-tips-for-becoming-an-advanced-programmer/>给想成长为高级别开发同学的七条建议</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work/>工作五年之后，对技术和业务的思考</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/meituan-three-year-summary-lesson-10/>美团三年，总结的10条血泪教训</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road/>十年大厂成长之路</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/20-bad-habits-of-bad-programmers/>糟糕程序员的 20 个坏习惯</a></li></ul></li><li><input type=checkbox id=section-5a7311ea7fe807f97a6fa93dffde10b6 class=toggle>
<label for=section-5a7311ea7fe807f97a6fa93dffde10b6 class="flex justify-between"><a role=button>Interview</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/some-secrets-about-alibaba-interview/>阿里技术面试的一些秘密</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/technical-preliminary-preparation/>从面试官和候选者的角度谈如何准备技术初试</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/summary-of-spring-recruitment/>普通人的春招总结（阿里、腾讯offer）</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology/>如何在技术初试中考察程序员的技术能力</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/screen-candidates-for-packaging/>如何甄别应聘者的包装程度</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/my-personal-experience-in-2021/>校招进入飞书的个人经验</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer/>一位大龄程序员所经历的面试的历炼和思考</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-of-get-offer-from-over-20-big-companies/>斩获 20+ 大厂 offer 的面试经验分享</a></li></ul></li><li><input type=checkbox id=section-bf0bb8140b840e0af3c2632b6b73e609 class=toggle>
<label for=section-bf0bb8140b840e0af3c2632b6b73e609 class="flex justify-between"><a role=button>Personal Experience</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/four-year-work-in-tencent-summary/>从校招入职腾讯的四年工作总结</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao/>滴滴和头条两年后端工作经验分享</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/huawei-od-275-days/>华为 OD 275 天后，我进了腾讯！</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/8-years-programmer-work-summary/>一个中科大差生的 8 年程序员工作总结</a></li></ul></li><li><input type=checkbox id=section-8166233fd6553926230055376f2b97f6 class=toggle>
<label for=section-8166233fd6553926230055376f2b97f6 class="flex justify-between"><a role=button>Programmer</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/efficient-book-publishing-and-practice-guide/>程序员高效出书避坑和实践指南</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/how-do-programmers-publish-a-technical-book/>程序员怎样出版一本技术书</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/high-value-certifications-for-programmers/>程序员最该拿的几种高含金量证书</a></li></ul></li><li><input type=checkbox id=section-b607a393d7717c448e31e58c8972bbba class=toggle>
<label for=section-b607a393d7717c448e31e58c8972bbba class="flex justify-between"><a role=button>Work</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/32-tips-improving-career/>32条总结教你提升职场经验</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/employee-performance/>聊聊大厂的绩效考核</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/get-into-work-mode-quickly-when-you-join-a-company/>新入职一家公司如何快速进入工作状态</a></li></ul></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/readme/>Index</a></li></ul></li><li><input type=checkbox id=section-5680a0cf00b09d8470dc67fa0a170b89 class=toggle>
<label for=section-5680a0cf00b09d8470dc67fa0a170b89 class="flex justify-between"><a role=button>Java</a></label><ul><li><input type=checkbox id=section-6e2eabf08cfe622d9921e3edfa11e55a class=toggle>
<label for=section-6e2eabf08cfe622d9921e3edfa11e55a class="flex justify-between"><a role=button>Basis</a></label><ul><li><a href=/zh/docs/technology/Interview/java/basis/java-keyword-summary/>Index</a></li><li><a href=/zh/docs/technology/Interview/java/basis/bigdecimal/>BigDecimal 详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/spi/>Java SPI 机制详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/proxy/>Java 代理模式详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/reflection/>Java 反射机制详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/unsafe/>Java 魔法类 Unsafe 详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/serialization/>Java 序列化详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/syntactic-sugar/>Java 语法糖详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/why-there-only-value-passing-in-java/>Java 值传递详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-01/>Java基础常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-03/>Java基础常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-02/>Java基础常见面试题总结(中)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/generics-and-wildcards/>泛型&通配符详解</a></li></ul></li><li><input type=checkbox id=section-b9f81b31813c0f4b2cd6e884ad0c0511 class=toggle>
<label for=section-b9f81b31813c0f4b2cd6e884ad0c0511 class="flex justify-between"><a role=button>Collection</a></label><ul><li><a href=/zh/docs/technology/Interview/java/collection/arrayblockingqueue-source-code/>ArrayBlockingQueue 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/arraylist-source-code/>ArrayList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/concurrent-hash-map-source-code/>ConcurrentHashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/copyonwritearraylist-source-code/>CopyOnWriteArrayList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/delayqueue-source-code/>DelayQueue 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/hashmap-source-code/>HashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-questions-01/>Java集合常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-questions-02/>Java集合常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-precautions-for-use/>Java集合使用注意事项总结</a></li><li><a href=/zh/docs/technology/Interview/java/collection/linkedhashmap-source-code/>LinkedHashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/linkedlist-source-code/>LinkedList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/priorityqueue-source-code/>PriorityQueue 源码分析（付费）</a></li></ul></li><li><input type=checkbox id=section-8cc9034354bdd549787a43bea3c7c40c class=toggle>
<label for=section-8cc9034354bdd549787a43bea3c7c40c class="flex justify-between"><a role=button>Concurrent</a></label><ul><li><a href=/zh/docs/technology/Interview/java/concurrent/aqs/>AQS 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/atomic-classes/>Atomic 原子类总结</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/cas/>CAS 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/completablefuture-intro/>CompletableFuture 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-collections/>Java 常见并发容器总结</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-thread-pool-summary/>Java 线程池详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-thread-pool-best-practices/>Java 线程池最佳实践</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-01/>Java并发常见面试题总结（上）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-03/>Java并发常见面试题总结（下）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-02/>Java并发常见面试题总结（中）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/jmm/>JMM（Java 内存模型）详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/threadlocal/>ThreadLocal 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/reentrantlock/>从ReentrantLock的实现看AQS的原理及应用</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/optimistic-lock-and-pessimistic-lock/>乐观锁和悲观锁详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/virtual-thread/>虚拟线程常见问题总结</a></li></ul></li><li><input type=checkbox id=section-498d2cde022f952a6751a7ebd2a53aeb class=toggle>
<label for=section-498d2cde022f952a6751a7ebd2a53aeb class="flex justify-between"><a role=button>Io</a></label><ul><li><a href=/zh/docs/technology/Interview/java/io/io-basis/>Java IO 基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/java/io/io-model/>Java IO 模型详解</a></li><li><a href=/zh/docs/technology/Interview/java/io/io-design-patterns/>Java IO 设计模式总结</a></li><li><a href=/zh/docs/technology/Interview/java/io/nio-basis/>Java NIO 核心知识总结</a></li></ul></li><li><input type=checkbox id=section-9ee5b42dd6a7edc6e1c0a1c88bde9426 class=toggle>
<label for=section-9ee5b42dd6a7edc6e1c0a1c88bde9426 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/technology/Interview/java/jvm/memory-area/>Java内存区域详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jdk-monitoring-and-troubleshooting-tools/>JDK监控和故障处理工具总结</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-garbage-collection/>JVM垃圾回收详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-in-action/>JVM线上问题排查和性能调优案例</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-intro/>大白话带你认识 JVM</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/class-loading-process/>类加载过程详解</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/classloader/>类加载器详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/class-file-structure/>类文件结构详解</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-parameters-intro/>最重要的JVM参数总结</a></li></ul></li><li><input type=checkbox id=section-aad47cdb4b5f179b406c6cf1c6282621 class=toggle>
<label for=section-aad47cdb4b5f179b406c6cf1c6282621 class="flex justify-between"><a role=button>New Features</a></label><ul><li><a href=/zh/docs/technology/Interview/java/new-features/java8-tutorial-translate/>Index</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java10/>Java 10 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java11/>Java 11 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java12-13/>Java 12 & 13 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java14-15/>Java 14 & 15 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java16/>Java 16 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java17/>Java 17 新特性概览（重要）</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java18/>Java 18 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java19/>Java 19 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java20/>Java 20 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java21/>Java 21 新特性概览(重要)</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java22-23/>Java 22 & 23 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java9/>Java 9 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java8-common-new-features/>Java8 新特性实战</a></li></ul></li></ul></li><li><input type=checkbox id=section-f77457e1ea013328645923186d400509 class=toggle>
<label for=section-f77457e1ea013328645923186d400509 class="flex justify-between"><a role=button>System Design</a></label><ul><li><input type=checkbox id=section-a9a8bf9713340a4888a6db9d8f8eda42 class=toggle>
<label for=section-a9a8bf9713340a4888a6db9d8f8eda42 class="flex justify-between"><a role=button>Basis</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/basis/RESTfulAPI/>RestFul API 简明教程</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/unit-test/>单元测试到底是什么？应该怎么做？</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/software-engineering/>软件工程简明教程</a></li></ul></li><li><input type=checkbox id=section-3bbccee656befcd0673c7a7ef7393710 class=toggle>
<label for=section-3bbccee656befcd0673c7a7ef7393710 class="flex justify-between"><a role=button>Framework</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/async1/>Async 注解原理分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/Async/>Async 注解原理分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/ioc-and-aop/>IoC & AOP详解（快速搞懂）</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/mybatis/mybatis-interview/>MyBatis常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/netty/>Netty常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/springboot-source-code/>Spring Boot核心源码解读（付费）</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-transaction/>Spring 事务详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-design-patterns-summary/>Spring 中的设计模式详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-common-annotations/>Spring&amp;SpringBoot常用注解总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-boot-auto-assembly-principles/>SpringBoot 自动装配原理详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/springboot-knowledge-and-questions-summary/>SpringBoot常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-knowledge-and-questions-summary/>Spring常见面试题总结</a></li></ul></li><li><input type=checkbox id=section-2baa7507d4a9ede0d38490ad77045e56 class=toggle>
<label for=section-2baa7507d4a9ede0d38490ad77045e56 class="flex justify-between"><a role=button>Security</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/security/jwt-intro/>JWT 基础概念详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/advantages-and-disadvantages-of-jwt/>JWT 身份认证优缺点分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/sso-intro/>SSO 单点登录详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/encryption-algorithms/>常见加密算法总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/basis-of-authority-certification/>认证授权基础概念详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/data-desensitization/>数据脱敏方案总结</a></li></ul></li><li><a href=/zh/docs/technology/Interview/system-design/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/>Index</a></li><li><a href=/zh/docs/technology/Interview/system-design/schedule-task/>Java 定时任务详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/web-real-time-message-push/>Web 实时消息推送详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/design-pattern/>设计模式常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/system-design-questions/>系统设计常见面试题总结(付费)</a></li></ul></li><li><input type=checkbox id=section-b12b3763d379141770d4fa07f12c73ec class=toggle>
<label for=section-b12b3763d379141770d4fa07f12c73ec class="flex justify-between"><a role=button>Tools</a></label><ul><li><input type=checkbox id=section-b6832c2bda30f11dca94b5d9440b112e class=toggle>
<label for=section-b6832c2bda30f11dca94b5d9440b112e class="flex justify-between"><a role=button>Docker</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/docker/docker-intro/>Docker核心概念总结</a></li><li><a href=/zh/docs/technology/Interview/tools/docker/docker-in-action/>Docker实战</a></li></ul></li><li><input type=checkbox id=section-e383b654b47946dea2499bcb3c4bac31 class=toggle>
<label for=section-e383b654b47946dea2499bcb3c4bac31 class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/git/github-tips/>Github实用小技巧总结</a></li><li><a href=/zh/docs/technology/Interview/tools/git/git-intro/>Git核心概念总结</a></li></ul></li><li><input type=checkbox id=section-05546e7a7af454a542b00fa4a34f43a5 class=toggle>
<label for=section-05546e7a7af454a542b00fa4a34f43a5 class="flex justify-between"><a role=button>Gradle</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/gradle/gradle-core-concepts/>Gradle核心概念总结</a></li></ul></li><li><input type=checkbox id=section-139d2af6b95c327fa03497bf63e3a4f4 class=toggle>
<label for=section-139d2af6b95c327fa03497bf63e3a4f4 class="flex justify-between"><a role=button>Maven</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/maven/maven-core-concepts/>Maven核心概念总结</a></li><li><a href=/zh/docs/technology/Interview/tools/maven/maven-best-practices/>Maven最佳实践</a></li></ul></li></ul></li></ul></li><li><input type=checkbox id=section-d9652e1d39ed08192f3dd99c4361d9ad class=toggle checked>
<label for=section-d9652e1d39ed08192f3dd99c4361d9ad class="flex justify-between"><a role=button>SpringCloud</a></label><ul><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E5%B0%81%E9%9D%A2-%E7%9B%AE%E5%BD%95/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC10%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7I_O/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC11%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC12%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC2%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/ class=active>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC4%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC5%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC6%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC7%E7%AB%A0-%E9%93%BE%E6%8E%A5/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC9%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C-2-6/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%92%8C%E9%80%9A%E4%BF%A1-10-12/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-7-9/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E9%99%84%E5%BD%95A-%E5%B0%81%E5%BA%95/>Index</a></li></ul></li><li><a href=/zh/docs/technology/Markdown/_SuperTutorial_/>Markdown超级教程</a></li></ul></li><li class=book-section-flat><a href=/zh/docs/problem/>问题解决</a><ul><li><input type=checkbox id=section-ab4f1dd893a7409a00858148e98c245c class=toggle>
<label for=section-ab4f1dd893a7409a00858148e98c245c class="flex justify-between"><a role=button>Other</a></label><ul><li><a href=/zh/docs/problem/Other/01/>如何搜索</a></li></ul></li><li><input type=checkbox id=section-ef3324c710f7241c89fc009a5f576fbc class=toggle>
<label for=section-ef3324c710f7241c89fc009a5f576fbc class="flex justify-between"><a role=button>Linux</a></label><ul><li><a href=/zh/docs/problem/Linux/20230919/>Linux操作符问题</a></li><li><a href=/zh/docs/problem/Linux/20230819/>Debian问题处理3</a></li><li><a href=/zh/docs/problem/Linux/20230817/>Debian问题处理2</a></li><li><a href=/zh/docs/problem/Linux/20230815/>Debian问题处理1</a></li><li><a href=/zh/docs/problem/Linux/20230803/>安卓手机及平板安装linuxDeploy的问题简记</a></li><li><a href=/zh/docs/problem/Linux/20230523/>zsh卸载后root无法登录及vm扩容centos7报错处理</a></li><li><a href=/zh/docs/problem/Linux/20221101/>post</a></li></ul></li><li><input type=checkbox id=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class=toggle>
<label for=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/problem/JVM/20230526/>JDK代理和CGLIB代理</a></li><li><a href=/zh/docs/problem/JVM/2023052302/>linux中调试open jdk</a></li></ul></li><li><input type=checkbox id=section-a028a45b205904a783d0c60e8a184391 class=toggle>
<label for=section-a028a45b205904a783d0c60e8a184391 class="flex justify-between"><a role=button>Hexo</a></label><ul><li><a href=/zh/docs/problem/Hexo/01/>hexo在线查看pdf</a></li></ul></li><li><input type=checkbox id=section-1c55bf7a5578a7de17cc1ee45681106b class=toggle>
<label for=section-1c55bf7a5578a7de17cc1ee45681106b class="flex justify-between"><a role=button>Idea</a></label><ul><li><a href=/zh/docs/problem/Idea/01/>问题01</a></li></ul></li><li><input type=checkbox id=section-66dd985e53d8e0b78efdab983762411c class=toggle>
<label for=section-66dd985e53d8e0b78efdab983762411c class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/problem/Git/01/>git使用ssh连不上</a></li></ul></li><li><input type=checkbox id=section-9440d21f7eb9f8cf7f45b16969ab18dc class=toggle>
<label for=section-9440d21f7eb9f8cf7f45b16969ab18dc class="flex justify-between"><a role=button>Hugo</a></label><ul><li><a href=/zh/docs/problem/Hugo/p1/>hugo踩坑</a></li><li><a href=/zh/docs/problem/Hugo/01a/>图片测试(hugo踩坑)</a></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/life/>生活</a><ul><li><input type=checkbox id=section-c7f767205668758142bb8053263cc14f class=toggle>
<label for=section-c7f767205668758142bb8053263cc14f class="flex justify-between"><a role=button>往日归档</a></label><ul><li><a href=/zh/docs/life/archive/20231026/>成就</a></li><li><a href=/zh/docs/life/archive/20231013/>沉没</a></li><li><a href=/zh/docs/life/archive/20230913/>鲇鱼后思</a></li><li><a href=/zh/docs/life/archive/20230912/>病愈 有感</a></li><li><a href=/zh/docs/life/archive/20220724/>人为什么要结婚(找对象)</a></li><li><a href=/zh/docs/life/archive/20220416/>《作酒》有感</a></li><li><a href=/zh/docs/life/archive/20121226/>2021年最后一个周日</a></li><li><a href=/zh/docs/life/archive/20231021/>沉沦</a></li></ul></li><li><a href=/zh/docs/life/20250103/>随想</a></li><li><a href=/zh/docs/life/dailyExcerpt/>每日摘抄</a></li><li><a href=/zh/docs/life/20240626/>知命不惧 日日自新</a></li><li><a href=/zh/docs/life/20231227/>起床临感</a></li><li><a href=/zh/docs/life/20231101/>20231101</a></li></ul></li><li class=book-section-flat><span>文化</span><ul><li><input type=checkbox id=section-2caf93f41e261fb08fbc8abd7e4170d5 class=toggle>
<label for=section-2caf93f41e261fb08fbc8abd7e4170d5 class="flex justify-between"><a role=button>论语</a></label><ul><li><input type=checkbox id=section-0d6e955a0862e2b200af0e2a2f889dd6 class=toggle>
<label for=section-0d6e955a0862e2b200af0e2a2f889dd6 class="flex justify-between"><a role=button>论语译注 杨伯峻</a></label><ul><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/19%E5%AD%90%E5%BC%A0%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B9%9D/>19子张篇第十九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/13%E5%AD%90%E8%B7%AF%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%89/>13子路篇第十三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/09%E5%AD%90%E7%BD%95%E7%AF%87%E7%AC%AC%E4%B9%9D/>09子罕篇第九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/06%E9%9B%8D%E4%B9%9F%E7%AF%87%E7%AC%AC%E5%85%AD/>06雍也篇第六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/20%E5%B0%A7%E6%9B%B0%E7%AF%87%E7%AC%AC%E4%BA%8C%E5%8D%81/>20尧曰篇第二十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/17%E9%98%B3%E8%B4%A7%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%83/>17阳货篇第十七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/12%E9%A2%9C%E6%B8%8A%E7%AF%87%E7%AC%AC%E5%8D%81%E4%BA%8C/>12颜渊篇第十二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/01%E5%AD%A6%E8%80%8C%E7%AF%87%E7%AC%AC%E4%B8%80/>01学而篇第一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/10%E4%B9%A1%E5%85%9A%E7%AF%87%E7%AC%AC%E5%8D%81/>10乡党篇第十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/14%E5%AE%AA%E9%97%AE%E7%AF%87%E7%AC%AC%E5%8D%81%E5%9B%9B/>14宪问篇第十四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/11%E5%85%88%E8%BF%9B%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%80/>11先进篇第十一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/18%E5%BE%AE%E5%AD%90%E7%AF%87%E7%AC%AC%E5%8D%81%E5%85%AB/>18微子篇第十八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/02%E4%B8%BA%E6%94%BF%E7%AF%87%E7%AC%AC%E4%BA%8C/>02为政篇第二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AF%87%E7%AC%AC%E5%8D%81%E4%BA%94/>15卫灵公篇第十五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/08%E6%B3%B0%E4%BC%AF%E7%AF%87%E7%AC%AC%E5%85%AB/>08泰伯篇第八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/07%E8%BF%B0%E8%80%8C%E7%AF%87%E7%AC%AC%E4%B8%83/>07述而篇第七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/%E8%AF%95%E8%AE%BA-%E5%AF%BC%E8%A8%80-%E4%BE%8B%E8%A8%80/>试论-导言-例言</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/04%E9%87%8C%E4%BB%81%E7%AF%87%E7%AC%AC%E5%9B%9B/>04里仁篇第四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/16%E5%AD%A3%E6%B0%8F%E7%AF%87%E7%AC%AC%E5%8D%81%E5%85%AD/>16季氏篇第十六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AF%87%E7%AC%AC%E4%BA%94/>05公冶长篇第五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/03%E5%85%AB%E4%BD%BE%E7%AF%87%E7%AC%AC%E4%B8%89/>03八佾篇第三</a></li></ul></li><li><input type=checkbox id=section-3c0bd8b9ce8b9615dcc02b6df6e7788e class=toggle>
<label for=section-3c0bd8b9ce8b9615dcc02b6df6e7788e class="flex justify-between"><a role=button>论语的生活智慧</a></label><ul><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/01%E5%AD%A6%E5%A4%A9%E7%AC%AC%E4%B8%80/>01学天第一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/02%E4%B8%BA%E6%94%BF%E7%AC%AC%E4%BA%8C/>02为政第二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/03%E5%85%AB%E4%BD%BE%E7%AC%AC%E4%B8%89/>03八佾第三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/04%E9%87%8C%E4%BB%81%E7%AC%AC%E5%9B%9B/>04里仁第四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AC%AC%E4%BA%94/>05公治长第五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/06%E9%9B%8D%E4%B9%9F%E7%AC%AC%E5%85%AD/>06雍也第六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/07%E8%BF%B0%E8%80%8C%E7%AC%AC%E4%B8%83/>07述而第七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/08%E6%B3%B0%E4%BC%AF%E7%AC%AC%E5%85%AB/>08泰伯第八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/09%E5%AD%90%E7%BD%95%E7%AC%AC%E4%B9%9D/>09子罕第九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/10%E4%B9%A1%E5%85%9A%E7%AC%AC%E5%8D%81/>10乡党第十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/11%E5%85%88%E8%BF%9B%E7%AC%AC%E5%8D%81%E4%B8%80/>11先进第十一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/12%E9%A2%9C%E6%B8%8A%E7%AC%AC%E5%8D%81%E4%BA%8C/>12颜渊第十二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/13%E5%AD%90%E8%B7%AF%E7%AC%AC%E5%8D%81%E4%B8%89/>13子路第十三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/14%E5%AE%AA%E9%97%AE%E7%AC%AC%E5%8D%81%E5%9B%9B/>14宪问第十四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AC%AC%E5%8D%81%E4%BA%94/>15卫灵公第十五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/16%E5%AD%A3%E6%B0%8F%E7%AC%AC%E5%8D%81%E5%85%AD/>16季氏第十六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/17%E9%98%B3%E8%B4%A7%E7%AC%AC%E5%8D%81%E4%B8%83/>17阳货第十七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/18%E5%BE%AE%E5%AD%90%E7%AC%AC%E5%8D%81%E5%85%AB/>18微子第十八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/19%E5%AD%90%E5%BC%A0%E7%AC%AC%E5%8D%81%E4%B9%9D/>19子张第十九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/20%E5%B0%A7%E6%97%A5%E7%AC%AC%E4%BA%8C%E5%8D%81/>20尧日第二十</a></li></ul></li></ul></li><li><input type=checkbox id=section-daa70c3e612b40fe4050f5185bb12608 class=toggle>
<label for=section-daa70c3e612b40fe4050f5185bb12608 class="flex justify-between"><a role=button>恰同学少年</a></label><ul><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AE%80%E4%BB%8B-%E4%BD%9C%E8%80%85/>简介-作者</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/>经典语录</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC1%E7%AB%A0-%E7%AC%AC5%E7%AB%A0/>第1章-第5章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC11%E7%AB%A0-%E7%AC%AC15%E7%AB%A0/>第11章-第15章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC16%E7%AB%A0-%E7%AC%AC20%E7%AB%A0/>第16章-第20章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC6%E7%AB%A0-%E7%AC%AC10%E7%AB%A0/>第6章-第10章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC21%E7%AB%A0-%E7%AC%AC25%E7%AB%A0/>第21章-第25章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC26%E7%AB%A0-%E7%AC%AC29%E7%AB%A0/>第26章-第29章</a></li></ul></li><li><input type=checkbox id=section-ab50087f003d55e32dba86fb838050b9 class=toggle>
<label for=section-ab50087f003d55e32dba86fb838050b9 class="flex justify-between"><a role=button>如何阅读一本书</a></label><ul><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E9%99%84%E5%BD%95/>附录</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AE%80%E4%BB%8B-%E5%BA%8F%E8%A8%80/>简介-序言</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%B8%80%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E5%B1%82%E6%AC%A1/>第一篇 阅读的层次</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E5%9B%9B%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E6%9C%80%E7%BB%88%E7%9B%AE%E6%A0%87/>第四篇 阅读的最终目标</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%B8%89%E7%AF%87_%E9%98%85%E8%AF%BB%E4%B8%8D%E5%90%8C%E8%AF%BB%E7%89%A9%E7%9A%84%E6%96%B9%E6%B3%95/>第三篇 阅读不同读物的方法</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%BA%8C%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1_%E5%88%86%E6%9E%90%E9%98%85%E8%AF%BB/>第二篇 阅读的第三个层次：分析阅读</a></li></ul></li><li><input type=checkbox id=section-3c72e7201480f45e35bf243c48374c4a class=toggle>
<label for=section-3c72e7201480f45e35bf243c48374c4a class="flex justify-between"><a role=button>古代天文历法讲座</a></label><ul><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E9%99%84%E5%BD%95-%E9%99%84%E8%A1%A8-%E5%90%8E%E8%AE%B0/>附录-附表-后记</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC6%E8%AE%B2-%E7%AC%AC7%E8%AE%B2/>第6讲-第7讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC4%E8%AE%B2-%E7%AC%AC5%E8%AE%B2/>第4讲-第5讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC1%E8%AE%B2-%E7%AC%AC3%E8%AE%B2/>第1讲-第3讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%89%88%E6%9D%83-%E5%BA%8F-%E5%89%8D%E8%A8%80/>版权-序-前言</a></li></ul></li><li><input type=checkbox id=section-9d5fdf0456d3af9d5079c94a509d2900 class=toggle>
<label for=section-9d5fdf0456d3af9d5079c94a509d2900 class="flex justify-between"><a role=button>置身事内</a></label><ul><li><a href=/zh/docs/culture/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/%E4%B8%8B%E7%AF%87/>下篇</a></li><li><a href=/zh/docs/culture/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/%E4%B8%8A%E7%AF%87/>上篇</a></li></ul></li><li><input type=checkbox id=section-2968790b5f933a15ae8f870afe7ff8b9 class=toggle>
<label for=section-2968790b5f933a15ae8f870afe7ff8b9 class="flex justify-between"><a role=button>中国通史(吕思勉)</a></label><ul><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8B%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%96%87%E5%8C%96%E5%8F%B2/>下编-中国文化史</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8A%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%8F%B2/>上编-中国政治史</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83-%E8%AF%BB%E5%90%8E-%E8%87%AA%E5%BA%8F/>封面-版权-读后-自序</a></li></ul></li><li><input type=checkbox id=section-77e618b9fdc931e63e2343a70dbe6630 class=toggle>
<label for=section-77e618b9fdc931e63e2343a70dbe6630 class="flex justify-between"><a role=button>资治通鉴</a></label><ul><li><input type=checkbox id=section-196ebc38f91a63032ca3483e389aa4c5 class=toggle>
<label for=section-196ebc38f91a63032ca3483e389aa4c5 class="flex justify-between"><a role=button>周纪</a></label><ul><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/>基本知识</a></li><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/001%E5%91%A8%E7%BA%AA%E4%B8%80/>001周纪一</a></li></ul></li></ul></li><li><input type=checkbox id=section-5aa85019131e2605fa7465dc987f590d class=toggle>
<label for=section-5aa85019131e2605fa7465dc987f590d class="flex justify-between"><a role=button>增广贤文</a></label><ul></ul></li><li><input type=checkbox id=section-36af101672fdef38bd3af078cbe1e845 class=toggle>
<label for=section-36af101672fdef38bd3af078cbe1e845 class="flex justify-between"><a role=button>天纪</a></label><ul></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/test/>测试</a><ul><li><a href=/zh/docs/test/mytest/>test</a></li><li><a href=/zh/docs/test/hello2/>pdfTest</a></li></ul></li></ul><ul><li><a href=/zh/posts/>博客</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Index</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents></nav></aside></header><article class="markdown book-article"><p>第 3章
C H A P T E R 3
程序的机器级表示
计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写
存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集
和操作系统遵循的惯例，经过一系列的阶段生成机器代码。 GCCC语言编译器以汇编代码
的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后
GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。在本章中，我们会近
距离地观察机器代码，以及人类可读的表示汇编代码。
当我们用高级语言编程的时候（例如 C语言， Java语言更是如此），机器屏蔽了程序的细节，即机器级的实现。与此相反，当用汇编代码编程的时候（就像早期的计算），程序员必须指定程序用来执行计算的低级指令。高级语言提供的抽象级别比较高，大多数时候，在这种抽象级别上工作效率会更高，也更可靠。编译器提供的类型检查能帮助我们发现许多程序错误，并能够保证按照一致的方式来引用和处理数据。通常情况下，使用现代的优化编译器产生的代码至少与一个熟练的汇编语言程序员手工编写的代码一样有效。最大的优点是，用高级语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关的。
那么为什么我们还要花时间学习机器代码呢？即使编译器承担了生成汇编代码的大部分工作，对于严谨的程序员来说，能够阅读和理解汇编代码仍是一项很重要的技能。以适当的命令行选项调用编译器，编译器就会产生一个以汇编代码形式表示的输出文件。通过阅读这些汇编代码，我们能够理解编译器的优化能力，并分析代码中隐含的低效率。就像我们将在第 5章中体会到的那样，试图最大化一段关键代码性能的程序员，通常会尝试源代码的各种形式，每次编译并检查产生的汇编代码，从而了解程序将要运行的效率如何。此外，也有些时候，高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为。例如，第 12章会讲到，用线程包写并发程序时，了解不同的线程是如何共享程序数据或保持数据私有的，以及准确知道如何在哪里访问共享数据，都是很重要的。这些信息在机器代码级是可见的。另外再举一个例子，程序遭受攻击（使得恶意软件侵扰系统）的许多方式中，都涉及程序存储运行时控制信息的方式的细节。许多攻击利用了系统程序中的漏洞重写信息，从而获得了系统的控制权。了解这些漏洞是如何出现的，以及如何防御它们，需要具备程序机器级表示的知识。程序员学习汇编代码的需求随着时间的推移也发生了变化，开始时要求程序员能直接用汇编语言编写程序，现在则要求他们能够阅读和理解编译器产生的代码。
在本章中，我们将详细学习一种特别的汇编语言，了解如何将 C程序编译成这种形式的机器代码。阅读编译器产生的汇编代码，需要具备的技能不同千手工编写汇编代码。我们必须了解典型的编译器在将 C程序结构变换成机器代码时所做的转换。相对于 C代码表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换慢速操作，甚至将递归计算变换成迭代计算。源代码与对应的汇编代码的关系通常不太容易理解一一凉尤像要拼出的拼图与盒子上图片的设计有点不太一样。这是一种逆向工程 (reverse engineering)一一－通过研究系统和逆向工作，来试图了解系统的创建过程。在这里，系统是一个机器产生的汇编语言程序，而不是由人设计的某个东西。这简化了逆向工程的任务，因为产生的代码遵循比较规则的模式，而且我们可以做试验，让编译器产生许多不同程序的代码。本章提供了许多示例和大量的练习，来说明汇编语言和编译器的各个不同方面。精通细节是理解更深和更基本概念的先决条件。有人说：“我理解了一般规则，不愿意劳神去学习细节！”他们实际上是在自欺欺人。花时间研究这些示例、完成练习并对照提供的答案来检查你的答案，是非常关键的。
我们的表述基于 x86-64,它是现在笔记本电脑和台式机中最常见处理器的机器语言，也是驱动大型数据中心和超级计算机的最常见处理器的机器语言。这种语言的历史悠久，开始于 Intel公司 1978年的第一个 16位处理器，然后扩展为 32位，最近又扩展到 64位。一路以来，逐渐增加了很多特性，以更好地利用已有的半导体技术，以及满足市场需求。这些进步中很多是 Intel自己驱动的，但它的对手 AMD(Advanced Micro Devices)也作出了重要的贡献。演化的结果是得到一个相当奇特的设计，有些特性只有从历史的观点来看才有意义，它还具有提供后向兼容性的特性，而现代编译器和操作系统早已不再使用这些特性。我们将关注 GCC和 Linux使用的那些特性，这样可以避免 x86-64的大量复杂性和许多隐秘特性。
我们在技术讲解之前，先快速浏览 C语言、汇编代码以及机器代码之间的关系。然后介绍 x86-64的细节，从数据的表示和处理以及控制的实现开始。了解如何实现 C语言中的控制结构，如辽、 while和 switch语句。之后，我们会讲到过程的实现，包括程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储。接着，我们会考虑在机器级如何实现像数组、结构和联合这样的数据结构。有了这些机器级编程的背景知识，我们会讨论内存访问越界的问题，以及系统容易遭受缓冲区溢出攻击的问题。在这一部分的结尾，我们会给出一些用 GDB调试器检查机器级程序运行时行为的技巧。本章的最后展示了包含浮点数据和操作的代码的机器程序表示。
-IA32编程
IA32, x86-64的 32位前身，是 Intel在 1985年提出的。几十年来一直是 Intel的机器语言之选。今天出售的大多数 x86微处理器，以及这些机器上安装的大多数操作系统，都是为运行 x86-64设计的。不过，它们也可以向后兼容执行 IA32程序。所以，很多应用程序还是基于 IA32的。除此之外，由于硬件或系统软件的眼制，许多已有的系统不能够执行 x86-64。 IA32仍然是一种重要的机器语言。学习过 x86-64会使你很容易地学会 IA32机器语言。
计算机工业已经完成从 32位到 64位机器的过渡。 32位机器只能使用大概 4GB（沪字节）的随机访问存储器。存储器价格急剧下降，而我们对计算的需求和数据的大小持续增加，超越这个限制既经济上可行又有技术上的需要。当前的 64位机器能够使用多达 256TB(2 “字节）的内存空间，而且很容易就能扩展至 16EB(2“字节）。虽然很难想象一台机器需要这么大的内存，但是回想 20世纪 70和 80年代，当 32位机器开始普及的时候， 4GB的内存看上去也是超级大的。
我们的表述集中于以现代操作系统为目标，编译 C或类似编程语言时，生成的机器级程序类型。 x86-64有一些特性是为了支持遗留下来的微处理器早期编程风格，在此，我们不试图去描述这些特性，那时候大部分代码都是手工编写的，而程序员还在努力与 16位机器允许的有限地址空间奋战。
3. 1 历史观点 Intel处理器系列俗称 x86,经历了一个长期的、不断进化的发展过程。开始时，它是第
一代单芯片、 16位微处理器之一，由于当时集成电路技术水平十分有限，其中做了很多妥
协。以后，它不断地成长，利用进步的技术满足更高性能和支持更高级操作系统的需求。
以下列举了一些 Intel处理器的模型，以及它们的一些关键特性，特别是影响机器级
编程的特性。我们用实现这些处理器所需要的品体管数量来说明演变过程的复杂性。其
中， “K"表示 1000, &ldquo;M"表示 1 000 000,而 “G"表示 1 000 000 000。
8086(1978年， 29K个晶体管）。它是第一代单芯片、 16位微处理器之一。 8088是 8086
的一个变种，在 8086上增加了一个 8位外部总线，构成最初的 IBM个人计算机的心脏。
IBM与当时还不强大的微软签订合同，开发 MS-DOS操作系统。最初的机器型号有 32 768字
节的内存和两个软驱（没有硬盘驱动器）。从体系结构上来说，这些机器只有 655 360字节的
地址空间地址只有 20位长（可寻址范围为 1 048 576字节），而操作系统保留了 393 216字
节自用。 1980年， Intel提出了 8087浮点协处理器 (45K个晶体管），它与一个 8086或 8088
处理器一同运行，执行浮点指令。 8087建立了 x86系列的浮点模型，通常被称为 “x87”。
80286(1982年， 134K个品体管）。增加了更多的寻址模式（现在巳经废弃了），构成
了 IBM PC-AT个人计算机的基础，这种计算机是 MS Windows最初的使用平台。
i386(1985年， 275K个晶体管）。将体系结构扩展到 32位。增加了平坦寻址模式 (flat
addressing model), Linux和最近版本的 Windows操作系统都是使用的这种模式。这是
Intel系列中第一台全面支持 Unix操作系统的机器。
i486(1989年， 1. 2M个晶体管）。改善了性能，同时将浮点单元集成到了处理器芯片
上，但是指令集没有明显的改变。
Pentium(l993年， 3. lM个晶体管）。改善了性能，不过只对指令集进行了小的扩展。
PentiumPro(l995年， 5 . 5M个晶体管）。引入全新的处理器设计，在内部被称为 P6
微体系结构。指令集中增加了一类”条件传送 (conditional move)&ldquo;指令。
Pentium/MMX(1997年， 4. 5M个晶体管）。在 Pentium处理器中增加了一类新的处
理整数向量的指令。每个数据大小可以是 1、 2或 4字节。每个向掀总长 64位。
Pentium 11(1997年， 7M个晶体管）。 P6微体系结构的延伸。
Pentium 1110999年， 8. 2M个晶体管）。引入了 SSE,这是一类处理整数或浮点数向
量的指令。每个数据可以是 1、 2或 4个字节，打包成 128位的向量。由于芯片上包括了
二级高速缓存，这种芯片后来的版本最多使用了 24M个晶体管。
Pentium 4(2000年， 42M个晶体管）。 SSE扩展到了 SSE2，增加了新的数据类型（包括双精度浮点数），以及针对这些格式的 144条新指令。有了这些扩展，编译器可以使用 SSE指令（而不是 x87指令），来编译浮点代码。
Pentium 4E(2004年， 125M个晶体管）。增加了超线程 (hyperthreading)，这种技术可以在一个处理器上同时运行两个程序；还增加了 EM64T,它是 Intel对 AMD提出的对 IA32的 64位扩展的实现，我们称之为 x86-64。
Core 2(2006年， 291M个晶体管）。回归到类似千 P 6的微体系结构。 Intel的第一个多核微处理器，即多处理器实现在一个芯片上。但不支持超线程。 Core i7, Ne halem( 2 008年， 781M个晶体管）。既支持超线程，也有多核，最初的版本支持每个核上执行两个程序，每个芯片上最多四个核。 Core i7, Sandy Bridge(2011年， 1. 17G个晶体管）。引入了 AVX,这是对 SSE的扩展，支持把数据封装进 2 5 6位的向量。 Core i7, Ha sw ell(2013年， 1. 4G个晶体管）。将 AVX扩展至 AVX2，增加了更多的
指令和指令格式。
每个后继处理器的设计都是后向兼容的一较早版本上编译的代码可以在较新的处理
器上运行。正如我们看到的那样，为了保持这种进化传统，指令集中有许多非常奇怪的东西。 Intel处理器系列有好几个名字，包括 IA32,也就是 “Inte l 32位体系结构 (Intel Architecture 32-bit)",以及最新的 lntel64,即 IA 3 2的 64位扩展，我们也称为 x86-64。最常用的名字是 “x86&rdquo;,我们用它指代整个系列，也反映了直到 i486处理器命名的惯例。
m摩尔定律 (Moore&rsquo;s Law)
如果我们画出各种不同的 Int e l处理器中晶体管的数量与它们出现的年份之间的图
(y轴为晶体管数量的对数值），我们能够看出，增长是很显著的。画一条拟合这些数据
的线，可以看到晶体管数量以每年大约 37％的速率增加，也就是说，晶体管数量每 26
个月就会翻一番。在 x86微处理器的历史上，这种增长已经持续了好几十年。
Intel微处理器的复杂性
LOE+ 10
LOE+ 09
Nehalem .
OEOEOE
080706 Pentium 4e～冬e2 Duo
lll+++
Pentium 4
I.OE+ 05
l.OE +04 1975 1980 1985 1990 1995 2000 2005 2010 2015
年份
1 9 6 5年， Gordon Moore, Intel公司的创始人，根据当时的芯片技术（那时他们能够在
一个芯片上制造有大约 64个晶体管的电路）做出推断，预测在未来 10年，芯片上的晶体
管数量每年都会翻一番。这个预测就称为摩尔定律。正如事实证明的那样，他的预测有点乐
观，而且短视。在超过 50年中，半导体工业一直能够使得晶体管数目每 1 8个月翻一倍。
对计算机技术的其他方面，也有类似的呈指数增长的情况出现，比如磁盘和半导体
存储器的存储容量。这些惊人的增长速度一直是计算机革命的主要驱动力。
这些年来，许多公司生产出了与 Intel处理器兼容的处理器，能够运行完全相同的机器级程序。其中，领头的是 AMD。数年来， AMD在技术上紧跟 Intel,执行的市场策略是：生产性能稍低但是价格更便宜的处理祥。 20 0 2年， AMD的处理器变得更加有竞争
力，它们率先突破了可商用微处理器的 1GHz的时钟速度屏障，并且引入了广泛采用的 IA32的 64位扩展 x86-64。虽然我们讲的是 Intel处理器，但是对千其竞争对手生产的与之兼容的处理器来说，这些表述也同样成立。
对于由 GCC编译器产生的、在 Linux操作系统平台上运行的程序，感兴趣的人大多并不关心 x86的复杂性。最初的 8086提供的内存模型和它在 80286中的扩展，到 i386的时候就都已经过时了。原来的 x87浮点指令到引入 SSE2以后就过时了。虽然在 x86-64程序中，我
们能看到历史发展的痕迹，但 x86中许多最晦涩难懂的特性已经不会出现了。
缅谈胆迁喽
3. 2 程序编码假设一个 C程序，有两个文件 pl.c和 p2.c。我们用 Unix命令行编译这些代码：
linux> gee -Og -op pt.e p2.e
命令 gee指的就是 GCC C编译器。因为这是 Linux上默认的编译器，我们也可以简单地用 cc来启动它。编译选项－Og e告诉编译器使用会生成符合原始 C代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。因此我们会使用－Og优化作为学习工具，然后当我们增加优化级别时，再看会发生什么。实际中，从得到的程序的性能考虑，较高级别的优化（例如，以选项－01或－02指定）被认为是较好的选择。
实际上 gee命令调用了一整套的程序，将源代码转化成可执行代码。首先， C预处理器扩展源代码，插入所有用＃ include命令指定的文件，并扩展所有用＃define声明指定的宏。其次，编译器产生两个源文件的汇编代码，名字分别为 pl. s和 p2.s。接下来，汇编器会将汇编代码转化成二进制目标代码文件 p1.o和 p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。最后，链接器将两个目标代码文件与实现库函数（例如 printf)的代码合并，并产生最终的可执行代码文件 p（由命令行指示符－op指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。我们会在第 7章更详细地介绍这些不同形式的机器代码之间的关系以及链接的过程。
3. 2. 1 机器级代码正如在 1. 9. 3节中讲过的那样，计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对千机器级编程来说，其中两种抽象尤为重要。第一种是由指令集体系结构或指令集架构 &lt;Instruction Set Arehitecture, ISA)来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数 ISA,包括 x86-64,将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与 ISA指定的顺序执行的行为完全一致。第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来，这会在第 9章中讲到。在整个编译过程中，编译器会完成大部分的工作，将把用 C语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。能够理解汇编代码以及它与原始 C代码的联系，是理解计算机如何执行程序的关键一步。 x86-64的机器代码和原始的 C代码差别非常大。一些通常对 C语言程序员隐藏的处理器状态都是可见的：
·程序计数器（通常称为 “PC&rdquo;,在 x86-64中用％ rip表示）给出将要执行的下一条指令在内存中的地址。
GCC版本 4.8引人了这个优化等级。较早的 GCC版本和其他一些非 G~U编译器不认识这个选项。对这样一些编译器，使用一级优化（由命令行标志 -01指定）可能是最好的选择，生成的代码能够符合原始程序的结构。
·整数寄存器文件包含 16个命名的位置，分别存储 64位的值。这些寄存器可以存储地址
（对应千 C语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其
他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
·条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或
数据流中的条件变化，比如说用来实现江和 while语句。
·一组向量寄存器可以存放一个或多个整数或浮点数值。
虽然 C语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。 C语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。即使是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至于不区分指针和整数。
程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如说用 malloc库函数分配的）。正如前面提到的，程序内存用虚拟地址来寻址。在任意给定的时刻，只有有限的一部分虚拟地址
被认为是合法的。例如， x86-64的虚拟地址是由 64位的字来表示的。在目前的实现中，这些地址的高 16位必须设置为 o,所以一个地址实际上能够指定的是 2“或 64TB范围内的一个字节。较为典型的程序只会访问几兆字节或几千兆字节的数据。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。
一条机器指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现（像算术表达式求值、循环或过程调用和返回这样的）程序结构。
四曰不断变化的生成代码的格式
在本书的表述中，我们给出的代码是由特定版本的 GCC在特定的命令行选项设置
下产生的。如果你在自己的机器上编译代码，很有可能用到其他的编译器或者不同版本
的 GCC,因而会产生不同的代码。支持 GCC的开源社区一直在修改代码产生器，试图
根据微处理器制造商提供的不断变化的代码规则，产生更有效的代码。
本书示例的目标是展示如何查看汇编代码，并将它反向映射到高级编程语言中的结
构。你需要将这些技术应用到你的特定的编译器产生的代码格式上。
3. 2. 2 代码示例
假设我们写了一个 C语言代码文件 mstore.c,包含如下的函数定义：
long mult2(long, long);
void multstore(long x, long y, long .dest) { long t = mult2(x, y);
.dest = t; }
在命令行上使用 ”-s"选项，就能看到 C语言编译器产生的汇编代码：
linux> gee -Og -S mstore.e
这会使 GCC运行编译器，产生一个汇编文件 mstore.s,但是不做其他进一步的工作。（通常情况下，它还会继续调用汇编器产生目标代码文件）。
汇编代码文件包含各种声明，包括下面几行：
multstore: pushq %rbx movq 1!.rdx, %rbx call mult2 movq %rax, (%rbx) popq %rbx ret
上面代码中每个缩进去的行都对应于一条机器指令。比如， pushq指令表示应该将寄存器％
rbx的内容压入程序栈中。这段代码中已经除去了所有关于局部变量名或数据类型的信息。
如果我们使用 ”-c"命令行选项， GCC会编译并汇编该代码：
linux> gee -Og -e mstore.e
这就会产生目标代码文件 mstore.o,它是二进制格式的，所以无法直接查看。 1368字节
的文件 mstore.o中有一段 14字节的序列，它的十六进制表示为：
53 48 89 d3 e8 00 00 00 00 48 89 03 Sb c3
这就是上面列出的汇编指令对应的目标代码。从中得到一个重要信息，即机器执行的程序只
是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。</p><p>m如何展示程序的字节表示
要展示程序（比如说 mstore )的二进制目标代码，我们用反汇编器（后面会讲到）确
定该过程的代码长度是 1 4字节。然后，在文件 ms t ore . o上运行 GNU调试工具 GDB,
输入命令：
(gdb) x/14xb multstore
这条命令告诉 GDB显示（简写为｀ x＇)从函数 multst o re所处地址开始的 14个十六进制
格式表示（也简写为＇矿）的宇节（简写为｀ b&rsquo;）。你会发现， GDB有很多有用的特性可以
用来分析机器级程序，我们会在 3. 10. 2节中讨论。
要查看机器代码文件的内容，有一类称为反汇编器 (disassembler)的程序非常有用。
这些程序根据机器代码产生一种类似于汇编代码的格式。在 Linux系统中，带｀－扩命令行
标志的程序 OBJDUMP（表示 “object dump”)可以充当这个角色：
linux> objdump -d mstore. o
结果如下（这里，我们在左边增加了行号，在右边增加了斜体表示的注解）：
Disassembly of function multstore in binary file mstore .o 0000000000000000 : Offset Bytes Equivalent assembly language
234567
0: 53 push %rbx 1: 48 89 d3 mov %rdx,%rbx
4: e8 00 00 00 00 callq 9 &lt;multstore+Ox9> 9: 48 89 03 mov %rax, (%rbx)
c: 5b pop %rbx d: c3 retq
在左边，我们看到按照前面给出的字节顺序排列的 1 4个十六进制字节值，它们分成了若干组，每组有 1~5个字节。每组都是一条指令，右边是等价的汇编语言。
其中一些关于机器代码和它的反汇编表示的特性值得注意： . x86-64的指令长度从 1到 1 5个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。·设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令 pushq % rbx是以字节值 53开头的。·反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
·反汇编器使用的指令命名规则与 GCC生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的｀ q&rsquo;。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给 call和 ret指令添加了｀矿后缀，同样，省略这些后缀也没有问题。
生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个 main函数。假设在文件 main.c中有下面这样的函数：
#include &lt;stdio.h>
void multstore(long, long, long*);
int main() { long d; multstore(2, 3, &amp;d); printf(&ldquo;2 * 3 &ndash;> %ld\n&rdquo;, d); return O;
}
long mult2(long a, long b) { longs= a* b; returns;
}
然后，我们用如下方法生成可执行文件 prog:
linux> gee -Og -o prog main.c mstore.c
文件 prog变成了 8 655个字节，因为它不仅包含了两个过程的代码，还包含了用来启动和终止程序的代码，以及用来与操作系统交互的代码。我们也可以反汇编 prog文件：
linux> objdump -d prog
反汇编器会抽取出各种代码序列，包括下面这段：
Disassembly of function sum multstore binary file prog
123456789
0000000000400540 :
400540: 53 push %rbx<br>400541: 48 89 d3 mov %rdx,%rbx<br>400544: e8 42 00 00 00 callq 40058b<br>400549: 48 89 03 mov %rax, (%rbx)<br>40054c: 5b pop %rbx<br>40054d: c3 retq<br>40054e: 90 nop<br>40054f: 90 nop</p><p>这段代码与 mstore.c反汇编产生的代码几乎完全一样。其中一个主要的区别是左边
列出的地址不同一链接器将这段代码的地址移到了一段不同的地址范围中。第二个不同
之处在千链接器填上了 callq指令调用函数 mult2需要使用的地址（反汇编代码第 4行）。
链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。最后一个区别是
多了两行代码（第 8和 9行）。这两条指令对程序没有影响，因为它们出现在返回指令后面
（第 7行）。插入这些指令是为了使函数代码变为 16字节，使得就存储器系统性能而言，
能更好地放置下一个代码块。
3.2. 3 关千格式的注解
GCC产生的汇编代码对我们来说有点儿难读。一方面，它包含一些我们不需要关心
的信息，另一方面，它不提供任何程序的描述或它是如何工作的描述。例如，假设我们用
如下命令生成文件 mstore.s。
linux> gee -Og -S mstore.e
mstore. s的完整内容如下：
.file &ldquo;010-mstore.c&rdquo; .text .globl multstore .type multstore, @function
multstore: pushq o!.rbx movq o!.rdx, %rbx call mult2 movq %rax, (%rbx)
popq %rbx ret .size multstore,.-multstore .ident &ldquo;GCC: (Ubuntu 4 . 8.1-2ubuntu1-12.04) 4.8. 1&rdquo; .section.note.GNU-stack,1111,@progbits
．所有以｀．，开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些
行。另一方面，也没有关于指令的用途以及它们与源代码之间关系的解释说明。
为了更清楚地说明汇编代码，我们用这样一种格式来表示汇编代码，它省略了大部分
伪指令，但包括行号和解释性说明。对于我们的示例，带解释的汇编代码如下：
void multstore(long x, l ong y, long *dest)
x.1n %rd.1 , y.1n .rs.1， dest.1n肚dx 1234567
multstore:<br>pushq %rbx Save %rbx<br>movq %rdx, 1!.rbx Copy dest to %rbx<br>call mult2 Call mult2(x, y)<br>movq %rax, (%rbx) Store result at *dest<br>popq %rbx Restore %rbx<br>ret Return</p><p>通常我们只会给出与讨论内容相关的代码行。每一行的左边都有编号供引用，右边是注释，简单地描述指令的效果以及它与原始 C语言代码中的计算操作的关系。这是一种汇编语言程序员写代码的风格。
我们还提供网络旁注，为专门的机器语言爱好者提供一些资料。一个网络旁注描述的是 IA32机器代码。有了 x86-64的背景，学习 IA32会相当简单。另外一个网络旁注简要
描述了在 C语言中插入汇编代码的方法。对千一些应用程序，程序员必须用汇编代码来访问机器的低级特性。一种方法是用汇编代码编写整个函数，在链接阶段把它们和 C函数组合起来。另一种方法是利用 GCC的支持，直接在 C程序中嵌入汇编代码。
田日 ATT与 Intel汇编代码格式我们的表述是 ATT（根据 “AT&amp;T"命名的， AT&amp;T是运营贝尔实验室多年的公司）格式的汇编代码，这是 GCC、 OBJDUMP和其他一些我们使用的工具的默认格式。其他一些编程工具，包括 Microsoft的工具，以及来自 Intel的文档，其汇编代码都是 Intel格式的。这两种格式在许多方面有所不同。例如，使用下述命令行， GCC可以产生 multstore函数的 Intel格式的代码：
linux> gee -Og -S -masm=intel mstore.e
这个命令得到下列汇编代码：
multstore: push rbx mov rbx, rdx call mult2 mov QWORD PTR [rbx], rax pop rbx ret
我们看到 Intel和 ATT格式在如下方面有所不同：
. Intel代码省略了指示大小的后缀。我们看到指令 push和 mov,而不是 pushq和 movq。
. Intel代码省略了寄存器名宇前面的飞＇符号，用的是 rbx ,而不是％ rbx。
. Intel代码用不同的方式来描述内存中的位置，例如是 &lsquo;QWORD PTR [rbx尸而不是 &lsquo;(%rbx)&rsquo;。·在带有多个操作数的指令情况下，列出操作数的顺序相反。当在两种格式之间进行转换的时候，这一点非常令人困惑。</p><p>虽然在我们的表述中不使用 Int el格式，但是在来自 Intel和 M icrosoft的文档中，你会遇到它。
日正，把 C程序和汇编代码结合起来
虽然 C编译器在把程序中表达的计算转换到机器代码方面表现出色，但是仍然有一
些机器特性是 C程序访问不到的。例如，每次 x86 -64处理器执行算术或逻辑运算时，
如果得到的运算结果的低 8位中有偶数个 1,那么就会把一个名为 PF的 1位条件码
(condition code)标志设置为 1,否则就设置为 0。这里的 PF表示 “parity flag（奇偶标
志）”。在 C语言中计算这个信息需要至少 7次移位、掩码和异或运算（参见习题 2 . 65)。
即使作为每次算术或逻辑运算的一部分，硬件都完成了这项计算，而 C程序却无法知道
PF条件码标志的值。在程序中插入几条汇编代码指令就能很容易地完成这项任务。
在 C程序中插入汇编代码有两种方法。笫一种是，我们可以编写完整的函数，放进
一个独立的汇编代码文件中，让汇编器和链接器把它和用 C语言书写的代码合并起来。
第二种方法是，我们可以使用 GCC的内联汇编 (inline assembly)特性，用 asm伪指令可
以在 C程序中包含简短的汇编代码。这种方法的好处是减少了与机器相关的代码量。
当然，在 C程序中包含汇编代码使得这些代码与某类特殊的机器相关（例如 x8 6 -64)，所以只应该在想要的特性只能以此种方式才能访问到时才使用它。
3. 3 数据格式
由千是从 16位体系结构扩展成 32位的， Intel用术语”字 (word)&ldquo;表示 16位数据类型。因此，称 32位数为“双字 (double words)",称 64位数为“四字 (quad words)”。图 3-1给出了 C语言基本数据类型对应的 x86-64表示。标准 l.nt值存储为双字 (32位）。指针（在此用 char<em>表示）存储为 8字节的四字， 64位机器本来就预期如此。 x86-64中，数据类型 long实现为 64位，允许表示的值范围较大。本章代码示例中的大部分都使用了指针和 long数据类型，所以都是四字操作。 x86-64指令集同样包括完整的针对字节、字和双字的指令。
C声明 Inte l数据类型汇编代码后缀大小（字节） char 字节 b 1 short 字 w 2 in七双字 1 4
l ong 四字 q 8 char</em> 四字 q 8 float 单精度 s 4 double 双精度 l 8
图 3-1 C语言数据类型在 x86-64中的大小。在 64位机器中，指针长 8字节
浮点数主要有两种形式：单精度 (4字节）值，对应千 C语言数据类型 float;双精度 (8字节）值，对应于 C语言数据类型 double。 x86家族的微处理器历史上实现过对一种特殊的 80位 (10字节）浮点格式进行全套的浮点运算（参见家庭作业 2.86)。可以在 C程序中用声明 long double来指定这种格式。不过我们不建议使用这种格式。它不能移植到其他类型的机器上，而且实现的硬件也不如单精度和双精度算术运算的高效。
如图所示，大多数 GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种： movb（传送字节）、 movw（传送字）、 movl（传送双字）和 movq（传送四字）。后缀＇口用来表示双字，因为 32位数被看成是“长字 (l on g word)”。注意，汇编代码也使用后缀＇立来表示 4字节整数和 8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。</p><ol start=3><li>4 访问信息
一个 x86-64的中央处理单元 (CPU)包含一组 16个存储 64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。图 3-2显示了这 16个寄存器。它们的名字都以％ r开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。最初的 8086中有 8个 16位的寄存器，即图 3-2中的％ax到％bp。每个寄存器都有特殊的用途，它们的名字就反映了这些不同的用途。扩展到 IA32架构时，这些寄存器也扩展成 32/ 位寄存器，标号从％eax到％ ebp。扩展到 x86-64后，原来的 8个寄存器扩展成 64位，标号从％ rax到％ rbp。除此之外，还增加了 8个新的寄存器，它们的标号是按照新的命名规则制定的：从％ r8到％rlS。
63 31 15 %rax %eax
「ax 雪7 返回0 值
%rbx %ebx [%bx
三二］］被调用者保存
cds
xx.L三l第4个参数
%rcx %ecx
0
ooP9o
%rdx %edx
二］第3个参数
一
%esi
尸 二l第2个参数
o-09
db
号 rdi [ %edi ,LP二荨］第1个参数
o
%rbp %ebp
二］］被调用者保存
.____~
二］栈指针
毛 rsp %esp
0一
o2o
sr
P8
w
%r8 %r8d
匡］第5个参数
&mldr;
~ 910111213釭釭釭釭釭釭釭 %r9d %rl0d 尸 [%r9w I毛 rlOw[%rllw 二三］］第6个参数二三］调用者保存匡l]调用者保存
%r l2d [%rl2w 三三］被调用者保存
~<br>%r13d [%rl3w 国荨］被调用者保存
.<br>.<br>1415 %rl4d [%rl4w 匡~l]被调用者保存
.<br>%rl5d I毛 rlSw 三l]被调用者保存</li></ol><p>图 3 -2整数寄存器。所有 16个寄存器的低位部分都可以作为字节、字 (16位）、双字 (32位）和四字 (64位）数字来访问
如图 3-2中嵌套的方框标明的，指令可以对这 16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节， 16位操作可以访问最低的 2个字节， 32位操作可以访问最低的 4个字节，而 64位操作可以访问整个寄存器。
在后面的章节中，我们会展现很多指令，复制和生成 1字节、 2字节、 4字节和 8字节值。当这些指令以寄存器作为目标时，对于生成小于 8字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则：生成 1字节和 2字节数字的指令会保持剩下的字节不变；生成 4字节数字的指令会把高位 4个字节置为 0。后面这条规则是作为从 IA32到 x86-64的扩展的一部分而采用的。
就像图 3-2右边的解释说明的那样，在常见的程序里不同的寄存器扮演不同的角色。其中最特别的是栈指针％rsp,用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。另外 15个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。更重要的是，有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。我们会在描述过程的实现时（特别是在 3. 7节中），讲述这些惯例。
3. 4. 1 操作数指示符
大多数指令有一个或多个操作数 (operand)，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。 x86-64支持多种操作数格式（参见图 3-3)。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此，各种不同的操作数的可能性被分为三种类型。第一种类型是立即数 (immediate)，用来表示常数值。在 ATT格式的汇编代码中，立即数的书写方式是＇沪后面跟一个用标准 C表示法表示的整数，比如，＄－577或＄ OxlF。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。第二种类型是寄存器 (register)，它表示某个寄存器的内容， 16个寄存器的低位 1字节、 2字节、 4字节或 8字节中的一个作为操作数，这些字节数分别对应于 8位、 16位、 32位或 64位。在图 3-3中，我们用符号 ra来表示任意寄存器 a,用引用 R[ra]来表示它的值，这是将寄存器集合看成一个数组 R,用寄存器标识符作为索引。
第三类操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。因为将内存看成一个很大的字节数组，我们用符号 Mi, [Addr]表示对存储在内存中从地址 Addr开始的 b个字节值的引用。为了简便，我们通常省去下标 b。
如图 3-3所示，有多种不同的寻址模式，允许不同形式的内存引用。表中底部用语法 lmm(r6, r;, s)表示的是最常用的形式。这样的引用有四个组成部分：一个立即数偏移 Imm,一个基址寄存器 rb&rsquo;一个变址寄存器 r，和一个比例因子 s,这里 s必须是 1、 2、 4或者 8。基址和变址寄存器都必须是 64位寄存器。有效地址被计算为 Imm+R[r6]+R[rJ . s。引用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况，只是省略了某些部分。正如我们将看到的，当引用数组和结构元素时，比较复杂的寻址模式是很有用的。
类型格式操作数值名称
立即数 $/mm Imm 立即数寻址寄存器 r a R[ra] 寄存器寻址存储器 Imm M(/mm] 绝对寻址存储器 (r。) M[R[ra]] 间接寻址存储器 Imm(rb) M[lmm+R[rb]] （基址＋偏移量）寻址存储器 (rb, r;) M(R[rb)+R[r;)] 变址寻址存储器 lmm(rb, r;) M[/mm+R[r b]+R[ r ;]] 变址寻址
存储器 (,r,, s) M[R[r,) · s) 比例变址寻址存储器 lmm(,r,,s) M[/mm+R[r;] · s] 比例变址寻址存储器 (rb, r,, s) M[R[rb]+R[rJ · s] 比例变址寻址存储器 Imm(rb, r;, s) M[/mm+R[r&]+R[r;] · s] 比例变址寻址
图 3 -3操作数格式。操作数可以表示立即数（常数）值、寄存器值或是来自内存的值。比例因子 s必须是 1、 2、 4或者 8
心练习题 3. 1 假设下面的值存放在指明的内存地址和寄存器中：
地址值寄存器值
OxlOO OxFF %rax OxlOO
Oxl04 OxAB 令rcx Oxl
Ox108 Ox13 号 rdx Ox3
OxlOC Oxll
填写下表，给出所示操作数的值：
操作数值
%rax Ox104 $0x108
(%rax) 4(%rax) 9(%rax,%rdx) 260(%rcx, %rdx)
OxFC(，毛 rcx, 4)
(%rax, %rdx, 4)</p><ol start=3><li><ol start=4><li>2 数据传送指令
最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。我们会介绍多种不同的数据传送指令，它们或者源和目的类型不同，或者执行的转换不同，或者具有的一些副作用不同。在我们的讲述中，把许多不同的指令划分成指令类，每一类中的指令执行相同的操作，只不过操作数大小不同。
图 3-4列出的是最简单形式的数据传送指令－MOV类。这些指令把数据从源位置复制到目的位置，不做任何变化。 MOV类由四条指令组成： movb、 movw、 movl和 movq。这些指令都执行同样的操作；主要区别在于它们操作的数据大小不同：分别是 1、 2、 4和 8字节。
指令效果描述 MOV S, D D+-S 传送 movb 传送字节
movw 传送字 movl 传送双字 movq 传送四字 movabsq I, R R今 I传送绝对的四字
图 3 -4简单的数据传送指令
源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。 x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令－第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。参考图 3-2,这些指令的寄存器操作数可以是 16个寄存骈有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符 (&rsquo; b &lsquo;,&lsquo;w&rsquo;,&lsquo;尸或｀ q＇)指定的大小匹配。大多数情况
中， MOV指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是
movl指令以寄存器作为目的时，它会把该寄存器的高位 4字节设置为 0。造成这个例外的原因是 x8 6-64采用的惯例，即任何为寄存器生成 32位值的指令都会把该寄存器的高位部分置成 0。
下面的 MOV指令示例给出了源和目的类型的五种可能的组合。记住，第一个是源操作数，第二个是目的操作数：
12345
movl $0x4050,%eax Immediate&ndash;Register, 4 bytes mo四％bp,%sp Reg.lster一Register, 2 bytes movb (%rdi,%rcx),%al Memory&ndash;Reg.lster, 1 byte movb $-17, (%rsp) Immed.late&ndash;Memory, 1 byte movq %rax,-12(%rbp) Reg.lster&ndash;Memory, 8 bytes
图 3-4中记录的最后一条指令是处理 64位立即数数据的。常规的 movq指令只能以表示为 32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到 64位的值，放到目的位置。 movabsq指令能够以任意 64位立即数值作为源操作数，并且只能以寄存器作为目的。
图 3-5和图 3-6记录的是两类数据移动指令，在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源（在寄存器或内存中）复制到目的寄存器。 MOVZ类中的
指令把目的中剩余的字节填充为 o,而 MOVS类中的指令通过符号扩展来填充，把源操作
的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符：第一个字符指定源的大小，而第二个指明目的的大小。正如看到的那样，这两个类中每个都有三条指令，包括了所有的源大小为 1个和 2个字节、目的大小为 2个和 4个的情况，当然只考虑目的大于源的情况。
指令 效果 描述<br>MOVZ S, R R+&ndash;零扩展 (5) 以零扩展进行传送<br>movzbw 将做了笭扩展的字节传送到字<br>movzbl 将做了零扩展的字节传送到双字<br>movzwl 将做了零扩展的字传送到双字<br>movzbq 将做了笭扩展的字节传送到四字<br>movzwq 将做了零扩展的字传送到四字</li></ol></li></ol><p>图 3 -5零扩展数据传送指令。这些指令以寄存器或内存地址作为源，以寄存器作为目的
指令效果描述 MOVS S, R R-符号扩展 (S)传送符号扩展的字节 movsbw 将做了符号扩展的字节传送到字 movsbl 将做了符号扩展的字节传送到双字 movswl 将做了符号扩展的字传送到双字 movsbq 将做了符号扩展的字节传送到四字 movswq 将做了符号扩展的字传送到四字 movslq 将做了符号扩展的双字传送到四字 cltq 马rax+-符号扩展（告eax)把号eax符号扩展到毛rax
图 3 -6符号扩展数据传送指令。 MOVS指令以寄存器或内存地址作为源，以寄存器
作为目的。 cltq指令只作用千寄存器％ eax和％ rax</p><p>田日理解数据传送如何改变目的寄存器
正如我们描述的那样，关于数据传送指令是否以及如何修改目的寄存器的高位字节有两种不同的方法。下面这段代码序列会说明其差别：
12345
movabsq $0x0011223344556677, %rax .rax = 0011223344556677 movb $-1, %al .rax = 00112233445566FF movw $-1, %ax .rax = 001122334455FFFF movl $-1, %eax .rax = OOOOOOOOFFFFFFFF movq $-1, i!.rax .rax = FFFFFFFFFFFFFFFF
在接下来的讨论中，我们使用十六进制表示。在这个例子中，笫 1行的指令把寄存器％
rax初始化为位模式 0011223344556677。剩下的指令的液操作数值是立即数值— 1。回想一 1的十六进制表示形如 FF… F,这里 F的数量是表述中字节数量的两倍。因此 movb指令（第 2行）把％rax的低位宇节设置为 FF,而 movw指令（第 3行）把低 2位字节设置为 FFFF,剩下的宇节保持不变。 movl指令（笫 4行）将低 4个字节设置为 FFFFFFFF,同时把高位 4宇节设置为 00000000。最后 movq指令（第 5行）把整个寄存器设置为 FFFFFFFFFFFFFFFF。
注意图 3-5中并没有一条明确的指令把 4字节源值零扩展到 8字节目的。这样的指令逻辑上应该被命名为 movzlq,但是并没有这样的指令。不过，这样的数据传送可以用以寄存器为目的的 movl指令来实现。这一技术利用的属性是，生成 4字节值并以寄存器作为目的的指令会把高 4字节置为 0。对于 64位的目标，所有三种源类型都有对应的符号扩展传送，而只有两种较小的源类型有零扩展传送。
图 3-6还给出 cltq指令。这条指令没有操作数：它总是以寄存器％eax作为源，％ rax作为符号扩展结果的目的。它的效果与指令 movslq %eax, %rax完全一致，不过编码更紧凑。五练习题 3. 2 对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。（例
如， mov可以被重写成 movb、 movw、 movl或者 movq。) mov_ ．儿eax, (%rsp) mov_ (%rax), %dx mov $0xFF, %bl mov_ (%rsp丛rdx,4), %dl mov_ (%rdx), %rax mov_ %dx, (%rax)
田日字节传送指令比较 下面这个示例说明了不同的数据传送指令如何改变或者不改变目的的高位宇节。仔细观察可以发现，三个宇节传送指令 movb、 movsbq和 movzbq之间有细微的差别。示例如下：
12345
movabsq $0x0011223344556677, %rax .rax = 0011223344556677 movb $0xAA, %dl 7.dl = AA movb %dl,%al 7.rax = 00112233445566AA movsbq i!.dl,%rax 7.rax = FFFFFFFFFFFFFFAA movzbq %dl, i!.rax 7.rax = OOOOOOOOOOOOOOAA
在下面的讨论中，所有的值都使用十六进制表示。代码的头 2行将寄存器％ rax和％dl分别初始化为 0011223344556677和 AA。剩下的指令都是将％ rdx的低位宇节复制到％ rax的低位宇节。 movb指令（笫 3行）不改变其他宇节。根据源宇节的最高位， movsbq指令（第 4行）将其他 7个字节设为全 1或全 0。由于十六进制 A表示二进制值 1 010,符号扩展会把高位宇节都设置为 FF。 movzbq指令（笫 5行）总是将其他 7个宇节全都设置为 0。
练习题3 . 3 当我们调用汇编器的时候，下面代码的每一行都会产生一个错误消息。解释每一行都是哪里出了错。
movb $0xF, (%ebx) movl %rax, (%rsp) movw (%rax),4(%rsp) movb %al,%s1 movq %rax,$0x123 movl %eax,%rdx movb %si, 8(%rbp)
3. 4. 3 数据传送示例
作为一个使用数据传送指令的代码示例，考虑图 3-7中所示的数据交换函数，既有 C
代码，也有 GCC产生的汇编代码。
long exchange(long *xp, long y)
{
long x = *xp; *XP = y; return x;
}
a) C语言代码
1 ong exchange (1 ong *xp, 1 ong y) xp 1.nZrd1. , y 1.n %r s1. exchange:
23 movq (%rdi), %rax Get x at xp. Set as return value. movq %rsi, (%rdi) Storey at xp.
4
ret Retur n.
b)汇编代码
图 3-7 exchange函数的 C语言和汇编代码。寄存器％r中和％ rsi分别存放参数 xp和 y
如图 3 -7 b所示，函数 exchange由三条指令实现：两个数据传送 (movq)，加上一条返回函数被调用点的指令 (ret)。我们会在 3. 7节中讲述函数调用和返回的细节。在此之前，知道参数通过寄存器传递给函数就足够了。我们对汇编代码添加注释来加以说明。函
数通过把值存储在寄存器％rax或该寄存器的某个低位部分中返回。当过程开始执行时，过程参数 xp和 y分别存储在寄存器％ rdi和％ rsi中。然后，指令 2从内存中读出 x,把它存放到寄存器％rax中，直接实现了 C程序中的操作 x=*xp。稍
后，用寄存器％rax从这个函数返回一个值，因而返回值就是 x。指令 3将 y写入到寄存器％ rdi中的 xp指向的内存位置，直接实现了操作＊ xp=y。这个例子说明了如何用 MOV
指令从内存中读值到寄存器（第 2行），如何从寄存器写到内存（第 3行）。
关于这段汇编代码有两点值得注意。首先，我们看到 C语言中所谓的”指针“其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。其次，像 x这样的局部变量通常是保存在寄存器中，而不是内存中。访问寄存器比访问内存要快得多。练习题3 . 4 假设变量 sp和 dp被声明为类型
src_t *sp; dest_t *dp;
这里 src_t和 dest＿七是用 typedef声明的数据类型。我们想使用适当的数据传送指令来实现下面的操作
*dp = (dest_t) *sp;
假设 sp和 dp的值分别存储在寄存器％rdi和％rsi中。对于表中的每个表项，给出实现指定数据传送的两条指令。其中第一条指令应该从内存中读数，做适当的转换，并设置寄存器％rax的适当部分。然后，第二条指令要把％rax的适当部分写到内存。在这两种情况中，寄存器的部分可以是％rax、 %eax、 %ax或％al,两者可以互不相同。
记住，当执行强制类型转换既涉及大小变化又涉及 C语言中符号变化时，操作应该先改变大小 (2. 2. 6节）。
src t des七 t 指令<br>long long movq伐 rd习， 号 rax<br>movq 沦 rax, 伐rsi)<br>char int</p><p>char unsigned
unsigned char long
int char
unsigned unsigned char
char short
一指针的一些示例函数 exchange（图 3-7a)提供了一个关于 C语言中指针使用的很好说明。参数 xp是一个指向 long类型的整数的指针，而 y是一个 long类型的整数。语句
long x = *xp;
表示我们将读存储在 xp所指位置中的值，并将它存放到名宇为 x的局部变量中。这个读操作称为指针的间接引用 (pointer dereferencing), C操作符＊执行指针的间接引用。语句
*XP = y;
正好相反——－它将参数 y的值写到 xp所指的位置。这也是指针间接引用的一种形式（所以有操作符＊），但是它表明的是一个写操作，因为它在赋值语句的左边。下面是调用 exchange的一个实际例子：
long a= 4; long b = exchange(&:a, 3); printf(&ldquo;a = %ld, b = %ld\n&rdquo;, a, b);
这段代码会打印出：
a = 3, b = 4
C操作符＆（称为“取址”操作符）创建一个指针，在本例中，该指针指向保存局部变
量 a的位置。然后，函数 exchange将用 3覆盖存储在 a中的值，但是返回原来的值 4作
为函数的值。注意如何将指针传递给 exchange ,它能修改存在某个远处位置的数据。
区练习题3 . 5 已知信息如下。将一个原型为
void decode1(long .xp, long *YP, long .zp);
的函数编译成汇编代码，得到如下代码：
VO.ld decode1 (long .xp, l ong *YP, long .zp) xp.ln .rd.l , yp.ln .rs.l , zp.ln .rdx
decode! : movq (%rdi), %r8 movq (&lsquo;I,r s i ), %r cx movq (o/.r dx), o/.rax movq %r8, (%rsi) movq %r cx, (%rdx) movq o/.rax, (o/.rdi) r et
参数 xp、 yp和 zp分别存储在对应的寄存器％rd丛％rsi和％rdx中。
请写出等效于上面汇编代码的 decodel的 C代码。
3. 4. 4 压入和弹出栈数据
最后两个数据传送操作可以将数据压入程序栈中，以及从程序栈中弹出数据，如图 3 -8所示。正如我们将看到的，栈在处理过程调用中起到至关重要的作用。栈是一种数据结构，可以添加或者删除值，不过要遵循”后进先出”的原则。通过 push操作把数据压入栈中，通过 pop操作删除数据；它具有一个属性：弹出的值永远是最近被压人而且仍然在栈中的值。栈可以实现为一个数组，总是从数组的一端插入和删除元素。这一端被称为栈
顶。在 x86-64中，程序栈存放在内存中某个区域。如图 3-9所示，栈向下增长，这样一来，栈顶元素的地址是所有栈中元素地址中最低的。（根据惯例，我们的栈是倒过来画的，栈“顶”在图的底部。）栈指针％r sp保存着栈顶元素的地址。
指令 效果 描述<br>pushq s R[毛 rsp] +-R［令 rsp] M [ R［毛 r sp]] &ndash;s 8; 将四字压人栈<br>popq D D..-M[ R［釭sp]] ;R [号 rsp]+-R [毛 rsp]+8 将四字弹出栈</p><p>图 3 -8入栈和出栈指令
pushq指令的功能是把数据压入到栈上，而 popq指令是弹出数据。这些指令都只有一个操作数一压入的数据源和弹出的数据目的。将一个四字值压入栈中，首先要将栈指针减 8,然后将值写到新的栈顶地址。因此，指令 pushq %rbp的行为等价于下面两条指令：
subq $8,%rsp Decrement stack pointer movq %rbp, (%rsp) Store .rbp on stack
它们之间的区别是在机器代码中 pushq指令编码为 1个字节，而上面那两条指令一共需要 8个字节。图 3-9中前两栏给出的是，当％ rsp为 Ox108, %rax为 Ox123时，执行指令
pushq %rax的效果。首先％ rsp会减 8,得到 OxlOO,然后会将 Ox123存放到内存地址 OxlOO处。
最初 pushq .rax popq %rdx
%rax Ox123 %rclx 。归%rsp Ox108
栈＂底” 栈＂底” 栈｀｀底”</p><p>`
.
地址增大
.
Oxl08 Oxl08 Ox108 栈＂顶” OxlOO Oxl23 Ox123
栈“顶” 栈“顶＇
图 3 -9栈操作说明。根据惯例，我们的栈是倒过来画的，因而栈“顶”在底部。 x86 -64中，栈向低地址方向增长，所以压栈是减小栈指针（寄存器％ rsp)的值，并将数据存放到内存中，而出栈是从内存中读数据，并增加栈指针的值
弹出一个四字的操作包括从栈顶位置读出数据，然后将栈指针加 8。因此，指令 popq % rax等价于下面两条指令：
movq (%rsp) , %rax Read .rax from stack addq $8,%rsp Increment stack pointer
图 3-9的第三栏说明的是在执行完 pushq后立即执行指令 popq %rdx的效果。先从内
存中读出值 Oxl23,再写到寄存器％ rdx中，然后，寄存器％ rsp的值将增加回到 Oxl08。
如图中所示，值 Oxl23仍然会保持在内存位置 OxlOO中，直到被覆盖（例如被另一条入栈操作覆盖）。无论如何，％ rsp指向的地址总是栈顶。因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置。例如，假设栈顶元素是四字，指令 movq 8 (% rsp), %rdx会将第二个四字从栈中复制到寄存器％rdx。
3. 5 算术和逻辑操作
图 3-10列出了 x86-64的一些整数和逻辑操作。大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种（只有 leaq没有其他大小的变种）。例如，指令类 ADD由四条加法指令组成： addb、 addw、 addl和 addq,分别是字节加法、字加法、双字加法和四字加法。事实上，给出的每个指令类都有对这四种不同大小数据的指令。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，而一元操作有一个操作数。这些操作数的描述方法与 3.4节中所讲的一样。
指令 效果 描述<br>leaq S, D D七＆S 加载有效地址<br>INC D D七 D+l 加 1<br>DEC D D七－D-1 减 1<br>NEG D D&ndash;D 取负<br>NOT D D +&ndash;D 取补<br>ADD S,D D七 D+S 加<br>SUB S,D D七 D-S 减<br>IMUL S,D D七 D *S 乘<br>XOR S,D D七 D ^S 异或<br>OR S,D D七－DIS 或<br>AND S,D D-D&amp;S 与<br>SAL k,D D~D.k 左移<br>SHL k, D D七－D.k 左移（等同于SAL )<br>SAR k,D D七 D.Ak 算术右移<br>SHR k,D D七· D .Lk 逻辑右移</p><p>图 3-10整数算术操作。加载有效地址 (le a q)指令通常用来执行简单的算术操作。其余的指令是更加标准的一元或二元操作。我们用＞＞入和＞＞ L来分别表示算术右移和逻辑右移。注意，这里的操作顺序与 ATT格式的汇编代码中的相反
3. 5. 1 加载有效地址
加载有效地址 (load effective address)指令 leaq实际上是 movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写人到目的操作数。在图 3-10中我们用 C语言的地址操作符＆ S说明这种计算。这条指令可以为后面的内存引用产生指针。另外，它还可以简洁地描述普通的算术操作。例如，如果寄存器％ rdx的值为 x,那么指令 leaq 7 (%rdx, %rdx, 4), %rax将设置寄存器％rax的值为 5x+ 7。编译器经常发现 leaq的一些灵活用法，根本就与有效地址计算无关。目的操作数必须是一个寄存器。
为了说明 leaq在编译出的代码中的使用，看看下面这个 C程序：
long scale(long x, long y, long z) { long t = x + 4 * y + 12 * z; return t;
编译时，该函数的算术运算以三条 leaq指令实现，就像右边注释说明的那样：
long s cale(long x, long y, long z) x.ln妇rdi , y.ln缸si , z in .rdx
scale: leaq (%rdi,%rsi,4), %rax X + 4<em>y leaq (%rdx,%rdx,2), %rdx Z + 2</em>z = 3<em>Z leaq (%rax,%rdx,4), %rax (x+4</em>y) + 4*(3<em>z) = x + 4</em>y + 12*z ret
leaq指令能执行加法和有限形式的乘法，在编译如上简单的算术表达式时，是很有用处的。芦练习题3 . 6 假设寄存器％rax的值为 x,%rcx的值为 y。填写下表，指明下面每条汇编代码指令存储在寄存器％rdx中的值：
表达式结果
leaq 6（毛ax)，毛rdx
leaq （号工ax,皂 rcx), %rdx
leaq (%rax, %rcx, 4)，毛rdx
leaq 7（号rax,告rax, 8 ), %rdx
leaq OxA(，毛 rcx,4)， %rdx
leaq 9( % rax,号 rcx,2),%rdx
让练习题3 . 7 考虑下面的代码，我们省略了被计算的表达式：
long scale2(long x, long y, long z) { long t = return t;
}
用 GCC编译实际的函数得到如下的汇编代码：
long scale2(long x, l ong y, long z ) x in .rdi, y in肛si , z in妇rdx
scale2: leaq (%rdi,%rdi,4), %rax leaq (%rax,%rsi,2), %rax leaq (%rax,%rdx,8), %rax ret
填写出 C代码中缺失的表达式。
3. 5. 2 一元和二元操作
第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。比如说，指令 incq( % rsp)会使栈顶的 8字节元素
加 1。这种语法让人想起 C语言中的加 1运算符(++）和减 1运算符（一—)。
第三组是二元操作，其中，第二个操作数既是源又是目的。这种语法让人想起 C语言中的赋值运算符，例如 x-=y。不过，要注意，源操作数是第一个，目的操作数是第二个，对千不可交换操作来说，这看上去很奇特。例如，指令 subq %rax, %rdx使寄存器％ rdx的
值减去％rax中的值。（将指令解读成“从％ rdx中减去％ r ax"会有所帮助。）第一个操作数
可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意，当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存。让练习题 3 . 8 假设下面的值存放在指定的内存地址和寄存器中：
地址 值 寄存器 值<br>OxlOO OxFF 号 ra x OxlOO<br>Ox108 OxAB %rcx Oxl<br>OxllO Oxl3 %rdx Ox3<br>Oxl18 Oxll</p><p>填写下表，给出下面指令的效果，说明将被更新的寄存器或内存位置，以及得到的值：
指令目的值
addq毛 rcx,（沧 rax)
subq毛 rdx,8( % rax)
耳nulq $16,伐 rax,毛 rdx,8)
incq 16(兮 rax) decq %rcx
subq皂rdx,釭ax
3. 5. 3 移位操作
最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器％ cl中。（这些指令很特别，因为只允许以这个特定的寄存器作为操作数。）原则上来说， 1个字节的移位量使得移位量的编码范围可以达到 28 -1 = 255。 x86-64中，移位操作对 w位长的数据值进行操作，移位量是由％cl寄存器的低 m位决定的，这里 2 &rsquo;n=w。高位会被忽略。所以，例如当寄存器％ cl的十六进制值为 OxFF时，指令 salb会移 7位， salw会移 15位， sall会移 31位，而 salq会移 63位。
如图 3-10所示，左移指令有两个名字： SAL和 SHL。两者的效果是一样的，都是将右边填上 0。右移指令不同， SAR执行算术移位（填上符号位），而 SHR执行逻辑移位（填上 0)。移位操作的目的操作数可以是一个寄存器或是一个内存位置。图 3-10中用＞＞＾（算术）和＞＞凶逻辑）来表示这两种不同的右移运算。区练习题 3. 9 假设我们想生成以下 C函数的汇编代码：
long shift_left4_rightn(long x, long n)
{
X .= 4; X &#187;= n; return x;
}
下面这段汇编代码执行实际的移位，并将最后的结果放在寄存器％ rax中。此处省略了两条关键的指令。参数 x和 n分别存放在寄存器％rdi和％rs土中。
long sh.lft_left4_r.lghtn(long x, long n) x.ln i.rdi, n in .rs.l shift_left4_rightn: movq %rdi. %rax Get x X &#171;= 4 movl %esi, %ecx Get n (4 bytes) X &#187;= n
根据右边的注释，填出缺失的指令。请使用算术右移操作。
3. 5. 4 讨论
我们看到图 3-10所示的大多数指令，既可以用千无符号运算，也可以用于补码运算。只有右移操作要求区分有符号和无符号数。这个特性使得补码运算成为实现有符号整数运
算的一种比较好的方法的原因之一。
图 3-11给出了一个执行算术操作的函数示例，以及它的汇编代码。参数 x、 y和 z初
始时分别存放在内存％ rdi、 % rsi和％ rdx中。汇编代码指令和 C源代码行对应很紧密。第 2
行计算 x^y的值。指令 3和 4用 leaq和移位指令的组合来实现表达式 z* 48。第 5行计
算 tl和 OxOFOFOFOF的 AND值。第 6行计算最后的减法。由于减法的目的寄存器是％
rax, 函数会返回这个值。
long arith(long x, long y, long z)
{
long ti= x -y; long t2 = z * 48; long t3 = ti & OxOFOFOFOF; long t4 = t2 -t3; return t4;
}
a) C语言代码
long arith(long x, long y, long z) x in .rdi, y in .rsi, z in .rdx
1234567
arith:
xorq %rsi, %rdi t1 = X ~ y<br>leaq (%rdx,%rdx,2), %rax 3<em>Z<br>salq $4, %rax t2 = 16 * (3</em>z) = 48*Z<br>andl $252645135, %edi t3 = t1 & OxOFOFOFOF<br>subq %rdi, %rax Return t2 -t3<br>ret</p><p>b )汇编代码
图 3-11 算术运算函数的 C语言和汇编代码
在图 3-11的汇编代码中，寄存 ;ff %rax中的值先后对应于程序值 3<em>z、 z</em> 48和 t4（作
为返回值）。通常，编译器产生的代码中，会用一个寄存器存放多个程序值，还会在寄存器之间传送程序值。沁氐练习题 3 . 10 下面的函数是图 3-lla中函数一个变种，其中有些表达式用空格替代：
long arith2(1ong x, long y, long z)
{
long t1 = _, long t2 = _ long t3 = long t4 = return t4;
}
实现这些表达式的汇编代码如下：
long ar.lt;h2(long x, long y, long z) x in .rd.l , y.ln .rs.l , z.ln .rdx
笫 3章程序的机器级表示 133
arith2: orq %rsi, %rdi sarq $3, %rdi notq %rdi movq %rdx, %rax subq %rdi, %rax ret
基于这些汇编代码，填写 C语言代码中缺失的部分。练习题 3. 11 常常可以看见以下形式的汇编代码行：
xorq %rdx,%rdx
但是在产生这段汇编代码的 C代码中，并没有出现 EXCLUSIVE-OR操作。
A.解释这条特殊的 EXCLUSIVE-OR指令的效果，它实现了什么有用的操作。 B.更直接地表达这个操作的汇编代码是什么？ C.比较同样一个操作的两种不同实现的编码字节长度。
3. 5. 5 特殊的算术操作正如我们在 2. 3节中看到的，两个 64位有符号或无符号整数相乘得到的乘积需要 1 28位来表示。 x86-64指令集对 128位 (16字节）数的操作提供有限的支持。延续字 (2字节）、双字 (4字节）和四字 (8字节）的命名惯例， Intel把 16字节的数称为八宇 (oct word)。图 3-12描述的是支持产生两个 64位数字的全 128位乘积以及整数除法的指令。
指令效果描述
imulq s R［沦rdx] : R［毛rax]&ndash;SX R[号rax]有符号全乘法 mulq s R[马 rdx]: R[ %rax]+-S X R[号 rax]无符号全乘法 clto R[ %rdx] , R[ %rax]-符号扩展 CR[%rax] )转换为八字
R[% rdx]+&ndash;R［毛 rdx]:
idivq s R[ %rax] mod S 有符号除法
R [号 rdx]+-R[ %rdx] : R[ %rax] -:-S
divq s R[号rdx]+-R［ % rdx] : R[角rax] mod S 无符号除法 R[兮 rctx] &mdash;R［ %rdx]: R[ %rax] -:-S
图 3 -1 2特殊的算术操作。这些操作提供了有符号和无符号数的全 128位乘法和除法。一对寄存器％ rdx和％ rax组成一个 128位的八字
imulq指令有两种不同的形式。其中一种，如图 3-1 0所示，是 IMUL指令类中的一种。这种形式的 imulq指令是一个“双操作数＂乘法指令。它从两个 64位操作数产生一个 64位乘积，实现了 2. 3. 4和 2. 3. 5节中描述的操作＊以和＊ ~4。（回想一下，当将乘积截取到 64位时，无符号乘和补码乘的位级行为是一样的。）
此外， x86-64指令集还提供了两条不同的“单操作数”乘法指令，以计算两个 64位值的全 128位乘积一－个是无符号数乘法 (mulq)，而另一个是补码乘法 (imulq)。这两条指令都要求一个参数必须在寄存器釭ax中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器％ rdx（高 64位）和％ rax（低 64位）中。虽然 imulq这个名字可以用千两个不同的乘法操作，但是汇编器能够通过计算操作数的数目，分辨出想用哪条指令。
下面这段 C代码是一个示例，说明了如何从两个无符号 64位数字 x和 y生成 128位的乘积：
#include &lt;inttypes.h>
typedef unsigned __int128 uint128_t;
void store_uprod(uint128_t *dest, uint64_t x, uint64_t y) { *dest = x * (uint128_t) y; }
在这个程序中，我们显式地把 x和 y声明为 64位的数字，使用文件 inttypes.h中声明的定义，这是对标准 C扩展的一部分。不幸的是，这个标准没有提供 128位的值。所以我们只好依赖 GCC提供的 128位整数支持，用名字＿＿int128来声明。代码用 typedef声明定义了一个数据类型 uint128_t,沿用的 inttypes. h中其他数据类型的命名规律。这段代码指明得到的乘积应该存放在指针 de江指向的 16字节处。
GCC生成的汇编代码如下：
VO.1d store_uprod(u.1nt128_t .dest, uint64_t x, u.1nt64_t y)
dest.1n %rd.1 , x.1n %rs.1 , y.1n %rdx 123456
store_uprod:<br>movq .rsi, .rax Copy x to multiplicand<br>mulq .rdx Multiply by y<br>movq .rax, （壮di) Store lower 8 bytes at dest<br>movq .rdx, 8(.rdi) Store upper 8 bytes at dest+8<br>ret</p><p>可以观察到，存储乘积需要两个 movq指令：一个存储低 8个字节（第 4行），一个存储高 8个字节（第 5行）。由于生成这段代码针对的是小端法机器，所以高位字节存储在大地址，正如地址 8(%rdi)表明的那样。
前面的算术运算表（图 3-10)没有列出除法或取模操作。这些操作是由单操作数除法指令来提供的，类似于单操作数乘法指令。有符号除法指令过ivl将寄存器％ rdx（高 64位）
和％ rax（低 64位）中的 128位数作为被除数，而除数作为指令的操作数给出。指令将商存
储在寄存器％rax中，将余数存储在寄存器％rdx中。对于大多数 64位除法应用来说，除数也常常是一个 64位的值。这个值应该存放在％
rax中，％rdx的位应该设置为全 0（无符号运算）或者％ rax的符号位（有符号运算）。后面这个操作可以用指令 cqto包来完成。这条指令不需要操作数一一它隐含读出％ rax的符号位，并将它复制到％rdx的所有位。
我们用下面这个 C函数来说明 x86~64如何实现除法，它计算了两个 64位有符号数的商和余数：
void remdiv(long x, long y,
long *qp, long *rp) { long q = x/y; long r = x%y; *qp = q; *rp = r;
}
该函数编译得到如下汇编代码：
e) 在 Intel的文档中，这条指令叫做 cqo,这是指令的 ATT格式名字和 Intel名字无关的少数情况之一。
void remdiv(long x, long y, long *qp, long .rp) x in .rdi, y in .rsi, qp in .rdx, rp in .rcx
12345678
remdiv:
rnovq %rdx, %r8 Copy qp<br>rnovq %rdi, %rax Move x to lower 8 bytes of dividend<br>cqto Sign-extend to upper 8 bytes of dividend<br>idivq %rsi Divide by y<br>movq %rax, (%r8) Store quotient at qp<br>movq %rdx, (%rcx) Store remainder at rp<br>ret</p><p>在上述代码中，必须首先把参数 qp保存到另一个寄存器中（第 2行），因为除法操作要使用参数寄存器％rdx。接下来，第 3~4行准备被除数，复制并符号扩展 x。除法之后，寄存器％ rax中的商被保存在 qp（第 6行），而寄存器％rdx中的余数被保存在 rp（第 7行）。
无符号除法使用 divq指令。通常，寄存器％rdx会事先设置为 0。饬练习题 3 . 12 考虑如下函数，它计算两个无符号 64位数的商和余数：
void urerndiv(unsigned long x, unsigned long y,
unsigned long *qp, unsigned long *rp) { unsigned long q = x/y; unsigned long r =戏y; *qp = q; *rp = r;
}
修改有符号除法的汇编代码来实现这个函数。</p><ol start=3><li>6 控制
到目前为止，我们只考虑了直线代码的行为，也就是指令一条接着一条顺序地执行。 C语言中的某些结构，比如条件语句、循环语句和分支语句，要求有条件的执行，根据数据测试的结果来决定操作执行的顺序。机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。
与数据相关的控制流是实现有条件行为的更一般和更常见的方法，所以我们先来介绍它。通常， C语言中的语句和机器代码中的指令都是按照它们在程序中出现的次序，顺序执行的。用 jump指令可以改变一组机器代码指令的执行顺序， jump指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试的结果。编译器必须产生构建在这种低级机制基础之上的指令序列，来实现 C语言的控制结构。本文会先涉及实现条件操作的两种方式，然后描述表达循环和 switch语句的方法。</li><li><ol start=6><li>1 条件码
除了整数寄存器， CPU还维护着一组单个位的条件码 (condition code)寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。最常用的条件码有：
CF:进位标志。最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。
ZF:零标志。最近的操作得出的结果为 0。
SF:符号标志。最近的操作得到的结果为负数。
OF:溢出标志。最近的操作导致一个补码溢出一正溢出或负溢出。
比如说，假设我们用一条 ADD指令完成等价千 C表达式 t=a+ b的功能，这里变量 a、 b和 t都是整型的。然后，根据下面的 C表达式来设置条件码： CF (unsigned) t &lt; (unsigned) a 无符号溢出
ZF (t =O)零
SF (t&lt;O) 负数
OF (a&lt;O==b&lt;O) && (t&lt;O ! =a&lt;O) 有符号溢出
leaq指令不改变任何条件码，因为它是用来进行地址计算的。除此之外，图 3-10中列出的所有指令都会设置条件码。对千逻辑操作，例如 XOR,进位标志和溢出标志会设置成 0。对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为 0。 INC和 DEC指令会设置溢出和零标志，但是不会改变进位标志，至于原因，我们就不在
这里深入探讨了。
除了图 3-10 中的指令会设置条件 指令 基于 描述<br>码，还有两类指令（有 8、 16、 32 和 64 CMP S1, S2 s,—S1 比较<br>位形式），它们只设置条件码而不改变任 crnpb 比较字节<br>何其他寄存器；如图 3 -13所示。 CMP指 cmpw 比较字<br>令根据两个操作数之差来设置条件码。 cmpl 比较双字<br>除了只设置条件码而不更新目的寄存器 cmpq 比较四字<br>之外， CMP指令与 SUB指令的行为是
一样的。在 ATT格式中，列出操作数的 TEST S1, S2 S1 &.S2 测试<br>顺序是相反的，这使代码有点难读。如 test b 测试字节<br>果两个操作数相等，这些指令会将零标 testw 测试字<br>志设置为 1&rsquo; 而其他的标志可以用来确定 testl 测试双字<br>两个操作数之间的大小关系。 TEST指 testq 测试四字</li></ol></li></ol><p>令的行为与 AND指令一样，除了它们只图 3-1 3比较和测试指令。这些指令不修改任何
设置条件码而不改变目的寄存器的值。寄存器的值，只设置条件码典型的用法是，两个操作数是一样的（例如， testq %rax,%rax用来检查％ rax是负数、零，还是正数），或其中的一个操作数是一个掩码，用来指示哪些位应该被测试。
3. 6. 2 访问条件码条件码通常不会直接读取，常用的使用方法有三种： l）可以根据条件码的某种组合，将一个字节设置为 0或者 1, 2)可以条件跳转到程序的某个其他的部分， 3）可以有条件地传送数据。对于第一种情况，图 3 -14中描述的指令根据条件码的某种组合，将一个字节设置为 0或者 1。我们将这一整类指令称为 SET指令；它们之间的区别就在千它们考虑的条件码的组合是什么，这些指令名字的不同后缀指明了它们所考虑的条件码的组合。这些指令的后缀表示不同的条件而不是操作数大小，了解这一点很重要。例如，指令 setl和 setb表示“小千时设置 (set less)&ldquo;和“低千时设置 (set below)",而不是“设置长字 (set long word)&ldquo;和“设置字节 (set byte)”。一条 SET指令的目的操作数是低位单字节寄存器元素（图 3-2)之一，或是一个字节的内存位置，指令会将这个字节设置成 0或者 1。为了得到一个 32位或 64位结果，我们必须对高位清零。一个计算 C语言表达式 a&lt; b的典型指令序列如下所示，这里 a和 b都是 long类型：
指令同义名效果设置条件
sete D setz D七 ZF相等／零 setne D setnz D七～ ZF不等／非零
sets D D七SF负数 setns D D七～SF非负数
setg D setnle D七～（SF-□F) &-ZF 大千（有符号＞） setge D setnl D七～（SF-OF) 大千等千（有符号＞＝） setl D setnge D七 SF-OF 小千（有符号＜） setle D setng D +-(SF -OF) I ZF 小千等千（有符号＜＝）
seta D setnbe D +&ndash;CF&-ZF 超过（无符号＞） setae D setnb D七～CF超过或相等（无符号＞＝） setb D setnae D七 CF低于（无符号＜） setbe D setna D七 CF I ZF 低于或相等（无符号＜＝）
图 3 -1 4 SET指令。每条指令根据条件码的某种组合，将一个字节设置为 0或者 1。有些指令有“同义名“，也就是同一条机器指令有别的名字
int comp(data_t a, data_t b) a in .rdi , bin加rsi
12345
comp: cmpq 。1/.rsi, %rdi Compare a :b setl %al Set low-order byte of .eax to O or 1 movzbl %al, %eax Clear rest of .eax (and rest of .rax)
ret
注意 cmpq指令的比较顺序（第 2行）。虽然参数列出的顺序先是％ rsi(b)再是％ rdi(a),
实际上比较的是 a和 b。还要记得，正如在 3.4. 2节中讨论过的那样， movzbl指令不仅会把％eax的高 3个字节清零，还会把整个寄存器％rax的高 4个字节都清零。
·某些底层的机器指令可能有多个名字，我们称之为“同义名 (synonym)”。比如说，
setg（表示“设置大千”)和 setnle（表示“设置不小千等于＂）指的就是同一条机器指令。编译器和反汇编器会随意决定使用哪个名字。
虽然所有的算术和逻辑操作都会设置条件码，但是各个 SET命令的描述都适用的情况是：执行比较指令，根据计算 t =a-b设置条件码。更具体地说，假设 a、 b和 t分别是变量 a、 b和 t的补码形式表示的整数，因此 t=a－口， b&rsquo;这里 w取决于 a和 b
的大小。来看 sete的情况，即“当相等时设置 (set when equal)&ldquo;指令。当 a=b时，会得到 t=O,
因此零标志置位就表示相等。类似地，考虑用 setl,即“当小千时设置 (set when less)&ldquo;指令，测试一个有符号比较。当没有发生溢出时 (OF设置为 0就表明无溢出），我们有当 a-!,,b&lt;O时 a&lt;b,将 SF设置为 1即指明这一点，而当 a—;，b亥0时 a~b,由 SF设置为 0指明。另一方面，当发生溢出时，我们有当 a—:,,b>O（负溢出）时 a&lt;b ,而当 a—~b&lt;O（正溢出）时 a>b。当 a=b时，不会有溢出。因此，当 OF被设置为 1时，当且仅当 SF被设置为 o,有 a&lt;b。将这些情况组合起来，溢出和符号位的 EXCLUSIVE-OR提供了 a&lt;b是否为真的测试。其他的
有符号比较测试基于 SF OF和 ZF的其他组合。
A
对于无符号比较的测试，现在设 a和 b是变量 a和 b的无符号形式表示的整数。在执行计算 t=a-b中，当 a -b&lt;O时， CMP指令会设置进位标志，因而无符号比较使用的是进位标志和零标志的组合。
注意到机器代码如何区分有符号和无符号值是很重要的。同 C语言不同，机器代码不会将每个程序值都和一个数据类型联系起来。相反，大多数情况下，机器代码对于有符号和无符号两种情况都使用一样的指令，这是因为许多算术运算对无符号和补码算术都有一样的位级行为。有些情况需要用不同的指令来处理有符号和无符号操作，例如，使用不同
版本的右移、除法和乘法指令，以及不同的条件码组合。 ;1练习题 3 . 13 考虑下列的 C语言代码：
int comp(data_t a, data_t b) { return a COMP b;
它给出了参数 a和 b之间比较的一般形式，这里，参数的数据类型 da七 a_t（通过 typede f)被声明为表 3 -1中列出的某种整数类型，可以是有符号的也可以是无符号的 comp通过＃ define来定义。
假设 a在％rd.l中某个部分， b在％rs.l中某个部分。对于下面每个指令序列，确
定哪种数据类型 data_t和比较 COMP会导致编译器产生这样的代码。（可能有多个正确答案，请列出所有的正确答案。）
A. cmpl %esi, %edi setl %al
B. cmpw %si, %di setge %al
C. cmpb %sil, %dil setbe %al
D. cmpq %rsi, %rdi
setne %a ;练习题3 . 14 考虑下面的 C语言代码：
int test(data_t a) { return a TEST O;
}
它给出了参数 a和 0之间比较的一般形式，这里，我们可以用七ypedef来声明 data＿七，从而设置参数的数据类型，用＃ define来声明 TEST,从而设置比较的类型。对于下
面每个指令序列，确定哪种数据类型 data_t和比较 TEST会导致编译器产生这样的代码。（可能有多个正确答案，请列出所有的正确答案。）
A. testq %rdi, %rdi setge i.al
B. testw %di, %di sete .!.al
C. testb %dil, %dil seta %al
D. testl %edi, .edi setne %al
3. 6. 3 跳转指令
正常执行的情况下，指令按照它们出现的顺序一条一条地执行。跳转 (jump)指令会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号
(label)指明。考虑下面的汇编代码序列（完全是人为编造的）：
movq $0,%rax Set .rax to 0 jmp.L1 Goto .L1 movq (%rax),%rdx Null pointer dereference (skipped)
.L1:
popq %rdx Jump target
指令 jmp.Ll会导致程序跳过 movq指令，而从 popq指令开始继续执行。在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令的地址）编码为跳转指令的一部分。
图 3 -1 5列举了不同的跳转指令。 jmp指令是无条件跳转。它可以是直接跳转，即跳转目标是作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或内存位置中读出的。汇编语言中，直接跳转是给出一个标号作为跳转目标的，例如上面所示代码中的标号 ”.Ll”。间接跳转的写法是&rsquo;*&lsquo;后面跟一个操作数指示符，使用图 3-3中描述的内存操作数格式中的一种。举个例子，指令
jmp *%rax
用寄存器％ rax中的值作为跳转目标，而指令
jmp *(%rax)
以％ rax中的值作为读地址，从内存中读出跳转目标。
指令同义名跳转条件描述
jmp Label 1 直接跳转 jmp *Operand 1 间接跳转
je Label jz ZF 相等／零 jne Label jnz ~ZF 不相等／非零
js Label SF 负数
jns Label <del>SF 非负数 jg Label jnle -(SF -OF) & -ZF 大千（有符号＞） jge Label jnl -(SF -OF) 大于或等千（有符号＞＝） jl Label jnge SF-OF 小千（有符号＜） jle Label jng (SF -OF) I ZF 小于或等于（有符号＜＝）
ja Label jnbe -CF & -ZF 超过（无符号＞） jae Label jnb <del>CF 超过或相等（无符号＞＝） jb Label jnae CF 低千（无符号＜） jbe Label jna CF I ZF 低于或相等（无符号＜＝）
图 3 -15 jump指令。当跳转条件满足时，这些指令会跳转到一条带标号的目的地。有些指令有“同义名“，也就是同一条机器指令的别名
表中所示的其他跳转指令都是有条件的一</del>它们根据条件码的某种组合，或者跳转，或者继续执行代码序列中下一条指令。这些指令的名字和跳转条件与 SET指令的名字和设置条件是相匹配的（参见图 3-14)。同 SET指令一样，一些底层的机器指令有多个名字。条件跳转只能是直接跳转。
3. 6. 4 跳转指令的编码
虽然我们不关心机器代码格式的细节，但是理解跳转指令的目标如何编码，这对第 7 章研究链接非常重要。此外，它也能帮助理解反汇编器的输出。在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是最常用都是 PC相对的 (PC-relative)。也就是，它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为 1、 2或 4个字节。第二种编码方法是给出“绝对“地址，用 4个字节直接指定目标。
汇编器和链接器会选择适当的跳转目的编码。
下面是一个 PC相对寻址的例子，这个函数的汇编代码由编译文件 branch. c产生。它
包含两个跳转：第 2行的］ mp指令前向跳转到更高的地址，而第 7行的 jg指令后向跳转
到较低的地址。
12345678
movq %rdi, %rax
jmp .L2
.L3:
sarq %rax
.L2:
testq %rax, %rax
jg.L3
rep; ret
汇编器产生的 &ldquo;.o"格式的反汇编版本如下：
123456
0: 48 89 f8 mov %rdi,%rax
3: eb 03 jmp 8 &lt;loop+Ox8>
5: 48 di f8 sar %rax
8: 48 85 co test %rax,%rax b: 7f f8 jg 5 &lt;loop+Ox5> d: f3 c3 repz retq
右边反汇编器产生的注释中，第 2行中跳转指令的跳转目标指明为 Ox8,第 5行中跳转指令的跳转目标是 OxS（反汇编器以十六进制格式给出所有的数字）。不过，观察指令的字节编码，会看到第一条跳转指令的目标编码（在第二个字节中）为 Ox03。把它加上 OxS,也就是下一条指令的地址，就得到跳转目标地址 Ox8,也就是第 4行指令的地址。
类似，第二个跳转指令的目标用单字节、补码表示编码为 Oxf8（十进制－8)。将这个数加上 Oxd（十进制 13)，即第 6行指令的地址，我们得到 OxS,即第 3行指令的地址。
这些例子说明，当执行 PC相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。这种惯例可以追溯到早期的实现，当时的处理器会将更新程序计数器作为执行一条指令的第一步。
下面是链接后的程序反汇编版本：
123456
4004d0: 48 89 f8 mov %rdi,%rax 4004d3: eb 03 jmp 4004d8 &lt;loop+Ox8> 4004d5: 48 d1 f8 sar %rax 4004d8: 48 85 co test %rax,%rax 4004db: 7f f8 jg 4004d5 &lt;loop+Ox5> 4004dd: f3 c3 repz retq
这些指令被重定位到不同的地址，但是第 2行和第 5行中跳转目标的编码并没有变。通过使用与 PC相对的跳转目标编码，指令编码很简洁（只需要 2个字节），而且目标代码
可以不做改变就移到内存中不同的位置。
m指令 rep和 repz有什么用
本节开始的汇编代码的笫 8行包含指令组合 rep; ret。它们在反汇编代码中（笫 6行）对应于 repz retq。可以推测出 repz是 rep的同义名，而 retq是 re七的同义名。查阅 Intel和 AMD有关 rep的文档，我们发现它通常用来实现重复的字符串操作 [3,
5 1 ]。在这里用它似乎很不合适。这个问题的答案可以在 AMD给编译器编写者的指导
意见书 [l]中找到。他们建议用 rep后面跟 ret的组合来避免使 re七指令成为条件跳转
指令的目标。如果没有 rep指令，当分支不跳转时， jg指令（汇编代码的笫 7行）会继
续到 ret指令。根据 AMD的说法，当 ret指令通过跳转指令到达时，处理器不能正确
预测 ret指令的目的。这里的 rep指令就是作为一种空操作，因此作为跳转目的插入
它，除了能使代码在 AMD上运行得更快之外，不会改变代码的其他行为。在本书后面
其他代码中再遇到 rep或 repz时，我们可以很放心地无视它们。
区§练习题 3 . 15 在下面这些反汇编二进制代码节选中，有些信息被 X代替了。回答下列关于这些指令的问题。
A.下面 je指令的目标是什么？（在此，你不需要知道任何有关 callq指令的信息。）
4003fa: 74 02 je xxxxxx 4003fc: ff dO callq *%rax
B.下面咋：指令的目标是什么？
40042f: 74 f4 je xxxxxx 400431: 5d pop %rbp
C. ja和 pop指令的地址是多少？
XXXXXX: 77 02 ja 400547 XXXXXX: 5d pop %rbp
D．在下面的代码中，跳转目标的编码是 PC相对的，且是一个 4字节补码数。字节按 . 照从最低位到最高位的顺序列出，反映出 x86-6 4的小端法字节顺序。跳转目标的地址是什么？
4005e8: e9 73 ff ff ff jmpq XXXXXXX 4005ed: 90 nop
跳转指令提供了一种实现条件执行（江）和几种不同循环结构的方式。
3. 6. 5 用条件控制来实现条件分支
将条件表达式和语句从 C语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。（另一种方式在 3. 6. 6节中会看到，有些条件可以用数据的条件转移实现，而不是用控制的条件转移来实现。）例如，图 3-16a给出了一个计算两数之差绝对值的函数的 C代码气这个函数有一个副作用，会增加两个计数器，编码为全局变抵 l七＿cn t和 ge_cnt之一。 GCC产生的汇编代码如图 3-16c所示。把这个机楛代码再转换成 C语言，我们称之为函数 gotodiff_se（图 3-16b)。它使用了 C语言中的 goto语句，这个语句类似于汇编代
码中的无条件跳转。使用 goto语句通常认为是一种不好的编程风格，因为它会使代码非
e 实际上，如果一个减法溢出，这个函数就会返回一个负数值。这里我们主要是为了展示机器代码．而不是实现代码的健壮性。
常难以阅读和调试。本文中使用 goto语句，是为了构造描述汇编代码程序控制流的 C程
序。我们称这样的编程风格为 “ g o to代码”。
在 goto代码中（图 3 -16b)，第 5行中的 goto x_ge_y语句会导致跳转到第 9行中的标
号 x_ge_y处（当 x</del>y时会进行跳转）。从这一点继续执行，完成函数 absdiff—se的 else部分并返回。另一方面，如果测试 x>=y失败，程序会计算 absdiff_s e的江部分指定的步骤并返回。
汇编代码的实现（图 3-16c)首先比较了两个操作数（第 2行），设置条件码。如果比较的结果表明 x大于或者等于 y ,那么它就会跳转到第 8行，增加全局变量 ge_cnt,计算 x -y作为返回值并返回。由此我们可以看到 absdiff_se对应汇编代码的控制流非常类似于
gotodiff_se的 goto代码。
long lt_cnt = O; long gotodiff_se(long x, long y) long ge_cnt = O; 2 { 3 long result; long absdiff_se(long x, long y) 4 if (x >= y) { 5 goto x_ge_y; long result; 6 lt_cnt++;
if (x &lt; y) { 7 result= y -x; lt_cnt++; 8 return result; result= y -x; 9 x_ge_y:
} 10 ge_cnt++;
else { 11 result= x -y; ge_cnt++; 12 return result; result= x -y; 13 }
}
return result;
}
a )原始的C语言代码 b )与之等价的goto版本
long absdiff_se(long x, long y)
X江肚di, y江肚si
absdiff_se: 2 cmpq %rsi, %rdi Compare x:y 3 jge .L2 If>= goto x_ge_y 4 addq $1, lt_cnt(%rip) lt_cnt++
5 movq o!.rsi, %rax 6 subq o!.rdi, %rax result= y -x 7 ret Return
8 .L2: x_ge_y: 9 addq $1, ge_cnt(%rip) ge_cnt++
10 movq %rdi, %rax 11 subq %rsi, %rax result= x -y 12 ret Return
c)产生的汇编代码
图 3-1 6条件语句的编译。 a)C过程 absdiff_se包含一个 if-else语句； b)C过程 gotodiff_se模拟了汇编代码的控制； c）给出了产生的汇编代码
C语言中的江－else语句的通用形式模板如下：
if (test-expr) then-statement else else-statement
这里 test-e工 pr是一个整数表达式，它的取值为 0（解释为“假”)或者为非 0（解释为“真”)。
两个分支语旬中 (then-statement或 else-statemen t )只会执行一个。
对于这种通用形式，汇编实现通常会使用下面这种形式，这里，我们用 C语法来描述控制流：
t = test-expr; if (!t)
goto false; then-statement goto done;
false: else-statement done:
也就是，汇编祥为 then-statement和 else-statement产生各自的代码块。它会插入条件和无条件分支，以保证能执行正确的代码块。</p><p>m用 C代码描述机器代码
图 3-1 6给出了一个示例，用来展示把 C语言控制结构翻译成机器代码。图中包括
示例的 C函数 a和由 GCC生成的汇编代码的注释版本 C,还有一个与汇编代码结构高度
一致的 C语言版本 b。机器代码的 C语言表示有助于你理解其中的关键点，能引导你理
解实际的汇编代码。
让一练习题 3 . 16 已知下列 C代码： void cond(long a, long *p)
{ if (p && a > *p) *P = a; }
GCC会产生下面的汇编代码：
void cond(long a, long <em>p) a in %rdi, p in %rsi
cond: testq %rsi, %rsi je .L1 cmpq %rdi, (%rsi) jge.L1 movq %rdi, (%rsi)
.L1:
rep; ret
A.按照图 3-166中所示的风格，用 C语言写一个 goto版本，执行同样的计算，并模拟汇编代码的控制流。像示例中那样给汇编代码加上注解可能会有所帮助。
B.请说明为什么 C语言代码中只有一个 if语句，而汇编代码包含两个条件分支。
;练习题 3. 17 将 if语句翻译成 goto代码的另一种可行的规则如下：
t = test-expr; if (t)
goto true; else-statement goto done;
true: then-statement done :
A.基于这种规则，重写 absdiff_se的 goto版本。
B.你能想出选用一种规则而不选用另一种规则的理由吗？ ;练习题3 . 18 从如下形式的 C语言代码开始：
long test(long x, long y, long z) { long val= _ ;
if (_ ) { if(_ )
val= else val= } else if (_ ) val= , return val;
}
GCC产生如下的汇编代码：
long test(long x, long y, long z) x in %rdi, y in %rsi , z in %rdx
test: leaq (%rdi,%rsi), %rax addq %rdx, %rax cmpq $-3, %rdi jge .L2 cmpq %rdx, %rsi jge .L3 movq %rdi , %rax imulq %rsi , %rax ret
.L3: movq %rsi, %rax imulq %rdx, %rax ret
.L2: cmpq $2, %rdi jle . L4 movq %rdi , %rax imulq %rdx, %rax
.L4: rep; ret
填写 C代码中缺失的表达式。
3. 6. 6 用条件传送来实现条件分支
实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条
执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代
处理器上，它可能会非常低效。
一种替代的策略是使用数据的条件转移。这种方法计算一个条件操作的两种结果，然
后再根据条件是否满足从中选取一个。只有在一些受限制的情况中，这种策略才可行，但
是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理
器的性能特性。我们将介绍这一策略，以及它在 x86-64上的实现。
图 3-17a给出了一个可以用条件传送编译的示例代码。这个函数计算参数 x和 y差的
绝对值，和前面的例子一样（图 3-16)。不过前面的例子中，分支里有副作用，会修改让＿
cnt或 ge—C吐的值，而这个版本只是简单地计算函数要返回的值。
GCC为该函数产生的汇编代码如图 3 -l 7c所示，它与图 3-17b中所示的 C函数
cmovdiff有相似的形式。研究这个 C版本，我们可以看到它既计算了 y-x，也计算了 x-y,
分别命名为 rval和 eval。然后它再测试 x是否大于等于 y,如果是，就在函数返回 rval
前，将 eval复制到 rval中。图 3-l 7c中的汇编代码有相同的逻辑。关键就在于汇编代码的那
条 cmovge指令（第 7行）实现了 cmovdiff的条件赋值（第 8行）。只有当第 6行的 crnpq指令表明
一个值大于等于另一个值（正如后缀 ge表明的那样）时，才会把数据源寄存器传送到目的。
long absdiff(long x, long y) 1 long cmovdiff(long x, long y)234567890
{ {
long result; long rval = y-x; if (x &lt; y) long eval = x-y; result= y -x; long ntest = x >= y; else I</em> Line below requires result= x -y; single instruction: *I return result; if (ntest) rval = eval; } return rval; 1
}
a)原始的C语言代码 b)使用条件赋值的实现
long absdiff(long x, long y) x in %rdi, y in %rsi
12345678
absdiff: movq %rsi, 1!.rax subq %rdi, %rax r val = y-x movq %rdi, %rdx subq %rsi, 1儿rdx eval = x-y cmpq o!.rsi, %rdi Compare x:y cmovge %rdx, %rax If >=, r val = eval ret Return t val
c)产生的汇编代码
图 3-1 7 使用条件赋值的条件语句的编译。 a)C函数 absdiff包含一个条件表达式；
b)C函数 cmovdiff模拟汇编代码操作； c）给出产生的汇编代码
为了理解为什么基千条件数据传送的代码会比基于条件控制转移的代码（如图 3-16中
那样）性能要好，我们必须了解一些关千现代处理器如何运行的知识。正如我们将在第 4
章和第 5章中看到的，处理器通过使用流水线 (pip e lining)来获得高性能，在流水线中，一
条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存取
指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数
器）。这种方法通过重叠连续指令的步骤来获得高性能，例如，在取一条指令的同时，执
行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行的指令序列，这
样才能保待流水线中充满了待执行的指令。当机器遇到条件跳转（也称为“分支”)时，只
有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的分支预测逻
辑来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠（现代微处理器设计试图达
到 90％以上的成功率），指令流水线中就会充满着指令。另一方面，错误预测一个跳转，
要求处理器丢掉它为该跳转指令后所有指令己做的工作，然后再开始用从正确位置处起始
的指令去填充流水线。正如我们会看到的，这样一个错误预测会招致很严重的惩罚，浪费
大约 15~30个时钟周期，导致程序性能严重下降。
作为一个示例，我们在 Int e l Haswell处理器上运行 absdiff函数，用两种方法来实现条件操作。在一个典型的应用中， x&lt; y的结果非常地不可预测，因此即使是最精密的分支预测硬件也只能有大约 50％的概率猜对。此外，两个代码序列中的计算执行都只需要一个时钟周期。因此，分支预测错误处罚主导着这个函数的性能。对于包含条件跳转的 x86-64代码，我们发现当分支行为模式很容易预测时，每次调用函数需要大约 8个时钟周期；而分支行为模式是随机的时候，每次调用需要大约 17. 50个时钟周期。由此我们可以推断出分支预测错误的处罚是大约 19个时钟周期。这就意味着函数需要的时间范围大约在 8到 27个周期之间，这依赖千分支预测是否正确。</p><p>日曰如何确定分支预测错误的处罚
假设预测错误的概率是 p,如果没有预测错误，执行代码的时间是 ToK .而预测错误的处罚是 TMP。那么，作为 p的一个函数，执行代码的平均时间是 Tavg (P) = (1 -P) TOK+ P (ToK + T MP) = ToK +PT MP。如果已知 ToK和 Tran（当 p=O. 5时的平均时间），要确定 TMP。将参数代入等式，我们有 T,an = Tavg(0. 5) = ToK + 0. 5 T MP,所以有 TMP=2 (Tran -TOK)。因此，对于 ToK =8和 T,an = 17. 5,我们有 TMp=l9。
另一方面，无论测试的数据是什么，编译出来使用条件传送的代码所需的时间都是大约 8个时钟周期。控制流不依赖千数据，这使得处理器更容易保持流水线是满的。让练习题3 . 19 在一个比较旧的处理器模型上运行，当分支行为模式非常可预测时，我
们的代码需要大约 16个时钟周期，而当模式是随机的时候，需要大约 31个时钟周期。
A.预测错误处罚大约是多少？
B.当分支预测错误时，这个函数需要多少个时钟周期？
图 3-18列举了 x86 -64上一些可用的条件传送指令。每条指令都有两个操作数：源寄
存器或者内存地址 S,和目的寄存器 R。与不同的 SETO. 6. 2节）和跳转指令 (3. 6. 3节）一样，这些指令的结果取决千条件码的值。源值可以从内存或者源寄存器中读取，但是只有在指定的条件满足时，才会被复制到目的寄存器中。
源和目的的值可以是 16位、 32位或 64位长。不支持单字节的条件传送。无条件指令的操作数的长度显式地编码在指令名中（例如 movw和 movl)，汇编器可以从目标寄存器的名字推断出条件传送指令的操作数长度，所以对所有的操作数长度，都可以使用同一个的指令名字。
指令同义名传送条件描述
cmove S,R cmovz ZF 相等／零 cmovne S,R cmovnz ~ZF 不相等／非零
cmovs S,R SF 负数 cmovns S, R ~SF 非负数
cmovg S,R cmovnle ~(SF ^ OF) & ~ZF 大千（有符号＞） cmovge S,R cmovnl ~(SF ^ OF) 大千或等千（有符号＞＝） cmovl S,R cmovnge SF -OF 小千（有符号＜） cmovle S,R cmovng (SF -OF) I ZF 小于或等千（有符号＜＝）
cmova S,R cmovnbe ~CF & ~ZF 超过（无符号＞） cmovae S,R cmovnb ~CF 超过或相等（无符号＞＝） cmovb S, R cmovnae CF 低千（无符号＜） cmovbe S,R cmovna CF I ZF 低千或相等（无符号＜＝）
图 3-1 8条件传送指令。当传送条件满足时，指令把源值 S复制到目的 R。有些指令是“同义名＂，即同一条机器指令的不同名字
同条件跳转不同，处理器无需预测测试的结果就可以执行条件传送。处理器只是读源值（可能是从内存中），检查条件码，然后要么更新目的寄存器，要么保持不变。我们会在第 4章中探讨条件传送的实现。
为了理解如何通过条件数据传输来实现条件操作，考虑下面的条件表达式和赋值的通用形式：
v = test-expr ? then-expr : else-expr;
用条件控制转移的标准方法来编译这个表达式会得到如下形式：
if (! test-expr)
goto false; v = then-expr; goto done;
false: v = else-expr; done:
这段代码包含两个代码序列：一个对 then-e工pr求值，另一个对 els仑expr求值。条件
跳转和无条件跳转结合起来使用是为了保证只有一个序列执行。基于条件传送的代码，会对 the介expr和 else-expr都求值，最终值的选择基于对 test-
expr的求值。可以用下面的抽象代码描述：
v = then-expr; ve = else-expr; t = test-expr; if (!t) v = ve;
这个序列中的最后一条语句是用条件传送实现的 ——只有当测试条件 t满足时， vt的值才会被复制到 v中。
不是所有的条件表达式都可以用条件传送来编译。最重要的是，无论测试结果如何，我们给出的抽象代码会对 then-ex pr和 else-ex pr都求值。如果这两个表达式中的任意一个可能产生错误条件或者副作用，就会导致非法的行为。前面的一个例子（图 3-16)就是这种情况。实际上，我们在该例中引入副作用就是为了强制 GCC用条件转移来实现这个函数。
作为说明，考虑下面这个 C函数：
long cread(long *xp) { return (xp? *xp : O);
}
乍一看，这段代码似乎很适合被编译成使用条件传送，当指针为空时将结果设置为 0 ,如下面的汇编代码所示：
long cread(long .xp) Invalid工 mplementation of function cread xp in register %rdi
123456
cread:
movq (%rdi), %rax V = <em>XP testq %rdi, %rdi Test x movl $0, %edx Set ve = 0 cmove %rdx, %rax If x==O, v = ve ret Return v
不过，这个实现是非法的，因为即使当测试为假时， movq指令（第 2行）对 xp的间接引用还是发生了，导致一个间接引用空指针的错误。所以，必须用分支代码来编译这段代码。
使用条件传送也不总是会提高代码的效率。例如，如果 the斤expr或者 else-expr的求值需要大呈的计算，那么当相对应的条件不满足时，这些工作就白费了。编译器必须考虑浪费的计算和由千分支预测错误所造成的性能处罚之间的相对性能。说实话，编译器并不具有足够的信息来做出可靠的决定；例如，它们不知道分支会多好地遵循可预测的模式。我们对 GCC的实验表明，只有当两个表达式都很容易计算时，例如表达式分别都只是一条加法指令，它才会使用条件传送。根据我们的经验，即使许多分支预测错误的开销会超过更复杂的计算， GCC还是会使用条件控制转移。
所以，总的来说，条件数据传送提供了一种用条件控制转移来实现条件操作的替代策略。它们只能用于非常受限制的情况，但是这些情况还是相当常见的，而且与现代处理器的运行方式更契合。亡练习题3 . 20 在下面的 C函数中，我们对 OP操作的定义是不完整的：
#define OP _ I</em> Unknown operator *I
long arith(long x) { return x OP 8;
}
当编译时， GCC会产生如下汇编代码：
long arith (long x) x in %rdi
arith: leaq 7(%rdi), %rax testq %rdi, %rd]. cmovns %rdi, %rax sarq $3, %rax ret
A. O P进行的是什么操作？
B.给代码添加注释，解释它是如何工作的。讫练习题3 . 21 C代码开始的形式如下：
long test(long x, long y) { long val= _ ;
if (){ if(_ ) val= , else val= , } else if(_ ) val= , return val;
}
GCC会产生如下汇编代码：
long test(l ong x, l ong y) x in %rdi, y in %rsi
test: leaq 0 (, %rdi, 8), %rax testq %rsi, %rsi jle .L2
movq %rsi, o/.rax subq %rdi, %rax movq %rdi, %rdx andq %rsi, %rdx cmpq o/.rsi, o/.rdi cmovge o/.rdx, o/,rax ret
:L2 : addq %rsi, %rdi cmpq $-2, %rsi cmovle %rdi, %rax ret
填补 C代码中缺失的表达式。
3.6. 7 循环
C语言提供了多种循环结构，即 do-while、 while和 for。汇编中没有相应的指令
存在，可以用条件测试和跳转组合起来实现循环的效果。 GCC和其他汇编器产生的循环代码主要基于两种基本的循环模式。我们会循序渐进地研究循环的翻译，从 do-whi l e开始，然后再研究具有更复杂实现的循环，并覆盖这两种模式。</p><ol><li>do-while循环
do-while语句的通用形式如下：
do body-statement while (test-expr);
这个循环的效果就是重复执行 bodystatement,对 test-expr求值，如果求值的结果为非
零，就继续循环。可以看到， bodystatement至少会执行一次。
这种通用形式可以被翻译成如下所示的条件和 goto语句：
loop: body-statement t = test-expr;
if (t)
goto loop;
也就是说，每次循环，程序会执行循环体里的语句，然后执行测试表达式。如果测试为
真，就回去再执行一次循环。看一个示例，图 3 -19a给出了一个函数的实现，用 do-while循环来计算函数参数的
阶乘，写作 n!。这个函数只计算 n > 0时 n的阶乘的值。
亡练习题 3. 22
A.用一个 32位 int表示 n!，最大的 n的值是多少？
B.如果用一个 64位 long表示，最大的 n的值是多少？</li></ol><p>图 3 -19b所示的 goto代码展示了如何把循环变成低级的测试和条件跳转的组合。 result初始化之后，程序开始循环。首先执行循环体，包括更新变量 result和 n。然后测试 11>1,如果是真，跳转到循环开始处。图 3-19c所示的汇编代码就是 goto代码的原型。条件跳转指
令 jg（第 7行）是实现循环的关键指令，它决定了是需要继续重复还是退出循环。
long fact_do(long n) long fact_do_goto(long n)
{ {
long result= 1; long result = 1;
do { loop: result*= n; result*= n; n = n-1; n = n一 1;
} while (n > 1); if (n > 1) return result; goto loop; } return result; }
a) C代码 b )等价的go七o版本
long fact_do(long n)
n in %rdi 1 fact_do: 2 movl $1, %eax Set result=. 1 3 .L2: l oop: 4 imulq %rdi, %rax Compute r esult&rsquo; *= n 5 subq $1, %rdi Decrement n 6 cmpq $1, %rdi Compare n:1 7 jg .L2 If>, goto l oop 8 rep; ret Return
c)对应的汇编代码
佟I 3-19 阶乘程序的 do-while版本的代码。条件跳转会使得程序循环
逆向工程像图 3-19c中那样的汇编代码，需要确定哪个寄存器对应的是哪个程序值。本
例中，这个对应关系很容易确定：我们知道 n在寄存器％ rdi中传递给函数。可以看到寄存器％rax初始化为 1（第 2行）。（注意，虽然指令的目的寄存器是％eax,它实际上还会把％rax的高 4字节设置为 0。)还可以看到这个寄存器还会在第 4行被乘法改变值。此外，％rax用来返回函数值，所以通常会用来存放需要返回的程序值。因此我们断定％rax对应程序值 resul t。
让；练习题 3 . 23 巳知 C代码如下：
long dw_loop(long x) { long y = x.x; l ong <em>P = &amp;x; l ong n = 2</em>x; do {
X += y; (*p) ++;
n&ndash;; } while (n > O) ; return x;
}
GCC产生的汇编代码如下：
long dw_loop(long x) x initially in .rdi dw_loop:
2 movq %rdi , %r ax 3 movq %r di, %r cx 4 imulq %rdi,壮ex 5 leaq (%rdi ,%rdi), %rdx 6 .L2 : 7 leaq 1(%rcx,%rax),．儿rax
. 8 subq $1, %rdx
9 testq 缸dx, %rdx 10 jg .L2 11 rep; ret
A.哪些寄存器用来存放程序值 x、 y和 n?
B.编译器如何消除对指针变量 p和表达式 (*p)+＋隐含的指针间接引用的需求？</p><p>C.对汇编代码添加一些汪释，描述程序的操作，类似于图 3 -19c中所示的那样。
m逆向工程循环理解产生的汇编代码与原始源代码之间的关系，关键是找到程序值和寄存器之间的
映射关系。对于图 3-19的循环来说，这个任务非常简单，但是对于更复杂的程序来说，
就可能是更具挑战性的任务。 C语言编译器常常会重组计算，因此有些 C代码中的变量
在机器代码中没有对应的值；而有时，机器代码中又会引入源代码中不存在的新值。此
外，编译器还常常试图将多个程序值映射到一个寄存器上，来最小化寄存器的使用率。我们描述 fact_do的过程对于逆向工程循环来说，是一个通用的策略。看看在循
环之前如何初始化寄存器，在循环中如何更新和测试寄存器，以及在循环之后又如何使
用寄存器。这些步骤中的每一步都提供了一个线索，组合起来就可以解开谜团。做好准备，你会看到令人惊奇的变换，其中有些情况很明显是编译器能够优化代码，而有些情
况很难解释编译器为什么要选用那些奇怪的策略。根据我们的经验， GCC常常做的一些变换，非但不能带来性能好处，反而甚至可能降低代码性能。
2. while循环
while语句的通用形式如下：
while (test-expr) body-statement
与 do-while的不同之处在于，在第一次执行 body-statement之前，它会对 test-expr求值，循环有可能就中止了。有很多种方法将 while循环翻译成机器代码， GCC在代码生成中使用其中的两种方法。这两种方法使用同样的循环结构，与 do-wh工 l e一样，不过它
们实现初始测试的方法不同。第一种翻译方法，我们称之为跳转到中间 (jump to middle)，它执行一个无条件跳转
跳到循环结尾处的测试，以此来执行初始的测试。可以用以下模板来表达这种方法，这个
模板把通用的 while循环格式翻译到 go七 o代码：
goto test; loop: body-statement
test: t = test-expr; if (t)
goto loop;
作为一个示例，图 3-20a给出了使用 while循环的阶乘函数的实现。这个函数能够正确地计算 O! =l。它旁边的函数 fact_while_jm_goto（图 3-206)是 GCC带优化命令行选
项－Og时产生的汇编代码的 C语言翻译。比较 fact_while（图 3-206)和 fact_do(图 3-196)
的代码，可以看到它们非常相似，区别仅在于循环前的 goto test语句使得程序在修改
result或 n的值之前，先执行对 n的测试。图的最下面（图 3-20c)给出的是实际产生的汇
编代码。 i练习题3 . 24 对于如下 C代码：
long loop_while(long a, long b)
{
long result= _ ;
while (_ ) { result= , a =
, }
return result;
}
以命令行选项－Og运行 GCC产生如下代码：
long loop卫加 le(long a, long b) a in %rdi, bin %rsi loop_while:
2 movl $1, ..eax 3 jmp.L2
.L3: 5
4
leaq (%rdi,%rs立， %rdx 6
imulq o!.rdx, %rax 7
addq $1, %rdi
.L2: 9
8
cmpq %rsi, %rdi 10 jl .L3 11 rep; ret
可以看到编译器使用了跳转到中间的翻译方法，在第 3行用 jmp跳转到以标号
.12开始的测试。填写 C代码中缺失的部分。
long fact_while(long n) long fact_while_jm_goto(long n)
{ {
long result = 1 ; long result= 1;
while (n > 1) { goto test ; result*= n; loop: n = n-1; result*= n;
} n = n-1; return result; test: } if (n > 1) goto l oop; return result;
}
a) C代码 b )等价的goto版本
long fact_while(long n) n in %rdi
fact_while: movl $1, %eax Set result= 1 jmp.LS Goto test
.L6: loop: imulq %rdi, %rax Compute result <em>= n subq $1, %rdi Decrement n
.LS: test : cmpq $1, %rdi Compare n:1 jg .L6 If>, goto loop rep; ret Return
c)对应的汇编代码
图 3-20使用跳转到中间翻译方法的阶乘算法的 wh ile版本的 C代码和汇编代码。
C函数 fact_whil e_jm_goto说明了汇编代码版本的操作
第二种翻译方法，我们称之为 gua rd e d-do,首先用条件分支，如果初始条件不成立就跳过循环，把代码变换为 do-wh i l e循环。当使用较高优化等级编译时，例如使用命令行选项－01, GCC会采用这种策略。可以用如下模板来表达这种方法，把通用的 whi le循环
格式翻译成 do-while循环：
t = test-expr; if (!t) goto done;
do body-statement while (test-expr) ;
done:
相应地，还可以把它翻译成 goto代码如下：
t = test-expr; if (!t) goto done;
loop: body-statement t = test-expr; if (t)
goto loop; done:
利用这种实现策略，编译器常常可以优化初始的测试，例如认为测试条件总是满足。
再来看个例子，图 3 -21给出了图 3-20所示阶乘函数同样的 C代码，不过给出的是 GCC使用命令行选项－01时的编译。图 3 -2 lc给出实际生成的汇编代码，图 3 -21 b是这个汇编代码更易读的 C语言表示。根据 goto代码，可以看到如果对于 n的初始值有 n &lt; l,那么将跳过该循环。该循环本身的基本结构与该函数 do -while版本产生的结构（图 3-1 9)一样。不过，一个有趣的特性是，循环测试（汇编代码的第 9行）从原始 C代码的 n > l变成了 n=f::-1。编译器知道只有当 n> l时才会进入循环，所以将 n减 1意味着 n> 1或者 n=
1。因此，测试 n =f::-l就等价于测试 n~l。
long fact_while(long n) long fact_while_gd_goto(long n)
{ {
long result = 1; long result= 1;
while (n > 1) { if (n &lt;= 1) result</em>= n; goto done; n = n-1; loop:
} result*= n; return result; n = n-1; } if (n != 1) goto loop; done: return result;
}
a) C代码 b )等价的goto版本
图 3-21使用 guarded-do翻译方法的阶乘算法的 while版本的 C代码和汇编代码。函数 fact—while_gd_goto说明了汇编代码版本的操作
long fact＿甘妇 le(long n)
n in %rd]_<br>fact_while:<br>2 cmpq $1, %rdi Compare n : 1<br>3 jle .L7 If &lt;=, goto done<br>4 rnovl $1, %eax Set result= 1<br>5 .L6: loop :<br>6 imulq %rdi, %rax Compute result *= n<br>7 subq $1, %rdi Decrement n<br>8 cmpq $1, %rdi Compare n:1<br>9 jne .L6 If !=, goto l oop<br>10 rep; ret Return<br>11 . L7 : done:<br>12 movl $1, %eax Compute result = 1<br>13 ret Return</p><p>C)对应的汇编代码
图 3-21（续）
讫练习题 3 .25对于如下 C代码：
long loop_wh立e2(long a, long b)
{
long result= -; while(_ ) { result= , b = , }
return result;
}
.
以命令行选项－0 1运行 GCC ,产生如下代码：
a in %rdi, bin %rsi
loop_&lsquo;While2: 2 testq o/江 si, %rsi 3 jle .L8 4 movq %rsi, %rax
5 .L7 : 6 imulq %rdi,．儿rax 7 subq 。儿rdi, 1儿rs]. 8 testq 。1/.rsi, %rsi
9 jg .L7 10 rep; ret
11 .L8 : 12 movq %rsi, %rax 13 ret
可以看到编译器使用了 guarded-do的翻译方法，在第 3行使用了 ]le指令使得当初始岚试不成立时，忽略循环代码。填写缺失的 C代码。注意汇编语言中的控制结构不一定与根据翻译规则直接翻译 C代码得到的完全一致。特别地，它有两个不同的 r过指令（第 1 0
行和第 13行）。不过，你可以根据等价的汇编代码行为填写 C代码中缺失的部分。
让练习题 3 . 26函数 fun_a有如下整体结构：
l ong fun_a(unsi gned long x) { long val= O; while (. ..) {
}
return
}
GCCC编译器产生如下汇编代码：
long fun_a (unsigned l ong x)
x in .rdi 1 fun_a: 2 movl $0, %eax 3 jmp .L5 4 .L6: 5 xorq %rdi , %rax 6 shrq %rdi Sh.lft right by 1
7 .L5 : 8 testq %rdi, %rdi 9 jne .L6
10 andl $1, %eax 11 ret
逆向工程这段代码的操作，然后宪成下面作业：
A.确定这段代码使用的循环翻译方法。
B.根据汇编代码版本填写 C代码中缺失的部分。
C.用自然语言描述这个函数是计算什么的。
3. for循环
for循环的通用形式如下：
for (init-expr; test-expr; up date-expr) body-statement
C语言标准说明（有一个例外，练习题 3 . 29中有特别说明），这样一个循环的行为与下面
这段使用 while循环的代码的行为一样：
init-expr;
while (test-expr) { body-statement up date-expr;
}
程序首先对初始表达式 init-e工 pr求值，然后进入循环；在循环中它先对测试条件 test飞xpr求值，如果测试结果为“假”就会退出，否则执行循环体 body-statement;最后对
更新表达式 upda t~e工pr求值。
GCC为 fo r循环产生的代码是 while循环的两种翻译之一，这取决于优化的等级。也就是，跳转到中间策略会得到如下 goto代码：
init-expr; goto test;
笫 3章程序的机器级表示 157
loop: body-statement update-expr;
test: t = test-expr;
if (t)
goto loop;
而 guarded-do策略得到：
init-expr; t = test-expr; if (!t)
goto done;
loop: body-statement update-expr; t = test-expr;
if (t)
goto loop; done:
作为一个示例，考虑用 for循环写的阶乘函数：
long fact_for(long n)
long i; long result= 1;
for (i = 2; i &lt;= llj i++) result*= i; return result;
}
如上述代码所示，用 for循环编写阶乘函数最自然的方式就是将从 2一直到 n的因子
乘起来，因此，这个函数与我们使用 while或者 do-while循环的代码很不一样。
这段代码中的 for循环的不同组成部分如下：
init-expr i = 2 test-expr i &lt;= n update-expr i ++ body-statement result <em>= i;
用这些部分替换前面给出的模板中相应的位置，就把 for循环转换成了 while循环，
得到下面的代码：
long fact_for_while(long n)
{
long i = 2; long result= 1; while (i &lt;= n) {
result</em>= i; i++;
}
return result;
}
对 while循环进行跳转到中间变换， 得到如下 goto代码：
long fact_for_jm_goto(long n)
{
long i = 2; long result= 1; goto test;
loop: result*= i; i++;
test: if (i &lt;= n) goto loop; return result;
}
确实，仔细查看使用命令行选项 -og的 GCC产生的汇编代码，会发现它非常接近于以下模板：
long fact_for (long n) n ].n %rd]. fact_for:
movl $1, i!.eax Set result= 1 movl $2, %edx Seti = 2 jmp .L8 Goto test
. L9 : l oop : imulq %rdx, %rax Compute r esult <em>= ].
addq $1, %rdx Increment i
.L8 : test : cmpq %rdi, %rdx Compare]. .. n jle .L9 If&lt;=, goto l oop
rep; ret Return
;练习题 3. 27 先把 fac七＿ for转换成 while循环， 再进行 guarded-do变换，写出 fact_for的 goto代码。综上所述， C语言中三种形式的所有的循环 do-while、while和 for——都可以
用一种简单的策略来翻译，产生包含一个或多个条件分支的代码。控制的条件转移提供了 将循环翻译成机器代码的基本机制。江练习题3 . 28 函数 fun_b有如下整体结构：
long fun_b(unsigned long x) { long val= O; long i; for (&mldr; &mldr;) {
}
return val;
}
GCCC编译器产生如下汇编代码：
l ong t皿＿ b（四 S.1gned long x) x.1n %rd.1
12
fun_b: movl $64, %edx
3
movl $0, %eax
4
.L10:
5
movq 。%rdi, %rcx
6 andl $1, %ecx
7 addq %rax, %rax
8 orq %rcx, %rax
9 shrq %rdi Shift right by 1
10 subq $1, %rdx
11 jne . L10
12 rep; ret
逆向工程这段代码的操作，然后完成下面的工作：
A.根据汇编代码版本填写 C代码中缺失的部分。 B.解释循环前为什么没有初始测试也没有初始跳转到循环内部的测试部分。 C.用自然语言描述这个函数是计算什么的。
讫：练习题 3 . 29 在 C语言中执行 continue语句会导致程序跳到当前循环迭代的结尾。当处理 continue语句时，将 for循环翻译成 whi le循环的描述规则需要一些改进。例如，考虑下面的代码：
I</em> Example of for loop containing a continue statement <em>I
I</em> Sum even numbers between O and 9 *I
long sum= O;
long i;
for (i = O; i &lt; 10; i++) {
if (i & 1)
continue;
sum+= i;
A.如果我们简单地直接应用将 for循环翻译到 while循环的规则，会得到什么呢？产生的代码会有什么错误呢？
B.如何用 goto语句来替代 continue语句，保证 while循环的行为同 for循环的行为完全一样？</p><ol start=3><li><ol start=6><li>8 switch语句
switch（开关）语句可以根据一个整数索引值进行多重分支 (multi way branchin g)。在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了 C代码的可读性，而且通过使用跳转表 (jump t ab le)这种数据结构使得实现更加高效。跳转表是一个数组，表项 t是一个代码段的地址，这个代码段实现当开关索引值等千 1时程序应该采取的动作。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。和使用一组很长的江－else语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。 GCC根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多（例如 4个以上），并且值的范围跨度比较小时，就会使用跳转表。
图 3-22a是一个 C语言 switch语句的示例。这个例子有些非常有意思的特征，包括情况标号(case label)跨过一个不连续的区域（对于情况 101和 105没有标号），有些情况有多个标号（情况 104和 106)，而有些情况则会落入其他情况之中（情况 102)，因为对应该情况的代码段没有以 break语句结尾。
图 3-23是编译 s witch_eg时产生的汇编代码。这段代码的行为用 C语言来描述就是图 3-226中的过程 switch_eg_impl。这段代码使用了 GCC提供的对跳转表的支持，这是
对 C语言的扩展。数组扛包含 7个表项，每个都是一个代码块的地址。这些位置由代码
中的标号定义，在］ t的表项中由代码指针指明，由标号加上飞矿前缀组成。（回想运算符
＆创建一个指向数据值的指针。在做这个扩展时， GCC的作者们创造了一个新的运算符
&&&rsquo; 这个运算符创建一个指向代码位置的指针。）建议你研究一下 C语言过程 switch_eg_
impl, 以及它与汇编代码版本之间的关系。
void switch_eg_impl(long x, long n,
234567890123456789012345678901234
long <em>dest)
{
I</em> Table of code pointers *I static void <em>jt[7] = { void switch_eg(long x, long n, &&amp;loc_A, &&amp;loc_def, &&amp;loc_B, long <em>dest) &&amp;loc_C, &&amp;loc_D, &&amp;loc_def,
{
&&amp;loc_D
long val= x; }; 1111111111222222222233333
unsigned long index= n -100; switch (n) { long val;
case 100: if (index> 6) val</em>= 13; goto loc_def; break; /. Multiway branch ./
goto .jt[index];
case 102: val+"&lsquo;10; loc_A: I</em> Case 100 <em>I I</em> Fall through <em>I val= x * 13;
goto done;
case 103: loc_B: I</em> Case 102 <em>I val += 11; X = X + 10; break; I</em> Fall through <em>/
loc_C: / * Case 103 <em>I
case 104: val= x + 11; case 106: goto done; val</em>= val; loc_D: I</em> Cases 104, 106 <em>I break; val= x * x; goto done;
default: loc_def: I</em> Default case *I val= O; val= O; } done: *dest = val; .dest = val;
} }
a) swi七 ch语句 b)翻译到扩展的C语言
图 3 -22 switch语句示例以及翻译到扩展的 C语言。该翻译给出了跳转表 jt的结构，
以及如何访问它。作为对 C语言的扩展， GCC支持这样的表
原始的C代码有针对值 100、 102-104和 106的情况，但是开关变量 n可以是任意整数。编
译器首先将 n减去 1 00,把取值范围移到 0和 6之间，创建一个新的程序变量，在我们的 C版
本中称为 index。补码表示的负数会映射成无符号表示的大正数，利用这一事实，将 index看
作无符号值，从而进一步简化了分支的可能性。因此可以通过测试 index是否大于 6来判定
index是否在 0~6的范围之外。在 C和汇编代码中，根据 index的值，有五个不同的跳转位
八
置： loc A（在汇编代码中标识为． L3), loc B(.15), loc c(.16), loc D( . 17)和 loc def (.18)，最后一个是默认的目的地址。每个标号都标识一个实现某个情况分支的代码块。在 C和汇编代码中，程序都是将 index和 6做比较，如果大于 6就跳转到默认的代码处。
void switch_eg(long x, long n, long *dest)<br>x in %rd.l , n.ln %rsi, dest.ln %rdx<br>1 S廿 itch_eg:<br>2 subq $100, %rsi Compute index = n-100<br>3 cmpq $6, %rsi Compare index: 6<br>4 ja . L8 If>, goto loc_def<br>5 jmp *.L4(,%rsi,8) Goto <em>jt[index]<br>6 .L3: loc_A :<br>7 leaq (°!.rdi ,%rdi, 2) , %rax 3</em>X<br>8 leaq (%rdi ,%rax,4), %rdi val = 13.x<br>9 jmp . L2 Goto done<br>10 . L5 : loc_B:<br>11 addq $10, %rdi X = X + 10<br>12 .L6: loc_C :<br>13 addq $11, %rdi val = x + 11<br>14 j mp . L2 Goto done<br>15 . L7 : loc_D:<br>16 i mulq %rdi , %rdi val = x * x<br>17 j mp . L2 Goto done<br>18 . L8 : loc_def:<br>19 movl $0, %edi val = 0<br>20 .L2 : done:<br>21 movq o!.rdi, (%r dx ) .dest = val<br>22 ret Return</li></ol></li></ol><p>图 3-23图 3-22中 sw i tc h语句示例的汇编代码
执行 s w i t ch语句的关键步骤是通过跳转表来访问代码位置。在 C代码中是第 16行，一条 ·goto语句引用了跳转表 jt。 GCC支持计算 goto(comput e d goto)，是对 C语言的扩展。在我们的汇编代码版本中，类似的操作是在第 5行， jmp指令的操作数有前缀＇＊＇，表明这是一个间接跳转，操作数指定一个内存位置，索引由寄存器％ rsi给出，这个寄存
器保存着 index的值。（我们会在 3. 8节中看到如何将数组引用翻译成机器代码。） C代码将跳转表声明为一个有 7个元素的数组，每个元素都是一个指向代码位置的指针。这些元素跨越 index的值 0<del>6,对应于 n的值 100</del> 1 06。可以观察到，跳转表对重
复情况的处理就是简单地对表项 4和 6用同样的代码标号 ( loc_D)，而对于缺失的情况的处理就是对表项 1和 5使用默认情况的标号 (loc_def)。
在汇编代码中，跳转表用以下声明表示，我们添加了一些注释：
.se ction .r odata
2 . align 8 Align address to multiple of 8 3 .L4:
4 . quad .L3 Case 100: loc_A
5 . quad .L8 Case 101: loc_def 6 .quad .L5 Case 102: loc_B 7 .quad .L6 Case 103: loc_C 8 .quad .L7 Case 104: loc_D
9 .quad . L8 Case 105: loc_def
10 . quad .L7 Case 106: loc_D</p><p>这些声明表明，在叫做 “.rodata&rdquo;（只读数据， Read-Only Data )的目标代码文件的段中，应该有一组 7个“四”字 (8个字节），每个字的值都是与指定的汇编代码标号（例如． L3)相关联的指令地址。标号． L4标记出这个分配地址的起始。与这个标号相对应的地址会作为间接跳转（第 5行）的基地址。
不同的代码块 (C标号 l oc_A到 l oc—D和 l oc—def)实现了 switch语句的不同分支。它们中的大多数只是简单地计算了 val的值，然后跳转到函数的结尾。类似地，汇编代码块计算了寄存器％r中的值，并且跳转到函数结尾处由标号． L2指示的位置，只有情况标号 102的代码不是这种模式的，正好说明在原始 C代码中情况 10 2会落到情况 103中。具体处理如下：以标号． LS起始的汇编代码块中，在块结尾处没有 jmp指令，这样代码就会继续执行下一个块。类似地， C版本 switch_eg_impl中以标号 loc_B起始的块的结尾处也没有 goto语句。
检查所有这些代码需要很仔细的研究，但是关键是领会使用跳转表是一种非常有效的实现多重分支的方法。在我们的例子中，程序可以只用一次跳转表引用就分支到 5个不同的位置。甚至当 switch语句有上百种情况的时候，也可以只用一次跳转表访问去处理。沁反练习题 3 . 30 下面的 C函数省略了 SW让 ch语句的主体。在 C代码中，情况标号是不
连续的，而有些情况有多个标号。
void switch2(long x, long *dest) { long val= O; switch (x) {
Body ofswitch statement omitted
*dest = val;
在编译该函数时， GCC为程序的初始部分生成了以下汇编代码，变量 x在寄存器％rdi中：
void switch2(long x, long *dest) x in %rdi
12345
switch2: addq $1, o!.rdi cmpq $8,．儿rdi ja .L2 jmp *. L4(, %rdi, 8)
为跳转表生成以下代码：
1234567890
.L4: .quad 956727825LLLLLLLLL &mldr;<br>.quad<br>.quad<br>.quad .<br>.quad .<br>.quad ..<br>.quad<br>1 .quad .quad ..</p><p>根据上述信息回答下列问题：
A. switch语句内情况标号的值分别是多少？
B . C代码中哪些情况有多个标号？</p><p>讫§练习题 3 . 31 对于一个通用结构的 C函数 switche r:
void switcher(long a, long b, long c, long <em>dest)
{
long val; switch(a) { casa _ : I</em> Case A <em>I
C = I</em> Fall through <em>I
case I</em> Case B <em>I val= break;
case I</em> Case C <em>I
case I</em> Case D <em>I val = break;
case I</em> Case E *I val= break;
default: val=
}
*dest = val;
}
GCC产生如图 3-2 4所示的汇编代码和跳转表。
void switcher(long a, long b, long c, long *dest) a in %rdi, b in %rsi, c in %rdx, dest in %rcx switcher:
2345678901234567890
cmpq $7, %rdi ja .L2 jmp * .L4(,%rdi,8) .section .rodata
.L7: xorq $15, %rsi rnovq %rsi, %rdx
.L3:
111111111
leaq 112(%rdx), %rdi jmp . L6
.L5 : leaq (o/.rdx,%rsi), o/.rdi salq $2, %rdi jmp .L6
.L2 : movq %rsi, %rdi .L6 : 1 movq %rdi, (%rcx)2
ret
1 2
3 4 5 6
7 8 9
.L4: .quad .quad .quad .quad .quad .quad .quad .quad
.L3 .L2 .L5 .L2 .L6 .L7 .L2 .L5
a )代码b )跳转表图 3 -2 4练习题 3. 3 1的汇编代码和跳转表
填写 C代码中缺失的部分。除了情况标号 C和 D的顺序之外，将不同情况填入这个模板的方式是唯一的。
3. 7 过程过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。设计良好的软件用过程作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值，过程会对程序状态产生什么样的影响。不同编程语言中，过程的形式多样：函数(function)、方法 (method)、子例程 (subroutine)、处理函数 (handler)等等，但是它们有一些共有的特性。要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程 P调用过程 Q, Q执行后返回到 P。这些动作包括下面一个或多个机制：传递控制。在进入过程 Q的时候，程序计数器必须被设置为 Q的代码的起始地址，然后在返回时，要把程序计数器设置为 P中调用 Q后面那条指令的地址。传递数据。 P必须能够向 Q提供一个或多个参数， Q必须能够向 P返回一个值。分配和释放内存。在开始时， Q可能需要为局部变量分配空间，而在返回前，义必须释放这些存储空间。 x86-64的过程实现包括一组特殊的指令和一些对机器资源（例如寄存器和程序内存）使用的约定规则。人们花了大量的力气来尽扯减少过程调用的开销。所以，它遵循了被认为是最低要求策略的方法，只实现上述机制中每个过程所必需的那些。接下来，我们一步步地构建起不同的机制，先描述控制，再描述数据传递，最后是内存管理。
3. 7. 1 运行时栈 栈底C语言过程调用机制的一个关键特性（大多数&ndash;
其他语言也是如此）在千使用了栈数据结构提供的
_
后进先出的内存管理原则。在过程 P调用过程 Q. -
的例子中，可以看到当 Q在执行时， p以及所有. 较早的帧在向上追溯到 P的询用链中的过程，都是暂时被^ &lsquo;, 挂起的。当 Q运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。.
_
另一方面，当 Q返回时，任何它所分配的局部存地址_ 储空间都可以被释放。因此，程序可以用栈来管增大参数n 调用函数
理它的过程所需要的存储空间，栈和程序寄存器 I . .. P的帧
存放着传递控制和数据、分配内存所需要的信息。参数7
当 P调用 Q时，控制和数据信息添加到栈尾。当 P返回地址返回时，这些信息会释放掉。
如 3.4. 4节中讲过的， x86 -64的栈向低地被保存的寄存器址方向增长，而栈指针％ rsp指向栈顶元素。可正在执行的以用 pushq和 popq指令将数据存入栈中或是局部变量函数Q的帧从栈中取出。将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。类栈指针 参数构造区似地，可以通过增加栈指针来释放空间。%rsp 栈＂顶”
当 x86-6 4过程需要的存储空间超出寄存器图 3-25通用的栈帧结构（栈用来传递参数、存能够存放的大小时，就会在栈上分配空间。这储返回信息、保存寄存器，以及局部个部分称为过程的栈帧 (stac k fram)。图 3 -25 存储。省略了不必要的部分）
给出了运行时栈的通用结构，包括把它划分为栈帧。当前正在执行的过程的帧总是在栈顶。当过程 P调用过程 Q时，会把返回地址压入栈中，指明当 Q返回时，要从 P程序的哪个位置继续执行。我们把这个返回地址当做 P的栈帧的一部分，因为它存放的是与 P相关的状态。 Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。大多数过程的栈帧都是定长的，在过程的开始就分配好了。但是有些过程需要变长的帧，这个问题会在 3 . 10. 5 节中讨论。通过寄存器，过程 P可以传递最多 6个整数值（也就是指针和整数），但是如果 Q需要更多的参数， P可以在调用 Q之前在自己的栈帧里存储好这些参数。
为了提高空间和时间效率， x86 -64过程只分配自己所需要的栈帧部分。例如，许多过程有 6个或者更少的参数，那么所有的参数都可以通过寄存器传递。因此，图 3-25中画出的某些栈帧部分可以省略。实际上，许多函数甚至根本不需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数（有时称之为叶子过程，此时把过程调用看做树结构）时，就可以这样处理。例如，到目前为止我们仔细审视过的所有函数都不需要栈帧。
3. 7. 2 转移控制将控制从函数 P转移到函数 Q只需要简单地把程序计数器 (PC )设置为 Q的代码的起始位置。不过，当稍后从 Q返回的时候，处理器必须记录好它需要继续 P的执行的代码位置。在 x86-64机器中，这个信息是用指令 call Q调用过程 Q来记录的。该指令会把地址 A压入栈中，并将 PC设置为 Q的起始地址。压入的地址 A被称为返回地址，是紧跟在 call指令后面的那条指令的地址。对应的指令 ret会从栈中弹出地址 A,并把 PC设置为 A。下表给出的是 call和 ret指令的一般形式：
指令描述
call Label 过程调用 call ·Operand 过程调用 ret 从过程调用中返回
（这些指令在程序 OBJDUMP产生的反汇编输出中被称为 callq和 retq。添加的后缀｀ q&rsquo;只是为了强调这些是 x86-64版本的调用和返回，而不是 IA32的。在 x86-64汇编代码中，这两种版本可以互换。）
call指令有一个目标，即指明被调用过程起始的指令地址。同跳转一样，洞用可以是直接的，也可以是间接的。在汇编代码中，直接调用的目标是一个标号，而间接调用的目标是＊后面跟一个操作数指示符，使用的是图 3-3中描述的格式之一。
图 3-26说明了 3. 2. 2节中介绍的 multstore和 main函数的 call和 ret指令的执行情况。下面是这两个函数的反汇编代码的节选：
Beginning of function multstore
1 0000000000400540 :<br>2 400540: 53 push %rbx<br>3 400541: 48 89 d3 mov %rdx,%rbx</p><p>Return from function multstore 40054d: c3 retq
Call to multstore from ma.ln 56 400563: e8 d8 ff ff ff callq 400540 400568: 48 8b 54 24 08 mov Ox8(%rsp),%rdx
在这段代码中我们可以看到，在 main函数中，地址为 Ox400563的 call指令调用函数 multstore。此时的状态如图 3-26a所示，指明了栈指针％rsp和程序计数器％江p的值。
call的效果是将返回地址 Ox400568压入栈中，并跳到函数 multstore的第一条指令，地址为 O x0400540（图 3-266)。函数 mult s tore继续执行，直到遇到地址 Ox40 0 54d处的 ret指令。这条指令从栈中弹出值 Ox400568 ,然后跳转到这个地址，就在 ca l l指令之
后，继续 main函数的执行。
气 °x400568
`0x7fff盓言:: I~：：山7/言言胃 %
rspl Ox7fffffffe840
Ox400568
a)执行call b) call执行之后c) ret执行之后
图 3-26 call和 ret函数的说明。 call指令将控制转移到一个函数的起始，而 ret指令返回到这次调用后面的那条指令
再来看一个更详细说明在过程间传递控制的例子，图 3-27a给出了两个函数 top和 leaf的反汇编代码，以及 main函数中调用 t op处的代码。每条指令都以标号标出： Ll ~ L2 (leaf中）， Tl<del>T4(main中）和 Ml</del>M2(main中）。该图的 b部分给出了这段代码执
Disassembly of leaf(long y) y.ln %rd.l
0000000000400540 : 2 400540: 48 8d 47 02 lea Ox2 (%rdi),%rax L1: y+2 3 400544: c3 retq L2: Return
4 · · 0000000000400545 : Disassembly of top(long x) X J.n %rdJ.
5678400545: 48 83 ef 05 sub $0x5,。儿rdi Tl: x-5 400549: e8 f2 ff ff ff callq 400540 T2: Call lea±(x-5) 40054e: 48 01 cO add %rax, %rax T3: Double result 400551: c3 retq T4: Return
Call to top from function main 90 40055b: e8 e5 ff ff ff callq 400545 Ml: Call top(100)1 400560: 48 89 c2 mov %rax, %rdx M2: Resume
a )说明过程调用和返回的反汇编代码
图 3-27包含过程调用和返回的程序的执行细节。使用栈来存储返回地址使得能够返回到过程中正确的位置
指令状态值（指令执行前）标号 PC 指令 %rdi 沦 rax %rsp *%rsp 描述Ml Ox40055b callq 100 Ox7fffffffe820 调用 top (10 0)
Tl Ox400555 sub 100 Ox7fffffffe818 Ox400560 进入top
T2 Ox400559 callq 95 Ox7 fffff ffe8 l 8 Ox400560 调用 leaf ( 95)
LI Ox400540 lea 95 Ox7fffffffe810 Ox40054e 进入leaf
L2 Ox400544 retq 97 Ox7fffffffe810 Ox40054e 从 leaf返回 97
T3 Ox40054e add 97 Ox7 fffffff eB18 Ox400560 继续t op
T4 Ox400551 retq 194 Ox7fffffffe818 Ox400560 从top返回 194
M2 Ox400560 mov 194 Ox7fffffffe820 继续main
b )示例代码的执行过程
图 3-27（续）
行的详细过程， main调用 top ( 100 )，然后 top调用 leaf(95)。函数 leaf向 top返回 97,然后 top向 main返回 194。前面三列描述了被执行的指令，包括指令标号、地址和指令类型。后面四列给出了在该指令执行前程序的状态，包括寄存器％rdi、%rax和％rsp的内容，以及位于栈顶的值。仔细研究这张表的内容，它们说明了运行时栈在管理支持过程调用和返回所需的存储空间中的重要作用。
leaf的指令 Ll将％ rax设置为 97,也就是要返回的值。然后指令 L2返回，它从栈中弹出 Ox400 0 54e。通过将 PC设置为这个弹出的值，控制转移回 t op的 T3指令。程序成功完成对 leaf的调用，返回到 top。
指令 T3将％ rax设置为 194,也就是要从 top返回的值。然后指令 T4返回，它从栈中弹出 Ox400 056 0,因此将 P C设置为 mai n的 M2指令。程序成功完成对 top的调用，返回到 m·ain。可以看到，此时栈指针也恢复成了 Ox7fffffffe820,即调用 top之前的值。
可以看到，这种把返回地址压入栈的简单的机制能够让函数在稍后返回到程序中正确的点。 C语言（以及大多数程序语言）标准的调用／返回机制刚好与栈提供的后进先出的内存管理方法吻合。讫］练习题 3 . 32 下面列出的是两个函数 first和 last的反汇编代码，以及 main函数
调用 first的代码：
釭 sassembly of last(long u, long v)
U ln %rdl, V ln %rsl
1 0000000000400540 :
2 400540 : 48 89 f8 mov %rdi,%rax L1: u
3 400543: 48 Of af c6 imul %rsi,%rax L2: u.v
4 400547: c3 retq L3: Retur n
Disassembly of fir st(long x)
X ln %rdl
5 0000000000400548 :
6 400548: 48 8d 77 01 lea Oxl (%rdi), %rsi Ft : x+1
7 40054c: 48 83 ef 01 sub $0x1, %rdi F2: x一1
8 400550 : e8 eb ff ff ff callq 400540 F3: Call last(x-1,x+1)
400555: f3 c3 repz retq F4: Return
1o 400560 : e8 e3 ff ff ff callq 400548 M1 : Call t.lrst (10) 11 400565: 48 89 c2 mov %rax,%rdx M2: Resume
每条指令都有一个标号，类似于图 3-27a。从 ma i n调用丘 rs七 (10)开始，到程序返回 main时为止，填写下表记录指令执行的过程。
指令状态值（指令执行前）
标号 PC 指令 毛 rdi %rsi %rax %rsp * %rsp 描述<br>Ml Ox400560 callq 10 Ox7fffffffe820 调用 f1rs tOO)<br>Fl<br>F2<br>F3<br>L1<br>L2<br>L3<br>F4<br>M2</p><ol start=3><li><ol start=7><li>3 数据传送当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递，而从过程返回还有可能包括返回一个值。 x86-64中，大部分过程间的数据传送是通过寄存器实现的。例如，我们已经看到无数的函数示例，参数在寄存器％ r生、％ rsi和其他寄存器中传递。当过程 P调用过程 Q时， P的代码必须首先把参数复制到适当的寄存器中。类似地，当 Q返回到 P时， P的代码可以访问寄存器％ rax中的返回值。在本节中，我们更详细地探讨这些规则。 x86-64中，可以通过寄存器最多传递 6个整型（例如整数和指针）参数。寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小，如图 3-28所示。会根据参数在参数列表中的顺序为它们分配寄存器。可以通过 64位寄存器适当的部分访问小千 64位的参数。例如，如果第一个参数是 3 2位的，那么可以用％ edi来访问它。
参数数批
操作数大小（位）
1 2 3 4 5 6 64 %rdi 毛 rsi %rdx 毛rcx毛r8 %r9
32 怠edi毛esi号edx毛ecx %r8d %r9d 16 %di 号 si %dx %ex %r8w %r9w 8
沧dil令 sil %dl %cl %r8b 皂 r 9b
图 3-28传递函数参数的寄存器。寄存器是按照特殊顺序来使用的，而使用的名字是根据参数的大小来确定的
如果一个函数有大于 6个整型参数，超出 6个的部分就要通过栈来传递。假设过程 P调用过程 Q,有 n个整型参数，且 n > 6。那么 P的代码分配的栈帧必须要能容纳 7到 n号参数的存储空间，如图 3-2 5所示。要把参数 1 <del>6复制到对应的寄存器，把参数 7</del>n放
到栈上，而参数 7位于栈顶。通过栈传递参数时，所有的数据大小都向 8的倍数对齐。参
数到位以后，程序就可以执行 call指令将控制转移到过程 Q了。过程 Q可以通过寄存禄
访问参数，有必要的话也可以通过栈访间。相应地，如果 Q也调用了某个有超过 6个参数
的函数，它也需要在自己的栈帧中为超出 6个部分的参数分配空间，如图 3-25中标号为
“参数构造区”的区域所示。
作为参数传递的示例，考虑图 3-29a所示的 C函数 proc。这个函数有 8个参数，包括
字节数不同的整数 (8、 4、 2和 1)和不同类型的指针，每个都是 8字节的。
void proc(long al, long *alp, int a2, int *a2p, short a3, short *a3p, char a4, char *a4p)
{
*alp+= a1; *a2p += a2; *a3p += a3; *a4p += a4;
}
a) C代码
VO.1d proc(a1, alp, a2, a2p, a3, a3p, a4, a4p)
Arguments passed as tollo农s:
a1 in %rdi (64 bits) alp in %rsi (64 b.1ts) a2 in %edx (32 bits) a2p in %rcx (64 bits) a3 in .rBw (16 bits) a3p in .r9 (64 bits) a4 at .rsp+B (8 b.1ts) a4p at %rsp+16 (64 b.1ts)
1234567
proc:
movq 16(%rsp), %rax Fetch a4p (64 bits)<br>addq %rdi, (%rsi) *a1p += a1 (64 bits)<br>addl %edx, (%rcx) *a2p += a2 (32 bits)<br>add&rsquo;W %r8w, (%r9) *a3p += a3 (16 bits)<br>movl 8(%rsp), ．儿 edx Fetch a4 (8 b工 ts)<br>8 addb ret %dl, (%rax) *a4p += a4 Return (8 bits)</li></ol></li></ol><p>b)生成的汇编代码
图 3-29 有多个不同类型参数的函数示例。参数 1<del>6通过寄存器传递，而参数 7</del>8通过栈传递
图 3-296中给出 proc生成的汇编代码。前面 6个参数通过寄存器传递，后面 2个通过栈传递，就像图 3-30中画出来的那样。可以看到，作为过程调用的一部分，返回地址被压入栈中。因而这两个参数位于相对千栈指针距离为 8和 16的位置。在这段代码中，我们可以看到根据操作数的大小，使用了 ADD指令的不同版本： al(l o ng)使用 addq, a2釭nt)使用 addl, a3(shor七）使用 addw，而 a4(char)使用 addb。请注意第 6行的 movl指令从内存读入 4字节，而后面的 addb指令只使用其中的低位一字节。
a4p 116<br>a4 I 8<br>返回地址 0 . 栈指针％ rsp</p><p>图 3 -30函数 proc的栈帧结构。参数 a4和 a4p通过栈传递
芦练习题 3. 33 C函数 procprob有 4个参数 u、 a、 v和 b,每个参数要么是一个有符号数，要么是一个指向有符号数的指针，这里的数大小不同。该函数的函数体如下：
*U += a;
*V += b;
return sizeof(a) + sizeof(b);
编译得到如下 x86-64代码：
procprob: 2 movslq %edi, %rdi 3 addq %rdi, (%rdx) 4 addb %sil, (i儿rcx) 5 movl $6, %eax 6 ret
确定 4个参数的合法顺序和类型。有两种正确答案。</p><ol start=3><li><ol start=7><li>4 栈上的局部存储
到目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不过有些时候，局部数据必须存放在内存中，常见的情况包括： ·寄存器不足够存放所有的本地数据。 ·对一个局部变量使用地址运算符＇矿，因此必须能够为它产生一个地址。 ·某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。在描述
数组和结构分配时，我们会讨论这个问题。一般来说，过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标
号为＂局部变量＇，如图 3-25所示。
来看一个处理地址运算符的例子，图 3-3la中给出的两个函数。函数 swap_add交换指针 xp和 yp指向的两个值，并返回这两个值的和。函数 caller创建到局部变量 argl
和 arg2的指针，把它们传递给 swap_add。图 3-31 b展示了 caller是如何用栈帧来实现这些局部变量的。 caller的代码开始的时候把栈指针减掉了 16;实际上这就是在栈上分配了 16个字节。 S表示栈指针的值，可以看到这段代码计算＆arg2为 S +8（第 5行），而 &amp;argl为 S。因此可以推断局部变量 argl和 arg 2存放在栈帧中相对于栈指针偏移量为 0和 8的地方。当对 swap_add的调用完成后， caller的代码会从栈上取出这两个值（第 8~9行），计算它们的差，再乘以 swap_add在寄存器％ r ax中返回的值（第 1 0行）。最后，
该函数把栈指针加 16,释放栈帧（第 11行）。通过这个例子可以看到，运行时栈提供了一种简单的、在需要时分配、函数完成时释放局部存储的机制。
如图 3 -32所示，函数 call_proc是一个更复杂的例子，说明 x86-64栈行为的一些特性。尽管这个例子有点儿长，但还是值得仔细研究。它给出了一个必须在栈上分配局部变量存储空间的函数，同时还要向有 8个参数的函数 proc传递值（图 3 -29)。该函数创建一个栈帧，如图 3-33所示。
long swap_add(long *xp, long *yp)
{
long x = *xp; long y = *yp; *XP = y; <em>YP = x; return x + y;
}
long caller()
{
long argl = 534; long arg2 = 1057; long sum= swap_add(&amp;argl, &amp;arg2); long diff = argl -arg2; return sum * diff;
}
a) swap_add和调用函数的代码
long caller()
caller:<br>2 subq $16, %rsp Allocate 16 bytes for stack frame<br>3 movq $534, (%rsp) Store 534 in arg1<br>4 movq $1057, 8(%rsp) Stor e 1057 in arg2<br>5 leaq 8(%rsp), i儿rsi Compute &amp;arg2 as second argument<br>6 movq %rsp, %rdi Compute &amp;arg1 as first argument<br>7 call swap_add Call s甘ap_add (&:arg1, &:arg2)<br>8 movq (°儿rsp), %rdx Get arg1<br>9 subq 8(°儿rsp), %rdx Compute diff = arg1 -arg2<br>10 imulq %rdx, %rax Compute sum</em> diff<br>11 addq $16, %rsp Deallocate stack frame<br>12 ret Return</li></ol></li></ol><p>b )调用函数生成的汇编代码
图 3-3 1过程定义和调用的示例。由于会使用地址运算符，所以调用代码必须分配一个栈帧
long call_proc ()
{
long xl = 1; int x2 = 2; short x3 = 3; char x4 = 4; proc(xl, &amp;xl, x2, &amp;x2, x3, &amp;x3, x4, &amp;x4); return (xl+x2)*(x3-x4);
}
a) swap_add和调用函数的代码
图 3 -3 2调用在图 3-29中定义的函数 proc的代码示例。该代码创建了一个栈帧
long call_proc() call_proc: Set up arguments to pr oc
2 subq $32, %rsp Allocate 32-byte stack frame<br>3 movq $1, 24(%rsp) Store 1 in &amp;x1<br>4 movl $2, 20(i儿rsp) Store 2 i n &amp;x2<br>5 movw $3, 18CJ儿rsp) Store 3 in &amp;x3<br>6 movb $4, 17(%rsp) Store 4 in &amp;x4<br>7 leaq 17(%rsp), %rax Create &amp;x4<br>8 movq %rax, 8()/,rsp) Store &amp;x4 as argument 8<br>9 movl $4, (%rsp) Store 4 as argument 7<br>10 leaq 18(%rsp), ~!.r9 Pass &amp;x3 as argument 6<br>11 movl $3, %r8d Pass 3 as argument 5<br>12 leaq 20(%rsp), %rcx Pass &amp;x2 as argument 4<br>13 movl $2, %edx Pass 2 as argument 3<br>14 leaq 24(i儿rsp), i!.rsi Pass &amp;x1 as argument 2<br>15 movl $1, °儿 edi Pass 1 as argument 1<br>Call proc<br>16 call proc<br>Retrieve changes to memory<br>17 movslq 20(%rsp), %rdx Get x2 and convert to long<br>18 addq 24(%rsp), %rdx Compute x1+x2<br>19 movswl 18(%rsp), %eax Get x3 and convert to int<br>20 movsbl 17(%rsp), %ecx Get x4 and convert to int<br>21 subl %ecx, %eax Compute x3-x4<br>22 cltq Convert to long<br>23 imulq %rdx, %rax Compute (x1+x2) * (x3-x4)<br>24 addq $32, %rsp Deallocate stack f r ame<br>25 ret Return</p><p>b)调用函数生成的汇编代码
图 3-32（续）
看看 call_proc的汇编代码（图 3-326)，可以看到代码中一大部分（第 2<del>15行）是为调用 proc做准备。其中包括为局部变晕和函数参数建立栈帧，将函数参数加载至寄存器。如图 3-33所示，在栈上分配局部变量 xl</del> x4,它们具有不同的大小： 24<del>31 Cxl), 20</del>23 (x2), 18<del>19(x3)和 17(s3)。用 leaq指令生成到这些位置的指针（第 7、 10、 12和 14行）。参数 7（值为 4)和 8（指向 x4的位置的指针）存放在栈中相对于栈指针偏移量为 0和 8的地方。
当调用过程 proc时，程序会开始执行图 3-296中的代码。如图 3-30所示，参数 7和 8现在位于相对千栈指针偏移量为 8和 16的返回地址
32
地方，因为返回地址这时已经被压入栈中了。
xl
当程序返回 call_proc时，代码会取出 x2 4个局部变最（第 17</del>20行），并执行最终的计算。在程序结束前，把栈指针加 32,释放参数8 =&amp;x4 8-
这个栈帧。 4 创&ndash;—栈指针毛 rsp3. 7. 5 寄存器中的局部存储空间参数7
图 3 -33函数 call__JJroe的栈帧。该栈帧包含局部寄存器组是唯一被所有过程共享的资源。变蜇和两个要传递给函数 proc的参数
虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。为此， x86-64采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。
根据惯例，寄存器％rbx、 %rbp和％ r12~ %r15被划分为被调用者保存寄存器。当过程 P调用过程 Q时， Q必须保存这些寄存器的值，保证它们的值在 Q返回到 P时与 Q被调用时是一样的。过程 Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压人栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分，如图 3-25中所示。有了这条惯例， P的代码就能安全地把值存在被调用者保存寄存器中（当然，要先把之前的值保存到栈上），调用 Q,
然后继续使用寄存器中的值，不用担心值被破坏。
所有其他的寄存器，除了栈指针％ rsp,都分类为调用者保存寄存器。这就意味着任何函数都能修改它们。可以这样来理解“调用者保存”这个名字：过程 P在某个此类寄存器中有局部数据，然后调用过程 Q。因为 Q可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是 P（调用者）的责任。
来看一个例子，图 3-34a中的函数 P。它两次调用 Q。在第一次调用中，必须保存 x的值以备后面使用。类似地，在第二次调用中，也必须保存 Q(y)的值。图 3-346中，可以看到 GCC生成的代码使用了两个被调用者保存寄存器：％ rbp保存 x和％ rbx保存计算出来的
long P(long x, long y)
{
long u = Q(y);
long v = Q(x);
return u + v;
}
a )调用函数
long P(long x, long y)
X in 肚di, yin .rsi<br>1 P:<br>2 pushq %rbp Save .rbp<br>3 pushq %rbx Save .rbx<br>4 subq $8, %rsp Align stack frame<br>5 movq 。%rdi, %rbp Save x<br>6 movq %rsi, %rdi Move y to first argument<br>7 call Q Call Q(y)<br>8 movq %rax, %rbx Save result<br>9 movq %rbp, %rdi Move x to first argument<br>10 call Q Call Q(x)<br>11 addq %rbx, %rax Add saved Q(y) to Q(x) ·<br>12 addq $8, %rsp Deallocate last part of stack<br>13 popq %rbx Restore .rbx<br>14 popq %rbp Restore Y.rbp<br>15 ret</p><p>b)调用函数生成的汇编代码
图 3-34展示被调用者保存寄存器使用的代码。在第一次调用中，必须保存 x的值，第二次调用中，必须保存 Q(y)的值
Q(y)的值。在函数的开头，把这两个寄存器的值保存到栈中（第 2<del>3行）。在第一次调用 Q
之前，把参数 x复制到％rbp（第 5行）。在第二次调用 Q之前，把这次调用的结果复制到％rbx（第 8行）。在函数的结尾，（第 13</del>14行），把它们从栈中弹出，恢复这两个被调用者保存寄存器的值。注意它们的弹出顺序与斥入顺序相反，说明了栈的后进先出规则。 ;练习题3 . 34 一个函数 P生成名为 a0 ~a7的局部变量，然后调用函数 Q,没有参数。
GCC为 P的第一部分产生如下代码：
long P(long x) x.1n %rdi P:
2 pushq %r15 3 pushq %r14 4 pushq %r13 5 pushq %r12 6 pushq %rbp 7 pushq %rbx 8 subq $24, %rsp 9 movq %rdi, %rbx
10 leaq 1(%rdi), %r15 11 leaq 2(%rdi), %r14 12 leaq 3(%rdi), %r13 13 leaq 4(%rdi), i!.r12 14 leaq 5(%rd立，％rbp 15 leaq 6(%rdi), %rax 16 movq %rax, (%rsp) 17 leaq 7(%rdi), %rdx 18 movq %rdx, 8(%rsp) 19 movl $0 , %eax 20 call Q
A.确定哪些局部值存储在被调用者保存寄存器中。
B.确定哪些局部变量存储在栈上。
C.解释为什么不能把所有的局部值都存储在被调用者保存寄存器中。</p><ol start=3><li><ol start=7><li>6 递归过程
前面已经描述的寄存器和栈的惯例使得 x86-64过程能够递归地调用它们自身。每个
过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。此外，栈的原则很自然地就提供了适当的策略，当过程被调用时分配局部存储，当返回时释放存储。
图 3-35给出了递归的阶乘函数的 C代码和生成的汇编代码。可以看到汇编代码使用寄存器％rb x来保存参数 n,先把已有的值保存在栈上（第 2行），随后在返回前恢复该值（第 11行）。根据栈的使用特性和寄存器保存规则，可以保证当递归调用 rfact(n-1)返回
时（第 9行），（ l）该次调用的结果会保存在寄存器％ rax中，（ 2)参数 n的值仍然在寄存器％rbx中。把这两个值相乘就能得到期望的结果。
从这个例子我们可以看到，递归调用一个函数本身与调用其他函数是一样的。栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回位置和被调用者
保存寄存器的值）存储空间。如果需要，它还可以提供局部变量的存储。栈分配和释放的
规则很自然地就与函数调用－返回的顺序匹配。这种实现函数调用和返回的方法甚至对更
复杂的情况也适用，包括相互递归调用（例如，过程 P调用 Q , Q再调用 P)。
l ong rfact(long n )
{
long result; 辽 (n &lt;= 1) result = 1; else result = n * rfact(n-1) ; ret urn result;
}
a) C代码
long rfact (long n)
n in %rdi<br>rfact:<br>2 pushq %rbx Save .rbx<br>3 movq 。%rdi, %rbx Store n.ln callee-saved reg.lster<br>4 movl $1, %eax Set return value = 1<br>5 cmpq $1, %rdi Compare n:1<br>6 jle . L35 If &lt;=, goto done<br>7 leaq -1(%rd沁， %rdi Compute n-1<br>8 call rfact Call rfact(n-1)<br>9 imulq %rbx, %rax Multiply result b y n<br>10 .L35 : done :<br>11 popq %rbx Restore .rbx<br>12 ret Return</li></ol></li></ol><p>b)生成的汇编代码
图 3 -3:i递归的阶乘程序的代码。标准过程处理机制足够用来实现递归函数
诠』练习题 3 . 35 一个具有通用结构的 C函数如下：
l ong rfun(unsigned long x ) { if ( ____ ) return
______ , unsigned long nx = __<em>; long rv = rfun(nx); return
~~&mdash;-</em> ,
}
GCC产生如下汇编代码：
long rfun (uns].gned long x) x ].n .rdi rfun:
2 pushq %rbx 3 movq 。%rdi, %rbx 4 movl $0 , %eax 5 testq %rdi, %rdi
6 je .L2 7 shrq $2, %rdi 8 call rfun 9 addq %rbx, %rax
10 . L2 : 11 popq %rbx 12 ret
A. rfun存储在被调用者保存寄存器％rbx中的值是什么？
B.填写上述 C代码中缺失的表达式。</p><ol start=3><li><p>8 数组分配和访问
C语言中的数组是一种将标量数据聚集成更大数据类型的方式。 C语言实现数组的方式非常简单，因此很容易翻译成机器代码。 C语言的一个不同寻常的特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算。
优化编译器非常善于简化数组索引所使用的地址计算。不过这使得 C代码和它到机器代码的翻译之间的对应关系有些难以理解。</p></li><li><ol start=8><li>1 基本原则
对于数据类型 T和整型常数 N,声明如下：
T A[N];
起始位置表示为 :i_·A。这个声明有两个效果。首先，它在内存中分配一个 L.N字节的连续
区域，这里 L是数据类型 T的大小（单位为字节）。其次，它引入了标识符 A,可以用 A来
作为指向数组开头的指针，这个指针的值就是环。可以用 O~N-1的整数索引来访问该数组元素。数组元素 1会被存放在地址为 xA+L.i的地方。作为示例，让我们来看看下面这样的声明：
char A[12]; char *B[8]; int C[6]; double *D[5];
这些声明会产生带下列参数的数组：
数组 元素大小 总的大小 起始地址 元素 t<br>A 1 12 XA 工A十 z<br>B 8 64 XB :rB+81<br>C 4 24 :rc 工 c +4i<br>D 8 40 .r。 工 0+8i</li></ol></li></ol><p>数组 A由 12个单字节 (char)元素组成。数组 c由 6个整数组成，每个需要 8个字节。 B和 D都是指针数组，因此每个数组元素都是 8个字节。
x86-64的内存引用指令可以用来简化数组访问。例如，假设 E是一个 int型的数组，而我们想计算 E［习，在此， E的地址存放在寄存器％ rdx中，而 i存放在寄存器％ rcx中。然后，指令
movl (%rdx,%rcx,4),%eax
会执行地址计算 XE +4i,读这个内存位置的值，并将结果存放到寄存器％eax中。允许的伸缩因子 1、 2、 4和 8覆盖了所有基本简单数据类型的大小。讫；练习题 3 . 36 考虑下面的声明：
short S[7]; short *T[3] ; short **U[6] ; int V[8]; double *W[4];
填写下表，描述每个数组的元素大小、整个数组的大小以及元素 1的地址：
数组 元素大小 整个数组的大小 起始地址 元素 l<br>s 工s<br>T .rT<br>u 工 u<br>V 工v<br>w 工w</p><ol start=3><li><ol start=8><li>2 指针运算
C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果 p是一个指向类型为 T的数据的指针， p的值为斗，那么表达式 p+i的值为 .rp+L . i,这里 L是数据类型 T的大小。
单操作数操作符＇矿和＇＊＇可以产生指针和间接引用指针。也就是，对千一个表示某个对象的表达式 Expr, &amp;Expr是给出该对象地址的一个指针。对于一个表示地址的表达式 AExpr, <em>AExpr给出该地址处的值。因此，表达式 Expr与＊＆ Expr是等价的。可以对数组和指针应用数组下标操作。数组引用 A[i]等同于表达式＊（ A+习。它计算第 1个数组元素的地址，然后访问这个内存位置。
扩展一下前面的例子，假设整型数组 E的起始地址和整数索引 1分别存放在寄存器 %rdx和％rcx中。下面是一些与 E有关的表达式。我们还给出了每个表达式的汇编代码实现，结果存放在寄存 ff % eax（如果是数据）或寄存器％rax（如果是指针）中。
表达式类型值汇编代码
E int</em> 工E movq %rdx, %rax E [O] int M［五 rnovl (%rdx), %rax E[i) 1nc M[:rE+ 4i] movl（寇rdx,号rcx , 4)，令eax &amp;E[2] in七＊工E+8 l eaq 8 (%rdx), %rax E+i一1 int* .rE +4广－4 leaq-4 (%rdx, %rcx,4), %rax</li></ol></li></ol><ul><li>(E+i-3) int M巨＋ 4 ,-12] movl一12(%rdx, %rcx,4 )，号eax
&amp;E[i)-E long l movq沦rcx ,毛rax
在这些例子中，可以看到返回数组值的操作类型为 int,因此涉及 4字节操作（例如 movl)和寄存器（例如％eax)。那些返回指针的操作类型为 int*，因此涉及 8字节操作（例如 leaq)和寄存器（例如％rax)。最后一个例子表明可以计算同一个数据结构中的两个指针之差，结果的数据类型为 long,值等千两个地址之差除以该数据类型的大小。让练习题3 . 37 假设短整型数组 s的地址 Xs和整数索引 1分别存放在寄存器％rdx和
% rcx中。对下面每个表达式，给出它的类型、值的表达式和汇编代码实现。如果结果是指针的话，要保存在寄存器％ rax中，如果数据类型为 short,就保存在寄存器元素％ax中。
表达式类型值汇编代码
S+ 1 S[3] &amp;S [ij
S[4五＋ 1)
S+ i-5</li></ul><ol start=3><li><ol start=8><li>3 嵌套的数组当我们创建数组的数组时，数组分配和引用的一般原则也是成立的。例如，声明
int A[5] [3] ;
等价于下面的声明
typedef int row3_t[3];
row3_t A[5];
数据类型 r ow3_t被定义为一个 3个整数的数组。数组 A包含 5个这样的元素，每个元素需要 1 2个字节来存储 3个整数。整个数组的大小就是 4 X 5X3 = 60字节。数组 A还可以被看成一个 5行 3列的二维数组，用 A [O J /1丁-元素地址
(0 ]到 A[4 ] [2]来引用。数组元素在内存中按照“行优先”的A[OJ A[O] [OJ x, 顺序排列，意味着第 0行的所有元素，可以写作 A [0 ]，后面A[O] [1] x, +4 跟着第 1行的所有元素 (A [1]），以此类推，如图 3 -36所示。A[O] [2] XA + 8
这种排列顺序是嵌套声明的结果。A[l] A[l] [O J XA + J2
将 A看作一个有 5个A[1) [l ) x_, + 16 元素的数组，每个元素都是 3个 in t的数组，首先是 A [OJ, A[1] [2] x, + 20 然后是 A[l]，以此类推。A[2] A[2] [0] x, + 24
要访问多维数组的元素，编译器会以数组起始为基地址，A[2] [l] x, + 28 （可能需要经过伸缩的）偏移量为索引，产生计算期望的元素A[2] [2] x入＋ 32
A[3] A[3] [OJ XA + 36 的偏移量，然后使用某种 MOV指令。通常来说，对于一个A [3] [1 ] x, +40 声明如下的数组： A[3 ] [2] x, +44 A [4] A[4 ] [OJ x, + 48
T D[R] [C];
A[4] (1] x. + 52 它的数组元素 D [i] [j ]的内存地址为 A[4 J (2) XA + 56
&amp;D [i][j] = X0 + L(C . i + j) (3. 1 ) 图 3-36按照行优先顺序这里， L是数据类型 T以字节为单位的大小。作为一个示例， 存储的数组元素考虑前面定义的 5X3的整型数组 A。假设工A、 1和）分别在寄存器％rdi、 %rsi和％ rdx中。然后，可以用下面的代码将数组元素 A[i ] [j ]复制到寄存器％ eax中：
A in %rd工，工 in %rsi, and J工n %rdx leaq (%rsi,%rsi,2), %rax Compute 31 23 leaq (%rdi,%rax,4), 1儿rax Compute xA + 121 movl C儿rax,%rdx,4),。I.eax Read from M[xA + 12i +4)]
正如可以看到的那样，这段代码计算元素的地址为 XA + 12i + 4j =xA+ 4C3i十户，使用了 x86-64地址运算的伸缩和加法特性。诠练习题3 . 38 考虑下面的源代码，其中 M和 N是用＃ define声明的常数：
long P [M] [N] ; l ong Q[N] [M] ;
long sum_element(long i, long j ) { return P[i] [j] + Q[j] [i] ; }
在编译这个程序中， GCC产生如下汇编代码：
long sum_element(long i, long j ) i in %rdi, j in %rsi
123456789
sum_element : leaq O(,%rdi, 8), %rdx subq 1儿rdi, %rdx addq %rsi, %rdx leaq (%rsi,%rsi,4), %rax addq %rax, %rdi movq Q(立rdi ,8) , %rax addq P(心rdx,8 ) , %rax ret
运用逆向工程技能，根据这段汇编代码，确定 M和 N的值。</li></ol></li><li><ol start=8><li>4 定长数组
C语言编译器能够优化定长多维数组上的操作代码。这里我们展示优化等级设置为-0 1时 GCC采用的一些优化。假设我们用如下方式将数据类型 fix_matrix声明为 1 6 X 16 的整型数组：
#define N 16 <em>typedef int fix_matrix [NJ [NJ ;
（这个例子说明了一个很好的编码习惯。当程序要用一个常数作为数组的维度或者缓冲区的大小时，最好通过＃ define声明将这个常数与一个名字联系起来，然后在后面一直使用这个名字代替常数的数值。这样一来，如果需要修改这个值，只用简单地修改这个＃ de f ine声明就可以了。）图 3-37a中的代码计算矩阵 A和 B乘积的元素 i, k,即 A的行 1和 B的列 k的内积。 GCC产生的代码（我们再反汇编成 C)，如图 3-376中函数 fix_prod</em> ele_op七所示。这段代码包含很多聪明的优化。它去掉了整数索引 j&rsquo;并把所有的数组引用都转换成了指针间接引用，其中包括 (1)生成一个指针，命名为 Aptr ,指向 A的行 1中连续的元素；（ 2）生成一个指针，命名为 Bp七 r,指向 B的列 k中连续的元素；（ 3）生成一个指针，命名为 Bend,当需要终止该循环时，它会等于 Bptr的值。 Aptr的初始值是 A
的行 l的第一个元素的地址，由 C表达式＆A(i] [0)给出。 Bptr的初始值是 B的列 k的第一个元素的地址，由 C表达式＆ B [OJ [k]给出。 Bend的值是假想中 B的列）的第 (n+ l )个元素的地址，由 C表达式＆B[N] [k ]给出。
下面给出的是 GCC为函数 fix_p r od_ele生成的这个循环的实际汇编代码。我们看到 4个寄存器的使用如下：％eax保存 resu l t, %r di保存 Apt r , %rc x保存 Bptr，而％ rsi保存 Bend。
I* Compute i,k of fixed matrix product <em>I
int fix_prod_ele (fix_matrix A, fix_matrix B, long i, long k) { long j; int result= O;
for (j = O; j &lt; N; j++) result += A[i] [j] * B[j] [k];
return result;
}
a )原始的C代码
I</em> Compute i,k of fixed matrix product *I 2 int fix_prod_ele_opt(fix_matrix A, fix_matrix B, long i, long k) { 3 int <em>Aptr = &amp;A[i] [OJ; I</em> Points to elements in row i of A *I 4 int <em>Bptr = &amp;B[O] [k]; I</em> Points to elements in column k of B *I 5 int <em>Bend= &amp;B[N] [k]; I</em> Marks stopping point for Bptr <em>I
678901
int result= O;
do { I</em> No need for initial test *I result+= *Aptr * <em>Bptr; I</em> Add next product to sum <em>I Aptr ++; I</em> Move Aptr to next column <em>I
11 Bptr += N; I</em> Move Bptr to next row <em>I } while (Bptr != Bend); I</em> Test for stopping point *I 12 return result;
13 }
b )优化过的C代码
图 3-37原始的和优化过的代码，该代码计算定长数组的矩阵乘积的元素 i , k。
编译器会自动完成这些优化
int fix_prod_ele_opt(fix_matrix A, fix_matrix B, long i, long k) A in %rdi, Bin %rsi, i in %rdx, kin %rcx
123456789012345
fix_prod_ele: salq $6 , %rdx Compute 64 * 1. addq %rdx, %rdi Compute Aptr = xA + 64i = &amp;A [i][OJ leaq (%rsi,%rcx,4) , i儿rcx Compute Bptr = x8 + 4k = &amp;B[O] [k] leaq 1024(%rcx), i!.rsi Compute Bend = x8 + 4k + 1024 = &amp;B[NJ [k] movl $0, %eax Set result= 0
. L7 : loop: movl (%rdi), %edx Read *Aptr imull (%rcx), %edx Multiply by <em>Bptr
111111
addl %edx, %eax Add to result
addq $4 , %rdi Increment Aptr ++ addq $64, %rcx Increment Bptr += N cmpq %rsi , %rcx Compare Bptr: Bend jne .L7 If!=, goto l oop rep; ret Return
;练习题3 . 39 利用等式 3 . 1来解释图 3-37b的 C代码中 Aptr、 Bptr和 Bend的初始值计
算（第 3<del>5行）是如何正确反映丘x_prod_ele的汇编代码中它们的计算（第 3</del>5行）的。
让练习题3 . 40 下面的 C代码将定长数组的对角线上的元素设置为 val:
I</em> Set all diagonal elements to val */
void fix_set_diag(fix_matrix A, int val) { long i; for (i = O; i &lt; N; i++)
A [i] [i] = val;
}
当以优化等级－01编译时， GCC产生如下汇编代码：
fix_set_diag: VO.ld f.lx_set_d.lag(f.lx_matr.lx A, int val) A.ln %rd.l , val.ln %rs.l
2345678
movl $0, %eax<br>.L13:<br>movl %esi, (%rdi,%rax)<br>addq $68, %rax<br>cmpq $1088, %rax<br>jne .L13</li></ol></li></ol><p>rep; ret
创建一个 C代码程序丘x_se七＿尘 ag_opt,它使用类似于这段汇编代码中所使用的优化，风格与图 3-376中的代码一致。使用含有参数 N的表达式，而不是整数常量，使得如果重新定义了 N,你的代码仍能够正确地工作。
3. 8. 5 变长数组历史上， C语言只支持大小在编译时就能确定的多维数组（对第一维可能有些例外）。程序员需要变长数组时不得不用 malloc或 calloc这样的函数为这些数组分配存储空间，而且不得不显式地编码，用行优先索引将多维数组映射到一维数组，如公式 (3. 1)所示。 ISO C吵引入了一种功能，允许数组的维度是表达式，在数组被分配的时候才计算出来。在变长数组的 C版本中，我们可以将一个数组声明如下：
int A[exprl] [expr2]
它可以作为一个局部变量，也可以作为一个函数的参数，然后在遇到这个声明的时候，通过对表达式 exprl和 expr2求值来确定数组的维度。因此，例如要访问 n X n数组的元素 i,, j&rsquo;我们可以写一个如下的函数：
int var_ele(long n, int A[n] [n], long i, long j) { return A[i] [j] ;
}
参数 n必须在参数 A[n) [n]之前，这样函数就可以在遇到这个数组的时候计算出数组的维度。 GCC为这个引用函数产生的代码如下所示：
int var_ele(long n, int A[n] [n], long i, long j)
n in %rdi, A in .rsi, i in %rdx, j in %rcx
var_ele :
2345imulq %rdx, ~!.rdi Compute n · 1 leaq (%rsi,i!.rdi,4), %rax Compute xA + 4(n · i ) movl (%rax,%rcx,4), %eax Read from M[入A + 4(n 1) + 4)] ret
正如注释所示，这段代码计算元素＂）的地址为工&rdquo;+ 4 (n . i) + 4j = x&rdquo; + 4 (n · i+)）。这个地址的计算类似于定长数组的地址计算（参见 3.8 . 3节），不同点在于 1)由于增加了参数 n,寄存器的使用变化了； 2）用了乘法指令来计算 n · i（第 2行），而不是用 leaq指令来计算 3i。因此引用变长数组只需要对定长数组做一点儿概括。动态的版本必须用乘法指令对
1伸缩 n倍，而不能用一系列的移位和加法。在一些处理器中，乘法会招致严重的性能处罚，但是在这种情况中无可避免。
在一个循环中引用变长数组时，编译器常常可以利用访问模式的规律性来优化索引的计算。例如，图 3-38a给出的 C代码，它计算两个 n X n矩阵 A和 B乘积的元素 i, k。 GCC产生的汇编代码，我们再重新变为 C代码（图 3 -38 6)。这个代码与固定大小数组的优化代码（图 3-37)风格不同，不过这更多的是编译器选择的结果，而不是两个函数有什么根本的不同造成的。图 3-386的代码保留了循环变量 j&rsquo;用以判定循环是否结束和作为到 A的行 1的元素组成的数组的索引。
I* Compute i,k of variable matrix product .I 2 int var_prod_ele (long n, int A[n] [n], int B[n] [n], long i, long k) { 3 long j; 4 int result= O;
5
for (j = 0; j &lt; n; j ++) result += A[i] [j] * B[j] [k];
return result; a)
原始的C代码</p><p>口
I* Compute i,k of variable matrix product *I
int va工＿prod_ele_opt(long n, int A[n] [n], int B[n] [n], long i, long k) {
int *Arow = A[i];
int *Bptr = &amp;B[O] [k];
int result= O;
long j;
for (j = O; j &lt; n; j++) {
result+= Arow[j] * *Bptr; Bptr += n;
}
return resul t;
}
b )优化后的C代码
图 3 -38计算变长数组的矩阵乘积的元素 i, k的原始代码和优化后的代码。编译器自动执行这些优化
下面是 var—p rod_ele的循环的汇编代码：
Registers: n in %rdi, Aro日 in %rsi, Bptr in .rcx<br>4n in %r9, result in .eax, j in %edx<br>.L24: loop:<br>2 movl (%rsi, %rdx,4), %r8d Read Arow句］<br>3 imull (%rcx), i!.r8d Multiply by *Bptr</p><p>，
45678addl 。%r8d , %eax Add to result<br>addq $1, %rdx j++<br>addq %r9, %rcx Bptr += n<br>cmpq %rdi, %rdx Compare j:n<br>jne . L24 If!=, goto l oop</p><p>我们看到程序既使用了伸缩过的值 4 n（寄存器％ r 9)来增加 Bptr,也使用了 n的值（寄存器％r中）来检查循环的边界。 C代码中并没有体现出需要这两个值，但是由于指针运算的伸缩，才使用了这两个值。
可以看到，如果允许使用优化， GCC能够识别出程序访问多维数组的元素的步长。然后生成的代码会避免直接应用等式 (3 . 1)会导致的乘法。不论生成基于指针的代码（图 3-37b)还是基于数组的代码（图 3-38b)，这些优化都能显著提高程序的性能。
3. 9 异质的数据结构 C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：结构 (struc -tu re)，用关键字 s七 ruc t来声明，将多个对象集合到一个单位中；联合 (union)，用关键字 un ion来声明，允许用几种不同的类型来引用一个对象。
3. 9. 1 结构
C语言的 stru吐声明创建一个数据类型，将可能不同类型的对象聚合到一个对象中。用名字来引用结构的各个组成部分。类似于数组的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段（如l d)的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。
凶 1 将一个对象表示为 s七rue七
·c语言提供的 struct数据类型的构造函数 (constructor)与 C+＋和 Java的对象最为接近。
它允许程序员在一个数据结构中保存关于某个实体的信息，并用名宇来引用这些信息。例如，一个图形程序可能要用结构来表示一个长方形：
struct rect { long llx; I* X coor dinat e of lower-left corner <em>I l ong lly; I</em> Y coordinate of lower-l ef t corner <em>I unsigned long width; I</em> Width (in pixels) <em>/ unsigned long he].ght ; I</em> He].ght (in p].xels ) <em>/ unsigned color; · /</em> Coding of color */
};
可以声明一个 struct rect类型的变量 r,并将它的字段值设置如下：
struct rect r ;
r . llx = r.lly = O;
r . col or = OxFFOOFF; r .wi dth = 10; r.height = 20 ;</p><p>这里表达式 r .llx就会选择结构 r的 llx宇段。另外，我们可以在一条语句中既声明变量又初始化它的宇段：
struct rect r = { 0, 0, 10, 20, OxFFOOFF } ;
将指向结构的指针从一个地方传递到另一个地方，而不是复制它们，这是很常见的。例如，下面的函数计算长方形的面积，这里，传递给函数的就是一个指向长方形 struct的指针：
long area(struct rect *rp) { return (*rp).width * (*rp).height;
}
表达式 (*rp). width间接引用了这个指针，并且选取所得结构的 width宇段。这里必须要用括号，因为编译器会将表达式＊ rp.width解释为＊（ rp.width)，而这是非法的。间接引用和宇段选取结合起来使用非常常见，以至于 C语言提供了一种替代的表示法－＞。即 rp-> width等价于表达式 (*rp). width。例如，我们可以写一个函数，它将一个长方形顺时针旋转 90度：
void rotate_left(struct rect <em>rp) { I</em> Exchange width and height <em>I long t = rp->height; rp->height = rp->width; rp->width = t; I</em> Shift to new lower-left corner *I rp->llx -= t;
}
C+＋和 Java的对象比 C语言中的结构要复杂精细得多，因为它们将一组可以被调用来执行计算的方法与一个对象联系起来。在 C语言中，我们可以简单地把这些方法写成普通函数，就像上面所示的函数 area和 rotate_left。
让我们来看看这样一个例子，考虑下面这样的结构声明：
struct rec { int i; int j; int a[2]; int <em>p;
};
这个结构包括 4个字段：两个 4字节 int、一个由两个类型为 int的元素组成的数组和一个 8字节整型指针，总共是 24个字节：
4 8
移容偏内
0
16 24
厂
i1-.J
lp
a[O] a [1]
可以观察到，数组 a是嵌入到这个结构中的。上图中顶部的数字给出的是各个字段相对于结构开始处的字节偏移。
为了访问结构的字段，编译器产生的代码要将结构的地址加上适当的偏移。例如，假设 struct rec</em>类型的变量 r放在寄存器％r土中。那么下面的代码将元素 r->i复制到元素 r->j:
Registers : r in .rdi<br>movl (%rdi), %eax Get r ->i<br>2 movl %eax, 4(%rdi) Store in r->j</p><p>因为字段 1的偏移最为 o,所以这个字段的地址就是 r的值。为了存储到字段 j&rsquo;代码要
将 r的地址加上偏移量 4。
要产生一个指向结构内部对象的指针，我们只需将结构的地址加上该字段的偏移量。
例如，只用加上偏移量 8 + 4Xl=12,就可以得到指针＆ ( r->a [l]）。对于在寄存器％ rdi
中的指针 r和在寄存器％ rsi中的长整数变量 i,我们可以用一条指令产生指针＆（ r->a
[1]）的值：
Registers : r in %rdi, i %rsi leaq 8 (%rdi,%rsi,4), 1!.rax Set %rax to &amp;r->a [.l]
最后举一个例子，下面的代码实现的是语句：
r->p = &amp;r->a[r->i + r ->j];
开始时 r在寄存器％ r中中：
Registers: r in .rdi
12345
movl 4(%rdi), %eax Get r->J addl (%rdi), 1儿 eax Add r->i cltq Extend to 8 bytes
leaq 8(°儿rdi,i!.rax,4), i!.rax Compute &amp;r->a[r-＞工＋ r->j]
movq %rax, 16(%rdi) Store in r->p
综上所述，结构的各个字段的选取完全是在编译时处理的。机器代码不包含关于字段
声明或字段名字的信息。
讫§练习题 3 . 41 考虑下面的结构声明：
struct prob { int *p; struct {
int x; int y; } s;
struct prob *next;
};
这个声明说明一个结构可以嵌套在另一个结构中，就像数组可以嵌套在结构中、数组
可以嵌套在数组中一样。
下面的过程（省略了某些表达式）对这个结构进行操作：
void sp_init(struct prob *sp) { sp->s.x = , sp->p = , sp->next = _ ;
}
A.下列字段的偏移量是多少（以字节为单位）？
p: s.x: s.y:
next:
B.这个结构总共需要多少字节？
C.编译器为 sp_init的主体产生的汇编代码如下：
void sp_ini t (struct prob *sp) sp in .rdi sp_init:
2 movl 12(%rdi), %eax 3 movl %eax, 8(%rdi) 4 leaq 8(%rdi), i/,rax 5 movq %rax, (%rd立 6 rnovq %rdi, 16(i儿 rdi) 7 ret
根据这些信息，填写 s p_in辽代码中缺失的表达式。沁义练习题 3 . 42下面的代码给出了类型 ELE的结构声明以及函数 fu n的原型：
struct ELE { long v; struct ELE *p;
} ;
long fun(struct ELE *ptr);
当编译 fun的代码时， GCC会产生如下汇编代码：
long fun(struct ELE *ptr) ptr in %rdi fun :
2 movl $0, %eax 3 jmp .L2 4 .L3: 5 addq (%rdi), %rax 6 movq 8(%rd立，°儿rdi 7 .L2: 8 testq 0/4rdi, %rdi 9 jne . L3
10 rep; ret
A.利用逆向工程技巧写出 fun的 C代码。
B.描述这个结构实现的数据结构以及 fun执行的操作。</p><ol start=3><li><ol start=9><li>2 联合
联合提供了一种方式，能够规避 C语言的类型系统，允许以多种类型来引用一个对
象。联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的内存块。
考虑下面的声明：
struct S3 { char c; int i [2]; double v ;
};
union U3 { char c; int i[2]; double v;
};
在一台 x86-64 Linux机器上编译时，字段的偏移量、数据类型 S3和 U3的完整大小如下：
类型 c V 大小 00 40
S3 16
24
U3 。
8
（稍后会解释 S3中 1的偏移量为什么是 4而不是 1 &lsquo;以及为什么 v的偏移量是 1 6而不是 9或 12。)对千类型 union U3 *的指针 p, p-> C、 p-> i[O]和 p-> V引用的都是数据结构
的起始位置。还可以观察到，一个联合的总的大小等于它最大字段的大小。
在一些下上文中，联合十分有用。但是，它也能引起一些讨厌的错误，因为它们绕过了 C语言类型系统提供的安全措施。一种应用情况是，我们事先知道对一个数据结构中的两个不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一
部分，会减小分配空间的总最。例如，假设我们想实现一个二叉树的数据结构，每个叶子节点都有两个 double类型的数据值，而每个内部节点都有指向两个孩子节点的指针，但是没有数据。如果声明如下：
struct node_s { struct node_s *left; struct node_s *right; double data[2];
};
那么每个节点需要 32个字节，每种类型的节点都要浪费一半的字节。相反，如果我们如下声明一个节点：
union node_u { struct {
,1-
union node_u *left;
union node_u *right; } internal; double data[2] ;
};
那么，每个节点就只需要 16个字节。如果 n是一个指针，指向 union node_u *类型的节点，我们用 n-> da七 a[O]和 n-> data[l]来引用叶子节点的数据，而用 n -> i nternal.
4,
left和 n-> inte rnal.rig阮来引用内部节点的孩子。
不过，如果这样编码，就没有办法来确定一个给定的节点到底是叶子节点，还是内部 § 节点。通常的方法是引入一个枚举类型，定义这个联合中可能的不同选择，然后再创建一个结构，包含一个标签字段和这个联合：
typedef enum { N_LEAF, N_INTERNAL} nodetype_t;
4`．一， 1， ＿＿『
I_
struct node_t { nodetype_t type;
union {
m-struct { struct node_t *left; struct node_t *right;
} internal; double data[2]; } info ;
};
这个结构总共需要 24个字节： type是 4个字节， info . in七ernal . left和 info .in七e rnal . right各要 8个字节，或者是 info.data要 16个字节。我们后面很快会谈到，在字段 t ype和联合的元素之间需要 4个字节的填充，所以整个结构大小为 4+4+ 16 = 24。在这种情况中，相对千给代码造成的麻烦，使用联合带来的节省是很小的。对千有较多字段的
数据结构，这样的节省会更加吸引人。
联合还可以用来访问不同数据类型的位模式。例如，假设我们使用简单的强制类型转
换将一个 double类型的值 d转换为 unsigned long类型的值 U :
unsigned l ong u = (unsigned l ong) d;
值 u会是 d的整数表示。除了 d的值为 0 . 0的情况以外， u的位表示会与 d的很不一样。再看下面这段代码，从一个 double产生一个 unsigned long类型的值：
unsigned long double2bits(double d) {
union { doubled; unsigned long u;
} ternp; ternp .d = d; return t ernp.u;
};
在这段代码中，我们以一种数据类型来存储联合中的参数，又以另一种数据类型来访
问它。结果会是 u具有和 d一样的位表示，包括符号位字段、指数和尾数，如 3 . 11节中描述的那样。 u的数值与 d的数值没有任何关系，除了 d等于 o . 0的情况。
当用联合来将各种不同大小的数据类型结合到一起时，字节顺序问题就变得很重要
了。例如，假设我们写了一个过程，它以两个 4字节的 unsigned的位模式，创建一个 8字节的 double :
double uu2doubl e(unsigned wordO, unsigned word1)
union { doubled; unsigned u[2] ;
} ternp;
temp.u[O] = wordO ; temp. u [1] = wordl; return temp.d;
}
在 x86-64这样的小端法机器上，参数 wo rdO是 d的低位 4个字节，而 wordl是高位 4个字节。在大端法机器上，这两个参数的角色刚好相反。 ;练习题3 . 43 假设给你个任务，检查一下 C编译器为结构和联合的访问产生正确的
代码。你写了下面的结构声明：
t ypedef union {
struct { l ong u; short v ; char w;
} t1 ;
struct { int a[2]; char *p;
} t2; } u_type;
你写了一组具有下面这种形式的函数：
void get(u_type *up, type *dest) { *dest = expr;
}
这组函数有不一样的访问表达式 expr,而且根据 expr的类型来设置目的数据类型 type。然后再检查编译这些函数时产生的代码，看看它们是否与你预期的一样。假设在这些函数中， up和 dest分别被加载到寄存器％rdi和％ rsi中。填写下表中的数据类型 type,并用 1~3条指令序列来计算表达式，并将结果存储到 dest中。
expr type 代码
up->tl . u long movq伐rdi)，毛rax movq %rax, (%rs]. )
up->tl .v
&amp;up->tl.w
up->t2.a
up->t2.a[up->tl.u]
*up->七2 .p</li></ol></li></ol><p>3.9. 3 数据对齐
许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值 K（通常是 2、 4或 8)的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。例如，假设一个处理器总是从内存中取 8个字节，则地址必须为 8的倍数。如果我们能保证将所有的 double类型数据的地址对齐成 8的倍数，那么就可以用一个内存操作来读或者写值了。否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个 8字节内存块中。
无论数据是否对齐， x86-64硬件都能正确工作。不过， Int e l还是建议要对齐数据以提高内存系统的性能。对齐原则是任何 K字节的基本对象的地址必须是 K的倍数。可以看到这条原则会得到如下对齐：
K 类型
1 char 2 short 4 int,float 8 long, doubl e , char*
确保每种数据类型都是按照指定方式来组织和分配，即每种类型的对象都满足它的对齐限制，就可保证实施对齐。编译器在汇编代码中放入命令，指明全局数据所需的对齐。例如， 3. 6.8节开始的跳转表的汇编代码声明在第 2行包含下面这样的命令：
.align 8
这就保证了它后面的数据（在此，是跳转表的开始）的起始地址是 8的倍数。因为每个表项长 8个字节，后面的元素都会遵守 8字节对齐的限制。对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。而结构本身对它的起始地址也有一些对齐要求。比如说，考虑下面的结构声明：
struct S1 { int i; char c; int j;
};
假设编译器用最小的 9字节分配，画出图来是这样的：
偏移 0 4 5 9 内容 I l. IC I J |
它是不可能满足字段认偏移为 0)和］（偏移为 5)的 4字节对齐要求的。取而代之地，编译器在字段 e和］之间插入一个 3字节的间隙（在此用蓝色阴影表示）：
偏移 0 4 5 8 12
I内容 1 L I C I J
结果， J的偏移量为 8，而整个结构的大小为 12字节。此外，编译器必须保证任何 S七 ruct Sl *类型的指针 p都满足 4字节对齐。用我们前面的符号，设指针 p的值为 Xp o 那么， Xp必须是 4的倍数。这就保证了 p->土（地址 Xp)和 p-> ]（地址 xp+s)都满足它们的 4字节对齐要求。
另外，编译器结构的末尾可能需要一些填充，这样结构数组中的每个元素都会满足它的对齐要求。例如，考虑下面这个结构声明：
struct S2 { int i; int j; char c;
};
如果我们将这个结构打包成 9个字节，只要保证结构的起始地址满足 4字节对齐要求，我们仍然能够保证满足字段 1和］的对齐要求。不过，考虑下面的声明：
struct S2 d[4];
分配 9个字节，不可能满足 d的每个元素的对齐要求，因为这些元素的地址分别为工d、 Xd+ 9、 xd+ l8和心＋27。相反，编译器会为结构 S2分配 12个字节，最后 3个字节是浪费的空间：
偏移 0 4 8 9 12 内容「 i 了
这样一来， d的元素的地址分别为 .Td、 .Td+12、 .Td +24和 .Td+36。只要五是 4的倍数，所有的对齐限制就都可以满足了。
区练习题 3 . 44对下面每个结构声明，确定每个字段的偏移量、结构总的大小，以及在 x86-64下它的对齐要求：
A. struct Pi {inti; char c; int j; chard;};
B. struct P2 { inti; char c; chard; long j; } ;
C. struct P3 { short w[3] ; char c [3] } ;
D. struct P4 { short w[5] ; char *C [3] } ;
E. struct P5 { struct P3 a [2] ; struct P2 t } ; 讫练习题 3. 45 对于下列结构声明回答后续问题：
struct { char *a ; short b, · double c , · char d; float e ; char f; long g; int h , ·
} rec ;
A.这个结构中所有的字段的字节偏移量是多少？ B．这个结构总的大小是多少？
C.重新排列这个结构中的字段，以最小化浪费的空间，然后再给出重排过的结构的字节偏移量和总的大小。</p><p>m强制对齐的情况
对于大多数 x86-64指令来说，保持数据对齐能够提高效率，但是它不会影响程序的行为。另一方面，如果数据没有对齐，某些型号的 Int e l和 AMD处理器对于有些实
现多媒体操作的 SSE指令，就无法正确执行。这些指令对 16字节数据块进行操作，在 SSE单元和内存之间传送数据的指令要求内存地址必须是 16的倍数。任何试图以不满
足对齐要求的地址来访问内存都会导致异常（参见 8 . 1节），默认的行为是程序终止。
因此，任何针对 x86-64处理器的编译器和运行时系统都必须保证分配用来保存可能会被 SSE寄存器读或写的数据结构的内存，都必须满足 16字节对齐。这个要求有两个后果：
·任何内存分配函数 (alloca、 mall o c、 calloc或 realloc)生成的块的起始地址
都必须是 16的倍数。
·大多数函数的栈帧的边界都必须是 1 6字节的倍数。（这个要求有一些例外。）
较近版本的 x 86 -64处理器实现了 AVX多媒体指令。除了提供 SSE指令的超集，支持 AVX的指令并没有强制性的对齐要求。
3. 10 在机器级程序中将控制与数据结合起来
到目前为止，我们已经分别讨论机器级代码如何实现程序的控制部分和如何实现不同的数据结构。在本节中，我们会看看数据和控制如何交互。首先，深入审视一下指针，它
是 C编程语言中最重要的概念之一，但是许多程序员对它的理解都非常浅显。我们复习符号调试器 GDB的使用，用它仔细检查机器级程序的详细运行。接下来，看看理解机器级程序如何帮助我们研究缓冲区溢出，这是现实世界许多系统中一种很重要的安全漏洞。最
后，查看机器级程序如何实现函数要求的栈空间大小在每次执行时都可能不同的情况。</p><ol start=3><li><ol start=10><li>1 理解指针
指针是 C语言的一个核心特色。它们以一种统一方式，对不同数据结构中的元素产生引用。对于编程新手来说，指针总是会带来很多的困惑，但是基本概念其实非常简单。在
此，我们重点介绍一些指针和它们映射到机器代码的关键原则。·每个指针都对应一个类型。这个类型表明该指针指向的是哪一类对象。以下面的指
针声明为例：
int *ip; char **cpp;
变量 ip是一个指向 int类型对象的指针，而 cpp指针指向的对象自身就是一个指向 char类型对象的指针。通常，如果对象类型为 T,那么指针的类型为 T *。特殊的 VO过＊类型代表通用指针。比如说， malloc函数返回一个通用指针，然后通过显式强制类型转换或者赋值操作那样的隐式强制类型转换，将它转换成一个有类型的指针。指针类型不是机器代码中的一部分；它们是 C语言提供的一种抽象，帮助程
序员避免寻址错误。
·
每个指针都有一个值。这个值是某个指定类型的对象的地址。特殊的 NULL(O)值表示该指针没有指向任何地方。</li></ol></li></ol><p>·
指针用＇矿运算符创建。这个运算符可以应用到任何 lvalue类的 C表达式上， lvalue意指可以出现在赋值语句左边的表达式。这样的例子包括变量以及结构、联合和数组的元素。我们已经看到，因为 leaq指令是设计用来计算内存引用的地</p><p>址的，＆运算符的机器代码实现常常用这条指令来计算表达式的值。 . <em>操作符用于间接引用指针。其结果是一个值，它的类型与该指针的类型一致。间接引用是用内存引用来实现的，要么是存储到一个指定的地址，要么是从指定的地
址读取。·数组与指针紧密联系。一个数组的名字可以像一个指针变量一样引用（但是不能修改）。数组引用（例如 a[3]）与指针运算和间接引用（例如＊ (a+ 3)）有一样的效果。
数组引用和指针运算都需要用对象大小对偏移量进行伸缩。当我们写表达式 p+凸这里指针 p的值为 p,得到的地址计算为 p+L · i,这里 L是与 p相关联的数据类
型的大小。
·将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。强
制类型转换的一个效果是改变指针运算的伸缩。例如，如果 p是一个 char</em>类型
的指针，它的值为 p,那么表达式 (int*)p+ 7计算为 p+28,而（ int <em>) (p+ 7) 计算为 p+7。（回想一下，强制类型转换的优先级高于加法。）
·指针也可以指向函数。这提供了一个很强大的存储和向代码传递引用的功能，这些引用可以被程序的某个其他部分调用。例如，如果我们有一个函数，用下面这个原型定义：
int fun(int x, int <em>p);
然后，我们可以声明一个指针 fp,将它赋值为这个函数，代码如下：
int (<em>fp)(int, int</em>);
fp = fun;
然后用这个指针来调用这个函数：
int y = 1;
int result= fp(3, &amp;y);
函数指针的值是该函数机器代码表示中第一条指令的地址。
mm，还詈i函数指针
函数指针声明的语法对程序员新手来说特别难以理解。对于以下声明：
int (<em>f) (int</em>);
要从里（从 “f"开始）往外读。因此，我们看到像“(</em> f)&ldquo;表明的那样， f是一个指针；而 “(<em>f)(int</em>)&ldquo;表明 f是一个指向函数的指针，这个函数以一个 int</em>作为参数。最后，我们看到，它是指向以 in七＊为参数并返回 int的函数的指针。
<em>f两边的括号是必需的，否则声明变成
int <em>f(int</em>);
它会被解读成
(int</em>) f(int*);
也就是说，它会被解释成一个函数原型，声明了一个函数 f,它以一个 int<em>作为参数
并返回一个 int</em>。
Kernigh an和 Ritchie [61, 5. 12节］提供了一个有关阅读 C声明的很有帮助的教程。
3. 10. 2 应用：使用 GDB调试器
GNU的调试器 GDB提供了许多有用的特性，支持机器级程序的运行时评估和分析。对千本书中的示例和练习，我们试图通过阅读代码，来推断出程序的行为。有了 GDB,可以观察正在运行的程序，同时又对程序的执行有相当的控制，这使得研究程序的行为变为可能。
图 3-39给出了一些 GDB命令的例子，帮助研究机器级 x86-64程序。先运行 OBJ-DUMP来获得程序的反汇编版本，是很有好处的。我们的示例都基于对文件 prog运行 GDB,程序的描述和反汇编见 3. 2. 3节。我们用下面的命令行来启动 GDB:
linux> gdb prog
通常的方法是在程序中感兴趣的地方附近设置断点。断点可以设置在函数入口后面，或是一个程序的地址处。程序在执行过程中遇到一个断点时，程序会停下来，并将控制返回给用户。在断点处，我们能够以各种方式查看各个寄存器和内存位置。我们也可以单步跟踪程序，一次只执行几条指令，或是前进到下一个断点。
.d3
A&rsquo;&rdquo;&rsquo;&lt;&rsquo;
日p人
开始和停止
quit run kill
断点
break multstore break * Ox400540 delete 1 delete
执行
stepi stepi 4 nexti continue finish
检查代码
disas disas multstore disas Ox400544 disas Ox400540, Ox40054d print /x $rip
检查数据
print Srax print /x Srax print /t $rax print OxlOO print /x 555 pr].nt /x ($rsp+ 8) print * (long *) Ox7fffffffe818 p rint * (long <em>) ($rsp+ 8) x/2g Ox7fffffffe818 x/20bmultstore
有用的信息
info frame info registers help
效果
退出 GOB 运行程序（在此给出命令行参数） 停止程序
在函数 rnultstore入口处设置断点 在地址 Ox400540处设置断点 删除断点 1 删除所有断点
执行 1条指令 执行 4条指令 类似于 stepi,但以函数调用为单位 继续执行 运行到当前函数返回
反汇编当前函数 反汇编函数 mults七 ore 反汇编位千地址 Ox400544附近的函数 反汇编指定地址范围内的代码 以十六进制输出程序计数器的值
以十进制输出％rax的内容 以十六进制输出 %rax的内容 以二进制输出％rax的内容 输出 OxlOO的十进制表示 输出 555的十六进制表示 以十六进制输出％rsp的内容加上 8 输出位于地址 Ox7fffffffe8 1 8的长整数 输出位于地址％rsp+S处的长整数 检查从地址 Ox7 fffffffe818开始的双 (8字节）字 检查函数 mu l ts七ore的前 20个字节
有关当前栈帧的信息 所有寄存器的值 获取有关 G DB的信息
图 3-39 GDB命令示例。说明了一些 GDB支持机器级程序询试的方式
正如我们的示例表明的那样， GDB的命令语法有点晦涩，但是在线帮助信息（用 GDB的 h el p命令调用）能克服这些毛病。相对千使用命令行接口来访问 GDB,许多程序员更愿意使用 DDD ,它是 GDB的一个扩展，提供了图形用户界面 U
3. 10. 3 内存越界引用和缓冲区溢出
我们已经看到， C对于数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行 ret指令时，就会出现很严重的错误。
一种特别常见的状态破坏称为缓冲区溢出 (buffer overflow)。通常，在栈中分配某个
字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。下面这个程序
示例就说明了这个问题：
I</em> Implementation of library function gets() */ char *gets(char *s)
{ int c:, char *dest = s;
while ((c = getchar()) !=&rsquo;\n&rsquo; && c != EDF) <em>dest++ = c;
if (c == EDF && dest == s) I</em> No characters read *I return NULL;
<em>dest++ =&rsquo;\0&rsquo;; I</em> Terminate string <em>I returns;
}
I</em> Read input line and write it back <em>I void echo()
{
char buf[8]; I</em> Way too small! *I gets(buf); puts(buf);
}
前面的代码给出了库函数 g ets的一个实现，用来说明这个函数的严重问题。它从标准
输入读入一行，在遇到一个回车换行字符或某个错误情况时停止。它将这个字符串复制到
参数． s指明的位置，并在字符串结尾加上 null字符。在函数 echo中，我们使用了 ge ts ,
这个函数只是简单地从标准输入中读入一行，再把它回送到标准输出。
gets的问题是它没有办法确定是否为保存整个字符串分配了足够的空间。在 echo示
例中，我们故意将缓冲区设得非常小只有 8个字节长。任何长度超过 7个字符的字符
串都会导致写越界。
检查 GCC为 echo产生的汇编代码，看看栈是如何组织的：
VO.ld echo()
12345
echo:
subq $24, %rsp Allocate 24 bytes on stack<br>movq %rsp, i!.rdi Compute buf as %rsp<br>call gets Call gets<br>movq %rsp, %rdi Compute buf as %rsp<br>678 call puts Call puts<br>addq $24, %rsp Deallocate stack space<br>ret Return</p><p>图 3-40画出了 e c ho执行时栈的组织。该程序把栈指针减去了 24（第 2行），在栈上分配了 24个字节。字符数组 buf位千栈顶，可以看到，％ rsp被复制到％ r主作为调用 gets和 puts的参数。这个调用的参数和存储的返回指针之间的 16字节是未被使用的。只要用户输入不超过 7个字符， ge ts返回的字符串（包括结尾的 nu ll)就能够放进为 buf分配的空间里。不过，长一些的字符串就会导致 gets覆盖栈上存储的某些信息。随着字符串变长，下面的信息会被破坏：
输入的字符数量 附加的被破坏的状态0<del>7 无9</del>23 未被使用的栈空间24<del>31 返回地址 32 + caller中保存的状态
字符串到 23个字符之前都没有严重的后果，但是超过以后，返回指针的值以调用者及更多可能的保存状态会被破坏。如果存的栈帧 储的返回地址的值被破坏了，那么 re七指返回地址 &lt;—%rsp +24 令（第 8行）会导致程序跳转到一个完全意echo 想不到的位置。如果只看 C代码，根本就的栈帧
不可能看出会有上面这些行为。只有通过h]1[6]1[5]1 [ 4]1[3]1 [ 2]|［ 1]1[0]尸—buf = %rsp
研究机器代码级别的程序才能理解像 图 3 -4 0 echo函数的栈组织。字符数组 buf就在保存gets这样的函数进行的内存越界写的的状态下面。对 buf的越界写会破坏程序的
影响。状态
我们的 echo代码很简单，但是有点太随意了。更好一点的版本是使用 fgets函数，它包括一个参数，限制待读入的最大字节数。家庭作业 3. 71要求你写出一个能处理任意长度输入字符串的 echo函数。通常，使用 gets或其他任何能导致存储溢出的函数，都是不好的编程习惯。不幸的是，很多常用的库函数，包括 strcpy、 strcat和 sprintf,都有一个属性一不需要告诉它们目标缓冲区的大小，就产生一个字节序列 [97]。这样的情况就会导致缓冲区溢出漏洞。亡｀练习题 3 . 46 图 3-41是一个函数的（不太好的）实现，这个函数从标准输入读入一行，
将字符串复制到新分配的存储中，并返回一个指向结果的指针。
考虑下面这样的场景。调用过程 get_line,返回地址等于 Ox400076,寄存器 %rbx等于 Ox01 2345 6789ABCDEF。输入的字符串为 “0123456789012345678901234&rdquo;。程序会因为段错误 (segmentation fault)而中止。运行 GDB,确定错误是在执行 get_line的 re七指令时发生的。 A.填写下图，尽可能多地说明在执行完反汇编代码中第 3行指令后栈的相关信息。
在右边标注出存储在栈中的数字含意（例如“返回地址”)，在方框中写出它们的十六进制值（如果知道的话）。每个方框都代表 8个字节。指出％ rsp的位置。记住，字符 0</del>9的 ASCII代码是 Ox3~ Ox39。
00 00 00 00 00 40 00 76 1返回地址
B.修改你的图，展现调用 gets的影响（第 5行）。 C.程序应该试图返回到什么地址？
D.当 get—line返回时，哪个（些）寄存器的值被破坏了？
E.除了可能会缓冲区溢出以外， get＿巨 ne的代码还有哪两个错误？</p><p>I* This is very low-quality code.
It is intended to illustrate bad programming practices.
See Practice Problem 3.46. *I
char *get_line ()
{
char buf [4] ;
char *result;
gets(buf);
result= malloc(strlen(buf));
strcpy(result, buf);
return result;
}
a) C代码
char *get_line()
0000000000400720 &lt;get_line>:
2 400720: 53 push 1!.rbx
3 400721: 48 83 ec 10 sub $0x10,1!.rsp
Di agram stack at this point
45 400725: 48 89 e7 mov 1儿rsp,。%rdi
400728: e8 73 ff ff ff callq 4006a0 Modify d].agram to sho忖 stack contents at this po].nt
b)对gets调用的反汇编
图 3-4 1练习题 3. 46的 C和反汇编代码
缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码 (exploit code)，另外，还有一些字节
会用一个指向攻击代码的指针覆盖返回地址。那么，执行 ret指令的效果就是跳转到攻击代码。
在一种攻击形式中，攻击代码会使用系统调用启动一个 shell程序，给攻击者提供一组操作系统函数。在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行 ret指令，（表面上）正常返回到调用者。
让我们来看一个例子，在 1988年 11月，著名的 Internet蠕虫病毒通过 Internet以四种不同的方法获取对许多计算机的访问。一种是对 finger守护进程 fingerd的缓冲区溢出攻击， fingerd服务 FINGER命令请求。通过以一个适当的字符串调用 FINGER,蠕虫可以使远程的守护进程缓冲区溢出并执行一段代码，让蠕虫访问远程系统。一旦蠕虫获得了对系统的访问，它就能自我复制，几乎完全地消耗掉机器上所有的计算资源。结果，在安全专家制定出如何消除这种蠕虫的方法之前，成百上千的机器实际上都瘫痪了。这种蠕虫的始作佣者最后被抓住并被起诉。时至今日，人们还是不断地发现遭受缓冲区溢出攻击的系统安全漏洞，这更加突显了仔细编写程序的必要性。任何到外部环境的接口都应该
是“防弹的＂，这样，外部代理的行为才不会导致系统出现错误。</p><p>田日蠕虫和病毒
蠕虫和病毒都试图在计算机中传播它们自己的代码段。正如 Spafford [ l0 5]所述，蠕虫 (wo rm )可以自己运行，并且能够将自己的等效副本传播到其他机器。病毒 (vi rus)能将自己添加到包括操作系统在内的其他程序中，但它不能独立运行。在一些大众媒体中，“病毒“用来指各种在系统间传播攻击代码的策略，所以你可能会听到人们把本来应该叫做“蠕虫”的东西称为“病毒”。
3. 10. 4 对抗缓冲区溢出攻击
缓冲区溢出攻击的普遍发生给计算机系统造成了许多的麻烦。现代的编译器和操作系
统实现了很多机制，以避免遭受这样的攻击，限制入侵者通过缓冲区溢出攻击获得系统控
制的方式。在本节中，我们会介绍一些 Linux上最新 GCC版本所提供的机制。
1栈随机化
为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。在过去，程序的栈地址非常容易预测。对千所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。因此，如果攻击者可以确定一个常见的 Web服务器所使用的栈空间，就可以设计一个在许多机器上都能实施的攻击。以传染病来打个比方，许多系统都容易受到同一种病毒的攻击，这种现象常被称作安全单一化 (security monoculture) [ 96]。
栈随机化的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。实现的方式是：程序开始时，在栈上分配一段 0~ 11字节之间的随机大小的空间，例如，使用分配函数 alloca在栈上分配指定字节数量的空间。程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化。分配的范困 n必须足够大，才能获得足够多的栈地址变化，但是又要足够小，不至千浪费程序太多的空间。
下面的代码是一种确定“典型的＂栈地址的方法：
int main() { long local; printf(&ldquo;local at %p\n&rdquo;, &amp;local); return O;
这段代码只是简单地打印出 main函数中局部变量的地址。在 32位 Linux上运行这段代码 10 000次，这个地址的变化范围为 Oxff7fc59c到 Oxffffd09c,范围大小大约是 2气在更新一点儿的机器上运行 64位 L inux,这个地址的变化范围为 Ox7fff000lb698到 Ox7ffffffaa4a8,范围大小大约是 2 32
0
在 Linux系统中，栈随机化巳经变成了标准行为。它是更大的一类技术中的一种，这类技术称为地址空间布局随机化 (Add ress-Space Layout Ra nd o mization )，或者简称 AS LR
[99]。采用 ASLR,每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域。这就意味着在一台机器上运行一个程序，与在其他机器上运行同样的程序，它们的地址映射大相径庭。这样才能够对抗一些形式的攻击。
然而，一个执著的攻击者总是能够用蛮力克服随机化，他可以反复地用不同的地址进行攻击。一种常见的把戏就是在实际的攻击代码前插入很长一段的 nop（读作 “no op&rdquo;, no operatioin的缩写）指令。执行这种指令除了对程序计数器加一，使之指向下一条指令之外，没有任何的效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序列，到达攻击代码。这个序列常用的术语是“空操作雪橇 (nop sled)&rdquo; [97]，意思是程序
会“滑过“这个序列。如果我们建立一个 256个字节的 nop sled,那么枚举 215 = 32 768个
起始地址，就能破解 n＝产的随机化，这对于一个顽固的攻击者来说，是完全可行的。对于 64位的情况，要尝试枚举沪＝ 16 777 216就有点儿令人畏惧了。我们可以看到栈随机化和其他一些 ASLR技术能够增加成功攻击一个系统的难度，因而大大降低了病毒或者蠕虫的传播速度，但是也不能提供完全的安全保障。讫｝练习题 3 . 47 在运行 Linux版本 2. 6. 16的机器上运行栈梒查代码 10 000次，我们获
得地址的范围从最小的 Oxffffb754到最大的 Oxffffd754。
A.地址的大概范围是多大？
B.如果我们尝试一个有 128字节 nop sled的缓冲区溢出，要想穷尽所有的起始地址，
需要尝试多少次？ 2栈破坏检测计算机的第二道防线是能够检测到何时栈已经被破坏。我们在 ech o函数示例（图 3 -
40)中看到，破坏通常发生在当超越局部缓冲区的边界时。在 C语言中，没有可靠的方法来防止对数组的越界写。但是，我们能够在发生了越界写的时候，在造成任何有害结果之前，尝试检测到它。
最近的 GCC版本在产生的代码中加
人了一种栈保护者 (stack protector)机制，调用者
来检测缓冲区越界。其思想是在栈帧中任的栈帧
何局部缓冲区与栈状态之间存储一个特殊返回地址 &lt;—%rsp + 24 的全丝雀 (canary)值 8,如图 3-42所示
[26, 97]。这个金丝雀值，也称为哨兵值盂记［而可言[订门匠皿门[OJ I+_辽气顷
(guard value)，是在程序每次运行时随机
产生的，因此，攻击者没有简单的办法能图 3-42echo函数具有栈保护者的栈组织（在数组 够知道它是什么。在恢复寄存器状态和从buf和保存的状态之间放了一个特殊的“金函数返回之前，程序检查这个金丝雀值是丝雀＂值。代码检查这个金丝雀值，确定栈
状态是否被破坏）
否被该函数的某个操作或者该函数调用的
某个函数的某个操作改变了。如果是的，那么程序异常中止。
最近的 GCC版本会试着确定一个函数是否容易遭受栈溢出攻击，并且自动插入这种溢出
检测。实际上，对于前面的栈溢出展示，我们不得不用命令行选项 ”-fno-s七ack-pro七ector&rdquo;
来阻止 GCC产生这种代码。当不用这个选项来编译 echo函数时，也就是允许使用栈保护者，得到下面的汇编代码：
void echo() 1 echo : 2 subq $24, %rsp Allocate 24 bytes on stack
9 术语“金丝雀＂源于历史上用这种鸟在煤矿中察觉有毒的气体。
3 movq ．儿fs:40, %rax Retrieve canary<br>4 movq %rax, 8(%rsp) Store on stack<br>5 xorl .!.eax, %eax Zero out reg].ster<br>6 movq %rsp, %rdi Compute buf as .rsp<br>7 cal l gets Call gets<br>8 movq %rsp, %rd i Compute buf as 7.rsp<br>9 call puts Call puts<br>10 movq 8(%rsp), %rax Retrieve canary<br>11 xorq o!.fs:40, %rax Compare to stored value<br>12 je .L9 If=, goto ok<br>13 call stack_chk_fail Stack corrupted&rsquo;<br>14 . L9: ok :<br>15 addq $24, %rsp Deallocate stack space<br>16 ret</p><p>这个版本的函数从内存中读出一个值（第 3行），再把它存放在栈中相对千％rsp偏移量为 8的地方。指令参数％fs : 40指明金丝雀值是用段寻址 (segmented address ing )从内存中读入的，段寻址机制可以追溯到 80 286的寻址，而在现代系统上运行的程序中已经很少见到了。将金丝雀值存放在一个特殊的段中，标志为“只读“，这样攻击者就不能覆盖存储的金丝雀值。在恢复寄存器状态和返回前，函数将存储在栈位置处的值与金丝雀值做比较（通过第 11行的 xorq指令）。如果两个数相同， xorq指令就会得到 0，函数会按照正常的方式完成。非零的值表明栈上的金丝雀值被修改过，那么代码就会调用一个错误处理例程。
栈保护很好地防止了缓冲区溢出攻击破坏存储在程序栈上的状态。它只会带来很小的性能损失，特别是因为 GCC只在函数中有局部 char类型缓冲区的时候才插入这样的代码。当然，也有其他一些方法会破坏一个正在执行的程序的状态，但是降低栈的易受攻击性能够对抗许多常见的攻击策略。立练习题3 . 48 函数 intlen、 len和 iptoa提供了一种很纠结的方式，来计算表示一
个整数所需要的十进制数字的个数。我们利用它来研究 GCC栈保护者措施的一些情况。
int len(char *s) { return strlen(s) ;
}
void iptoa(char *s, long *p) { long val= *p; sprintf(s, &ldquo;%ld&rdquo;, val) ;
}
int intlen(long x) { long v; char buf[12]; v = x; iptoa(buf, &amp;v); return len(buf);
}
下面是 intlen的部分代码，分别由带和不带栈保护者编译：
int intlen(long x)
x in %rdi<br>intlen:<br>int intlen(long x) 2 subq $56, °儿 rsp<br>x in %rdi 3 movq %fs :40, 1!.rax<br>i nt len: 4 movq %rax, 40(%rsp)<br>2 subq $40, %rsp 5 xorl %eax, %eax<br>3 movq %rdi , 24(%rsp) 6 movq %rdi, 8(%rsp)<br>4 leaq 24(%rsp), %rsi 7 leaq 8(%rsp), %rsi<br>5 movq %rsp, %rdi 8 leaq 16(%rsp), %rdi<br>6 call iptoa 9 call iptoa</p><p>a)不带保护者 b)带保护者
A.对于两个版本： buf、 v和金丝雀值（如果有的话）分别在栈帧中的什么位置？ B.在有保护的代码中，对局部变量重新排列如何提供更好的安全性来对抗缓冲区越界攻击？ 3限制可执行代码区域最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能
够存放可执行代码。在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。正如第 9章中会看到的，虚拟内存空间在逻辑上被分成了页 (page)，典型的每页是 2048或者 4096个字节。硬件支待多种形式的内存保护，能够指明用户程序和操作系统内核所允许的访问形式。许多系统允许控制三种访问形式：读（从内存读数据）、写（存储数据到内存）和执行（将内存的内容看作机器级代码）。以前， x86体系结构将读和执行访问控制合并成一个 1位的标志，这样任何被标记为可读的页也都是可执行的。栈必须是既可读又可写的，因而栈上的字节也都是可执行的。已经实现的很多机制，能够限制一些页是可读但是不可执行的，然而这些机制通常会带来严重的性能损失。
最近， AMD为它的 64位处理器的内存保护引入了 “NX" (No-Execute,不执行）位，将读和执行访问模式分开， Intel也跟进了。有了这个特性，栈可以被标记为可读和可写，但是不可执行，而检查页是否可执行由硬件来完成，效率上没有损失。
有些类型的程序要求动态产生和执行代码的能力。例如，”即时 (just-in-tim e )&ldquo;编译技术为解释语言（例如 Java)编写的程序动态地产生代码，以提高执行性能。是否能够将可执行代码限制在由编译器在创建原始程序时产生的那个部分中，取决于语言和操作系统。
我们讲到的这些技术随机化、栈保护和限制哪部分内存可以存储可执行代码是用于最小化程序缓冲区溢出攻击漏洞三种最常见的机制。它们都具有这样的属性，即不需要程序员做任何特殊的努力，带来的性能代价都非常小，甚至没有。单独每一种机制都降低了涌洞的等级，而组合起来，它们变得更加有效。不幸的是，仍然有方法能够攻击计算机 [85, 97]，因而蠕虫和病毒继续危害着许多机器的完整性。
3. 10. 5 支持变长栈帧到目前为止，我们已经检查了各种函数的机器级代码，但它们有一个共同点，即编译器能够预先确定需要为栈帧分配多少空间。但是有些函数，需要的局部存储是变长的。例如，当函数调用 alloca时就会发生这种情况。 alloca是一个标准库函数，可以在栈上分配任意字节数量的存储。当代码声明一个局部变长数组时，也会发生这种情况。虽然本节介绍的内容实际上是如何实现过程的一部分，但我们还是把它推迟到现在才
讲，因为它需要理解数组和对齐。
图 3-43a的代码给出了一个包含变长数组的例子。该函数声明了 n个指针的局部数组 p，这里 n由第一个参数给出。这要求在栈上分配 8n个字节，这里 n的值每次调用该函数时都会不同。因此编译器无法确定要给该函数的栈帧分配多少空间。此外，该程序还产生一个对局部变量 l的地址引用，因此该变蜇必须存储在栈中。在执行工程中，程序必须能够访问局部变扯 l和数组 p中的元素。返回时，该函数必须释放这个栈帧，并将栈指针设置为存储返回地址的位置。
long vframe(long n, long idx, long *q) {
long i;
long *p[n]; p[O] = &amp;i;
for (i = 1; i &lt; n; i ++)
p[i] = q; return *p[idx];
}
a) C代码
long vframe(long n, long idx, long .q) n in .rd工，过x in i.rsi, q辽2 i.rdx Only portions of code shown
1 vframe:<br>2 -pushq %rbp Save old %rbp<br>3 movq %rsp, %rbp Set frame pointer<br>4 subq $16, %rsp Allocate space for i 吆rsp = s1)<br>5 leaq 22(,%rdi,8), %rax<br>6 andq $-16, °儿rax<br>7 subq %rax, %rsp Allocate space for array p (.rsp = sz)<br>8 leaq 7(%rsp), %rax<br>9 shrq $3, %rax<br>10 leaq 0(,%rax,8), %r8 Set 肚8 to &amp;p[O]<br>11 movq %r8, %rcx Set .rcx to &amp;p[O] (.rcx = p)</p><p>Code for in.ltialization loop
.l.ln %rax and on stack, n.ln %rd.l , p in %rcx, q.ln %rdx 12 .13: loop: 13 movq 1!.rdx, C!.rcx,%rax,8) Set p[i] to q 14 addq $1, %rax Increment i
movq %rax, -BC!.rbp) Store on stack 16 .12: 17 movq -8(%rbp), %rax Retrieve i from stack 18 cmpq %rdi, %rax Compare i :n 19 jl . L3 If &lt;, goto loop
Code for function exit 20 leave Restore .rbp and .rsp 21 ret Return
b )生成的部分汇编代码
图 3-43需要使用帧指针的函数。变长数组意味着在编译时无法确定栈帧的大小
为了管理变长栈帧， x86-64代码使用寄存器％ rbp作为帧指针 (frame pointer)（有时称
为基指针 (base pointer)，这也是釭bp中 bp两个字母的由来）。当使用帧指针时，栈帧的组织结构与图 3-44中函数 vframe的情况一样。可以看到代码必须把％ rbp之前的值保存到栈中，因为它是一个被调用者保存寄存器。 8 。帧指针％ rbp -8 6 返回地址保存的％ rbp i （未被使用的） ｝亡｀<br>然后在函数的整个执行过程中，都使得皂 rbp
指向那个时刻栈的位置，然后用固定长度的
局部变篮（例如 l.）相对于％ r bp的偏移最来引
用它们。 8n字节 p<br>图 3-43 6是 GCC为函数 v frame 生成的
部分代码。在函数的开始，代码建立栈帧，
并为数组 p分配空间。首先把％ rbp的当前值 压入栈中，将％ r bp设置为指向当前的栈位置 栈指针％ rsp ——> ｝了 P ( S2</p><p>（第 2 <del>3行）。然后，在栈上分配 16个字节，图 3-44函数 vframe的栈帧结构（该函数使用寄其中前 8个字节用千存储局部变晕 i,而后 8存器％ rbp作为帧指针。图右边的注释供个字节是未被使用的。接着，为数组 p分配练习题 3 . 49所用）空间（第 5</del>11行）。练习题 3. 49探讨了分配多少空间以及将 p放在这段空间的什么位置。当程序到第 11行的时候，巳经 (1)在栈上分配了 8n字节，并 (2)在已分配的区域内放置好数组 p,至少有 8n字节可供其使用。
初始化循环的代码展示了如何引用局部变量 1和 p的例子。第 13行表明数组元素 p
[ i ]被设置为 q。该指令用寄存器％rcx中的值作为 p的起始地址。我们可以看到修改局部变掀 l（第 15行）和读局部变最（第 17行）的例子。 l的地址是引用－8(%rbp)，也就是相对于帧指针偏移量为－8的地方。
在函数的结尾， leave指令将帧指针恢复到它之前的值（第 20行）。这条指令不需要参数，等价于执行下面两条指令：
movq %rbp, %rsp Set stack po.Inter to beg.Inn.Ing of frame popq %rbp Restore saved %rbp and set stack ptr
to end of caller&rsquo;s frame
也就是，首先把栈指针设置为保存％ rbp值的位置，然后把该值从栈中弹出到％ rbp。这个指令组合具有释放整个栈帧的效果。
在较早版本的 x86代码中，每个函数调用都使用了帧指针。而现在，只在栈帧长可变的情况下才使用，就像函数 vframe的情况一样。历史上，大多数编译器在生成 IA32代码时会使用帧指针。最近的 GCC版本放弃了这个惯例。可以看到把使用帧指针的代码和不使用帧指针的代码混在一起是可以的，只要所有的函数都把％ rbp当做被调用者保存寄存器来处理即可。江练习题3 . 49 在这道题中，我们要探究图 3-43b第 5<del>11行代码背后的逻辑，它分配
了变长大小的数组 p。正如代码的注释表明的， s］表示执行第 4行的 subq指令之后栈指针的地址。这条指令为局部变量 l分配空间。 S 2表示执行第 7行的 subq指令之后栈指针的值。这条指令为局部数组 p分配存储。最后， p表示第 10</del>11行的指令赋给寄存器％r8和％ rc x的值。这两个寄存器都用来引用数组 p。
图 3-44的右边画出了 S 1、 S2和 p指示的位置。图中还画出了 S2和 p的值之间可能有一个偏移量为 e2字节的位置，该空间是未被使用的。数组 p的结尾和 S1指示的位置之间还可能有一个偏移量为 e 1字节的地方。 A.用数学语言解释第 5 ~ 7行中计算 s2的逻辑。提示：想想一 16的位级表示以及它在
第 6行 andq指令中的作用。 B.用数学语言解释第 8<del>10行中计算 p的逻辑。提示：可以参考 2 . 3. 7节中有关除以 2的幕的讨论。
C.对于下面 n和 S 1的值，跟踪代码的执行，确定 S2、 p、 e1和 e2的结果值。
n SI S2 p e, e2
3 2 065 6 2 064
D.这段代码为．s 2和 p的值提供了什么样的对齐属性？
3. 11 浮点代码 处理器的浮点体系结构包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括： ·如何存储和访问浮点数值。通常是通过某种寄存器方式来完成。 ·对浮点数据操作的指令。 ·向函数传递浮点数参数和从函数返回浮点数结果的规则。 ·函数调用过程中保存寄存器的规则例如，一些寄存器被指定为调用者保存，而其他的被指定为被凋用者保存。简要回顾历史会对理解 x86 -64的浮点体系结构有所帮助。 1997年出现了 Pentium/ MMX, Int el和 AMD都引入了持续数代的媒体 (media)指令，支持图形和图像处理。这些指令本意是允许多个操作以并行模式执行，称为单指令多数据或 SIMD（读作 sim-dee)。在这种模式中，对多个不同的数据并行执行同一个操作。近年来，这些扩展有了长足的发展。名字经过了一系列大的修改，从 MMX到 SSE (Streaming SIMD Extension,流式 SIMD扩展），以及最新的 A VX(Advanced Vector Extension,高级向量扩展）。每一代中，都有一些不同的版本。每个扩展都是管理寄存器组中的数据，这些寄存器组在 MMX中称为 “MM"寄存器， SSE中称为 “XMM"寄存器，而在 AVX中称为 &ldquo;YMM"寄存器； MM寄存器是 64位的， XMM是 128位的，而YMM是 256位的。所以，每个YMM寄存器可以存放 8个 32位值，或 4个 64位值，这些值可以是整数，也可以是浮点数。 2000年 Pen tium 4中引入了 SSE2,媒体指令开始包括那些对标量浮点数据进行操作的指令，使用 XMM或 YMM寄存器的低 32位或 64位中的单个值。这个标量模式提供了一组寄存器和指令，它们更类似千其他处理器支持浮点数的方式。所有能够执行 x86-6 4代码的处理器都支持 SSE2或更高的版本，因此 x86-64浮点数是基于 SSE或 AVX的，包括传递过程参数和返回值的规则 [ 77]。我们的讲述基于 AVX2,即 AVX的第二个版本，它是在 2013年 Core i7 Haswell处理器中引入的。当给定命令行参数－mavx2时， GCC会生成 AVX2代码。基于不同版本的 SSE以及第一个版本的 AVX的代码从概念上来说是类似的，不过指令名和格式有所不同。我们只介绍用 GCC编译浮点程序时会出现的那些指令。其中大部分是标量 AVX指令，我
们也会说明对整个数据向量进行操作的指令出现的情况。后文中的网络旁注 OPT: SIMD 更全面地说明了如何利用 SSE和 AVX的 SIMD功能读者可能希望参考 AMD和 Inte l对每条指令的说明文档[ 4, 51]。和整数操作一样，注意我们表述中使用的 ATT格式不同于这些文档中使用的 Intel格式。特别地，这两种版本中列出指令操作数的顺序是不同的。
如图 3-45所示， AVX浮点体系结构允许数据存储在 16个 YMM寄存器中，它们的名字为％ ymmO</del> %ymm15。每个 YMM寄存器都是 256位 (32字节）。当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低 32位（对千 float)或 64位（对于 double )。汇编代码用寄存器的 SSE XMM寄存器名字％ xmm0~%xmm15来引用它们，每个 XMM寄存器都是对应的 YMM寄存器的低 1 28位 (16字节）。
255 127
。
[%ymm0
［兮 ymml
1%ymm2 [%ymm3 1%ymm4 [%ymm5 1%ymm6 [%ymm7 1%ymm8 [%ymm9 1%ymml0 [%ymmll 1%ymml2 [%ymml3 1%ymml4 %xmm0 %xmml %xmm2 %xmm3</p><dl><dt>尸</dt><dt>[%xmm5</dt><dt>尸mm6</dt><dt>[%xmm7</dt><dd></dd></dl><p>[%xmm8
%xmm9
%xmm10
%xmmll
%xmml2
号 xmm13
..
%%45
xx11
mmmm
!st FP arg返回值 2ndFP参数 3rd FP参数
4thFP参数
I5th FP参数 6th FP参数 7th FP参数 8th FP参数 调用者保存调用者保存调用者保存
］调用者保存］调用者保存］调用者保存］调用者保存
．
一一
l%ymml5 I调用者保存
图 3 -45媒体寄存器。这些寄存器用于存放浮点数据。每个 YMM寄存器保存 32个字节。低 16字节可以作为 XMM寄存器来访间
3. 11. 1 浮点传送和转换操作图 3-46给出了一组在内存和 XMM寄存器之间以及从一个 XMM寄存器到另一个不
做任何转换的传送浮点数的指令。引用内存的指令是标量指令，意味着它们只对单个而不是一组封装好的数据值进行操作。数据要么保存在内存中（由表中的 M3 2和 M6 .指明），要么保存在 XMM寄存器中（在表中用 X表示）。无论数据对齐与否，这些指令都能正确执行，不过代码优化规则建议 32位内存数据满足 4字节对齐， 64位数据满足 8字节对齐。内存引用的指定方式与整数 MOV指令的一样，包括偏移量、基址寄存器、变址寄存器和伸缩因子的所有可能的组合。
指令 源 目的 描述<br>vmovss M32 X 传送单精度数<br>vmovss X M坟 传送单精度数<br>vmovsd M6, X 传送双精度数<br>vrnovsd X M6.1 传送双精度数<br>vmovaps X X 传送对齐的封装好的单精度数<br>vmovapd X X 传送对齐的封装好的双精度数</p><p>图 3-46浮点传送指令。这些操作在内存和寄存器之间以及一对寄存器之间传送值 (X , XMM 寄存器（例如％ xmm3); M 32 : 32位内存范围； M 64: 6 4位内存范围）
GCC只用标量传送操作从内存传送数据到 XMM寄存器或从 XMM寄存器传送数据到内存。对于在两个 XMM寄存器之间传送数据， GCC会使用两种指令之一，即用 vmovaps传送单精度数，用 vmovapd传送双精度数。对于这些情况，程序复制整个寄存器还是只复制低位值既不会影响程序功能，也不会影响执行速度，所以使用这些指令还是针对标量数据的指令没有实质上的差别。指令名字中的字母｀矿表示 “aligned（对齐的） ”。当用于读写内存时，如果地址不满足 1 6字节对齐，它们会导致异常。在两个寄存器之间传送数据，绝不会出现错误对齐的状况。
下面是一个不同浮点传送操作的例子，考虑以下 C函数
float float_mov(float vl, float *Src, float *dst) { float v2 = *src; *dst = vl; return v2;
}
与它相关联的 x86-64汇编代码为
float float_mov(float v1, float *Src, float *dst)
v1 in %xmm0, src in %rdi, dst in %rsi
12345
float_mov: vrnovaps %xmm0, %xmm1 Copy v1 vrnovss (%rdi), %xmm0 Read v2 from src vrnovss %xmm1, (%rsi) Write v1 to dst ret Return v2 in .xmmO
这个例子中可以看到它使用了 vrnovap s指令把数据从一个寄存器复制到另一个，使用了 vrnovss指令把数据从内存复制到 XMM寄存器以及从 XMM寄存器复制到内存。
图 3-4 7和图 3-48给出了在浮点数和整数数据类型之间以及不同浮点格式之间进行转换的指令集合。这些都是对单个数据值进行操作的标量指令。图 3-47中的指令把一个从 XMM寄存器或内存中读出的浮点值进行转换，并将结果写入一个通用寄存器（例如 %rax、 %ebx等）。把浮点值转换成整数时，指令会执行截断 ( truncation)，把值向 0进行舍
入，这是 C和大多数其他编程语言的要求。
指令源目的描述 vcvttss2si X/ M32 R32 用截断的方法把单精度数转换成整数 vcvttsd2si X/ M64 R32 用截断的方法把双精度数转换成整数 vcvttss2siq X/M32 R54 用截断的方法把单精度数转换成四字整数 vcvttsd2siq X/ M64 R64 用截断的方法把双精度数转换成四字整数
图 3 -47双操作数浮点转换指令。这些操作将浮点数转换成整数 (X: XMM寄存器（例如％ xrnrn3) ; R32 : 32位通用寄存器（例如％eax); RG,: 64位通用寄存器（例如％ ra x); M32 : 3 2位内存范圉； M6, : 64位内存范围）
指令源l源2目的描述
vcvtsi2ss M32/R32 X X 把整数转换成单精度数 vcvt si2sd M32/R32 X X 把整数转换成双精度数 vcvtsi2s sq M64IR64 X X 把四字整数转换成单精度数 vcvtsi2sdq M64 IR64 X X 把四字整数转换成双精度数
图 3 -48三操作数浮点转换指令。这些操作将第一个源的数据类型转换成目的的数据类型。第二个源值对结果的低位字节没有影响 CX: XMM寄存器（例如％ xmm3) ; M32 : 32位内存范围； M&rdquo; : 64位内存范匪）
图 3-48中的指令把整数转换成浮点数。它们使用的是不太常见的三操作数格式，有两个源和一个目的。第一个操作数读自千内存或一个通用目的寄存器。这里可以忽略第二个操作数，因为它的值只会影响结果的高位字节。而我们的目标必须是 XMM寄存器。在最常见的使用场景中，第二个源和目的操作数都是一样的，就像下面这条指令：
vcvtsi2sdq %rax, i!.xmm1, o!.xmm1
这条指令从寄存器％ rax读出一个长整数，把它转换成数据类型 double,并把结果存放进 XMM寄存器％ xmml的低字节中。最后，要在两种不同的浮点格式之间转换， GCC的当前版本生成的代码需要单独说明。假设％xmmO的低位 4字节保存着一个单精度值，很容易就想到用下面这条指令
vcvtss2sd ~!.xmmO, %xmm0, %xmm0
把它转换成一个双精度值，并将结果存储在寄存器％xmmO的低 8字节。不过我们发现 GCC生成的代码如下
Conversion from single to double precision vunpcklps %xmm0, %xmm0, %xmm0 Replicate first vector element 2 vcvtps2pd %xrnm0, %xmm0 Convert two vector elements to double
vunpcklps指令通常用来交叉放置来自两个 XMM寄存器的值，把它们存储到第三个寄存器中。也就是说，如果一个源寄存器的内容为字 [s3 , s2, s1, s。]，另一个源寄存器为字 [d3 , dz, d1, d。]，那么目的寄存器的值会是 [s1, d1, s。 , d。 ]。在上面的代码中，我们看到三个操作数使用同一个寄存器，所以如果原始寄存器的值为 [x3 , Xz, X1, X。]，那么该指令会将寄存器的值更新为值 [x 1 , X1, Xo, X。]。 VCV七ps2pd指令把源 XMM寄存器中的两个低位单精度值扩展成目的 XMM寄存器中的两个双精度值。对前面 vunpcklps指令的结果应用这条指令会得到值 [dxo , dx。]，这里 dxo是将 x转换成双精度后的结果。
即，这两条指令的最终效果是将原始的％ xmmO低位 4字节中的单精度值转换成双精度值，
再将其两个副本保存到％ xmmO中。我们不太清楚 GCC为什么会生成这样的代码，这样做
既没有好处，也没有必要在 XMM寄存器中把这个值复制一遍。
对于把双精度转换为单精度， GCC会产生类似的代码：
Conversion from double to single precision vmovddup %xmm0, %xmm0 Rep止 cate first vector element vcvtpd2psx ~儿xmmO, %xmm0 Convert two vector elements to single
假设这些指令开始执行前寄存器％xmmO保存着两个双精度值 [.:r口工。］。然后 vmovddup指
令把它设置为 [.:ro &lsquo;X。 ]。 vcvtpd2psx指令把这两个值转换成单精度，再存放到该寄存器
的低位一半中，并将高位一半设置为 o,得到结果 [ 0. 0, 0. 0, Xo ,工。］（回想一下，浮点值
0 .0是由位模式全 0表示的）。同样，用这种方式把一种精度转换成另一种精度，而不用下
面的单条指令，没有明显直接的意义：
vcvtsd2ss %xmm0, %xmm0, %xmm0
下面是一个不同浮点转换操作的例子，考虑以下 C函数
double fcvt(int i, float *fp, double *dp, long *lp)
{
float f = *fp; doubled= *dp; long 1 = *lp; *lp = (long) d;
.1
.
*fp = (float) &rsquo; *dp = (double) l; return (double) f;
}
以及它对应的 x86-64汇编代码
double fcvt (int i, float *fp, double *dp, long *lp)
i in i,edi, fp in .rsi, dp in .rdx, lp in .rcx 1 fcvt : 2 vmovss (%rsi), %xmm0 Get f = .fp
.
rcx). Get 1 vcvttsd2siq (%rdx).(%rdx),缸8 Get d = *dp and convert to long
movq (%rcx), %rax
= *lp %r8 movq %r8,r8. (%rcx) Store at lp
1&mldr;-____
vcvtsi2ss %edi,edi, %xmm1, Convert i to float
%xmm1. %xmm1
VJDOVSS %xmm1, (%rsi)</p><p>nml. Store at fp vcvtsi2sdq %rax. %xmm1. %xmm1 Convert 1 to double vmovsd o!.xmm1, (%rdx)</p><p>nml. Store at dp
The following two instructions convert f to double 10 vunpcklps %xmm0, %xmm0, %xmm0 11 vcvtps2pd %xmm0, %xmm0 12 ret Return f
fcvt的所有参数都是通过通用寄存器传递的，因为它们既不是整数也不是指针。结
果通过寄存器％xmmO返回。如图 3-45中描述的，这是 float或 double值指定的返回寄存
器。在这段代码中，可以看到图 3-46～图 3 -4 8中的许多传送和转换指令，还可以看到
GCC将单精度转换为双精度的方法。
心练习题 3 . 50对于下面的 C代码，表达式 vall<del>val4分别对应程序值 1、 f、 d和 1 :
double fcvt2(int *ip, float *fp, double *dp , long 1)
{
inti= *ip; float f = *fp; doubled= *dp; *ip = (int) vall ; *fp = (float) val2; *dp = (double) val3; return (double) val4;
}
根据该函数如下的 x86 -64代码，确定这个映射关系：
double fcvt2(int .ip, float .fp, double .dp, long 1) ip in i.rdi, fp in i.rsi, dp in i.rdx, 1 in i.rcx Result returned in 7.xmmO fcvt2:
2 movl (%rdi), %eax 3 vmovss (%rsi), %xmrn0 4 vcvttsd2si (%rdx), 1儿r8d 5 movl %r8d, (%rdi) 6 vcvtsi2ss %eax, %xmm1 , %xmm1 7 vmovss o!.xmml, (%rsi) 8 vcvtsi2sdq %rcx , %xmm1, %xmm1 9 vmovsd o!.xmml, (%rdx)
10 vunpcklps %xmm0 , %xmmO, %xmm0 11 vcvtps2pd %xmm0, %xmm0 12 ret
d练习题 3. 51 下面的 C函数将类型为 s rc_t的参数转换为类型为 dst—t的返回值，
这里两种数据类型都用 typedef定义：
dest_t cvt(src_t x)
{
dest_t y = (dest_t) x; return y ;
}
在 x86-64上执行这段代码，假设参数 x在％ xmmO中，或者在寄存器％ rdi的某个适当的命名部分中（即％立江或％ edi)。用一条或两条指令来完成类型转换，并把结果
值复制到寄存器％ r a x的某个适当命名部分中（整数结果），或％ xmmO中（浮点结果）。给出这条或这些指令，包括源和目的寄存器。
TX Ty 指令
long double vcvtsi 2sdq %rdi, %xmm0 double int double float long float float long
3. 11. 2 过程中的浮点代码
在 x86-64中， XMM寄存器用来向函数传递浮点参数，以及从函数返回浮点值。如图
3-45所示，可以看到如下规则：
. XMM寄存器％xrnmo</del> %xmm7最多可以传递 8个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。
·函数使用寄存器％
xmmO来返回浮点值。</p><p>·所有的
XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。</p><p>当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点值通过 XMM寄存器传递。也就是说，参数到寄存器的映射取决千它们的类型和排列的顺序。下面是一些例子：
double fl(int x, double y, long z);
这个函数会把 x存放在％ edi中， y放在％xmmO中，而 z放在％rsi中。
double f2(double y, int x, long z);
这个函数的寄存器分配与函数 fl相同。
double fl(float x, double *Y, long .z);
这个函数会将 x放在％xmmO中， y放在％r生中，而 z放在％r江中。让、练习题 3 . 52 对于下面每个函数声明，确定参数的寄存器分配：
A. double gl(double a, long b, float c, int d);
B. double g2(int a, double .b, float .c, long d);
C. double g3(double .a, double b, int c, float d) ;
D. double g4(float a, int *b, float c, double d) ;</p><ol start=3><li><ol start=11><li>3 浮点运算操作
图 3-49描述了一组执行算术运算的标量 AVX2浮点指令。每条指令有一个 ( S 1 )或两个 &lt;S1, S2)源操作数，和一个目的操作数 D。第一个源操作数 S1可以是一个 XMM寄存器或一个内存位置。第二个源操作数和目的操作数都必须是 XMM寄存器。每个操作都有一
条针对单精度的指令和一条针对双精度的指令。结果存放在目的寄存器中。
单精度 双精度 效果 描述<br>vaddss vaddsd D+-S2+S1 浮点数加<br>vs ubss vsubsd D&mdash;S2- S1 浮点数减<br>vmulss vmulsd D.-S2X S1 浮点数乘<br>vdi vss vdivsd D-Sz/S1 浮点数除<br>vrnaxs s vmaxsd D-max(S2, S1) 浮点数最大值<br>vmi nss vminsd D-mm(Sz , 5 1) 浮点数最小值<br>sq r tss sqrtsd D-ffi 浮点数平方根</li></ol></li></ol><p>图 3 -4 9标量浮点算术运算。这些指令有一个或两个源操作数和一个目的操作数来看一个例子，考虑下面的浮点函数： double fu卫ct(double a, float x, double b, int i)
{
return a<em>x -b/i;
}
x86-64代码如下：
double funct(double a, float x, double b,].nt].)<br>a ].n %xmm0, x].n %xmm1, b].n %xmm2,]. ].n %ed].<br>funct:<br>The following two].nstructions convert x to double<br>2 vunpcklps %xmm1, %xmm1, %xmm1<br>3 vcvtps2pd %xmm1, %xmm1<br>4 vmulsd %xmm0, %xmm1, %xmm0 Mult].ply a by x<br>s vcvtsi2sd i!.edi, %xmm1, %xmm1 Convert i to double<br>6 vdivsd %xmm1, i!.xmm2, %xmm2 Compute b/].<br>7 vsubsd %xmm2, %xmm0, %xmm0 Subtract from a</em>x<br>8 ret Return</p><p>三个浮点参数 a、 x和 b通过 XMM寄存器％xrnmO~ %xrnm2传递，而整数参数通过寄存器％edi传递。标准的双指令序列用以将参数 x转换为双精度类型（第 2~3行）。另一条转换指令用来将参数 l转换为双精度类型（第 5行）。该函数的值通过寄存器％xrnmO返回。
练习题3 . 53 对于下面的 C函数， 4个参数的类型由 typedef定义：
double functl(argl_t p, arg2_t q, arg3_t r, arg4_t s)
return p/(q+r) -s;
编译时， GCC产生如下代码：
double funct1(arg1_t p, arg2_t q, arg3_t r, arg4_t s)
funct1: 2 vcvtsi2ssq %rsi, %xmm2, %xmm2 3 vaddss %xmm0, %xmm2, %xmm0
4 vcvtsi2ss %edi, %xmm2, %xmm2 5 vdivss %xmm0, %xmm2, %xmm0 6 vunpcklps %xmm0, %xmm0, %xmm0 7 vcvtps2pd %xmm0, %xmm0 8 vsubsd %xmm1, %xmm0, %xmm0 9 ret
确定 4个参数类型可能的组合（答案可能不止一种）。讫练习题3 . 54 函数 func七 2具有如下原型：
double funct2(double w, int x, floaty, long z);
GCC为该函数产生如下代码：
double funct2(double甘， int x, float y, long z) 甘 in %xmm0, x in .edi , y in %xmm1, z in .rsi funct2 :
2 vcvtsi2ss . %edi, %xmm2,。%xmm2
3 vmulss %xmm1, %xmm2, %xmm1 4 vunpcklps %xmm1, i/.xmml, %xmm1 5 vcvtps2pd %xmm1, %xmm2 6 vcvtsi2sdq %rsi, %xmm1, %xmm1 7 vdivsd %xmm1, %xmm0, %xmm0 8 vsubsd %xmm0, %xmm2 , %xmm0 9 ret
写出 funct2的 C语言版本。
3. 1 1. 4 定义和使用浮点常数
和整数运算操作不同， AVX浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常最值分配和初始化存储空间。然后代码在把这些值从内存读入。下面从摄氏度到华氏度转换的函数就说明了这个问题：
double cel2fahr(double temp)
{
return 1.8 * temp + 32.0;
}
相应的 x86-64汇编代码部分如下：
double cel2fahr(double temp)<br>t emp in 7.xmmO<br>cel2fahr:<br>2 vmulsd. LC2 (%rip), %xmm0, 1!.xmmO Multiply by 1.8<br>3 vaddsd.LC3(%rip), %xmm0, %xmm0 Add 32.0<br>4 ret<br>5 .LC2:<br>6 . long 3435973837 Low-order 4 bytes of 1.8<br>7 . long 1073532108 High-order 4 bytes of 1.8<br>8 .LC3:<br>90 1 .long .long 0 1077936128 Low-order 4 bytes of 32.0 H.Igh-order 4 bytes of 32.0</p><p>可以看到函数从标号为． LC2的内存位置读出值 1. 8&rsquo;从标号为． LC3的位置读入值 32. 0。观察这些标号对应的值，可以看出每一个都是通过一对． long声明和十进制表示的值指定的。该怎样把这些数解释为浮点值呢？看看标号为． LC2的声明，有两个值： 3435973837 (Oxcccccccd)和 1073532108(0x3ffccccc)。因为机器采用的是小端法字节顺序，第一个值给出的是低位 4字节，第二个给出的是高位 4字节。从高位字节，可以抽取指数字段为 Ox3ff0023)，减去偏移 1023得到指数 0。将两个值的小数位连接起来，得到小数字段 Oxccccccccccccd,二进制小数表示为 0. 8,加上隐含的 1得到 1.8。 ;练习题3 . 55 解释标号为． LC3处声明的数字是如何对数字 32.0编码的。
3. 11 . 5 在浮点代码中使用位级操作
有时，我们会发现 GCC生成的代码会在 XMM寄存器上执行位级操作，得到有用的浮点结果。图 3-50展示了一些相关的指令，类似于它们在通用寄存器上对应的操作。这些操作都作用千封装好的数据，即它们更新整个目的 XMM寄存器，对两个源寄存器的所有位都实施指定的位级操作。和前面一样，我们只对标量数据感兴趣，只想了解这些指令对目的寄存器的低 4或 8字节的影响。从下面的例子中可以看出，运用这些操作通常可以简单方便地操作浮点数。
单精度双精度效果 描述
vxorps vorpd D-S2-S1 位级异或 (EXCLUSIVE-OR)vandps andpd D-S2&.S1 位级与 (AND)
图 3-50对封装数据的位级操作（这些指令对一个 XMM寄存器中的所有 12 8位进行布尔操作）
练习题3 . 56 考虑下面的 C函数，其中 EXPR是用＃ define定义的宏： double simplefun(double x) { return EXPR(x);
}
下面，我们给出了为不同的 EXPR定义生成的 AVX2代码，其中， x的值保存在％ xmrnO中。这些代码都对应于某些对浮点数值有用的操作。确定这些操作都是什么。要理解从内存中取出的常数字的位模式才能找出答案。
A. 1 vmovsd .LC1(%rip), %xmm1 2 vandpd o!.xmm1, %xmmO, 1!.xmmO 3 .LC1: 4 .long 4294967295 5 .long 2147483647 6 .long 。 7 .long 。
B. 1 vxorpd %xmm0, 1!.xmmO, %xmm0
C. 1 vmovsd .LC2(%rip), %xmm1 2 vxorpd %xmm1, %xmm0, %xmm0 3 .LC2: 4 .long 。 5 .long -2147483648 6 .long 。 7 .long 。
3.11.6 浮点比较操作
AVX2提供了两条用于比较浮点数值的指令：
指令 基于描述ucomiss 51, 52 S2-S1 比较单精度值ucomisd 51, 52 S2-S1 比较双精度值
这些指令类似千 CMP指令（参见 3 . 6节），它们都比较操作数 S1和 S2（但是顺序可能与预计的相反），并且设置条件码指示它们的相对值。与 cmpq一样，它们遵循以相反顺序列出操作数的 ATT格式惯例。参数 S2必须在 XMM寄存器中，而 S1可以在 XMM寄存器
中，也可以在内存中。
浮点比较指令会设置三个条件码：零标志位 ZF、进位标志位 CF和奇偶标志位 PF。 3. 6. 1节中我们没有讲奇偶标志位，因为它在 GCC产生的 x86代码中不太常见。对于整数操作，当最近的一次算术或逻辑运算产生的值的最低位字节是偶校验的（即这个字节中有偶数个 1)，那么就会设置这个标志位。不过对于浮点比较，当两个操作数中任一个是 NaN时，会设置该位。根据惯例， C语言中如果有个参数为 NaN,就认为比较失败了，这个标志位就被用来发现这样的条件。例如，当 x为 NaN时，比较 x==x都会得到 0。
条件码的设置条件如下：
顺序 S2:S1 CF ZF PF
无序的 1
S2&lt; S1 。。
S2= S1 。。
S2> S1 。。。
当任一操作数为 NaN时，就会出现无序的情况。可以通过奇偶标志位发现这种情况。通常 JP勺 ump on parity)指令是条件跳转，条件就是浮点比较得到一个无序的结果。除了这种情况以外，进位和零标志位的值都和对应的无符号比较一样：当两个操作数相等时，设置 ZF;当 S2 &lt;S]时，设置 CF。像 ja和 j b这样的指令可以根据标志位的各种组合进行条件跳转。
来看一个浮点比较的例子，图 3-5la中的 C函数会根据参数 x与 0. 0的相对关系进行分类，返回一个枚举类型作为结果。 C中的枚举类型是编码为整数的，所以函数可能的值为： O(NEG), lCZERO), 2(POS)和 3(0THER)。当 x的值为 NaN时，会出现最后一种结果。
typedef enum {NEG, ZERO, POS, OTHER} r ange_t;
range_t find_range(float x)
{
int result; if (x &lt; 0) result= NEG; else if (x == 0) result= ZERO; else if (x > 0) result= POS; else result= OTHER; return result;
}
a) C代码
range_t find_range(tloat x)
x in %xmm0<br>1 find_range:<br>2 vxorps %xmm1, i!.xmml, %xmm1 Set %xmm1 = 0<br>3 vucom1ss %xmm0, %xmm1 Compare 0:x<br>4 ja .L5 If>, goto neg<br>5 vucom1ss %xmrn1, %xmrn0 Compare x :O<br>6 j p .L8 If NaN, goto posornan<br>7 movl $1, %eax result= ZERO<br>8 je .L3 If=, goto done<br>9 .L8: posornan:<br>10 vucom1ss .LCO(%rip), 。%xmm0 Compare x:O<br>11 setbe %al Set result= NaN? 1 : 0<br>12 movzbl %al, 1儿eax Zero-extend<br>13 addl $2, %eax result += 2 (POS for > 0, OTHER for NaN)<br>14 ret Return<br>15 . L5 : neg:<br>16 movl $0, %eax result= NEG<br>17 .L3: done :<br>18 rep; ret Return</p><p>b)产生的汇编代码图 3-51浮点代码中的条件分支说明
GCC为丘nd_range生成图 3-516中的代码。这段代码的效率不是很高：它比较了 x
和 0.0三次，即使一次比较就能获得所需的信息。它还生成了浮点常数两次：一次使用
vxorps,另一次从内存读出这个值。让我们追踪这个函数，看看四种可能的比较结果：
X &lt; 0. 0 第 4行的 ja分支指令会选择跳转，跳转到结尾，返回值为 0。
x=O. 0 ja（第 4行）和 jp（第 6行）两个分支语句都会选择不跳转，但是 je分支（第 8
行）会选择跳转，以％ eax等于 1返回。
X > 0. 0 这三个分支都不会选择跳转。 setbe（第 11行）会得到 o,addl指令（第 13
行）会把它增加，得到返回值 2。
x=NaN jp分支（第 6行）会选择跳转。第三个 vucomi ss指令（第 1 0行）会设置进
位和零标志位，因此 setbe指令（第 11行）和后面的指令会把％ eax设置为 1。 addl指令
（第 13行）会把它增加，得到返回值 3。
家庭作业 3. 73和 3. 74中，你需要试着手动生成 find_range更高效的实现。
霆练习题3 . 57 函数 funct3有如下原型：
double funct3(int *ap, double b, long c, float *dp);
对于此函数， GCC产生如下代码：
double funct3(.1nt .ap, double b, l ong c, float .dp)
ap.1n .rd.1 , b.1n Y.xmmO, c.1n .rs.1 , dp.1n Y.rdx 123
funct3 : vmovss (%rdx), %xmm1 vcvtsi2sd (%rdi), %xmm2, %xmm2
4
vucomisd %xmm2, %xrnm0
567 jbe.LS vcvtsi2ssq %rsi, %xrnrn0, %xmm0 vmulss %xmm1, %xmmO, %xmm1
89 vunpcklps %xmm1, %xmm1, %xmm1 vcvtps2pd %xmm1, %xmm0
o.1234567
11
ret
. L8 : 1
vaddss %xmm1, %xmm1, %xmm1 11 vcvtsi2ssq %rsi, %xmm0, %xmm0
vaddss %xmm1, %xmm0, %xrnm0 1 vunpcklps %xmm0, %xmm0, %xmm0 11 vcvtps2pd %xmm0, i!.xmmO
ret
写出 funct3的 C版本。
3. 11. 7 对浮点代码的观察结论
我们可以看到，用 AVX2为浮点数上的操作产生的机器代码风格类似于为整数上的操
作产生的代码风格。它们都使用一组寄存骈来保存和操作数据值，也都使用这些寄存器来
传递函数参数。
当然，处理不同的数据类型以及对包含混合数据类型的表达式求值的规则有许多复杂
之处，同时， AVX2代码包括许多比只执行整数运算的函数更加不同的指令和格式。
AVX2还有能力在封装好的数据上执行并行操作，使计算执行得更快。编译器开发者
正致力于自动化从标量代码到并行代码的转换，但是目前通过并行化获得更高性能的最可靠的方法是使用 GCC支持的、操纵向量数据的 C语言扩展。参见原书 546页的网络旁注 OPT: SIMD,看看可以怎么做到这样。
3. 12 小结
在本章中，我们窥视了 C语言提供的抽象层下面的东西，以了解机器级编程。通过让编译器产生机器级程序的汇编代码表示，我们了解了编译器和它的优化能力，以及机器、数据类型和指令集。在第 5章，我们会看到，当编写能有效映射到机器上的程序时，了解编译器的特性会有所帮助。我们还更完整地了解了程序如何将数据存储在不同的内存区域中。在第 12章会看到许多这样的例子，应用程序员需要知道一个程序变最是在运行时栈中，是在某个动态分配的数据结构中，还是全局程序数据的一部分。理解程序如何映射到机器上，会让理解这些存储类型之间的区别容易一些。
机器级程序和它们的汇编代码表示，与 C程序的差别很大。各种数据类型之间的差别很小。程序是以指令序列来表示的，每条指令都完成一个单独的操作。部分程序状态，如寄存器和运行时栈，对程序员来说是直接可见的。本书仅提供了低级操作来支持数据处理和程序控制。编译器必须使用多条指令来产生和操作各种数据结构，以及实现像条件、循环和过程这样的控制结构。我们讲述了 C语言和如何编译它的许多不同方面。我们看到 C语言中缺乏边界检查，使得许多程序容易出现缓冲区溢出。虽然最近的运行时系统提供了安全保护，而且编译器帮助使得程序更安全，但是这已经使许多系统容易受到恶意入侵者的攻击。
我们只分析了 C到 x86-64的映射，但是大多数内容对其他语言和机器组合来说也是类似的。例如，
编译 C+＋与编译 C就非常相似。实际上， C++的早期实现就只是简单地执行了从 C+＋到 C的源到源的转换，并对结果运行 C编译器，产生目标代码。 C+＋的对象用结构来表示，类似于 C的 struct。 C++的方法是用指向实现方法的代码的指针来表示的。相比而言， Java的实现方式完全不同。 Java的目标代码是一种特殊的二进制表示，称为 Java宇节代码。这种代码可以看成是虚拟机的机器级程序。正如它的
名字暗示的那样，这种机器并不是直接用硬件实现的，而是用软件解释器处理字节代码，模拟虚拟机的行为。另外，有一种称为及时编译 (just-in-time compilation)的方法，动态地将字节代码序列翻译成机器指令。当代码要执行多次时（例如在循环中），这种方法执行起来更快。用字节代码作为程序的低级表示，优点是相同的代码可以在许多不同的机器上执行，而在本章谈到的机器代码只能在 x86 -64机器上运行。
参考文献说明
Intel和 AMD提供了关于他们处理器的大量文档。包括从汇编语言程序员角度来看硬件的概貌 [2, 50 ]，还包括每条指令的详细参考 [3, 51]。读指令描述很复杂；因为 1)所有的文档都基于 Intel汇编代码格式， 2）由于不同的寻址和执行模式，每条指令都有多个变种， 3）没有说明性示例。不过这些文档仍然是关于每条指令行为的权威参考。
组织 x86-64. o rg负责定义运行在 Linux系统上的 x8 6-64代码的应用二进制接口 (Applicatio in Binary Interface, ABI) [ 77]。这个接口描述了一些细节，包括过程链接、二进制代码文件和大量的为了让机器代码程序正确运行所需要的其他特性。
正如我们讨论过的那样， GCC使用的 ATT格式与 Intel文档中使用的 Intel格式和其他编译器（包括 Microsoft编译器）使用的格式都很不相同。 Muchnick的关于编译器设计的书 [80]被认为是关千代码优化技术最全面的参考书。它涵盖了许多我们在此讨论过的技术，例如寄存器使用规则。
已经有很多文章是关于使用缓冲区溢出通过因特网来攻击系统的。 Spafford出版了关于 1988年因特网蠕虫的详细分析[105]，而帮助阻止它传播的 MIT团队的成员也出版了一些论著[35]。从那以后，大量的论文和项目提出了各种创建和阻止缓冲区溢出攻击的方法。 Seacord的书 [97]提供了关于缓冲区溢出和其他一些对 C编译器产生的代码进行攻击的丰富信息。
家庭作业
·3 58 一个函数的原型为
long decode2(long x, long y , long z);
GCC产生如下汇编代码：
decode2 : subq %rdx, %rsi imulq %rsi, %rdi movq %rsi, %rax salq $63,%rax sarq $63,%rax xorq %rdi, %rax
8 ret
参数 x、 y和 z通过寄存器釭di、毛 rsi和毛 rdx传递。代码将返回值存放在寄存器釭ax中。
写出等价于上述汇编代码的 decode2的 C代码。
.. 3. 59 下面的代码计算两个 64位有符号值 x和 y的 128位乘积，并将结果存储在内存中：
1234
typedef __int128 int128_t;
void store_prod(int128立＊dest, int64_t x, int64_t y) { *dest = x * (int128_t) y;
5
}
GCC产出下面的汇编代码来实现计算：
1 store_prod:
234567890123
movq %rdx, %rax cqto movq %rsi, %rcx sarq $63, %rcx imulq %rax, %rcx imulq %rsi, %rdx addq 。儿rdx, %rcx
mulq %rsi
1111addq %rcx, %rdx movq %rax, (%rdi) movq %rdx, 8(%rdi) ret
为了满足在 64位机器上实现 1 28位运算所需的多精度计算，这段代码用了三个乘法。描述用
来计算乘积的算法，对汇编代码加注释，说明它是如何实现你的算法的。提示：在把参数 x和 y
扩展到 128位时，它们可以重写为 x=26&rsquo; . x. +x,和 Y = 25&rsquo;. Y. + Yt ,这里 x.&lsquo;Xt&rsquo;Yh和 y 1都是
64位值。类似地， 128位的乘积可以写成 p= 264 . ph+ pi，这里 ph和 p 1是 64位值。请解释这段
代码是如何用 xh, x,, Y.和 Y I来计算 P h和户的。
.. 3. 60 考虑下面的汇编代码：
long loop (long x, int n)
x in i.rdi , n i n i.esi
12345678901234
loop: movl %esi, %ecx movl $1, %edx movl $0, %eax jmp .L2
.L3: movq %rdi, %r8 andq %rdx, %r8 orq %r8, %rax
11111
salq %cl,%.rdx
.L2 : testq %rdx, %rdx jne .L3 rep; ret
以上代码是编译以下整体形式的 C代码产生的：
1
long loop(long x, int n)
23456789
{
long result= — long mask; for (mask= _ ; mask ;mask= _ ){
result I= _ _, }
return result;
}
你的任务是填写这个 C代码中缺失的部分，得到一个程序等价于产生的汇编代码。回想一下，这个函数的结果是在寄存器％ rax中返回的。你会发现以下工作很有帮助：检查循环之前、之中和之后的汇编代码，形成一个寄存器和程序变量之间一致的映射。
A.哪个寄存器保存着程序值 x、 n、 result和 mask?
B. result和 mask的初始值是什么？
C. mask的测试条件是什么？
D. mask是如何被修改的？
E. result是如何被修改的</p><p>F.填写这段 C代码中所有缺失的部分。.. 3. 61 在 3. 6. 6节，我们查看了下面的代码，作为使用条件数据传送的一种选择：
long cread(long .xp) { return (xp? .xp : 0);
}
我们给出了使用条件传送指令的一个尝试实现，但是认为它是不合法的，因为它试图从一个空地址读数据。写一个 C函数 cread_alt,它与 cread有一样的行为，除了它可以被编译成使用条件数据传送。当编译时，产生的代码应该使用条件传送指令而不是某种跳转指令。
** 3. 62 下面的代码给出了一个开关语句中根据枚举类型值进行分支选择的例子。回忆一下， C语言中枚举类型只是一种引人一组与整数值相对应的名字的方法。默认情况下，值是从 0向上依次赋给名字的。在我们的代码中，省略了与各种情况标号相对应的动作。
1234567890123456789012
/. Enumerated type creates set of constants numbered O and upward./ typedef enum {MDDE_A, MDDE_B, MODE_C, MODE_D, MDDE_E} mode_t;
long switch3(long .pl, long .p2, mode_t action)
{
long result= O; switch(action) { case MODE_A:
1
case MODE_B: 11111
case MODE_C:
case MODE_D:
11
case MODE_E:
1
default:
1222 }
return result;
}
产生的实现各个动作的汇编代码部分如图 3-52所示。注释指明了参数位置，寄存器值，以及
各个跳转目的的情况标号。
p1 in Y.rdi, p2 in Y.rsi, action in Y.edx
1
. L8 : MODE_E
234567890123456789012345
movl $27, %eax
ret
.L3 : MODE_A
movq (.rsi), .rax movq (.rdi), .rdx movq .rdx, (.rsi)
ret
. L5 : MOOE_B 1111
movq (.rdi), .rax
addq (.rsi), .rax movq .rax, (.rdi) ret
1111
.L6 : MODE_C
movq $59, (%rdi)
movq (%rsi), %rax
ret
11222222
.L7: MODE_D
movq ( %rsi), %rax
movq %rax,（壮d劝
movl $27, %eax ret .L9: default
movl $12, i.eax
ret
图 3 -52家庭作业 3.62的汇编代码。这段代码实现了 switch语句的各个分支
填写 C代码中缺失的部分。代码包括落人其他情况的情况，试着重建这个情况。
, .. 3. 63 这个程序给你一个机会，从反汇编机器代码逆向工程一个 switch语句。在下面这个过程中，去掉
了 switch语句的主体：
12345678
long switch_prob(long x, long n) { long result= x; switch(n) {
/. Fill in code here./
}
return result;
}
图 3-53给出了这个过程的反汇编机器代码。
跳转表驻留在内存的不同区域中。可以从第 5行的间接跳转看出来，跳转表的起始地址为 Ox
4006f8。用调试器 GDB,我们可以用命令 x/6gx Ox4006f8来检查组成跳转表的 6个 8字节字的内
存。 GDB打印出下面的内容：
(gdb) x/6gx Ox4006f8
Ox4006f8 : Ox00000000004005a1 Ox00000000004005c3
Ox400708: Ox00000000004005a1 Ox00000000004005aa
Ox400718: Ox00000000004005b2 Ox00000000004005bf
用 C代码填写开关语句的主体，使它的行为与机器代码一致。
long switch_prob(long x, long n)
x in .rdi, n in .rsi
123456789012345678
0000000000400590 &lt;sw].tch_prob>:
400590: 48 83 ee 3c sub $0x3c,%rsi
400594: 48 83 fe 05 cmp $0x5,%rsi 400598: 77 29 ja 4005c3 &lt;switch_prob+Ox33> 40059a: ff 24 f5 f8 06 40 00 Jmpq *Ox4006f8( , %rsi,8)
4005a1: 48 8d 04 fd 00 00 00 lea OxO (, %rdi, 8) , %rax 4005a8: 00 4005a9: c3 retq 4005aa: 48 89 f8 mov 0/,rdi,%rax
4005ad: 48 cl f8 03 4005b1: c3 retq 4005b2: 48 89 f8 mov %rdi,o!.rax 4005b5: 48 cl eO 04 shl $0x4,%rax 4005b9: 48 29 f8 sub %rdi,o!.rax 4005bc: 48 89 c7 mov %rax,%rdi 4005bf : 48 Of af ff imul %rdi,%rdi 4005c3: 48 8d 47 4b lea Ox4b(%rdi) ,%rax 4005c7: c3 retq
111111111 sa工 $0x3,%rax
图 3-53家庭作业 3.63的反汇编代码
<em>~</em> 3. 64 考虑下面的源代码，这里 R、 S和 T都是用＃define声明的常数：</p><ul><li>1234567
long A [R] [SJ [T] ;
long store_ele(long i, long j, long k , long *dest)
{
*dest = A[i] [j] [k] ; return sizeof(A);
}
在编译这个程序中， GCC产生下面的汇编代码：
long store_ele(long i, long j, long k, long .dest) i in .rdi, j in .rsi, kin .rdx, dest in .rcx
1234567
store_ele: leaq (%rsi,%rsi,2), %rax leaq (i!.rsi,%rax,4), i!.rax movq i!.rdi, %rsi salq $6, %rsi addq i!.rsi, i!.rdl. addq %rax, i!.rdi
89012
addq %rdi, %rdx movq A(, %rdx, 8), %rax
111
movq %rax, (%rcx) movl $3640, %eax ret
A.将等式 (3 . 1)从二维扩展到三维，提供数组元素 A [i] [j J [k]的位置的公式。
B.运用你的逆向工程技术，根据汇编代码，确定 R、 S和 T的值。</li></ul><p>. 3. 65 下面的代码转置一个 MXM矩阵的元素，这里M是一个用＃define定义的常数：
123456789
void transpose(long A[M] [M]) { long i, j; for (i = 0; i &lt; M; i ++)
for (j = 0; j &lt; i; j ++) { long t = A[i][j]; A[i][j] = A[j][i]; A [j] [i] = t;
} }
当用优化等级－01编译时， GCC为这个函数的内循环产生下面的代码：
123456789
.L6:
movq (%rdx), %rcx movq (%rax), %rsi movq %rsi, (%rdx) movq %rcx, .(%rax) addq $8, %rdx addq $120, %rax cmpq %rdi, .!.rax jne .L6
我们可以看到 GCC把数组索引转换成了指针代码。
A.哪个寄存器保存着指向数组元素 A[i] [j]的指针？
B.哪个寄存器保存着指向数组元素 A[j J [i］的指针？</p><p>C.M的值是多少？
. 3. 66 考虑下面的源代码，这里 NR和 NC是用＃define声明的宏表达式，计算用参数 n表示的矩阵 A的
维度。这段代码计算矩阵的第）列的元素之和。
1234567
long sum_col(long n, long A[NR(n)] [NC(n)], long j) { long i; long result= O; for (]. =O; i &lt; NR(n);].++)
result += A[i] [j]; return result;
}
编译这个程序， GCC产生下面的汇编代码：
long sum_col(long n, long A[NR(n)J [NC(n)J, long j )
n in 7.过i, A in 7.rsi, j in 7.rdx 12345678901234567890
sum_col: leaq 1(,%rdi,4), %r8 leaq (%rdi,)!.rdi,2), %rax movq %rax, %rdi testq %rax, %rax jle .L4 salq $3, %r8 leaq (%rsi,%rdx,8), %rcx movl $0,众,eax
11111111112
movl $0, %edx
.L3: addq (.rcx), .rax addq $1, .rdx addq %r8, .rcx cmpq .rdi, .rdx jne.L3 rep; ret
.L4: movl $0, %eax ret
运用你的逆向工程技术，确定 NR和 NC的定义。
&ldquo;3. 67 这个作业要查看 GCC为参数和返回值中有结构的函数产生的代码，由此可以看到这些语言特性通
常是如何实现的。
下面的 C代码中有一个函数 process,它用结构作为参数和返回值，还有一个函数 e val,它
调用 process:
12 typedef struct { long a[2];
345678901234567890123456
long .p; } strA;
typedef struct { long u[2]; long q;
} strB;
11111111112222222
strB process(strA s) { strB r; r.u[O] = s.a[1]; r.u[1] = s.a[O];
r.q = .s.p; return r;
}
long eval(long x, long y, long z) { strA s; s .a[O] = x; s.a[1] = y;
s.p = &amp;z; strB r = process(s); return r.u[O] + r.u[1] + r.q;
}
GCC为这两个函数产生下面的代码：
strB process(strA s)
1234567890
process: movq .rdi, .rax movq 24(.rsp), .rdx movq (.rdx), .rdx
movq 16(.rsp)，壮ex
movq 店ex,（壮di)
movq S(.rsp),&lsquo;I.rcx movq &lsquo;I.rcx, S(.rdi) movq .rdx, 16(.rdi)
1
ret
long eval (long x, long y, long z) x in 7.rdi, y in 7.rsi, z in 7.rdx
12
eval: subq $104, .rsp
3
movq .rdx, 24(.rsp)
456789
leaq 24(.rsp), .rax movq .rdi, (.rsp) movq .rsi, 8(.rsp) movq .rax, 16(.rsp) leaq 64(.rsp), .rdi call process
10 movq 72(.rsp), .rax 11 addq 64(.rsp), .rax 12 addq 80(.rsp), .rax 13 addq $104, .rsp 14 ret
A.从 eval函数的第 2行我们可以看到，它在栈上分配了 104个字节。画出 eval的栈帧，给出它
在调用 process前存储在栈上的值。
B. eval调用 process时传递了什么值？
C. process的代码是如何访问结构参数 s的元素的？
D. process的代码是如何设置结果结构 r的字段的？</p><p><em>聿</em>3 . 68
“3 69
拿
E.完成 eval的栈帧图，给出在从 process返回后 eval是如何访问结构 r
F.就如何传递作为函数参数的结构以及如何返回作为函数结果的结构值，
原则？
在下面的代码中， A和 B是用＃ define定义的常数：
12345678901234567
typedef struct { int x[A] [B]; /. Unknown constants A and B ./ long y;
} str1;
typedef struct { char array[B); int t; short s[A];
1
long u;
1
} str2;
11111
void setVal(str1 *P, str2 *q) { long vl = q->t; long v2 = q->u; p->y = vl+v2;
1 }
GCC为 setVal产生下面的代码：
void setVal (str1 .p, str2 .q) pin .rdi, q in .rs工 setVal:
movslq 8(%rsi), %rax addq 32(%rsi), %rax
movq %rax, 184(%rdi) ret
A和 B的值是多少？（答案是唯一的。）
你负责维护一个大型的 C程序，遇到下面的代码：
typedef struct { 2 int first; 3 a_struct a[CNT]; 4 int last;
5 } b_struct;
6
void test(long i, b_struct *bp)
8 {
9 int n = bp今first+ bp->last;
10 a_struct *ap = &amp;bp->a[i]; 11 ap->x[ap->].dx] = n;
}
12
的元素的。 你可以看出什么通用的
编译时常数 CNT和结构 a_struct的声明是在一个你没有访问权限的文件中。幸好，你有代码的 &lsquo;.o&rsquo;版本，可以用 OBJDUMP程序来反汇编这些文件，得到下面的反汇编代码：
void test(long i, b_str uct .bp)
l ln Zrd1, bp 1n 1r s1
1234567
0000000000000000 : 0: 8b 8e 20 01 00 00 6: 03 Oe 8: 48 8d 04 bf c: 48 8d 04 c6
10: 48 8b 50 08 14: 48 63 c9
mov Ox120(.rsi)心ecx<br>add (.rsi)心ecx<br>lea (.rdi,.rdi,4)心rax<br>lea (.rsi,.rax,8),.rax<br>mov Ox8(.rax),.rdx</p><p>movslq .ecx心rcx
*/ 3. 70
. 3. 71</p><ul><li><ul><li><ol start=3><li>72
89 17: 48 89 4c dO 10 mov %rcx,Ox10(%rax,%rdx,8) 1c: c3 retq
运用你的逆向工程技术，推断出下列内容：
A. CNT的值。
B.结构 a_struct的完整声明。假设这个结构中只有字段 idx和 X,并且这两个字段保存的都是
有符号值。考虑下面的联合声明：
12 union ele { struct {
3
long *p;
4567890
long y; } e1 ; struct {
long x; union ele *next; } e2;
1
};
这个声明说明联合中可以嵌套结构。下面的函数（省略了一些表达式）对一个链表进行操作，链表是以上述联合作为元素的：
12 VO].d proc Cun].on ele .up) {
3 } up->-= .C-__) -一；
A.下列字段的偏移量是多少（以字节为单位）：
el.p el.y e2.x e2.next
B.这个结构总共需要多少个字节？
c.编译器为 proc产生下面的汇编代码：
void proc (union ele .up) up in .rdi
12
proc: movq 8(%rdi), %rax
34567
movq (%rax), %rdx movq (%rdx), %rdx subq 8(%rax), %rdx movq %rdx, (%rdi) ret
在这些信息的基础上，填写 proc代码中缺失的表达式。提示：有些联合引用的解释可以有歧义。当你清楚引用指引到哪里的时候，就能够澄清这些歧义。只有一个答案，不需要进行强制类型转换，且不违反任何类型限制。写一个函数 g ood_echo,它从标准输入读取一行，再把它写到标准输出，你的实现应该对任意长度的输入行都能工作。可以使用库函数 fgets,但是你必须确保即使当输入行要求比你已经为缓冲区分配的更多的空间时，你的函数也能正确地工作。你的代码还应该检查错误条件，要在遇到错误条件时返回。参考标准 I / 0函数的定义文档 [45, 6 1 ]。图 3-54a给出了一个函数的代码，该函数类似千函数 vfunct（图 3-43a)。我们用 vfunct来说明过帧指针在管理变长栈帧中的使用情况。这里的新函数 aframe调用库函数 alloca为局部数组 p分配空间。 alloca类似于更常用的函数 malloc,区别在千它在运行时栈上分配空间。当正在执行的过程返回时，该空间会自动释放。
图 3 -54b给出了部分的汇编代码，建立帧指针，为局部变量 1和 p分配空间。非常类似于
. 3 73
.. 3. 74
. 3 75
vframe对应的代码。在此使用与练习题 3. 49中同样的表示法：栈指针在第 4行设置为值 S 1 ,在
第 7行设置为值 S 2。数组 p的起始地址在第 9行被设置为值 p。 S 2和 p之间可能有额外的空间 e2&rsquo;
数组 p结尾和 S1之间可能有额外的空间 e l o
A.用数学语言解释计算 S2的逻辑。
B.用数学语言解释计算 p的逻辑。
C.确定使 e1的值最小和最大的 n和 S1的值。
D.这段代码为 S2和 p的值保证了怎样的对齐属性？
1234567890
#include &lt;alloca.h>
{
long aframe(long n, long idx, long .q) long i; long **P = alloca(n * sizeof(long .)); p[O] = &amp;i; for (i = 1; i &lt; n; i ++)
p[i] = q; return .p[idx];
1 }
a) C代码
long aframe(long n, long idx, long .q)
n in肚di, idx in肚s1, q ln肛dx
123456789
aframe: pushq %rbp movq %rsp, %rbp subq $16, %rsp Allocate space f or i吆rsp = s1) leaq 30(,%rdi,8), %rax andq $-16, %rax subq %rax, %rsp Allocate space for array p (7.rsp = s2) leaq 15(%rsp), %r8 andq ＄一 16, %r8 Set .rB to &amp;p[O]
b)部分生成的汇编代码
图 3 -54 家庭作业 3. 72的代码。该函数类似于图 3 -43中的函数
用汇编代码写出匹配图 3-51中函数 find_range行为的函数。你的代码必须只包含一个浮点比较
指令，并用条件分支指令来生成正确的结果。在沪种可能的参数值上测试你的代码。网络旁注
ASM:EASM描述了如何在 C程序中嵌入汇编代码。
用汇编代码写出匹配图 3-51中函数 find_range行为的函数。你的代码必须只包含一个浮点比较
指令，并用条件传送指令来生成正确的结果。你可能会想要使用指令 crnovp（如果设置了偶校验位
传送）。在沪种可能的参数值上测试你的代码。网络旁注 ASM:EASM描述了如何在 C程序中嵌
入汇编代码。
ISO C99包括了支持复数的扩展。任何浮点类型都可以用关键字 c omplex修饰。这里有一些使用
复数数据的示例函数，调用了一些关联的库函数：
123456
#include &lt;complex.h>
double c_imag(double complex x) { return cimag(x);
}
7
double c_real(double complex x) {
8
return creal(x);
9 }
10 11 double complex c_sub(double complex x, double complex y) { 12 return x -y;
13 }
编译时， GCC为这些函数产生如下代码：
double c_imag(double complex x) 1 c_imag: 2 movapd %xmm1, %xmm0 ret
double c_real (double complex x) 4 c_real: 5 rep; ret
double complex c_sub(double complex x, double complex y) 6 c_sub: 7 subsd %xmm2, %xmm0
8 subsd %xmm3, %xmm1 9 ret
根据这些例子，回答下列问题：
A.如何向函数传递复数参数？
B.如何从函数返回复数值？
练习题答案</li></ol></li></ul></li></ul><ol start=3><li><p>1 这个练习使你熟悉各种操作数格式。
操作数 值注释
%rax OxlOO 寄存器
Oxl04 OXAB 绝对地址
$0x108 OxlOB 立即数
伐 r ax) OXFF 地址 OxlOO
4(%rax) OXAB 地址 Oxl04
9 （号 rax,号 rdx) Oxll 地址 OxlOC
260($rcx,毛 rdx) Oxl3 地址 Oxl0 8
OXFC(，号rcx,4) OxFF 地址 OxlOO
(%rax, %rdx, 4) Oxll 地址 OxlOC</p></li><li><p>2 正如我们已经看到的， GCC产生的汇编代码指令上有后缀，而反汇编代码没有。能够在这两种形
式之间转换是一种很重要的需要学习的技能。一个重要的特性就是， x86-64中的内存引用总是用
四字长寄存器给出，例如％rax ,哪怕操作数只是一个字节、一个字或是一个双字。
这里是带后缀的代码：
movl %eax, (%rsp) movw (%rax)，次ix movb $0xFF, %bl movb (%rsp,%rdx,4), %dl movq (%rdx), %rax mo四％dx, (%rax)</p></li><li><p>3 由于我们会依赖 GCC来产生大多数汇编代码，所以能够写正确的汇编代码并不是一项很关键的技能。但是，这个练习会帮助你熟悉不同的指令和操作数类型。
下面给出了有错误解释的代码：
movb $0xF, (%ebx) Cannot use .ebx as address register movl %rax, (%rsp) 出 smatcb be切een instruction s辽丘 x and register ID mov&rsquo;II (%rax),4(%rsp) Cannot have both source and destination be memory references movb %al,%s1 No register named .sl
movq %rax,$0x123 Cannot have immediate as destination movl %eax,%rdx Destination operand incorrect size movb %si, 8(%rbp) Mismatch between instruction s出fix and register ID</p></li><li><p>4 这个练习给你更多经验，关千不同的数据传送指令，以及它们与 C语言的数据类型和转换规则的关系。
src t dest t 指令 注释<br>l ong long movq( % rd习，％ rax 读 8个字节<br>movq %rax, (%rsi) 存 8个字节<br>char int novsbl(号 rdi),号 eax 将 c h ar转换成 l.吐<br>mov l 兮 eax,（毛 rsi ) 存 4个字节<br>char unsigned movsbl ( % rdi)，毛 e ax 将 char转换成 in t<br>movl 令eax, 伐 rsi ) 存 4个字节<br>unsigned char l ong movzbl(%rdi), %eax 读一个字节并零扩展<br>movq毛 rax, (%rsi) 存 8个字节<br>int char movl（毛 rdi),号eax 读 4个字节<br>movb % al,（号 rsi) 存低位字节<br>unsigned unsigned movl( % rd习，％ea x 读 4个字节<br>char movb %al, (%rsi) 存低位字节<br>char short movsbw ( % rdi)，毛 a x 读一个字节并符号扩展<br>movw %ax, (%r si) 存 2个字节</p></li><li><p>5 逆向工程是一种理解系统的好方法。在此，我们想要逆转 C编译器的效果，来确定什么样的 C代码会得到这样的汇编代码。最好的方法是进行“模拟＂，从值 x、 y和 z开始，它们分别在指针 xp、 yp和 zp指定的位置。于是，我们可以得到下面这样的效果：
void decode1 (long .xp, long *YP, long .zp) xp in i/rdi, yp in .rsi, zp in .rdx
decodel: movq (%rdi), %r8 Get x = .xp movq (i,rsi), i.rcx Get y = *YP movq (i.rdx), i.rax Get z = .zp movq %r8, (%rsi) Store x at yp movq i.rcx, (i.rdx) Storey at zp
movq .rax, (.rdi) Store z at xp ret
由此可以产生下面这样的 C代码：
VO].d decodel(long .xp, long *YP, long *Zp)
{
long x = .xp; long y = *yp; long z = *zp;
*YP = x;
.zp = y;
.xp = z;</p></li></ol><p>}
3. 6 这个练习说明了 leaq指令的多样性，同时也让你更多地练习解读各种操作数形式。虽然在图 3-3中有的操作数格式被划分为“内存”类型，但是并没有访存发生。
指令结果
leaq 6(沦r:ax)，毛工dx 6+工
leaq（号rax,沧rcx )，令rdx .r+ y
leaq( % rax,乌 rcx,4), % rdx .r+ 4y
leaq 7 (%rax, %rax, 8)，毛rdx 7+ 9x leaq OxA (, %rcx, 4), %rdx 10+4y leaq 9 (%rax, %rcx, 2), %rdx 9+.r+ Zy
3. 7 逆向工程再次被证明是学习 C代码和生成的汇编代码之间关系的有用方式。
解决此类型问题的最好方式是为汇编代码行加注释，说明正在执行的操作信息。下面是一个例子：
long scale2(long x, long y, long z) X立肚di, y in 7.rsi, z in 7.rdx
scale2: leaq (.rdi,.rdi,4), .rax s * x leaq (.rax,.rsi,2), .rax s * x + 2 * y leaq (.rax,.rdx,8), .rax s * x + 2 * y + 8 * z
ret
由此很容易得到缺失的表达式：
long t = 5 * x + 2 * y + 8 * z;
3 8 这个练习使你有机会检验对操作数和算术指令的理解。指令序列被设计成每条指令的结果都不会影响后续指令的行为。
指令目的值
addq % r-cx,（号 rax) OxlOO OxlOO
subq枭rdx, 8 (%rax) Oxl08 OxA8
耳nulq $16, (%rax , %rdx, 8) Ox118 OxllO
incq 16（沧rax) OxllO Oxl4 decq %rcx %rcx OxO subq %rdx, %rax %rax OXFD
3. 9 这个练习使你有机会生成一点汇编代码。答案的代码由 GCC生成。将参数 n加载到寄存器告 ecx中，它可以用字节寄存器％ cl来指定 sarl指令的移位量。使用 movl指令看上去有点儿奇怪，因为 n的长度是 8字节，但是要记住只有最低位的那个字节才指示着移位量。
long sbitt_lett4_r ightn(long x, long n) X立1 7,rd工， n in 7.rsi
shift_left4_rightn: movq i.rdi, %rax Get x salq $4, i.rax x .= 4 movl i.esi, i.ecx Get n (4 bytes) sarq %cl, i.rax x .= n
3. 10 这个练习比较简单，因为汇编代码基本上沿用了 C代码的结构。
long t1 = x I y; long t2 = tl . 3; long t3 = -t2; long t4 = z-t3;
3 11
3. 12
3. 13
3 1 4
3. 15
笫 3章程序的机器级表示 229
A.这个指令用来将寄存器％rdx设置为 o,运用了对任意工，工它＝0这一属性。它对应于 C语句 x=O。
B.将寄存器％ rdx设置为 0的更直接的方法是用指令 movq $0, %rdx。
C.不过，汇编和反汇编这段代码，我们发现使用 xorq的版本只需要 3个字节，而使用 movq的版本需要 7个字节。其他将％ rdx设置为 0的方法都依赖于这样一个属性，即任何更新低位 4字节的指令都会把高位字节设置为 0。因此，我们可以使用 xorl % edx,% edx(2字节）或 movl $0,% edx(S字节）。</p><p>我们可以简单地把 cqto指令替换为将寄存器％ rdx设置为 0的指令，并且用 divq而不是 idivq作为我们的除法指令，得到下面的代码：
void uremd江 (unsigned long x, unsigned long y, 皿signed long *qp, unsigned long *rp) x in Y.rdi, y in缸si, qp in Y.rdx, rp in Y.rcx
12345678
uremdiv:
movq %rdx, %r8 Copy qp movq %rdi, %rax Move x to lower 8 bytes of dividend movl $0, %edx Set upper 8 bytes of div工 dend to 0 divq %rsi Divide by y
movq %rax,（红8) Store quotient at qp movq %rdx, (%rcx) Store remainder at rp ret
汇编代码不会记录程序值的类型，理解这点这很重要。相反地，不同的指令确定操作数的大小以及是有符号的还是无符号的。当从指令序列映射回 C代码时，我们必须做一点儿侦查工作，推断程序值的数据类型。
A.后缀｀尸和寄存器指示符表明是 32位操作数，而比较是对补码的＜。我们可以推断 data_t -定是 int。
B.后缀｀矿和寄存器指示符表明是 16位操作数，而比较是对补码的＞＝。我们可以推断 data_t -定是 short。
c.后缀 &lsquo;b&rsquo;和寄存器指示符表明是 8位操作数，而比较是对无符号数的＜＝。我们可以推断 da七 a卢一定是 unsigned cha r。 .D．后缀｀矿和寄存器指示符表明是 64位操作数，而比较是！＝，有符号、无符号和指针参数都是</p><p>一样的。我们可以推断 da七a_t可以是 long、 unsigned long或者某种形式的指针。这道题与练习题 3 . 13类似，不同的是它使用了 TEST指令而不是 CMP指令。 A.后缀｀矿和寄存器指示符表明是 64位操作数，而比较是＞＝，一定是有符号数。我们可以推断
data_t一定是 long。 B.后缀＇矿和寄存器指示符表明是 16位操作数，而比较是＝＝，这个对有符号和无符号都是一样的。我们可以推断 data＿七一定是 short或者 unsigned short。
C.后缀｀ b＇和寄存器指示符表明是 8位操作数，而比较是针对无符号数的＞。我们可以推断 data＿七一定是 unsigned char。
D.后缀丁和寄存器指示符表明是 32位操作数，而比较是＜＝。我们可以推断 data_t一定是 int。这个练习要求你仔细检查反汇编代码，并推理跳转目标的编码。同时练习十六进制运算。 A. je指令的目标为 Ox4003fc+ Ox02。如原始的反汇编代码所示，这就是 Ox4003fe。</p><p>4003fa: 74 02 je 4003fe 4003fc: ff dO callq *o/orax
B. jb指令的目标是 Ox400431 -12（由千 Oxf4是一 12的一个字节的补码表示）。正如原始的反汇编代码所示，这就是 Ox400425:
40042f: 74 f4 je 400425 400431: 5d pop %rbp
C.根据反汇编器产生的注释，跳转目标是绝对地址 Ox400547。根据字节编码，一定在距离 pop
指令 Ox2的地址处。减去这个值就得到地址 Ox400545。注意， ja指令的编码需要 2个字节，
它一定位于地址 Ox400543处。检查原始的反汇编代码也证实了这一点：
400543: 77 02 ja 400547 400545: 5d pop %rbp
D.以相反的顺序来读这些字节，我们看到目标偏移昼是 Oxffffff73,或者十进制数一 14 1。
Ox4005ed(nop指令的地址）加上这个值得到地址 Ox400560:
4005e8: e9 73 ff ff ff jmpq 400560 4005ed : 90 nop
3. 16 对汇编代码写注释，并且模仿它的控制流来编写 C代码，是理解汇编语言程序很好的第一步。本题是一个具有简单控制流的示例，给你一个检查逻辑操作实现的机会。
A.这里是 C代码：
void goto_cond(long a, long .p) { if (p == 0) goto done; if (*p >= a) goto done; <em>P = a; done: return;
B.第一个条件分支是＆＆表达式实现的一部分。如果对 p为非空的测试失败，代码会跳过对 a><em>p
的测试。 3 17 这个练习帮助你思考一个通用的翻译规则的思想以及如何应用它。
A .转换成这种替代的形式，只需要调换一下几行代码：
long gotod].ff_se_alt(long x, long y) { long result;
if (x &lt; y)
goto x_lt_y; ge_cnt++; result= x -y; return result;
x_lt_y: lt_cnt++; result= y -x; return result;
B.在大多数情况下，可以在这两种方式中任意选择。但是原来的方法对常见的没有 else语句的
情况更好一些。对千这种情况，我们只用简单地将翻译规则修改如下：
t = test-expr;
if (!t)
goto done; then-statement done :
基于这种替代规则的翻译更麻烦一些。 3. 18 这个题目要求你完成一个嵌套的分支结构，在此你会看到如何使用翻译辽语句的规则。大部分情
况下，机器代码就是 C代码的直接翻译。
long test(long x, long y, long z) { long val= x+y+z;
if (x &lt; -3) { if (y &lt; z)
val= x.y;
笫 3章程序的机器级表示 231
else val= y.z; } else if (x > 2) val= x.z; return val;
}
3. 19 这道题巩固加强了我们计算预测错误处罚的方法。 A.可以直接应用公式得到 TMr=2X(31-16)=30。
B.当预测错误时，函数会需要大概 16 +30 =46个周期。 3. 20 这道题提供了研究条件传送使用的机会。 A.运算符是＇／＇。可以看到这是一个通过右移实现除以 2的 3次幕的例子（见 2. 3. 7节）。在移位
k=3之前，如果被除数是负数的话，必须加上偏移扯 2.-1 =7。
B.下面是该汇编代码加上注释的一个版本：
long arith(long x) x in 7.rdi
arith: leaq 7(%rdi), %rax temp = x+7 testq %rdi, %rdi Test x cmovns %rdi, %rax If x>= o, temp = x sarq $3, %rax result = temp . 3 (= x/ 8) ret
这个程序创建一个临时值等于工＋ 7&rsquo;预期工为负，需要加偏移量时使用。 cmovn s指令在当
.r<del>o条件成立时把这个值修改为 .r，然后再移动 3位，得到对8。 3. 21 这个题目类似千练习题 3. 18,除了有些条件语句是用条件数据传送实现的。虽然将这段代码装进到原始的 C代码中看起来有些令人惧怕，但是你会发现它相当严格地遵守了翻译规则。
long test(long x, long y) { long val= 8.x; if (y > 0) {
if (x &lt; y)
val= y-x; else val= x&amp;y; } else if (y &lt;= -2) val= x+y; return val;
3 22 A．如果构建一张使用数据类型 int来计算的阶乘表，得到下面这样的表：
n n! OK? 1 1 Y 2 2 Y
3 6 Y 4 24 Y 5 120 Y 6 720 Y 7 5 040 Y 8 40 320 Y 9 362 880 Y 10 3 628 800 Y 11 39916800 Y 12 4 79 001 600 Y 13 1 932 053 504 N
我们可以看到，计算 13!溢出了。正如在练习题 2 . 35中学到的那样，还可以通过计算
:r/n，看它是否等于 (n — l)！来测试 n!的计算是否溢出了（假设我们已经能够保证 (n-1)！的
计算没有溢出）。在此处，我们得到 1 932 053 504/ 13= 161 004 458. 667。另外有个测试方法，
可以看到 10!以上的阶乘数都必须是 100的倍数，因此最后两位数字必然是 0。 13!的正确值应该是 6 227 020 800。
B.用数据类型 long来计算，直到 20!才溢出，得到 2 432 902 008 176 640 000。
3 23 编译循环产生的代码可能会很难分析，因为编译器对循环代码可以执行许多不同的优化，也因为可能很难把程序变量和寄存器匹配起来。这个特殊的例子展示了几个汇编代码不仅仅是 C代码直
接翻译的地方。
A.虽然参数 x通过寄存器％ rdi传递给函数，可以看到一旦进入循环就再也没有引用过该寄存器
了。相反，我们看到第 2</del>5行上寄存器％rax、 %rcx和％rdx分别被初始化为 x、 x</em>x和 x+x。因
此可以推断，这些寄存器包含着程序变量。
B.编译器认为指针 p总是指向 x,因此表达式 (<em>p)＋＋就能够实现 x加一。代码通过第 7行的 leaq
指令，把这个加一和加 y组合起来。
C.添加了注释的代码如下：
l ong d巳loop (long x) x initially in Y.rdi dw_loop:
2 movq %rdi, %rax Copy x to 7.rax 3 movq %rdi, %rcx 4 imulq %rd]., %rcx Compute y = x.x
5 leaq (%rdi,%rdi),&rsquo;/.rdx Compute n = 2.x
6 . L2: loop:
7 l eaq 1(%rcx,%rax), %rax Compute x += y + 1 8 subq $1, %rdx Decrement n 9 testq %rdx, %rdx Test n
10 jg .L2 If > 0, goto l oop 11 rep; ret Return
3 24 这个汇编代码是用跳转到中间方法对循环的相当直接的翻译。完整的 C代码如下：
long loop卫hile(long a, long b)
long result= 1;
while (a&lt; b) { result= result</em> (a+b); a = a+l;
return result;
3. 25 这个汇编代码没有完全遵循 guarded-do翻译的模式，可以看到它等价于下面的 C代码：
long loop_vhile2(long a, long b)
long result= b;
while (b > 0) { result= result</em> a; b = b-a;
return result;
我们会经常看到这样的情况，特别是用较高优化等级编译时，此时 GCC会自作主张地修改生
成代码的格式，同时又保留所要求的功能。
3 26 能够从汇编代码工作回 C代码，是逆向工程的一个主要例子。
A.可以看到这段代码使用的是跳转到中间翻译方法，在第 3行使用了 jmp指令。
B.下面是原始的 C代码：
long fun_a(unsigned long x) { long val= O; while (x) {
val-= x; X &#187;= 1; } return val & Ox1; }
C.这个代码计算参数 x的奇偶性。也就是，如果 x中有奇数个 1&rsquo;就返回 l，如果有偶数个 l，就
返回 0。 3.27这道练习题意在加强你对如何实现循环的理解。
long fact_for_gd_goto(long n)
{
long i = 2; long result= 1; if (n &lt;= 1)
goto done;
loop: result.= i; i++; if (i &lt;= n)
goto loop; done: return result;
}
3. 28 这个问题比练习题 3. 26要难一些，因为循环中的代码更复杂，而整个操作也不那么熟悉。
A.以下是原始的 C代码：
long fun_b(unsigned long x) { long val= O; long i;
for (i = 64; i != O; i一一） { val = (val . 1) I (x & Ox1); X &#187;= 1;
}
return val;
}
B.这段代码是用 guarded-do变换生成的，但是编译器发现因为 l.初始化成了 64,所以一定会满足测试 l.#0，因此初始的测试是没必要的。
C.这段代码把 x中的位反过来，创造一个镜像。实现的方法是：将 x的位从左往右移，然后再填人这些位，就像是把 val从右往左移。</p><ol start=3><li><p>29我们把 for循环翻译成 while循环的规则有些过于简单这是唯一需要特殊考虑的方面。 A.使用我们的翻译规则会得到下面的代码：
I* Naive translation of for loop into while loop <em>I I</em> WARNING : This is buggy code <em>I long sum= O; long i = O; wh辽e (i &lt; 10) {
辽 (i & 1)
I</em> This will cause an infinite loop <em>I
continue; sum+= i; i++;
}
因为 continue语句会阻止索引变量 L被修改，所以这段代码是无限循环。
B.通用的解决方法是用 goto语句替代 continue语句，它会跳过循环体中余下的部分，直接跳到 update部分：
I</em> Correct translation of for loop into while loop *I long sum= O; long i = O; while (i &lt; 10) {
if (i & 1) goto update; sum+= i ; update: i++;</p></li><li><p>30 这个练习给你一个机会，推算出 switch语句的控制流。要求你将汇编代码中的多处信息综合起
来回答这些问题： ·汇编代码的第 2行将 x加上 1，将情况 (cases)的下界设置成 0。这就意味着最小的清况标号为一 1。 ·当调整过的情况值大于 8时，第 3行和第 4行会导致程序跳转到默认情况。这就意味着最大情
况标号为— 1+8=7。
·在跳转表中，我们看到第 6行的表项（情况值 3)与第 9行的表项（情况值 6 )都以第 4行的跳转指
令作为同样的目标 ( . 12)，表明这是默认的情况行为。因此，在 switch语句体中缺失了情况标
号 3和一6。
·在跳转表中，我们看到第 3行和第 10行上的表项有相同的目的。这对应于情况标号 0和 7。 ·在跳转表中，我们看到第 5行和第 7行上的表项有相同的目的。这对应于情况标号 2和 4。从上述推理，我们得出如下结论：
A. switch语句体中的情况标号值为一1、 0、 1、 2、 4、 5和 7。 B．目标为． L5的情况标号为 0和 7。
C.目标为． L7的情况标号为 2和 4。</p></li><li><p>31 逆向工程编译出 switch语句，关键是将来自汇编代码和跳转表的信息结合起来，理清不同的情况。从 ja指令（第 3行）可知，默认情况的代码的标号是． 12。我们可以看到，跳转表中只有另一个标号重复出现，就是． LS,因此它一定是情况 C和 D的代码。代码在第 8行落入下面的情况，
因而标号．L7符合情况 A,标号．13符合情况 B。只剩下标号．16 ,符合情况 E。
原始的 C代码如下：
void switcher(long a, long b, long c, long <em>dest)
{
long val; switch(a) { case 5:
c = b -15; I</em> Fall through *I
case 0: val = C + 112; break;
case 2:
case 7: val = (c + b) . 2; break;
case 4: val = a; break;
default: val= b;
}
*dest = val;
}
3 32 追踪此等级上的程序的执行有助于理解过程调用和返回的很多方面。可以明确看到调用时控制是怎么传给过程的以及返回时调用函数如何继续执行的。还可以看到参数通过寄存器％ r中和％ rsi传递，结果通过寄存器％ rax返回。
指令状态值（指令开始执行前）
标号 PC 指令 %rdi 令rsi毛 rax %rsp 飞rsp 描述
Ml Ox400560 callq 10 Ox7fffffffe820 调用 first (10) Fl Ox400548 lea 10 Ox7fffffffe818 Ox400565 first的人口 F2 Ox40054c sub 10 11 Ox7fffffffe818 Ox400565 F3 Ox400550 callq 9 11 Ox7fffffffe818 Ox400565 调用 last (9, 11) LI Ox400540 mov 9 11 Ox7fffffffe810 Ox400555 last的人口 L2 Ox400543 imul 9 11 9 Ox7fffffffe810 Ox400555 L3 Ox400547 retq 9 11 99 Ox7fffffffe810 Ox400555 从 last返回 99 F4 Ox400555 repz repq 9 11 99 Ox7fffffffe818 Ox400565 从 fi rst返回 99 M2 Ox400565 mov 9 11 99 Ox7fffffffe820 继续执行 main</p></li><li><p>33 由于是多种数据大小混合在一起，这道题有点儿难。
让我们先描述第一种答案，再解释第二种可能性。如果假设第一个加（第 3行）实现＊ u+=a,第二个加（第 4行）实现 v+=b,然后我们可以看到 a通过％ edi作为第一个参数传递，把它从 4个字节转换成 8个字节，再加到％rdx指向的 8个字节上。这就意味着 a必定是 l吐类型， u一定是 long<em>类型。还可以看到参数 b的低位字节被加到了％ rcx指向的字节。这就意味着 v一定是 char</em>，但是 b的类型是不确定的一—它的大小可以是 1、 2、 4或 8字节。注意到返回值为 6就能解决这种不确定性，这个返回值是 a和 b大小的和。因为我们知道 a的大小是 4字节，所以可以推断出 b一定是 2字节的。
该函数的一个加了注释的版本解释了这些细节：
int procpr obl (int a, shor t b, long &ldquo;&lsquo;U, char *V) a in 7.edi , b in 7.si , u in 7.rdx, v in 7.rcx procprob:
movslq %edi, %rdi Convert a to long addq ;!.rdi, (%rdx) Add to .u (long) addb %sil, (%rcx) Add low-order byte of b to .v movl $6, %eax Return 4+2 ret
此外，我们可以看到如果以它们在 C代码中出现相反的顺序在汇编代码中计算这两个和，这段汇编代码同样合法。这会导致交换参数 a和 b,参数 u和 v,得到如下原型：
int procprob(int b, short a, long *v, char *u);</p></li><li><p>34 这个例子展示了被调用者保存寄存器的使用，以及保存局部数据的栈的使用。
A.可以看到第 9~ 1 4行将局部值 aO~ aS分别保存进被调用者保存寄存器％ rbx、 %rlS、 %rl4、 %rl3、 %rl2和％rbp。
B.局部值 a6和 a7存放在栈中相对于栈指针偏移量为 0和 8的地方（第 16和 18行）。 C.在存储完 6个局部变量之后，这个程序用完了所有的被调用者保存寄存祥，所以剩下的两个值保存在栈上。</p></li><li><p>35 这道题给了一个检查递归函数代码的机会。要学的一个很重要的内容就是，递归代码与我们看到的其他函数的结构一模一样。栈和寄存器保存规则足以让递归函数正确执行。
A.寄存器％rbx保存参数 x的值，所以它可以被用来计算结果表达式。
B.汇编代码是由下面的 C代码产生而来的：</p></li></ol><p>，
勹23456
long rfun(uns].gned long x) { if (x == 0)
return O; unsigned long rue= x&#187;2; long rv = rfun(nx); return x + rv;
3 36 这个练习测试你对数据大小和数组索引的理解。注意，任何类型的指针都是 8个字节长。 short数据类型需要 2个字节，而 int需要 4个。
数组元素大小总大小起始地址元素 1
s 2 14 Xs X5+2i T 8 24 XT XT+ 8i u 8 48 Xu Xu+ Si V 4 32 Xv Xv +4i w 8 32 Xw 环＋ 8i
3. 37 这个练习是关于整数数组 E的练习的一个变形。理解指针与指针指向的对象之间的区别是很重要的。因为数据类型 short需要 2个字节，所以所有的数组索引都将乘以因子 2。前面我们用的是 movl,现在用的则是 movw。
表达式类型值汇编语句
S+l short* X5 + 2 leal2(%rdx) , %rax S [3] short M[x5 + 6] movw6(%rdx) , %ax &amp;S[i] short* x, + 2i leal(%rdx, %rcx,2),%rax S[4<em>i+l] short M[x5 + 8i + 2] movw2( %rdx, %rcx,8), %ax S+i-5 short</em> XS + 2i -lO leal一10(%rdx,%rcx, 2) , %rax
3. 38 这个练习要求你完成缩放操作，来确定地址的计算，并且应用行优先索引的公式 (3. 1)。第一步是注释汇编代码，来确定如何计算地址引用：
long sum_element(long i, long j) 12 1 1n Y.rd1, J 1n肛s1 sum_element: leaq O(,%rdi,8), %rdx Compute 81
3456789
subq %rdi, %rdx Compute 7i addq %rsi,&rsquo;/.rdx Compute 7i + J leaq (%rsi,%rsi,4), %rax Compute 5」 addq %rax, %rdi Compute i + Sj movq Q(,%rdi,8), %rax Retrieve M[xq + 8 (5」 +i) ] addq P(,%rdx,8), %rax Add M[xp + 8 (7i + j )] ret
我们可以看出，对矩阵 P的引用是在字节偏移 8X（九十户的地方，而对矩阵 Q的引用是在字节偏移 8X (5j+i)的地方。由此我们可以确定 p有 7列，而 Q有 5列，得到 M=5和 N=7。3 39 这些计算是公式 (3. 1)的直接应用：
·对千
L=4, C=l6和）＝ 0,指针 Aptr等于 x A +4X Cl6i+O) =xA+64z。</p><p>·对于
L=4, C=16, i=O和）＝ k,指针 Bptr等于 Xa +4X (16 X o+ k) =x. +4k。</p><p>·对于 L=4, C=l6, i=l6和 j=k, Bend等于 x 8 +4 X (16 X 16+k) =x. + 1024+ 4k。3. 40 这个练习要求你能够研究编译产生的汇编代码，了解执行了哪些优化。在这个情况中，编译器做一些聪明的优化。
让我们先来研究一下 C代码，然后看看如何从为原始函数产生的汇编代码推导出这个 C代码。
I* Set all diagonal elements to val *I
void fix_set_diag_opt(fix_matrix A, int val) { int <em>Abase = &amp;A [OJ [OJ ; long i = O; long iend = N</em>(N+1); do {
Abase[iJ = val; i += (N+1); } while (i != iend);
这个函数引人了一个变量 Abase, int *类型的，指向数组 A的起始位置。这个指针指向一
个 4字节整数序列，这个序列由按照行优先顺序存放的 A的元素组成。我们引入一个整数变量 l.斤
dex,它一步一步经过 A的对角线，它有一个属性，那就是对角线元素 L和 i+l在序列中相隔 N+
1个元素，而且一旦我们到达对角线元素 N（索引为 N(N+ l)），我们就超出了边界。
实际的汇编代码遵循这样的通用格式，但是现在指针的增加必须乘以因子 4。我们将寄存
器％rax标记为存放值 index4，等于 C版本中的 index，但是使用因子 4进行伸缩。对于 N=l6,
我们可以看到对千 index4的停止点会是 4 · 1606+1)=1088。
fix_set_diag: void fix_set_diag(fix_matrix A, int val)
A耳I加rdi, val in .rsi
2345678
movl $0, %eax Set index4 = 0 .L13: l oop: movl %esi, (%rdi,%rax) Set Abase[工 ndex4/4] to val
addq $68, %rax In crement工 ndex4 += 4(N+1)
cmpq $1088, %rax Compare工 ndex4 : 4N(N+1)
jne.L13 If 1=, goto loop rep; ret Return
3. 41 这个练习让你思考结构的布局，以及用来访问结构字段的代码。该结构声明是书中所示例子的一
个变形。它表明嵌套的结构的分配是将内层结构嵌入到外层结构之中。
A.该结构的布局图如下：
8 1 2 1 6
偏移 0 p __ &mdash;-勹 2 4 内容［ s.x s.y next
B.它使用了 24个字节。
C.同平时一样，我们从给汇编代码加注释开始：
void sp_init (struct prob .sp)
spin .rd工
1234567
sp_init: movl 12(%rdi), %eax Get sp->s .y movl %eax, 8(%rdi) Save in sp->s .x leaq 8(%rdi), %rax Compute &(sp->s .x) movq %rax, (%rdi) Store in sp->p movq %rdi, 16(%rdi) Store spin sp->next ret
由此可以产生如下 C代码：
void sp_init(struct prob .sp)
{
sp->s.x = sp->s.y; sp->p = &(sp->s.x); sp->next = sp;
3. 42 这道题说明了一个非常普通的数据结构和对它的操作时如何在机器代码中实现。要解答这些问题，
还是先对汇编代码加注释，确认出该结构的两个字段分别在偏移量 0（字段 v)和 8（字段 p)处。
long fun(struct ELE .ptr)
ptr in肛di 1 fun: 2 movl $0, :/,eax result= 0 3 jmp .L2 Goto middle
4 .L3: loop: 5 addq (`!.rdi) , %rax result += ptr->v 6 movq 8 (%rdi), %rdi ptr = ptr->p 7 .L2: middle : 8 testq &lsquo;1/.rdi,&lsquo;1/.rdi Test ptr 9 jne .L3 It != NULL, goto loop
10 rep; ret
A.根据加了注释的代码，可以得到 C语言：
long fun (struct ELE .ptr) { long val= O; while (ptr) {
val+= ptr->v; ptr = ptr->p;
return val;</p><p>』
B.可以看到每个结构都是一个单链表中的元素，字段 v是元素的值，字段 p是指向下一个元素的
指针。函数 fun计算列表中元素值的和。
3. 43 结构和联合涉及的概念很简单，但是需要练习来习惯不同的引用模式和它们的实现。
表达式类型代码
up->tl.u long movq伐rdi), %rax
movq %rax, (%rsi)
up->tl.V s hort movw 8 ( % rd i),毛ax
movw毛ax ,伐rsi)
&amp;up->tl.w char. addq$，毛rdi
movq %rdi , (%rsi)
up->七 2.a int * movq %rdi , %rsi
up->t2 .a[up-> tl.u) i nt movq (%rdi) , %rax
movl（令rdi ,号rax, 4)，令eax
movl令eax , (%r s i)
*up->t2 .p char rnovq 8（毛rd习，毛rax
movb (%rax) , %a l
movb兮al ,（毛rsi )
3. 44 想理解各种数据结构需要多少存储，以及编译器为访问这些结构产生的代码，理解结构的布局和对齐是非常重要的。这个练习让你看清楚一些示例结构的细节。
A. struct Pl { int i; char c; int j; char d; } ;
c -J 总共对齐 4 8 4</p><p>勹 16
B. struct P2 { int i ; char c; char d; long j; } ;
1,
d-.
c J-总共 对齐 4 5 8
16 8
。
~~，
笫 3章程序的机器级表示 239
C. struct P3 { short w[3); char c[3) };
. wo I总共对齐 2
6C 10
~
D. struct P4 { short w[S]; char *c[3] };
wo 总共对齐
8
16 40
I
E. struct PS { struct P3 a [2]; struct P2 t } ;
a0 总共对齐 8
24 40
I
3. 45这是一个理解结构的布局和对齐的练习。 A.这里是对象大小和字节偏移量：
字段 a b C d e g-h
大小 8 2 8 1 4 8 4
偏移旦 I o 8 16 24 28 32 40 48
B.这个结构一共是 56个字节长。结构的结尾必须填充 4个字节来满足 8字节对齐的要求。
C.当所有的数据元素的长度都是 2的幕时，一种行之有效的策略是按照大小的降序排列结构的元
索。导致声明如下：
struct { char *a; double c; long g; float e·, int h; short b·, char d; char f;
} rec;
得到的偏移量如下：
字段 a C g-8 e h b d f
大小 8 8 4 4 2
偏移量 I o 8 16 24 28 32 34 35
这个结构要填充 4个字节以满足 8字节对齐的要求，所以总共是 4 0个字节。
3 . 46这个问题覆盖的话题比较广泛，例如栈帧、字符串表示、 ASCII码和字节顺序。它说明了越界的
内存引用的危险性，以及缓冲区溢出背后的基本思想。
A.执行了第 3行后的栈：
00 00 00 00 00 40 00 761返回值 01 23 45 67 89 AB CD EF保存的%rbx
&lt;— buf = %rsp
B.执行了第 5行后的栈：
勹三：rubfx沧 rsp
C.这个程序试图返回到地址 Ox040034。低位 2字节被字符｀矿和结尾的空 (null)字符覆盖了。
D.寄存器％ rbx的保存值被设置为 Ox3332313039383736。在 get_line返回前，这个值会被加载回这个寄存器中。
E.对 malloc的调用应该以 strlen(buf)+ 1作为它的参数，而且代码还应该检查返回值是否为</p><p>NULL。 3. 47 A.这对应于大约沪个地址的范图。 B．每次尝试，一个 128字节的空操作 sled会覆盖了个地址，因此我们只需要 2 6 =64次尝试。这个例子明确地表明了这个版本的 Li nux中的随机化程度只能很小地阻挡溢出攻击。 3. 48 这道题让你看看 x86-64代码如何管理栈，也让你更好地理解如何防卫缓冲区溢出攻击。
A.对于没有保护的代码，第 4行和第 5行计算 v和 buf的地址为相对千％ rsp偏移最为 24和 0。在有保护的代码中，金丝雀被存放在偏移量为 40的地方（第 4行），而 v和 buf在偏移盘为 8和 16的地方（第 7行和第 8行）。
B.在有保护的代码中，局部变量 v比 buf更靠近栈顶，因此 buf溢出就不会破坏 v的值。 3. 49 这段代码中包含许多我们已经见到过的执行位级运算的技巧。要仔细研究才能看得懂。
A.第 5行的 leaq指令计算值 8n+22,然后第 6行的 andq指令把它向下舍入到最接近的 16的倍数。当 n是奇数时，结果值会是 8n+8 ,当 n是偶数时，结果值会是 8n+l6,这个值减去 s)就得到s2。
B.该序列中的三条指令将 52舍入到最近的 8的倍数。它们利用了 2. 3. 7节中实现除以 2的幕用到的偏移和移位的组合。 c.这两个例子可以看做最小化和最大化 e1和 e 2的情况。
n s, S2 p eI e2
5 2065 2017 2024 I 7
6 2064 2000 2000 16 。
D．可以看到 S2的计算方式会保留 s 1的偏移量为最接近的 1 6的倍数。还可以看到 p会以 8的倍数对齐，正是对 8字节元素数组建议使用的。
`
3. 50 这道题要求你仔细检查代码，小心留意使用的转换和数据传送指令。可以看到取出的值和转换的情况如下： ·取出位于 dp的值，转换成 1.nt（第 4行），再存储到 1.p。因此可以推断出 vall是 d。 ·取出位于 ip的值，转换成 float（第 6行），再存储到 fp。因此可以推断出 val2是 1.。 . 1的值被转换成 double（第 8行），并存储在 dp。因此可以推断出 val3是 1。 ·第 3行上取出位千 fp的值。第 10和 11行的两条指令把它转换为双精度，值通过寄存器％ xmmO
返回。因此可以推断出 val4是 f。 3. 51 可以通过从图 3-47和图 3 -48中选择适当的条目或者使用在浮点格式间转换的代码序列来处理这些情况。
TX T.y 指令
long double VCV七 si2sdq号 rdi,毛 xmmO,令 xmmO
double int VCV七七 sd2si务 xmmO,毛 eax
double floa七 vunpckl pd %xmm0, %xmm0, %xmm0
vcvtpd2ps %xmm0,%xmm0 long float vctsi2ssq %rdi,%xmm0, %xmm0 float l ong VCV七 t ss2siq %xmm0, %rax
3. 52
3 53
3. 54
3. 55
3. 56
第 3章程序的机器级表示 241
映射参数到寄存器的基本规则非常简单（虽然随着有更多类型的参数出现，这些规则也变得越来越复杂[77] )。
A. double g1(double a, long b, float c, int d) ;
寄存器： a在毛xrnrnO中， b在％r土中， c在房xmml中， d在% esi中
B. double g2(int a, double *b, float *c, long d);
寄存器： a在％奾中， b在％ rsi中， c在％rdx中， d在％rcx中
C. double g3(double *a, double b, int c, float d);
寄存器： a在％r中中， b在枭xmmO中， e在亳 esi中， d在％xmml中
D. double g4(float a, int *b, float c, double d);
寄存器： a在％xmmO中， b在釭di中， e在％xmml中， d在毛xmm2中从这段汇编代码可以看出有两个整数参数，通过寄存器釭生和釭si传递，将其命名为 i1和立。类似地，有两个浮点参数，通过寄存器号xmmO和毛xmml传递，将其命名为 fl和 f2。
然后给汇编代码加注释：
Refer to arguments as工 1 (.r中），立 (.esi) fl (.xmmO), and f2 (.xmm1)
double tunctl(argl_t p, arg2_t q, arg3_t r, arg4_t s)
123456789
functl: vcvtsi2ssq %rsi, %xmm2, %xmm2 Get i2 and convert from long to float vaddss %xmm0, %xmm2, %xmm0 Add fl (type float) vcvtsi2ss %edi, %xmm2, %xmm2 Get i1 and convert from int to float vdivss %xmm0, %xmm2, %xmm0 Compute辽／ ( i2 + fl) vunpcklps %xmm0, %xmm0, %xmm0 vcvtps2pd %xmm0, %xmm0 Convert to double vsubsd %xmm1 , %xmm0, %xmm0 Compute i1 I (i2 + f1) -f2 (double) ret
由此可以看出这段代码计算值 il/ (i2 +fl) -f2。还可以看到， 1.1的类型为 1.nt , 1.2的类型为 long, fl的类型为 floa七，而 f2的类型为 double。将参数匹配到命名的值只有一个不确定的地方，来自于加法的交换性－得到两种可能的结果：
. double functla(int p, float q, long r, double s); double fu卫 ctlb(int p , long q, float r, doubles);
一步步梳理汇编代码，确定每一步计算什么，就很容易找到这道题的答案，如下面的注释所示：
double funct2(double甘， int x, float y, long z) w in .xmmO, x in .edi, y in .xmm1, z in .r si
123456789
funct2:<br>vcvtsi2ss %edi, %xmm2, %xmm2 Convert x t o float<br>vmulss %xmm1, %xmm2, %xmm1 加ltiply by y<br>vunpcklps %xmm1,)!.xmm1, %xmm1<br>vcvtps2pd %xmm1 , %xmm2 Convert x.y to double<br>vcvtsi2sdq %rsi, %xmm1, %xmm1 Convert z to double<br>vdivsd %xmm1 , %xmm0, %xmm0 Compute w/z<br>vsubsd %xmm0, %xmm2, %xmm0 Subtract from x.y<br>ret Return</p><p>可以从分析得出结论，该函数计算 y*x-w/z。这道题使用的推理与推断标号． LC2处声明的数字是 1. 8的编码一样，不过例子更简单。
我们看到两个值分别是 0和 1077936128 (Ox4 0400000)。从高位字节可以抽取出指数字段 Ox404Cl028)，减去偏移量 1023得到指数为 5。连接两个值的小数位，得到小数字段为 o,加上隐含的开头的 1，得到 1. 0。因此这个常数是 1. 0X沪＝ 32 . 0。 A.在此可以看到从地址． LCl开始的 16个字节是一个掩码，它的低 8个字节是全 1&rsquo;除了最高位，
这是双精度值的符号位。计算这个掩码和％xmmO的 AND值时，会清除 x的符号位，得到绝对值。实际上，定义 EXPR(x)为 fabs(x)就能得到这段代码， fabs是在 &lt;math.h>中定义的。
B.可以看到 vxorpd指令将整个寄存器设置为 0,所以这是一种产生浮点常数 0 . 0的方法。
C.可以看到从地址．LC2开始的 16个字节是一个掩码，它只有一个 1位，位于 XMM寄存器中低
位数值的符号位。计算这个掩码与％ xmmO的 EXCLUSIVE -OR值时，会改变 x符号的值，计
算出表达式叹。
3. 57 同样地，为代码加注释，包括处理条件分支： double tunct3(int .ap, double b, long c, float .dp) ap in 7.rdi, bin 7.xmmO, c in 7.rsi , dp in 7.rdx funct3:
2345
vmovss (%rdx), %xmm1 Get d = *dp vcvtsi2sd (%rdi), %xmm2, %xmm2 Get a= *ap and convert to double vucomisd %xmm2, %xmm0 Compare b:a jbe . L8 If&lt;=, goto lesseq
6 vcvtsi2ssq i儿rsi, .xmmO, .xmmO Convert c to float 7 vrnulss %xmm1, .xmmO, %xmm1 Multiply by d 8 vunpcklps %xmm1, %xmm1, %xmm1 9 vcvtps2pd %xmm1, i!.xmmO Convert to double
10 ret Return
11 .L8: lesseq: 12 vaddss %xmm1, i!.xmm1, %xmm1 Compute d+d = 2 .0 . d 13 vcvtsi2ssq .rsi, .xmmO, .xmmO Convert c to float 14 vaddss %xmm1, .xmmO, .xmmO Compute c + 2.d 15 vunpcklps .xmmO, .xmmO, .xmmO 16 vcvtps2pd .xmmO, .xmmO Convert to double 17 ret Return
由此，可以写出 funct3的代码如下：
double funct3(int *ap, double b, long c, float *dp) { int a = <em>ap; float d = <em>dp; if (a &lt; b)
return c</em>d; else return c+2</em>d;
}</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents></nav></div></aside></main></body></html>