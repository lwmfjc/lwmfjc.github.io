<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="第 8 章
C H A P T E R 8
异常控制流
从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列
a0 , a , , &mldr; , a ,, _1
其中，每个 ak 是某个相应的指令 I k的地址。每次从 Qk 到 a k一 1 的过渡称为控 制 转移 ( co ntro l trans £er ) 。 这样的 控制转移 序列叫做处理器的控制流( flow of cont rol 或 cont ro l flow ) 。
最简单的一种控制流 是一个“平滑的＂ 序列， 其中每个 L 和 I尸！在内存中都是相邻
的。这种 平滑流的 突变（也就是 I尸］与 L 不相邻）通常是由诸如跳转 、调用和返回这样一些熟悉的 程序指令造成的 。这样一些指令都是必要的机制， 使得程序能够对由程序变扯表示的内部程序状 态中的 变化做出反应 。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"><meta property="og:site_name" content="随记"><meta property="og:title" content="随记"><meta property="og:description" content="第 8 章
C H A P T E R 8
异常控制流
从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列
a0 , a , , … , a ,, _1
其中，每个 ak 是某个相应的指令 I k的地址。每次从 Qk 到 a k一 1 的过渡称为控 制 转移 ( co ntro l trans £er ) 。 这样的 控制转移 序列叫做处理器的控制流( flow of cont rol 或 cont ro l flow ) 。
最简单的一种控制流 是一个“平滑的＂ 序列， 其中每个 L 和 I尸！在内存中都是相邻
的。这种 平滑流的 突变（也就是 I尸］与 L 不相邻）通常是由诸如跳转 、调用和返回这样一些熟悉的 程序指令造成的 。这样一些指令都是必要的机制， 使得程序能够对由程序变扯表示的内部程序状 态中的 变化做出反应 。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Index | 随记</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/><link rel=stylesheet href=/book.min.61c2259501b059453d6e3b0551df29ef9de07bb5236b73baae9ac80bb6f5e94c.css integrity="sha256-YcIllQGwWUU9bjsFUd8p753ge7Uja3O6rprIC7b16Uw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.baf072a92c993083ba999c81365d7a56656f32cb4f757d6eecc302acdf1b349c.js integrity="sha256-uvByqSyZMIO6mZyBNl16VmVvMstPdX1u7MMCrN8bNJw=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>随记</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><a href=/zh/docs/technology/>技术</a><ul><li><input type=checkbox id=section-d2e5dc71fe2274ddaa089e125f33ae58 class=toggle>
<label for=section-d2e5dc71fe2274ddaa089e125f33ae58 class="flex justify-between"><a role=button>My SQL</a></label><ul><li><input type=checkbox id=section-385256c91dd6127cb06668afb2ab262b class=toggle>
<label for=section-385256c91dd6127cb06668afb2ab262b class="flex justify-between"><a role=button>mysql_进阶_施磊</a></label><ul><li><a href=/zh/docs/technology/MySQL/advanced_shilei/02/>02增删改查</a></li><li><a href=/zh/docs/technology/MySQL/advanced_shilei/01/>01基础知识</a></li></ul></li><li><input type=checkbox id=section-b36f39b28986b079f4216fd3e38bfa3e class=toggle>
<label for=section-b36f39b28986b079f4216fd3e38bfa3e class="flex justify-between"><a role=button>My Sql是怎样运行的</a></label><ul><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC26%E7%AB%A0_%E5%86%99%E4%BD%9C%E6%9C%AC%E4%B9%A6%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>第26章_写作本书时用到的一些重要的参考资料</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC25%E7%AB%A0_%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E8%80%81%E5%A4%A7%E9%9A%BE-%E9%94%81/>第25章_工作面试老大难-锁</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC24%E7%AB%A0_%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%9A%E5%B9%85%E9%9D%A2%E5%AD%94-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC/>第24章_一条记录的多幅面孔-事务的隔离级别与MVCC</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC23%E7%AB%A0_%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%E4%B8%8B/>第23章_后悔了怎么办-undo日志(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC22%E7%AB%A0_%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%E4%B8%8A/>第22章_后悔了怎么办-undo日志(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC21%E7%AB%A0_%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%E4%B8%8B/>第21章_说过的话就一定要办到-redo日志(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC20%E7%AB%A0_%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%E4%B8%8A/>第20章_说过的话就一定要办到-redo日志(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC19%E7%AB%A0_%E4%BB%8E%E7%8C%AB%E7%88%B7%E8%A2%AB%E6%9D%80%E8%AF%B4%E8%B5%B7-%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/>第19章_从猫爷被杀说起-事务简介</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC18%E7%AB%A0_%E8%B0%83%E8%8A%82%E7%A3%81%E7%9B%98%E5%92%8CCPU%E7%9A%84%E7%9F%9B%E7%9B%BE-InnoDB%E7%9A%84BufferPool/>第18章_调节磁盘和CPU的矛盾-InnoDB的BufferPool</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC17%E7%AB%A0_%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-optimizer_trace%E8%A1%A8%E7%9A%84%E7%A5%9E%E5%99%A8%E5%8A%9F%E6%95%88/>第17章_神兵利器-optimizer_trace表的神器功效</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC16%E7%AB%A0_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8B/>第16章_查询优化的百科全书-Explain详解(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC15%E7%AB%A0_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8A/>第15章_查询优化的百科全书-Explain详解(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC14%E7%AB%A0_%E4%B8%8D%E5%A5%BD%E7%9C%8B%E5%B0%B1%E8%A6%81%E5%A4%9A%E6%95%B4%E5%AE%B9-MySQL%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96%E5%86%85%E5%90%AB%E5%85%B3%E4%BA%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%BA%8C%E4%B8%89%E4%BA%8B%E5%84%BF/>第14章_不好看就要多整容-MySQL基于规则的优化(内含关于子查询优化二三事儿)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC13%E7%AB%A0_%E5%85%B5%E9%A9%AC%E6%9C%AA%E5%8A%A8%E7%B2%AE%E8%8D%89%E5%85%88%E8%A1%8C-InnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E7%9A%84/>第13章_兵马未动粮草先行-InnoDB统计数据是如何收集的</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC12%E7%AB%A0_%E8%B0%81%E6%9C%80%E4%BE%BF%E5%AE%9C%E5%B0%B1%E9%80%89%E8%B0%81-MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/>第12章_谁最便宜就选谁-MySQL基于成本的优化</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC10%E7%AB%A0_%E6%9D%A1%E6%9D%A1%E5%A4%A7%E8%B7%AF%E9%80%9A%E7%BD%97%E9%A9%AC-%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/>第10章_条条大路通罗马-单表访问方法</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC9%E7%AB%A0_%E5%AD%98%E6%94%BE%E9%A1%B5%E7%9A%84%E5%A4%A7%E6%B1%A0%E5%AD%90-InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/>第9章_存放页的大池子-InnoDB的表空间</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC8%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%B6-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/>第8章_数据的家-MySQL的数据目录</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC7%E7%AB%A0_%E5%A5%BD%E4%B8%9C%E8%A5%BF%E4%B9%9F%E5%BE%97%E5%85%88%E5%AD%A6%E4%BC%9A%E6%80%8E%E4%B9%88%E7%94%A8-B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/>第7章_好东西也得先学会怎么用-B+树索引的使用</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC6%E7%AB%A0_%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A7%98%E7%B1%8D-B+%E6%A0%91%E7%B4%A2%E5%BC%95/>第6章_快速查询的秘籍-B+树索引</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC5%E7%AB%A0-%E7%9B%9B%E6%94%BE%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%A7%E7%9B%92%E5%AD%90-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/>第5章 盛放记录的大盒子-InnoDB数据页结构</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC4%E7%AB%A0_%E4%BB%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E8%AF%B4%E8%B5%B7-InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/>第4章_从一条记录说起-InnoDB记录结构</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC3%E7%AB%A0_%E4%B9%B1%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/>第3章_乱码的前世今生-字符集和比较规则</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC2%E7%AB%A0_MySQL%E7%9A%84%E8%B0%83%E6%8E%A7%E6%8C%89%E9%92%AE-%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/>第2章_MySQL的调控按钮-启动选项和系统变量</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC1%E7%AB%A0_%E8%A3%85%E4%BD%9C%E8%87%AA%E5%B7%B1%E6%98%AF%E4%B8%AA%E5%B0%8F%E7%99%BD-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86MySQL/>第1章_装作自己是个小白-重新认识MySQL</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC0%E7%AB%A0_%E4%B8%87%E9%87%8C%E9%95%BF%E5%BE%81%E7%AC%AC%E4%B8%80%E6%AD%A5%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81-%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E7%9A%84%E9%98%85%E8%AF%BB%E6%9C%AC%E5%B0%8F%E5%86%8C/>第0章_万里长征第一步(非常重要)-如何愉快的阅读本小册</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC11%E7%AB%A0_%E4%B8%A4%E4%B8%AA%E8%A1%A8%E7%9A%84%E4%BA%B2%E5%AF%86%E6%8E%A5%E8%A7%A6-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/>第11章_两个表的亲密接触-连接的原理</a></li></ul></li><li><input type=checkbox id=section-14acbe73a39f7c2e8d055bbdbab560d6 class=toggle>
<label for=section-14acbe73a39f7c2e8d055bbdbab560d6 class="flex justify-between"><a role=button>_MySQL是怎样运行的_</a></label><ul><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/08/>08数据的家--MySQL的数据目录</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/07/>07B+数索引的使用</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/06/>06B+树索引</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/05/>05InnoDB数据页结构</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/04/>04InnoDB记录存储结构</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/03/>03字符集和比较规则</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/02/>02启动选项和系统变量</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/01/>01初识MySQL</a></li></ul></li><li><input type=checkbox id=section-522269efe4a436e18b16a29ff12d542d class=toggle>
<label for=section-522269efe4a436e18b16a29ff12d542d class="flex justify-between"><a role=button>高性能 My SQL</a></label><ul><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83/>封面-版权</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC9%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96/>第9章操作系统和硬件优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC8%E7%AB%A0%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/>第8章优化服务器设置</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC7%E7%AB%A0MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/>第7章MySQL高级特性</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC6%E7%AB%A0%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>第6章查询性能优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC5%E7%AB%A0%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/>第5章创建高性能的索引</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC4%E7%AB%A0Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/>第4章Schema与数据类型优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC3%E7%AB%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/>第3章服务器性能剖析</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC2%E7%AB%A0MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/>第2章MySQL基准测试</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC1%E7%AB%A0MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2/>第1章MySQL架构与历史</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC16%E7%AB%A0MySQL%E7%94%A8%E6%88%B7%E5%B7%A5%E5%85%B7/>第16章MySQL用户工具</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC15%E7%AB%A0%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/>第15章备份与恢复</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC14%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82%E4%BC%98%E5%8C%96/>第14章应用层优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC13%E7%AB%A0%E4%BA%91%E7%AB%AF%E7%9A%84MySQL/>第13章云端的MySQL</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC12%E7%AB%A0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/>第12章高可用性</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC11%E7%AB%A0%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84MySQL/>第11章可扩展的MySQL</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC10%E7%AB%A0%E5%A4%8D%E5%88%B6/>第10章复制</a></li></ul></li><li><input type=checkbox id=section-33ad04dc8d65b11ab6b2d2e0964c3c89 class=toggle>
<label for=section-33ad04dc8d65b11ab6b2d2e0964c3c89 class="flex justify-between"><a role=button>进阶(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MySQL/bl_sgg_/96-00/>mysql高阶_sgg 96-00</a></li></ul></li></ul></li><li><input type=checkbox id=section-d9652e1d39ed08192f3dd99c4361d9ad class=toggle checked>
<label for=section-d9652e1d39ed08192f3dd99c4361d9ad class="flex justify-between"><a role=button>SpringCloud</a></label><ul><li><span>SpringCloud</span><ul><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E5%B0%81%E9%9D%A2-%E7%9B%AE%E5%BD%95/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC10%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7I_O/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC11%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC12%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC2%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC4%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC5%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC6%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC7%E7%AB%A0-%E9%93%BE%E6%8E%A5/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/ class=active>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC9%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C-2-6/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%92%8C%E9%80%9A%E4%BF%A1-10-12/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-7-9/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E9%99%84%E5%BD%95A-%E5%B0%81%E5%BA%95/>Index</a></li></ul></li></ul></li><li><input type=checkbox id=section-1dd4601389ea65ef400f95373226aee0 class=toggle>
<label for=section-1dd4601389ea65ef400f95373226aee0 class="flex justify-between"><a role=button>Linux</a></label><ul><li><input type=checkbox id=section-eb3a110e9a221e46d625b63087e91152 class=toggle>
<label for=section-eb3a110e9a221e46d625b63087e91152 class="flex justify-between"><a role=button>SHELL编程(learnLinuxTV)_</a></label><ul><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/16-18/>16-18</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/12-15/>12-15</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/11DataStreams/>11DataStreams</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/07-10/>07-10</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/06ExitCode/>06ExitCode</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/05If/>05If</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/01-04/>01-04</a></li></ul></li><li><input type=checkbox id=section-cd7838d42e3d9f745d945ce90940f02e class=toggle>
<label for=section-cd7838d42e3d9f745d945ce90940f02e class="flex justify-between"><a role=button>韩顺平老师_</a></label><ul><li><a href=/zh/docs/technology/Linux/hanshunping_/52-x/>52-X</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/40-51/>linux_韩老师_40-51</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/28-39/>linux_韩老师_28-39</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/21-27/>linux_韩老师_21-33</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/12-20/>linux_韩老师_12-20</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/07-11/>linux_韩老师_07-11</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/01-06/>linux_韩老师_01-06</a></li></ul></li><li><a href=/zh/docs/technology/Linux/_TheLinuxCommandsHandbook_/>_TheLinuxCommandsHandbook_</a></li><li><a href=/zh/docs/technology/Linux/basic/>基本操作</a></li><li><a href=/zh/docs/technology/Linux/create_clone/>vmware上linux主机的安装和克隆</a></li></ul></li><li><input type=checkbox id=section-9f56b27db6873dfaab68a13a9088b050 class=toggle>
<label for=section-9f56b27db6873dfaab68a13a9088b050 class="flex justify-between"><a role=button>Reg Exp</a></label><ul><li><input type=checkbox id=section-e7092def48f35456be32e3b6257559e4 class=toggle>
<label for=section-e7092def48f35456be32e3b6257559e4 class="flex justify-between"><a role=button>基础(CoreySchafer)_</a></label><ul><li><a href=/zh/docs/technology/RegExp/baseCoreySchafer_/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class=toggle>
<label for=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class="flex justify-between"><a role=button>Hugo</a></label><ul><li><input type=checkbox id=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class=toggle>
<label for=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class="flex justify-between"><a role=button>主题</a></label><ul><li><a href=/zh/docs/technology/Hugo/themes/PaperMod/01/>使用PaperMode</a></li></ul></li><li><input type=checkbox id=section-d72f299b202b2766d1efe5fb807ed184 class=toggle>
<label for=section-d72f299b202b2766d1efe5fb807ed184 class="flex justify-between"><a role=button>基础(Giraffe学院)_</a></label><ul><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced20-23/>hugo进阶学习20-23</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced17-19/>hugo进阶学习17-19</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced11-16/>hugo进阶学习11-15</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced01-10/>hugo进阶学习01-10</a></li></ul></li></ul></li><li><input type=checkbox id=section-43be5f3c9fb2465efc746ae00240e4b3 class=toggle>
<label for=section-43be5f3c9fb2465efc746ae00240e4b3 class="flex justify-between"><a role=button>Obsidian</a></label><ul><li><a href=/zh/docs/technology/Obsidian/border-theme/>border-theme背景图片问题</a></li><li><a href=/zh/docs/technology/Obsidian/obsidian-theme/>obsidian-theme</a></li><li><a href=/zh/docs/technology/Obsidian/plugin/>plugin</a></li></ul></li><li><input type=checkbox id=section-7123c56777444b2f7157631dd88ad8f6 class=toggle>
<label for=section-7123c56777444b2f7157631dd88ad8f6 class="flex justify-between"><a role=button>Redis</a></label><ul><li><input type=checkbox id=section-e6cea4f92582460cfa10699a07a10e32 class=toggle>
<label for=section-e6cea4f92582460cfa10699a07a10e32 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/19-A/>redis_尚硅谷_19-A</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/18/>redis_尚硅谷_18</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/12-17/>redis_尚硅谷_12-17</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/06-11/>redis_尚硅谷_06-11</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/01-05/>redis_尚硅谷_01-05</a></li></ul></li><li><a href=/zh/docs/technology/Redis/rsync-use/>rsync使用</a></li><li><a href=/zh/docs/technology/Redis/redis-cluster/>redis集群搭建</a></li></ul></li><li><input type=checkbox id=section-a94b8d7740a71c28fc6e0f89885b2468 class=toggle>
<label for=section-a94b8d7740a71c28fc6e0f89885b2468 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><input type=checkbox id=section-64c6733376d70496ded44b4ef3db6718 class=toggle>
<label for=section-64c6733376d70496ded44b4ef3db6718 class="flex justify-between"><a role=button>_深入理解Java虚拟机_</a></label><ul><li><a href=/zh/docs/technology/JVM/_understanding_the_jvm_/03/>03垃圾收集器与内存分配策略</a></li></ul></li></ul></li><li><input type=checkbox id=section-e8f515fe7fc71d283363385aa363c2dd class=toggle>
<label for=section-e8f515fe7fc71d283363385aa363c2dd class="flex justify-between"><a role=button>其他</a></label><ul><li><a href=/zh/docs/technology/Other/kaoshi/>科目</a></li><li><a href=/zh/docs/technology/Other/pc_base/>电脑基础操作</a></li></ul></li><li><input type=checkbox id=section-f54112ca99b135fbc484938888b1f1a2 class=toggle>
<label for=section-f54112ca99b135fbc484938888b1f1a2 class="flex justify-between"><a href=/zh/docs/technology/Review/>面试</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/>JavaGuide</a><ul><li><input type=checkbox id=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class=toggle>
<label for=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class="flex justify-between"><a role=button>数据库</a></label><ul><li><input type=checkbox id=section-e7660273cef85dff1f39af04a42bd062 class=toggle>
<label for=section-e7660273cef85dff1f39af04a42bd062 class="flex justify-between"><a role=button>MySQL</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0606lymysql-query-execution-plan/>mysql执行计划</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0611lymysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0610lymysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0609lyindex-invalidation-caused-by-implicit-conversion/>MySQL中的隐式转换造成的索引失效</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0608lysome-thoughts-on-database-storage-time/>MySQL数据库时间类型数据存储建议</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0605lyhow-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0604lyinnodb-implementation-of-mvcc/>innodb引擎对MVCC的实现</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0603lytransaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0602lymysql-logs/>日志</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0601lymysql-index/>索引</a></li></ul></li><li><input type=checkbox id=section-680d077436e58b0cad0a63ed8edb5f53 class=toggle>
<label for=section-680d077436e58b0cad0a63ed8edb5f53 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/diagram/>redis问题图解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0703ly3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0704lyredis-memory-fragmentation/>redis内存碎片</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0702lyredis-spec-data-structure/>redis特殊数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0701lyredis-base-data-structures/>redis基本数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0706lyredis-questions-02/>redis面试题02</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0705lyredis-questions-01/>redis面试题01</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0503lysql-question-01/>sql常见面试题总结01</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0504lysql-syntax-summary/>sql语法基础知识总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0502lycharactor-set/>字符集详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0501lybasis/>数据库基础</a></li></ul></li><li><input type=checkbox id=section-a1b717b4079938cc0efe574541b240b8 class=toggle>
<label for=section-a1b717b4079938cc0efe574541b240b8 class="flex justify-between"><a role=button>系统设计</a></label><ul><li><input type=checkbox id=section-9eaf95f03abf595bfdf838c4b4cdb2ef class=toggle>
<label for=section-9eaf95f03abf595bfdf838c4b4cdb2ef class="flex justify-between"><a role=button>安全</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly06ly_sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly05ly_design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly04ly_sso-intro/>sso单点登录</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly03ly_jwt-advantages-disadvantages/>jwt身份认证优缺点</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly02ly_jwt-intro/>jwt-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly01ly_basis-of-authority-certification/>认证授权基础概念详解</a></li></ul></li><li><input type=checkbox id=section-79417049c90714c6ddbf18a3c3958148 class=toggle>
<label for=section-79417049c90714c6ddbf18a3c3958148 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/unit-test/>单元测试</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/software-engineering/>软件工程简明教程</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/restful/>restFul</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/web-real-time-message-push/>web-real-time-message-push</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/schedule-task/>Java定时任务详解</a></li></ul></li><li><input type=checkbox id=section-0a9533f3005d615c696f74456e46d269 class=toggle>
<label for=section-0a9533f3005d615c696f74456e46d269 class="flex justify-between"><a role=button>高可用</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly05ly_performance-test/>性能测试入门</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly04ly_timout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly03ly_limit-request/>服务限流详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly02ly_redundancy/>冗余设计</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly01ly_high-availability-system-design/>高可用系统设计指南</a></li></ul></li><li><input type=checkbox id=section-e36f94f48e5027e7cbd39b7f7bbc249c class=toggle>
<label for=section-e36f94f48e5027e7cbd39b7f7bbc249c class="flex justify-between"><a role=button>高性能</a></label><ul><li><input type=checkbox id=section-581624dd7aa25a150f706312689ba446 class=toggle>
<label for=section-581624dd7aa25a150f706312689ba446 class="flex justify-between"><a role=button>RocketMQ</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-questions/>rocketmq常见面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-intro/>rocketmq介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/base/>message-queue</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly02ly_cdn/>cdn</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly01ly_read-and-write-separation-and-library-subtable/>数据库读写分离&分库分表详解</a></li></ul></li><li><input type=checkbox id=section-a6916634f1b5324076467df4cc9ac3b5 class=toggle>
<label for=section-a6916634f1b5324076467df4cc9ac3b5 class="flex justify-between"><a role=button>分布式系统</a></label><ul><li><input type=checkbox id=section-0c8e62b6137b614e01882e2a88ea5daf class=toggle>
<label for=section-0c8e62b6137b614e01882e2a88ea5daf class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/raft-algorithm/>raft算法</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/paxos-algorithm/>paxos算法</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/cap_base-theorem/>CAP&amp;BASE 理论</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly08ly_zookeeper-in-action/>zookeeper实战</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly07ly_zookeeper-plus/>zookeeper进阶</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly06ly_zookeeper-intro/>zookeeper介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly04ly_rpc-http/>rpc_http</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly05ly_rpc-intro/>rpc基础及面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly03ly_distributed-lock/>分布式锁</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly02ly_distributed-id/>分布式id</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly01ly_api-gateway/>api网关</a></li></ul></li><li><input type=checkbox id=section-ce3cbb53c62f67624e4ab24a5a14298a class=toggle>
<label for=section-ce3cbb53c62f67624e4ab24a5a14298a class="flex justify-between"><a role=button>框架</a></label><ul><li><input type=checkbox id=section-dbe480810d1877286936b38cdb5e9229 class=toggle>
<label for=section-dbe480810d1877286936b38cdb5e9229 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><input type=checkbox id=section-30b916f2071579e2468767a2562433d9 class=toggle>
<label for=section-30b916f2071579e2468767a2562433d9 class="flex justify-between"><a role=button>原理</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle3/>Mybatis原理系列(3)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle2/>Mybatis原理系列(2)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle1/>Mybatis原理系列(1)</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/MyBatis-interview/>Mybatis面试</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/conditional_on_class/>ConditionalOnClass实践</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly05ly_springboot-auto-assembly/>SpringBoot自动装配原理</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly04ly_spring-design-patterns/>spring 设计模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly03ly_spring-transaction/>Spring事务详情</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly02ly_spring-annotations/>Spring/SpringBoot常用注解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/>spring 常见面试题总结</a></li></ul></li><li><input type=checkbox id=section-1f6733a85e33dcc22aabbf820e3ef963 class=toggle>
<label for=section-1f6733a85e33dcc22aabbf820e3ef963 class="flex justify-between"><a role=button>开发工具</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/git/>git</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/maven/>maven</a></li></ul></li><li><input type=checkbox id=section-c01151f806b917cd0ecc4cffa72c3402 class=toggle>
<label for=section-c01151f806b917cd0ecc4cffa72c3402 class="flex justify-between"><a role=button>Java基础</a></label><ul><li><input type=checkbox id=section-26625a0c4c0bffef02640966ca545537 class=toggle>
<label for=section-26625a0c4c0bffef02640966ca545537 class="flex justify-between"><a role=button>并发</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly030301lyatomicpre/>Atomic预备知识</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0311lycompletablefuture-intro/>completablefuture-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0310lythreadlocal/>ThreadLocal详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0309lyatomic-classes/>Atomic原子类介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0308lyaqs-details/>aqs详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0307lyconcurrent-collections/>java常见并发容器</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0306lythread-pool-best/>线程池最佳实践</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0305lyjava-thread-pool/>java线程池详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0304lyjmm/>java内存模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0303lyconcurrent-03/>并发03</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03122lylock_escalation/>锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated2/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03121lyobject-concurrent/>对象内存布局和对象头</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0302lyconcurrent-02/>并发02</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0301lyconcurrent-01/>并发01</a></li></ul></li><li><input type=checkbox id=section-8f747d8f024fbfe2b392a25696e01266 class=toggle>
<label for=section-8f747d8f024fbfe2b392a25696e01266 class="flex justify-between"><a role=button>IO</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0203lyio-model/>io模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0202lyio-design-patterns/>io设计模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0201lyio/>io基础</a></li></ul></li><li><input type=checkbox id=section-7d26c3d37b0e4678a1ec776265992903 class=toggle>
<label for=section-7d26c3d37b0e4678a1ec776265992903 class="flex justify-between"><a role=button>集合</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0105lysource-code-concurrenthashmap/>ConcurrentHashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0106lysource-code-hashmap/>HashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0104lysource-code-ArrayList/>ArrayList源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0103lycollections-precautions-for-use/>集合使用注意事项</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0102lycollection_2/>集合_2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0101lycollection_1/>集合_1</a></li></ul></li><li><input type=checkbox id=section-7027a9bc1d603892e7826da81b333f38 class=toggle>
<label for=section-7027a9bc1d603892e7826da81b333f38 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0011lysyntactic_sugar/>语法糖</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0010lyjava_spi/>java_spi</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0009lyunsafe_class/>unsafe类</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0008lybig_decimal/>big_decimal</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0007lyproxy_pattern/>Java代理模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0006lyreflex/>java-reflex</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0005lyserialize/>Java序列化详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0004lypassbyvalue/>为什么Java中只有值传递</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0003lyjava_guide_basic_3/>javaGuide基础3</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0002lyjava_guide_basic_2/>javaGuide基础2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0001lyjava_guide_basic_1/>javaGuide基础1</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0408lyjdk-monitoring-and-troubleshooting-tools/>jvm监控和故障处理工具 总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0406lyjvm-params/>jvm参数</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0403lyclass-structure/>类文件结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0405lyclassloader-detail/>类加载器详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0404lyclassloader-process/>类加载过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0402lygarbage-collection/>java垃圾回收</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0407lyjvm-intro/>jvm-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0401lymemory-area/>memory-area</a></li></ul></li><li><input type=checkbox id=section-04d967d6579d47b35ececb3d233024f1 class=toggle>
<label for=section-04d967d6579d47b35ececb3d233024f1 class="flex justify-between"><a role=button>计算机基础</a></label><ul><li><input type=checkbox id=section-316b43351a75a19ac6dec86ad1a48c45 class=toggle>
<label for=section-316b43351a75a19ac6dec86ad1a48c45 class="flex justify-between"><a role=button>数据结构</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/heap/>堆</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li></ul></li></ul></li><li><input type=checkbox id=section-09d19e9c6f50e4706fe8b6d358c441ce class=toggle>
<label for=section-09d19e9c6f50e4706fe8b6d358c441ce class="flex justify-between"><a role=button>Ssm</a></label><ul><li><a href=/zh/docs/technology/Review/ssm/scope_transaction/>作用域及事务</a></li></ul></li><li><input type=checkbox id=section-11f3d4afcbd3591ad3ee5d79993e29d7 class=toggle>
<label for=section-11f3d4afcbd3591ad3ee5d79993e29d7 class="flex justify-between"><a role=button>Java基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Review/basics/member_variables_and_local_variables/>成员变量与局部变量</a></li><li><a href=/zh/docs/technology/Review/basics/recursion_and_iteration/>递归与迭代</a></li><li><a href=/zh/docs/technology/Review/basics/method_parameter_passing_mechanism/>方法的参数传递机制</a></li><li><a href=/zh/docs/technology/Review/basics/class_and_instance_initialization/>类、实例初始化</a></li><li><a href=/zh/docs/technology/Review/basics/singleton_design_pattern/>单例设计模式</a></li><li><a href=/zh/docs/technology/Review/basics/self_incrementing_variable/>自增变量</a></li></ul></li></ul></li><li><input type=checkbox id=section-2fa8d2f95840b0143e19fcee5ee1ad97 class=toggle>
<label for=section-2fa8d2f95840b0143e19fcee5ee1ad97 class="flex justify-between"><a role=button>SpringCloud</a></label><ul><li><input type=checkbox id=section-b7a5506013de8d65cad1cac0f659f728 class=toggle>
<label for=section-b7a5506013de8d65cad1cac0f659f728 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/springCloud/bl_zhouyang_/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-5057ba12f456498454476dc11b58648b class=toggle>
<label for=section-5057ba12f456498454476dc11b58648b class="flex justify-between"><a role=button>Git</a></label><ul><li><input type=checkbox id=section-55d261358c84b4996ac8d7851d37ccf8 class=toggle>
<label for=section-55d261358c84b4996ac8d7851d37ccf8 class="flex justify-between"><a role=button>基础(尚硅谷视频)_</a></label><ul><li><a href=/zh/docs/technology/Git/git_sgg_/19-26/>19-26_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg_/09-18/>09-18_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg_/01-08/>01-08_git_尚硅谷</a></li></ul></li></ul></li><li><input type=checkbox id=section-d8f59257917ebff8da82fd22583ae10c class=toggle>
<label for=section-d8f59257917ebff8da82fd22583ae10c class="flex justify-between"><a role=button>Maven</a></label><ul><li><input type=checkbox id=section-9b52bdf229c64237c3a478dc6a533410 class=toggle>
<label for=section-9b52bdf229c64237c3a478dc6a533410 class="flex justify-between"><a role=button>进阶(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/advance_dljd_/01-21/>01-21 maven多模块管理_动力节点</a></li></ul></li><li><input type=checkbox id=section-3b2851b4ae70cae160ce8f24dba7236a class=toggle>
<label for=section-3b2851b4ae70cae160ce8f24dba7236a class="flex justify-between"><a role=button>基础(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/base_dljd_/31-43/>31-43 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd_/17-30/>17-30 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd_/01-16/>01-16 maven基础_动力节点</a></li></ul></li></ul></li><li><input type=checkbox id=section-d2ff9acb1ec90bec89f165361ced2010 class=toggle>
<label for=section-d2ff9acb1ec90bec89f165361ced2010 class="flex justify-between"><a role=button>算法</a></label><ul><li><input type=checkbox id=section-d1faa468beb89fe27a31308721f74c82 class=toggle>
<label for=section-d1faa468beb89fe27a31308721f74c82 class="flex justify-between"><a role=button>_算法(第四版)_</a></label><ul><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/3.2.1/>算法红皮书 3.2.1</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/3.1.1-3.1.7/>算法红皮书 3.1.1-3.1.7</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.5/>算法红皮书 2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.4/>算法红皮书 2.4</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.1.2-2.1.3/>算法红皮书 2.1.2-2.1.3</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.1.1/>算法红皮书 2.1.1</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.5.1-1.5.3/>算法红皮书 1.5.1-1.5.3</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.4.1-1.4.10/>算法红皮书 1.4.1-1.4.10</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.3.3.1-1.3.4/>算法红皮书1.3.3.1-1.3.4</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.3.1.1-1.3.2.5/>算法红皮书 1.3.1.1-1.3.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.2.1-1.2.5/>算法红皮书 1.2.1-1.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.1.6-1.1.11/>算法红皮书 1.1.6-1.1.11</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.1.1-1.1.5/>算法红皮书 1.1.1-1.1.5</a></li></ul></li></ul></li><li><input type=checkbox id=section-b414f13e51dbc5e90231aa49f06e7237 class=toggle>
<label for=section-b414f13e51dbc5e90231aa49f06e7237 class="flex justify-between"><a role=button>My Batis Plus</a></label><ul><li><input type=checkbox id=section-0e4fa61015701c3d99296175840aa5d3 class=toggle>
<label for=section-0e4fa61015701c3d99296175840aa5d3 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/40-57/>mybatis-plus-sgg-40-57</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/19-39/>mybatis-plus-sgg-19-39</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/12-18/>mybatis-plus-sgg-12-18</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/01-11/>mybatis-plus-sgg-01-11</a></li></ul></li><li><a href=/zh/docs/technology/MyBatis-Plus/official/hello/>官方的hello-world</a></li></ul></li><li><input type=checkbox id=section-1e5a67821c47d147a096480c75e0d7c4 class=toggle>
<label for=section-1e5a67821c47d147a096480c75e0d7c4 class="flex justify-between"><a role=button>Flowable</a></label><ul><li><input type=checkbox id=section-0a06ca67446b7a26392adaea7b2dc30f class=toggle>
<label for=section-0a06ca67446b7a26392adaea7b2dc30f class="flex justify-between"><a role=button>基础(波哥)_</a></label><ul><li><a href=/zh/docs/technology/Flowable/boge_blbl_/03-others/>boge-03-其他</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_6/>boge-02-flowable进阶_6</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_5/>boge-02-flowable进阶_5</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_4/>boge-02-flowable进阶_4</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_3/>boge-02-flowable进阶_3</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_2/>boge-02-flowable进阶_2</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_1/>boge-02-flowable进阶_1</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/01-base/>boge-01-flowable基础</a></li></ul></li><li><input type=checkbox id=section-6019d9043956834af14f96c2f7dcd5ca class=toggle>
<label for=section-6019d9043956834af14f96c2f7dcd5ca class="flex justify-between"><a role=button>官方文档</a></label><ul><li><a href=/zh/docs/technology/Flowable/offical/05/>Flowable-05-spring-boot</a></li><li><a href=/zh/docs/technology/Flowable/offical/04/>Flowable-04-spring</a></li><li><a href=/zh/docs/technology/Flowable/offical/03/>Flowable-03-api</a></li><li><a href=/zh/docs/technology/Flowable/offical/02/>Flowable-02-Configuration</a></li><li><a href=/zh/docs/technology/Flowable/offical/01/>Flowable-01-GettingStarted</a></li></ul></li><li><a href=/zh/docs/technology/Flowable/zsx_design/01/>zsx_flowable_design01</a></li></ul></li><li><input type=checkbox id=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class=toggle>
<label for=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class="flex justify-between"><a role=button>Rocket Mq</a></label><ul><li><input type=checkbox id=section-8c49e88e8756a0a7b3e45abde3117dd5 class=toggle>
<label for=section-8c49e88e8756a0a7b3e45abde3117dd5 class="flex justify-between"><a role=button>基础(黑马)_</a></label><ul><li><a href=/zh/docs/technology/RocketMQ/heima_/05advance/>05高级功能</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/04case/>04案例</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/03messagetype/>03收发消息</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/02buildcluster/>02双主双从集群搭建</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/01base/>01rocketmq学习</a></li></ul></li></ul></li><li><input type=checkbox id=section-dcbf6163d9f750f7cc3b9417d1386331 class=toggle>
<label for=section-dcbf6163d9f750f7cc3b9417d1386331 class="flex justify-between"><a href=/zh/docs/technology/Interview/>Interview</a></label><ul><li><input type=checkbox id=section-c8fd55079fae864a8c659fb14cbb379e class=toggle>
<label for=section-c8fd55079fae864a8c659fb14cbb379e class="flex justify-between"><a role=button>Cs Basics</a></label><ul><li><input type=checkbox id=section-ac5cd91bf1acc2a16a9dbdfa9c17f629 class=toggle>
<label for=section-ac5cd91bf1acc2a16a9dbdfa9c17f629 class="flex justify-between"><a role=button>Algorithms</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/common-data-structures-leetcode-recommendations/>常见数据结构经典LeetCode题目推荐</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/linkedlist-algorithm-problems/>几道常见的链表算法题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/string-algorithm-problems/>几道常见的字符串算法题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/the-sword-refers-to-offer/>剑指offer部分编程题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/classical-algorithm-problems-recommendations/>经典算法思想总结（含LeetCode题目推荐）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/10-classical-sorting-algorithms/>十大经典排序算法总结</a></li></ul></li><li><input type=checkbox id=section-f435ca39dd71dd7765b81dd8ec05c344 class=toggle>
<label for=section-f435ca39dd71dd7765b81dd8ec05c344 class="flex justify-between"><a role=button>Data Structure</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/heap/>Index</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/bloom-filter/>布隆过滤器</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/red-black-tree/>红黑树</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li><li><input type=checkbox id=section-fa182df3abee2343aa6c977c2a75dda2 class=toggle>
<label for=section-fa182df3abee2343aa6c977c2a75dda2 class="flex justify-between"><a role=button>Network</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/network/computer-network-xiexiren-summary/>《计算机网络》（谢希仁）内容总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/arp/>ARP 协议详解(网络层)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/dns/>DNS 域名系统详解（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http1.0-vs-http1.1/>HTTP 1.0 vs HTTP 1.1（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http-vs-https/>HTTP vs HTTPS（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http-status-codes/>HTTP 常见状态码总结（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/nat/>NAT 协议详解（网络层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/osi-and-tcp-ip-model/>OSI 和 TCP/IP 网络分层模型详解（基础）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/tcp-reliability-guarantee/>TCP 传输可靠性保障（传输层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/tcp-connection-and-disconnection/>TCP 三次握手和四次挥手（传输层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/the-whole-process-of-accessing-web-pages/>访问网页的全过程（知识串联）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/other-network-questions/>计算机网络常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/other-network-questions2/>计算机网络常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/network-attack-means/>网络攻击常见手段总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/application-layer-protocol/>应用层常见协议总结（应用层）</a></li></ul></li><li><input type=checkbox id=section-76856ab8063b8754553c166410441284 class=toggle>
<label for=section-76856ab8063b8754553c166410441284 class="flex justify-between"><a role=button>Operating System</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/linux-intro/>Linux 基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/shell-intro/>Shell 编程基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-01/>操作系统常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-02/>操作系统常见面试题总结(下)</a></li></ul></li></ul></li><li><input type=checkbox id=section-fa219a2fa1e454bccf1abf45b7e68c8e class=toggle>
<label for=section-fa219a2fa1e454bccf1abf45b7e68c8e class="flex justify-between"><a role=button>Database</a></label><ul><li><input type=checkbox id=section-1e90eaf849a2719b2603214b93639e7c class=toggle>
<label for=section-1e90eaf849a2719b2603214b93639e7c class="flex justify-between"><a role=button>Elasticsearch</a></label><ul><li><a href=/zh/docs/technology/Interview/database/elasticsearch/elasticsearch-questions-01/>Elasticsearch常见面试题总结(付费)</a></li></ul></li><li><input type=checkbox id=section-36fcdf6608f26e92ce7bb1e95612ca73 class=toggle>
<label for=section-36fcdf6608f26e92ce7bb1e95612ca73 class="flex justify-between"><a role=button>Mongodb</a></label><ul><li><a href=/zh/docs/technology/Interview/database/mongodb/mongodb-questions-01/>MongoDB常见面试题总结（上）</a></li><li><a href=/zh/docs/technology/Interview/database/mongodb/mongodb-questions-02/>MongoDB常见面试题总结（下）</a></li></ul></li><li><input type=checkbox id=section-1681ed9defad2064b37ff3e603cd509c class=toggle>
<label for=section-1681ed9defad2064b37ff3e603cd509c class="flex justify-between"><a role=button>Mysql</a></label><ul><li><a href=/zh/docs/technology/Interview/database/mysql/innodb-implementation-of-mvcc/>InnoDB存储引擎对MVCC的实现</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-query-cache/>MySQL查询缓存详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/some-thoughts-on-database-storage-time/>MySQL日期类型选择建议</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-logs/>MySQL三大日志(binlog、redo log和undo log)详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/transaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-index/>MySQL索引详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/index-invalidation-caused-by-implicit-conversion/>MySQL隐式转换造成索引失效</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-query-execution-plan/>MySQL执行计划分析</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-auto-increment-primary-key-continuous/>MySQL自增主键一定是连续的吗</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/how-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/a-thousand-lines-of-mysql-study-notes/>一千行 MySQL 学习笔记</a></li></ul></li><li><input type=checkbox id=section-7b494a9accb20a42d3eb50307ebf95b8 class=toggle>
<label for=section-7b494a9accb20a42d3eb50307ebf95b8 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Interview/database/redis/3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-data-structures-02/>Redis 3 种特殊数据类型详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-data-structures-01/>Redis 5 种基本数据类型详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-questions-01/>Redis常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-questions-02/>Redis常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-common-blocking-problems-summary/>Redis常见阻塞原因总结</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-persistence/>Redis持久化机制详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-cluster/>Redis集群详解(付费)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-memory-fragmentation/>Redis内存碎片详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-skiplist/>Redis为什么用跳表实现有序集合</a></li><li><a href=/zh/docs/technology/Interview/database/redis/cache-basics/>缓存基础常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-delayed-task/>如何基于Redis实现延时任务</a></li></ul></li><li><input type=checkbox id=section-0b495945d7d1c7bace636f2809188369 class=toggle>
<label for=section-0b495945d7d1c7bace636f2809188369 class="flex justify-between"><a role=button>SQL</a></label><ul><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-01/>SQL常见面试题总结（1）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-02/>SQL常见面试题总结（2）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-03/>SQL常见面试题总结（3）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-04/>SQL常见面试题总结（4）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-05/>SQL常见面试题总结（5）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-syntax-summary/>SQL语法基础知识总结</a></li></ul></li><li><a href=/zh/docs/technology/Interview/database/nosql/>NoSQL基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/database/basis/>数据库基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/database/character-set/>字符集详解</a></li></ul></li><li><input type=checkbox id=section-9bc7f274474a2d4825bfb7e0f835ec9f class=toggle>
<label for=section-9bc7f274474a2d4825bfb7e0f835ec9f class="flex justify-between"><a role=button>Distributed System</a></label><ul><li><input type=checkbox id=section-4aa0a804a8f6d6d2745a8f9d92dbae63 class=toggle>
<label for=section-4aa0a804a8f6d6d2745a8f9d92dbae63 class="flex justify-between"><a role=button>Distributed Process Coordination</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-in-action/>ZooKeeper 实战</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus/>ZooKeeper相关概念总结(进阶)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro/>ZooKeeper相关概念总结(入门)</a></li></ul></li><li><input type=checkbox id=section-917636e43923e143cb27e958ae247d83 class=toggle>
<label for=section-917636e43923e143cb27e958ae247d83 class="flex justify-between"><a role=button>Protocol</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/cap-and-base-theorem/>CAP & BASE理论详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/gossip-protocl/>Gossip 协议详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/paxos-algorithm/>Paxos 算法详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/raft-algorithm/>Raft 算法详解</a></li></ul></li><li><input type=checkbox id=section-5f212fdd6451198aab8e6d9d1c28c4d2 class=toggle>
<label for=section-5f212fdd6451198aab8e6d9d1c28c4d2 class="flex justify-between"><a role=button>Rpc</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/dubbo/>Dubbo常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/rpc-intro/>RPC基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/httprpc/>有了 HTTP 协议，为什么还要有 RPC ？</a></li></ul></li><li><a href=/zh/docs/technology/Interview/distributed-system/api-gateway/>API网关基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/spring-cloud-gateway-questions/>Spring Cloud Gateway常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-id/>分布式ID介绍&实现方案总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-id-design/>分布式ID设计指南</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-configuration-center/>分布式配置中心常见问题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-transaction/>分布式事务常见解决方案总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-lock-implementations/>分布式锁常见实现方案总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-lock/>分布式锁介绍</a></li></ul></li><li><input type=checkbox id=section-20eb042d5085894960b2b40cdde1bd95 class=toggle>
<label for=section-20eb042d5085894960b2b40cdde1bd95 class="flex justify-between"><a role=button>High Availability</a></label><ul><li><a href=/zh/docs/technology/Interview/high-availability/timeout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/limit-request/>服务限流详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/high-availability-system-design/>高可用系统设计指南</a></li><li><a href=/zh/docs/technology/Interview/high-availability/fallback-and-circuit-breaker/>降级&熔断详解(付费)</a></li><li><a href=/zh/docs/technology/Interview/high-availability/redundancy/>冗余设计详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/performance-test/>性能测试入门</a></li></ul></li><li><input type=checkbox id=section-d863e9c02108d739d2116dee6c3f0df2 class=toggle>
<label for=section-d863e9c02108d739d2116dee6c3f0df2 class="flex justify-between"><a role=button>High Performance</a></label><ul><li><a href=/zh/docs/technology/Interview/high-performance/cdn/>CDN工作原理详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/disruptor-questions/>Disruptor常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/kafka-questions-01/>Kafka常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/rabbitmq-questions/>RabbitMQ常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/rocketmq-questions/>RocketMQ常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/sql-optimization/>常见SQL优化手段总结（付费）</a></li><li><a href=/zh/docs/technology/Interview/high-performance/read-and-write-separation-and-library-subtable/>读写分离和分库分表详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/load-balancing/>负载均衡原理及算法详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/deep-pagination-optimization/>深度分页介绍及优化建议</a></li><li><a href=/zh/docs/technology/Interview/high-performance/data-cold-hot-separation/>数据冷热分离详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/message-queue/>消息队列基础知识总结</a></li></ul></li><li><input type=checkbox id=section-2874dffbab1645c0b90b66f58878baeb class=toggle>
<label for=section-2874dffbab1645c0b90b66f58878baeb class="flex justify-between"><a role=button>High Quality Technical Articles</a></label><ul><li><input type=checkbox id=section-043c9e2ae521f883513d71615d921b93 class=toggle>
<label for=section-043c9e2ae521f883513d71615d921b93 class="flex justify-between"><a role=button>Advanced Programmer</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant/>程序员的技术成长战略</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/programmer-quickly-learn-new-technology/>程序员如何快速学习新技术</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/seven-tips-for-becoming-an-advanced-programmer/>给想成长为高级别开发同学的七条建议</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work/>工作五年之后，对技术和业务的思考</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/meituan-three-year-summary-lesson-10/>美团三年，总结的10条血泪教训</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road/>十年大厂成长之路</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/20-bad-habits-of-bad-programmers/>糟糕程序员的 20 个坏习惯</a></li></ul></li><li><input type=checkbox id=section-5a7311ea7fe807f97a6fa93dffde10b6 class=toggle>
<label for=section-5a7311ea7fe807f97a6fa93dffde10b6 class="flex justify-between"><a role=button>Interview</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/some-secrets-about-alibaba-interview/>阿里技术面试的一些秘密</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/technical-preliminary-preparation/>从面试官和候选者的角度谈如何准备技术初试</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/summary-of-spring-recruitment/>普通人的春招总结（阿里、腾讯offer）</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology/>如何在技术初试中考察程序员的技术能力</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/screen-candidates-for-packaging/>如何甄别应聘者的包装程度</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/my-personal-experience-in-2021/>校招进入飞书的个人经验</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer/>一位大龄程序员所经历的面试的历炼和思考</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-of-get-offer-from-over-20-big-companies/>斩获 20+ 大厂 offer 的面试经验分享</a></li></ul></li><li><input type=checkbox id=section-bf0bb8140b840e0af3c2632b6b73e609 class=toggle>
<label for=section-bf0bb8140b840e0af3c2632b6b73e609 class="flex justify-between"><a role=button>Personal Experience</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/four-year-work-in-tencent-summary/>从校招入职腾讯的四年工作总结</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao/>滴滴和头条两年后端工作经验分享</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/huawei-od-275-days/>华为 OD 275 天后，我进了腾讯！</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/8-years-programmer-work-summary/>一个中科大差生的 8 年程序员工作总结</a></li></ul></li><li><input type=checkbox id=section-8166233fd6553926230055376f2b97f6 class=toggle>
<label for=section-8166233fd6553926230055376f2b97f6 class="flex justify-between"><a role=button>Programmer</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/efficient-book-publishing-and-practice-guide/>程序员高效出书避坑和实践指南</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/how-do-programmers-publish-a-technical-book/>程序员怎样出版一本技术书</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/high-value-certifications-for-programmers/>程序员最该拿的几种高含金量证书</a></li></ul></li><li><input type=checkbox id=section-b607a393d7717c448e31e58c8972bbba class=toggle>
<label for=section-b607a393d7717c448e31e58c8972bbba class="flex justify-between"><a role=button>Work</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/32-tips-improving-career/>32条总结教你提升职场经验</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/employee-performance/>聊聊大厂的绩效考核</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/get-into-work-mode-quickly-when-you-join-a-company/>新入职一家公司如何快速进入工作状态</a></li></ul></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/readme/>Index</a></li></ul></li><li><input type=checkbox id=section-5680a0cf00b09d8470dc67fa0a170b89 class=toggle>
<label for=section-5680a0cf00b09d8470dc67fa0a170b89 class="flex justify-between"><a role=button>Java</a></label><ul><li><input type=checkbox id=section-6e2eabf08cfe622d9921e3edfa11e55a class=toggle>
<label for=section-6e2eabf08cfe622d9921e3edfa11e55a class="flex justify-between"><a role=button>Basis</a></label><ul><li><a href=/zh/docs/technology/Interview/java/basis/java-keyword-summary/>Index</a></li><li><a href=/zh/docs/technology/Interview/java/basis/bigdecimal/>BigDecimal 详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/spi/>Java SPI 机制详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/proxy/>Java 代理模式详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/reflection/>Java 反射机制详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/unsafe/>Java 魔法类 Unsafe 详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/serialization/>Java 序列化详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/syntactic-sugar/>Java 语法糖详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/why-there-only-value-passing-in-java/>Java 值传递详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-01/>Java基础常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-03/>Java基础常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-02/>Java基础常见面试题总结(中)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/generics-and-wildcards/>泛型&通配符详解</a></li></ul></li><li><input type=checkbox id=section-b9f81b31813c0f4b2cd6e884ad0c0511 class=toggle>
<label for=section-b9f81b31813c0f4b2cd6e884ad0c0511 class="flex justify-between"><a role=button>Collection</a></label><ul><li><a href=/zh/docs/technology/Interview/java/collection/arrayblockingqueue-source-code/>ArrayBlockingQueue 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/arraylist-source-code/>ArrayList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/concurrent-hash-map-source-code/>ConcurrentHashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/copyonwritearraylist-source-code/>CopyOnWriteArrayList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/delayqueue-source-code/>DelayQueue 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/hashmap-source-code/>HashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-questions-01/>Java集合常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-questions-02/>Java集合常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-precautions-for-use/>Java集合使用注意事项总结</a></li><li><a href=/zh/docs/technology/Interview/java/collection/linkedhashmap-source-code/>LinkedHashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/linkedlist-source-code/>LinkedList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/priorityqueue-source-code/>PriorityQueue 源码分析（付费）</a></li></ul></li><li><input type=checkbox id=section-8cc9034354bdd549787a43bea3c7c40c class=toggle>
<label for=section-8cc9034354bdd549787a43bea3c7c40c class="flex justify-between"><a role=button>Concurrent</a></label><ul><li><a href=/zh/docs/technology/Interview/java/concurrent/aqs/>AQS 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/atomic-classes/>Atomic 原子类总结</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/cas/>CAS 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/completablefuture-intro/>CompletableFuture 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-collections/>Java 常见并发容器总结</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-thread-pool-summary/>Java 线程池详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-thread-pool-best-practices/>Java 线程池最佳实践</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-01/>Java并发常见面试题总结（上）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-03/>Java并发常见面试题总结（下）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-02/>Java并发常见面试题总结（中）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/jmm/>JMM（Java 内存模型）详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/threadlocal/>ThreadLocal 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/reentrantlock/>从ReentrantLock的实现看AQS的原理及应用</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/optimistic-lock-and-pessimistic-lock/>乐观锁和悲观锁详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/virtual-thread/>虚拟线程常见问题总结</a></li></ul></li><li><input type=checkbox id=section-498d2cde022f952a6751a7ebd2a53aeb class=toggle>
<label for=section-498d2cde022f952a6751a7ebd2a53aeb class="flex justify-between"><a role=button>Io</a></label><ul><li><a href=/zh/docs/technology/Interview/java/io/io-basis/>Java IO 基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/java/io/io-model/>Java IO 模型详解</a></li><li><a href=/zh/docs/technology/Interview/java/io/io-design-patterns/>Java IO 设计模式总结</a></li><li><a href=/zh/docs/technology/Interview/java/io/nio-basis/>Java NIO 核心知识总结</a></li></ul></li><li><input type=checkbox id=section-9ee5b42dd6a7edc6e1c0a1c88bde9426 class=toggle>
<label for=section-9ee5b42dd6a7edc6e1c0a1c88bde9426 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/technology/Interview/java/jvm/memory-area/>Java内存区域详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jdk-monitoring-and-troubleshooting-tools/>JDK监控和故障处理工具总结</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-garbage-collection/>JVM垃圾回收详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-in-action/>JVM线上问题排查和性能调优案例</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-intro/>大白话带你认识 JVM</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/class-loading-process/>类加载过程详解</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/classloader/>类加载器详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/class-file-structure/>类文件结构详解</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-parameters-intro/>最重要的JVM参数总结</a></li></ul></li><li><input type=checkbox id=section-aad47cdb4b5f179b406c6cf1c6282621 class=toggle>
<label for=section-aad47cdb4b5f179b406c6cf1c6282621 class="flex justify-between"><a role=button>New Features</a></label><ul><li><a href=/zh/docs/technology/Interview/java/new-features/java8-tutorial-translate/>Index</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java10/>Java 10 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java11/>Java 11 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java12-13/>Java 12 & 13 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java14-15/>Java 14 & 15 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java16/>Java 16 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java17/>Java 17 新特性概览（重要）</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java18/>Java 18 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java19/>Java 19 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java20/>Java 20 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java21/>Java 21 新特性概览(重要)</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java22-23/>Java 22 & 23 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java9/>Java 9 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java8-common-new-features/>Java8 新特性实战</a></li></ul></li></ul></li><li><input type=checkbox id=section-f77457e1ea013328645923186d400509 class=toggle>
<label for=section-f77457e1ea013328645923186d400509 class="flex justify-between"><a role=button>System Design</a></label><ul><li><input type=checkbox id=section-a9a8bf9713340a4888a6db9d8f8eda42 class=toggle>
<label for=section-a9a8bf9713340a4888a6db9d8f8eda42 class="flex justify-between"><a role=button>Basis</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/basis/RESTfulAPI/>RestFul API 简明教程</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/unit-test/>单元测试到底是什么？应该怎么做？</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/software-engineering/>软件工程简明教程</a></li></ul></li><li><input type=checkbox id=section-3bbccee656befcd0673c7a7ef7393710 class=toggle>
<label for=section-3bbccee656befcd0673c7a7ef7393710 class="flex justify-between"><a role=button>Framework</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/async1/>Async 注解原理分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/Async/>Async 注解原理分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/ioc-and-aop/>IoC & AOP详解（快速搞懂）</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/mybatis/mybatis-interview/>MyBatis常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/netty/>Netty常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/springboot-source-code/>Spring Boot核心源码解读（付费）</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-transaction/>Spring 事务详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-design-patterns-summary/>Spring 中的设计模式详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-common-annotations/>Spring&amp;SpringBoot常用注解总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-boot-auto-assembly-principles/>SpringBoot 自动装配原理详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/springboot-knowledge-and-questions-summary/>SpringBoot常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-knowledge-and-questions-summary/>Spring常见面试题总结</a></li></ul></li><li><input type=checkbox id=section-2baa7507d4a9ede0d38490ad77045e56 class=toggle>
<label for=section-2baa7507d4a9ede0d38490ad77045e56 class="flex justify-between"><a role=button>Security</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/security/jwt-intro/>JWT 基础概念详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/advantages-and-disadvantages-of-jwt/>JWT 身份认证优缺点分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/sso-intro/>SSO 单点登录详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/encryption-algorithms/>常见加密算法总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/basis-of-authority-certification/>认证授权基础概念详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/data-desensitization/>数据脱敏方案总结</a></li></ul></li><li><a href=/zh/docs/technology/Interview/system-design/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/>Index</a></li><li><a href=/zh/docs/technology/Interview/system-design/schedule-task/>Java 定时任务详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/web-real-time-message-push/>Web 实时消息推送详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/design-pattern/>设计模式常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/system-design-questions/>系统设计常见面试题总结(付费)</a></li></ul></li><li><input type=checkbox id=section-b12b3763d379141770d4fa07f12c73ec class=toggle>
<label for=section-b12b3763d379141770d4fa07f12c73ec class="flex justify-between"><a role=button>Tools</a></label><ul><li><input type=checkbox id=section-b6832c2bda30f11dca94b5d9440b112e class=toggle>
<label for=section-b6832c2bda30f11dca94b5d9440b112e class="flex justify-between"><a role=button>Docker</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/docker/docker-intro/>Docker核心概念总结</a></li><li><a href=/zh/docs/technology/Interview/tools/docker/docker-in-action/>Docker实战</a></li></ul></li><li><input type=checkbox id=section-e383b654b47946dea2499bcb3c4bac31 class=toggle>
<label for=section-e383b654b47946dea2499bcb3c4bac31 class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/git/github-tips/>Github实用小技巧总结</a></li><li><a href=/zh/docs/technology/Interview/tools/git/git-intro/>Git核心概念总结</a></li></ul></li><li><input type=checkbox id=section-05546e7a7af454a542b00fa4a34f43a5 class=toggle>
<label for=section-05546e7a7af454a542b00fa4a34f43a5 class="flex justify-between"><a role=button>Gradle</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/gradle/gradle-core-concepts/>Gradle核心概念总结</a></li></ul></li><li><input type=checkbox id=section-139d2af6b95c327fa03497bf63e3a4f4 class=toggle>
<label for=section-139d2af6b95c327fa03497bf63e3a4f4 class="flex justify-between"><a role=button>Maven</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/maven/maven-core-concepts/>Maven核心概念总结</a></li><li><a href=/zh/docs/technology/Interview/tools/maven/maven-best-practices/>Maven最佳实践</a></li></ul></li></ul></li></ul></li><li><a href=/zh/docs/technology/Markdown/_SuperTutorial_/>Markdown超级教程</a></li></ul></li><li class=book-section-flat><a href=/zh/docs/problem/>问题解决</a><ul><li><input type=checkbox id=section-ab4f1dd893a7409a00858148e98c245c class=toggle>
<label for=section-ab4f1dd893a7409a00858148e98c245c class="flex justify-between"><a role=button>Other</a></label><ul><li><a href=/zh/docs/problem/Other/01/>如何搜索</a></li></ul></li><li><input type=checkbox id=section-ef3324c710f7241c89fc009a5f576fbc class=toggle>
<label for=section-ef3324c710f7241c89fc009a5f576fbc class="flex justify-between"><a role=button>Linux</a></label><ul><li><a href=/zh/docs/problem/Linux/20230919/>Linux操作符问题</a></li><li><a href=/zh/docs/problem/Linux/20230819/>Debian问题处理3</a></li><li><a href=/zh/docs/problem/Linux/20230817/>Debian问题处理2</a></li><li><a href=/zh/docs/problem/Linux/20230815/>Debian问题处理1</a></li><li><a href=/zh/docs/problem/Linux/20230803/>安卓手机及平板安装linuxDeploy的问题简记</a></li><li><a href=/zh/docs/problem/Linux/20230523/>zsh卸载后root无法登录及vm扩容centos7报错处理</a></li><li><a href=/zh/docs/problem/Linux/20221101/>post</a></li></ul></li><li><input type=checkbox id=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class=toggle>
<label for=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/problem/JVM/20230526/>JDK代理和CGLIB代理</a></li><li><a href=/zh/docs/problem/JVM/2023052302/>linux中调试open jdk</a></li></ul></li><li><input type=checkbox id=section-a028a45b205904a783d0c60e8a184391 class=toggle>
<label for=section-a028a45b205904a783d0c60e8a184391 class="flex justify-between"><a role=button>Hexo</a></label><ul><li><a href=/zh/docs/problem/Hexo/01/>hexo在线查看pdf</a></li></ul></li><li><input type=checkbox id=section-1c55bf7a5578a7de17cc1ee45681106b class=toggle>
<label for=section-1c55bf7a5578a7de17cc1ee45681106b class="flex justify-between"><a role=button>Idea</a></label><ul><li><a href=/zh/docs/problem/Idea/01/>问题01</a></li></ul></li><li><input type=checkbox id=section-66dd985e53d8e0b78efdab983762411c class=toggle>
<label for=section-66dd985e53d8e0b78efdab983762411c class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/problem/Git/01/>git使用ssh连不上</a></li></ul></li><li><input type=checkbox id=section-9440d21f7eb9f8cf7f45b16969ab18dc class=toggle>
<label for=section-9440d21f7eb9f8cf7f45b16969ab18dc class="flex justify-between"><a role=button>Hugo</a></label><ul><li><a href=/zh/docs/problem/Hugo/p1/>hugo踩坑</a></li><li><a href=/zh/docs/problem/Hugo/01a/>图片测试(hugo踩坑)</a></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/life/>生活</a><ul><li><input type=checkbox id=section-c7f767205668758142bb8053263cc14f class=toggle>
<label for=section-c7f767205668758142bb8053263cc14f class="flex justify-between"><a role=button>往日归档</a></label><ul><li><a href=/zh/docs/life/archive/20231026/>成就</a></li><li><a href=/zh/docs/life/archive/20231013/>沉没</a></li><li><a href=/zh/docs/life/archive/20230913/>鲇鱼后思</a></li><li><a href=/zh/docs/life/archive/20230912/>病愈 有感</a></li><li><a href=/zh/docs/life/archive/20220724/>人为什么要结婚(找对象)</a></li><li><a href=/zh/docs/life/archive/20220416/>《作酒》有感</a></li><li><a href=/zh/docs/life/archive/20121226/>2021年最后一个周日</a></li><li><a href=/zh/docs/life/archive/20231021/>沉沦</a></li></ul></li><li><a href=/zh/docs/life/20250103/>随想</a></li><li><a href=/zh/docs/life/dailyExcerpt/>每日摘抄</a></li><li><a href=/zh/docs/life/20240626/>知命不惧 日日自新</a></li><li><a href=/zh/docs/life/20231227/>起床临感</a></li><li><a href=/zh/docs/life/20231101/>20231101</a></li></ul></li><li class=book-section-flat><span>文化</span><ul><li><input type=checkbox id=section-b8eda9fc7502eac7b68386b9c9edef56 class=toggle>
<label for=section-b8eda9fc7502eac7b68386b9c9edef56 class="flex justify-between"><a role=button>汉字就是这么来的</a></label><ul><li><a href=/zh/docs/culture/%E6%B1%89%E5%AD%97%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E6%9D%A5%E7%9A%84/01%E8%B5%B0%E8%BF%9B%E6%B1%89%E5%AD%97%E4%B8%96%E7%95%8C/>01走进汉字世界</a></li></ul></li><li><input type=checkbox id=section-36af101672fdef38bd3af078cbe1e845 class=toggle>
<label for=section-36af101672fdef38bd3af078cbe1e845 class="flex justify-between"><a role=button>天纪</a></label><ul><li><span>人间道</span><ul><li><input type=checkbox id=section-c36005c9ebaefb7d6ad1c4b3beef5892 class=toggle>
<label for=section-c36005c9ebaefb7d6ad1c4b3beef5892 class="flex justify-between"><a role=button>下经</a></label><ul><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/64%E7%81%AB%E6%B0%B4%E6%9C%AA%E6%BF%9F/>64火水未濟</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/63%E6%B0%B4%E7%81%AB%E6%97%A2%E6%BF%9F/>63水火既濟</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/62%E9%9B%B7%E5%B1%B1%E5%B0%8F%E9%81%8E/>62雷山小過</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/61%E9%A2%A8%E6%BE%A4%E4%B8%AD%E5%AD%9A/>61風澤中孚</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/60%E6%B0%B4%E6%BE%A4%E7%AF%80/>60水澤節</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/59%E9%A2%A8%E6%B0%B4%E6%B8%99/>59風水渙</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/58%E5%85%8C%E7%88%B2%E6%BE%A4/>58兌爲澤</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/57%E5%B7%BD%E7%82%BA%E9%A2%A8/>57巽為風</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/56%E7%81%AB%E5%B1%B1%E6%97%85/>56火山旅</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/55%E9%9B%B7%E7%81%AB%E8%B1%90/>55雷火豐</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/54%E9%9B%B7%E6%BE%A4%E6%AD%B8%E5%A6%B9/>54雷澤歸妹</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/53%E9%A2%A8%E5%B1%B1%E6%BC%B8/>53風山漸</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/52%E8%89%AE%E7%82%BA%E5%B1%B1/>52艮為山</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/51%E9%9C%87%E7%88%B2%E9%9B%B7/>51震爲雷</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/50%E7%81%AB%E9%A2%A8%E9%BC%8E/>50火風鼎</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/49%E6%BE%A4%E7%81%AB%E9%9D%A9/>49澤火革</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/48%E6%B0%B4%E9%A2%A8%E4%BA%95/>48水風井</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/47%E6%BE%A4%E6%B0%B4%E5%9B%B0/>47澤水困</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/46%E5%9C%B0%E9%A2%A8%E5%8D%87/>46地風升</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/45%E6%BE%A4%E5%9C%B0%E8%90%83/>45澤地萃</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/44%E5%A4%A9%E9%A2%A8%E5%A7%A4/>44天風姤</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/43%E6%BE%A4%E5%A4%A9%E5%A4%AC/>43澤天夬</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/42%E9%A2%A8%E9%9B%B7%E7%9B%8A/>42風雷益</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/41%E5%B1%B1%E6%BE%A4%E6%90%8D/>41山澤損</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/40%E9%9B%B7%E6%B0%B4%E8%A7%A3/>40雷水解</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/39%E6%B0%B4%E5%B1%B1%E8%B9%87/>39水山蹇</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/38%E7%81%AB%E6%BE%A4%E7%9D%BD/>38火澤睽</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/37%E9%A2%A8%E7%81%AB%E5%AE%B6%E4%BA%BA/>37風火家人</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/36%E5%9C%B0%E7%81%AB%E6%98%8E%E5%A4%B7/>36地火明夷</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/35%E7%81%AB%E5%9C%B0%E6%99%89/>35火地晉</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/34%E9%9B%B7%E5%A4%A9%E5%A4%A7%E5%A3%AF/>34雷天大壯</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/33%E5%A4%A9%E5%B1%B1%E9%81%AF/>33天山遯</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/32%E9%9B%B7%E9%A2%A8%E6%81%86/>32雷風恆</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/31%E6%BE%A4%E5%B1%B1%E5%92%B8/>31澤山咸</a></li></ul></li><li><input type=checkbox id=section-15975a28a78c108ecbf451806d35782b class=toggle>
<label for=section-15975a28a78c108ecbf451806d35782b class="flex justify-between"><a role=button>上经</a></label><ul><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/30%E9%9B%A2%E7%82%BA%E7%81%AB/>30離為火</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/29%E5%9D%8E%E7%88%B2%E6%B0%B4/>29坎爲水</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/28%E6%BE%A4%E9%A2%A8%E5%A4%A7%E9%81%8E/>28澤風大過</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/27%E5%B1%B1%E9%9B%B7%E9%A0%A4/>27山雷頤</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/26%E5%B1%B1%E5%A4%A9%E5%A4%A7%E7%95%9C/>26山天大畜</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/25%E5%A4%A9%E9%9B%B7%E6%97%A0%E5%A6%84/>25天雷无妄</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/24%E5%9C%B0%E9%9B%B7%E5%BE%A9/>24地雷復</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/23%E5%B1%B1%E5%9C%B0%E5%89%9D/>23山地剝</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/22%E5%B1%B1%E7%81%AB%E8%B3%81/>22山火賁</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/21%E7%81%AB%E9%9B%B7%E5%99%AC%E5%97%91/>21火雷噬嗑</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/20%E9%A2%A8%E5%9C%B0%E8%A7%80/>20風地觀</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/19%E5%9C%B0%E6%BE%A4%E8%87%A8/>19地澤臨</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/18%E5%B1%B1%E9%A2%A8%E8%A0%B1/>18山風蠱</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/17%E6%BE%A4%E9%9B%B7%E9%9A%A8/>17澤雷隨</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/16%E9%9B%B7%E5%9C%B0%E8%B1%AB/>16雷地豫</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/15%E5%9C%B0%E5%B1%B1%E8%AC%99/>15地山謙</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/14%E7%81%AB%E5%A4%A9%E5%A4%A7%E6%9C%89/>14火天大有</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/13%E5%A4%A9%E7%81%AB%E5%90%8C%E4%BA%BA/>13天火同人</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/12%E5%A4%A9%E5%9C%B0%E5%90%A6/>12天地否</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/11%E5%9C%B0%E5%A4%A9%E6%B3%B0/>11地天泰</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/10%E5%A4%A9%E6%B3%BD%E5%B1%A5/>10天澤履</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/09%E9%A2%A8%E5%A4%A9%E5%B0%8F%E7%95%9C/>09風天小畜</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/08%E6%B0%B4%E5%9C%B0%E6%AF%94/>08水地比</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/07%E5%9C%B0%E6%B0%B4%E5%B8%AB/>07地水師</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/06%E5%A4%A9%E6%B0%B4%E8%AE%BC/>06天水讼</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/05%E6%B0%B4%E5%A4%A9%E9%9C%80/>05水天需</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/04%E5%B1%B1%E6%B0%B4%E8%92%99/>04山水蒙</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/03%E6%B0%B4%E9%9B%B7%E5%B1%AF/>03水雷屯</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/02%E5%9D%A4%E4%B8%BA%E5%9C%B0/>02坤爲地</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/01%E4%B9%BE%E4%B8%BA%E5%A4%A9/>01乾爲天</a></li></ul></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/0%E5%BA%8F/>序</a></li></ul></li></ul></li><li><input type=checkbox id=section-2caf93f41e261fb08fbc8abd7e4170d5 class=toggle>
<label for=section-2caf93f41e261fb08fbc8abd7e4170d5 class="flex justify-between"><a role=button>论语</a></label><ul><li><input type=checkbox id=section-0d6e955a0862e2b200af0e2a2f889dd6 class=toggle>
<label for=section-0d6e955a0862e2b200af0e2a2f889dd6 class="flex justify-between"><a role=button>论语译注 杨伯峻</a></label><ul><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/19%E5%AD%90%E5%BC%A0%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B9%9D/>19子张篇第十九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/13%E5%AD%90%E8%B7%AF%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%89/>13子路篇第十三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/09%E5%AD%90%E7%BD%95%E7%AF%87%E7%AC%AC%E4%B9%9D/>09子罕篇第九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/06%E9%9B%8D%E4%B9%9F%E7%AF%87%E7%AC%AC%E5%85%AD/>06雍也篇第六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/20%E5%B0%A7%E6%9B%B0%E7%AF%87%E7%AC%AC%E4%BA%8C%E5%8D%81/>20尧曰篇第二十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/17%E9%98%B3%E8%B4%A7%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%83/>17阳货篇第十七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/12%E9%A2%9C%E6%B8%8A%E7%AF%87%E7%AC%AC%E5%8D%81%E4%BA%8C/>12颜渊篇第十二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/01%E5%AD%A6%E8%80%8C%E7%AF%87%E7%AC%AC%E4%B8%80/>01学而篇第一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/10%E4%B9%A1%E5%85%9A%E7%AF%87%E7%AC%AC%E5%8D%81/>10乡党篇第十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/14%E5%AE%AA%E9%97%AE%E7%AF%87%E7%AC%AC%E5%8D%81%E5%9B%9B/>14宪问篇第十四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/11%E5%85%88%E8%BF%9B%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%80/>11先进篇第十一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/18%E5%BE%AE%E5%AD%90%E7%AF%87%E7%AC%AC%E5%8D%81%E5%85%AB/>18微子篇第十八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/02%E4%B8%BA%E6%94%BF%E7%AF%87%E7%AC%AC%E4%BA%8C/>02为政篇第二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AF%87%E7%AC%AC%E5%8D%81%E4%BA%94/>15卫灵公篇第十五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/08%E6%B3%B0%E4%BC%AF%E7%AF%87%E7%AC%AC%E5%85%AB/>08泰伯篇第八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/07%E8%BF%B0%E8%80%8C%E7%AF%87%E7%AC%AC%E4%B8%83/>07述而篇第七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/%E8%AF%95%E8%AE%BA-%E5%AF%BC%E8%A8%80-%E4%BE%8B%E8%A8%80/>试论-导言-例言</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/04%E9%87%8C%E4%BB%81%E7%AF%87%E7%AC%AC%E5%9B%9B/>04里仁篇第四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/16%E5%AD%A3%E6%B0%8F%E7%AF%87%E7%AC%AC%E5%8D%81%E5%85%AD/>16季氏篇第十六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AF%87%E7%AC%AC%E4%BA%94/>05公冶长篇第五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/03%E5%85%AB%E4%BD%BE%E7%AF%87%E7%AC%AC%E4%B8%89/>03八佾篇第三</a></li></ul></li><li><input type=checkbox id=section-3c0bd8b9ce8b9615dcc02b6df6e7788e class=toggle>
<label for=section-3c0bd8b9ce8b9615dcc02b6df6e7788e class="flex justify-between"><a role=button>论语的生活智慧</a></label><ul><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/01%E5%AD%A6%E5%A4%A9%E7%AC%AC%E4%B8%80/>01学天第一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/02%E4%B8%BA%E6%94%BF%E7%AC%AC%E4%BA%8C/>02为政第二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/03%E5%85%AB%E4%BD%BE%E7%AC%AC%E4%B8%89/>03八佾第三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/04%E9%87%8C%E4%BB%81%E7%AC%AC%E5%9B%9B/>04里仁第四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AC%AC%E4%BA%94/>05公治长第五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/06%E9%9B%8D%E4%B9%9F%E7%AC%AC%E5%85%AD/>06雍也第六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/07%E8%BF%B0%E8%80%8C%E7%AC%AC%E4%B8%83/>07述而第七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/08%E6%B3%B0%E4%BC%AF%E7%AC%AC%E5%85%AB/>08泰伯第八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/09%E5%AD%90%E7%BD%95%E7%AC%AC%E4%B9%9D/>09子罕第九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/10%E4%B9%A1%E5%85%9A%E7%AC%AC%E5%8D%81/>10乡党第十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/11%E5%85%88%E8%BF%9B%E7%AC%AC%E5%8D%81%E4%B8%80/>11先进第十一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/12%E9%A2%9C%E6%B8%8A%E7%AC%AC%E5%8D%81%E4%BA%8C/>12颜渊第十二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/13%E5%AD%90%E8%B7%AF%E7%AC%AC%E5%8D%81%E4%B8%89/>13子路第十三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/14%E5%AE%AA%E9%97%AE%E7%AC%AC%E5%8D%81%E5%9B%9B/>14宪问第十四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AC%AC%E5%8D%81%E4%BA%94/>15卫灵公第十五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/16%E5%AD%A3%E6%B0%8F%E7%AC%AC%E5%8D%81%E5%85%AD/>16季氏第十六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/17%E9%98%B3%E8%B4%A7%E7%AC%AC%E5%8D%81%E4%B8%83/>17阳货第十七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/18%E5%BE%AE%E5%AD%90%E7%AC%AC%E5%8D%81%E5%85%AB/>18微子第十八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/19%E5%AD%90%E5%BC%A0%E7%AC%AC%E5%8D%81%E4%B9%9D/>19子张第十九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/20%E5%B0%A7%E6%97%A5%E7%AC%AC%E4%BA%8C%E5%8D%81/>20尧日第二十</a></li></ul></li></ul></li><li><input type=checkbox id=section-daa70c3e612b40fe4050f5185bb12608 class=toggle>
<label for=section-daa70c3e612b40fe4050f5185bb12608 class="flex justify-between"><a role=button>恰同学少年</a></label><ul><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AE%80%E4%BB%8B-%E4%BD%9C%E8%80%85/>简介-作者</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/>经典语录</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC1%E7%AB%A0-%E7%AC%AC5%E7%AB%A0/>第1章-第5章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC11%E7%AB%A0-%E7%AC%AC15%E7%AB%A0/>第11章-第15章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC16%E7%AB%A0-%E7%AC%AC20%E7%AB%A0/>第16章-第20章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC6%E7%AB%A0-%E7%AC%AC10%E7%AB%A0/>第6章-第10章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC21%E7%AB%A0-%E7%AC%AC25%E7%AB%A0/>第21章-第25章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC26%E7%AB%A0-%E7%AC%AC29%E7%AB%A0/>第26章-第29章</a></li></ul></li><li><input type=checkbox id=section-ab50087f003d55e32dba86fb838050b9 class=toggle>
<label for=section-ab50087f003d55e32dba86fb838050b9 class="flex justify-between"><a role=button>如何阅读一本书</a></label><ul><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E9%99%84%E5%BD%95/>附录</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AE%80%E4%BB%8B-%E5%BA%8F%E8%A8%80/>简介-序言</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%B8%80%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E5%B1%82%E6%AC%A1/>第一篇 阅读的层次</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E5%9B%9B%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E6%9C%80%E7%BB%88%E7%9B%AE%E6%A0%87/>第四篇 阅读的最终目标</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%B8%89%E7%AF%87_%E9%98%85%E8%AF%BB%E4%B8%8D%E5%90%8C%E8%AF%BB%E7%89%A9%E7%9A%84%E6%96%B9%E6%B3%95/>第三篇 阅读不同读物的方法</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%BA%8C%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1_%E5%88%86%E6%9E%90%E9%98%85%E8%AF%BB/>第二篇 阅读的第三个层次：分析阅读</a></li></ul></li><li><input type=checkbox id=section-3c72e7201480f45e35bf243c48374c4a class=toggle>
<label for=section-3c72e7201480f45e35bf243c48374c4a class="flex justify-between"><a role=button>古代天文历法讲座</a></label><ul><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E9%99%84%E5%BD%95-%E9%99%84%E8%A1%A8-%E5%90%8E%E8%AE%B0/>附录-附表-后记</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC6%E8%AE%B2-%E7%AC%AC7%E8%AE%B2/>第6讲-第7讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC4%E8%AE%B2-%E7%AC%AC5%E8%AE%B2/>第4讲-第5讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC1%E8%AE%B2-%E7%AC%AC3%E8%AE%B2/>第1讲-第3讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%89%88%E6%9D%83-%E5%BA%8F-%E5%89%8D%E8%A8%80/>版权-序-前言</a></li></ul></li><li><input type=checkbox id=section-9d5fdf0456d3af9d5079c94a509d2900 class=toggle>
<label for=section-9d5fdf0456d3af9d5079c94a509d2900 class="flex justify-between"><a role=button>置身事内</a></label><ul><li><a href=/zh/docs/culture/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/%E4%B8%8B%E7%AF%87/>下篇</a></li><li><a href=/zh/docs/culture/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/%E4%B8%8A%E7%AF%87/>上篇</a></li></ul></li><li><input type=checkbox id=section-2968790b5f933a15ae8f870afe7ff8b9 class=toggle>
<label for=section-2968790b5f933a15ae8f870afe7ff8b9 class="flex justify-between"><a role=button>中国通史(吕思勉)</a></label><ul><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8B%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%96%87%E5%8C%96%E5%8F%B2/>下编-中国文化史</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8A%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%8F%B2/>上编-中国政治史</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83-%E8%AF%BB%E5%90%8E-%E8%87%AA%E5%BA%8F/>封面-版权-读后-自序</a></li></ul></li><li><input type=checkbox id=section-77e618b9fdc931e63e2343a70dbe6630 class=toggle>
<label for=section-77e618b9fdc931e63e2343a70dbe6630 class="flex justify-between"><a role=button>资治通鉴</a></label><ul><li><input type=checkbox id=section-196ebc38f91a63032ca3483e389aa4c5 class=toggle>
<label for=section-196ebc38f91a63032ca3483e389aa4c5 class="flex justify-between"><a role=button>周纪</a></label><ul><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/>基本知识</a></li><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/001%E5%91%A8%E7%BA%AA%E4%B8%80/>001周纪一</a></li></ul></li></ul></li><li><input type=checkbox id=section-5aa85019131e2605fa7465dc987f590d class=toggle>
<label for=section-5aa85019131e2605fa7465dc987f590d class="flex justify-between"><a role=button>增广贤文</a></label><ul></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/test/>测试</a><ul><li><a href=/zh/docs/test/test2/>test2</a></li><li><a href=/zh/docs/test/mytest/>test</a></li><li><a href=/zh/docs/test/hello2/>pdfTest</a></li></ul></li></ul><ul><li><a href=/zh/posts/>博客</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Index</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#img1620c4a88871dd25f3cb5ce4b5b4d28djpegi><img src=img/1620c4a88871dd25f3cb5ce4b5b4d28d.jpeg alt>i</a><ul><li><a href=#参考文献说明>参考文献说明</a></li><li><a href=#家庭作业>家庭作业</a></li></ul></li></ul></li><li><a href=#heading>．</a></li><li><a href=#heading-1>．</a></li></ul></nav></aside></header><article class="markdown book-article"><p>第 8 章</p><p>C H A P T E R 8</p><p>异常控制流</p><p>从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列</p><p>a0 , a , , &mldr; , a ,, _1</p><p>其中，每个 ak 是某个相应的指令 I k的地址。每次从 Qk 到 a k一 1 的过渡称为控 制 转移 ( co ntro l trans £er ) 。 这样的 控制转移 序列叫做处理器的控制流( flow of cont rol 或 cont ro l flow ) 。</p><p>最简单的一种控制流 是一个“平滑的＂ 序列， 其中每个 L 和 I尸！在内存中都是相邻</p><p>的。这种 平滑流的 突变（也就是 I尸］与 L 不相邻）通常是由诸如跳转 、调用和返回这样一些熟悉的 程序指令造成的 。这样一些指令都是必要的机制， 使得程序能够对由程序变扯表示的内部程序状 态中的 变化做出反应 。</p><p>但是系统也必须能够对系统状态的变化做出反应，这 些系统状态不是被内部程序变量捕获的， 而且也不一定要和程序的执行相关。比如， 一个硬件定时 器定期产生信号 ， 这个事 件必须得到处理 。包到达网络适配器后，必 须存放在内存中。程序向磁盘请求数据， 然后休眠， 直到被通知说数据巳就绪。当子进程终止时， 创造这些子进程的父进程必须得到通知。</p><p>现代系统通过使 控制流发生突 变来对这些情况做出反应。一般而言， 我们把这些突变称为异常控制流 ( Exceptiona l Control Flow, ECF) 。异常控制流发 生在计算机系统的各个层次。比如， 在硬件层， 硬件检测到的 事件会触发控制突 然转移到异常处理程序。在操作系统层 ，内 核通过上下 文切换 将控制从一个用户进程转 移到 另一个用户进程。在应用层， 一个进 程可以发送信 号到 另一个进程， 而接收者会将控制 突然转移到它的一个信号处理程序。一个程序可以通 过回避通常的栈规则 ， 并执行到其他 函数中任意位置的非本地跳转来对错误做出反应 。</p><p>作为程序员， 理解 ECF 很重要 ， 这有很多原因：</p><ul><li><p>理解 ECF 将帮助 你理解重要 的 系统概念。ECF 是操作系统 用来实现 I/ 0 、进程和虚拟内存的基本机制。在能够真正理解这些 重要概念之前 ， 你必须理解 ECF 。</p></li><li><p>理解 ECF 将帮助你理 解应 用程序是如何与操作 系统交互的 。应用程序 通过使用一个叫做陷阱 ( t ra p) 或者 系统调 用 ( s ys tem call ) 的 ECF 形式， 向操作系统请求服务。比如，向磁盘写数据、从网络读取数据、创建一个新进程，以及终止当前进程，都 是通过应用程序调用系统调用来实现的。理解基本的 系统调用机制将帮助你理 解这些服务是如何提供给应用的。</p></li><li><p>理解 ECF 将帮 助 你 编写 有趣的 新应 用程 序。操作系统为应用程序提供了强大的</p><p>ECF 机制，用 来创建新进程、等待进程终止 、通知其他进程系统 中的异常事件， 以及检测和响应这些 事件。如果理解了这些 ECF 机制， 那么你就能用它们来编写诸如 U nix shell 和 Web 服务器 之类的有趣程序 了。</p></li><li><p>理解 ECF 将帮助你理 解并发 。ECF 是计算机系统 中实现并发的基本机制。在运行中的并发的例子有：中断应用程序执行的异常处理程序，在时间上重叠执行的进程 和线程 ， 以及中断应用程序执行的信号处理程序。理解 ECF 是理解并发的第一步。我们会 在第 12 章中更详细地研究并 发。</p></li><li><p>理解 ECF 将帮助你理解软件异常如何 工作。像 C+ + 和 J a va 这样的语言通过 t r y、c a t c h 以及 t hr o w 语 句 来 提供软件异常机制。软件异常允许程序进行非 本地跳转</p><p>（即违反通常的调用／返回栈规则的跳转）来响应错误情况。非本地跳转是一种应用 层 ECF , 在 C 中是通过 s e t j mp 和 l o ng j mp 函 数 提供的。理解这些低级函数将帮助你理解高级软件异常如何得以实现。</p><p>对系统的学习，到目前为止你巳经了解了应用是如何与硬件交互的。本章的重要性在 千你将开始学习应用是如何与操作系统交互的。有趣的是， 这些交互都是围绕着 ECF 的。我们将描述存在千一个计算机系统中所有层次上的各种形式的 ECF。从异常开始， 异常位于 硬 件和操作系统交界的部分。我们还会讨论系统调用，它 们 是 为应用程序提供到操作系统 的 入口点的异常。然后， 我们会提升抽象的层次，描 述 进程和信号， 它 们 位 于应用和操作系统的交界之处。最后讨论非本地跳转， 这是 ECF 的一种应用层形式。</p></li></ul><ol><li><p>1 异常</p><p>异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相同的。在这一节中我们的目的是让你对异常和异常处理有一个一般性的了解，并 且 向 你 揭示现代计算机系统的一个经常令人感到迷惑的方面。</p></li></ol><p>异常( exception ) 就 是控制流中的突</p><p>变，用来响应处理器状态中的某些变化。图 8-1 展示了基本的思想。</p><p>在图中，当处理器状态中发生一个</p><p>事件在</p><p>&mldr;&mldr;&mldr;&mldr;.. .</p><p>应用程序 异常处理程序</p><p><img src=img/a22ef18047078bba22c17d91993dffca.jpeg alt>Icurr</p><p>重要的变化时，处 理 器正在执行某个当前指令 J curr 。在处理器中，状 态被编码为不同的位和信号。状态变化称为事件(event) 。事件可能和当前指令的执行直接相关。比如，发 生虚拟内存缺页、算</p><p>这里发生 / next</p><p>术溢出，或者一条指令试图除以零。另 图 8- 1 异常的剖析。处理器状态中的变化（事件 ）触发从</p><p>应用程序到异常处理程序的突发的控制转移（异</p><p>一方面，事件也可能和当前指令的执行</p><p>没有关系。比如，一个系统定时器产生信号或者一个1/0 请求完成。</p><p>常）。在异常处理程序完成处理后，它将控制返回给被中断的程序或者终止</p><p>在任何情况下， 当处 理器检测到有事件发生时， 它 就 会通过一张叫做异常表( excep- tion ta ble ) 的跳转表，进 行 一 个间 接过程调用（异常）， 到 一 个 专门设计用来处理这类事件 的 操 作 系统子程序（异常 处理程序( exce pt io n ha ndle r ) ) 。当异常处理程序完成处理后，根 ｝ 据引 起异常的事件的类型， 会发生以下 3 种情况中的一种：</p><ol><li><p>处 理 程 序将控制返回给当前指令 ICUTT &rsquo; 即当事件发生时正在执行的指令。</p></li><li><p>) 处理程序将控制返回给 [ next • 如果没有发生异常将会执行的下一条指令。</p></li><li><p>) 处理程序终止被中断的程序。</p><p>8. l. 2 节将讲述关于这些可能性的更多内容。</p></li></ol><p>囚 日 硬件异常与软件异常</p><p>C ++ 和 J ava 的程序员会 注意 到术语“异常” 也 用 来描述由 C+ + 和 J a va 以 c a t ch、</p><p>t h r o w 和 七r y 语句形 式提供的应用级 ECF 。如 果想严格 清晰， 我们必须区别“ 硬件” 和</p><p>“软 件” 异 常，但 这通常是不必要的， 因 为从 上 下文中就能够很 清楚 地知道是哪种含义。</p><ol><li><p>1. 1 异常处理</p><p>异常可能会难以理解，因为处理异常需要硬件和软件紧密合作。很容易搞混哪个部分执行哪个任务。让我们更详细地来看看硬件和软件的分工吧。</p><p>系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号 ( exce ptio n n um ­ her ) 。其中一些号码是由处理器的设计者分配的， 其 他 号 码 是 由 操 作系统内核（操作系统常驻内存的部分）的设计者分配的。前者的示例包括被零除、缺页、内存访问违例、断点 以及算术运算溢出。后者的示例包括系统调用和来自外部 I / 0 设备的信号。</p><p>在系统启动时（当计算机重启或者加电</p></li></ol><p>时）， 操作系统分配和初始化一张称为异常表的跳转表，使 得表目 K 包 含异常 k 的处理程序的地址。图 8-2 展 示了异常表的格式。</p><p>在运行时（当系统在执行某个程序时），处 理器检测到发生了一个事件，并且确定了相应 的异常号 k。随后， 处理器触发异常，方 法是执行间 接过程调用，通 过异常表的表目 k , 转到相应的处理程序。图 8-3 展示了处理器如何</p><ol><li><p>二1</p><p>异常处理程序0的代码</p></li></ol><p><img src=img/f09e5c46aff66b9f371a1a3c8f598220.jpeg alt>异常处理程序l的代码异常处理程序2的代码</p><p>上</p><p>使用异常表来形成适当的异常处理程序的地址。 图 8-2 异常表。异常表是一 张跳转表， 其中表目 K</p><p>异常号是到异常表中的索引，异常表的起始地 包含异常k 的处理程序代码的地址</p><p><img src=img/089b2942ab576562ae8b35419c163bc7.jpeg alt><img src=img/c4a7354315ec565393f155022833a7a1.jpeg alt>址放在一个叫做异常表基 址寄存器( e xce ption table base register ) 的 特殊 CPU 寄存器里。</p><p>异常号</p><p>(X 84)</p><p>i 异常表</p><p>n- 11 I</p><p>图 8-3 生成异常处理程序的地址 。异常号是到异常表中的索引</p><p>异常类似于过程调用 ，但 是有一些重要的不同之处：</p><ul><li>过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一 条指令（如果事件不发生，将 会在当前指令后执行的指令）。</li><li>处理器也把一些额外的处理器状态压到栈里，在 处理程序返回时， 重新开始执行被中断的程序会需要这些状态。比如， x86-64 系统会将包含当前条件码的 EF LAGS 寄存器和其他内容压入栈中。<ul><li><p>如果控制从用户程序转移到内核，所 有这些项目都被压到内核栈中， 而不是压到用户栈中。</p></li><li><p>异常处理程序运行在内核模式下（见 8. 2. 4 节）， 这意味着它们对所有的系统资源都有完全的访间权限。</p><p>一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在处理程序处理完事件之后，它通过执行一条特殊的“从中断返回”指令，可选地返回到被中断的程</p></li></ul></li></ul><p>序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序 ， 就将状态恢复为用 户模式（见8. 2. 4 节）， 然后将控制返回给被中断的程序。</p><ol><li><p>1. 2 异常的类别</p><p>异常可以分为四类： 中断 ( interru pt ) 、陷阱( tra p) 、故障( fault) 和终止( abort )。图 8-4 中的表对这些类别 的属性做了小结。</p></li></ol><table><thead><tr><th>类别</th><th>原因</th><th>异步／同步</th><th>返回行为</th></tr></thead><tbody><tr><td>中断</td><td>来自 1/0 设备的信号</td><td>异步</td><td>总是返回到下一条指令</td></tr><tr><td>陷阱</td><td>有意的异常</td><td>同步</td><td>总是返回到下一条指令</td></tr><tr><td>故障</td><td>潜在可恢复的错误</td><td>同步</td><td>可能返回到当前指令</td></tr><tr><td>终止</td><td>不可恢复的错误</td><td>同步</td><td>不会返回</td></tr></tbody></table><p>图 8-4 异 常 的 类 别 。 异步异常是由处理器外部的 I/ 0 设备中的事件产生的。同 步异常是执行一条指令的直接产物</p><ol><li><p>中断</p><p>中断是 异步发生的 ， 是来自处理器外部的I/ 0 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从 这个意义上来说它是异步的。硬件中断的异常处理程序常常称为中断处理 程序 ( in t er ru pt hand ler ) 。</p><p>图 8-5 概述了一个中断的处理。I/ 0 设备， 例如网 络适配器、磁盘控制器和定时 器芯片，通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断， 这个异常号标识 了引起中断的设备。</p></li></ol><p>( I ) 在当前指令的执行过程中，中</p><p><img src=img/925cd9611de929cf597d007c5989ea0c.jpeg alt>f cu斤</p><p>I</p><p>断引脚 电压变高了</p><p>next</p><p>( 3 ) 中断处</p><p>理程序运行</p><p>图 8-5 中断处理。中断处理程序将控制返回给应用程序控制流中的下一 条指令</p><p>在当前指令完成 执行之后， 处理器注意到中 断引脚的电压变高了， 就从系统总线读取异常号， 然后调用适当的中断处理程序。当处 理程序返 回时，它 就将控制返回给下一条指令（也即如果没有发生中断，在控制流中会在当前指令之后的那条指令）。结果是程序继续执行， 就好像没有发生过中断一样。</p><p>剩下的异常类型（陷阱、故障和终止）是同 步发 生的，是 执行当前指令的结果。我们把这类指令叫做故障指令 ( fa ult ing ins t ru ct ion ) 。</p><ol><li><p>陷阱和系统调用</p><p>陷阱是有意的 异常 ， 是执行一条指令的结果。就像中断处理程序一样， 陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序 和内核之间提供一个像过程一样的接口， 叫做系统调用。</p><p>用 户程序经常需 要向内核请求服务， 比如读一个文件 (r e a d ) 、创建一个新的进程( for k ) 、加载一个新的程序( e x e c v e ) , 或者终止当前 进程( e x 江）。为了允许对这些内核服务的受控的访问， 处理器提供了一条特殊的 " s y s c a l l n " 指令， 当用户程序想要请求</p></li></ol><p>服务 n 时， 可以执行这条指令。执行 s y s c a l l 指令会导致一个到异常处理程序的陷阱， 这个处 理程序解析参数， 并调用适当的内核程序。图 8-6 概述了一个系统调用的处理。</p><p>( 1 ) 应用程 s ys c a l l 序执行一次系 /next 统调用</p><p><img src=img/7382637781712f8b67e83cf92fe35b61.jpeg alt>( 3 ) 陷阱处理程序运行</p><p>图 8-6 陷阱处理。陷阱处 理程序将控制返回给应用程序控制流中的下一条指令</p><p>从程序员的角度来看 ，系 统调用和普通的函数调用是 一样的。然而， 它们的实现非常不同。普通的函数运行在 用户 模式中，用 户模式限制了函数可以执行的指令的类型， 而且它们只能访问与调用函数相同的栈。系统调用运行在内核模 式中 ，内 核模式允许系统调用执行特权指令， 并访问定义在内核中的栈。8. 2. 4 节会更详细地讨论用 户模式和内核模式。</p><ol><li><p>故陪</p><p>故障由错误 情况引起，它 可能能 够被故障处理程序修 正。当故障发生时， 处理器将控制转移给故 障处理程序。如果处理程序能够修正这个错误情况，它 就将控制返回到引起故障的指令 ，从 而重新执行它。否则， 处理程序返 回到内核中的 a bor t 例程， a b o 江 例程会终止引起故 障的应用程序。图 8-7 概述了一个故障的处理。</p></li></ol><p><img src=img/693ed72c8ec7d1da47ddb11c02faf1b4.jpeg alt>( 3 ) 故障处理程序运行</p><p>•••••••••••••••••.•… &mldr; ..►.</p><p>( 4 ) 处理程序要么重新执行当前指令，要么终止</p><p>abort</p><p>图 8-7 故障处 理。根据故障是否能够被修复，故 障 处 理 程序要么重新执行引起故障的指令，要 么 终 止</p><p>一个经典的故 障示例是缺页异常， 当指令引用一个虚拟地址， 而与该地址相对应的物理页面不 在内存中， 因此必须从磁盘中取出时， 就会发生故障。就像我们将在第 9 章中看到的那样 ， 一个页面就是 虚拟内存的一个连续的块（典型的是 4K B) 。缺页处理程序从 磁盘加载适当的 页面， 然后将控制返回 给引起 故障的指令。当指令再次执行时， 相应的物理页面已 经驻留在内存中 了， 指令就可以 没有故障地运行 完成了。</p><ol start=2><li><p>终止</p><p>终止是不 可恢 复的致命错误造成的结果， 通常是一些硬件错误， 比如 DR AM 或者</p><p>SRAM 位被损坏时 发生的奇偶错误。终止处理程序从不将控制返回给应用程序。如图 8-8</p><p>所示，处 理程序将控制返 回给一个 a bor t 例程， 该例程会终止这个应用 程序。</p></li><li><p>1. 3 Linux/ x86-64 系统中的异常</p><p>为了使描述更具体 ， 让我们来看看为 x86-64 系统定义的一些异常。有高达 256 种不同的异常类型 [ 50] 。0 31 的号码对应的是由 Intel 架构师定义的异常， 因此对任何 x86-64 系统都是一样 的。32 255 的号码对应的是操作系统定义的中断和陷阱 。图 8-9 展示了一些示 例。</p></li></ol><p>( I ) 发生致命I</p><p>的硬件错误</p><p>curr</p><p>( 2 ) 传递控制给处理程序</p><p>( 3 ) 终止处理程序运行</p><p>&mldr;&mldr;&mldr;&mldr;…&mldr;&mldr;&mldr;..…. &mldr;&mldr;..►.. abort</p><p>( 4 ) 处理程序返回到</p><p>abor t 例程</p><p>图 8-8 终止处理。终止处理程序将控制传递给一个内核 abor t 例程，该 例 程会终止这个应用程序</p><p>。异常号 描述 异常类别</p><p>图 8-9 x86-64 系统中的异常示例</p><ol><li><p>Linux/ x86-6 4 故障和终止</p><p>除法错误 。当应用试图除以零时， 或者当一个除法指令的结果对于目标操作数来说太大了的时候， 就会发生除法错误（异常 0 ) 。U nix 不会试图从除法错误中恢复， 而是选择终止程序。Linu x s hell 通常会把除法错误 报告为“ 浮点异常 ( F loa ting except io n ) " 。</p><p>一般保护故障 。许多原因都会 导致不为人知的一般保护故障（异常 13 ) , 通常是因为一个程序引用了一个未定义的虚拟内存区域， 或者因为程序试图写一个只读的文本段。L in ux 不会尝试恢复这类故障。Lin ux s hell 通常会把这种一般保护故障报告为 ＂段故樟</p><p>( S eg m e n tat io n fa ult ) " 。</p><p>缺页（异常 14) 是会重新执行产生故障的指令的一个 异常示例。处理程序将适当的磁盘上虚拟内存的一个页面映射到物理内存的一个页面，然 后重新执行这条产生故障的指令。我们将在第 9 章中看到缺页是 如何工作的细节。</p><p>机器桧 查。机 器检查（异常 18 ) 是在导致故障 的指令执行中检测到致命 的硬件错误时发生的。机器检查处理程序从不返回控制给应用程序。</p><ol><li><p>Linux/ 86-64 系统调 用</p><p>L in ux 提供几百 种系统调用， 当应用程序想要请求内核服务时可以使用， 包括读文件、写文件或是创建一个新进程。图 8-10 给出了一些常见的 Lin ux 系统调用。每个系统调用都有一个唯一的整数号， 对应于一个到内核中跳转表的偏移址。（注意： 这个跳转表和异常表不一样 。）</p><p>C 程序用 s ys c a l l 函数可以直接调用任何系统调用。然而，实 际中几乎没必要这么做。对于大多数系统调用， 标准 C 库提供了一组方便的包装函数。这些包装函数将参数打包到一 起， 以 适当的系统调用指令陷人内核， 然后将系统调用的返回状态传递回调用程序 。在本书中，我们将系统调用和与它们相关联的包装函数都称为系统级函数， 这两个术语可以互换地使用。</p><p>在 x86- 64 系统上， 系统调用是通过 一条称为 s ys c a l l 的陷阱指令来提供的。研究程序能够如何使用这条指令来直接调用 L in u x 系统调用是很有趣的。所有到 Lin ux 系统调用的 参 数都是通过通用寄存器而不 是栈传递的。按照惯例， 寄存器%r a x 包含系统 调用号，</p><p>寄存器%r d i 、%r s i 、%r d x 、%r 1 0 、r% 8 和%r 9 包含最多 6 个参数。第一个参数在% r 中 中，第</p><p>二个在%r s i 中 ， 以此类推。从系统调用 返回时， 寄存器%r c x 和%r ll 都 会被破坏，%r a x 包</p></li></ol></li></ol><p>含返回值。—40 9 5 到一1 之间的 负 数返回值表明发生了错误， 对应于负的 er r n o 。</p><p>编号</p><p>图 8-10 Linux x86-64 系 统中 常用的系统调用示例</p><p>例如， 考 虑 大家熟悉的 h e l l o 程序的下 面这个版本， 用 系统级函数 wr i t e ( 见 1 0 . 4</p><p>节）来写，而 不是用 pr i n t f :</p><p>int ma i n ()</p><p>2 {</p><p>3 vrite(l, &ldquo;hello, vorld\n&rdquo;, 13) ;</p><p>_e xi t ( O) ;</p><p>5 }</p><p>wr i t e 函 数的第一个参数将输出发送到 s t d o u 七。 第二个参数是要写的字节序列， 而第三个参数是要写的字节数。</p><p>图 8-11 给出的是 h e l l o 程序的汇编语言版本， 直 接 使 用 s y s c a l l 指 令 来 调 用 wr i t e</p><p>和 e x i t 系统调用。第 9 ~ 1 3 行调用 wr i t e 函 数 。 首先， 第 9 行将系统调用 wr i t e 的 编号存放在%r a x 中 ， 第 1 0 ~ 1 2 行设 置 参数 列 表。然后第 1 3 行使用 s y s c a l l 指令来调用系统调用。类 似地，第 1 4 ~ 1 6 行调用_e x i t 系统调用。</p><p>code/ecf/hello-asm64.sa</p><p>.section .dat a str i ng:</p><ol><li><p>. a s c i i &ldquo;hello, vorld\n&rdquo;</p></li><li><p>s t r i ng _e nd :</p></li><li><p>.equ len, string_end - string</p><p>.section .text</p></li><li><p>.globl main</p></li><li><p>main:</p><p>First, call write(1, &ldquo;hello, world\n&rdquo;, 13)</p></li><li><p>movq $1, %rax write 1s system call 1</p></li><li><p>movq $1, %rdi Argl: stdout has descriptor 1</p></li><li><p>movq $s tr i ng , %rsi Arg2: hello world string</p></li></ol><table><thead><tr><th>12</th><th>mo v q $ l e n , %rdx</th><th>Arg3: string length</th></tr></thead><tbody><tr><td>13</td><td>syscall</td><td>Make the system call</td></tr></tbody></table><p>Next, call _exit(O)</p><ol><li>movq $60, %rax</li><li>movq $0, %rdi</li><li>syscall</li></ol><p>_ex1 t is system call 60 Arg1: exit status is 0 Make the system call</p><p>code/ecfh/ello-asm64.as</p><p>图8-11 直接用Linux 系统调用来实现 he ll o 程序</p><p>日 日 关千术 语的注释</p><p>各种异常类型的 术语根据系统的不同 而有所不同 。处理 器 ISA 规范通常会 区分异步</p><p>“中 断” 和同 步“异 常＂， 但是并没有提供 描述这些非 常相 似的 概念的概括性的术语。为了避免不断地提到“异常和中断”以及“异常或者中断＂，我们用单词“异常”作为通 用的 术语， 而且 只有在必要时才 区别异 步异 常（中断）和同 步异 常（陷阱、故障和终止）。正如我们提到过的，对于每个系统而言，基本的概念都是相同的，但是你应该意识到一 些制 造厂商的 手册会 用“ 异常” 仅仅 表示同 步事件 引起的 控制流的 改变。</p><ol><li><p>2 进程</p><p>异常是允许操作系统内核提供进程( pro cess ) 概念的基本构造块 ， 进程是计算机科学中最深刻、最成功的概念之一。</p><p>在现代系统上运行 一个程序时 ， 我们会得到一个假象， 就好像我们的程序是 系统中当前运行的唯一的程序一样。我们的 程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们程序中的指令。最后 ， 我们程序中 的代码和数据好像是系统内存中唯一的对象。这些假象都 是通过进程的概念提供给我们的。</p><p>进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的 上下文 ( co n t e x t ) 中。上下文是由程序正确 运行所需的状态组成的。这个状 态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变最以及 打开文件描述符的 集合。</p><p>每次用 户通过向 s hell 输入一个可执行目 标文件的名字， 运行 程序时， s hell 就会创建一个新的进程， 然后在这个新进程的上下文中运行这个 可执行目标文件。应用程序也能够创建新进程， 并且在这个新进程的上下 文中运行它们自己的代码或其他应用程序。</p><p>关千操作系统如何实现进程的 细节的讨论超出了本 书的范围。反之，我 们将关注进程提供给应用程序的关键抽象：</p><ul><li>一个独立的逻辑控制流 ， 它提供一个假象 ， 好像我们的程序独占地使用处理器。</li><li>一个私有的地址空间， 它提供一个假象 ， 好像我们的 程序独占地使用内 存系统。让我们更 深入地看看这些 抽象。</li></ul></li></ol><p>8. 2. 1 逻辑控制流</p><p>即使在系统中通常有许 多其他程序在运行 ， 进程也 可以向每个 程序提供一种假象，好像它在独占地使用处理器。如果想用调试器单步执行程序 ， 我们会看到一系列的程序计数器(PC) 的值， 这些值唯一地对应于包含 进程A 进程B 进程C</p><p><img src=img/3a502ea4768e0484f3ea0547dd74c5cf.jpeg alt>在程 序的 可执行目标文件中的指令， 或是包含在运行时动态链接到程序的共享</p><p>对象中的指令。这个 PC 值的序列叫做逻</p><p>时间</p><p>辑控 制流，或者 简称逻辑流。</p><p>考虑一个运行着 三个 进 程的 系统， 如图 8-12 所示。处理器的一个物理控制</p><p>流被分成了三个逻辑流， 每个 进程一个。 图 8-12 逻辑控制流。进程为每个程序提供了一种假象，</p><p>每个竖直的条表示一个进程的逻辑流的</p><p>一部分。在这个例子中， 二个逻辑流的</p><p>好像程序在独占地使用处理器 。每个竖直的条表示一个进程的逻辑控制流的一部分 j</p><p>执行是交错的 。进程 A 运行 了一会儿， 然后是进程 B 开始运行到完成。然后， 进程 C 运行了一会儿 ， 进程 A 接着运行 直到完成。最后， 进程 C 可以运行到结束了。</p><p>图 8-1 2 的关键点在于进程是轮流使 用处理器的。每个 进程执 行它的流的一部分， 然后被抢占 ( preem pted )(暂时挂起）， 然后 轮到其他进程。对千一个运行在这些进程之一的上下文中的程序， 它看上去就像是在独占地使用处 理器。唯一的反面例证是 ， 如果我们 精确地测扯 每条指令使用的时间， 会发现在程序中一些指令的执行之间， CPU 好像会周期性地停顿 。然而 ， 每次处 理器停顿 ， 它随后会继续执行我们的程序 ， 并不改变程序内存位置或寄存器的内 容。</p><p>8. 2. 2 并发流</p><p>计算机系统中逻辑 流有许 多不同的形式。异常处理程序、进程、信号处理程序、线程和 Java 进程都是逻辑 流的例子。</p><p>一个逻辑流的执行在时间上与另一个流重叠， 称为并发 流 ( co nc urr e n t flow), 这两个流被称为并发 地运行 。更准确地说 ，流 X 和 Y 互相并发， 当且仅当 X 在 Y 开始之后和 Y 结束之前开始，或者 Y 在 X 开始之后和 X 结束 之前开始。例如，图 8-1 2 中，进 程 A 和 B 并发地运行 ， A 和 C 也一样。另一方面， B 和 C 没有并发地运行 ， 因为 B 的最后一条指令在 C 的第一条指令之前执行。</p><p>多个流并发地执行的一般现象被称为并发 ( co ncu rr e ncy ) 。一个进程和其 他进程轮流运行的概念称为 多任务( m ult itas king ) 。一个进程执行它的控制流的 一部分的每一时间段叫做时间 片 ( t im e s lice ) 。因此，多 任务也叫 做时间分 片 ( t im e s licing ) 。例如， 图 8-1 2 中， 进程 A 的流由两个时间片组成。</p><p>注意， 并发流的思想与流运行的 处理器核数或者计算机数无关。如果两个 流在时间 上重叠 ， 那么它们就是并 发的， 即使它们是运行在同一个处理器上。不 过， 有时我们会发现确认并行 流是很有帮助的，它 是并发流的一个真子集。如果两个流并发地运行 在不同的处理器核或 者计算机上， 那么我们称它们为并行 流( pa ra ll el fl o w ) , 它们并行 地运行 ( ru n ning in para llel) , 且并行地执行( para llel exec ut ion ) 。</p><p>让 练习题 8. 1 考虑 三个具有下述起 始和结束 时间的 进程：</p><p>起始时间</p><p>I 3</p><p>结束时间</p><p>2</p><p>4</p><p>5</p><p>对于每 对进 程，指 出它 们是 否是 并发地运行 ：</p><p>8. 2. 3 私有地址空间</p><p>进程也为每个 程序提 供一种假象 ， 好像它独占地使用 系统地址空间。在一台 n 位地址的机器上 ，地 址空间是 2" 个可能地址的集合， o, 1, … , 2" - 1。进程为每个程序提供它自己的私有地 址空间 。一 般而言， 和这个空间中某个地址相关 联的那个内存字节是不能被</p><p>其他进程读或者写的， 从这个意义上说， 这个地址空间 是私有的。</p><p>尽管和每个私有 地址空间 相关联的内存的内容一般是不同的， 但是每个这样的空间都有相同的通用结 构。比如，图 8-1 3 展示了一个 x8 6- 64 L in u x 进程的地址空间 的组织结构。</p><p>地址空间底部是保留给用户程序的， 包括通常的 代码、数据、堆和栈段。代码段总是从地址 Ox 400000 开始。地址空间顶部保留给内 核（操作系统 常驻内存的部分）。地址空间的这个部分包含内核在代表进程执行指令时（比如当应用程序执行系统调用时）使用的代 码、数据和栈。</p><p>248-1&mdash;+</p><p>内核虚拟内存</p><p>（代码、数据、堆、栈）</p><p>用户栈</p><p>（运行时创建的）</p><p>-&mldr;</p><p>i 用户代码不可见的内存</p><p>七 %e sp (栈指针）</p><p>,. ,,</p><p>之- ,. ·.&rsquo;·</p><p>) -气</p><p>共享库的内存映射区域</p><p>.•• ., 丸 ＿. 才. ｀- &ndash; . ; 千 、、,•.、:-.</p><p>； i "</p><p>运行时堆</p><p>（用ma l l oc 创建的）</p><p>读／写段</p><p>( . da t a、.bss)</p><p>只读代码段</p><p>．七 br k</p><p>Ox 0 0 4 00 0 0 0 &ndash;+</p><p>( . i ni 七、. t ex t 、.rodata)</p><p>,, . i°; i 飞 宁</p><p>图 8-13 进程地址空间</p><p>8. 2. 4 用户模式和内核模式</p><p>为了使 操作系统内核提供一个无懈可击的 进程抽象 ， 处理器必须提供一种机制， 限制一个应用可以 执行的指令以及它可以访问的地址空间范围。</p><p>处理器通常 是用某个控制寄存器中的一个模式位( m o de b it ) 来提供这种功能的， 该寄</p><p>存器描述了进程当前享有的特权。当设置了 模式位时 ， 进程就运行在内核 模式中（有时叫做超级 用户 模式）。一个运行 在内核模式 的进程可以执行指令集中的任何指令， 并且可以访问系统中的任何内存位置。</p><p>没有设置模式位时 ， 进程就运行 在用户 模式中。用户模式中的 进程不允 许执行特权指令( pr ivileged ins t ru ct ion ) , 比如停止处理器、改变模式位，或 者发起一个 1/ 0 操作。也不允许用户模式中的进程直接引用 地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之， 用 户程序必须通过系统凋用接口间 接地访问内核代码和数据 。</p><p>运行 应用程序代码的 进程初始时 是在用户模式中 的。进程从 用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递 到异常处理程序， 处理器将模式 从用户模式变为内 核模式。处理程序运行在内核模式中， 当它返回到应用程序代码时，处理器就把模式从内核摸式改回到用户模式。</p><p>Lin ux 提供了一种聪明的机制 ， 叫做/ pr o c 文件系统 ， 它允许用户模式进程访问内核数</p><p>据结构的内 容。/ pr oc 文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。比如，你 可以使用/ pr oc 文件系统找出一般的系统属性，比 如 CPU 类型(/proc/ cpuinfo), 或者某个特殊的进程使用的内存段( / pr oc / &lt;p ro c e s s - i d > / ma ps ) 。2. 6 版本的 Linux 内核引入/ s ys 文件系统，它输 出 关 千系统总线和设备的额外的低层信息。</p><p>8. 2. 5 上下文切换</p><p>操作系统内核使用一种称为上下文切换 ( context switch ) 的较高层形式的异常控制流来实现多任务 。上下文切换机制是建立在 8. 1 节中已经讨论过的那些较低层异常机制之上的。</p><p>内核为每个进程维持一个上下文( conte xt ) 。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程 序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页 表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。</p><p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了</p><p>的进程。这种决策就叫做调度( sched uling ) , 是由内核中称为调度器 ( sched ule r ) 的 代码处理的。当内核选择一个新的进程运行时 ， 我们说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到 新的进 程， 上下文切换 1 ) 保存当前进程的上下文， 2 ) 恢复某个先前被抢占的进程被保存的上下文， 3 ) 将控制传递给这个新恢复的进程。</p><p>当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某 个事件 发生而阻塞，那 么 内 核 可以让当前进程休眠，切 换 到另一个进程。比如， 如 果 一 个 r e a d 系统调用需要访问磁盘，内 核 可以选择执行上下文切换， 运行另外一个进程， 而 不是等待数 据从磁盘到达。另一个示例是 s l e e p 系统调用， 它 显 式 地请求让调用进程休眠。一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回 给涸用进程。</p><p>中 断也可能引发上下文切换。比如，所 有的系统都有某 种产生周期性定时器中断的机制，通 常为每 1 毫秒或每 10 毫秒。每次发生定时器中断时，内 核 就 能 判定当前进程已经运行了 足够长的时间，并 切 换 到 一 个 新 的 进 程。</p><p>图 8-14 展示了一对进程 A 和 B 之间上下文切换的示例。在这个例子中， 进程 A 初始运行 在用户模式中，直 到它通过执行系统调用 r e a d 陷入到内核。内核中的陷阱处理程序请求来 自磁盘控制器的 OMA 传输，并 且安排在磁盘控制器完成从磁盘到内存的数据传输后，磁盘中断处理器。</p><p>时间 进程A 进程B</p><p>read········► + 用户模式</p><p>芒 内核模式 ｝上下文切换</p><p>磁盘中断 &mldr;&mldr;.. — { 用户模式</p><p>从r ead 返回 &mldr;..►.</p><p>内核模式 ｝上下文切换</p><p>用户模式图 8-14 进程上下文切换的剖析</p><p>磁盘取数据要用一段相对较长的时间（数量级为几 十毫秒），所以内核执行从 进程 A 到进程 B 的上下文切换， 而不是在这个间 歇时间内等待， 什么都不做。注意在切换之前， 内核正代表进程 A 在用户模式下执行指令（即没有单独的 内核进程）。在切换的第一部分中， 内 核代表进程 A 在内核模式下执行指令。然后在某一时刻， 它开始代表进程 B ( 仍然是内核模式下）执行指令。在切换之后，内 核代表进程 B 在用户模式下执行指令。</p><p>随后，进程 B 在用户模式下运行一 会儿， 直到磁盘发出一个 中断信号， 表示数据已经从磁盘传送到了内存。内核判定进程 B 已经运行了足够长的时间， 就执行一个从 进程 B 到进程 A 的上下文切换 ， 将控制返回给进程 A 中紧随 在系统调用 r e a d 之后的那条指令。进程 A 继续运行， 直到下一 次异常发生 ，依 此类推。</p><p>8. 3 系统调用错误处理</p><p>当 U nix 系统级函数遇到错 误时， 它们通常会返回一1, 并设置全局整数变量 e r r no 来表示什么出错了。程序员应该总是检查错误，但是不幸的是，许多人都忽略了错误检 查， 因为它使 代码变得膀 肿， 而且难以读懂。比如，下 面是我们调用 U n ix f or k 函数时会如何检查错误：</p><p>if ((pid = fork()) &lt; 0) {</p><p>fprintf(stderr, &ldquo;fork error: %s\n&rdquo;, strerror(errno)); exit(O);</p><p>｝</p><p>s t re rr or 函数返回一 个文本串 ， 描述了和某个 err n o 值相关联的错误。通过定义下面的错误报告函数，我们能够在某种程度上简化这个代码：</p><p>void unix_error(char *msg) I* Unix-style error *I</p><p>｛</p><p>fprintf(stderr, &ldquo;%s: %s\n&rdquo;, msg, strerror(errno)); exit(O);</p><p>｝</p><p>给定这个函数， 我们对 f or k 的调用从 4 行缩减到 2 行：</p><p>if ((pid = fork()) &lt; 0) unix_error(&ldquo;fork error&rdquo;);</p><p>通过使用 错误处理 包装函数， 我们可以更 进一步地简化代码， S t eve n s 在[ ll O] 中首先提出了 这种方法。对于一个给定的基本函数 f o o , 我们定义一个具有相同参数的包装函数</p><p>Foo, 但是第一个字母大写了。包装函数调用基本函数， 检查错误， 如果有任何问题就终止。比如，下 面是 f o r k 函数的错误处 理包装函数 ：</p><p>pid_t Fork(void)</p><p>｛</p><p>pid_t pid;</p><p>if ((pid = fork()) &lt; 0) unix_error(&ldquo;Fork error&rdquo;);</p><p>return pid;</p><p>给定这个包装函数， 我们对 f o r k 的调用就缩减为 1 行：</p><p>pid = Fork() ;</p><p>我们将在本书剩余的部分中都使用错误处理包装函数。它们能够保持代码示例简洁，而 又不会给你错误的假象，认为允许忽略错误检查。注意，当在本书中谈到系统级函数时，我 们总是用它们的小写字母的基本名字来引用它们 ， 而不是用它们大写的包装函数名来引用。</p><p>关千 U nix 错误处理以及本书中使用的错误处理包装函数的讨论， 请参见附录 A 。包装函数定 义在一个 叫做 c s a pp . c 的文件中， 它们的原型定义在一个叫做 c s a p p . h 的头文件中； 可以从 CS : APP 网站上在线地得到这些代码。</p><p>8. 4 进程控制</p><p>Unix 提供了大量从 C 程序中操作进程的系统 调用。这一节将描述这些重要的函数， 并举例说明如何使用它们。</p><p>8. 4. 1 获 取进程 ID</p><p>每个进程都有一个唯一的正数（非零）进程 ID( PID) 。ge t pi d 函数返回调用进程的 PIO。</p><p>ge七pp i d 函数返回它的父进程的PIO( 创建调用进程的进程）。</p><p>#include &lt;sys/types.h></p><p>#include &lt;unistd.h></p><p>pid_t getpid(void); pid_t getppid(void);</p><p>返回： 调 用者或 其 父进程的 PID,</p><p>g e t p i d 和 g e t p p i d 函数返回一个类型为 p i d t 的整数值， 在 Lin ux 系统上它在</p><p>t ype s . h 中被定义为 i n 七。</p><ol><li><p>4·. 2 创建和终止进程</p><p>从程序员的角度 ， 我们可以认为进程总是处于下面三种状态之一：</p><ul><li>运行。进程要么在 CP U 上执行， 要么在等待 被执行且最终会被内核调度。</li><li>停止。进程的执行被挂起 ( s us pended ) , 且不会被调度。当收到 SIGS T O P 、S IG T ­ S T P、SIG T T I N 或者 SIG T T O U 信号时， 进程就停止， 并且保持停止直到它收到一个 S IGCO NT 信号， 在这个时刻，进 程再次开始运行。（信号是一种软件中断的形式， 将在 8. 5 节中详细描述。）</li><li>终止。进 程永远地停止了。进程会因为三种原 因终止： 1) 收到一个信号，该 信 号的默认行为是终 止进程， 2 ) 从 主程序返 回， 3 ) 调用 e x i t 函数。</li></ul></li></ol><p>#include &lt;stdlib.h></p><p>void exit(int status);</p><p>该函数不返回 。</p><p>e x i t 函数以 s t a t u s 退出状 态来 终止进程（另一种设置退出状态的方法是从主程序中返回一个整数值）。</p><p>父进程通过调用 f or k 函数创建一个新的运行的子 进程。</p><p>#include &lt;sys/types.h></p><p>#include &lt;unistd.h></p><p>pid_t fork(void);</p><p>返回： 子 进 程 返 回 o, 父进程返 回 子进 程的 PID, 如果出错 ，则 为一 l 。</p><p>新创 建的子 进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父 进程任何打开文件描述符相 同的副本， 这就意味着当父进程调用 for k 时，子 进 程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。</p><p>f or k 函数是有趣的（也常常令人迷惑），因 为它只被调用一次， 却 会返回两 次： 一次是在调用进程（父进程）中，一 次 是 在新创建的子进程中。在父进程中， f o r k 返回子进程的 PID 。在子进程中， f o r k 返回 0。因为子进程的 PID 总是为非零， 返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p><p>图 8-15 展示了一个使用 f o r k 创建子进程的父进程的示例。当 f or k 调用在第 6 行返回 时 ，在 父 进 程和子进程中 x 的值都为 1。子进程在第 8 行加一并输出它的 x 的副本。相似地 ，父 进 程 在第 13 行减一并输出它的 x 的副本。</p><p>1 int main()</p><p>2 {</p><p>3 pid_t pid;</p><p>4 int X = 1·，</p><p>5</p><p>6 pid = Fork();</p><ol><li><p>if (pid == 0) { I* Child *I</p></li><li><p>printf (&ldquo;child : x=加 \ n " , ++x);</p><p>9 exit(O);</p><p>10 }</p><p>11</p><p>12 I* Parent *I</p><p>13 printf (&ldquo;parent: x=加 \ n " , &ndash;x);</p><p>14 exit (0);</p><p>15 }</p><p>code/ecf/fork.c</p></li></ol><p>code/ecf/fork.c</p><p>图 8-15 使用 fo r k 创建一个新进程</p><p>当在 U nix 系统上运行这个程序时， 我们得到下面的结果：</p><p>linux> . / f ork parent: x=O chil d : x=2</p><p>这个简单的例子有一些微妙的方面。</p><ul><li>调用一次，返 回 两次。 f o r k 函数被父进程调用一次， 但 是 却 返 回 两 次 一 一次是返回到父进程，一 次 是 返回到新创建的子进程。对于只创建一个子进程的程序来说 ， 这还是相当简单直接的。但是具有多个 f or k 实例的程序可能就会令人迷惑， 需要仔细地推敲了。<ul><li>并发执行。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行 它 们 的 逻辑控制流中的指令。在我们的系统上运行这个程序时，父 进程先完成它的pr i n t f 语 句 ，然 后 是 子 进程。然而， 在另一个系统上可能正好相反。一般而言，</li></ul></li></ul><p>作为程序员，我们决不能对不同进程中指令的交替执行做任何假设。</p><ul><li>相同但是独立的 地址空间。 如果能够在 f or k 函数在父进程和子进程 中返回后立即暂停这两个进程，我们会看到两个进程的地址空间都是相同的。每个进程有相同的 用户栈、相同的本地变量值 、相同的堆、相同的全局变量值， 以及相同的代码。因此， 在我们 的示例程序 中， 当 f or k 函数在第 6 行返回时 ， 本地变量 x 在父进程和子进程中都 为 1。然而 ， 因为父进程和子进程是独立的进程，它 们都有自己 的私有地址空间。后面， 父进程和子进程对 x 所做的任何改变都是 独立的 ， 不会反映在另一个进程的内 存中。这就是为什么当父进程 和子进程调用它们各自的 p r i n t f 语句时， 它们中的变量 x 会有不同的值。<ul><li><p>共享文件。 当运行这个示例程序时， 我们注意 到父进 程和子进程都 把它们的输出显示在屏幕上。原因是子进程继 承了父进程所有的 打开文件。当父进程调用 f or k 时， s t d o 江 文件是打开的， 并指向屏幕。子进程继承了这个文件， 因此它的输出也是指向屏幕的。</p><p>如果你是第一次学习 for k 函数， 画进程图通常会有所帮助，进程图 是刻画程序语 句的 偏序的一种简单的前趋图。每个顶点a 对应于一条程序语句的执行。有向边 a - b 表示语 句 a 发生在语句 b 之前。边上可以标记出一些信息， 例如一个变量的当前值。对应于 pr i nt f 语句的顶点可以 标记上 pr i n t f 的输出。每张图从一个顶点开始，对应千调用 mai n 的父进程。这个顶 点没有入边，并且只有一个出边 。每个进程的顶点序列结束于一 个对应于 e x i t 调用</p></li></ul></li></ul><p>的顶点。这个顶点只有一条入边，没有出边。例如， 图 8-16 展示了图 8-15 中示例程序</p><p>的进程图 。初始时， 父进程将变量 x 设置为</p><p>X==l</p><p>ch i l d: x=2 printf</p><p>pra ent : x=O</p><p>exit</p><p>子进程</p><p>l 。父进程调用 f or k , 创建一个子进程，它在自己的私有地址空间中与父进程并发执行。对千运行在单处理器上的程序，对应进</p><p>main f or k printf exi七</p><p>图 8-16 图 8-15 中示 例程序 的进程图</p><p>父进程</p><p>程图中所 有顶点的 拓扑排序( to po log ica l so r t ) 表示程序中语句的一个可行的全序排 列。下面是一个理解拓扑排序概念的简单方法：给定进程图中顶点的一个排列，把顶点序列从左 到右写成 一行，然后 画出每条有向边。排列 是一个拓扑排序， 当且仅当画出的每条边的方向都是从 左往右的。因此， 在图 8-15 的示例程序中 ， 父进程和子进程 的 pr i n t f 语句可以以任意先 后顺序执行， 因为每种顺 序都对应千图顶点的某种拓扑 排序。</p><p>进程图特别有 助千理解带 有嵌套 f or k 调用的程序。例如，图 8-17 中的程序源码中两次调用了 f or k。对应 的进程图可帮 助我们 看清这个程序运行 了四个进程， 每个 都调用了一次 pr i n t f , 这些 pr i n t f 可以以 任意顺序执行。</p><p>int main()</p><p>｛</p><p>Fork();</p><p>Fork(); printf(&ldquo;hello\n&rdquo;); exit(O);</p><p>hel l o pr i nt f he ll o</p><p>f or k printf</p><p><img src=img/2e986459ab4a85f47036b1297744b0ae.jpeg alt>hell o</p><p>e x i t exi 七</p><p>图 8 - 17</p><p>main f or k</p><p>嵌套 f or k 的进程图</p><p>f or k pr i nt f exit</p><p>i 练习题 8. 2 考虑下面的程序：</p><p>int main()</p><p>｛</p><p>code/ecflforkprobO.c</p><p>int X = 1;</p><p>if (Fork() == 0)</p><p>printf(&ldquo;p1: x=%d\n&rdquo;, ++x); printf(&ldquo;p2: x=%d\n&rdquo;, &ndash;x); exit(O);</p><p>codelecflforkprobO.c</p><ol><li>子进程的输出是什么？</li><li>父进程的输出是什么？</li></ol><p>8. 4. 3 回收子进程</p><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中， 直到被它的 父进程回收( r ea ped ) 。当父进程回收己终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃己终止的进程，从此时开始， 该进程就不 存在了。一 个终止了但还未被回收的 进程称为僵 死进 程( zo m bie ) 。</p><p>日 日 为什么已终止的子进程被 称为僵死进程？</p><p>在民 间传说 中，僵 尸是 活着的 尸体 ， 一种半 生半 死的 实体。僵死进程已经终止了， 而内核仍保留着它的某些状态直到父进程回收它为止，从这个意义上说它们是类似的。</p><p>如果一个父进程终 止了，内 核会安排 i n i t 进程成 为它的 孤儿进程的养父。 i n i t 进程的 P ID 为 1, 是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死子进程就终 止了， 那么内核会安排 i n i t 进程去回收它们。不过，长时间运行 的程序，比如 shell 或者服务器，总 是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然消耗系统的内存资源。</p><p>一个进程可以 通过调用 wa i t p i d 函数来等待它的 子进程终止或者停止。</p><p>#include &lt;sys/types.h></p><p>#include &lt;s ys / wa i t . h ></p><p>pid_t waitpid(pid_t pid, int *statusp, int options);</p><p>返回： 如 果 成 功 ， 则为 子 进 程 的 PIO, 如 果 WNO HAN G , 则 为 o, 如 果其他错误 ， 则为— 1.</p><p>wa i t p 过 函数有点复杂。默认情况下（当o p巨 o ns = O 时）， wa i t p i d 挂起调用进程的执行， 直到它的等待 集合 ( w ait set ) 中的一个子进程终止。如果等待集合 中的一个进程在刚调用的时刻就已经终止了， 那么 wa i t p i d 就立即返回。在这两种情况中， wa i t p i d 返回导致 w ait pid 返回的已终止子进程的 P IO 。此 时， 已终止的子进程巳经被回收， 内核会从系统中删除掉它的所有痕迹。</p><p>1 判定等待集合的 成员</p><p>等待集合的成员是由参数 p 过 来确定的：</p><ul><li><p>如果 p 过 >O, 那么等待集合就是一个单独的子进程 ，它的 进程 ID 等千 p i d。</p></li><li><p>如果 pi d= - 1 , 那么等待集合就是由父进程所有的子进程组成的。</p><p>wa i t p 迈 函数还支持其他类型的等待集合， 包括 Unix 进程组， 对此我们将不做讨论。</p></li></ul><ol><li><p>修改默认行 为</p><p>可以通过将 op t i on s 设置为常晕 WNO H ANG 、 WU NT RACED 和 WCO NT INUED</p><p>的各种组合来修改默认行为：</p></li></ol><ul><li><p>WNOHANG: 如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为 0 ) 。默认的行 为是挂起调用进程， 直到有子进程终 止。在等待子进程终 止的同时，如果还想做些有用的工作，这个选项会有用。</p></li><li><p>WUNTRACED: 挂起调用进程的执行， 直到等待集合中的一个进程变成巳终止或者被停止。返回的 PID 为导致返回的已终止或被停止 子进程的 PID。默认的行为是只返回己终止的子进程。当你想要检查己终止和被停止的子进程时，这 个选项会有用。</p></li><li><p>WCONT I NU ED: 挂起调用进程的 执行， 直到等待集合中一个正在运行的进程终止或等待集合中一个 被停止的进程收 到 S IGCO NT 信号重新开始执行。( 8. 5 节会解释这些信号。）</p><p>可以用或运算把这些选项组合起来。例如：</p></li><li><p>WNOHANG I WUNTRACED: 立即返回，如果等待集合中的子进程都没有被停止或终止， 则返回值为 O; 如果有一个停止或终 止， 则返回值为该子进程的 PID。</p></li></ul><ol start=2><li><p>检查己回 收子进程的 退出状态</p><p>如果 s 七a t us p 参数是非空的， 那么 wa i t p i d 就会在 s 七a t us 中放上关于导致返回的子进程 的状态信息， s 七a t us 是 s t a t us p 指向的值。wa i t . h 头文件定义了解释 s 七a 七us 参数的几个宏：</p></li></ol><ul><li><p>WIFEXITED(s t a 七us ) : 如果子进程通过调用 e xi t 或者一个返回( ret urn ) 正常终止， 就返回真。</p></li><li><p>WEXITSTATUS ( s t a 七us ) : 返回一 个正常终止的 子进程的退出状态。只有 在</p><p>WIFEXIT ED( ) 返回为真时 ， 才会定义这个状态。</p></li><li><p>WIFSIGNALED(status): 如果子进程是因为一个未被捕获的信号终止的， 那么就返回真。</p></li><li><p>WTERMSIG(status): 返回导致子进程终止的信号的编号。只有在 WIFSIG­ NALE D( ) 返回为真时 ， 才定义这个状态。</p></li><li><p>WIF ST OPP ED(s t a 七us ) : 如果引起返回的子进程当前是 停止的， 那么就返回真。</p></li><li><p>WSTOPSIG(status): 返回引起子进程停止的信号的编号。只有在 WIFSTOPP D ( )</p><p>返回为真时，才定义这个状态。</p></li><li><p>WIFCONTINUED( s t a 七us ) : 如果子进程收到 SIGCONT 信号重新启动， 则返回真。</p></li></ul><ol start=3><li><p>错误条件</p><p>如果调用进程没有子进程， 那么 wa i t p i d 返回—1, 并且设置 err no 为 EC H ILD 。如果 wa i t p 卫 函数被一个信号中断， 那么它返回- 1 , 并设置 err no 为 EINT R。</p><p>m 和 Unix 函数相关的 常量</p><p>像 WNOHANG 和 WUNT RACED 这样的常量 是由 系统头文件定义的。例如， WNO­ HANG 和 WU NT RACE D 是由 wa i t . h 头文件（间接）定义的 ：</p></li></ol><p>I* Bits</p><p>#define</p><p>#define</p><p>in the third WNOHANG 1</p><p>WUNTRACED 2</p><p>argument to&rsquo;waitpid&rsquo;. */ I* Don&rsquo;t block waiting. *I</p><p>I* Report status of stopped children. *I</p><p>为了使用这些常量， 必须在代码中 包含 wa i t . h 头文件：</p><p>#include &lt;sys/wait.h></p><p>每个 U nix 函数的 ma n 页列 出 了 无论何 时你在代码中使 用 那个函数都要 包含 的头文件。同时， 为 了检 查诸如 ECH ILD 和 EINT R 之 类的 返回代码， 你必须 包含 er r n o . h 。 为了简化代码示例 ， 我们 包含 了 一个称 为 c s a p p . h 的 头 文件， 它 包括 了 本 书 中使 用的 所有函数的头文件。c s a pp . h 头文件可以从 CS: APP 网站在线荻得。</p><p>沁凶 练习题 8. 3 列出下面程序所有可能的输出序列：</p><p>int main()</p><p>｛</p><p>code/ecf/waitprobO.c</p><p>if (Fork() == 0) ｛</p><p>printf(&ldquo;a&rdquo;);</p><p>｝</p><p>fflush(stdout);</p><p>else {</p><p>printf(&ldquo;b&rdquo;); fflush(stdout); waitpid(-1, NULL, O);</p><p>｝</p><p>printf(&ldquo;c&rdquo;); fflush(stdout); exit(O);</p><p>5 . wa i t 函数</p><p>wa i t 函数 是 wa i t p i d 函 数 的 简单版本：</p><p>code/ecflwaitprob0.c</p><p>#include &lt;sys/types.h></p><p>#include &lt;s ys 压 a i t . h> pid_t wait(int *statusp);</p><p>返回： 如 果 成 功， 则 为 子进程的 PID, 如 果 出错 ， 则为 一1。</p><p>调 用 wa i t ( &amp;s 七a t u s ) 等价千调用 wa i t p i d (- l , &amp;s t a t u s , O ) 。</p><p>6 使用 wa 江 p i d 的示例</p><p>因为 wa i t p i d 函 数有些复杂，看 几 个 例 子会有所帮助。图 8-18 展示了一个程序， 它使 用 wa i 七p 过 ，不 按 照 特定的顺序等待它的所有 N 个子进程终止。在第 11 行， 父进程创建 N 个子进程，在 第 12 行 ， 每个子进程以一个唯一的退出状态退出。在我们继续讲解之前 ，请 确 认 你 已经理解为什么每个子进程会执行第 12 行 ， 而父进程不会。</p><p>在第 15 行， 父进程用 wa i t p i d 作 为 wh i l e 循 环 的 测 试 条 件，等 待它所有的子进程终止 。 因 为第一个参数是 — 1, 所以对 wa i t p i d 的 调 用 会 阻 塞 ， 直 到 任意一个子进程终止。在每个子进程终止时， 对 wa i 七p i d 的 调 用 会 返回， 返回值为该子进程的非零的 PID。第1 6 行检查子进程的退出状态。如果子进程是正常终止的一 在此是以调用 e x i t 函数终止 的 那 么 父进程就提取出退出状态，把 它 输 出 到 s t d o u t 上。</p><p>code/ecflwaitpidl.c</p><ol start=4><li><p>printf(&ldquo;child %d terminated normally with exit status=%d\n&rdquo;,</p></li><li><p>pid, WEXITSTATUS(status));</p></li><li><p>else</p></li><li><p>printf (&ldquo;child %d terminated abnormally\n&rdquo;, pid);</p><p>21 }</p><p>22</p></li><li><p>I* The only normal termination is if there are no more children *I</p></li><li><p>if (errno != ECHILD)</p></li><li><p>unix_error(&ldquo;waitpid error&rdquo;);</p><p>26</p><p>27 exit(O);</p><p>28 }</p></li></ol><p>code/ecf/waitpidl.c</p><p>图 8-18 使用 wa i t pi d 函数不按照特定的顺 序回收僵死 子进程</p><p>当回收了所有的子 进 程之后， 再 调用 wa i t p i d 就返回 — 1, 并且设 置 err n o 为</p><p>£ C H IL D。第 24 行检查 wa i 七p i d 函数是正常终止的， 否则就输出一个错误 消息。在我们的 L in ux 系统上 运行 这个程序时 ，它 产生如下输出：</p><p>linux> ./ 甘 ai t p i d1</p><p>child 22966 terminated normally with exit status=lOO child 22967 terminated normally with exit status=101</p><p>注意，程序不会按照特定的顺序回收子进程。子进程回收的顺序是这台特定的计算机系统的属性。在另一个系统上，甚至在同一个系统上再执行一次，两个子进程都可能以相反的顺序被回收。这是非确定性行为的一个示例，这种非确定性行为使得对并发进行推理非常困难。两种 可能的结果都同样是正确的， 作为一个 程序员， 你绝不可以 假设总是会出现某一个结果，无论多么不可能出现另一个结果。唯一正确的假设是每一个可能的结果都同样可能出现。</p><p>图 8-19 展示了一个简单的改变，它消除了这种不确定性 ， 按照父进程创建子进程的相同顺序来回收这些子进程。在第 11 行中，父进程按照顺 序存储了它的子进程的 PIO, 然后通过用适当的 PIO 作为第一个参数来调用 wa i t p i d , 按照同样的顺序来等待每个子进程。</p><p>code/ecflwaitpid2.c</p><ol><li><p>I* Parent reaps N children in order *I</p></li><li><p>i = O;</p></li><li><p>while ((retpid = waitpid(pid[i++], &amp;status, 0)) > 0) {</p><p>1 7 if (WIFEXITED(status))</p></li><li><p>printf(&ldquo;child %ct terminated normally with exit status=%d\n&rdquo;,</p></li><li><p>retpid, WEXITSTATUS(status));</p></li><li><p>else</p></li><li><p>printf (11child %d terminated abnormally\n11, retpid) ;</p></li></ol><table><thead><tr><th>22</th><th>}</th><th></th></tr></thead><tbody><tr><td>23</td><td></td><td></td></tr><tr><td>24</td><td>I*</td><td>The only normal termination is if there are no more children *I</td></tr><tr><td>25</td><td>if</td><td>(errno != ECHILD)</td></tr></tbody></table><p>26 unix_error(11waitpid error&rdquo;);</p><p>27</p><p>28 exit(O);</p><p>29 }</p><p>code/ecf/waitpid2.c</p><p>图 8-19 使用 wa i t pi d 按照创建子进程的顺序来回收这些 僵死子进程</p><p>亡 练习题 8. 4 考虑下面的程序：</p><p>code/ecflwaitprobl.c</p><p>code/ecflwaitprob1.,</p><ol><li>这个程序会产生多少输出行？</li><li>这些输 出行的一种 可能的 顺 序是 什么？</li></ol><p>8. 4. 4 让进程休眠</p><p>s l e ep 函数将一个进程挂起一段指定的时间。</p><p>#include &lt;unistd.h></p><p>unsigned int sleep(unsigned int secs);</p><p>返回： 还 要 休 眠 的 秒 数 。</p><p>如果请求的时间量已经到了， s l e e p 返回 o, 否则返回还剩下的要休眠的秒数。后一种情况 是可能的，如果 因 为 s l e e p 函数被一个信号中断而过早地返回。我们将在 8. 5 节中详细讨论信号。</p><p>我们会发现另一个很有用的函数是 p a u s e 函数，该 函 数让 调 用 函数 休 眠 ，直 到 该 进 程收到一 个信号。</p><p>#include &lt;unistd.h></p><p>int pause(void);</p><p>总是返回一1。</p><p>让目 练习题 8. 5 编写 一个 s l e e p 的包 装函数，叫做 s n o o z e , 带有下面的接口：</p><p>unsigned int snooze(unsigned int secs);</p><p>snooze 函数和 s l e e p 函数的行 为 完全 一样 ， 除 了它 会打印 出 一条 消息来描述进程 实际休眠了多长时间：</p><p>lept for 4 of 5 secs.</p><ol><li><p>4. 5 加载并运行程序</p><p>e xe cve 函数在当前进程的上下文中加载并运行一个新程序。</p></li></ol><p>#include &lt;unistd.h></p><p>int execve(const char *filename, const char *argv[J, const char *envp []) ;</p><p>如果成功，则不返回 ，如果错误，则 返回- 1 .</p><p>e x e c v e 函 数 加 载 并 运行可执行目标文件 f i l e na me , 且 带 参 数 列 表 ar gv 和环境变量列表 e nv p。只有当出现错误时， 例 如 找 不 到 f i l e n a me , e x e c v e 才会返回到调用程序。所以 ， 与 f or k 一次调用返回两次不同， e x e c v e 调 用 一 次并 从 不 返 回 。</p><p>参 数 列 表是 用 图 8-20 中的数据结构表示的。ar g v 变量指向一个以 n ull 结尾的指针数组，其 中 每个指针都指向一个参数字符串。按照惯例， a r g v [ OJ 是 可 执行目标文件的名字。环 境变量的列表是由一个类似的数据结构表示的， 如图 8-21 所示。e nv p 变最指向一个以 n ull 结尾的指针数组， 其 中 每个指针指向一个环境变量字符串， 每个串都是形如&rdquo; na me =v a l u e " 的 名 字—值 对 。</p><p>I argv</p><p>argv[] argv[O]</p><p>I argv [1]</p><p>argv [ar gc - 1]</p><p>1 ·I</p><h2 id=img1620c4a88871dd25f3cb5ce4b5b4d28djpegi><img src=img/1620c4a88871dd25f3cb5ce4b5b4d28d.jpeg alt>i
<a class=anchor href=#img1620c4a88871dd25f3cb5ce4b5b4d28djpegi>#</a></h2><p>&ldquo;ls&rdquo; &ldquo;-lt&rdquo;</p><p>皿 L '</p><p>佟I 8-20 参数列表的组织结构</p><p>I &ldquo;/ user / i ncl ude&rdquo; j</p><p>「一二 ，</p><p>en vp[]</p><p><img src=img/92cee3546a5cbe1b0a0a1fd24f3b3b66.jpeg alt>envp [OJ envp [1)</p><p>j</p><p>envp [n - 1)</p><p>NULL</p><p>图 8- 21 环境变扯列表的组织结构</p><p>在 e x e c v e 加载了 f i l e n a me 之后， 它调用 7. 9 节中描述的启动代码。启动代码设置栈， 并将控制传递给新程 序的主函数， 该主函数 有如下形式的原型</p><p>int main(int argc,</p><p>或者等价的</p><p>int main(int argc,</p><p>char **argv,</p><p>char *argv [] ,</p><p>char **envp);</p><p>char *envp(]);</p><p>当 ma i n 开始执行时，用 户栈的组织结构如图 8- 22 所示。让我们从栈底（高地址）往栈顶</p><p>（低地址 ）依次看一看。首先是 参数和环境字符串。栈往上紧随其后的是以 n u ll 结尾的指针数组 ， 其中每个指针都指向栈中的一个环境变量字符串。全局变量 e n v ir o n 指向这些指针中的第一个 e n v p [ O J 。 紧随环境变量数组之后的是以 n u ll 结尾的 ar g v [ ]数组， 其中每个元素都指向栈 中的一个参数字符串。在栈的顶部是系统启动函数 l i b c _ s t ar t _ ma i n ( 见</p><ol><li><p>9 节）的栈帧。</p><p>栈底</p><p>以null结尾的环境变扯字符串</p></li></ol><p>. 以null结尾的命令行字符串</p><p>envp[n] == NULL</p><p>e nvp [ n - 1 ]</p><p>．．．</p><p>e n vp [ O ] •</p><p>ar gv [ar g c ) = NUL L</p><p>argv[argc-1]</p><p>..</p><p>. ， argv[O]</p><p>environ</p><p>（全局变量）</p><p>argc</p><p>（在寄存器%r d i 中 ）</p><p>·.</p><p>l i b c _ s t ar t _ma i n 的栈帧</p><p>栈顶</p><p>ma i n 的未来的栈帧</p><p>图 8-22 一个新程序开始时，用 户 栈的典型组织结构</p><p>ma i n 函 数有 3 个 参 数 ： l)argc, 它给出 ar g v [ ]数组中非空指针的数量， 2 ) ar g v ,</p><p>指向 ar g v [ ] 数组中的第一个条目， 3 ) e n v p , 指 向 e nv p ( ] 数组中的第一个条目。</p><p>Lin ux 提供了几个函数来操作环境数组：</p><p>#include &lt;stdlib.h></p><p>char *getenv(const char *name);</p><p>返回： 若存在则为指 向 name 的 指 针 ， 若 无匹 配的 ， 则 为 NU LL。</p><p>g e t e nv 函 数 在 环境 数组中搜索字符串 " na me =v a l ue " 。 如果找到了， 它 就 返回一个指向 va l ue 的指针，否 则 它 就 返回 NULL 。</p><p>#include &lt;stdlib.h></p><p>int setenv(const char *name, const char *newvalue, int overwrite);</p><p>返回： 若成功 则 为 0 , 若 错 误 则 为 一1 。</p><p>void unsetenv(const char *name);</p><p>返回： 无。</p><p>如果环境数组包含一个形如 " n a me = o l d v a l u e " 的 字 符 串 ，那 么 u n s e t e nv 会 删除它， 而 s e t e nv 会用 ne wv a l u e 代替 o l d v a l u e , 但是只有在 ov er wir 七e 非 零 时 才会这样。如果 na me 不存在，那 么 s e t e n v 就 把 " n a me =n e wv a l u e " 添加到数组中。</p><p>豆 日 程序与进程</p><p>这是一个适当的地方，停下来，确认一下你理解了程序和进程之间的区别。程序是 一堆代码和数据；程序可以作为目标文件存在于磁盘上，或者作为段存在于地址空间 中。进程是执行中程序的一个具体的实例；程序总是运行在某个进程的上下文中。如果 你想要 理解 f or k 和 e x e c ve 函数， 理解这个差 异是很 重要 的。f or k 函数在新的子进程中运行 相同的 程序， 新的子进程是父进程的一个复制品。e x e c v e 函数在 当 前进程的上下文中加栽并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新 进程。 新的程序仍然有 相同的 PIO, 并且继承了调用 e x e c v e 函数时已打开的 所有文件描述符。</p><p>江 练习题 8. 6 编 写 一 个 叫 做 my e c h o 的 程 序， 打 印 出 它 的 命令行 参 数 和 环境 变 量。</p><p>例如：</p><p>linux> ./myecho arg1 arg2 Command-ine arguments:</p><p>argv[ OJ: myecho argv [ 1] : argl argv[ 2]: arg2</p><p>Environment variables:</p><p>envp[ OJ: PWD=/usrO/droh/ics/code/ecf envp[ 1]: TERM=emacs</p><p>envp[25]: USER=droh</p><p>envp[26]: SHELL=/usr/local/bin/tcsh envp[27]: HOME=/usrO/droh</p><ol><li><p>4. 6 利 用 f or k 和 e x e c v e 运行 程序</p><p>像 U nix s hell 和 We b 服务器这样的程序大量使用了 f or k 和 e xe c ve 函数。s hell 是一个交互型的应用级程序， 它 代表用户运行其他程序。最早的 shell 是 s h 程序，后 面出现了一些 变种，比 如 c s h、t c s h 、ks h 和 b a s h。s hell 执行一系列的读／求值( read / evaluate ) 步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运 行程序。</p><p>图 8- 23 展示了一个简单 shell 的 ma i n 例 程 。 s hell 打印一个命令行提示符， 等待用户</p><p>在 s t d i n 上输入命令行，然 后对这个命令行求值。</p></li></ol><p>#include &ldquo;csapp.h&rdquo;</p><p>2 #define MAXARGS 128</p><p>3</p><p>4 I* Function prototypes *I</p><p>5 void eval(char *cmdline);</p><p>6 int parseline(char *buf, char **argv);</p><p>7 int builtin_command(char **argv);</p><p>8</p><p>9 int main()</p><p>10 {</p><p>11 char cmdline[MAXLINE]; I* Command line *I</p><p>12</p><p>13 while (1) {</p><p>14 I* Read *I</p><ol><li><p>printf("> &ldquo;);</p></li><li><p>Fgets(cmdline, MAXLINE, stdin);</p></li><li><p>if (feof (stdin))</p></li><li><p>exit(O);</p><p>19</p><p>20 I* Evaluate *I</p><p>21 eval (cmdline);</p><p>22 }</p><p>23 }</p><p>code/ecf/shellex. c</p></li></ol><p>code/ecflshellex.c</p><p>图 8-23 一个简单的 shell 程序的 ma i n 例程</p><p>图 8- 24 展示了对命令行求值的代码。它的首要任务是调用 par s e l i ne 函数（见图8-25) , 这个函数解析了以空格分隔的命令行参数，并 构 造最终会传递给 e xe c ve 的 a r gv 向量。第 一个参数被假设为要么是一个内置的 s hell 命令名， 马上就会解释这个命令， 要么是一个可执行目标文件，会在一个新的子进程的上下文中加载并运行这个文件。</p><p>如果最后一个参数是一个 " &.&rdquo; 字符，那 么 p ar s e l i ne 返回 1, 表示应该在后台执行该程序( s h ell 不会等待它完成）。否则，它 返 回 0 , 表示应该在前台执行 这个 程序( shell 会等待它完成）。</p><p>在解析了命令行之后， e v a l 函 数 调 用 b u i l t i n_ c o mma nd 函 数 ，该 函 数 检 查第一个命令 行 参数是 否是一个内置的 s he ll 命令。如果是，它 就 立 即 解 释这个命令，并 返 回值 1。否则 返回 0。简单的 s hell 只有一个内置命令——- qu i t 命令，该 命 令 会 终 止 s hell 。实际使用</p><p>的 s h ell 有大僵的命令，比 如 p wd 、 j o b s 和 f g。</p><p>如果 b ui l t i n_comma nd 返 回 o, 那 么 s hell 创 建 一 个 子 进 程 ，并 在 子 进程中执行所请求的程序。如果 用户要求在后台运行该程序， 那么 s hell 返回到循环的顶部， 等 待下一个命令 行。否则， s hell 使用 wa 江 p 卫 函数 等 待作 业 终 止 。 当作业终止时， s hell 就 开始下一轮迭代。</p><p>code/ecflshellex.c</p><p>9 strcpy(buf, cmdline);</p><p>1o bg = parseline (buf , argv) ;</p><ol><li><p>if (argv [OJ == NULL)</p></li><li><p>return; I* Ignore empty lines *I</p><p>13</p></li><li><p>if (!builtin_command(argv)) {</p></li><li><p>if ((pid = Fork()) == 0) { I* Child runs user job *I</p></li><li><p>if (execve(argv[O], argv, environ)&lt; 0) {</p></li><li><p>7 printf ("%s: Command not found. \n", argv [O]);</p></li><li><p>exit(O);</p><p>19 }</p><p>20 }</p><p>21</p></li><li><p>I* Parent waits for foreground job to terminate *I</p></li><li><p>if (!bg) {</p></li><li><p>int st at us·</p></li><li><p>if (waitpid(pid, &amp;status, 0) &lt; 0)</p></li><li><p>unix_error(&ldquo;waitfg: waitpid err or&rdquo;) ;</p><p>27 }</p></li><li><p>else</p></li><li><p>printf("%d %s", pid, cmdline);</p><p>30 }</p><p>31 return;</p><p>32 }</p><p>33</p></li><li><p>I* If first arg is a builtin command, run it and return true *I</p></li><li><p>int builtin_command(char **argv)</p><p>36 {</p><p>37 if (!strcmp(argv[O], &ldquo;quit&rdquo;)) I* quit command *I</p></li><li><p>exit(O);</p></li><li><p>if (!strcmp(argv[O], &ldquo;&&rdquo;)) I* Ignore singleton & *I</p></li><li><p>return 1;</p><p>return O; I* Not a builtin command *I</p></li></ol><p>cod e/ecfrshellex.c</p><p>图 8-24 eva l 对 shell 命令行求值</p><p>code/ecf/shellex.c I* parseline - Parse the command line andbuild the argv array *I</p><p>2 int parseline(char *buf, char **argv)</p><p>3 {</p><p>char *delim; int argc; int bg;</p><p>I* Points to first space delimiter *I I* Number of args *I</p><p>I* Background job? *I</p><table><thead><tr><th>8</th><th>buf[strlen(buf)-1] =&rsquo;&rsquo;; I Replace trailing&rsquo;\n&rsquo;with space</th><th>*I</th></tr></thead><tbody><tr><td>9</td><td>while (*buf && (*buf ==&rsquo;&rsquo;)) I*Ignore leading spaces *I</td><td></td></tr><tr><td>10</td><td>buf++;</td><td></td></tr><tr><td>11</td><td></td><td></td></tr><tr><td>12</td><td>I* Build the argv list *I</td><td></td></tr><tr><td>13</td><td>argc = O;</td><td></td></tr><tr><td>14</td><td>while ((delim = strchr (buf,&rsquo;&rsquo;))) {</td><td></td></tr><tr><td>15</td><td>argv [argc++] = buf ;</td><td></td></tr><tr><td>16</td><td>*delim = &rsquo; \ O&rsquo; ·</td><td></td></tr><tr><td>1 7</td><td>buf = delim + 1·</td><td></td></tr><tr><td>18</td><td>while (*buf && (*buf ==&rsquo;&rsquo;)) I*Ignore spaces *I</td><td></td></tr><tr><td>19</td><td>buf++·</td><td></td></tr><tr><td>20</td><td>}</td><td></td></tr><tr><td>21</td><td>argv [argc] = NULL;</td><td></td></tr><tr><td>22</td><td></td><td></td></tr><tr><td>23</td><td>if (argc == 0) I* Ignore blank line *I</td><td></td></tr><tr><td>24</td><td>return 1;</td><td></td></tr><tr><td>25</td><td></td><td></td></tr><tr><td>26</td><td>I* Should the job run in the background? *I</td><td></td></tr><tr><td>27</td><td>if ((bg"&rsquo;(*argv[argc-1] &ldquo;&rsquo;&rdquo;&rsquo;&rsquo;&&rsquo;))&rsquo;"&lsquo;0)</td><td></td></tr><tr><td>28</td><td>argv [&ndash;argc] &ldquo;&lsquo;NULL;</td><td></td></tr><tr><td>29</td><td></td><td></td></tr></tbody></table><p>30 return bg;</p><p>31 }</p><p>图 8-25 par s e li ne 解析 shell 的一个输入行</p><p>codelecf/shellex.c</p><p>注意 ， 这个简单的 s h ell 是有缺陷的， 因为它并 不回收它的后台子进程。修改这个缺陷就要求使用信号，我们将在下一节中讲述信号。</p><p>8. 5 信号</p><p>到目前为止对异常控制流的学习中，我们已经看到了硬件和软件是如何合作以提供基 本的低层异常机制的。我们也看到了操作系统如何利用异常来支持进程上下文切换的异常 控制流形式 。在本节中， 我们将研究一种更高层 的软件形式的异常， 称为 L in ux 信号，它允许进程和内核中断其他进程。</p><p>一个信号就是一条小消息，它 通知进程系统中发生了一个某种类型的事件 。比如，图 8-26</p><p>展示了 L in u x 系统上支持的 30 种不同类型的信号。</p><p>每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正 常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。比如，如果一个进程试图除以0, 那么内核就发送给它一个SIGFPE信号（号码8)。如果一个进</p><p>程执行一条非法指令， 那么内核就发送给它一个SIGILL 信号（号码4) 。如果进程进行非法内存引用，内 核就发送给它一个SIGSEGV信号（号码11)。其他信号对应千内核或者其他用户进程中较高层的软件事件。比如， 如果当进程在前台运行时， 你键入 Ctrl+ CC也就是同时按下 Ctrl 键和 C 键）， 那么内核就会发送一个 SIGINT 信号（号码2) 给这个前台进程组中的每个进程。一个进程可以通过向另 一个进程发送一个 SIGKILL 信号（号码9) 强制终止它。当一个子进程终止或者停止时，内核会发送一个SIGCHLD 信号（号码17) 给父进程。</p><table><thead><tr><th>序号</th><th>名称</th><th>默认行为</th><th>相应事件</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>终止</td><td>终端线挂断</td></tr><tr><td>2</td><td>SIGINT</td><td>终止</td><td>来自键盘的中断</td></tr><tr><td>3</td><td>SIGQUIT</td><td>终止</td><td>来自键盘的退出</td></tr><tr><td>4</td><td>SIGILL</td><td>终止</td><td>非法指令</td></tr><tr><td>5</td><td>SIGTRAP</td><td>终止并转储内存(l)</td><td>跟踪陷阱</td></tr><tr><td>6</td><td>SIGABRT</td><td>终止并转储内存(!)</td><td>来自 a b or t 函数的终止信号</td></tr><tr><td>7</td><td>SIGBUS</td><td>终止</td><td>总线错误</td></tr><tr><td>8</td><td>SIGFPE</td><td>终止并转储内存°</td><td>浮点异常</td></tr><tr><td>9</td><td>SIGKILL</td><td>终止©</td><td>杀死程序</td></tr><tr><td>10</td><td>SIGUSRI</td><td>终止</td><td>用户定义的信号1</td></tr><tr><td>11</td><td>SIGSEGV</td><td>终止并转储内存°</td><td>无效的内存引用（段故障）</td></tr><tr><td>12</td><td>SIGUSR2</td><td>终止</td><td>用户定义的信号2</td></tr><tr><td>13</td><td>SIGPIPE</td><td>终止</td><td>向一个没有读用户的管道做写操作</td></tr><tr><td>14</td><td>SIGALRM</td><td>终止</td><td>来自a l a r m 函数的定时器信号</td></tr><tr><td>15</td><td>SIGTERM</td><td>终止</td><td>软件终止信号</td></tr><tr><td>16</td><td>SIGSTKFLT</td><td>终止</td><td>协处理器上的栈故隐</td></tr><tr><td>17</td><td>SIGCHLD</td><td>忽略</td><td>一个子进程停止或者终止</td></tr><tr><td>18</td><td>SIGCONT</td><td>忽略</td><td>继续进程如果该进程停止</td></tr><tr><td>19</td><td>SIGSTOP</td><td>停止直到下一个 SIGCONT＠</td><td>不是来自终端的停止信号</td></tr><tr><td>20</td><td>SIGTSTP</td><td>停止直到下一个SIGCONT</td><td>来自终端的停止信号</td></tr><tr><td>21</td><td>SIGTTIN</td><td>停止直到下一个 SIGCONT</td><td>后台进程从终端读</td></tr><tr><td>22</td><td>SIGTTOU</td><td>停止直到下一个 SIGCONT</td><td>后台进程向终端写</td></tr><tr><td>23</td><td>SIGURG</td><td>忽略</td><td>套接字上的紧急情况</td></tr><tr><td>24</td><td>SIGXCPU</td><td>终止</td><td>CPU 时间限制超出</td></tr><tr><td>25</td><td>SIGXFSZ</td><td>终止</td><td>文件大小限制超出</td></tr><tr><td>26</td><td>SIGVTALRM</td><td>终止</td><td>虚拟定时器期满</td></tr><tr><td>27</td><td>SIGPROF</td><td>终止</td><td>剖析定时器期满</td></tr><tr><td>28</td><td>SIGWINCH</td><td>忽略</td><td>窗口大小变化</td></tr><tr><td>29</td><td>SIGIO</td><td>终止</td><td>在某个描述符上可执行 J/0 操作</td></tr><tr><td>30</td><td>SIGPWR</td><td>终止</td><td>电源故障</td></tr></tbody></table><p>图 8-26 L in ux 信 号</p><p>汪： O 多年前， 主存是用一种称为磁 芯存 储器( core memory) 的技术来实现的。“转储 内存&rdquo; ( dump ing core ) 是 一个历史术语 ，意 思是把代码和数据内存 段的映像写到磁盘上。</p><p>＠）这个信 号既 不能被捕获，也 不能被忽略。</p><p>（来源： man 7 signal。数据来自 Linux Found ation. )</p><ol><li><p>5. 1 信号术语</p><p>传送一个信号到目的进程是由两个不同步骤组成的：</p><ul><li>发送信号。内核 通过更新目的进程上下文中的 某个状态， 发送（递送）一个信号给目的进程。发送信号可以有如下两种原因： 1) 内 核检测到一个系统事件， 比如除零错误或者子进程终止。2) 一个进程调用了 ki ll 函数（在下一节中讨论），显 式地要求内核发送一个信号给目的进程。一个进程 可以发 送信号给它自己 。</li></ul></li></ol><p><img src=img/6fffa764a58258fa35c418c55ef60576.jpeg alt>·接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了 信号。进程可以忽略这个信号，终 止或 者 通过执行一个称为信号处理 程序( sig nal han­ dler ) 的用户层函数捕获这个信号。图 8-27 给出了信号处理程序捕获信号的基本思想。</p><p>( I ) 进程接 I</p><p>curr</p><p>收到信号</p><p>In,.,</p><p>( 3 ) 信号处理程序运行</p><p>图 8- 27 信号处理。接收到信号会触发控制转移到信号处理程序 。在信号处理程序完成处理之 后， 它将控制返回给被中断的程序</p><p>一个发出而没有被接收的信号叫做待处理信号( pe nd ing s ig n al) 。在 任何 时 刻 ， 一种类型至多 只会有一个待处理信号。如果一个进程有一个类型为 K 的 待 处 理 信 号 ，那 么 任何接下 来发送到这个进程的类型为 K 的 信 号 都 不会排队等待；它 们 只 是 被 简单地丢弃。一个进程 可 以 有 选择性地阻塞接收某种信号 。当一种信号被阻塞时， 它 仍 可 以 被发送， 但是产生的待 处 理信号不会被接收， 直到 进程 取 消对这种信号的阻塞。</p><p>一个待处理信号最多只能被接收一次。内核为每个进程在 p e n d i n g 位向量中维护着待处 理信号的集合， 而在 b l o c ke d 位向量e 中维护着被阻塞的信号集合。只要传送了一个类型为 K 的 信 号 ，内 核 就 会 设 置 p e n d i n g 中的第 k 位， 而 只 要 接 收 了 一 个类型为 K 的信号 ，内 核 就 会 清 除 p e n d i ng 中 的 第 K 位。</p><ol><li><p>5. 2 发送信号</p><p>U nix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组( pro cess gro u p ) 这个概念的。</p><ol><li><p>进程组</p><p>每个进程都只属于一个进程组， 进程组是由一个正整数进程组 ID 来标识的。ge t pgr p</p><p>函数返回当前进程的进程组 ID :</p></li></ol></li></ol><p>#include &lt;unistd.h></p><p>pid_t getpgrp(void);</p><p>返回： 调 用进 程的 进 程 组 ID。</p><p>默认地，一 个 子 进程和它的父进程同属千一个进程组。一个进程可以通过使用 s e t ­ pg i d 函数来改变自己或者其他进程的进程组：</p><p>#include &lt;unistd.h></p><p>int setpgid(pid_t pid, pid_t pgid);</p><p>返回： 若 成 功 则 为 0 , 若铸 误 则为 一1。</p><p>s e 七p g i d 函 数 将 进程 p 过 的进程组改为 pg i d。如果 p i d 是 o, 那么就使用当前进程</p><p>8 也称为信号掩码( sig na l ma s k ) 。</p><p>的 PID。如果 pg过 是 o, 那么就用 pi d 指定的进程的 PID 作为进程组 ID。例如， 如果进程 1521 3 是调用进程， 那么</p><p>setpgid(O, O);</p><p>会创建一 个新的进程组，其 进程组 ID 是 15213, 并且把进程 15213 加入到这个新的进程</p><p>组中。</p><ol><li><p>用/ b i n / k i l l 程序发 送信号</p><p>/ b i n / k过1 程序可以向另外的进程发 送任意的 信号。比如，命 令</p><p>linux> /bin/kill -9 15213</p></li></ol><p>发送信号 9(SIGKIL L) 给进程 15213。一 个为负的 PID 会导致信号被发送到进程组 PID 中的每个进程 。比如，命 令</p><p>linux> /bin/kill -9 -15213</p><p>发送一个 SIGKILL 信号给进程组 15213 中的每个 进程。注意， 在此我们使用完整路径／</p><p>bi n / k i ll , 因为有些 U nix s h ell 有自己内 置的 k i ll 命令。</p><ol start=2><li><p>从键盘发送信号</p><p>Unix shell 使用作业( jo b ) 这个抽象概念来表示为对一条命令行求值而创建的进程。在任何时刻， 至多只有一个前台作业 和 0 个或多个后台作业。比如 ， 键入</p><p>linux> ls I sort</p><p><img src=img/c9fe1a0beccf004ea1b471855bceb69a.jpeg alt>会创建一个由两个进程组成的前 台作业， 这两个进程是通过 U n ix 管道连接起来的： 一个进程运 行 l s 程序， 另一个运行 s or t 程序。s h ell 为每个作 业创建 一个独立的 进程组。进程组 ID 通常取 自作 业中父进程中的一个 。比如， 图 8-28 展示了有一个前台作业和两个后台作业的 s h e ll 。前台作业中的父进程 PID 为 20 , 进程组 ID 也为 20。父进程创建两个子进程，每 个也都是进程组 20 的成员 。</p></li></ol><p>p i d = 21 pid=22</p><p>pgid=20 pgid=20</p><p>-&mdash;&mdash;&mdash;&mdash;&mdash;</p><p>前台进程组20</p><p>图 8-28 前 台 和后 台 进程组</p><p>在键盘上输入 Ctrl + C 会导致内核发送一个 SIGINT 信号到前台进程组中的每个进程。默认情况下 ，结果 是终止前台作业。类似地， 输入 Ctrl + z 会发送一个 SIGTST P 信号到前台进程组中 的每个进程。默认情 况下， 结果是停止（挂起）前台作业。</p><ol><li><p>用 k i l l 函数发 送信号</p><p>进程通过调用 K过 1 函数发送信号 给其他进程（包括它们 自己）。</p></li></ol><p>#include &lt;sys/types.h></p><p>#include &lt;signal.h></p><p>int kill(pid_t pid, int sig);</p><p>返回： 若 成 功 则 为 o, 若 错 误 则 为 一1。</p><p>如果 p i d 大于零， 那么 k i ll 函数发送信号号码 s i g 给进程 p i d 。如果 p i d 等千零 ， 那么k i ll 发送信号 s i g 给调用进 程所在进程组中的每个 进程， 包括调用进程自己。如果 p i d 小千零， k i ll 发送信号 s i g 给进程组 I pid I ( p i d 的绝对值）中的每个进程。图 8- 29 展示了一个示例， 父进程用 ki ll 函数发送 SIGK ILL 信号给它的 子进程。</p><p>code/ecf/kill.c</p><p>#include &ldquo;csapp.h&rdquo;</p><p>2</p><p>3 int main()</p><p>4 {</p><p>s pid_t pid;</p><p>6</p><p>7 I* Child sleeps until SIGKILL signal received, then dies *I</p><p>8 if ((pid = Fork()) == 0) {</p><p>9 Pause(); I* Wait for a signal to arrive *I</p><p>10 printf(&ldquo;control should never reach here!\n&rdquo;);</p><p>11 exit(O);</p><p>12 }</p><p>13</p><p>14 f* Parent sends a SIGKILL signal to a child *I</p><ol><li><p>Kill (pid, SIGKILL) ;</p></li><li><p>exit(O);</p><p>17 }</p></li></ol><p>code/ecf/kill.c</p><p>图 8-29 使用 K过 1 函数发送信号 给子进 程</p><ol start=2><li><p>用 a l a rm 函数发送信号</p><p>进程可以通过调用 a l a r m 函数向它自己发送 S IGALRM 信号。</p></li></ol><p><img src=img/0fbc7c4711b39d79f61bd317a01d4282.jpeg alt></p><p>a l ar m 函数安排内核在 s e c s 秒后发送一个 S IGALRM 信号给调用进程。如果 s e cs 是零， 那么不会调度安排新的闹 钟( a lar m ) 。在任何情况下， 对 a l ar m 的调用都将取消任何 待处理的( pe nd in g ) 闹钟， 并且返回任何待处理的闹钟在被发送前还剩下 的秒数（如果这次对 a l ar m 的调用没有取消它的 话）； 如果没有任何待处理的闹钟，就返 回零。</p><ol><li><p>5. 3 接收信号</p><p>当内核把进程 p 从内核模式切换到用户模式时（例如， 从系统调用返回或是完成了一次上下文切换）， 它会检查进程 p 的未被阻塞的待处理 信号的集合 ( p e nd i ng & ~b l o c ke d ) 。如果这个集合 为空（通常情况下）， 那么内核将控制 传递到 p 的逻辑控制流中的下一条指令 (J next ) 。 然而 ， 如果集合是非空的 ， 那么内核选择集合中的某个信号 k ( 通常是最小的 k ) , 并且强制 p 接收信号 k 。收到这个信号会触发进 程采取 某种行为。一旦进程完成了这个行为，那 么控制就传递回 p 的逻辑控制流中的下一条指令( J next ) 。 每个信号类型都有一个预定义的默认行为，是下面中的一种：</p><ul><li><p>进程终止。</p></li><li><p>进程终止并转储内存。</p></li><li><p>进程停止（挂起）直到被 SIG CO NT 信号重启。</p></li><li><p>进程忽略该信号。</p><p>图 8- 26 展示了与每个信号类 型相关联的默认行为。比 如， 收到 S IG K IL L 的默认行为就是终止 接收进程。另外， 接收到 S IGCH LD 的默认行 为就是忽略这个信号。进程可以 通过使用 s i g na l 函数修改和信号相关联的默认行为。唯一的 例外是 SIGS T OP 和 SIG K I L L , 它们的默认行为是不能修改的。</p><p>#include &lt;signal.h></p><p>typedef void (*sighandler_t)(int);</p><p>sighandler_t signal(int signum, sighandler_t handler);</p><p>返回： 若 成 功则 为 指 向 前 次 处 理 程 序 的 指 针 ， 若 出错 则 为 SIG_ERR C不设 置 err no )。</p></li></ul></li></ol><p>s i g na l 函数可以通过下列 三种方法之 一来改变和信号 s i g n um 相关联的行 为：</p><ul><li>如果 h a n d l er 是 SIG _IG N , 那么忽略类型为 s i g num 的信号。<ul><li><p>如果 ha nd l er 是 S IG _DF L , 那么类型为 s i g nu m 的 信号行为恢复为默认行 为。</p></li><li><p>否则， ha ndl e r 就是用户定义的函数的地址，这个 函数被称为信 号处理 程序，只 要进程接收到一个类型为 s i g nwn 的信号， 就会调用这个程序。通 过把处理程序的 地址传递到 s i gna l 函数从而改变默认行为，这 叫做设置信 号处理 程序( installing the han­</p><p>dler) 。调用信号处理程序被称为捕 获信号。执行信号处理程序被称 为处理信号。</p><p>当一个 进程捕 获了一个类型为 K 的信号时， 会调用为信号 k 设置的处理程序， 一个整数参数被设置 为 K。 这个参数允许同一个处理函数捕获不同类 型的信号。</p><p>当处理程序执行它 的 r e t ur n 语句时， 控制（通常）传递回控制流中进程被信号 接收中断位置处的指令。我们说“通常”是因为在某些系统中，被中断的系统调用会立即返回一 个错误。</p><p>图 8-30 展示了一个 程序，它 捕获用户在键盘上输入 C t rl + C 时发送的 S IG I NT 信号。SIGINT 的默认行为是立 即终止该进程。 在这个示例中， 我们将默认行为修改为捕获信号，输出一条消息，然后终止该进程。</p><p>信号处理程序可以被其 他信号处理程序中断， 如图 8-31 所示。在这个例子中， 主程</p><p>,, 序捕获到信号 s&rsquo; 该 信 号会中断主程序， 将控制转移 到处理程序 S。S 在运行时， 程序捕获信号 t #- s , 该信号会中断 s, 控制转移到 处理程序 T 。当 T 返回时 ， S 从它被中断的地方继续 执行。最 后， S 返回， 控制传送回主程序 ， 主程序从它 被中断 的地方继续执行。</p></li></ul></li></ul><p>#include &ldquo;csapp.h&rdquo;</p><p>2</p><p>code/ecf/sigint.c</p><p>3 void sigint_handler(int sig) I* SIGINT handler *I</p><p>4 {</p><p>s printf(&ldquo;Caught SIGINT!\n&rdquo;);</p><p>6 exit(O);</p><p>7 }</p><p>8</p><p>9 int main()</p><p>10 {</p><ol><li><p>I* Install the SIGINT handler *I</p></li><li><p>2 if (signal(SIGINT, sigint_handler) == SIG_ERR)</p></li><li><p>3 uni.x_error(&ldquo;signal error&rdquo;);</p><p>14</p><p>15 pause(); I* Wait for the receipt of a signal *I</p><p>16</p><p>17 return O·</p><p>18 }</p></li></ol><p>code/ecf/sigint.c</p><p>图 S :111 一 个用信号处理程序捕获 SIGINT 信号 的 程 序</p><p>主程序</p><p>( I ) 程序捕获信号s</p><p><img src=img/8d77e2f3c860275f80461a704c7014de.jpeg alt>CWT</p><p>主程序继续执行 I"°&rsquo;&rsquo;</p><p>( 2 ) 控制信号传递给处理程序S</p><p>处理程序S 处理程序T</p><p>图 8飞 l 信号处理程序可以被其他信号处理程序中断</p><p>让 练习题 8. 7 编写 一个叫做 s no o z e 的程序 ， 它 有 一个命令行参 数， 用 这个参数调用练 习题 8. 5 中的 s n o o z e 函数 ， 然 后终 止。编写 程 序， 使 得用 户 可以 通过在键 盘上输入 C t rl + C 中断 s n o o z e 函 数。 比如：</p><p>linux> ./ snooze 5</p><p>CTRL+C</p><p>Slept for 3 of 5 secs. linux></p><p>8. 5. 4 阻塞和解除阻塞信号</p><p>User hi t s Cr t l +C after 3 seconds</p><p>Linux 提供阻塞信号的隐式和显式的机制：</p><p>隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。 例如，图 8-31 中 ， 假设程序捕获了信号 s&rsquo; 当前正在运行处理程序 S 。如果发送给该进程另 一 个 信 号 s , 那 么 直 到 处 理 程序 S 返回， s 会 变成待处理而没有被接收。</p><p>显式阻寒机制。应用程序可以使用 s i g p r o c ma s k 函 数 和它的辅助函数，明 确地阻塞和解除阻塞选定的信号。</p><p>#include &lt;signal.h></p><p>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); int sigemptyset(sigset_t *set);</p><p>int sigfillset(sigset_t *set);</p><p>int sigaddset(sigset_t *Set, int signum); int sigdelset(sigset_t *set, int signum);</p><p>int sigismember(const sigset_t *set, int signum);</p><p>返回： 如 果 成 功 则为 0&rsquo; 若 出错 则为 - 1。</p><p>返回： 若 s i gnum 是 set 的 成 员 则 为 1, 如 果 不是 则 为 0&rsquo; 若 出错 则 为 - 1。</p><p>s i g p r o c ma s k 函数改变当前阻塞的信号集合C 8. 5. 1 节中描述的 block ed 位向最）。具体的行为依赖 于 h o w 的 值 ：</p><p>SIG_BLOCK: 把 s e t 中的信号添加到 b l o c ke d 中( b l o c ke d=b l o c ke d I s e t ) 。SIG_ UNBLOCK: 从bl oc ked 中删除 s e t 中的信号( b l o c ke d =b l o c ke d &&ndash;se t ) 。SIG_SETMASK: bl oc k=se t 。</p><p>如果 o l d s e t 非空， 那么 b l o c ke d 位向量之前的值保存在 o l d s e t 中。</p><p>使用下述函数对s e t 信号集合进行操作： s i ge mpt ys e t 初始化 s e t 为空集合。s i g f i ll s e t 函数把每个信号都添加到 s e t 中。s i ga dd s e t 函数把s i g nurn 添加到 s e t , s i gde l s e 七从 s e t 中删除 s i gnurn, 如果 s i g nurn 是 s e t 的成员 ， 那么 s i gi s me mber 返回 1, 否则返回0。</p><p>例如， 图 8-32 展示了如何用 s i gpr o c ma s k 来临时阻 塞接收 S IG INT 信号。</p><p>sigset_t mask, prev_mask;</p><p>2</p><p>3 Sigemptyset(&amp;mask);</p><p>4 Sigaddset(&amp;mask, SIGINT);</p><p>5</p><ol><li>I* Block SIGINT a 丑 d save previous blocked set *I</li><li>Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);</li></ol><p>8 : // Code region that will not be interrupted by SIG INT</p><p>9 I* Restore previous blocked set, unblocking SIGINT *I</p><p>10 Sigprocmask(SIG_SETMASK, &amp;prev_mask, NULL);</p><p>11</p><ol><li><p>5. 5 编写信号处理程序</p><p>图 8- 32 临时阻塞接收 一个信号</p></li></ol><p>信号处理是 L in ux 系统编程最棘手的一个问题。处理程序有几个属性使得它们很难推理分析： 1) 处理程序与主程序并发 运行 ， 共享同样的全局变量， 因此可能 与主程序和其他处理程序互相干扰； 2 ) 如何以及何时接收信号的规则常常有违人的直觉； 3 ) 不同的系统有不同的信号处 理语义。</p><p>在本节中 ，我们 将讲述这些问题， 介绍编写安全、正确和可移植的信号处理程序的一些基本规则 。</p><ol><li><p>安全的信号处理</p><p>信号处理程序很麻烦 是因为它们 和主程序以及其他信号处理程序并 发地运行 ， 正如我们在图 8-31 中看到的那样。如果处理程序和主程 序并发地访问同样的全局数据结构， 那</p></li></ol><p>么结果可能就不可预知，而且经常是致命的。</p><p>我们会在第 12 章详细讲述并 发编程。这里我们的目标是给你一些保守的编写处理程序的原则， 使得这些处理程序能安全地并 发运行 。如果你忽视这些原则， 就可能有引入细微的并发错误的风险。如果有这些错误，程序可能在绝大部分时候都能正确工作。然而当 它出错的时候， 就会错得不可预测和不可重复 ， 这样是很难调试的。一定要防患于未然！</p><ul><li>GO. 处理程序要尽可能简单。避免麻烦的最好方法是保持处理程序尽可能小和简单。例如， 处理程序可能只是简单地设置全局标志并立即返回； 所有与接收信号相关的处理都 由主程序执行 ， 它周期性地检查（并重置）这个标志。<ul><li>Gl. 在处理程序中只调用异步 信号安全的函数。所谓异步信号安全的函数（或简称安全的函数）能够被信号处理程序安全地调，用原 因有二： 要么它是可重入的（例如只访问局部变量， 见 12. 7. 2 节），要么它不能被信号处理程序中断。图 8-33列出了 Linux 保证安全的系统级函数。注意， 许多常见的函数（例如pr i ntf 、s pr i nt f 、mall oc 和 e xi t )都不在此列。</li></ul></li></ul><table><thead><tr><th>_Exit</th><th>fexecve</th><th>poll</th><th>sigqueue</th></tr></thead><tbody><tr><td>exit</td><td>fork</td><td>posix_trace_event</td><td>sigset</td></tr><tr><td>abort</td><td>fstat</td><td>pselect</td><td>sigsuspend</td></tr><tr><td>accept</td><td>fstatat</td><td>raise</td><td>sleep</td></tr><tr><td>access</td><td>fsync</td><td>read</td><td>sockatmark</td></tr><tr><td>aio_error</td><td>ftruncate</td><td>readlink</td><td>socket</td></tr><tr><td>aio_return</td><td>futimens</td><td>readlinkat</td><td>socketpair</td></tr><tr><td>aio_suspend</td><td>getegid</td><td>recv</td><td>stat</td></tr><tr><td>alarm</td><td>geteuid</td><td>recvfrom</td><td>symlink</td></tr><tr><td>bind</td><td>getgid</td><td>recvmsg</td><td>symlinkat</td></tr><tr><td>cfgetispeed</td><td>getgroups</td><td>rename</td><td>tcdrain</td></tr><tr><td>cfgetospeed</td><td>getpeername</td><td>renameat</td><td>tcflow</td></tr><tr><td>cfsetispeed</td><td>getpgrp</td><td>rmdir</td><td>tcflush</td></tr><tr><td>cfsetospeed</td><td>getpid</td><td>select</td><td>tcgetattr</td></tr><tr><td>chdir</td><td>getppid</td><td>sem_post</td><td>tcgetpgrp</td></tr><tr><td>chmod</td><td>getsockname</td><td>send</td><td>tcsendbreak</td></tr><tr><td>chown</td><td>getsockopt</td><td>sendmsg</td><td>tcsetattr</td></tr><tr><td>clock_gettime</td><td>getuid</td><td>sendto</td><td>tcsetpgrp</td></tr><tr><td>close</td><td>kill</td><td>setgid</td><td>time</td></tr><tr><td>connect</td><td>link</td><td>setpgid</td><td>timer_getoverrun</td></tr><tr><td>creat</td><td>linkat</td><td>setsid</td><td>timer_gettime</td></tr><tr><td>dup</td><td>listen</td><td>setsockopt</td><td>timer_settime</td></tr><tr><td>dup2</td><td>lseek</td><td>setuid</td><td>times</td></tr><tr><td>execl</td><td>lstat</td><td>shutdo&rsquo;\ffi</td><td>umask</td></tr><tr><td>execle</td><td>mkdir</td><td>sigaction</td><td>皿 ame</td></tr><tr><td>execv</td><td>mkdirat</td><td>sigaddset</td><td>unlink</td></tr><tr><td>execve</td><td>mkfifo</td><td>sigdelset</td><td>unlinkat</td></tr><tr><td>faccessat</td><td>mkfifoat</td><td>sigemptyset</td><td>ut i me</td></tr><tr><td>fchmod</td><td>mknod</td><td>sigfillset</td><td>utimensat</td></tr><tr><td>fchmodat</td><td>mknodat</td><td>sigismember</td><td>utimes</td></tr><tr><td>fcho=</td><td>open</td><td>signal</td><td>wait</td></tr><tr><td>fchownat</td><td>openat</td><td>sigpause</td><td>waitpid</td></tr><tr><td>fcntl</td><td>pause</td><td>sigpending</td><td>write</td></tr><tr><td>fdatasync</td><td>pipe</td><td>sigprocmask</td><td></td></tr></tbody></table><p>图 8-33 异步信号安全的函数（来源： ma n 7 signal。数据来自 Lin ux Foundation)</p><p>信号处理程序中产生输出唯一安全的方法是使用 wr i t e 函数（见10. 1 节）。特别地， 调用 pr i n 七f 或 s p r i n t f 是 不安全的。为了绕 开这个不幸的限制， 我们开发一些 安全的函数，称为 S IO ( 安全的 I/ 0 ) 包，可 以用来在信号处理程序中打印简单的消息。</p><p>#include &ldquo;csapp.h&rdquo;</p><p>ssize_t sio_putl(long v); ssize_t sio_puts(char s[]);</p><p>void sio_error(char s[]);</p><p>返回： 如 果 成 功则 为 传 送 的 字 节数 ，如 果 出错 ， 则 为 一1。</p><p>返回： 空。</p><p>sio p u t l 和 s i o p u t s 函数分别向标准输出传送一个 l o n g 类型数和一个字符串。</p><p>sio e rr or 函数打印一条错误消息并终止。</p><p>图 8- 34 给出的是 SIO 包的实现， 它使用了 c s a p p . c 中两个私有的可重入函数。第 3 行的 s i o_ s 七r l e n 函数返回字符串 s 的长度。第 10 行的 s i o _ l 七o a 函数基于来自[ 61] 的it o a 函数， 把 v 转换成它的基 b 字符串表示， 保存在 s 中。第 1 7 行的_ e x i t 函数是 e x 江的一个异步信号安全的变种。</p><p>codelsrc/csapp.c</p><p>ssize_t sio_puts(char s[]) I* Put string *I</p><p>2 {</p><p>3 return write(STDOUT_FILENO, s, sio_strlen(s));</p><p>4 }</p><p>5</p><p>6 ssize_t sio_putl(long v) I* Put long *I</p><p>7 {</p><p>8 char s (128) ;</p><p>9</p><p>10 sio_ltoa(v, s, 10); I* Based on K&amp;R itoa() *I</p><p>11 return sio_puts(s);</p><p>12 }</p><p>13</p><p>14 void sio_error(char s[]) I* Put error message and exit *I</p><p>15 {</p><p>16 sio_puts(s);</p><p>17 _exit(!);</p><p>18 }</p><p>图 8-3.J 信号处理程序的 SIO C安全 I/0) 包</p><p>codelsrc/csapp.c</p><p>图 8-3 5 给出了图 8- 30 中 S IG I NT 处理程序的一个 安全的版本。</p><p>code/ecflsigintsafe.c</p><p>#include &ldquo;csapp.h&rdquo;</p><p>2</p><p>3 void sigint_handler(int sig) I* Safe SIGINT handler *I</p><p>4 {</p><p>s Sio_puts(&ldquo;Caught SIGINT!\n&rdquo;); I* Safe output *I</p><p>6 _exit(O); I* Safe exit *I</p><p>7 }</p><p>code/ecf/sigien.ctsaf</p><p>图 8-35 图 8-30 的 SIGINT 处理程序的 一个安全版本</p><ul><li><p>G2. 保存和恢复 err no 。许多 Lin ux 异步信号安全的函数都会在出错返回时设置e rr no 。 在处理 程序中调用 这样的函数可能会干扰 主程序中其他依赖于 e r r no 的部分。解决方法是在进入处 理程序时把 err no 保存在一个局部 变量中 ， 在处理程序返回前恢复它。注意，只有在处理程序要返回时才有此必要。如果处理程序调用</p><p>_e x i t 终止该进程 ， 那么就不需要这样做 了。</p></li><li><p>G3. 阻塞 所有的信 号， 保护对共享全局数 据结构的访问。如果处理程序和主程序或其他处理程序共享一个全局数据结构， 那么在访问（读或者写）该数据结构时， 你的处理程序和主程序应该暂时阻塞所有的 信号。这条规则的原因 是从主程序访问一个数据结构 d 通常需要一系列的指令 ， 如果指令序列被访问 d 的处理程序中断， 那么处理程序可能会发现 d 的状态不一致， 得到不可预知的结果。在访问 d 时暂时阻塞信号保证了处理程序不会中断该指令序列。</p></li><li><p>G4. 用 vol a t i l e 声明全 局变量 。考虑一个处理程序和一个mai n 函数， 它们共享一个全局变 量 g。处理程序更新 g , mai n 周期性地读 g。对于一个优化编译器而言， mai n 中 g 的值看上去从来没有变化过， 因此使用缓存在寄存器中g 的副本来满足对g 的每次引用是很安全的。如果这样， mai n 函数可能永远都无法看到处理程序更新过的值。</p><p>可以用 vol a已 l e 类型限定符来定义一个变量，告 诉编译器不要缓存这个量变。例如：</p><p>volatile int g;</p></li></ul><p>vol a巨 l e 限定符强迫编译器每次在代码中引用 g 时， 都要从内存中读取 g 的值。一般来说 ， 和其他所有共享数据结构一样， 应该暂时阻塞信号， 保护每次对全局变量的访问。</p><ul><li><p>GS. 用 s i g_a t omi c _ 七 声明标志 。在常见的处理程序设计中， 处理程序会写全局标志来记录收到了信 号。主程序周期性 地读这个标志， 响应信号，再 清除该标志。对千通过这种方式 来共享的标志， C 提供一种整型数据类型 s i g _ a t omi c _ 七，对它的读和写保证会是原子的（不可中断的）， 因为可以用 一条指令来实现它们：</p><p>volatile sig_atomic_t flag;</p></li></ul><p>因为它们是不 可中断的，所 以可以安全地读和写 s i g _a t omi c _ t 变量，而不需要暂时阻塞信号。注意 ， 这里对原子性的保证只适用于单个的读和写， 不适用于像f l a g + + 或 fl a g=fl a g +l O 这样的更新， 它们可能需 要多条指令。</p><p>要记住 我们这里讲述的规则是保守的 ，也 就是说它们不总是严格必需的。例如，如果你知道处理 程序绝对 不会修改 err no , 那么就不需要保存和恢复 err no 。或者如果你可以证明 pr i nt f 的实例都不会被处理 程序中断 ， 那么在处理程序中 调用 pr i n t f 就是安全的。对共享全局数据结构的访问也是同样。不过，一般来说这种断言很难证明。所以我们建议 你采用保守的方法，遵循这些规则，使得处理程序尽可能简单，调用安全函数，保存和恢</p><p>复 er r n o , 保护对共享数 据结构的访问， 并使用 v ol a t i l e 和 s i g _a t omi c _ t 。</p><ol><li><p>正确的信号处理</p><p>信号的一个与直觉不符的方面是未处理的信号是不排队的。因为 p e nd i ng 位向量中每种类型的 信号只对应有一位， 所以每种类型最多 只能有一个未处理的信号。因此，如果两个类型 k 的信号发送 给一个目的进程，而 因为目的进程当前正在执行信号 k 的处理程序， 所以信号 k 被阻塞了， 那么第二个信号就简单地被丢 弃了；它 不会排队。关键思想是 如果存在一个未处理的信号就表明至少有一个 信号到达了。</p></li></ol><p>要了解这样会如何影响正确性， 来 看 一个简单的应用， 它 本 质 上 类似于像 sh ell 和</p><p>Web 服务器这样的真实程序。基本的结构是父进程创建一些子进程，这 些子进程各自独立运行一 段时间， 然后终止。父进程必须回收子进程以避免在系统中留下僵死进程。但是我们还 希 望 父 进 程 能 够 在 子 进 程 运 行 时 自 由 地 去 做 其 他 的 工 作。所以， 我 们 决 定 用</p><p>SIGCHLD 处 理程序来回收子进程， 而不是显式地等待子进程终止。（回想一下， 只 要 有一个子进程终止或者停止， 内 核 就会发 送一个 SIGCHLD 信号给父进程。）</p><p>图 8-36 展示 了我们的初次尝试。父进程设 置了一 个 SIGCH LD 处理程序， 然后创建</p><p>code/ecf/signall .c</p><p>I* WARNING: This code is buggy! *I</p><p>2</p><p>3 void handlerl(int sig)</p><p>4 {</p><p>5 int olderrno = errno;</p><p>6</p><p>7 if ((waitpid(-1, NULL, 0)) &lt; 0)</p><p>8 sio_error(&ldquo;waitpid er or&rdquo;) ;</p><ol><li><p>Sio_puts(&ldquo;Handler reaped child\n&rdquo;);</p></li><li><p>Sleep(!);</p></li><li><p>errno = olderrno;</p><p>12 }</p><p>13</p><p>14 int main()</p><p>15 {</p></li><li><p>int i, n;</p></li><li><p>char buf[MAXBUF];</p><p>18</p></li><li><p>if (signal(SIGCHLD, handler!)== SIG_ERR)</p></li><li><p>unix_error (&ldquo;signal error&rdquo;);</p><p>21</p><p>22 I* Parent creates children *I</p><p>23 for (i = 0; i &lt; 3; i ++) {</p><p>24 if (Fork() == 0) {</p></li><li><p>printf(&ldquo;Hello from child %d\n&rdquo;, (int)getpid());</p></li><li><p>exit(O);</p><p>27 }</p><p>28 }</p><p>29</p></li><li><p>I* Parent waits for terminal input and then processes it *I</p></li><li><p>if ((n = read(STDIN_FILENO, buf, sizeof(buf))) &lt; 0)</p></li><li><p>un i x _err or (&ldquo;read&rdquo;) ;</p><p>33</p></li><li><p>printf(&ldquo;Parent processing input\n&rdquo;);</p></li><li><p>while (1)</p><p>36</p><p>37</p><p>38 exit (0);</p><p>39 }</p></li></ol><p>cod/eecflignall.c</p><p>图8-36 signa ll : 这个程序是有缺陷的 ， 因 为它假设信号是排队的</p><p>了 3 个子进程。同时， 父进程等待来自终端的一个输入行，随 后 处 理 它 。 这个处理被模型化 为一个无限循环。当每个子进程终止时，内 核 通过发送一个 S IG C H LD 信号通知父进程。父进程捕获这个 SIG C H L D 信号， 回 收 一 个 子 进程， 做 一 些 其他的清理工作（模型化为 s l e e p 语句）， 然后返回。</p><p>图 8- 36 中的 s i g na l l 程序看起来相当简单。然而， 当 在 L in u x 系统上运行它时， 我</p><p>们得到如下输出：</p><p>linux> ./signal1</p><p>Hello from child 14073 Hello from child 14074 Hello from child 14075 Handler reaped child Handler reaped child CR</p><p>Parent processing input</p><p>从输出中我们 注意到，尽 管 发送了 3 个 SIGC H LD 信号给父进程，但 是其中只有两个信号被接收了，因此父进程只是回收了两个子进程。如果挂起父进程，我们看到，实际上子进程14075 没有被回收，它成 了一 个僵 死 进程（在p s 命令的输出中由字符串 " de f unc t " 表明）：</p><p>Ctrl+Z Suspended linux> ps t</p><table><thead><tr><th>PID TTY</th><th>STAT</th><th>TIME</th><th>COMMAND</th></tr></thead><tbody><tr><td>14072 pts/3</td><td>T</td><td>O: 02</td><td>. /signall</td></tr><tr><td>14075 pts/3</td><td>Z</td><td>0:00</td><td>[signall] &lt;defunct></td></tr><tr><td>14076 pts/3</td><td>R+</td><td>0:00</td><td>ps t</td></tr></tbody></table><p>哪里出错了呢？问题就在于我们的代码没有解决信号不会排队等待这样的情况。所发 生的 情 况 是 ： 父进程接收并捕获了第一个信号。当处理程序还在处理第一个信号时， 第二个 信 号 就 传 送并 添 加 到了待处理信号集合里。然而，因 为 SIG C H LD 信号被 SIG C H LD 处理程序阻塞了，所 以 第二个信号就不会被接收。此后不久，就 在 处 理 程序还在处理第一个信 号 时 ，第 三个信号到达了。因为已经有了一个待处理的 S IG C H L D , 第三个 S IG C H LD 信号 会被 丢弃。一段时间之后， 处理程序返回，内 核 注意到有一个待处理的 S IG C H LD 信号 ， 就迫使父进程接收这个信号。父进程捕获这个信号， 并第二次执行处理程序。在处理程序完成对第二个信号的处理之后， 已经没有待处理的 S IG C H L D 信号了， 而且也绝不会再 有，因 为第三个 S IG C H L D 的所有信息都已经丢失了。由此得到的重要 教 训是， 不 可以用信 号来对其他进程中发 生的 事件计数。</p><p>为了修正这个问题，我们必须回想一下，存在一个待处理的信号只是暗示自进程最后 一次收到一个信号以来， 至少已经有一个这种类型的信号被发送了。所以我们必须修改S IG C H L D 的 处 理 程序，使 得每次 S IG C H LD 处理程序被调用时 ， 回 收 尽 可能多的僵死子进程。图 8- 37 展示了修改后的 SIGC H L D 处理程序。</p><p>当我们在 Lin u x 系统上运行 s i g n a l 2 时， 它 现 在可以正 确地回收所有的僵死子进程了：</p><p>linux> ./signal2</p><p>Hello from child 15237</p><p>Hello from child 15238 Hello from child 15239 Handler reaped child Handler reaped child Handler reaped child CR</p><p>Parent processing input</p><p>void handler2(int si g)</p><p>2 {</p><p>3 int olderrno = errno;</p><p>4</p><p>s while (waitpid(-1, NULL, 0) > 0) {</p><p>6 Sio_puts(&ldquo;Handler reaped ch辽d\ n&rdquo;) ;</p><p>7 }</p><p>8 if (errno != ECHILD)</p><p>9 Sio_error(&ldquo;waitpid error&rdquo;);</p><ol><li><p>Sleep(i);</p></li><li><p>errno = olderrno; 12 }</p><p>code/ecfilgsna/2.c</p></li></ol><p>code/ecfl signal2.c</p><p>图 8-3 7 s i gnal 2: 图 8-36 的一个改进版本 ， 它能够正确解决信号不 会排队 等待的情况</p><p>沁 练习题 8. 8 下 面这 个程序 的输 出是 什么？</p><p>volatile long counter= 2;</p><p>2</p><p>3 void handlerl(int sig)</p><ul><li><p>4 {</p><p>5 sigset_t mask, prev_mask;</p><p>6</p></li></ul><ol><li>Sigfillset(&amp;mask);</li></ol><p>codelecfls ig nalp ro bO.c</p><ol start=2><li><p>Sigprocmask(SIG_BLOCK, &amp;mask, &amp;pr ev _ma s k) ; I* Block sigs *I</p><p>9 Si o_putl (- - c oun t er ) ;</p><p>10 Si gpr oc mas k (SI G_SETMAS K , &amp;prev_mask, NULL); I* Restore sigs *I</p><p>11</p><p>12 _e x i t ( O) ;</p><p>13 }</p><p>14</p><p>15 int main()</p><p>16 {</p></li><li><p>pid_t pid;</p></li><li><p>sigset_t mask, prev_mask;</p><p>19</p></li><li><p>printf (11%ld11 , counter) ;</p></li><li><p>f fl us h ( s t dout ) ;</p><p>22</p><p>23 signal (SIGUSR1, handler!) ;</p><p>24 if ((pid = Fork()) == 0) {</p></li></ol><p>25 Yhile(1) {};</p><p>26</p><ol><li><p>Kill (pid, SIGUSR1);</p></li><li><p>Waitpid(-1, NULL, 0);</p><p>29</p></li><li><p>Sigfillset (&amp;mask);</p></li><li><p>Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask); I* Block sigs *I</p></li><li><p>printf (11%ld11 , ++counter) ;</p></li><li><p>Sigprocmask(SIG_SETMASK, &amp;prev_mask, NULL); I* Restore sigs *I</p><p>34</p><p>35 exit (0);</p><p>36 }</p></li><li><p>可移植的信号处理</p><p>code/ef俎ic gnalprobO.c</p></li></ol><p>U n ix 信号处理的另一个缺陷在于不同的系统有不同的信号处理语义。例如：</p><ul><li><p>s i g n a l 函数的语 义各 有不同。有 些老的 U n ix 系统在信号 K 被处理程序捕获之后就把对信号k 的反应恢 复到默认值。在这些 系统上， 每次运行 之后， 处理程序必须调用 s i g n a l 函数， 显式地重新设置它自己。</p></li><li><p>系统调用可 以被中断 。像 r e a d 、 wr i 七e 和 a c c e p t 这样的系统调用潜在地会阻塞进程一段较长的时间 ， 称为慢 速 系统调用。在 某些较早版本的 U nix 系统 中， 当处理程序捕 获到一个信号时 ， 被中断的慢速系统 调用在信号处理程序返回时不再继续， 而是立即返回给用户一个错误条件， 并将 e rr n o 设置为 E I N T R 。在这些系统上， 程序员必须 包括手动重启 被中断的系统调用的代码。</p><p>要解决这些问 题， P o s ix 标准定 义了 s i g a c t i o n 函数， 它允许用户在设置信号处理时，明确指定他们想要的信号处理语义。</p><p>#include &lt;signal.h></p></li></ul><p>int sigaction(int signum, struct sigaction *act, struct sigaction *oldact);</p><p>返回： 若 成 功则 为 0 , 若 出错 则 为 - I .</p><p>s i g a c t i o n 函数运用并不广泛， 因为它要求用户设置一个复杂结构的条目。一个更简洁的方 式， 最初是由 W. Richard Stevens 提出的[ 11 0 ] , 就是定义一个包装 函数， 称为</p><p>Signal, 它调用 s i g a c t i o n。图 8-38 给出了 S i g n a l 的定义，它的 调用方式与 s i g na l 函</p><p>数的调用方式一样。</p><p>S i g n a l 包装函数设置了一 个信号处理程序， 其信号处理语义如下 ：</p><ul><li><p>只 有这个处 理程序当前正在处理的那种类型的 信号被阻塞。</p></li><li><p>和所有信号实现一样，信号不会排队等待。</p></li><li><p>只要可能 ， 被中断的系统调用会自动重启。</p></li><li><p>一旦设置了信号处理程序， 它就会一直保持， 直到 S i g n a l 带着 h a nd l e r 参数为</p><p>S IG _ IG N 或 者 S IG _DF L 被调用。</p><p>我们在所有的 代码中实现 Si g n a l 包装函数 。</p></li></ul><p>8. 5. 6 同步流以避免讨厌的并发错误</p><p>如何编写读写相同存储位置的并发流程序的问 题， 困扰着数代计算机科学家。一般而</p><p>言，流可能交错的数量与指令的数量呈指数关系。这些交错中的一些会产生正确的结果， 而有些则不会。基本的问题是以某种方式同步并发流，从而得到最大的可行的交错的集 合， 每个可行的 交错都能得到正确的结果。</p><p>code/src/csapp.c</p><p>handler_t *Signal(int signum, handler_t *handler)</p><p>｛</p><p>struct sigaction action, old_action;</p><p>action.sa_handler = handler;</p><p>sigemptyset(&amp;action.sa_mask); I* Block sigs of type being handled *I action.sa_flags = SA_RESTART; I* Restart syscalls if possible *I</p><p>if (sigaction(signurn, &amp;action, &amp;old_action) &lt; 0) unix_error(&ldquo;Signal error&rdquo;);</p><p>return (old_action.sa_handler);</p><p>codelsrdcsapp.c</p><p>图8-38 Si gna l : s i ga c t i on 的一个包装函数 ， 它提供在 Posix 兼容系统上的可移植的 信号处理</p><p>并发编程是一个很深且很重要的问题， 我们将在第 12 章 中更详细地讨 论。不过， 在本章中学习的有关 异常控制流的 知识， 可以让你感觉一下与并发相关的有趣的智力挑战。例如， 考虑图 8-39 中的程序， 它总结了一个典型的 U nix shell 的结构。父进程在一个全局 作业列 表中记录着它的 当前子进程， 每个作 业一个条目。a d d j o b 和 d e l e 七e j o b 函数分别 向这个作业列表 添加和从中删除作业。</p><p>当父进程创建一个新的子进程后 ， 它就把这 个子进程添加到 作业列表中。当父进程在</p><p>SIGCHLD 处理程序中回收一个终止的（僵死）子进程时， 它就从作业列表中删除这个子进程。</p><p>乍一看 ， 这段代码是对的。不幸的是， 可能发生下面这样的 事件序列 ：</p><ol><li>父进程执行 f o r k 函数，内 核调度新创建的子进程运行 ， 而不是父进程。</li></ol><ol><li><p>) 在父进程能 够再次运行之前， 子进程就终止， 并且变成一个僵死进程， 使得内核传递一个 SIGCH LD 信号给父进程。</p></li><li><p>) 后来， 当父 进程再次变成可运行但又 在它执行之前，内 核注意到有未处理的</p><p>SIGCHLD 信号， 并通过在父进程中运行处 理程序接收 这个信号。</p></li><li><p>) 信号处理程序回收终止的子进程，并 调用 d e l e t e j o b , 这个函数什么也不做， 为父进程还没有把该子进程添加到列表中。</p></li><li><p>) 在处理程序运行完毕后，内 核运行父进程， 父进程从 f or k 返回， 通过调用 a d d­ j ob 错误地把（不存在的）子进程添加到作 业列表中。</p><p>因此， 对千父进 程的 ma i n 程序和信号处理流的某些交错， 可能会在 a d d j o b 之前调用 d e l e t e j o b 。这导 致作业列 表中出现一个不正确的条目， 对应于一个不再存在而且永远也不会被删 除的作业。另一方面，也 有一些交错 ， 事件按照正确的顺 序发生。例如， 如果在 fo r k 调用返回时，内 核刚好调度父进程而不是子进程运行， 那么父进程就会正确地把子进程添加到作业列表中，然后子进程终止，信号处理函数把该作业从列表中删除。</p><p>这是一个称为竞争 ( ra ce ) 的经典同步错误的示例。在这个情况中， ma i n 函数中调用</p><p>add j ob 和处理程序中调用 d e l e t e j ob 之间存在竞争。如果 a d d j o b 赢得进展，那 么结果</p></li></ol><p>就是正确的。如果它没有， 那么结果就是错误的。这样的错误非常难以调试， 因为几乎不可能测试所有的交错。你可能运行这段代码十亿次， 也 没有一次错误， 但是下一次测试却导致引发竞争的交错。</p><p>codelecf/p rocmaskl .c</p><p>I* WARNING: This code is buggy! *I</p><p>2 void handler(int sig) 3 {</p><p>4 int olderrno = errno;</p><p>5 sigset_t mask_all, prev_all;</p><p>6 pid_t pid;</p><p>8 Sigf illset(&amp;mask_all) ;</p><p>9 while ((pid = waitpid(-1, NULL, 0)) > 0) { I* Reap a zombie child *I</p><ol><li><p>Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;pr e v _a ll ) ;</p><ol><li><p>de l et e j ob (pi d) ; I* Delete the child from the job list *I</p></li><li><p>Sigprocmask(SIG_SETMASK, &amp;prev_all, NULL);</p><p>13 }</p><p>14 if (errno != ECHILD)</p><p>15 Sio_error(&ldquo;waitpid error&rdquo;);</p><p>16 errno = olderrno·</p><p>17 }</p><p>18</p><p>19 int main(int argc, char **argv)</p><p>20 {</p></li></ol></li><li><p>int pid;</p></li><li><p>sigset_t mask_all, prev_all;</p><p>23</p></li><li><p>Sigfillset (&amp;ma s k_a ll ) ;</p></li><li><p>Signal(SIGCHLD, handler);</p></li><li><p>initjobs(); I* Initialize the job list *I</p><p>27</p></li><li><p>while (1) {</p></li><li><p>if ((pid = Fork()) == 0) { I* Child process *I</p></li><li><p>Execve("/bin/date", argv, NULL);</p><p>31 }</p></li><li><p>Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;pr ev _a ll ) ; I* Parent process *I</p></li><li><p>addjob(pid); I* Add the child to the job list *I</p></li><li><p>Sigprocmask(SIG_SETMASK, &amp;prev_all, NULL);</p><p>35 }</p><p>36 e x i t ( O) ;</p><p>37 }</p><p>cod e/ ecf/ p roc maskl.c</p></li></ol><p>图 8-39 一 个 具 有细微同步错误的 shell 程序。如果子进程在父进程能够开始运行前就结束了， 那么</p><p>add j ob 和 de l e t e j ob 会以错误的方式被调用</p><p>图 8-40 展示 了 消除图 8-39 中竞争 的一种 方 法。通 过 在调用 f or k 之前， 阻塞S IGCH LD 信号， 然后在调用 a dd j o b 之后取消阻塞这些信号， 我们保证了在子进程被添加到作业列表中之后回收该子进程。注意 ， 子进程继 承了它们父进程的被阻塞集合， 所以我们必须在调用 e x e c v e 之前，小 心地解除子进程中阻 塞的 SIGCHLD 信号。</p><p>code/ecflprocmask2.c</p><p>void handler(int sig)</p><p>2 {</p><ol><li><p>int olderrno = errno;</p></li><li><p>sigset_t mask_all, prev_all;</p></li><li><p>pid_t pid;</p></li><li><p>Sigfillset (&amp;mask_all);</p></li><li><p>while ((pid = waitpid(-1, NULL, 0)) > 0) { f* Reap a zombie child *f</p></li><li><p>Sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</p></li><li><p>deletejob(pid); I* Delete the child from the job list *I</p></li><li><p>Sigprocmask (SIG_SETMASK, &amp;prev_all, NULL) ; 12 }</p></li><li><p>3 if (errno != ECHILD)</p></li><li><p>Sio_error(&ldquo;waitpid error&rdquo;);</p></li><li><p>errno = olderrno; 16 }</p><p>17</p><p>18 int main(int argc, char **argv) 19 {</p></li><li><p>int pid;</p></li><li><p>sigset_t mask_all, mask_one, prev_one;</p><p>22</p></li><li><p>Sigfillset(&amp;mask_all);</p></li><li><p>Sigemptyset (&amp;mask_one) ;</p></li><li><p>Sigaddset(&amp;mask_one, SIGCHLD);</p></li><li><p>Signal(SIGCHLD, handler);</p></li><li><p>initjobs(); I* Initialize the job list *I</p><p>28</p></li><li><p>while (1) {</p></li><li><p>· Si gpr oc ma s k (S I G_BLOCK, &amp;mask_one, &amp;prev_one); I* Block SIGCHLD *f</p></li><li><p>if ((pid = Fork()) == 0) { I* Child process *I</p></li><li><p>Sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); f* Unblock SIGCHLD *f</p></li><li><p>Exeeve (11/bin/date11, argv, NULL) ; 34 }</p></li><li><p>Sigprocmask(SIG_BLOCK, &amp;mask_all, NULL); I* Parent process *I</p></li><li><p>addjob(pid); I* Add the child to the job list *I</p></li><li><p>Sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); f* Unblock SIGCHLD *f</p><p>38 }</p><p>39 exit(O); 40 }</p><p>code/ecfl p roc mask2.c</p></li></ol><p>图 8-40 用 s i gpr ocmas k 来同步进程。在这个例子中 ，父进程保证在相应的 del et e job 之前执行 add job</p><ol><li><p>5. 7 显式地等待信号</p><p>有时候 主程序需要显式地等待某个信号处理程序运行。例如，当 Linu x shell 创建一个前台作业时 ， 在接收下一条用户命令之前， 它必须等待作业终止， 被 SIGCHLD 处理程序回收。</p><p>图 8-41 给出了一个基本的思路。父进程设置 SIGINT 和 SIGCH LD 的处理程序， 然后</p></li></ol><p>进入一个无限循环。它阻塞 S IG C H L D 信号， 避免 8. 5. 6 节中讨论过的父进程和子进程之间的竞争。创建了 子进程之后， 把 p 过 重置为 o, 取消阻塞 S IG C H L D , 然后以循环的方式等待 p 迈 变为非零。子进程终止后， 处理程序回收它， 把它非零的 P ID 赋值给全局 p i d</p><p>变温。这会终止循环，父进程 继续其他的工作， 然后开始下一次迭代。</p><p>code/ecflwaitforsignal.c</p><p>#include &ldquo;csapp.h&rdquo;</p><p>2</p><p>3 volatile sig_atomic_t pid;</p><p>4</p><p>5 void sigchld_handler(int s)</p><p>6 {</p><ol><li><p>int olderrno = errno;</p></li><li><p>pid = wai tpid( 一 1 , NULL, O);</p></li><li><p>errno = olderrno;</p><p>10 }</p><p>11</p><p>12 void sigint_handler(int s)</p><p>13 {</p><p>14 }</p><p>15</p><p>16 int main(int argc, char **argv)</p><p>17 {</p><p>18 sigset_t mask, prev;</p><p>19</p></li><li><p>Signal(SIGCHLD, sigchld_handler);</p></li><li><p>Signal (SIGINT, sigint_handler) ;</p></li><li><p>Sigemptyset(&amp;mask);</p><p>23 Sigaddset (&amp;mask, SIGCHLD) ;</p><p>24</p></li><li><p>while (1) {</p></li><li><p>Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); I* Block SIGCHLD *I</p><p>27 if (Fork() == 0) I* Child *I</p><p>28 exit (0);</p><p>29</p></li><li><p>I* Parent *I</p></li><li><p>pid = O;</p></li><li><p>Sigprocmask(SIG_SETMASK, &amp;prev, NULL); I* Unblock SIGCHLD *I</p><p>33</p><p>34 I* Wait for SIGCHLD to be received (wasteful) *I</p><p>35 while (! pid)</p><p>36</p><p>37</p></li><li><p>I* Do some work after receiving SIGCHLD *I</p></li><li><p>printf(".");</p><p>40 }</p><p>41 exit(O);</p><p>42 }</p></li></ol><p>code/ecflwaitforsignal.c</p><p>图 8- 41 用循环来等待信号 。这段代码正确， 但循环是一种浪费</p><p>当这段代码正确执行的时候，循环在浪费处理器资源。我们可能会想要修补这个问 题， 在循环体内插入 pa us e :</p><p>while (! pid) I* Race! *I pause();</p><p>注意， 我们仍然需要一个循环， 因 为收到一个或多个 S IGINT 信号， p a u s e 会 被 中断。不过， 这段代码有很严直 的竞 争 条 件： 如果在 wh i l e 测 试 后 和 p a u s e 之前 收到SIGC H LD 信号， p a u s e 会永远睡眠。</p><p>另一个选择是用 s l e e p 替换 p a us e :</p><p>while (! pid) I* Too slow! *I sleep(!);</p><p>当这段代码正确执行时， 它太慢了。如果在 wh i l e 之 后 p a u s e 之 前 收 到 信 号 ， 程 序必须 等相当长的一段时间才会再次检查循环的终止条件。使用像 na nos l e e p 这样更高精度的休眠函数也是不可接受的，因为没有很好的方法来确定休眠的间隔。间隔太小，循环 会太浪费。间隔太大，程序又会太慢。</p><p>合适的解决方法是使用 s i g s u s p e nd 。</p><p>#include &lt;signal.h></p><p>int sigsuspend(const sigset_t *mask);</p><p>返回： —1。</p><p>s i g s us pe nd 函数暂时用 ma s k 替换当前的阻塞集合， 然后挂起该进程， 直 到收到一个信号，其行为要么是运行一个处理程序，要么是终止该进程。如果它的行为是终止，那 么该进程不从 s i g s us pe nd 返回就直接终止。如果 它的行为是运行一个处 理程序， 那 么s i g u s p e n d 从处理程序返回，恢 复 调 用 s i g s u s pe nd 时 原 有的阻塞集合。</p><p>s i g s us pe nd 函数等价于下述代码的原子的（不可中断的）版本：</p><p>sigprocmask(SIG_SETMASK, &amp;mask, &amp;prev); pause();</p><p>3 sigprocmask(SIG_SETMASK, &amp;prev, NULL);</p><p>原子属 性保证对 s i g pr oc ma s k( 第 1 行）和pa us e ( 第 2 行）的调用总是一起发生的，不 会 被中断。这样就消除了潜在的竞争， 即 在 调 用 s i g pr o c ma s k 之后但在调用 pa us e 之前收到了一个信号。</p><p>图 8- 42 展示了如何使用 s i g s u s pe nd 来替代图 8- 41 中的循 环。在每次调用 s i g s us ­ pe nd 之前，都 要 阻 塞 SIG CH LD。 s i g s us p e nd 会暂时取消阻塞 S IGCH LD , 然后休眠， 直到父进程捕获信号。在返回之前， 它会恢复原始的阻塞集合， 又再次阻塞 SIG C H L D。如果父进程捕获一个 SIG IN T 信号，那 么 循 环 测 试 成 功 ，下 一 次 迭代又再次调用 s i g s us ­ pe nd。如果 父 进 程 捕 获 一 个 SIGCH LD , 那么循环测试失败，会退出循环。此时， SIGCH LD 是被阻塞的，所 以 我们可以可选地取消阻塞 SIG CH LD。在真实的有后台作业需要回收的 shell 中这样做可能会有用处。</p><p>s i g s us pe nd 版本比起原来的循环版本不那么浪费， 避免了引入 p a us e 带来的竞争， 又比 s l e e p 更有 效 率 。</p><p>code/ecflsigsuspend.c</p><p>1 #include &ldquo;csapp.h&rdquo;</p><p>2</p><p>3 volatile sig_atomic_t pid;</p><p>4</p><p>5 void sigchld_handler(int s)</p><p>6 {</p><p>7 int olderrno = errno;</p><p>8 . p过 ＝ 扣釭 t p 过（ 一1 , NULL, O);</p><p>9 errno = olderrno·</p><p>10 }</p><p>11</p><p>12 void sigint_handler(int s)</p><p>13 {</p><p>14 }</p><p>15</p><p>16 int main(int argc, char **argv)</p><p>17 {</p><p>18 sigset_t mask, prev;</p><p>19</p><ol><li><p>Signal(SIGCHLD, sigchld_handler);</p></li><li><p>Signal(SIGINT, sigint_handler);</p></li><li><p>Sigemptyset(&amp;mask);</p></li><li><p>Sigaddset(&amp;mask, SIGCHLD); 24</p></li><li><p>while (1) {</p></li><li><p>Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev); I* Block SIGCHLD *I</p></li><li><p>if (Fork() == 0) I* Child *I</p><p>28 exit(O);</p><p>29</p></li><li><p>I* Wait for SIGCHLD to be received *I</p></li><li><p>pid = O;</p></li><li><p>while (! pid)</p></li><li><p>sigsuspend(&amp;prev);</p><p>34</p></li><li><p>I* Optionally unblock SIGCHLD *I</p></li><li><p>Sigprocmask(SIG_SETMASK, &amp;prev, NULL);</p><p>37</p></li><li><p>I* Do some work after receiving SIGCHLD *I</p></li><li><p>printf(". &ldquo;);</p><p>40 }</p><p>41 exit(O); 42 }</p></li></ol><p>code/ecfl sigs uspend.c</p><p>图 8-42 用 s i gs us pe nd 来等待信号</p><ol><li><p>6 非本地跳转</p><p>C 语言提供了一种用户级异常控制流形式，称 为非本地跳转( no nloca l jump), 它将控</p><p>制 直 接从一个函数转移到另一个当前正在执行的函数，而 不 需 要 经 过 正 常 的 调 用－ 返回序</p></li></ol><p>列。非本地跳转是通过 s e t j mp 和 l o ng j mp 函数来提供的 。</p><p>#include &lt;setjmp.h></p><p>int int</p><p>setjmp(jmp_buf env);</p><p>si gset jmp (s 屯 j mp _buf env, int savesigs);</p><p>返回： se t jmp 返 回 O, l ong jmp 返 回 非零。</p><p>s e t j mp 函数在 e nv 缓冲区中保 存当前调用环境 ， 以供后面的 l o n g j mp 使 用 ， 并返回</p><p>0。调用环境包括程序计数器、栈指针和通用目的寄存器。出于某种超出本书描述范围的 原因， s e t j mp 返回的值不能被赋值给变量：</p><p>re= setjmp(env); I* Wrong! *I</p><p>不过它可以安全地用在 S W止 c h 或条件语句的测 试中[ 62] 。</p><p>#include &lt;setjmp.h></p><p>void longjmp(jmp_buf env, int retval);</p><p>void siglongjmp(sigjmp_buf env, int retval);</p><p>从不返回 。</p><p>l o n g j mp 函数从 e nv 缓冲区中恢复调用环境， 然后触发一个从最近一次初始化 e nv</p><p>的 s e t j mp 调用的返回。然后 s e t j mp 返回， 并带有非零的返回值r e t v a l 。</p><p>第一眼看过去， s e t j mp 和 l o n g j mp 之间的相互关系令人迷惑。s e t j mp 函数只被调用一次， 但返回多 次： 一次是当第一次调用 s e t j mp , 而调用环境保存在缓 冲区 e nv 中时， 一次是为每个相应 的 l o ng j mp 调用。另一方面， l o ng j mp 函数被调用一次， 但从不返回。</p><p>非本地跳转的一个重要应用就是允 许从一个深层嵌套的函数调用中立即返回， 通常是由检测到某个错误 情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误情况， 我们可 以使用非本地跳转直接返回到一个普通的本 地化的错 误处理程序， 而不是费力地解开调用栈 。</p><p>图 8-43 展示了一个示例，说 明这可能是如何工作的。ma i n 函数首先调用 s e t j mp 以保存当前的调用环境， 然后调用 函数 f o o , f o o 依次调用函数 bar 。如果 f o o 或者 b ar 遇到一个错误 ， 它们立即通过一次 l o ng j mp 调用从 s e t j mp 返回。s e 七 j mp 的 非零返回值指明了错误类型， 随后可以被解码 ， 且在代码中的某个位置进行处 理。</p><p>code/ecf/setjmp.c</p><p>#include &ldquo;csapp.h&rdquo; jmp _buf buf;</p><p>int error!= O;</p><p>int error2 = 1;</p><p>vo i d foo(void), bar(void);</p><p>图8-43 非本地跳转的示例。本示例表明了使用非本地跳转来从深层嵌套的函数调用中的错误情况恢复， 而不需要解开整个栈 的基本框架</p><p>10 int main()</p><p>11 {</p><ol><li><p>switch(setjmp(buf)) {</p></li><li><p>case 0:</p><p>14 foo();</p><p>15 break;</p></li><li><p>case 1:</p></li><li><p>printf(&ldquo;Detected an errorl condition in foo\n&rdquo;);</p></li><li><p>break;</p></li><li><p>case 2:</p></li><li><p>printf(&ldquo;Detected an error2 condition in foo\n&rdquo;);</p></li><li><p>break;</p></li><li><p>default:</p></li><li><p>printf (&ldquo;Unknown error condition in foo\n&rdquo;);</p><p>24 }</p><p>25 exit(O);</p><p>26 }</p><p>27</p></li><li><p>I* Deeply nested function foo *I</p></li><li><p>void foo(void)</p><p>30 {</p></li><li><p>if (errorl)</p></li><li><p>longjmp(buf, 1);</p></li><li><p>bar();</p><p>34 }</p><p>35</p><p>36 void bar(void)</p><p>37 {</p></li><li><p>if (error2)</p></li><li><p>longjmp (buf, 2);</p><p>40 }</p></li></ol><p>code/ecf/setjmp.c</p><p>图 8- 43 (续）</p><p>l o ng j mp 允 许它跳过所有中间 调用的特性可能产 生意外的后果。例如， 如果中间函数调用中分配了某些数据结构，本来预期在函数结尾处释放它们，那么这些释放代码会被跳 过，因而会产生内存泄涌。</p><p>非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。图8-44 展示了一个简单的程序，说明 了这种基本技术。当用户在键盘上键入 C trl + C 时， 这个程序用 信号 和非本地跳转来实现软重启。 s i g­ s e t j mp 和 s i g l o ng j mp 函数是 s e t j mp 和 l o ng j mp 的可 以被信号处理程序使用的版本。</p><p>在程序第一次启动时， 对 s i g s e t j mp 函数的初始调用保存调用环境和信号的上下文</p><p>（包括待处理的和被阻塞的信号向扯）。随后，主函数进入一个无限处理循环。当用户键入 C t rl + C 时，内 核发送一个 S IG I N T 信号给这个进程，该 进程捕获这个信号。不是从信号处理程序返回，如果是这样那么信号处理程序会将控制返回给被中断的处理循环，反之， 处理程序完成一个非本地跳转， 回到 ma i n 函数的开始处。当我们在系统上运行这个程序时，得到以下输出：</p><p>linux> ./restart starting processing .. . processing . . .</p><p>Ctrl+C restarting processing&mldr; Ctrl+C restarting processing . . .</p><p>关千这个程序有两件很有趣的事情。首先， 为了避免竞争，必须 在调用 了 s i g s e t j mp 之后再设 置处 理 程序 。否 则 ，就 会 冒在初始调用 s i gs e t j mp 为 s i g l o ng j mp 设 置调用环境之前运行处理程序的风险。其次，你 可 能 巳 经 注 意 到 了 ， s i g s e t j mp 和 s i g l ong j mp 函 数 不 在 图8- 33 中异 步信号安全的函数之列。原因是一般来说 s i g l ong j mp 可以 跳到任意代码，所 以 我们必须小心， 只在 s i g l o ng j mp 可达的代码中调用安全的函数。在本例中， 我们调用安全的 s i o主 u t s 和 s l e e p 函数。不安全的 e x i t 函数是不可达的。</p><p>#include &ldquo;csapp.h&rdquo;</p><p>2</p><p>code/ecf/restart.c</p><p>3 sigjmp_buf buf;</p><p>4</p><p>s void handler(int sig)</p><p>6 {</p><p>7 s iglongjmp (buf , 1) ;</p><p>8 }</p><p>9</p><p>1o int main()</p><p>11 {</p><ol><li><p>if (!sigsetjmp(buf, 1)) {</p></li><li><p>Signal(SIGINT, handler);</p></li><li><p>Sio_puts(&ldquo;starting\n&rdquo;);</p><p>15 }</p></li><li><p>else</p></li><li><p>Sio_puts (&ldquo;restarting\n&rdquo;) ;</p><p>18</p></li><li><p>while(!) {</p></li><li><p>Sleep(! ) ;</p></li><li><p>Sio_puts (&ldquo;processing &mldr; \n&rdquo;);</p><p>22 }</p><p>23 exit(O); I* Control never reaches here *I</p><p>24 }</p></li></ol><p>code/ecflrestart.c</p><p>图8-44 当用户键入 Ctrl+ C 时， 使 用 非本地跳转来重启 动它自身的 程序</p><p>豆日C++ 和 J a va 中的软件异常</p><p>C++ 和 J ava 提供的异常机制是较 高层次的 ， 是 C 语言的 s e t j mp 和 l o n g j mp 函数的更加结构化的版本。你可以把 t r y 语句中 的 c a t c h 子句 看做 类似于 s e 七 j mp 函数。相似地， t hr o w 语句就 类似于 l o n g j mp 函数。</p><p>8. 7 操作进程的工具</p><p>Lin u x 系统提供了大量的监 控和操作进程的有用 工具。</p><p>ST RACE : 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这 是一个令人着迷的 工具。用- s t a t i c 编译你的 程序， 能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。</p><p>PS: 列出当前 系统中的进程（包括僵死进程）。</p><p>T OP: 打印出关于当前进程资源使用的信息。</p><p>PMAP: 显示进程的内存映射。</p><p>/ pr o c : 一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容， 用户程序可以读取这些内容。比如， 输入 " c a t / p r o c / l o a d a v g&rdquo; , 可以看到你的 Lin u x 系统上当前的平均负载。</p><p>8. 8 小结</p><p>异常控制流 ( ECF) 发生在计算机系统的各个层次 ， 是计算机系统中 提供并发的 基本机 制。</p><p>在硬件层 ， 异常是由处理器中的 事件触发的 控制流中的 突变。控制流传 递给一 个软件处理程序，该处理程序进行一些处理 ， 然后 返回控制给被中断的 控制流。</p><p>有四种不同类 型的异常 ： 中断、故障、终止和陷阱 。当一个外部 1/0 设备（例如定时器芯片或者磁盘</p><p>控制器）设置了处理 器芯片上的中断管脚时 ，（对于任意指令）中断会异步地发生。控制返回到故障指令后面的那条指令。一条指令的 执行可能导致 故障 和终止同步发生。故障处理程序会重新启动故障指 令， 而终止处理程序从 不将控制返回 给被中断的 流。最后 ， 陷阱就像是用来实现向应用 提供到操作系统代码的受控的入口点的系统调用的函数调用。</p><p>在操作 系统层，内 核用 ECF 提供进程的 基本概念。进程提供给应 用两个重要的抽象： 1) 逻辑控制 流，它 提供给每个程序一个假象 ， 好像它是 在独占 地使用处理器， 2 ) 私有地 址空间 ， 它提供 给每个程序一个假象，好像它是在独占地使用主存。</p><p>在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止， 运行新的 程序 ， 以及捕获来 自其他进 程的信号。信号处理的语义是微妙的， 并且随系统不同而不同。然而， 在与 Pos ix 兼容的系统 上存在着一些机制 ，允 许程序清楚 地指定期望的信号处理语义。</p><p>最后， 在应用层， C 程序可以 使用非本 地跳转来 规避正常的调用／返回栈规则 ， 并且直接从 一个函数分支到另一个函数．</p><h3 id=参考文献说明>参考文献说明
<a class=anchor href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae%e8%af%b4%e6%98%8e>#</a></h3><p>Ke r risk 是 Linux 环境编程的 完全参考手册 [ 62] 。Intel ISA 规范包含对 Intel 处理器上的异常和中断的详 细讨论 [ 50] 。操作系统教科书 [ 102. 106, 113] 包括关于异 常、进 程和信号的其他信息。W. Richard St evens 的[ 111 ] 是一本有价值的和可读性很高的 经典著作， 是关于如何 在应用程序中处 理进程和信号的。Bovet 和 Cesati[ 11] 给出了一个关千 Linux 内核的非常清晰的描述， 包括进程和信号实现的 细节。</p><h3 id=家庭作业>家庭作业
<a class=anchor href=#%e5%ae%b6%e5%ba%ad%e4%bd%9c%e4%b8%9a>#</a></h3><ul><li>8. 9 考虑四个具有 如下开始和结束时间的进程 ：</li></ul><table><thead><tr><th>进程</th><th>开始时间</th><th>结束时间</th></tr></thead><tbody><tr><td>A</td><td>5</td><td>7</td></tr><tr><td>B</td><td>2</td><td>4</td></tr><tr><td>C</td><td>3</td><td>6</td></tr><tr><td>D</td><td>I</td><td>8</td></tr></tbody></table><p>对于每对进程，指明它们是否是并发地运行的：</p><ul><li><p>8. 10 在这一章里 ， 我们介绍 了一些具有不寻常的调用和返回行为的 函数： s e t j mp 、 l ong j mp 、 e xe c ve</p><p>和 f or k。找到下列行为中和每个函数相匹 配的一种 ：</p><ol><li>调用一次， 返回两次。<ol><li><p>调用一次，从不返回。</p><p>c. 调用一次，返回一次或者多次。</p></li></ol></li></ol></li><li><p>8. 11 这个程序会输出多 少个 " hello" 输出行？</p></li></ul><p>妇 ncl ude &ldquo;csapp.h&rdquo;</p><p>2</p><p>codelecf/forkprobl.c</p><p>3 int main()</p><p>4 {</p><p>5 inti;</p><p>6</p><p>7 for(i = 0; i &lt; 2; i ++)</p><p>8 Fork();</p><p>9 printf(&ldquo;hello\n&rdquo;);</p><p>10 exit(O);</p><p>11 ｝</p><p>codelecf/forkprobl.c</p><ul><li>8. 12 这个程序会输出多 少个 " hello" 输出行？</li></ul><p>#include &ldquo;csapp.h&rdquo;</p><p>3 void doit 0</p><p>4 {</p><p>5 Fork();</p><p>6 Fork(); printf(&ldquo;hello\n&rdquo;);</p><p>8 return·，</p><p>9 }</p><p>10</p><p>11 int main()</p><p>12 {</p><p>13 doit();</p><p>14 printf (&ldquo;hello\n&rdquo;) ;</p><p>15 exit(O);</p><p>16 }</p><p>code/ecflforkprob4.c</p><p>code/ecflforkprob4.c</p><ul><li>8. 13 下面程序的 一种可能的输出是 什么？</li></ul><p>扣 ncl ude &ldquo;cs app . h&rdquo;</p><p>codelecf/forkprob3.c</p><p>int main()</p><p><img src=img/ba97fc1d28c09500a370b749c1b85b9b.jpeg alt></p><table><thead><tr><th>4</th><th>{</th><th></th><th></th></tr></thead><tbody><tr><td>5</td><td></td><td>int</td><td>X = 3;</td></tr><tr><td>6</td><td></td><td></td><td></td></tr><tr><td>7</td><td></td><td>if</td><td>(Fork() != 0)</td></tr><tr><td>8</td><td></td><td></td><td>printf(&ldquo;x=%d\n&rdquo;, ++x);</td></tr><tr><td>9</td><td></td><td></td><td></td></tr></tbody></table><p>10 printf(&ldquo;x=%d\n&rdquo;, &ndash;x);</p><p>11 exit(O);</p><p>12 }</p><p>codelecflforkprob3.c</p><ul><li>8. 14 下 面这个程序会输出多 少个 " hello" 输出行？</li></ul><p>1 #include &ldquo;csapp.h&rdquo;</p><p>2</p><p>3 void doitO</p><p>4 {</p><p>5 if (Fork() == 0) {</p><ol><li><p>Fork();</p></li><li><p>printf(&ldquo;hello\n&rdquo;);</p></li><li><p>exit(O);</p><p>9 }</p><p>10 return; 11 }</p><p>12</p><p>13 int main()</p><p>14 {</p><p>1s doitO;</p></li><li><p>printf(&ldquo;hello\n&rdquo;);</p></li><li><p>exit(O);</p><p>18 }</p></li></ol><p>codelecflforkprob5.c</p><p>codelecflforkprob5.c</p><ul><li>8. 15 下面这个程序会 输出多 少个 " hello" 输出行？</li></ul><p>#include &ldquo;csapp.h&rdquo;</p><p>2</p><p>3 void doit ()</p><p>4 {</p><p>s if (Fork() == 0) {</p><ol><li><p>Fork();</p></li><li><p>printf (&ldquo;hello\n&rdquo;);</p><p>s return·，</p><p>9 }</p><p>10 return; 11 }</p><p>12</p><p>13 int main()</p><p>14 {</p><p>1s doitO;</p></li><li><p>printf(&ldquo;hello\n&rdquo;);</p></li><li><p>exit(O);</p><p>18 }</p></li></ol><p>codelecflforkprob6.c</p><p>codelecf/forkprob6.c</p><ul><li>8. 16 下面这个程序的输出是什么？</li></ul><p>codelecf/forkprob7.c</p><p>#include &ldquo;csapp. h&rdquo; int counter= 1;</p><p>int main()</p><p>｛</p><p>辽 (for k () == 0) { counter&ndash;; exit(O);</p><p>｝</p><p>else {</p><p>Wait(NULL);</p><p>printf(&ldquo;counter = o/,d\n&rdquo;, ++counter);</p><p>｝</p><p>exit(O);</p><p>｝</p><p>code/ecf/forkprob7.c</p><p>列举练习题 8. 4 中程序所有可能的 输出。考虑下面的程序：</p><p>#include &ldquo;csapp.h&rdquo; void end(void)</p><p>｛</p><p>code/ecflforkprob2.c</p><p>printf(&ldquo;2&rdquo;); fflush(stdout);</p><p>｝</p><p>int main()</p><p>｛</p><p>if (Fork() == 0) atexit(end);</p><p>if (Fork() == 0) {</p><p>printf(&ldquo;O&rdquo;); fflush(stdout);</p><p>｝</p><p>else {</p><p>printf(&ldquo;1&rdquo;); fflush(stdout);</p><p>｝</p><p>exit(O);</p><p>｝</p><p>code/ecflforkprob2.c</p><p>判断下面哪个输出是 可能的 。注意： a t e x 江 函数以一个指向函数的指针为输入 ， 并将它添加到函数列 表中（初始为空）， 当 e x 江 函数被调用时 ， 会调用该列 表中的函数。</p><p>•• 8. 19</p><p>A. 112002 B. 211020 C. 102120 D. 122001</p><p>下面的函数会打印多 少行输出？ 用一个 n 的函数给出答 案。假设 n l 。</p><p>code/ecflforkprob8.c</p><p>E . 100212</p><p>void foo(int n)</p><p>｛</p><p>inti;</p><p>for(i = 0; i &lt; n; i ++)</p><p>Fork(); printf(&ldquo;hello\n&rdquo;); exit(O);</p><p>code/ecflrfkoprob8.c</p><p>** 8. 20</p><p>使用 e xe c ve 编写一个叫做 myl s 的 程 序 ，该 程序的行为和 / bi n / l s 程序的一样。你的程序应该接受相同的命令行参数 ， 解释同样的环境变量，并 产 生 相 同 的 输 出 。</p><p>l s 程 序从 CO L U M NS 环境变扯中获得屏幕的宽度。如果没有设 置 CO L U MNS , 那么 l s 会假设 屏幕宽 80 列。因此，你 可以 通过把 CO LU M NS 环境设置得小于 80 , 来检查你对环境变址的处理：</p><p>linux> setenv COLUMNS 40 linux> ./ myls</p><p>II Output is 40 columns wide</p><p>linux> unsetenv COLUMNS linux> ./ myls</p><p>II Output is now 80 columns wide</p><p>** 8. 21</p><p>下面的程序可能的输出序列是什么？</p><p>int main()</p><p>｛</p><p>codelecflwaitprob3.c</p><p>if (fork() == 0) {</p><p>printf(&ldquo;a&rdquo;); fflush(stdout); exit (O) ;</p><p>｝</p><p>else {</p><p>pri ntf (&ldquo;b&rdquo;) ; fflush(stdout); waitpid(-1, NULL, 0);</p><p>｝</p><p>printf(&ldquo;c&rdquo;); fflush(stdout); exit(O);</p><p>*＊* 8. 22</p><p>编写 U nixs ys t e m 函 数的你自己的版本</p><p>立 t mysystem(char *command);</p><p>code/ecwfa/itprob3 .c</p><p>•• 8. 23</p><p>mys ys t e m 函 数 通过调用 " / b i n / s h - c c omma nd " 来 执 行 c omma nd , 然 后 在 c omma nd 完成后返回。如果 c omma nd ( 通过 调用 e xi t 函数 或 者 执 行一 条r e t u r n 语 句）正常 退出， 那 么 mys ys t e m 返回 c omma nd 退出状态。例如， 如 果 c o mma nd 通过调用 e xi t (8 ) 终 止，那 么 mys ys t e m 返回值 8。否则，如 果 c o mma nd 是 异常终止的，那 么 mys y s t e m 就 返 回 s he ll 返回的状态。</p><p>你的一个同事想要使用信号来让一个父进程对发生在子进程中的事件计数。其想法是每次发生一 个事件时，通过向父进程发送一个信号来通知它，并且让父进程的信号处理程序对一个全局变量 coun t e r 加一， 在子进程终止之后， 父进程就可以检查这个变量。然而， 当他在系统上运行图 8-</p><p>45 中的测试程序时，发 现 当父进程调用 pr i n t f 时， c o unt er 的值总是 2 , 即使子进程向父进程发</p><p>送了 5 个信号也是如此。他很困惑，向 你 寻 求 帮助。你能解释这个程序有什么错误吗？</p><p>codelecf/counterprob.c</p><p>#include &ldquo;csapp.h&rdquo; int counter= O;</p><p>void handler(int sig)</p><p>｛</p><p>counter++;</p><p>sleep(1); I* Do some work in the handler *I return;</p><p>图8-&lsquo;15 家庭作业 8. 23 中引用的计数器程序</p><p>10 }</p><p>11</p><p>12 int main()</p><p>13 {</p><p>14 int i;</p><p>15</p><p>16 Signal(SIGUSR2, handler); 17</p><p>18 if (Fork() == 0) { I* Child *I 19 for (i = O; i &lt; 5; i++) {</p><ol><li><p>Kill(getppid () , SIGUSR2) ;</p></li><li><p>printf(&ldquo;sent SIGUSR2 to parent \n&rdquo;) ; 22 }</p><p>23 exit(O);</p><p>24 }</p><p>25</p></li><li><p>Wait (NULL) ;</p></li><li><p>printf(&ldquo;counter=%d\n&rdquo;, counter);</p></li><li><p>exit(O); 29 }</p><p>codelecf/counterprob.c</p></li></ol><p>图 8-45 (续）</p><p>\* 8. 24 修改图 8-18 中的程序，以 满足下 面两个条件：</p><ol><li><p>每个子进程在试图写一个只读文本段中的位置时会异常终止。</p></li><li><p>父进 程打印和下 面所示相同（除了 PID) 的输出：</p><p>child 12255 terminated by signal 11: Segmentation fault child 12254 terminated by signal 11: Segmentation fault</p></li></ol><p>提示：请 参 考 ps i g na l (3 )的 ma n 页。</p><p>*/ 8 . 25 编写 f ge t s 函 数 的 一 个 版本， 叫做 t f ge t s , 它 5 秒钟后会超时。t f ge t s 函数接收和 f ge t s 相同的输入。如果用户在 5 秒内不键人一个输入行， t f ge t s 返回 NU LL。否则， 它 返 回一 个 指向 输 入</p><p>．行的指针。</p><p>:： 8 . 26 以图 8-23 中的示例作为开始点，编 写一个 支持作业控制的 s hell 程序。s hell 必须具有以下特性：</p><ul><li>用 户输 入的命令行由一个 na me 、 零 个 或 者 多 个 参 数 组成，它 们 都 由 一 个 或 者 多 个 空 格分隔开。如果 na me 是 一 个 内 置 命 令 ，那 么 s hell 就 立即处理它，并 等 待 下 一 个 命 令 行 。 否 则 ， s hell 就 假设 na me 是 一 个 可执行文件， 在一个初始的子进程（作业）的上下文中加载并运行它。作业的进程组 ID 与子进程的 P ID 相同。</li><li>每个作业是由一个进程 IDCPID ) 或 者一个作业 ID(J ID) 来标识的，它 是 由 一 个 she ll 分配的任意的小正整数。J ID 在命令行上用前缀 " %" 来表示。比如， " %5" 表示 J ID 5, 而 " s" 表示 PID 5。</li><li>如果 命令行以 ＆来结 束 ， 那么 shell 就在后台运行这个作业。否则， she ll 就在前台运行这个作业。</li><li>输入 Ctr l+ C( Ctrl+ Z) , 使得内核发送一个 S IGI NT ( SIGT ST P ) 信号给 s hell , s hell 再转发给前台进程组中的每个进程e</li><li>内置命令 j ob s 列出所有的后台作业。</li><li>内置命令 bg j ob 通过发送一个 S IGCO NT 信号重启 j ob, 然后在后台运行它。j ob 参数可以是一个 PID , 也可以是一个 JID。</li><li>内置命令 f g J动 通过发送一个 SIGCO NT 信号重启 j ob, 然后在前台运行它。</li></ul><p>9 注意这是对真实的 shell 工作方式的简化。真实的shell 里， 内核响应Ct rl + C( Ctr!+ Z), 把 SIGINT ( SIGT ­</p><p>STP) 直接发送给终端前台进程组中的 每个进程。shell 用 t c s e t pgr p 函数管理这个 进程组的成员 ，用 t c­ se t a t t r 函数管 理 终 端 的 属 性 ，这 两个函数都超出了本书讲述的范围。可以参考[ 62] 获 得 详 细信息。</p><ul><li><p>shell 回收它所有的僵死子进程。如果 任何作业 因为收到一个未捕获的信号而终止 ， 那么 s hell 就输出一条 消息到终端， 消息中包含该作业的 PID 和对该信号的描述。</p><p>图 8- 46 展示了一个 s hell 会话示例。</p></li></ul><p>linux> ./shell</p><p>>bogus</p><p>bogus: Command not found.</p><p>>foo 10</p><p>Run your shell program Execve can &rsquo; t find executable</p><p>Job 5035 terminated by signal: Interrupt User types Crt l +C</p><p>>foo 100 &</p><p>[1] 5036 foo 100 &</p><p>>foo 200 &</p><p>[2] 5037 foo 200 &</p><p>>jobs</p><ol><li><p>5036 Running foo 100 &</p></li><li><p>5037 Running foo 200 &</p><p>>fg %1</p><p>Job [1] 5036 stopped by signal: Stopped User types Ctrl +Z</p><p>>jobs</p></li><li><p>5036 Stopped foo 100 &</p></li><li><p>5037 Running foo 200 &</p><p>>bg 5035</p><p>5035: No such process</p><p>>bg 5036</p><p>[1] 5036 foo 100 &</p><p>>/bin/kill 5036</p><p>Job 5036 terminated by si gnal : Terminated</p><p>> fg %2 Wait for fg job to finish</p><p>>quit</p><p>linux> Back to the Uni x shell</p><p>图 8- 46 家庭作业 8. 26 的 s hell 会话示例</p></li></ol><p>练习题答案</p><p>8. 1 进程 A 和 B 是互相并发的， 就像 B 和 C 一样， 因为它们各自的执行是重叠的， 也就是一个进程在另一个进程结 束前开始 。进程 A 和 C 不是并发的 ， 因为它们的执行没有 重叠； A 在 C 开始之前就结束了。</p><ol><li><p>. 2 在图 8- 1 5 的示例程序中 ，父子进程 执行无关的指令集合。然而， 在这个程序中， 父子进程执行 的</p><p>指令集合是相关的，这是有可能的，因为父子进程有相同的代码段。这会是一个概念上的啼碍，所 以请确认你理解了本题的答 案。图 8- 47 给出了进 程图。</p><ol><li>这里的关键点是子进程执行 了两个 pr i nt f 语句。在 f or k 返回之后， 它执行第 6 行的 p r i nt f。然后它从 辽 语句中出来， 执行第 7 行的 pr i n t f 语句。下面是子进程产生 的输出：</li></ol></li><li><p>父进程只执行 第 7 行的 p r i n t f : p2: x=O</p></li></ol><p>Pl，: .x =2 P2•: • x=l</p><p>pr i n 七 f printf exit</p><p>x==l I P2: x=O</p><p>main f or k pr i n七 f exit</p><p>图 8-4 7 练习题 8. 2 的进程图</p><p>子进程父进程</p><p>8 3 我们知道序列 ache、a bcc 和 bacc 是可能的， 因为它们对应有进程图的拓扑排序（图8-48 ) 。而像</p><p>bcac 和 c bca 这样的 序列不对应有任何拓扑排序， 因此它们是不可行的。</p><h1 id=heading>．
<a class=anchor href=#heading>#</a></h1><p>ma i n</p><p>a</p><p>pr i n t f b</p><p>p r＂i n t f</p><p>C</p><p>p＂r i n 七 f</p><p>C</p><p>p r i n t f</p><p>e x i t</p><p>图 8 - 48</p><p>练习题 8. 3 的进程图 －</p><p>8. 4</p><ol><li><p>只简单地计算进程图（图8 - 4 9 ) 中 pr i n t f 顶点的个数就能确 定输出行数。在这里， 有 6 个这样的顶点， 因此程序会打印 6 行输出。</p></li><li><p>任何对应有进程图的拓扑排序的 输出序列都是可能的 。例如： He l l o 、 1 、 0 、 Bye 、 2、Bye 是可</p><p>能的。</p></li></ol><h1 id=heading-1>．
<a class=anchor href=#heading-1>#</a></h1><p>ma i n</p><p>He..l.l o p r i n t f</p><p>1</p><p>pr 一i 。n t f pr i n t f</p><p>Bye</p><p>pr i n t f</p><p>二wa 让 p i d pr i n 七f</p><p>B,y.e printf</p><p>e x i t</p><p>图 8 - 49</p><p>练习 题 8. 4 的进程图</p><p>8 5</p><p>un s i gn ed int snooze(unsigned int secs ) { unsigned int re= sl eep(secs ) ;</p><p>code/ecflsnoo ze.c</p><p>printf(&ldquo;Slept for %d of %d s e c s . \ n " , secs-re, secs) ; return re;</p><p>8. 6</p><p>#incl ude &ldquo;csapp.h&rdquo;</p><p>i nt ma i n ( i nt ar g c , c har *argv[], char *envp[])</p><p>｛</p><p>codelecfs/nooze.c codelecfm/yecho.c</p><p>i nt i ;</p><p>pr i nt f (&ldquo;Comman d - l i n e ar gument s : \ n " ) ; for ( i =O; ar gv [ i ] ! = NULL ; i ++)</p><p>printf (&rdquo; argv[o/.2d] : %s \n&rdquo; , i , ar g v [i]) ;</p><p>printf ("\n");</p><p>printf (&ldquo;Envir onme nt var i a bl e s : \ n " ) ; for ( i =O; envp[i] != NULL ; i ++)</p><p>printf (&rdquo; envp[%2d] : %s \n" , i, envp[i]) ; exit (O) ;</p><p>8. 7</p><p>co d ele cf/ my ec ho .c</p><p>只 要休眠进程收到一个未被忽略的信号， s l e e p 函数就会提前返回。但是 ， 因为收到一个 SIGINT 信号的默认行为就是终止进程（图 8- 26 ) , 我们必须设置一个 SIGINT 处理程序来允许 s l e e p 函数返回。处理程序简单地捕获 SIGNA L, 并将控制返回给 s l e e p 函数， 该 函数会立即返回。</p><p>code/ecflsnooze.c</p><p>#i ncl ude " cs app . h"</p><p>3 /• SIGINT handler•/</p><p>4 void handler (int sig)</p><p>5 {</p><p>6 return; /• Catch the signal and return•I</p><p>7 }</p><p>8</p><p>9 unsigned int snooze(unsigned int secs) {</p><p>10 unsigned int re= sleep(secs);</p><p>11</p><p>12 printf(&ldquo;Slept for %d of %d s e cs . \ n " , secs-re, secs);</p><p>13 return re;</p><p>14 }</p><p>15</p><p>16 int main(int argc, char **argv) {</p><p>17</p><ol><li><p>if (argc != 2) {</p></li><li><p>fprintf(stderr, &ldquo;usage: %s &lt;secs>\n&rdquo;, argv[O]);</p><p>20 exit(O);</p><p>21 }</p><p>22</p></li><li><p>if (signal(SIGINT, handler) == SIG_ERR) I• Install SIGINT•I</p></li><li><p>unix_error(&ldquo;signal error\n&rdquo;); /• handler•/</p></li><li><p>(void)snooze(atoi(argv[l]));</p></li><li><p>exit(O);</p><p>27 }</p><p>code/ecf/snooze.c</p></li></ol><p>8. 8 这个 程序打印 字符串 " 213&rdquo; , 这是卡内 基－梅隆大学 CS: APP 课程的缩写名。父进程开始时 打印</p><p>&ldquo;2&rdquo;, 然后创 建子进程 ， 子进程会陷入一 个无限循环。然 后父进程向 子进程发送 一个信号， 并等待它终止。子进程捕获这个信 号（中断这个无限循环）， 对计数器值（从初始值 2) 减一， 打印 &ldquo;1&rdquo;&rsquo; 然后终止。在父进程回收子进程之后 ， 它对计数器值（从初始值 2) 加一， 打印 " 3" , 并且终止。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#img1620c4a88871dd25f3cb5ce4b5b4d28djpegi><img src=img/1620c4a88871dd25f3cb5ce4b5b4d28d.jpeg alt>i</a><ul><li><a href=#参考文献说明>参考文献说明</a></li><li><a href=#家庭作业>家庭作业</a></li></ul></li></ul></li><li><a href=#heading>．</a></li><li><a href=#heading-1>．</a></li></ul></nav></div></aside></main></body></html>