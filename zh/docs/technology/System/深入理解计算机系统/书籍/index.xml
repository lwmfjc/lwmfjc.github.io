<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>随记</title><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/</link><description>Recent content on 随记</description><generator>Hugo</generator><language>zh</language><atom:link href="https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E5%B0%81%E9%9D%A2-%E7%9B%AE%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E5%B0%81%E9%9D%A2-%E7%9B%AE%E5%BD%95/</guid><description>&lt;p>&lt;img src="img/84a99ff609e9a3e1c3bea19467abeaed.jpeg" alt="" />&lt;/p>
&lt;p>｀．&lt;/p>
&lt;p>&lt;img src="img/262318a5c6fc43bf03c45143e4e828a3.jpeg" alt="" />&lt;/p>
&lt;p>兰镶尔 E. 布莱恩特&lt;/p>
&lt;p>(Randal E. Bryant)&lt;/p>
&lt;p>1981 年千麻省理工学院获得计算机博士学位 ，&lt;/p>
&lt;p>1984 年至今一直任教 千卡内基－梅隆大学。现任卡内基－梅隆大学计算机科学学院院长、教授，同时还受邀任教 千电子和计算机工程 系。他从事本科生和研究生计算机 系统方面课程的教学近 40 年。他和&lt;/p>
&lt;p>O&amp;rsquo;Hallaron 教授一起在卡内基－梅隆大学开设了15-&lt;/p>
&lt;p>213课程 ”计算机系统导论” ， 该课程即为本书的基础。他还是ACM院士、IEEE院士、美国国家工程院院士和美国 人文与科学研究院院 士。其研究成果被&lt;/p>
&lt;p>Intel 、IBM、Fujitsu 和Microsoft 等主要计算机制造商使用， 他还因研究获得过Semiconductor Research Corporation、ACM、IEEE颁发的多项大奖。&lt;/p>
&lt;p>&lt;img src="img/99e8488313965d2fbd0c5c8526568c26.jpeg" alt="" />&lt;/p>
&lt;p>大卫 R. 奥哈拉伦&lt;/p>
&lt;p>(David R. O&amp;rsquo;Hallaron)&lt;/p>
&lt;p>卡内基－梅隆大学电子和计算 机工程系教授 。在弗吉尼亚大学获得计算机科学的博士学位 ， 2007 年一2010 年为Intel 匹兹堡实验室主任。他教授本科生和研究生的计算机 系统方面的课程已有 20余年， 井和Bryant 教授一起开设了 ”计算机系统导论 ” 课程。曾获得CMU计算机学院颁发的Herbert Simon杰出教学奖。他主要从事计算机系统领域的研究 ， 与&lt;/p>
&lt;p>Quake项目成员一起获得过高性能计算领域中的最高 国际奖项—-G ordon Bell奖。他目前的工作重点是研究自动分级 ( autograding ) 概念， 即评价其他程序质量的程序。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC10%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7I_O/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC10%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7I_O/</guid><description>&lt;p>第 10 章&lt;/p>
&lt;p>C H A P T E R 10&lt;/p>
&lt;p>系统级 1 /0&lt;/p>
&lt;h3 id="输入扴出10-是在主存和外部设备例如磁盘驱动器终端和网络之间复制数据的过程输入操作是从-i-0-设备复制数据到主存-而输出操作是从主存复制数据到10-设备">输入／扴出(1/0 )是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。输入操作是从 I/ 0 设备复制数据到主存， 而输出操作是从主存复制数据到1/0 设备。&lt;a class="anchor" href="#%e8%be%93%e5%85%a5%e6%89%b4%e5%87%ba10-%e6%98%af%e5%9c%a8%e4%b8%bb%e5%ad%98%e5%92%8c%e5%a4%96%e9%83%a8%e8%ae%be%e5%a4%87%e4%be%8b%e5%a6%82%e7%a3%81%e7%9b%98%e9%a9%b1%e5%8a%a8%e5%99%a8%e7%bb%88%e7%ab%af%e5%92%8c%e7%bd%91%e7%bb%9c%e4%b9%8b%e9%97%b4%e5%a4%8d%e5%88%b6%e6%95%b0%e6%8d%ae%e7%9a%84%e8%bf%87%e7%a8%8b%e8%be%93%e5%85%a5%e6%93%8d%e4%bd%9c%e6%98%af%e4%bb%8e-i-0-%e8%ae%be%e5%a4%87%e5%a4%8d%e5%88%b6%e6%95%b0%e6%8d%ae%e5%88%b0%e4%b8%bb%e5%ad%98-%e8%80%8c%e8%be%93%e5%87%ba%e6%93%8d%e4%bd%9c%e6%98%af%e4%bb%8e%e4%b8%bb%e5%ad%98%e5%a4%8d%e5%88%b6%e6%95%b0%e6%8d%ae%e5%88%b010-%e8%ae%be%e5%a4%87">#&lt;/a>&lt;/h3>
&lt;p>所有语言的运行时系统都 提供执行 1/ 0 的较高级别的工具。例如， ANSI C 提供标准1/ 0 库， 包含像 pr i n t f 和 s c a n f 这样执行带 缓冲区的 I/ 0 函数。C++ 语言用它的重载操作符＜＜（输入）和＞＞（输出）提供了类似的功能 。在 Lin ux 系统中， 是通过使用由内核提供的系统级 U nix I/ 0 函数来实现这些较高级别的 I/ 0 函数的。大多数时候，高 级别 1/ 0 函数工作良好， 没有必要直接使用 U nix I/ 0 。那么为什么还要麻烦地学习 U nix 1/ 0 呢？&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC11%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC11%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid><description>&lt;p>第 1 1 章&lt;/p>
&lt;h4 id="c-h-a-p-t-e-r-11">C H A P T E R 11&lt;a class="anchor" href="#c-h-a-p-t-e-r-11">#&lt;/a>&lt;/h4>
&lt;p>网络编程&lt;/p>
&lt;h3 id="网络应用随处可见任何时候浏览-w-eb-发送-ema-il-信息或是玩在线游戏-你就正在使用网络应用程序有趣的-是-所有的网络应用都是基千相同的基本编程模型-有着相似的整体逻辑结构并且依赖相同的编程接口">网络应用随处可见。任何时候浏览 W eb 、发送 ema il 信息或是玩在线游戏， 你就正在使用网络应用程序。有趣的 是， 所有的网络应用都是基千相同的基本编程模型， 有着相似的整体逻辑结构，并且依赖相同的编程接口。&lt;a class="anchor" href="#%e7%bd%91%e7%bb%9c%e5%ba%94%e7%94%a8%e9%9a%8f%e5%a4%84%e5%8f%af%e8%a7%81%e4%bb%bb%e4%bd%95%e6%97%b6%e5%80%99%e6%b5%8f%e8%a7%88-w-eb-%e5%8f%91%e9%80%81-ema-il-%e4%bf%a1%e6%81%af%e6%88%96%e6%98%af%e7%8e%a9%e5%9c%a8%e7%ba%bf%e6%b8%b8%e6%88%8f-%e4%bd%a0%e5%b0%b1%e6%ad%a3%e5%9c%a8%e4%bd%bf%e7%94%a8%e7%bd%91%e7%bb%9c%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e6%9c%89%e8%b6%a3%e7%9a%84-%e6%98%af-%e6%89%80%e6%9c%89%e7%9a%84%e7%bd%91%e7%bb%9c%e5%ba%94%e7%94%a8%e9%83%bd%e6%98%af%e5%9f%ba%e5%8d%83%e7%9b%b8%e5%90%8c%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%9e%8b-%e6%9c%89%e7%9d%80%e7%9b%b8%e4%bc%bc%e7%9a%84%e6%95%b4%e4%bd%93%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84%e5%b9%b6%e4%b8%94%e4%be%9d%e8%b5%96%e7%9b%b8%e5%90%8c%e7%9a%84%e7%bc%96%e7%a8%8b%e6%8e%a5%e5%8f%a3">#&lt;/a>&lt;/h3>
&lt;p>网络应用依 赖于很多在系统 研究中巳经学习过的概念。例如， 进程、信号、字节顺序、内存映射以及动态内存 分配， 都扮演着 重要的角色。还有一些新概念要掌握。我们需要理解基本的客户端－服务器编程模型 ， 以及如何编写使 用因特网提供的服务的客户端－服务器程序。最后 ， 我们将把所有这些概念结合起来， 开发一个虽小但功能齐全的 Web 服务器 ， 能够为真实的 Web 浏览器提供静态和动态的 文本和图形内容。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>1 客户端－服务器编程模型&lt;/p>
&lt;p>每个网络应用都是基千客户端－服务器模型的。采用这个模型，一个应用是由一个服 务器进 程和一个或者多个客户端 进程组 成。服务器管理某种资源， 并且通过操作这种资濒来为它的客户端提供某种服务。例如， 一个 Web 服务器管理着一组磁盘文件， 它会代表客户端进行检索和执行。一个 FT P 服务器管理着一组磁盘文件，它 会为客户端进行存储和检索。相似地 ， 一个电子邮件服务器管理着一些文件，它 为客户端进行读和更新。&lt;/p>
&lt;p>客户端－服务器模 型中的基本操作是 事务 ( t ra nsaction )( 见图 11-1) 。一个客户端－服务器事务由以下四步组成。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC12%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC12%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid><description>&lt;p>第 12 章&lt;/p>
&lt;p>C H A P T E R 12 . . . _&lt;/p>
&lt;p>并发编程&lt;/p>
&lt;p>正如我们在第 8 章学到的 ， 如果逻辑控制流在时间上重叠， 那么它们就是并发的 ( concu rr e nt ) 。这种常见的现象称为并发 ( co nc urr e ncy ) , 出现在计算机系统的许多不同层面上。硬件 异常处理程序、进程和 L in ux 信号处理程序都是 大家很熟悉的例子。&lt;/p>
&lt;p>到目前为止，我们主要将并发看做是一种操作系统内核用来运行多个应用程序的机 制。但是， 并发不仅仅局限 于内核。它也可以在应用程序中 扮演重要角色。例如，我 们已经看到 Linux 信号处理程序如何允许应用响应异步事件， 例如用户键入 C t rl + C , 或者程序访问虚拟内存的 一个未定义的区域。应用级并发在其他情况下 也是很有用的：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>访问慢速 1/0 设备。当一个应用正在等待来自慢速 1/ 0 设备（例如磁盘）的数据到达时，内 核会运行其他进程，使 CP U 保持繁忙。每个应用都可以按照类似的方式， 通过交替 执行 I/ 0 请求和其他有用的工作来利用并发。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</guid><description>&lt;p>第1章&lt;/p>
&lt;p>CHAPTER1&lt;/p>
&lt;p>计算机系统漫游&lt;/p>
&lt;p>计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有相似的硬件和软件组件，它们又执行着相似的功能。一些程序员希望深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的，以此来提高自身的技能。本书便是为这些读者而写的。&lt;/p>
&lt;p>现在就要开始一次有趣的漫游历程了。如果你全力投身学习本书中的概念，完全理解底层计算机系统以及它对应用程序的影响，那么你会步上成为为数不多的“大牛＂的道路。&lt;/p>
&lt;p>你将会学习一些实践技巧，比如如何避免由计算机表示数字的方式引起的奇怪的数字错误。你将学会怎样通过一些小窍门来优化自己的C代码，以充分利用现代处理器和存储器系统的设计。你将了解编译器是如何实现过程调用的，以及如何利用这些知识来避免缓冲区溢出错误带来的安全漏洞，这些弱点给网络和因特网软件带来了巨大的麻烦。你将学会如何识别和避免链接时那些令人讨厌的错误，它们困扰着普通的程序员。你将学会如何编写自己的Unixshell、自己的动态存储分配包，甚至于自己的Web服务器。你会认识并发带来的希望和陷阱，这个主题随着单个芯片上集成了多个处理器核变得越来越重要。&lt;/p>
&lt;p>在Kernighan和Ritchie的关于C编程语言的经典教材[61]中，他们通过图1-1中所示的hello程序来向读者介绍C。尽管hello程序非常简单，但是为了让它实现运行，系统的每个主要组成部分都需要协调工作。从某种意义上来说，本书的目的就是要帮助你了解当你在系统上执行hello程序时，系统发生了什么以及为什么会这样。&lt;/p>
&lt;p>codelintrolhello.c&lt;/p>
&lt;p>#include &amp;lt;stdio.h&amp;gt;&lt;/p>
&lt;p>int main()&lt;/p>
&lt;p>｛&lt;/p>
&lt;p>printf(&amp;ldquo;hello, world\n&amp;rdquo;); return O;&lt;/p>
&lt;p>｝&lt;/p>
&lt;p>code/intro/he/lo .c&lt;/p>
&lt;p>图 1-1 he ll o 程序（来源： [60])&lt;/p>
&lt;p>我们通过跟踪hello程序的生命周期来开始对系统的学习——从它被程序员创建开始，到在系统上运行，输出简单的消息，然后终止。我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的关键概念、专业术语和组成部分。后面的章节将围绕这些内容展开。&lt;/p>
&lt;h1 id="11">1.1&lt;a class="anchor" href="#11">#&lt;/a>&lt;/h1>
&lt;h2 id="信息就是位上下文">信息就是位＋上下文&lt;a class="anchor" href="#%e4%bf%a1%e6%81%af%e5%b0%b1%e6%98%af%e4%bd%8d%e4%b8%8a%e4%b8%8b%e6%96%87">#&lt;/a>&lt;/h2>
&lt;p>hello程序的生命周期是从一个源程序（或者说源文件）开始的，即程序员通过编辑器创&lt;/p>
&lt;p>建并保存的文本文件，文件名是hello.c。源程序实际上就是一个由值0和1组成的位（又称为比特）序列，8个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。&lt;/p>
&lt;p>大部分的现代计算机系统都使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值e来表示每个字符。比如，图1-2中给出了hello.c程序的ASCII码表示。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>＃&lt;/th>
 &lt;th>i&lt;/th>
 &lt;th>n&lt;/th>
 &lt;th>C&lt;/th>
 &lt;th>1&lt;/th>
 &lt;th>u&lt;/th>
 &lt;th>d&lt;/th>
 &lt;th>e&lt;/th>
 &lt;th>SP&lt;/th>
 &lt;th>＜&lt;/th>
 &lt;th>s&lt;/th>
 &lt;th>t&lt;/th>
 &lt;th>d&lt;/th>
 &lt;th>i&lt;/th>
 &lt;th>。&lt;/th>
 &lt;th>&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>35&lt;/td>
 &lt;td>1 05&lt;/td>
 &lt;td>11 0&lt;/td>
 &lt;td>9 9&lt;/td>
 &lt;td>108&lt;/td>
 &lt;td>11 7&lt;/td>
 &lt;td>1 00&lt;/td>
 &lt;td>1 0 1&lt;/td>
 &lt;td>32&lt;/td>
 &lt;td>60&lt;/td>
 &lt;td>1 15&lt;/td>
 &lt;td>116&lt;/td>
 &lt;td>1 00&lt;/td>
 &lt;td>105&lt;/td>
 &lt;td>111&lt;/td>
 &lt;td>46&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>h&lt;/td>
 &lt;td>＞&lt;/td>
 &lt;td>\ n&lt;/td>
 &lt;td>\n&lt;/td>
 &lt;td>i&lt;/td>
 &lt;td>n&lt;/td>
 &lt;td>t&lt;/td>
 &lt;td>SP&lt;/td>
 &lt;td>m&lt;/td>
 &lt;td>a&lt;/td>
 &lt;td>i&lt;/td>
 &lt;td>n&lt;/td>
 &lt;td>（&lt;/td>
 &lt;td>）&lt;/td>
 &lt;td>\n&lt;/td>
 &lt;td>｛&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>10 4&lt;/td>
 &lt;td>62&lt;/td>
 &lt;td>10&lt;/td>
 &lt;td>1 0&lt;/td>
 &lt;td>105&lt;/td>
 &lt;td>11 0&lt;/td>
 &lt;td>116&lt;/td>
 &lt;td>32&lt;/td>
 &lt;td>109&lt;/td>
 &lt;td>97&lt;/td>
 &lt;td>105&lt;/td>
 &lt;td>110&lt;/td>
 &lt;td>40&lt;/td>
 &lt;td>41&lt;/td>
 &lt;td>10&lt;/td>
 &lt;td>123&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>\ n&lt;/td>
 &lt;td>SP&lt;/td>
 &lt;td>SP&lt;/td>
 &lt;td>SP&lt;/td>
 &lt;td>SP&lt;/td>
 &lt;td>p&lt;/td>
 &lt;td>r&lt;/td>
 &lt;td>i&lt;/td>
 &lt;td>n&lt;/td>
 &lt;td>t&lt;/td>
 &lt;td>f&lt;/td>
 &lt;td>（ II h e 1&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>1 0&lt;/td>
 &lt;td>32&lt;/td>
 &lt;td>32&lt;/td>
 &lt;td>3 2&lt;/td>
 &lt;td>3 2&lt;/td>
 &lt;td>112&lt;/td>
 &lt;td>114&lt;/td>
 &lt;td>105&lt;/td>
 &lt;td>110&lt;/td>
 &lt;td>116&lt;/td>
 &lt;td>10 2&lt;/td>
 &lt;td>40&lt;/td>
 &lt;td>34&lt;/td>
 &lt;td>104&lt;/td>
 &lt;td>101&lt;/td>
 &lt;td>108&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>1 。 SP ｀， 。 r 1 d ＼ n II ） \n SP&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC2%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC2%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</guid><description>&lt;p>第 2 章&lt;/p>
&lt;p>C H A P T E R 2&lt;/p>
&lt;p>信息的表示和处理&lt;/p>
&lt;p>现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称 为位( bit ) , 形成了数字革命的基础。大 家熟悉并使用了 10 00 多年的十进制（以10 为基数） 起源于印度， 在 12 世纪被阿拉伯数学家改进，并 在 13 世纪被意大利数学家 Leona rdo P isano ( 大约公元 11 70- 1250 , 更为大家所熟 知的名字是 Fibo nacci ) 带到西方。对 千有 10 个手指的人类来说，使用十进制表示法是很自然的事情，但是当构造存储和处理信息的机 器时，二进制值工作得更好。二值信号能够很容易地被表示、存储和传输，例如，可以表 示为穿孔卡片上有洞或无洞、导线上的高电压或低电压、或者顺时针或逆时针的磁场。对 二值信号进行存储和执行计算的电子电路非常简单和可靠，制造商能够在一个单独的硅片 上集成数百万甚至数十亿个这样的电路。&lt;/p>
&lt;p>孤立地讲， 单个的位不是非常有用。然而，当把位 组合在一起，再 加上某种解释( inter­ pretation) , 即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。比如， 使用一个二进制数字系统 ， 我们能 够用位组来编码非负数。通过使用标准的字符码， 我们能够对文档中的字母和符号进行编码。在本章中，我们将讨论这两种编码，以及负数 表示和实数近似值的编码。&lt;/p>
&lt;p>我们研究三种最重 要的数字表示。无符号 ( unsig ned ) 编码基千传统的 二进制表示法，&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</guid><description>&lt;p>第 3 章&lt;/p>
&lt;p>—- CH APTER 3&lt;/p>
&lt;h5 id="程序的机器级表示">程序的机器级表示&lt;a class="anchor" href="#%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%9c%ba%e5%99%a8%e7%ba%a7%e8%a1%a8%e7%a4%ba">#&lt;/a>&lt;/h5>
&lt;p>计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写 存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集 和操作系 统遵循的 惯例， 经过一系列的 阶段生成 机器代码 。GCC C 语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后&lt;/p>
&lt;p>GCC调用汇编 器和 链接器， 根据汇编代码生成可执行的机器代码。在本章中， 我们会近距离地观察机器代码，以及人类可读的表示 汇编代码。&lt;/p>
&lt;p>当我们用高级语言 编程的时候（例如C 语言， Java 语言更是如此）， 机器屏蔽了 程序的 细节，即机器级的实现。与此相反，当用汇编代码编程的时候（就像早期的计算），程序员必须 指定程序用来执行计算的低级指令。高级语言提供的抽象级别比较高，大多数时候，在这种 抽象级别上工作效率会更高，也更可靠。编译器提供的类型检查能帮助我们发现许多程序错 误，并能够保证按照一致的方式来引用和处理数据。通常情况下，使用现代的优化编译器产 生的代码至少与一个熟练的汇编语言程序员手工编写的代码一样有效。最大的优点是，用高级 语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关的。 那么为什么我们还要花时间学习机器代码呢？即使编译器承担了生成汇编代码的大部&lt;/p>
&lt;p>分工作，对千严谨的程序员来说，能够阅读和理解汇编代码仍是一项很重要的技能。以适 当的命令行选项调用编译器，编译器就会产生一个以汇编代码形式表示的输出文件。通过 阅读这些汇编代码，我们能够理解编译器的优化能力，并分析代码中隐含的低效率。就像 我们将在 第 5 章中体会到的那样， 试图最大化一 段关键代码性能的程序员 ， 通常会尝试源代码的各种形式，每次编译并检查产生的汇编代码，从而了解程序将要运行的效率如何。 此外，也有些时候，高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为。例 如，第 12 章会讲到，用线程包写并 发程序时 ，了 解不同的线程是如何共享程序数 据或保持数据私有的，以及准确知道如何在哪里访问共享数据，都是很重要的。这些信息在机器代码 级是可见的。另外再举一个例子，程序遭受攻击（使得恶意软件侵扰系统）的许多方式中，都涉及程序存储运行时控制信息的方式的细节。许多攻击利用了系统程序中的漏洞重写信息， 从而获得了系统的控制权。了解这些漏洞是如何出现的，以及如何防御它们，需要具备程序 机器级表示的知识。程序员学习汇编代码的需求随着时间的推移也发生了变化，开始时要求 程序员能直接用汇编语言编写程序，现在则要求他们能够阅读和理解编译器产生的代码。&lt;/p>
&lt;p>在本章 中， 我们 将详细学习一 种特别的 汇编语 言，了 解如何将 C 程序编译成这种形式的机器代码。阅读编译器产生的汇编代码，需要具备的技能不同千手工编写汇编代码。我 们必须 了解典型的编译器在将 C 程序结 构变换成 机器代码时所做的转换 。相对于 C 代码表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换 慢速操作，甚至将递归计算变换成迭代计算。源代码与对应的汇编代码的关系通常不太容易 理解一一－就像要拼出的 拼图与盒子上图 片的设 计有点不太一样。这是一种逆向 工程 ( reverse engineering ) — 通过研究 系统 和逆向工作， 来试图了解系统 的创建过程。 在这里， 系统是一个机器产生的汇编语言程序，而不是由人设计的某个东西。这简化了逆向工程的任&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC4%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC4%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</guid><description>&lt;p>第 4 章&lt;/p>
&lt;p>C H A P T E R 4 ·&lt;/p>
&lt;h2 id="处理器体系结构">处理器体系结构&lt;a class="anchor" href="#%e5%a4%84%e7%90%86%e5%99%a8%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84">#&lt;/a>&lt;/h2>
&lt;p>现代微处理器可以称得上是人类创造出的最复杂的系统之一。一块手指甲大小的硅片上，可以容纳一个完整的高性能处理器、大的高速缓存，以及用来连接到外部设备的逻辑电路。 从性能上来说 ， 今天在一块芯片上实现的处理器已经使 20 年前价值 1000 万美元、房间那么大的超级计算机相形见细了。即使是在像手机、导航系统和可编程恒温器这样的日常设备中的嵌入式处理器，也比早期计算机开发者所能想到的强大得多。&lt;/p>
&lt;p>到目前为止，我们看到的计算机系统只限于机器语言程序级。我们知道处理器必须执行一系列指令，每条指令执行某个简单操作，例如两个数相加。指令被编码为由一个或多 个字节序列组成的二进制格式。一个处理器支持的指令和指令的字节级编码称为它的指令 集体系 结构 (I nst ru ction-Set Architecture, ISA)。不同的处理器“ 家族”， 例如 In tel IA32 和 x86-64 、IBM/ Freescale Power 和 ARM 处理器家族， 都有不 同的 ISA。一个程序编译成在一种机器上运行，就不能在另一种机器上运行。另外，同一个家族里也有很多不同型 号的处 理器。虽然每个厂商制造的处理器性能和复杂性不断提高， 但是不同的型号在 ISA 级别上都保持着兼容。一些常见的处理器家族（例如x86-64) 中的处理器分别由多 个厂商提供。因此， ISA 在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编 译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出执行 这些指令的处理器。&lt;/p>
&lt;p>本章将简要介绍处理骈硬件的设计。我们将研究一个硬件系统执行某种 ISA 指令的方&lt;/p>
&lt;p>式。这会使你能更好地理解计算机是如何工作的，以及计算机制造商们面临的技术挑战。 一个很重要的 概念是 ， 现代处理器的实际工作方式可能跟 ISA 隐含的计算模型大相径庭。&lt;/p>
&lt;p>ISA 模型看上去应该是顺序指 令执行， 也就是先取出一条指令，等 到它执行完毕 ，再 开始下一条。然而，与一个时刻只执行一条指令相比，通过同时处理多条指令的不同部分，处 理器可以获得更高的性能。为了保证处理器能得到同顺序执行相同的结果，人们采用了一 些特殊的机制。在计算机科学中，用巧妙的方法在提高性能的同时又保待一个更简单、更 抽象模型的功能 ， 这种思想是众所周知的。在 Web 浏览器或平衡二叉树和哈希表这样的信息检索数据结构中使用缓存，就是这样的例子。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC5%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC5%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</guid><description>&lt;p>C H— _&lt;/p>
&lt;p>第 5 章&lt;/p>
&lt;p>_ A P T E R 5&lt;/p>
&lt;h1 id="优化程序性能">优化程序性能&lt;a class="anchor" href="#%e4%bc%98%e5%8c%96%e7%a8%8b%e5%ba%8f%e6%80%a7%e8%83%bd">#&lt;/a>&lt;/h1>
&lt;p>写程序最主要的目标就是使它在所有可能的情况下都正确工作。一个运行得很快但是给出错误结果的程序没有任何用处。程序员必须写出清晰简洁的代码，这样做不仅是为了 自己能够看懂代码，也是为了在检查代码和今后需要修改代码时，其他人能够读懂和理解 代码。&lt;/p>
&lt;p>另一方面，在很多情况下，让程序运行得快也是一个重要的考虑因素。如果一个程序要实时地处理视频帧或者网络包，一个运行得很慢的程序就不能提供所需的功能。当一个 计算任务的 计算量非常 大，需 要执行数日或者数周， 那么哪怕只是让它运行得快 20 %也会产生重大的影响。本章会探讨如何使用几种不同类型的程序优化技术，使程序运行得 更快。&lt;/p>
&lt;p>编写高效程序需要做到以下几点：第一，我们必须选择一组适当的算法和数据结构。 第二，我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。对于这第 二点，理解优化编译器的能力和局限性是很重要的。编写程序方式中看上去只是一点小小 的变动，都 会引起编译器优化方式很大的变化。有些编程语言比其他语言容易优化。C 语言的有些特性，例如执行指针运算和强制类型转换的能力，使得编译器很难对它进行优 化。程序员经常能够以一种使编译器更容易产生高效代码的方式来编写他们的程序。第三 项技术针对处理运算量特别大的计算，将一个任务分成多个部分，这些部分可以在多核和 多处理器的 某种组合上并行地计算。我们会 把这种性能改进的方法推迟到第 12 章中去讲。即使是要利用并行性，每个并行的线程都以最高性能执行也是非常重要的，所以无论如何 本章所讲的内容也还是有意义的。&lt;/p>
&lt;p>在程序开发和优化的过程中，我们必须考虑代码使用的方式，以及影响它的关键因&lt;/p>
&lt;p>素。通常，程序员必须在实现和维护程序的简单性与它的运行速度之间做出权衡。在算法 级上，几分钟就能编写一个简单的插入排序，而一个高效的排序算法程序可能需要一天或更长的时间来实现和优化。在代码级上，许多低级别的优化往往会降低程序的可读性和模块性，使得程序容易出错，并且更难以修改或扩展。对于在性能重要的环境中反复执行的代码，进行大量的优化会比较合适。一个挑战就是尽管做了大量的变化，但还是要维护代码一定程度的简洁和可读性。&lt;/p>
&lt;p>我们描述许多提高代码性能的技术。理想的情况是，编译器能够接受我们编写的任何代码，并产生尽可能高效的、具有指定行为的机器级程序。现代编译器采用了复杂的分析 和优化形式，而且变得越来越好。然而，即使是最好的编译器也受到妨碍优化的因素(optimization blocker ) 的阻碍， 妨碍优化的因素就是程序行为中那些严重依赖于执行环境的方面。程序员必须编写容易优化的代码，以帮助编译器。&lt;/p>
&lt;p>程序优化的第一步就是消除不必要的工作，让代码尽可能有效地执行所期望的任务。这包括消除不必要的函数调用、条件测试和内存引用。这些优化不依赖于目标机器的任何 具体属性。&lt;/p>
&lt;p>为了使程序性能最大化，程序员和编译器都需要一个目标机器的模型，指明如何处理指&lt;/p>
&lt;p>令，以 及各个操作的时序特性。例如， 编译器必须知道时序信息， 才能够确定是用一条乘法指令， 还是用移位和加法的某种组合 。现代计算机用复杂的技术来处理机器级程序， 并行地执行许多指令，执行顺序还可能不同 千它们在程序中出现的顺序。程序员必须理解这些处理器是如何工作的， 从而调整他们的程序以获得最大的 速度。基千 Intel 和 AMD 处理器最近的设计 ， 我们提出了这种机器的一个高级模型。我们 还设计了一种图形数据流( data-flow) 表示法， 可以使处理器对指令的执行 形象化， 我们还可以 利用它预测程序的性能。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC6%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC6%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</guid><description>&lt;p>－－－&lt;/p>
&lt;p>第 6 章&lt;/p>
&lt;p>H A P T E R 6&lt;/p>
&lt;h4 id="存储器层次结构">存储器层次结构&lt;a class="anchor" href="#%e5%ad%98%e5%82%a8%e5%99%a8%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84">#&lt;/a>&lt;/h4>
&lt;p>到目前 为止，在对系 统的研究中， 我们依赖千一 个简单的计算机系统 模型， C P U 执行指令，而 存储器系统为 CP U 存放指令和数据。在简单模型中， 存储器系统是一个线性的字节数组， 而 CP U 能够在一个常数时间内访问每个存储器位置。虽然迄今为止这都是一个有效的模型， 但是它没有反映现代系统 实际工作的方式。&lt;/p>
&lt;p>实际上， 存储器 系统( m em o r y s ys te m ) 是一个具有不同容量、成本和访问 时间的存储设备的层 次结构。CP U 寄存器保存着最常用的数据。靠近 C P U 的小的、快 速的 高速 缓存存储器 ( cache memor y) 作为一部分存储在相对慢速的 主存储器( main mem o r y ) 中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为 存储在通过网络连接的其他机器的磁盘或磁带上的数据的缓冲区域。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC7%E7%AB%A0-%E9%93%BE%E6%8E%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC7%E7%AB%A0-%E9%93%BE%E6%8E%A5/</guid><description>&lt;p>第 7 章&lt;/p>
&lt;ul>
&lt;li>
&lt;p>· · · 0 · H A . · P T · .E R 7&lt;/p>
&lt;p>链接&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>链接Clink ing ) 是将各种代码和数据片段收集并 组合成 为一个单一文件的过程， 这个文件可被加栽（复制）到内存并执行。链接可以 执行于编译 时( com pile time), 也就是在源代码被翻译成 机器代码时； 也可以执行千加 载 时 ( loa d time) , 也就是在程序被加栽 器( lo ad­ er ) 加载到内存并 执行时； 甚至执行 于运行 时( ru n time), 也就是由应用程序来执行。在早期的计算机系统中， 链接是手 动执行的。在现代系统中， 链接是由叫做链接器 Clinker ) 的程序自动 执行的 。&lt;/p>
&lt;p>链接器在软 件开发中扮演着一个关键的角色， 因为它们使得分 离 编译( separa te com­ pila t io n ) 成为可能。我们不用将一个 大型的应用程序组织为一个巨大的源文 件， 而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模 块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</guid><description>&lt;p>第 8 章&lt;/p>
&lt;p>C H A P T E R 8&lt;/p>
&lt;p>异常控制流&lt;/p>
&lt;p>从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列&lt;/p>
&lt;p>a0 , a , , &amp;hellip; , a ,, _1&lt;/p>
&lt;p>其中，每个 ak 是某个相应的指令 I k的地址。每次从 Qk 到 a k一 1 的过渡称为控 制 转移 ( co ntro l trans £er ) 。 这样的 控制转移 序列叫做处理器的控制流( flow of cont rol 或 cont ro l flow ) 。&lt;/p>
&lt;p>最简单的一种控制流 是一个“平滑的＂ 序列， 其中每个 L 和 I尸！在内存中都是相邻&lt;/p>
&lt;p>的。这种 平滑流的 突变（也就是 I尸］与 L 不相邻）通常是由诸如跳转 、调用和返回这样一些熟悉的 程序指令造成的 。这样一些指令都是必要的机制， 使得程序能够对由程序变扯表示的内部程序状 态中的 变化做出反应 。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC9%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC9%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</guid><description>&lt;p>第 9 章&lt;/p>
&lt;p>C H A P T E A 9 . .&lt;/p>
&lt;p>虚拟内存&lt;/p>
&lt;p>一个系统中 的进程是与其他进程共享 CPU 和主存资源的。然而， 共享主存会形成一些特殊的挑战。随着 对 CPU 需求的增长， 进程以 某种合理的平滑方式慢了下来。但是如果太多的 进程需要太多的内存， 那么它们中的一些就根本无法运行 。当一个程序没有空间可用时 ， 那就是它运气不好了。内存还很容易被破坏 。如果某个进程不小心写了另一个进程使用的内存 ， 它就可能以某种完全和程序逻辑无关 的令人迷惑的方式失 败。&lt;/p>
&lt;p>为了更加有效 地管理内存并且少出错， 现代系统提供了一种对主存的抽象概念， 叫做虚拟内存 CV M) 。虚拟内存 是硬件异常、硬件地址翻译 、主存 、磁盘文件和内核软件的完美交互 ， 它为每个进程提供了一个 大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力： 1 ) 它将主存看成是 一个存储在磁盘上的 地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过 这种方式 ， 它高效地使用了主存。2 ) 它为每个进程提 供了一致的地址空间，从 而简化了内存管理。3 ) 它保护了每个进程的地址空间不被其他进程破坏。&lt;/p>
&lt;p>虚拟内存是计算机系统最重要的概念之一。它成功的一个主要原因就是因为它是沉默地、自动 地工作的 ， 不需要应用程序员的任何干涉。既然虚拟内存在幕后工作得如此之好，为什么程序员还需要理解它呢？有以下儿个原因：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>虚拟内存是核心的。虚拟内存遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程的设 计中扮演着重要 角色。理解虚拟内存将帮助你更好地理解系统通常是如何工作的。&lt;/p>
&lt;p>. • 虚拟内存是强大的。虚拟内存给予应用程序强大的能力，可以创建和销毁内存片 ( ch unk ) 、将内存片映射到磁盘文件的 某个部分， 以及与其他进程共享内存。比如， 你知道可以通过读写内存位置读或者修改一个磁盘文件的内容吗？或者可以加载一 个文件的内容到内存中，而不需要进行任何显式地复制吗？理解虚拟内存将帮助你 利用它的强大功能在应用程序中添加动力。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C-2-6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C-2-6/</guid><description>&lt;p>第一部分&lt;/p>
&lt;p>尸&lt;/p>
&lt;p>心r&lt;/p>
&lt;p>程序结构和执行&lt;/p>
&lt;p>我们对计算机系统的探索是从学习计算机本身开始的，它由 处理器和存储器子系统组成。在核心部分，我们需要方法来表示 基本数据类型，比如整数和实数运算的近似值。然后，我们考虑 机器级指令如何操作这 样 的 数 据， 以 及 编译器 又如何 将 C 程 序 翻译成这样的指令。接下来，研究几种实现处理器的方法，帮助我 们更好地了解硬件资源如何被用来执行指令。一旦理解了编译器 和机器级代码 ， 我们 就 能 了 解如何通 过编写 C 程 序 以 及 编译 它 们来最大化程序的性能。本部分以存储器子系统的设计作为结束， 这是现代计算机系统最复杂的部分之一。&lt;/p>
&lt;p>本书的这一部分将领着你深入了解如何表示和执行应用程序。你将学会一些技巧，来帮助你写出安全、可靠且充分利用计算资 源的程序。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%92%8C%E9%80%9A%E4%BF%A1-10-12/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%92%8C%E9%80%9A%E4%BF%A1-10-12/</guid><description>&lt;p>&lt;img src="img/3a5216eff04803609c99d1f3962e69ab.jpeg" alt="" />第三部分&lt;/p>
&lt;p>程序间的交互和通信&lt;/p>
&lt;p>我们学习计算机系统到现在，一直假设程序是独立运行的， 只包含最小 限度 的 输入 和 输 出 。 然 而 ， 在 现实 世界 里， 应 用 程 序利用 操作 系统提供的服 务 来 与 I/ 0 设 备 及 其他程序通信。&lt;/p>
&lt;p>本书 的 这 一部分将使你 了 解 U ni x 操作 系统提供 的基本 I/ 0 服务 ， 以及如何用这 些服务 来构 造 应 用 程 序 ， 例如 Web 客 户 端 和服务器， 它 们是 通过 Intern et 彼 此 通 信 的 。 你 将 学 习 编 写 诸 如 Web 服务器这样的 可 以 同 时 为 多 个 客 户 端提 供 服 务 的并 发 程 序。 编 写并发应用程序还能使程序在现代多核处理器上执行得更快。当学 完了这个部分，你将逐渐变成一个很牛的程序员，对计算机系统 以及它们对程序的影响有很成熟的理解。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-7-9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-7-9/</guid><description>&lt;p>霄＇&lt;/p>
&lt;p>第二部分&lt;/p>
&lt;p>在系统上运行程序&lt;/p>
&lt;p>&lt;img src="img/4eaf8efb7f8ecd98f51d4916974b5c33.jpeg" alt="" />继续我们对计算机系统的探索，进一步来看看构建和运行应 用程序的系统软件。链接器把程序的各个部分联合成一个文件， 处理器可以将这个文件加载到内存，并且执行它。现代操作系统 与硬件合作，为每个程序提供一种幻象，好像这个程序是在独占 地使用处 理器和 主存 ， 而 实际 上，在 任何 时 刻， 系 统 上 都 有 多 个程序在运行。&lt;/p>
&lt;p>&lt;img src="img/8bd1b1e7deb481acbd4a4bf003ec9f04.jpeg" alt="" />在本书的第一部分，你很好地理解了程序和硬件之间的交互 关系。本书的第二部分将拓宽你对系统的了解，使你牢固地掌握 程序和操作系统之间的交互关系。你将学习到如何使用操作系统 提供的 服 务 来 构 建 系 统 级 程 序， 例 如 U nix shell 和 动 态 内 存 分配包。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E9%99%84%E5%BD%95A-%E5%B0%81%E5%BA%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E9%99%84%E5%BD%95A-%E5%B0%81%E5%BA%95/</guid><description>&lt;p>附录 A&lt;/p>
&lt;h4 id="a-p-p-e-n-d-i-x-a">A P P E N D I X A&lt;a class="anchor" href="#a-p-p-e-n-d-i-x-a">#&lt;/a>&lt;/h4>
&lt;p>错误处理&lt;/p>
&lt;h3 id="程序员应该总是检查系统级函数返回的错误代码有许多细微的方式会导致出现错-误只-有使用内核能够提供给我们的状态信息才能理解为什么有这样的错误不幸的是-程序员-往往不愿意进行错误检查-因为这使他们的代码变得-很庞大将-一行代码变成一个多行的条件语句错误检查也是很令人迷惑的因为不同的函数以不同的方式表示错误">程序员应该总是检查系统级函数返回的错误代码。有许多细微的方式会导致出现错 误，只 有使用内核能够提供给我们的状态信息才能理解为什么有这样的错误。不幸的是， 程序员 往往不愿意进行错误检查， 因为这使他们的代码变得 很庞大，将 一行代码变成一个多行的条件语句。错误检查也是很令人迷惑的，因为不同的函数以不同的方式表示错误。&lt;a class="anchor" href="#%e7%a8%8b%e5%ba%8f%e5%91%98%e5%ba%94%e8%af%a5%e6%80%bb%e6%98%af%e6%a3%80%e6%9f%a5%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e%e7%9a%84%e9%94%99%e8%af%af%e4%bb%a3%e7%a0%81%e6%9c%89%e8%ae%b8%e5%a4%9a%e7%bb%86%e5%be%ae%e7%9a%84%e6%96%b9%e5%bc%8f%e4%bc%9a%e5%af%bc%e8%87%b4%e5%87%ba%e7%8e%b0%e9%94%99-%e8%af%af%e5%8f%aa-%e6%9c%89%e4%bd%bf%e7%94%a8%e5%86%85%e6%a0%b8%e8%83%bd%e5%a4%9f%e6%8f%90%e4%be%9b%e7%bb%99%e6%88%91%e4%bb%ac%e7%9a%84%e7%8a%b6%e6%80%81%e4%bf%a1%e6%81%af%e6%89%8d%e8%83%bd%e7%90%86%e8%a7%a3%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9c%89%e8%bf%99%e6%a0%b7%e7%9a%84%e9%94%99%e8%af%af%e4%b8%8d%e5%b9%b8%e7%9a%84%e6%98%af-%e7%a8%8b%e5%ba%8f%e5%91%98-%e5%be%80%e5%be%80%e4%b8%8d%e6%84%bf%e6%84%8f%e8%bf%9b%e8%a1%8c%e9%94%99%e8%af%af%e6%a3%80%e6%9f%a5-%e5%9b%a0%e4%b8%ba%e8%bf%99%e4%bd%bf%e4%bb%96%e4%bb%ac%e7%9a%84%e4%bb%a3%e7%a0%81%e5%8f%98%e5%be%97-%e5%be%88%e5%ba%9e%e5%a4%a7%e5%b0%86-%e4%b8%80%e8%a1%8c%e4%bb%a3%e7%a0%81%e5%8f%98%e6%88%90%e4%b8%80%e4%b8%aa%e5%a4%9a%e8%a1%8c%e7%9a%84%e6%9d%a1%e4%bb%b6%e8%af%ad%e5%8f%a5%e9%94%99%e8%af%af%e6%a3%80%e6%9f%a5%e4%b9%9f%e6%98%af%e5%be%88%e4%bb%a4%e4%ba%ba%e8%bf%b7%e6%83%91%e7%9a%84%e5%9b%a0%e4%b8%ba%e4%b8%8d%e5%90%8c%e7%9a%84%e5%87%bd%e6%95%b0%e4%bb%a5%e4%b8%8d%e5%90%8c%e7%9a%84%e6%96%b9%e5%bc%8f%e8%a1%a8%e7%a4%ba%e9%94%99%e8%af%af">#&lt;/a>&lt;/h3>
&lt;p>在编写本书时， 我们面临类似的问题。一方面， 我们希望代码示例阅读起来简洁简单；另一方面，我们又不希望给学生们一个错误的印象，以为可以省略错误检查。为了解 决这些问题， 我们采用了一种基于错误处理 包装函数 ( er ro r- ha ndling wra pper ) 的方法， 这是由 W. Richard Steve ns 在他的网络编程教材 [ 11 0] 中最先提出的。&lt;/p>
&lt;h3 id="其思想是-给-定某个基本的-系统级函数-f-oo--我们定义一个有相同参数只不过开头字母大写了的包装函数-foo包装函数调用基本函数并检查错误如果包装函数发现了错误那么它就打印一条信息并终止进程否则它返回到调用者注意如果没有错误-包装函数的行为与基本函数完全一样换句话说如果程序使用包装函数运行正确那么-我们把每个-包装函数的第一个字母小-写并重新编译也-能正确运行">其思想是 ，给 定某个基本的 系统级函数 f oo , 我们定义一个有相同参数、只不过开头字母大写了的包装函数 Foo。包装函数调用基本函数并检查错误。如果包装函数发现了错误，那么它就打印一条信息并终止进程。否则，它返回到调用者。注意，如果没有错误， 包装函数的行为与基本函数完全一样。换句话说，如果程序使用包装函数运行正确，那么 我们把每个 包装函数的第一个字母小 写并重新编译，也 能正确运行。&lt;a class="anchor" href="#%e5%85%b6%e6%80%9d%e6%83%b3%e6%98%af-%e7%bb%99-%e5%ae%9a%e6%9f%90%e4%b8%aa%e5%9f%ba%e6%9c%ac%e7%9a%84-%e7%b3%bb%e7%bb%9f%e7%ba%a7%e5%87%bd%e6%95%b0-f-oo--%e6%88%91%e4%bb%ac%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aa%e6%9c%89%e7%9b%b8%e5%90%8c%e5%8f%82%e6%95%b0%e5%8f%aa%e4%b8%8d%e8%bf%87%e5%bc%80%e5%a4%b4%e5%ad%97%e6%af%8d%e5%a4%a7%e5%86%99%e4%ba%86%e7%9a%84%e5%8c%85%e8%a3%85%e5%87%bd%e6%95%b0-foo%e5%8c%85%e8%a3%85%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e5%9f%ba%e6%9c%ac%e5%87%bd%e6%95%b0%e5%b9%b6%e6%a3%80%e6%9f%a5%e9%94%99%e8%af%af%e5%a6%82%e6%9e%9c%e5%8c%85%e8%a3%85%e5%87%bd%e6%95%b0%e5%8f%91%e7%8e%b0%e4%ba%86%e9%94%99%e8%af%af%e9%82%a3%e4%b9%88%e5%ae%83%e5%b0%b1%e6%89%93%e5%8d%b0%e4%b8%80%e6%9d%a1%e4%bf%a1%e6%81%af%e5%b9%b6%e7%bb%88%e6%ad%a2%e8%bf%9b%e7%a8%8b%e5%90%a6%e5%88%99%e5%ae%83%e8%bf%94%e5%9b%9e%e5%88%b0%e8%b0%83%e7%94%a8%e8%80%85%e6%b3%a8%e6%84%8f%e5%a6%82%e6%9e%9c%e6%b2%a1%e6%9c%89%e9%94%99%e8%af%af-%e5%8c%85%e8%a3%85%e5%87%bd%e6%95%b0%e7%9a%84%e8%a1%8c%e4%b8%ba%e4%b8%8e%e5%9f%ba%e6%9c%ac%e5%87%bd%e6%95%b0%e5%ae%8c%e5%85%a8%e4%b8%80%e6%a0%b7%e6%8d%a2%e5%8f%a5%e8%af%9d%e8%af%b4%e5%a6%82%e6%9e%9c%e7%a8%8b%e5%ba%8f%e4%bd%bf%e7%94%a8%e5%8c%85%e8%a3%85%e5%87%bd%e6%95%b0%e8%bf%90%e8%a1%8c%e6%ad%a3%e7%a1%ae%e9%82%a3%e4%b9%88-%e6%88%91%e4%bb%ac%e6%8a%8a%e6%af%8f%e4%b8%aa-%e5%8c%85%e8%a3%85%e5%87%bd%e6%95%b0%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%ad%97%e6%af%8d%e5%b0%8f-%e5%86%99%e5%b9%b6%e9%87%8d%e6%96%b0%e7%bc%96%e8%af%91%e4%b9%9f-%e8%83%bd%e6%ad%a3%e7%a1%ae%e8%bf%90%e8%a1%8c">#&lt;/a>&lt;/h3>
&lt;p>包装函数被封装在一个源文件( c s a p p . c ) 中， 这个文件被编译 和链接到每个程序中。一个独立的 头文件Cc s a p p . h ) 中包含这些包装函数的 函数原型。&lt;/p></description></item></channel></rss>