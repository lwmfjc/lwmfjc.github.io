<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="－－－
第 6 章
H A P T E R 6

  存储器层次结构
  #

到目前 为止，在对系 统的研究中， 我们依赖千一 个简单的计算机系统 模型， C P U 执行指令，而 存储器系统为 CP U 存放指令和数据。在简单模型中， 存储器系统是一个线性的字节数组， 而 CP U 能够在一个常数时间内访问每个存储器位置。虽然迄今为止这都是一个有效的模型， 但是它没有反映现代系统 实际工作的方式。
实际上， 存储器 系统( m em o r y s ys te m ) 是一个具有不同容量、成本和访问 时间的存储设备的层 次结构。CP U 寄存器保存着最常用的数据。靠近 C P U 的小的、快 速的 高速 缓存存储器 ( cache memor y) 作为一部分存储在相对慢速的 主存储器( main mem o r y ) 中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为 存储在通过网络连接的其他机器的磁盘或磁带上的数据的缓冲区域。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC6%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"><meta property="og:site_name" content="随记"><meta property="og:title" content="随记"><meta property="og:description" content="－－－
第 6 章
H A P T E R 6
存储器层次结构 # 到目前 为止，在对系 统的研究中， 我们依赖千一 个简单的计算机系统 模型， C P U 执行指令，而 存储器系统为 CP U 存放指令和数据。在简单模型中， 存储器系统是一个线性的字节数组， 而 CP U 能够在一个常数时间内访问每个存储器位置。虽然迄今为止这都是一个有效的模型， 但是它没有反映现代系统 实际工作的方式。
实际上， 存储器 系统( m em o r y s ys te m ) 是一个具有不同容量、成本和访问 时间的存储设备的层 次结构。CP U 寄存器保存着最常用的数据。靠近 C P U 的小的、快 速的 高速 缓存存储器 ( cache memor y) 作为一部分存储在相对慢速的 主存储器( main mem o r y ) 中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为 存储在通过网络连接的其他机器的磁盘或磁带上的数据的缓冲区域。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Index | 随记</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC6%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/><link rel=stylesheet href=/book.min.8cec3a17310cf1804783c64adc1262d2887f4c1c55a3b42660027130b0b10b7e.css integrity="sha256-jOw6FzEM8YBHg8ZK3BJi0oh/TBxVo7QmYAJxMLCxC34=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.0c3359f4ee92d85049eac29271383117c4be950c9997c7f7ae94e4175dd7e5ee.js integrity="sha256-DDNZ9O6S2FBJ6sKScTgxF8S+lQyZl8f3rpTkF13X5e4=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>随记</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><a href=/zh/docs/technology/>技术</a><ul><li><input type=checkbox id=section-d9652e1d39ed08192f3dd99c4361d9ad class=toggle checked>
<label for=section-d9652e1d39ed08192f3dd99c4361d9ad class="flex justify-between"><a role=button>System</a></label><ul><li><span>SpringCloud</span><ul><li><input type=checkbox id=section-34c1382ca3a0d6868e10683db155c5f7 class=toggle>
<label for=section-34c1382ca3a0d6868e10683db155c5f7 class="flex justify-between"><a role=button>视频笔记</a></label><ul><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/16SystemLevelI_O/>16SystemLevelI_O</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/21NetworkProgramming01/>21NetworkProgramming01</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/08MachineLevelProgramming04Data/>08MachineLevelProgramming04Data</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/07MachineLevelProgramming03Procedures/>07MachineLevelProgramming03Procedures</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/06Machine-LevelProgramming02Control/>06Machine-LevelProgramming02Control</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/05MachineLevelProgramming01Basic/>05MachineLevelProgramming01Basic</a></li></ul></li><li><input type=checkbox id=section-c5bcefb305c982df1e56b6f496a0df25 class=toggle checked>
<label for=section-c5bcefb305c982df1e56b6f496a0df25 class="flex justify-between"><a role=button>书籍</a></label><ul><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E5%B0%81%E9%9D%A2-%E7%9B%AE%E5%BD%95/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC10%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7I_O/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC11%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC12%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC2%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC4%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC5%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC6%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/ class=active>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC7%E7%AB%A0-%E9%93%BE%E6%8E%A5/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC9%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C-2-6/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%92%8C%E9%80%9A%E4%BF%A1-10-12/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-7-9/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E9%99%84%E5%BD%95A-%E5%B0%81%E5%BA%95/>Index</a></li></ul></li></ul></li></ul></li><li><input type=checkbox id=section-79ad4ec36247c32c4cd2190b9ba6b65a class=toggle>
<label for=section-79ad4ec36247c32c4cd2190b9ba6b65a class="flex justify-between"><a role=button>Markdown</a></label><ul><li><a href=/zh/docs/technology/Markdown/EpubsToMd/>将epub文件转换为md文件</a></li><li><a href=/zh/docs/technology/Markdown/_SuperTutorial_/>Markdown超级教程</a></li></ul></li><li><input type=checkbox id=section-2fb98c56480f40c379c8653613ac5510 class=toggle>
<label for=section-2fb98c56480f40c379c8653613ac5510 class="flex justify-between"><a role=button>Cpp</a></label><ul><li><input type=checkbox id=section-0bf9e6fc3c3b29b6dfa5edcdd6349f4a class=toggle>
<label for=section-0bf9e6fc3c3b29b6dfa5edcdd6349f4a class="flex justify-between"><a href=/zh/docs/technology/cpp/chernoCPP/>Cherno Cpp</a></label><ul><li><a href=/zh/docs/technology/cpp/chernoCPP/01-/>01-</a></li></ul></li><li><a href=/zh/docs/technology/cpp/leetcode/>154【杂项】算竞常用_C++_STL_用法</a></li><li><a href=/zh/docs/technology/cpp/qt/>qt学习</a></li></ul></li><li><input type=checkbox id=section-d2e5dc71fe2274ddaa089e125f33ae58 class=toggle>
<label for=section-d2e5dc71fe2274ddaa089e125f33ae58 class="flex justify-between"><a role=button>My SQL</a></label><ul><li><input type=checkbox id=section-385256c91dd6127cb06668afb2ab262b class=toggle>
<label for=section-385256c91dd6127cb06668afb2ab262b class="flex justify-between"><a role=button>mysql_进阶_施磊</a></label><ul><li><a href=/zh/docs/technology/MySQL/advanced_shilei/05/>05日志</a></li><li><a href=/zh/docs/technology/MySQL/advanced_shilei/04/>04事务</a></li><li><a href=/zh/docs/technology/MySQL/advanced_shilei/03/>03存储引擎</a></li><li><a href=/zh/docs/technology/MySQL/advanced_shilei/02/>02增删改查</a></li><li><a href=/zh/docs/technology/MySQL/advanced_shilei/01/>01基础知识</a></li></ul></li><li><input type=checkbox id=section-b36f39b28986b079f4216fd3e38bfa3e class=toggle>
<label for=section-b36f39b28986b079f4216fd3e38bfa3e class="flex justify-between"><a role=button>My Sql是怎样运行的</a></label><ul><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC26%E7%AB%A0_%E5%86%99%E4%BD%9C%E6%9C%AC%E4%B9%A6%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>第26章_写作本书时用到的一些重要的参考资料</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC25%E7%AB%A0_%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E8%80%81%E5%A4%A7%E9%9A%BE-%E9%94%81/>第25章_工作面试老大难-锁</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC24%E7%AB%A0_%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%9A%E5%B9%85%E9%9D%A2%E5%AD%94-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC/>第24章_一条记录的多幅面孔-事务的隔离级别与MVCC</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC23%E7%AB%A0_%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%E4%B8%8B/>第23章_后悔了怎么办-undo日志(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC22%E7%AB%A0_%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%E4%B8%8A/>第22章_后悔了怎么办-undo日志(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC21%E7%AB%A0_%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%E4%B8%8B/>第21章_说过的话就一定要办到-redo日志(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC20%E7%AB%A0_%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%E4%B8%8A/>第20章_说过的话就一定要办到-redo日志(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC19%E7%AB%A0_%E4%BB%8E%E7%8C%AB%E7%88%B7%E8%A2%AB%E6%9D%80%E8%AF%B4%E8%B5%B7-%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/>第19章_从猫爷被杀说起-事务简介</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC18%E7%AB%A0_%E8%B0%83%E8%8A%82%E7%A3%81%E7%9B%98%E5%92%8CCPU%E7%9A%84%E7%9F%9B%E7%9B%BE-InnoDB%E7%9A%84BufferPool/>第18章_调节磁盘和CPU的矛盾-InnoDB的BufferPool</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC17%E7%AB%A0_%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-optimizer_trace%E8%A1%A8%E7%9A%84%E7%A5%9E%E5%99%A8%E5%8A%9F%E6%95%88/>第17章_神兵利器-optimizer_trace表的神器功效</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC16%E7%AB%A0_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8B/>第16章_查询优化的百科全书-Explain详解(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC15%E7%AB%A0_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8A/>第15章_查询优化的百科全书-Explain详解(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC14%E7%AB%A0_%E4%B8%8D%E5%A5%BD%E7%9C%8B%E5%B0%B1%E8%A6%81%E5%A4%9A%E6%95%B4%E5%AE%B9-MySQL%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96%E5%86%85%E5%90%AB%E5%85%B3%E4%BA%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%BA%8C%E4%B8%89%E4%BA%8B%E5%84%BF/>第14章_不好看就要多整容-MySQL基于规则的优化(内含关于子查询优化二三事儿)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC13%E7%AB%A0_%E5%85%B5%E9%A9%AC%E6%9C%AA%E5%8A%A8%E7%B2%AE%E8%8D%89%E5%85%88%E8%A1%8C-InnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E7%9A%84/>第13章_兵马未动粮草先行-InnoDB统计数据是如何收集的</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC12%E7%AB%A0_%E8%B0%81%E6%9C%80%E4%BE%BF%E5%AE%9C%E5%B0%B1%E9%80%89%E8%B0%81-MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/>第12章_谁最便宜就选谁-MySQL基于成本的优化</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC10%E7%AB%A0_%E6%9D%A1%E6%9D%A1%E5%A4%A7%E8%B7%AF%E9%80%9A%E7%BD%97%E9%A9%AC-%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/>第10章_条条大路通罗马-单表访问方法</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC9%E7%AB%A0_%E5%AD%98%E6%94%BE%E9%A1%B5%E7%9A%84%E5%A4%A7%E6%B1%A0%E5%AD%90-InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/>第9章_存放页的大池子-InnoDB的表空间</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC8%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%B6-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/>第8章_数据的家-MySQL的数据目录</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC7%E7%AB%A0_%E5%A5%BD%E4%B8%9C%E8%A5%BF%E4%B9%9F%E5%BE%97%E5%85%88%E5%AD%A6%E4%BC%9A%E6%80%8E%E4%B9%88%E7%94%A8-B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/>第7章_好东西也得先学会怎么用-B+树索引的使用</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC6%E7%AB%A0_%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A7%98%E7%B1%8D-B+%E6%A0%91%E7%B4%A2%E5%BC%95/>第6章_快速查询的秘籍-B+树索引</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC5%E7%AB%A0-%E7%9B%9B%E6%94%BE%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%A7%E7%9B%92%E5%AD%90-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/>第5章 盛放记录的大盒子-InnoDB数据页结构</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC4%E7%AB%A0_%E4%BB%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E8%AF%B4%E8%B5%B7-InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/>第4章_从一条记录说起-InnoDB记录结构</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC3%E7%AB%A0_%E4%B9%B1%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/>第3章_乱码的前世今生-字符集和比较规则</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC2%E7%AB%A0_MySQL%E7%9A%84%E8%B0%83%E6%8E%A7%E6%8C%89%E9%92%AE-%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/>第2章_MySQL的调控按钮-启动选项和系统变量</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC1%E7%AB%A0_%E8%A3%85%E4%BD%9C%E8%87%AA%E5%B7%B1%E6%98%AF%E4%B8%AA%E5%B0%8F%E7%99%BD-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86MySQL/>第1章_装作自己是个小白-重新认识MySQL</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC0%E7%AB%A0_%E4%B8%87%E9%87%8C%E9%95%BF%E5%BE%81%E7%AC%AC%E4%B8%80%E6%AD%A5%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81-%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E7%9A%84%E9%98%85%E8%AF%BB%E6%9C%AC%E5%B0%8F%E5%86%8C/>第0章_万里长征第一步(非常重要)-如何愉快的阅读本小册</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC11%E7%AB%A0_%E4%B8%A4%E4%B8%AA%E8%A1%A8%E7%9A%84%E4%BA%B2%E5%AF%86%E6%8E%A5%E8%A7%A6-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/>第11章_两个表的亲密接触-连接的原理</a></li></ul></li><li><input type=checkbox id=section-14acbe73a39f7c2e8d055bbdbab560d6 class=toggle>
<label for=section-14acbe73a39f7c2e8d055bbdbab560d6 class="flex justify-between"><a role=button>_MySQL是怎样运行的_</a></label><ul><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/08/>08数据的家--MySQL的数据目录</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/07/>07B+数索引的使用</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/06/>06B+树索引</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/05/>05InnoDB数据页结构</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/04/>04InnoDB记录存储结构</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/03/>03字符集和比较规则</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/02/>02启动选项和系统变量</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/01/>01初识MySQL</a></li></ul></li><li><input type=checkbox id=section-522269efe4a436e18b16a29ff12d542d class=toggle>
<label for=section-522269efe4a436e18b16a29ff12d542d class="flex justify-between"><a role=button>高性能 My SQL</a></label><ul><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83/>封面-版权</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC9%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96/>第9章操作系统和硬件优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC8%E7%AB%A0%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/>第8章优化服务器设置</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC7%E7%AB%A0MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/>第7章MySQL高级特性</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC6%E7%AB%A0%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>第6章查询性能优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC5%E7%AB%A0%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/>第5章创建高性能的索引</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC4%E7%AB%A0Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/>第4章Schema与数据类型优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC3%E7%AB%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/>第3章服务器性能剖析</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC2%E7%AB%A0MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/>第2章MySQL基准测试</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC1%E7%AB%A0MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2/>第1章MySQL架构与历史</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC16%E7%AB%A0MySQL%E7%94%A8%E6%88%B7%E5%B7%A5%E5%85%B7/>第16章MySQL用户工具</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC15%E7%AB%A0%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/>第15章备份与恢复</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC14%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82%E4%BC%98%E5%8C%96/>第14章应用层优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC13%E7%AB%A0%E4%BA%91%E7%AB%AF%E7%9A%84MySQL/>第13章云端的MySQL</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC12%E7%AB%A0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/>第12章高可用性</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC11%E7%AB%A0%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84MySQL/>第11章可扩展的MySQL</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC10%E7%AB%A0%E5%A4%8D%E5%88%B6/>第10章复制</a></li></ul></li><li><input type=checkbox id=section-33ad04dc8d65b11ab6b2d2e0964c3c89 class=toggle>
<label for=section-33ad04dc8d65b11ab6b2d2e0964c3c89 class="flex justify-between"><a role=button>进阶(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MySQL/bl_sgg_/96-00/>mysql高阶_sgg 96-00</a></li></ul></li></ul></li><li><input type=checkbox id=section-1dd4601389ea65ef400f95373226aee0 class=toggle>
<label for=section-1dd4601389ea65ef400f95373226aee0 class="flex justify-between"><a role=button>Linux</a></label><ul><li><input type=checkbox id=section-eb3a110e9a221e46d625b63087e91152 class=toggle>
<label for=section-eb3a110e9a221e46d625b63087e91152 class="flex justify-between"><a role=button>SHELL编程(learnLinuxTV)_</a></label><ul><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/16-18/>16-18</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/12-15/>12-15</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/11DataStreams/>11DataStreams</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/07-10/>07-10</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/06ExitCode/>06ExitCode</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/05If/>05If</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/01-04/>01-04</a></li></ul></li><li><input type=checkbox id=section-cd7838d42e3d9f745d945ce90940f02e class=toggle>
<label for=section-cd7838d42e3d9f745d945ce90940f02e class="flex justify-between"><a role=button>韩顺平老师_</a></label><ul><li><a href=/zh/docs/technology/Linux/hanshunping_/52-x/>52-X</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/40-51/>linux_韩老师_40-51</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/28-39/>linux_韩老师_28-39</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/21-27/>linux_韩老师_21-33</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/12-20/>linux_韩老师_12-20</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/07-11/>linux_韩老师_07-11</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/01-06/>linux_韩老师_01-06</a></li></ul></li><li><a href=/zh/docs/technology/Linux/_TheLinuxCommandsHandbook_/>_TheLinuxCommandsHandbook_</a></li><li><a href=/zh/docs/technology/Linux/basic/>基本操作</a></li><li><a href=/zh/docs/technology/Linux/create_clone/>vmware上linux主机的安装和克隆</a></li></ul></li><li><input type=checkbox id=section-9f56b27db6873dfaab68a13a9088b050 class=toggle>
<label for=section-9f56b27db6873dfaab68a13a9088b050 class="flex justify-between"><a role=button>Reg Exp</a></label><ul><li><input type=checkbox id=section-e7092def48f35456be32e3b6257559e4 class=toggle>
<label for=section-e7092def48f35456be32e3b6257559e4 class="flex justify-between"><a role=button>基础(CoreySchafer)_</a></label><ul><li><a href=/zh/docs/technology/RegExp/baseCoreySchafer_/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class=toggle>
<label for=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class="flex justify-between"><a role=button>Hugo</a></label><ul><li><input type=checkbox id=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class=toggle>
<label for=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class="flex justify-between"><a role=button>主题</a></label><ul><li><a href=/zh/docs/technology/Hugo/themes/PaperMod/01/>使用PaperMode</a></li></ul></li><li><input type=checkbox id=section-d72f299b202b2766d1efe5fb807ed184 class=toggle>
<label for=section-d72f299b202b2766d1efe5fb807ed184 class="flex justify-between"><a role=button>基础(Giraffe学院)_</a></label><ul><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced20-23/>hugo进阶学习20-23</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced17-19/>hugo进阶学习17-19</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced11-16/>hugo进阶学习11-15</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced01-10/>hugo进阶学习01-10</a></li></ul></li></ul></li><li><input type=checkbox id=section-43be5f3c9fb2465efc746ae00240e4b3 class=toggle>
<label for=section-43be5f3c9fb2465efc746ae00240e4b3 class="flex justify-between"><a role=button>Obsidian</a></label><ul><li><a href=/zh/docs/technology/Obsidian/border-theme/>border-theme背景图片问题</a></li><li><a href=/zh/docs/technology/Obsidian/obsidian-theme/>obsidian-theme</a></li><li><a href=/zh/docs/technology/Obsidian/plugin/>plugin</a></li></ul></li><li><input type=checkbox id=section-7123c56777444b2f7157631dd88ad8f6 class=toggle>
<label for=section-7123c56777444b2f7157631dd88ad8f6 class="flex justify-between"><a role=button>Redis</a></label><ul><li><input type=checkbox id=section-e6cea4f92582460cfa10699a07a10e32 class=toggle>
<label for=section-e6cea4f92582460cfa10699a07a10e32 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/19-A/>redis_尚硅谷_19-A</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/18/>redis_尚硅谷_18</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/12-17/>redis_尚硅谷_12-17</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/06-11/>redis_尚硅谷_06-11</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/01-05/>redis_尚硅谷_01-05</a></li></ul></li><li><a href=/zh/docs/technology/Redis/rsync-use/>rsync使用</a></li><li><a href=/zh/docs/technology/Redis/redis-cluster/>redis集群搭建</a></li></ul></li><li><input type=checkbox id=section-a94b8d7740a71c28fc6e0f89885b2468 class=toggle>
<label for=section-a94b8d7740a71c28fc6e0f89885b2468 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><input type=checkbox id=section-64c6733376d70496ded44b4ef3db6718 class=toggle>
<label for=section-64c6733376d70496ded44b4ef3db6718 class="flex justify-between"><a role=button>_深入理解Java虚拟机_</a></label><ul><li><a href=/zh/docs/technology/JVM/_understanding_the_jvm_/03/>03垃圾收集器与内存分配策略</a></li></ul></li></ul></li><li><input type=checkbox id=section-e8f515fe7fc71d283363385aa363c2dd class=toggle>
<label for=section-e8f515fe7fc71d283363385aa363c2dd class="flex justify-between"><a role=button>其他</a></label><ul><li><a href=/zh/docs/technology/Other/kaoshi/>科目</a></li><li><a href=/zh/docs/technology/Other/pc_base/>电脑基础操作</a></li></ul></li><li><input type=checkbox id=section-f54112ca99b135fbc484938888b1f1a2 class=toggle>
<label for=section-f54112ca99b135fbc484938888b1f1a2 class="flex justify-between"><a href=/zh/docs/technology/Review/>面试</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/>JavaGuide</a><ul><li><input type=checkbox id=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class=toggle>
<label for=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class="flex justify-between"><a role=button>数据库</a></label><ul><li><input type=checkbox id=section-e7660273cef85dff1f39af04a42bd062 class=toggle>
<label for=section-e7660273cef85dff1f39af04a42bd062 class="flex justify-between"><a role=button>MySQL</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0606lymysql-query-execution-plan/>mysql执行计划</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0611lymysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0610lymysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0609lyindex-invalidation-caused-by-implicit-conversion/>MySQL中的隐式转换造成的索引失效</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0608lysome-thoughts-on-database-storage-time/>MySQL数据库时间类型数据存储建议</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0605lyhow-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0604lyinnodb-implementation-of-mvcc/>innodb引擎对MVCC的实现</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0603lytransaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0602lymysql-logs/>日志</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0601lymysql-index/>索引</a></li></ul></li><li><input type=checkbox id=section-680d077436e58b0cad0a63ed8edb5f53 class=toggle>
<label for=section-680d077436e58b0cad0a63ed8edb5f53 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/diagram/>redis问题图解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0703ly3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0704lyredis-memory-fragmentation/>redis内存碎片</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0702lyredis-spec-data-structure/>redis特殊数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0701lyredis-base-data-structures/>redis基本数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0706lyredis-questions-02/>redis面试题02</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0705lyredis-questions-01/>redis面试题01</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0503lysql-question-01/>sql常见面试题总结01</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0504lysql-syntax-summary/>sql语法基础知识总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0502lycharactor-set/>字符集详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0501lybasis/>数据库基础</a></li></ul></li><li><input type=checkbox id=section-a1b717b4079938cc0efe574541b240b8 class=toggle>
<label for=section-a1b717b4079938cc0efe574541b240b8 class="flex justify-between"><a role=button>系统设计</a></label><ul><li><input type=checkbox id=section-9eaf95f03abf595bfdf838c4b4cdb2ef class=toggle>
<label for=section-9eaf95f03abf595bfdf838c4b4cdb2ef class="flex justify-between"><a role=button>安全</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly06ly_sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly05ly_design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly04ly_sso-intro/>sso单点登录</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly03ly_jwt-advantages-disadvantages/>jwt身份认证优缺点</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly02ly_jwt-intro/>jwt-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly01ly_basis-of-authority-certification/>认证授权基础概念详解</a></li></ul></li><li><input type=checkbox id=section-79417049c90714c6ddbf18a3c3958148 class=toggle>
<label for=section-79417049c90714c6ddbf18a3c3958148 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/unit-test/>单元测试</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/software-engineering/>软件工程简明教程</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/restful/>restFul</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/web-real-time-message-push/>web-real-time-message-push</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/schedule-task/>Java定时任务详解</a></li></ul></li><li><input type=checkbox id=section-0a9533f3005d615c696f74456e46d269 class=toggle>
<label for=section-0a9533f3005d615c696f74456e46d269 class="flex justify-between"><a role=button>高可用</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly05ly_performance-test/>性能测试入门</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly04ly_timout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly03ly_limit-request/>服务限流详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly02ly_redundancy/>冗余设计</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly01ly_high-availability-system-design/>高可用系统设计指南</a></li></ul></li><li><input type=checkbox id=section-e36f94f48e5027e7cbd39b7f7bbc249c class=toggle>
<label for=section-e36f94f48e5027e7cbd39b7f7bbc249c class="flex justify-between"><a role=button>高性能</a></label><ul><li><input type=checkbox id=section-581624dd7aa25a150f706312689ba446 class=toggle>
<label for=section-581624dd7aa25a150f706312689ba446 class="flex justify-between"><a role=button>RocketMQ</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-questions/>rocketmq常见面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-intro/>rocketmq介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/base/>message-queue</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly02ly_cdn/>cdn</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly01ly_read-and-write-separation-and-library-subtable/>数据库读写分离&分库分表详解</a></li></ul></li><li><input type=checkbox id=section-a6916634f1b5324076467df4cc9ac3b5 class=toggle>
<label for=section-a6916634f1b5324076467df4cc9ac3b5 class="flex justify-between"><a role=button>分布式系统</a></label><ul><li><input type=checkbox id=section-0c8e62b6137b614e01882e2a88ea5daf class=toggle>
<label for=section-0c8e62b6137b614e01882e2a88ea5daf class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/raft-algorithm/>raft算法</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/paxos-algorithm/>paxos算法</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/cap_base-theorem/>CAP&amp;BASE 理论</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly08ly_zookeeper-in-action/>zookeeper实战</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly07ly_zookeeper-plus/>zookeeper进阶</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly06ly_zookeeper-intro/>zookeeper介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly04ly_rpc-http/>rpc_http</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly05ly_rpc-intro/>rpc基础及面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly03ly_distributed-lock/>分布式锁</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly02ly_distributed-id/>分布式id</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly01ly_api-gateway/>api网关</a></li></ul></li><li><input type=checkbox id=section-ce3cbb53c62f67624e4ab24a5a14298a class=toggle>
<label for=section-ce3cbb53c62f67624e4ab24a5a14298a class="flex justify-between"><a role=button>框架</a></label><ul><li><input type=checkbox id=section-dbe480810d1877286936b38cdb5e9229 class=toggle>
<label for=section-dbe480810d1877286936b38cdb5e9229 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><input type=checkbox id=section-30b916f2071579e2468767a2562433d9 class=toggle>
<label for=section-30b916f2071579e2468767a2562433d9 class="flex justify-between"><a role=button>原理</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle3/>Mybatis原理系列(3)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle2/>Mybatis原理系列(2)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle1/>Mybatis原理系列(1)</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/MyBatis-interview/>Mybatis面试</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/conditional_on_class/>ConditionalOnClass实践</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly05ly_springboot-auto-assembly/>SpringBoot自动装配原理</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly04ly_spring-design-patterns/>spring 设计模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly03ly_spring-transaction/>Spring事务详情</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly02ly_spring-annotations/>Spring/SpringBoot常用注解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/>spring 常见面试题总结</a></li></ul></li><li><input type=checkbox id=section-1f6733a85e33dcc22aabbf820e3ef963 class=toggle>
<label for=section-1f6733a85e33dcc22aabbf820e3ef963 class="flex justify-between"><a role=button>开发工具</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/git/>git</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/maven/>maven</a></li></ul></li><li><input type=checkbox id=section-c01151f806b917cd0ecc4cffa72c3402 class=toggle>
<label for=section-c01151f806b917cd0ecc4cffa72c3402 class="flex justify-between"><a role=button>Java基础</a></label><ul><li><input type=checkbox id=section-26625a0c4c0bffef02640966ca545537 class=toggle>
<label for=section-26625a0c4c0bffef02640966ca545537 class="flex justify-between"><a role=button>并发</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly030301lyatomicpre/>Atomic预备知识</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0311lycompletablefuture-intro/>completablefuture-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0310lythreadlocal/>ThreadLocal详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0309lyatomic-classes/>Atomic原子类介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0308lyaqs-details/>aqs详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0307lyconcurrent-collections/>java常见并发容器</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0306lythread-pool-best/>线程池最佳实践</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0305lyjava-thread-pool/>java线程池详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0304lyjmm/>java内存模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0303lyconcurrent-03/>并发03</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03122lylock_escalation/>锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated2/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03121lyobject-concurrent/>对象内存布局和对象头</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0302lyconcurrent-02/>并发02</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0301lyconcurrent-01/>并发01</a></li></ul></li><li><input type=checkbox id=section-8f747d8f024fbfe2b392a25696e01266 class=toggle>
<label for=section-8f747d8f024fbfe2b392a25696e01266 class="flex justify-between"><a role=button>IO</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0203lyio-model/>io模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0202lyio-design-patterns/>io设计模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0201lyio/>io基础</a></li></ul></li><li><input type=checkbox id=section-7d26c3d37b0e4678a1ec776265992903 class=toggle>
<label for=section-7d26c3d37b0e4678a1ec776265992903 class="flex justify-between"><a role=button>集合</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0105lysource-code-concurrenthashmap/>ConcurrentHashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0106lysource-code-hashmap/>HashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0104lysource-code-ArrayList/>ArrayList源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0103lycollections-precautions-for-use/>集合使用注意事项</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0102lycollection_2/>集合_2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0101lycollection_1/>集合_1</a></li></ul></li><li><input type=checkbox id=section-7027a9bc1d603892e7826da81b333f38 class=toggle>
<label for=section-7027a9bc1d603892e7826da81b333f38 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0011lysyntactic_sugar/>语法糖</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0010lyjava_spi/>java_spi</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0009lyunsafe_class/>unsafe类</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0008lybig_decimal/>big_decimal</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0007lyproxy_pattern/>Java代理模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0006lyreflex/>java-reflex</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0005lyserialize/>Java序列化详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0004lypassbyvalue/>为什么Java中只有值传递</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0003lyjava_guide_basic_3/>javaGuide基础3</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0002lyjava_guide_basic_2/>javaGuide基础2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0001lyjava_guide_basic_1/>javaGuide基础1</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0408lyjdk-monitoring-and-troubleshooting-tools/>jvm监控和故障处理工具 总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0406lyjvm-params/>jvm参数</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0403lyclass-structure/>类文件结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0405lyclassloader-detail/>类加载器详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0404lyclassloader-process/>类加载过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0402lygarbage-collection/>java垃圾回收</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0407lyjvm-intro/>jvm-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0401lymemory-area/>memory-area</a></li></ul></li><li><input type=checkbox id=section-04d967d6579d47b35ececb3d233024f1 class=toggle>
<label for=section-04d967d6579d47b35ececb3d233024f1 class="flex justify-between"><a role=button>计算机基础</a></label><ul><li><input type=checkbox id=section-316b43351a75a19ac6dec86ad1a48c45 class=toggle>
<label for=section-316b43351a75a19ac6dec86ad1a48c45 class="flex justify-between"><a role=button>数据结构</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/heap/>堆</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li></ul></li></ul></li><li><input type=checkbox id=section-09d19e9c6f50e4706fe8b6d358c441ce class=toggle>
<label for=section-09d19e9c6f50e4706fe8b6d358c441ce class="flex justify-between"><a role=button>Ssm</a></label><ul><li><a href=/zh/docs/technology/Review/ssm/scope_transaction/>作用域及事务</a></li></ul></li><li><input type=checkbox id=section-11f3d4afcbd3591ad3ee5d79993e29d7 class=toggle>
<label for=section-11f3d4afcbd3591ad3ee5d79993e29d7 class="flex justify-between"><a role=button>Java基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Review/basics/member_variables_and_local_variables/>成员变量与局部变量</a></li><li><a href=/zh/docs/technology/Review/basics/recursion_and_iteration/>递归与迭代</a></li><li><a href=/zh/docs/technology/Review/basics/method_parameter_passing_mechanism/>方法的参数传递机制</a></li><li><a href=/zh/docs/technology/Review/basics/class_and_instance_initialization/>类、实例初始化</a></li><li><a href=/zh/docs/technology/Review/basics/singleton_design_pattern/>单例设计模式</a></li><li><a href=/zh/docs/technology/Review/basics/self_incrementing_variable/>自增变量</a></li></ul></li></ul></li><li><input type=checkbox id=section-2fa8d2f95840b0143e19fcee5ee1ad97 class=toggle>
<label for=section-2fa8d2f95840b0143e19fcee5ee1ad97 class="flex justify-between"><a role=button>SpringCloud</a></label><ul><li><input type=checkbox id=section-b7a5506013de8d65cad1cac0f659f728 class=toggle>
<label for=section-b7a5506013de8d65cad1cac0f659f728 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/springCloud/bl_zhouyang_/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-5057ba12f456498454476dc11b58648b class=toggle>
<label for=section-5057ba12f456498454476dc11b58648b class="flex justify-between"><a role=button>Git</a></label><ul><li><input type=checkbox id=section-55d261358c84b4996ac8d7851d37ccf8 class=toggle>
<label for=section-55d261358c84b4996ac8d7851d37ccf8 class="flex justify-between"><a role=button>基础(尚硅谷视频)_</a></label><ul><li><a href=/zh/docs/technology/Git/git_sgg_/19-26/>19-26_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg_/09-18/>09-18_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg_/01-08/>01-08_git_尚硅谷</a></li></ul></li></ul></li><li><input type=checkbox id=section-d8f59257917ebff8da82fd22583ae10c class=toggle>
<label for=section-d8f59257917ebff8da82fd22583ae10c class="flex justify-between"><a role=button>Maven</a></label><ul><li><input type=checkbox id=section-9b52bdf229c64237c3a478dc6a533410 class=toggle>
<label for=section-9b52bdf229c64237c3a478dc6a533410 class="flex justify-between"><a role=button>进阶(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/advance_dljd_/01-21/>01-21 maven多模块管理_动力节点</a></li></ul></li><li><input type=checkbox id=section-3b2851b4ae70cae160ce8f24dba7236a class=toggle>
<label for=section-3b2851b4ae70cae160ce8f24dba7236a class="flex justify-between"><a role=button>基础(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/base_dljd_/31-43/>31-43 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd_/17-30/>17-30 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd_/01-16/>01-16 maven基础_动力节点</a></li></ul></li></ul></li><li><input type=checkbox id=section-d2ff9acb1ec90bec89f165361ced2010 class=toggle>
<label for=section-d2ff9acb1ec90bec89f165361ced2010 class="flex justify-between"><a role=button>算法</a></label><ul><li><input type=checkbox id=section-d1faa468beb89fe27a31308721f74c82 class=toggle>
<label for=section-d1faa468beb89fe27a31308721f74c82 class="flex justify-between"><a role=button>_算法(第四版)_</a></label><ul><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/3.2.1/>算法红皮书 3.2.1</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/3.1.1-3.1.7/>算法红皮书 3.1.1-3.1.7</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.5/>算法红皮书 2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.4/>算法红皮书 2.4</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.1.2-2.1.3/>算法红皮书 2.1.2-2.1.3</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.1.1/>算法红皮书 2.1.1</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.5.1-1.5.3/>算法红皮书 1.5.1-1.5.3</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.4.1-1.4.10/>算法红皮书 1.4.1-1.4.10</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.3.3.1-1.3.4/>算法红皮书1.3.3.1-1.3.4</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.3.1.1-1.3.2.5/>算法红皮书 1.3.1.1-1.3.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.2.1-1.2.5/>算法红皮书 1.2.1-1.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.1.6-1.1.11/>算法红皮书 1.1.6-1.1.11</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.1.1-1.1.5/>算法红皮书 1.1.1-1.1.5</a></li></ul></li></ul></li><li><input type=checkbox id=section-b414f13e51dbc5e90231aa49f06e7237 class=toggle>
<label for=section-b414f13e51dbc5e90231aa49f06e7237 class="flex justify-between"><a role=button>My Batis Plus</a></label><ul><li><input type=checkbox id=section-0e4fa61015701c3d99296175840aa5d3 class=toggle>
<label for=section-0e4fa61015701c3d99296175840aa5d3 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/40-57/>mybatis-plus-sgg-40-57</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/19-39/>mybatis-plus-sgg-19-39</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/12-18/>mybatis-plus-sgg-12-18</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/01-11/>mybatis-plus-sgg-01-11</a></li></ul></li><li><a href=/zh/docs/technology/MyBatis-Plus/official/hello/>官方的hello-world</a></li></ul></li><li><input type=checkbox id=section-1e5a67821c47d147a096480c75e0d7c4 class=toggle>
<label for=section-1e5a67821c47d147a096480c75e0d7c4 class="flex justify-between"><a role=button>Flowable</a></label><ul><li><input type=checkbox id=section-0a06ca67446b7a26392adaea7b2dc30f class=toggle>
<label for=section-0a06ca67446b7a26392adaea7b2dc30f class="flex justify-between"><a role=button>基础(波哥)_</a></label><ul><li><a href=/zh/docs/technology/Flowable/boge_blbl_/03-others/>boge-03-其他</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_6/>boge-02-flowable进阶_6</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_5/>boge-02-flowable进阶_5</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_4/>boge-02-flowable进阶_4</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_3/>boge-02-flowable进阶_3</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_2/>boge-02-flowable进阶_2</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_1/>boge-02-flowable进阶_1</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/01-base/>boge-01-flowable基础</a></li></ul></li><li><input type=checkbox id=section-6019d9043956834af14f96c2f7dcd5ca class=toggle>
<label for=section-6019d9043956834af14f96c2f7dcd5ca class="flex justify-between"><a role=button>官方文档</a></label><ul><li><a href=/zh/docs/technology/Flowable/offical/05/>Flowable-05-spring-boot</a></li><li><a href=/zh/docs/technology/Flowable/offical/04/>Flowable-04-spring</a></li><li><a href=/zh/docs/technology/Flowable/offical/03/>Flowable-03-api</a></li><li><a href=/zh/docs/technology/Flowable/offical/02/>Flowable-02-Configuration</a></li><li><a href=/zh/docs/technology/Flowable/offical/01/>Flowable-01-GettingStarted</a></li></ul></li><li><a href=/zh/docs/technology/Flowable/zsx_design/01/>zsx_flowable_design01</a></li></ul></li><li><input type=checkbox id=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class=toggle>
<label for=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class="flex justify-between"><a role=button>Rocket Mq</a></label><ul><li><input type=checkbox id=section-8c49e88e8756a0a7b3e45abde3117dd5 class=toggle>
<label for=section-8c49e88e8756a0a7b3e45abde3117dd5 class="flex justify-between"><a role=button>基础(黑马)_</a></label><ul><li><a href=/zh/docs/technology/RocketMQ/heima_/05advance/>05高级功能</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/04case/>04案例</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/03messagetype/>03收发消息</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/02buildcluster/>02双主双从集群搭建</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/01base/>01rocketmq学习</a></li></ul></li></ul></li><li><input type=checkbox id=section-dcbf6163d9f750f7cc3b9417d1386331 class=toggle>
<label for=section-dcbf6163d9f750f7cc3b9417d1386331 class="flex justify-between"><a href=/zh/docs/technology/Interview/>Interview</a></label><ul><li><input type=checkbox id=section-c8fd55079fae864a8c659fb14cbb379e class=toggle>
<label for=section-c8fd55079fae864a8c659fb14cbb379e class="flex justify-between"><a role=button>Cs Basics</a></label><ul><li><input type=checkbox id=section-ac5cd91bf1acc2a16a9dbdfa9c17f629 class=toggle>
<label for=section-ac5cd91bf1acc2a16a9dbdfa9c17f629 class="flex justify-between"><a role=button>Algorithms</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/common-data-structures-leetcode-recommendations/>常见数据结构经典LeetCode题目推荐</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/linkedlist-algorithm-problems/>几道常见的链表算法题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/string-algorithm-problems/>几道常见的字符串算法题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/the-sword-refers-to-offer/>剑指offer部分编程题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/classical-algorithm-problems-recommendations/>经典算法思想总结（含LeetCode题目推荐）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/10-classical-sorting-algorithms/>十大经典排序算法总结</a></li></ul></li><li><input type=checkbox id=section-f435ca39dd71dd7765b81dd8ec05c344 class=toggle>
<label for=section-f435ca39dd71dd7765b81dd8ec05c344 class="flex justify-between"><a role=button>Data Structure</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/heap/>Index</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/bloom-filter/>布隆过滤器</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/red-black-tree/>红黑树</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li><li><input type=checkbox id=section-fa182df3abee2343aa6c977c2a75dda2 class=toggle>
<label for=section-fa182df3abee2343aa6c977c2a75dda2 class="flex justify-between"><a role=button>Network</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/network/computer-network-xiexiren-summary/>《计算机网络》（谢希仁）内容总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/arp/>ARP 协议详解(网络层)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/dns/>DNS 域名系统详解（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http1.0-vs-http1.1/>HTTP 1.0 vs HTTP 1.1（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http-vs-https/>HTTP vs HTTPS（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http-status-codes/>HTTP 常见状态码总结（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/nat/>NAT 协议详解（网络层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/osi-and-tcp-ip-model/>OSI 和 TCP/IP 网络分层模型详解（基础）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/tcp-reliability-guarantee/>TCP 传输可靠性保障（传输层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/tcp-connection-and-disconnection/>TCP 三次握手和四次挥手（传输层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/the-whole-process-of-accessing-web-pages/>访问网页的全过程（知识串联）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/other-network-questions/>计算机网络常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/other-network-questions2/>计算机网络常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/network-attack-means/>网络攻击常见手段总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/application-layer-protocol/>应用层常见协议总结（应用层）</a></li></ul></li><li><input type=checkbox id=section-76856ab8063b8754553c166410441284 class=toggle>
<label for=section-76856ab8063b8754553c166410441284 class="flex justify-between"><a role=button>Operating System</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/linux-intro/>Linux 基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/shell-intro/>Shell 编程基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-01/>操作系统常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-02/>操作系统常见面试题总结(下)</a></li></ul></li></ul></li><li><input type=checkbox id=section-fa219a2fa1e454bccf1abf45b7e68c8e class=toggle>
<label for=section-fa219a2fa1e454bccf1abf45b7e68c8e class="flex justify-between"><a role=button>Database</a></label><ul><li><input type=checkbox id=section-1e90eaf849a2719b2603214b93639e7c class=toggle>
<label for=section-1e90eaf849a2719b2603214b93639e7c class="flex justify-between"><a role=button>Elasticsearch</a></label><ul><li><a href=/zh/docs/technology/Interview/database/elasticsearch/elasticsearch-questions-01/>Elasticsearch常见面试题总结(付费)</a></li></ul></li><li><input type=checkbox id=section-36fcdf6608f26e92ce7bb1e95612ca73 class=toggle>
<label for=section-36fcdf6608f26e92ce7bb1e95612ca73 class="flex justify-between"><a role=button>Mongodb</a></label><ul><li><a href=/zh/docs/technology/Interview/database/mongodb/mongodb-questions-01/>MongoDB常见面试题总结（上）</a></li><li><a href=/zh/docs/technology/Interview/database/mongodb/mongodb-questions-02/>MongoDB常见面试题总结（下）</a></li></ul></li><li><input type=checkbox id=section-1681ed9defad2064b37ff3e603cd509c class=toggle>
<label for=section-1681ed9defad2064b37ff3e603cd509c class="flex justify-between"><a role=button>Mysql</a></label><ul><li><a href=/zh/docs/technology/Interview/database/mysql/innodb-implementation-of-mvcc/>InnoDB存储引擎对MVCC的实现</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-query-cache/>MySQL查询缓存详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/some-thoughts-on-database-storage-time/>MySQL日期类型选择建议</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-logs/>MySQL三大日志(binlog、redo log和undo log)详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/transaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-index/>MySQL索引详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/index-invalidation-caused-by-implicit-conversion/>MySQL隐式转换造成索引失效</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-query-execution-plan/>MySQL执行计划分析</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-auto-increment-primary-key-continuous/>MySQL自增主键一定是连续的吗</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/how-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/a-thousand-lines-of-mysql-study-notes/>一千行 MySQL 学习笔记</a></li></ul></li><li><input type=checkbox id=section-7b494a9accb20a42d3eb50307ebf95b8 class=toggle>
<label for=section-7b494a9accb20a42d3eb50307ebf95b8 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Interview/database/redis/3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-data-structures-02/>Redis 3 种特殊数据类型详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-data-structures-01/>Redis 5 种基本数据类型详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-questions-01/>Redis常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-questions-02/>Redis常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-common-blocking-problems-summary/>Redis常见阻塞原因总结</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-persistence/>Redis持久化机制详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-cluster/>Redis集群详解(付费)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-memory-fragmentation/>Redis内存碎片详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-skiplist/>Redis为什么用跳表实现有序集合</a></li><li><a href=/zh/docs/technology/Interview/database/redis/cache-basics/>缓存基础常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-delayed-task/>如何基于Redis实现延时任务</a></li></ul></li><li><input type=checkbox id=section-0b495945d7d1c7bace636f2809188369 class=toggle>
<label for=section-0b495945d7d1c7bace636f2809188369 class="flex justify-between"><a role=button>SQL</a></label><ul><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-01/>SQL常见面试题总结（1）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-02/>SQL常见面试题总结（2）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-03/>SQL常见面试题总结（3）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-04/>SQL常见面试题总结（4）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-05/>SQL常见面试题总结（5）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-syntax-summary/>SQL语法基础知识总结</a></li></ul></li><li><a href=/zh/docs/technology/Interview/database/nosql/>NoSQL基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/database/basis/>数据库基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/database/character-set/>字符集详解</a></li></ul></li><li><input type=checkbox id=section-9bc7f274474a2d4825bfb7e0f835ec9f class=toggle>
<label for=section-9bc7f274474a2d4825bfb7e0f835ec9f class="flex justify-between"><a role=button>Distributed System</a></label><ul><li><input type=checkbox id=section-4aa0a804a8f6d6d2745a8f9d92dbae63 class=toggle>
<label for=section-4aa0a804a8f6d6d2745a8f9d92dbae63 class="flex justify-between"><a role=button>Distributed Process Coordination</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-in-action/>ZooKeeper 实战</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus/>ZooKeeper相关概念总结(进阶)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro/>ZooKeeper相关概念总结(入门)</a></li></ul></li><li><input type=checkbox id=section-917636e43923e143cb27e958ae247d83 class=toggle>
<label for=section-917636e43923e143cb27e958ae247d83 class="flex justify-between"><a role=button>Protocol</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/cap-and-base-theorem/>CAP & BASE理论详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/gossip-protocl/>Gossip 协议详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/paxos-algorithm/>Paxos 算法详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/raft-algorithm/>Raft 算法详解</a></li></ul></li><li><input type=checkbox id=section-5f212fdd6451198aab8e6d9d1c28c4d2 class=toggle>
<label for=section-5f212fdd6451198aab8e6d9d1c28c4d2 class="flex justify-between"><a role=button>Rpc</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/dubbo/>Dubbo常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/rpc-intro/>RPC基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/httprpc/>有了 HTTP 协议，为什么还要有 RPC ？</a></li></ul></li><li><a href=/zh/docs/technology/Interview/distributed-system/api-gateway/>API网关基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/spring-cloud-gateway-questions/>Spring Cloud Gateway常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-id/>分布式ID介绍&实现方案总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-id-design/>分布式ID设计指南</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-configuration-center/>分布式配置中心常见问题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-transaction/>分布式事务常见解决方案总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-lock-implementations/>分布式锁常见实现方案总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-lock/>分布式锁介绍</a></li></ul></li><li><input type=checkbox id=section-20eb042d5085894960b2b40cdde1bd95 class=toggle>
<label for=section-20eb042d5085894960b2b40cdde1bd95 class="flex justify-between"><a role=button>High Availability</a></label><ul><li><a href=/zh/docs/technology/Interview/high-availability/timeout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/limit-request/>服务限流详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/high-availability-system-design/>高可用系统设计指南</a></li><li><a href=/zh/docs/technology/Interview/high-availability/fallback-and-circuit-breaker/>降级&熔断详解(付费)</a></li><li><a href=/zh/docs/technology/Interview/high-availability/redundancy/>冗余设计详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/performance-test/>性能测试入门</a></li></ul></li><li><input type=checkbox id=section-d863e9c02108d739d2116dee6c3f0df2 class=toggle>
<label for=section-d863e9c02108d739d2116dee6c3f0df2 class="flex justify-between"><a role=button>High Performance</a></label><ul><li><a href=/zh/docs/technology/Interview/high-performance/cdn/>CDN工作原理详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/disruptor-questions/>Disruptor常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/kafka-questions-01/>Kafka常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/rabbitmq-questions/>RabbitMQ常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/rocketmq-questions/>RocketMQ常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/sql-optimization/>常见SQL优化手段总结（付费）</a></li><li><a href=/zh/docs/technology/Interview/high-performance/read-and-write-separation-and-library-subtable/>读写分离和分库分表详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/load-balancing/>负载均衡原理及算法详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/deep-pagination-optimization/>深度分页介绍及优化建议</a></li><li><a href=/zh/docs/technology/Interview/high-performance/data-cold-hot-separation/>数据冷热分离详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/message-queue/>消息队列基础知识总结</a></li></ul></li><li><input type=checkbox id=section-2874dffbab1645c0b90b66f58878baeb class=toggle>
<label for=section-2874dffbab1645c0b90b66f58878baeb class="flex justify-between"><a role=button>High Quality Technical Articles</a></label><ul><li><input type=checkbox id=section-043c9e2ae521f883513d71615d921b93 class=toggle>
<label for=section-043c9e2ae521f883513d71615d921b93 class="flex justify-between"><a role=button>Advanced Programmer</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant/>程序员的技术成长战略</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/programmer-quickly-learn-new-technology/>程序员如何快速学习新技术</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/seven-tips-for-becoming-an-advanced-programmer/>给想成长为高级别开发同学的七条建议</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work/>工作五年之后，对技术和业务的思考</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/meituan-three-year-summary-lesson-10/>美团三年，总结的10条血泪教训</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road/>十年大厂成长之路</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/20-bad-habits-of-bad-programmers/>糟糕程序员的 20 个坏习惯</a></li></ul></li><li><input type=checkbox id=section-5a7311ea7fe807f97a6fa93dffde10b6 class=toggle>
<label for=section-5a7311ea7fe807f97a6fa93dffde10b6 class="flex justify-between"><a role=button>Interview</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/some-secrets-about-alibaba-interview/>阿里技术面试的一些秘密</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/technical-preliminary-preparation/>从面试官和候选者的角度谈如何准备技术初试</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/summary-of-spring-recruitment/>普通人的春招总结（阿里、腾讯offer）</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology/>如何在技术初试中考察程序员的技术能力</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/screen-candidates-for-packaging/>如何甄别应聘者的包装程度</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/my-personal-experience-in-2021/>校招进入飞书的个人经验</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer/>一位大龄程序员所经历的面试的历炼和思考</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-of-get-offer-from-over-20-big-companies/>斩获 20+ 大厂 offer 的面试经验分享</a></li></ul></li><li><input type=checkbox id=section-bf0bb8140b840e0af3c2632b6b73e609 class=toggle>
<label for=section-bf0bb8140b840e0af3c2632b6b73e609 class="flex justify-between"><a role=button>Personal Experience</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/four-year-work-in-tencent-summary/>从校招入职腾讯的四年工作总结</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao/>滴滴和头条两年后端工作经验分享</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/huawei-od-275-days/>华为 OD 275 天后，我进了腾讯！</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/8-years-programmer-work-summary/>一个中科大差生的 8 年程序员工作总结</a></li></ul></li><li><input type=checkbox id=section-8166233fd6553926230055376f2b97f6 class=toggle>
<label for=section-8166233fd6553926230055376f2b97f6 class="flex justify-between"><a role=button>Programmer</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/efficient-book-publishing-and-practice-guide/>程序员高效出书避坑和实践指南</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/how-do-programmers-publish-a-technical-book/>程序员怎样出版一本技术书</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/high-value-certifications-for-programmers/>程序员最该拿的几种高含金量证书</a></li></ul></li><li><input type=checkbox id=section-b607a393d7717c448e31e58c8972bbba class=toggle>
<label for=section-b607a393d7717c448e31e58c8972bbba class="flex justify-between"><a role=button>Work</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/32-tips-improving-career/>32条总结教你提升职场经验</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/employee-performance/>聊聊大厂的绩效考核</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/get-into-work-mode-quickly-when-you-join-a-company/>新入职一家公司如何快速进入工作状态</a></li></ul></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/readme/>Index</a></li></ul></li><li><input type=checkbox id=section-5680a0cf00b09d8470dc67fa0a170b89 class=toggle>
<label for=section-5680a0cf00b09d8470dc67fa0a170b89 class="flex justify-between"><a role=button>Java</a></label><ul><li><input type=checkbox id=section-6e2eabf08cfe622d9921e3edfa11e55a class=toggle>
<label for=section-6e2eabf08cfe622d9921e3edfa11e55a class="flex justify-between"><a role=button>Basis</a></label><ul><li><a href=/zh/docs/technology/Interview/java/basis/java-keyword-summary/>Index</a></li><li><a href=/zh/docs/technology/Interview/java/basis/bigdecimal/>BigDecimal 详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/spi/>Java SPI 机制详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/proxy/>Java 代理模式详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/reflection/>Java 反射机制详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/unsafe/>Java 魔法类 Unsafe 详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/serialization/>Java 序列化详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/syntactic-sugar/>Java 语法糖详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/why-there-only-value-passing-in-java/>Java 值传递详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-01/>Java基础常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-03/>Java基础常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-02/>Java基础常见面试题总结(中)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/generics-and-wildcards/>泛型&通配符详解</a></li></ul></li><li><input type=checkbox id=section-b9f81b31813c0f4b2cd6e884ad0c0511 class=toggle>
<label for=section-b9f81b31813c0f4b2cd6e884ad0c0511 class="flex justify-between"><a role=button>Collection</a></label><ul><li><a href=/zh/docs/technology/Interview/java/collection/arrayblockingqueue-source-code/>ArrayBlockingQueue 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/arraylist-source-code/>ArrayList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/concurrent-hash-map-source-code/>ConcurrentHashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/copyonwritearraylist-source-code/>CopyOnWriteArrayList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/delayqueue-source-code/>DelayQueue 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/hashmap-source-code/>HashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-questions-01/>Java集合常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-questions-02/>Java集合常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-precautions-for-use/>Java集合使用注意事项总结</a></li><li><a href=/zh/docs/technology/Interview/java/collection/linkedhashmap-source-code/>LinkedHashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/linkedlist-source-code/>LinkedList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/priorityqueue-source-code/>PriorityQueue 源码分析（付费）</a></li></ul></li><li><input type=checkbox id=section-8cc9034354bdd549787a43bea3c7c40c class=toggle>
<label for=section-8cc9034354bdd549787a43bea3c7c40c class="flex justify-between"><a role=button>Concurrent</a></label><ul><li><a href=/zh/docs/technology/Interview/java/concurrent/aqs/>AQS 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/atomic-classes/>Atomic 原子类总结</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/cas/>CAS 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/completablefuture-intro/>CompletableFuture 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-collections/>Java 常见并发容器总结</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-thread-pool-summary/>Java 线程池详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-thread-pool-best-practices/>Java 线程池最佳实践</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-01/>Java并发常见面试题总结（上）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-03/>Java并发常见面试题总结（下）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-02/>Java并发常见面试题总结（中）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/jmm/>JMM（Java 内存模型）详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/threadlocal/>ThreadLocal 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/reentrantlock/>从ReentrantLock的实现看AQS的原理及应用</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/optimistic-lock-and-pessimistic-lock/>乐观锁和悲观锁详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/virtual-thread/>虚拟线程常见问题总结</a></li></ul></li><li><input type=checkbox id=section-498d2cde022f952a6751a7ebd2a53aeb class=toggle>
<label for=section-498d2cde022f952a6751a7ebd2a53aeb class="flex justify-between"><a role=button>Io</a></label><ul><li><a href=/zh/docs/technology/Interview/java/io/io-basis/>Java IO 基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/java/io/io-model/>Java IO 模型详解</a></li><li><a href=/zh/docs/technology/Interview/java/io/io-design-patterns/>Java IO 设计模式总结</a></li><li><a href=/zh/docs/technology/Interview/java/io/nio-basis/>Java NIO 核心知识总结</a></li></ul></li><li><input type=checkbox id=section-9ee5b42dd6a7edc6e1c0a1c88bde9426 class=toggle>
<label for=section-9ee5b42dd6a7edc6e1c0a1c88bde9426 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/technology/Interview/java/jvm/memory-area/>Java内存区域详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jdk-monitoring-and-troubleshooting-tools/>JDK监控和故障处理工具总结</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-garbage-collection/>JVM垃圾回收详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-in-action/>JVM线上问题排查和性能调优案例</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-intro/>大白话带你认识 JVM</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/class-loading-process/>类加载过程详解</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/classloader/>类加载器详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/class-file-structure/>类文件结构详解</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-parameters-intro/>最重要的JVM参数总结</a></li></ul></li><li><input type=checkbox id=section-aad47cdb4b5f179b406c6cf1c6282621 class=toggle>
<label for=section-aad47cdb4b5f179b406c6cf1c6282621 class="flex justify-between"><a role=button>New Features</a></label><ul><li><a href=/zh/docs/technology/Interview/java/new-features/java8-tutorial-translate/>Index</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java10/>Java 10 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java11/>Java 11 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java12-13/>Java 12 & 13 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java14-15/>Java 14 & 15 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java16/>Java 16 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java17/>Java 17 新特性概览（重要）</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java18/>Java 18 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java19/>Java 19 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java20/>Java 20 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java21/>Java 21 新特性概览(重要)</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java22-23/>Java 22 & 23 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java9/>Java 9 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java8-common-new-features/>Java8 新特性实战</a></li></ul></li></ul></li><li><input type=checkbox id=section-f77457e1ea013328645923186d400509 class=toggle>
<label for=section-f77457e1ea013328645923186d400509 class="flex justify-between"><a role=button>System Design</a></label><ul><li><input type=checkbox id=section-a9a8bf9713340a4888a6db9d8f8eda42 class=toggle>
<label for=section-a9a8bf9713340a4888a6db9d8f8eda42 class="flex justify-between"><a role=button>Basis</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/basis/RESTfulAPI/>RestFul API 简明教程</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/unit-test/>单元测试到底是什么？应该怎么做？</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/software-engineering/>软件工程简明教程</a></li></ul></li><li><input type=checkbox id=section-3bbccee656befcd0673c7a7ef7393710 class=toggle>
<label for=section-3bbccee656befcd0673c7a7ef7393710 class="flex justify-between"><a role=button>Framework</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/async1/>Async 注解原理分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/Async/>Async 注解原理分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/ioc-and-aop/>IoC & AOP详解（快速搞懂）</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/mybatis/mybatis-interview/>MyBatis常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/netty/>Netty常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/springboot-source-code/>Spring Boot核心源码解读（付费）</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-transaction/>Spring 事务详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-design-patterns-summary/>Spring 中的设计模式详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-common-annotations/>Spring&amp;SpringBoot常用注解总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-boot-auto-assembly-principles/>SpringBoot 自动装配原理详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/springboot-knowledge-and-questions-summary/>SpringBoot常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-knowledge-and-questions-summary/>Spring常见面试题总结</a></li></ul></li><li><input type=checkbox id=section-2baa7507d4a9ede0d38490ad77045e56 class=toggle>
<label for=section-2baa7507d4a9ede0d38490ad77045e56 class="flex justify-between"><a role=button>Security</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/security/jwt-intro/>JWT 基础概念详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/advantages-and-disadvantages-of-jwt/>JWT 身份认证优缺点分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/sso-intro/>SSO 单点登录详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/encryption-algorithms/>常见加密算法总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/basis-of-authority-certification/>认证授权基础概念详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/data-desensitization/>数据脱敏方案总结</a></li></ul></li><li><a href=/zh/docs/technology/Interview/system-design/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/>Index</a></li><li><a href=/zh/docs/technology/Interview/system-design/schedule-task/>Java 定时任务详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/web-real-time-message-push/>Web 实时消息推送详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/design-pattern/>设计模式常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/system-design-questions/>系统设计常见面试题总结(付费)</a></li></ul></li><li><input type=checkbox id=section-b12b3763d379141770d4fa07f12c73ec class=toggle>
<label for=section-b12b3763d379141770d4fa07f12c73ec class="flex justify-between"><a role=button>Tools</a></label><ul><li><input type=checkbox id=section-b6832c2bda30f11dca94b5d9440b112e class=toggle>
<label for=section-b6832c2bda30f11dca94b5d9440b112e class="flex justify-between"><a role=button>Docker</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/docker/docker-intro/>Docker核心概念总结</a></li><li><a href=/zh/docs/technology/Interview/tools/docker/docker-in-action/>Docker实战</a></li></ul></li><li><input type=checkbox id=section-e383b654b47946dea2499bcb3c4bac31 class=toggle>
<label for=section-e383b654b47946dea2499bcb3c4bac31 class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/git/github-tips/>Github实用小技巧总结</a></li><li><a href=/zh/docs/technology/Interview/tools/git/git-intro/>Git核心概念总结</a></li></ul></li><li><input type=checkbox id=section-05546e7a7af454a542b00fa4a34f43a5 class=toggle>
<label for=section-05546e7a7af454a542b00fa4a34f43a5 class="flex justify-between"><a role=button>Gradle</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/gradle/gradle-core-concepts/>Gradle核心概念总结</a></li></ul></li><li><input type=checkbox id=section-139d2af6b95c327fa03497bf63e3a4f4 class=toggle>
<label for=section-139d2af6b95c327fa03497bf63e3a4f4 class="flex justify-between"><a role=button>Maven</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/maven/maven-core-concepts/>Maven核心概念总结</a></li><li><a href=/zh/docs/technology/Interview/tools/maven/maven-best-practices/>Maven最佳实践</a></li></ul></li></ul></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/problem/>问题解决</a><ul><li><input type=checkbox id=section-ef3324c710f7241c89fc009a5f576fbc class=toggle>
<label for=section-ef3324c710f7241c89fc009a5f576fbc class="flex justify-between"><a role=button>Linux</a></label><ul><li><a href=/zh/docs/problem/Linux/20250331/>平板安装linuxDeploy的问题简记</a></li><li><a href=/zh/docs/problem/Linux/20230919/>Linux操作符问题</a></li><li><a href=/zh/docs/problem/Linux/20230819/>Debian问题处理3</a></li><li><a href=/zh/docs/problem/Linux/20230817/>Debian问题处理2</a></li><li><a href=/zh/docs/problem/Linux/20230815/>Debian问题处理1</a></li><li><a href=/zh/docs/problem/Linux/20230803/>安卓手机及平板安装linuxDeploy的问题简记</a></li><li><a href=/zh/docs/problem/Linux/20230523/>zsh卸载后root无法登录及vm扩容centos7报错处理</a></li><li><a href=/zh/docs/problem/Linux/20221101/>post</a></li></ul></li><li><input type=checkbox id=section-ab4f1dd893a7409a00858148e98c245c class=toggle>
<label for=section-ab4f1dd893a7409a00858148e98c245c class="flex justify-between"><a role=button>Other</a></label><ul><li><a href=/zh/docs/problem/Other/01/>如何搜索</a></li></ul></li><li><input type=checkbox id=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class=toggle>
<label for=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/problem/JVM/20230526/>JDK代理和CGLIB代理</a></li><li><a href=/zh/docs/problem/JVM/2023052302/>linux中调试open jdk</a></li></ul></li><li><input type=checkbox id=section-a028a45b205904a783d0c60e8a184391 class=toggle>
<label for=section-a028a45b205904a783d0c60e8a184391 class="flex justify-between"><a role=button>Hexo</a></label><ul><li><a href=/zh/docs/problem/Hexo/01/>hexo在线查看pdf</a></li></ul></li><li><input type=checkbox id=section-1c55bf7a5578a7de17cc1ee45681106b class=toggle>
<label for=section-1c55bf7a5578a7de17cc1ee45681106b class="flex justify-between"><a role=button>Idea</a></label><ul><li><a href=/zh/docs/problem/Idea/01/>问题01</a></li></ul></li><li><input type=checkbox id=section-66dd985e53d8e0b78efdab983762411c class=toggle>
<label for=section-66dd985e53d8e0b78efdab983762411c class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/problem/Git/01/>git使用ssh连不上</a></li></ul></li><li><input type=checkbox id=section-9440d21f7eb9f8cf7f45b16969ab18dc class=toggle>
<label for=section-9440d21f7eb9f8cf7f45b16969ab18dc class="flex justify-between"><a role=button>Hugo</a></label><ul><li><a href=/zh/docs/problem/Hugo/p1/>hugo踩坑</a></li><li><a href=/zh/docs/problem/Hugo/01a/>图片测试(hugo踩坑)</a></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/life/>生活</a><ul><li><input type=checkbox id=section-c7f767205668758142bb8053263cc14f class=toggle>
<label for=section-c7f767205668758142bb8053263cc14f class="flex justify-between"><a role=button>往日归档</a></label><ul><li><a href=/zh/docs/life/archive/20231026/>成就</a></li><li><a href=/zh/docs/life/archive/20231013/>沉没</a></li><li><a href=/zh/docs/life/archive/20230913/>鲇鱼后思</a></li><li><a href=/zh/docs/life/archive/20230912/>病愈 有感</a></li><li><a href=/zh/docs/life/archive/20220724/>人为什么要结婚(找对象)</a></li><li><a href=/zh/docs/life/archive/20220416/>《作酒》有感</a></li><li><a href=/zh/docs/life/archive/20121226/>2021年最后一个周日</a></li><li><a href=/zh/docs/life/archive/20231021/>沉沦</a></li></ul></li><li><a href=/zh/docs/life/20250103/>随想</a></li><li><a href=/zh/docs/life/dailyExcerpt/>每日摘抄</a></li><li><a href=/zh/docs/life/20240626/>知命不惧 日日自新</a></li><li><a href=/zh/docs/life/20231227/>起床临感</a></li><li><a href=/zh/docs/life/20231101/>20231101</a></li></ul></li><li><input type=checkbox id=section-8563b93946248c7ca9d806174ae45260 class=toggle>
<label for=section-8563b93946248c7ca9d806174ae45260 class="flex justify-between"><a role=button>Culture</a></label><ul><li><input type=checkbox id=section-e17ff368fc19f19c3f48633004418234 class=toggle>
<label for=section-e17ff368fc19f19c3f48633004418234 class="flex justify-between"><a role=button>中国历代政治得失</a></label><ul><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/%E6%80%BB%E8%AE%BA/>总论</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/%E7%9B%AE%E5%BD%95_%E5%BA%8F/>目录_序</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/%E7%AC%AC%E4%B8%80%E8%AE%B2_%E6%B1%89%E4%BB%A3/>第一讲_汉代</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/%E7%AC%AC%E4%BA%94%E8%AE%B2_%E6%B8%85%E4%BB%A3/>第五讲_清代</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/%E7%AC%AC%E5%9B%9B%E8%AE%B2_%E6%98%8E%E4%BB%A3/>第四讲_明代</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/%E7%AC%AC%E4%B8%89%E8%AE%B2_%E5%AE%8B%E4%BB%A3/>第三讲_宋代</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/%E7%AC%AC%E4%BA%8C%E8%AE%B2_%E5%94%90%E4%BB%A3/>第二讲_唐代</a></li></ul></li><li><input type=checkbox id=section-5458643b5cc681aeb7589a30c20b5eca class=toggle>
<label for=section-5458643b5cc681aeb7589a30c20b5eca class="flex justify-between"><a role=button>万历十五年</a></label><ul><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/%E7%BB%8F%E5%85%B8%E7%9A%84%E5%8E%86%E7%A8%8B/>经典的历程</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/%E9%99%84%E5%BD%95/>附录</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/%E7%89%88%E6%9D%83-%E8%87%AA%E5%BA%8F/>版权-自序</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B8%87%E5%8E%86%E7%9A%87%E5%B8%9D/>第一章万历皇帝</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%B5%B7%E7%91%9E_%E5%8F%A4%E6%80%AA%E7%9A%84%E6%A8%A1%E8%8C%83%E5%AE%98%E5%83%9A/>第五章海瑞_古怪的模范官僚</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%B4%BB%E7%9D%80%E7%9A%84%E7%A5%96%E5%AE%97/>第四章活着的祖宗</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%96%E9%97%B4%E5%B7%B2%E6%97%A0%E5%BC%A0%E5%B1%85%E6%AD%A3/>第三章世间已无张居正</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%9D%8E%E8%B4%BD_%E8%87%AA%E7%9B%B8%E5%86%B2%E7%AA%81%E7%9A%84%E5%93%B2%E5%AD%A6%E5%AE%B6/>第七章李贽_自相冲突的哲学家</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%88%9A%E7%BB%A7%E5%85%89_%E5%AD%A4%E7%8B%AC%E7%9A%84%E5%B0%86%E9%A2%86/>第六章戚继光_孤独的将领</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%A6%96%E8%BE%85%E7%94%B3%E6%97%B6%E8%A1%8C/>第二章首辅申时行</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/%E5%8F%82%E8%80%83%E4%B9%A6%E7%9B%AE/>参考书目</a></li></ul></li><li><input type=checkbox id=section-25bf8aa304781904e13d45dd3ed174ca class=toggle>
<label for=section-25bf8aa304781904e13d45dd3ed174ca class="flex justify-between"><a role=button>国学的天空_傅佩荣</a></label><ul><li><a href=/zh/docs/culture/%E5%9B%BD%E5%AD%A6%E7%9A%84%E5%A4%A9%E7%A9%BA_%E5%82%85%E4%BD%A9%E8%8D%A3/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83-%E5%89%8D%E8%A8%80/>封面-版权-前言</a></li><li><a href=/zh/docs/culture/%E5%9B%BD%E5%AD%A6%E7%9A%84%E5%A4%A9%E7%A9%BA_%E5%82%85%E4%BD%A9%E8%8D%A3/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%AD%94%E5%AD%90%E7%9A%84%E7%9C%9F%E8%AF%9A/>第一部孔子的真诚</a></li><li><a href=/zh/docs/culture/%E5%9B%BD%E5%AD%A6%E7%9A%84%E5%A4%A9%E7%A9%BA_%E5%82%85%E4%BD%A9%E8%8D%A3/%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%BA%84%E5%AD%90%E7%9A%84%E9%80%8D%E9%81%A5/>第四部庄子的逍遥</a></li><li><a href=/zh/docs/culture/%E5%9B%BD%E5%AD%A6%E7%9A%84%E5%A4%A9%E7%A9%BA_%E5%82%85%E4%BD%A9%E8%8D%A3/%E7%AC%AC%E4%B8%89%E9%83%A8%E8%80%81%E5%AD%90%E7%9A%84%E6%99%BA%E6%85%A7/>第三部老子的智慧</a></li><li><a href=/zh/docs/culture/%E5%9B%BD%E5%AD%A6%E7%9A%84%E5%A4%A9%E7%A9%BA_%E5%82%85%E4%BD%A9%E8%8D%A3/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%AD%9F%E5%AD%90%E7%9A%84%E5%90%91%E5%96%84/>第二部孟子的向善</a></li></ul></li><li><input type=checkbox id=section-2a1be704b60228104c555da78b998e92 class=toggle>
<label for=section-2a1be704b60228104c555da78b998e92 class="flex justify-between"><a role=button>易经真的很容易</a></label><ul><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93/%E7%BB%93%E8%AF%AD/>结语</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93/%E9%99%84%E5%BD%95/>附录</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83-%E5%89%8D%E8%A8%80/>封面-版权-前言</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93/01%E6%98%93%E7%BB%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%AD%A6%E9%97%AE/>01易经是什么样的学问</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93/05%E6%80%8E%E6%A0%B7%E8%B6%8B%E5%90%89%E9%81%BF%E5%87%B6/>05怎样趋吉避凶</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93/04%E8%83%BD%E9%A2%84%E6%B5%8B%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%8F%98%E5%8C%96%E5%90%97/>04能预测未来的变化吗</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93/10%E6%98%93%E5%AD%A6%E7%9A%84%E5%8A%9F%E8%83%BD%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/>10易学的功能到底是什么</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93/03%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%90%88%E7%90%86%E5%AE%9A%E4%BD%8D/>03为什么需要合理定位</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93/07%E5%AE%87%E5%AE%99%E5%8F%AF%E8%83%BD%E6%B0%B8%E7%BB%AD%E7%BB%8F%E8%90%A5%E5%90%97/>07宇宙可能永续经营吗</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93/06%E9%81%93%E5%BE%B7%E4%BF%AE%E5%85%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%9A%E4%BA%BA%E7%9A%84%E6%A0%B9%E6%9C%AC/>06道德修养为什么是做人的根本</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93/09%E6%98%93%E5%AD%A6%E7%9A%84%E7%A5%9E%E6%98%AF%E4%BB%80%E4%B9%88/>09易学的神是什么</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93/02%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A9%E4%BA%BA%E5%8F%AF%E4%BB%A5%E5%90%88%E4%B8%80/>02为什么天人可以合一</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93/08%E6%98%93%E7%BB%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E5%BC%80%E5%A7%8B%E7%9A%84/>08易经是怎样开始的</a></li></ul></li><li><input type=checkbox id=section-c790e210cbf7f66f13ff6eea57f8a1c4 class=toggle>
<label for=section-c790e210cbf7f66f13ff6eea57f8a1c4 class="flex justify-between"><a role=button>论语的生活智慧</a></label><ul><li><input type=checkbox id=section-8dfb9c11161c3cc789d196fdefb4da07 class=toggle>
<label for=section-8dfb9c11161c3cc789d196fdefb4da07 class="flex justify-between"><a role=button>下</a></label><ul><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8B/19%E5%AD%90%E5%BC%A0%E7%AC%AC%E5%8D%81%E4%B9%9D/>19子张第十九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8B/13%E5%AD%90%E8%B7%AF%E7%AC%AC%E5%8D%81%E4%B8%89/>13子路第十三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8B/20%E5%B0%A7%E6%9B%B0%E7%AC%AC%E4%BA%8C%E5%8D%81/>20尧曰第二十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8B/17%E9%98%B3%E8%B4%A7%E7%AC%AC%E5%8D%81%E4%B8%83/>17阳货第十七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8B/12%E9%A2%9C%E6%B8%8A%E7%AC%AC%E5%8D%81%E4%BA%8C/>12颜渊第十二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8B/14%E5%AE%AA%E9%97%AE%E7%AC%AC%E5%8D%81%E5%9B%9B/>14宪问第十四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8B/11%E5%85%88%E8%BF%9B%E7%AC%AC%E5%8D%81%E4%B8%80/>11先进第十一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8B/18%E5%BE%AE%E5%AD%90%E7%AC%AC%E5%8D%81%E5%85%AB/>18微子第十八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8B/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AC%AC%E5%8D%81%E4%BA%94/>15卫灵公第十五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8B/16%E5%AD%A3%E6%B0%8F%E7%AC%AC%E5%8D%81%E5%85%AD/>16季氏第十六</a></li></ul></li><li><input type=checkbox id=section-b72a47a1c9c55833499c73871c7ce073 class=toggle>
<label for=section-b72a47a1c9c55833499c73871c7ce073 class="flex justify-between"><a role=button>上</a></label><ul><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8A/09%E5%AD%90%E7%BD%95%E7%AC%AC%E4%B9%9D/>09子罕第九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8A/06%E9%9B%8D%E4%B9%9F%E7%AC%AC%E5%85%AD/>06雍也第六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8A/01%E5%AD%A6%E5%A4%A9%E7%AC%AC%E4%B8%80/>01学天第一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8A/10%E4%B9%A1%E5%85%9A%E7%AC%AC%E5%8D%81/>10乡党第十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8A/02%E4%B8%BA%E6%94%BF%E7%AC%AC%E4%BA%8C/>02为政第二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8A/08%E6%B3%B0%E4%BC%AF%E7%AC%AC%E5%85%AB/>08泰伯第八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8A/07%E8%BF%B0%E5%A4%A9%E7%AC%AC%E4%B8%83/>07述天第七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8A/04%E9%87%8C%E4%BB%81%E7%AC%AC%E5%9B%9B/>04里仁第四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8A/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AC%AC%E4%BA%94/>05公冶长第五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8A/%E5%B0%81%E9%9D%A2-%E4%B9%A6%E5%90%8D-%E5%89%8D%E8%A8%80-%E7%BC%96%E8%80%85-%E7%9B%AE%E5%BD%95/>封面-书名-前言-编者-目录</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/%E4%B8%8A/03%E5%85%AB%E4%BD%BE%E7%AC%AC%E4%B8%89/>03八佾第三</a></li></ul></li></ul></li><li><input type=checkbox id=section-abcb4c073d0fcf577d195a21f3ae1356 class=toggle>
<label for=section-abcb4c073d0fcf577d195a21f3ae1356 class="flex justify-between"><a role=button>吕氏春秋</a></label><ul><li><input type=checkbox id=section-5d036be7451d03de7180ed3b51930184 class=toggle>
<label for=section-5d036be7451d03de7180ed3b51930184 class="flex justify-between"><a role=button>上册</a></label><ul><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/05%E4%BB%B2%E5%A4%8F%E7%BA%AA%E7%AC%AC%E4%BA%94/>05仲夏纪第五</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/08%E4%BB%B2%E7%A7%8B%E7%BA%AA%E7%AC%AC%E5%85%AB/>08仲秋纪第八</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/11%E4%BB%B2%E5%86%AC%E7%BA%AA%E7%AC%AC%E5%8D%81%E4%B8%80/>11仲冬纪第十一</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/02%E4%BB%B2%E6%98%A5%E7%BA%AA%E7%AC%AC%E4%BA%8C/>02仲春纪第二</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/13%E6%9C%89%E5%A7%8B%E8%A7%88%E7%AC%AC%E4%B8%80/>13有始览第一</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/14%E5%AD%9D%E8%A1%8C%E8%A7%88%E7%AC%AC%E4%BA%8C/>14孝行览第二</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/16%E5%85%88%E8%AF%86%E8%A7%88%E7%AC%AC%E5%9B%9B/>16先识览第四</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/15%E6%85%8E%E5%A4%A7%E8%A7%88%E7%AC%AC%E4%B8%89/>15慎大览第三</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/04%E5%AD%9F%E5%A4%8F%E7%BA%AA%E7%AC%AC%E5%9B%9B/>04孟夏纪第四</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/07%E5%AD%9F%E7%A7%8B%E7%BA%AA%E7%AC%AC%E4%B8%83/>07孟秋纪第七</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/10%E5%AD%9F%E5%86%AC%E7%BA%AA%E7%AC%AC%E5%8D%81/>10孟冬纪第十</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/01%E5%AD%9F%E6%98%A5%E7%BA%AA%E7%AC%AC%E4%B8%80/>01孟春纪第一</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/06%E5%AD%A3%E5%A4%8F%E7%BA%AA%E7%AC%AC%E5%85%AD/>06季夏纪第六</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/09%E5%AD%A3%E7%A7%8B%E7%BA%AA%E7%AC%AC%E4%B9%9D/>09季秋纪第九</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/12%E5%AD%A3%E5%86%AC%E7%BA%AA%E7%AC%AC%E5%8D%81%E4%BA%8C/>12季冬纪第十二</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8A%E5%86%8C/03%E5%AD%A3%E6%98%A5%E7%BA%AA%E7%AC%AC%E4%B8%89/>03季春纪第三</a></li></ul></li><li><input type=checkbox id=section-3d3d8ca290c4bf707503707fa529950b class=toggle>
<label for=section-3d3d8ca290c4bf707503707fa529950b class="flex justify-between"><a role=button>下册</a></label><ul><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8B%E5%86%8C/25%E4%BC%BC%E9%A1%BA%E8%AE%BA%E7%AC%AC%E4%BA%94/>25似顺论第五</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8B%E5%86%8C/26%E5%A3%AB%E5%AE%B9%E8%AE%BA%E7%AC%AC%E5%85%AD/>26士容论第六</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8B%E5%86%8C/20%E6%81%83%E5%90%9B%E8%A7%88%E7%AC%AC%E5%85%AB/>20恃君览第八</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8B%E5%86%8C/18%E5%AE%A1%E5%BA%94%E8%A7%88%E7%AC%AC%E5%85%AD/>18审应览第六</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8B%E5%86%8C/22%E6%85%8E%E8%A1%8C%E8%AE%BA%E7%AC%AC%E4%BA%8C/>22慎行论第二</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8B%E5%86%8C/17%E5%AE%A1%E5%88%86%E8%A7%88%E7%AC%AC%E4%BA%94/>17审分览第五</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8B%E5%86%8C/19%E7%A6%BB%E4%BF%97%E8%A7%88%E7%AC%AC%E4%B8%83/>19离俗览第七</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8B%E5%86%8C/21%E5%BC%80%E6%98%A5%E8%AE%BA%E7%AC%AC%E4%B8%80/>21开春论第一</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8B%E5%86%8C/23%E8%B4%B5%E7%9B%B4%E8%AE%BA%E7%AC%AC%E4%B8%89/>23贵直论第三</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B8%8B%E5%86%8C/24%E4%B8%8D%E8%8B%9F%E8%AE%BA%E7%AC%AC%E5%9B%9B/>24不苟论第四</a></li></ul></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/%E4%B9%A6%E5%90%8D-%E5%89%8D%E8%A8%80-%E7%9B%AE%E5%BD%95/>书名-前言-目录</a></li></ul></li><li><input type=checkbox id=section-b8eda9fc7502eac7b68386b9c9edef56 class=toggle>
<label for=section-b8eda9fc7502eac7b68386b9c9edef56 class="flex justify-between"><a role=button>汉字就是这么来的</a></label><ul><li><a href=/zh/docs/culture/%E6%B1%89%E5%AD%97%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E6%9D%A5%E7%9A%84/01%E8%B5%B0%E8%BF%9B%E6%B1%89%E5%AD%97%E4%B8%96%E7%95%8C/>01走进汉字世界</a></li></ul></li><li><input type=checkbox id=section-36af101672fdef38bd3af078cbe1e845 class=toggle>
<label for=section-36af101672fdef38bd3af078cbe1e845 class="flex justify-between"><a role=button>天纪</a></label><ul><li><span>人间道</span><ul><li><input type=checkbox id=section-c36005c9ebaefb7d6ad1c4b3beef5892 class=toggle>
<label for=section-c36005c9ebaefb7d6ad1c4b3beef5892 class="flex justify-between"><a role=button>下经</a></label><ul><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/64%E7%81%AB%E6%B0%B4%E6%9C%AA%E6%BF%9F/>64火水未濟</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/63%E6%B0%B4%E7%81%AB%E6%97%A2%E6%BF%9F/>63水火既濟</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/62%E9%9B%B7%E5%B1%B1%E5%B0%8F%E9%81%8E/>62雷山小過</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/61%E9%A2%A8%E6%BE%A4%E4%B8%AD%E5%AD%9A/>61風澤中孚</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/60%E6%B0%B4%E6%BE%A4%E7%AF%80/>60水澤節</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/59%E9%A2%A8%E6%B0%B4%E6%B8%99/>59風水渙</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/58%E5%85%8C%E7%88%B2%E6%BE%A4/>58兌爲澤</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/57%E5%B7%BD%E7%82%BA%E9%A2%A8/>57巽為風</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/56%E7%81%AB%E5%B1%B1%E6%97%85/>56火山旅</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/55%E9%9B%B7%E7%81%AB%E8%B1%90/>55雷火豐</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/54%E9%9B%B7%E6%BE%A4%E6%AD%B8%E5%A6%B9/>54雷澤歸妹</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/53%E9%A2%A8%E5%B1%B1%E6%BC%B8/>53風山漸</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/52%E8%89%AE%E7%82%BA%E5%B1%B1/>52艮為山</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/51%E9%9C%87%E7%88%B2%E9%9B%B7/>51震爲雷</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/50%E7%81%AB%E9%A2%A8%E9%BC%8E/>50火風鼎</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/49%E6%BE%A4%E7%81%AB%E9%9D%A9/>49澤火革</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/48%E6%B0%B4%E9%A2%A8%E4%BA%95/>48水風井</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/47%E6%BE%A4%E6%B0%B4%E5%9B%B0/>47澤水困</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/46%E5%9C%B0%E9%A2%A8%E5%8D%87/>46地風升</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/45%E6%BE%A4%E5%9C%B0%E8%90%83/>45澤地萃</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/44%E5%A4%A9%E9%A2%A8%E5%A7%A4/>44天風姤</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/43%E6%BE%A4%E5%A4%A9%E5%A4%AC/>43澤天夬</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/42%E9%A2%A8%E9%9B%B7%E7%9B%8A/>42風雷益</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/41%E5%B1%B1%E6%BE%A4%E6%90%8D/>41山澤損</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/40%E9%9B%B7%E6%B0%B4%E8%A7%A3/>40雷水解</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/39%E6%B0%B4%E5%B1%B1%E8%B9%87/>39水山蹇</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/38%E7%81%AB%E6%BE%A4%E7%9D%BD/>38火澤睽</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/37%E9%A2%A8%E7%81%AB%E5%AE%B6%E4%BA%BA/>37風火家人</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/36%E5%9C%B0%E7%81%AB%E6%98%8E%E5%A4%B7/>36地火明夷</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/35%E7%81%AB%E5%9C%B0%E6%99%89/>35火地晉</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/34%E9%9B%B7%E5%A4%A9%E5%A4%A7%E5%A3%AF/>34雷天大壯</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/33%E5%A4%A9%E5%B1%B1%E9%81%AF/>33天山遯</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/32%E9%9B%B7%E9%A2%A8%E6%81%86/>32雷風恆</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/31%E6%BE%A4%E5%B1%B1%E5%92%B8/>31澤山咸</a></li></ul></li><li><input type=checkbox id=section-15975a28a78c108ecbf451806d35782b class=toggle>
<label for=section-15975a28a78c108ecbf451806d35782b class="flex justify-between"><a role=button>上经</a></label><ul><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/30%E9%9B%A2%E7%82%BA%E7%81%AB/>30離為火</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/29%E5%9D%8E%E7%88%B2%E6%B0%B4/>29坎爲水</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/28%E6%BE%A4%E9%A2%A8%E5%A4%A7%E9%81%8E/>28澤風大過</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/27%E5%B1%B1%E9%9B%B7%E9%A0%A4/>27山雷頤</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/26%E5%B1%B1%E5%A4%A9%E5%A4%A7%E7%95%9C/>26山天大畜</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/25%E5%A4%A9%E9%9B%B7%E6%97%A0%E5%A6%84/>25天雷无妄</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/24%E5%9C%B0%E9%9B%B7%E5%BE%A9/>24地雷復</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/23%E5%B1%B1%E5%9C%B0%E5%89%9D/>23山地剝</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/22%E5%B1%B1%E7%81%AB%E8%B3%81/>22山火賁</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/21%E7%81%AB%E9%9B%B7%E5%99%AC%E5%97%91/>21火雷噬嗑</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/20%E9%A2%A8%E5%9C%B0%E8%A7%80/>20風地觀</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/19%E5%9C%B0%E6%BE%A4%E8%87%A8/>19地澤臨</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/18%E5%B1%B1%E9%A2%A8%E8%A0%B1/>18山風蠱</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/17%E6%BE%A4%E9%9B%B7%E9%9A%A8/>17澤雷隨</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/16%E9%9B%B7%E5%9C%B0%E8%B1%AB/>16雷地豫</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/15%E5%9C%B0%E5%B1%B1%E8%AC%99/>15地山謙</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/14%E7%81%AB%E5%A4%A9%E5%A4%A7%E6%9C%89/>14火天大有</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/13%E5%A4%A9%E7%81%AB%E5%90%8C%E4%BA%BA/>13天火同人</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/12%E5%A4%A9%E5%9C%B0%E5%90%A6/>12天地否</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/11%E5%9C%B0%E5%A4%A9%E6%B3%B0/>11地天泰</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/10%E5%A4%A9%E6%B3%BD%E5%B1%A5/>10天澤履</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/09%E9%A2%A8%E5%A4%A9%E5%B0%8F%E7%95%9C/>09風天小畜</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/08%E6%B0%B4%E5%9C%B0%E6%AF%94/>08水地比</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/07%E5%9C%B0%E6%B0%B4%E5%B8%AB/>07地水師</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/06%E5%A4%A9%E6%B0%B4%E8%AE%BC/>06天水讼</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/05%E6%B0%B4%E5%A4%A9%E9%9C%80/>05水天需</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/04%E5%B1%B1%E6%B0%B4%E8%92%99/>04山水蒙</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/03%E6%B0%B4%E9%9B%B7%E5%B1%AF/>03水雷屯</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/02%E5%9D%A4%E4%B8%BA%E5%9C%B0/>02坤爲地</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/01%E4%B9%BE%E4%B8%BA%E5%A4%A9/>01乾爲天</a></li></ul></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/0%E5%BA%8F/>序</a></li></ul></li></ul></li><li><input type=checkbox id=section-2caf93f41e261fb08fbc8abd7e4170d5 class=toggle>
<label for=section-2caf93f41e261fb08fbc8abd7e4170d5 class="flex justify-between"><a role=button>论语</a></label><ul><li><input type=checkbox id=section-0d6e955a0862e2b200af0e2a2f889dd6 class=toggle>
<label for=section-0d6e955a0862e2b200af0e2a2f889dd6 class="flex justify-between"><a role=button>论语译注 杨伯峻</a></label><ul><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/19%E5%AD%90%E5%BC%A0%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B9%9D/>19子张篇第十九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/13%E5%AD%90%E8%B7%AF%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%89/>13子路篇第十三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/09%E5%AD%90%E7%BD%95%E7%AF%87%E7%AC%AC%E4%B9%9D/>09子罕篇第九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/06%E9%9B%8D%E4%B9%9F%E7%AF%87%E7%AC%AC%E5%85%AD/>06雍也篇第六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/20%E5%B0%A7%E6%9B%B0%E7%AF%87%E7%AC%AC%E4%BA%8C%E5%8D%81/>20尧曰篇第二十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/17%E9%98%B3%E8%B4%A7%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%83/>17阳货篇第十七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/12%E9%A2%9C%E6%B8%8A%E7%AF%87%E7%AC%AC%E5%8D%81%E4%BA%8C/>12颜渊篇第十二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/01%E5%AD%A6%E8%80%8C%E7%AF%87%E7%AC%AC%E4%B8%80/>01学而篇第一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/10%E4%B9%A1%E5%85%9A%E7%AF%87%E7%AC%AC%E5%8D%81/>10乡党篇第十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/14%E5%AE%AA%E9%97%AE%E7%AF%87%E7%AC%AC%E5%8D%81%E5%9B%9B/>14宪问篇第十四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/11%E5%85%88%E8%BF%9B%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%80/>11先进篇第十一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/18%E5%BE%AE%E5%AD%90%E7%AF%87%E7%AC%AC%E5%8D%81%E5%85%AB/>18微子篇第十八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/02%E4%B8%BA%E6%94%BF%E7%AF%87%E7%AC%AC%E4%BA%8C/>02为政篇第二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AF%87%E7%AC%AC%E5%8D%81%E4%BA%94/>15卫灵公篇第十五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/08%E6%B3%B0%E4%BC%AF%E7%AF%87%E7%AC%AC%E5%85%AB/>08泰伯篇第八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/07%E8%BF%B0%E8%80%8C%E7%AF%87%E7%AC%AC%E4%B8%83/>07述而篇第七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/%E8%AF%95%E8%AE%BA-%E5%AF%BC%E8%A8%80-%E4%BE%8B%E8%A8%80/>试论-导言-例言</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/04%E9%87%8C%E4%BB%81%E7%AF%87%E7%AC%AC%E5%9B%9B/>04里仁篇第四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/16%E5%AD%A3%E6%B0%8F%E7%AF%87%E7%AC%AC%E5%8D%81%E5%85%AD/>16季氏篇第十六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AF%87%E7%AC%AC%E4%BA%94/>05公冶长篇第五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/03%E5%85%AB%E4%BD%BE%E7%AF%87%E7%AC%AC%E4%B8%89/>03八佾篇第三</a></li></ul></li><li><input type=checkbox id=section-3c0bd8b9ce8b9615dcc02b6df6e7788e class=toggle>
<label for=section-3c0bd8b9ce8b9615dcc02b6df6e7788e class="flex justify-between"><a role=button>论语的生活智慧</a></label><ul><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/01%E5%AD%A6%E5%A4%A9%E7%AC%AC%E4%B8%80/>01学天第一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/02%E4%B8%BA%E6%94%BF%E7%AC%AC%E4%BA%8C/>02为政第二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/03%E5%85%AB%E4%BD%BE%E7%AC%AC%E4%B8%89/>03八佾第三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/04%E9%87%8C%E4%BB%81%E7%AC%AC%E5%9B%9B/>04里仁第四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AC%AC%E4%BA%94/>05公治长第五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/06%E9%9B%8D%E4%B9%9F%E7%AC%AC%E5%85%AD/>06雍也第六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/07%E8%BF%B0%E8%80%8C%E7%AC%AC%E4%B8%83/>07述而第七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/08%E6%B3%B0%E4%BC%AF%E7%AC%AC%E5%85%AB/>08泰伯第八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/09%E5%AD%90%E7%BD%95%E7%AC%AC%E4%B9%9D/>09子罕第九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/10%E4%B9%A1%E5%85%9A%E7%AC%AC%E5%8D%81/>10乡党第十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/11%E5%85%88%E8%BF%9B%E7%AC%AC%E5%8D%81%E4%B8%80/>11先进第十一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/12%E9%A2%9C%E6%B8%8A%E7%AC%AC%E5%8D%81%E4%BA%8C/>12颜渊第十二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/13%E5%AD%90%E8%B7%AF%E7%AC%AC%E5%8D%81%E4%B8%89/>13子路第十三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/14%E5%AE%AA%E9%97%AE%E7%AC%AC%E5%8D%81%E5%9B%9B/>14宪问第十四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AC%AC%E5%8D%81%E4%BA%94/>15卫灵公第十五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/16%E5%AD%A3%E6%B0%8F%E7%AC%AC%E5%8D%81%E5%85%AD/>16季氏第十六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/17%E9%98%B3%E8%B4%A7%E7%AC%AC%E5%8D%81%E4%B8%83/>17阳货第十七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/18%E5%BE%AE%E5%AD%90%E7%AC%AC%E5%8D%81%E5%85%AB/>18微子第十八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/19%E5%AD%90%E5%BC%A0%E7%AC%AC%E5%8D%81%E4%B9%9D/>19子张第十九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/20%E5%B0%A7%E6%97%A5%E7%AC%AC%E4%BA%8C%E5%8D%81/>20尧日第二十</a></li></ul></li></ul></li><li><input type=checkbox id=section-daa70c3e612b40fe4050f5185bb12608 class=toggle>
<label for=section-daa70c3e612b40fe4050f5185bb12608 class="flex justify-between"><a role=button>恰同学少年</a></label><ul><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AE%80%E4%BB%8B-%E4%BD%9C%E8%80%85/>简介-作者</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/>经典语录</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC1%E7%AB%A0-%E7%AC%AC5%E7%AB%A0/>第1章-第5章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC11%E7%AB%A0-%E7%AC%AC15%E7%AB%A0/>第11章-第15章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC16%E7%AB%A0-%E7%AC%AC20%E7%AB%A0/>第16章-第20章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC6%E7%AB%A0-%E7%AC%AC10%E7%AB%A0/>第6章-第10章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC21%E7%AB%A0-%E7%AC%AC25%E7%AB%A0/>第21章-第25章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC26%E7%AB%A0-%E7%AC%AC29%E7%AB%A0/>第26章-第29章</a></li></ul></li><li><input type=checkbox id=section-ab50087f003d55e32dba86fb838050b9 class=toggle>
<label for=section-ab50087f003d55e32dba86fb838050b9 class="flex justify-between"><a role=button>如何阅读一本书</a></label><ul><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E9%99%84%E5%BD%95/>附录</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AE%80%E4%BB%8B-%E5%BA%8F%E8%A8%80/>简介-序言</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%B8%80%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E5%B1%82%E6%AC%A1/>第一篇 阅读的层次</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E5%9B%9B%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E6%9C%80%E7%BB%88%E7%9B%AE%E6%A0%87/>第四篇 阅读的最终目标</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%B8%89%E7%AF%87_%E9%98%85%E8%AF%BB%E4%B8%8D%E5%90%8C%E8%AF%BB%E7%89%A9%E7%9A%84%E6%96%B9%E6%B3%95/>第三篇 阅读不同读物的方法</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%BA%8C%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1_%E5%88%86%E6%9E%90%E9%98%85%E8%AF%BB/>第二篇 阅读的第三个层次：分析阅读</a></li></ul></li><li><input type=checkbox id=section-3c72e7201480f45e35bf243c48374c4a class=toggle>
<label for=section-3c72e7201480f45e35bf243c48374c4a class="flex justify-between"><a role=button>古代天文历法讲座</a></label><ul><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E9%99%84%E5%BD%95-%E9%99%84%E8%A1%A8-%E5%90%8E%E8%AE%B0/>附录-附表-后记</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC6%E8%AE%B2-%E7%AC%AC7%E8%AE%B2/>第6讲-第7讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC4%E8%AE%B2-%E7%AC%AC5%E8%AE%B2/>第4讲-第5讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC1%E8%AE%B2-%E7%AC%AC3%E8%AE%B2/>第1讲-第3讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%89%88%E6%9D%83-%E5%BA%8F-%E5%89%8D%E8%A8%80/>版权-序-前言</a></li></ul></li><li><input type=checkbox id=section-9d5fdf0456d3af9d5079c94a509d2900 class=toggle>
<label for=section-9d5fdf0456d3af9d5079c94a509d2900 class="flex justify-between"><a role=button>置身事内</a></label><ul><li><a href=/zh/docs/culture/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/%E4%B8%8B%E7%AF%87/>下篇</a></li><li><a href=/zh/docs/culture/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/%E4%B8%8A%E7%AF%87/>上篇</a></li></ul></li><li><input type=checkbox id=section-51674e319d079fc9a9944a0500f74ff3 class=toggle>
<label for=section-51674e319d079fc9a9944a0500f74ff3 class="flex justify-between"><a role=button>中国通史 吕思勉</a></label><ul><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2_%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8B%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%96%87%E5%8C%96%E5%8F%B2/>下编-中国文化史</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2_%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8A%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%8F%B2/>上编-中国政治史</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2_%E5%90%95%E6%80%9D%E5%8B%89/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83-%E8%AF%BB%E5%90%8E-%E8%87%AA%E5%BA%8F/>封面-版权-读后-自序</a></li></ul></li><li><input type=checkbox id=section-77e618b9fdc931e63e2343a70dbe6630 class=toggle>
<label for=section-77e618b9fdc931e63e2343a70dbe6630 class="flex justify-between"><a role=button>资治通鉴</a></label><ul><li><input type=checkbox id=section-196ebc38f91a63032ca3483e389aa4c5 class=toggle>
<label for=section-196ebc38f91a63032ca3483e389aa4c5 class="flex justify-between"><a role=button>周纪</a></label><ul><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/>基本知识</a></li><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/001%E5%91%A8%E7%BA%AA%E4%B8%80/>001周纪一</a></li></ul></li></ul></li><li><input type=checkbox id=section-5aa85019131e2605fa7465dc987f590d class=toggle>
<label for=section-5aa85019131e2605fa7465dc987f590d class="flex justify-between"><a role=button>增广贤文</a></label><ul></ul></li><li><a href=/zh/docs/culture/%E6%B4%BB%E7%9D%80/>活着</a></li><li><a href=/zh/docs/culture/%E5%BA%84%E5%AD%90%E5%BF%83%E5%BE%97_%E5%82%85%E4%BD%A9%E8%8D%A3/>庄子心得_傅佩荣</a></li></ul></li><li class=book-section-flat><a href=/zh/docs/test/>测试</a><ul><li><a href=/zh/docs/test/test2/>test2</a></li><li><a href=/zh/docs/test/mytest/>test</a></li><li><a href=/zh/docs/test/hello2/>pdfTest</a></li></ul></li></ul><ul><li><a href=/zh/posts/>博客</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Index</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><ul><li></li></ul></li><li><a href=#img1129d8f07f3deaf9439a791f1cce81d1jpeg之-imgbae90b00348e3e736832474da360f580jpeg><img src=img/1129d8f07f3deaf9439a791f1cce81d1.jpeg alt>之 <img src=img/bae90b00348e3e736832474da360f580.jpeg alt></a><ul><li></li><li><a href=#->。 。</a></li></ul></li></ul></li><li><a href=#heading>=</a><ul><li><ul><li></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><p>－－－</p><p>第 6 章</p><p>H A P T E R 6</p><h4 id=存储器层次结构>存储器层次结构
<a class=anchor href=#%e5%ad%98%e5%82%a8%e5%99%a8%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84>#</a></h4><p>到目前 为止，在对系 统的研究中， 我们依赖千一 个简单的计算机系统 模型， C P U 执行指令，而 存储器系统为 CP U 存放指令和数据。在简单模型中， 存储器系统是一个线性的字节数组， 而 CP U 能够在一个常数时间内访问每个存储器位置。虽然迄今为止这都是一个有效的模型， 但是它没有反映现代系统 实际工作的方式。</p><p>实际上， 存储器 系统( m em o r y s ys te m ) 是一个具有不同容量、成本和访问 时间的存储设备的层 次结构。CP U 寄存器保存着最常用的数据。靠近 C P U 的小的、快 速的 高速 缓存存储器 ( cache memor y) 作为一部分存储在相对慢速的 主存储器( main mem o r y ) 中数据和指令的缓冲区域。主存缓存存储在容量较大的、慢速磁盘上的数据，而这些磁盘常常又作为 存储在通过网络连接的其他机器的磁盘或磁带上的数据的缓冲区域。</p><p>存储器层次 结构是可行的，这 是因为与下 一个更低层次的存储设备相比来说， 一个编写良好的程序倾向千更频繁地访问某一个层次上的存储设 备。所以， 下一层的存储设备可以更慢速 一点，也 因此可以更大， 每个比特位更便宜。整体效果是一个大的存储器池， 其成本与 层次结构底层最便宜的存储设备相当， 但是却以接近于层次结构顶部存储设备的高 速率向程序 提供数据。</p><p>作为一个 程序员 ， 你需要理解存储器层次结构， 因为它对应用程序的性能有着巨大的影响。如果你的程序需要的数据是存储在 C P U 寄存器中的 ， 那么在指令的执行期间， 在 0 个周期内 就能访问 到它们。如果存储在高速缓存中，需 要 4 ~ 75 个周期。如果存储在主存中，需要上百个周期 。而如果存 储在磁盘上，需 要 大约几千万个周期！</p><p>这里就是计算机系统中一个基本而持久的思想：如果你理解了系统是如何将数据在存 储器层次结构中上上下下移动的，那么你就可以编写自己的应用程序，使得它们的数据项 存储在层次结构 中较高的地方 ， 在那里 CP U 能更快地访问到它们。</p><p>这个思想围 绕着计算 机程序的一 个称为局部性 (l oca lit y ) 的基本属性 。具有良好局部性的程序倾向于一次又一次地访问 相同的数据项集合 ， 或是倾向于访问 邻近的 数据项集合。具有良好局部性的程序比局部性差的程序更多 地倾向 于从存储器层次 结构中较高层次处访问数据项， 因此运行得更快。例如， 在 C ore i7 系统， 不同的矩阵乘法核心程序执行相同数量的算术操作， 但是有不同程度的局部性， 它们的运行时间可以 相差 40 倍！</p><p>在本章中 ， 我们会看看基本的存储技术一 SRA M 存储器、DRAM 存储器、ROM 存储器以及旋转的 和固态的硬盘一一－并描述它们是如何被组织成层次结 构的。特别地， 我们将注意力集中在高 速缓存存储器上， 它是作为 C P U 和主存之间的缓存区域， 因为它们对应用程序性能的 影响最大。我们向你展示如何分析 C 程序的 局部性， 并且介绍改进你的程序中局部性的技术。你还会学到一种描绘某台机器上存储器层次结构的性能的有趣方法， 称为“ 存储器山( memor y mountain)", 它展示出读访问时间是局部性的一个函数。</p><ol><li><p>1 存储技术</p><p>计算机技术的成 功很大程度上源自于存储 技术的 巨大进步。早期的计算机只有几千字</p></li></ol><p>节的随机访问存储器。最早的 IBM PC 甚至千没有硬盘。1982 年引入的 IBM PC-XT 有 l OM 字节的磁盘。到 2015 年，典 型的计算机巳有 300 000 倍于 PC-XT 的磁盘存储，而且磁盘的容量以每两年加倍的速度增长。</p><ol><li><p>1. 1 随机访问存储器</p><p>随机访问存储 器( Ra ndom- Access Memory, R AM ) 分为两类 ： 静态的 和动态的 。静态RA M CS RAM ) 比动态 R A M ( DRAM ) 更快， 但也贵得多。SR A M 用来作为高速缓存存储器，既 可以在 CP U 芯片上 ， 也可以在片下。DR AM 用来作为主存以及图形系统的帧缓冲区 。典 型地， 一个桌面系统的 SRAM 不会超过几兆字节， 但是 DRA M 却有几百 或几千兆字节。</p><ol><li><p>静态 RAM</p><p>SR AM 将每个位 存储在一个双稳 态的 ( bista ble ) 存储器单元里。每个 单元是用一个六晶体管电路来实现的。这个电路有这样一个属性，它可以无限期地保持在两个不同的电压 配置( config ur a tion ) 或状态( s tate) 之一。其他任何状态都是不稳定的一 从不稳定状态开始， 电路会迅速地转移到 两个稳定状态中的一个。这样一个存储器单元类似于图 6-1 中画出的倒转的钟摆。</p></li></ol></li></ol><h2 id=img1129d8f07f3deaf9439a791f1cce81d1jpeg之-imgbae90b00348e3e736832474da360f580jpeg><img src=img/1129d8f07f3deaf9439a791f1cce81d1.jpeg alt>之 <img src=img/bae90b00348e3e736832474da360f580.jpeg alt>
<a class=anchor href=#img1129d8f07f3deaf9439a791f1cce81d1jpeg%e4%b9%8b-imgbae90b00348e3e736832474da360f580jpeg>#</a></h2><p>图 6-l 倒转的钟摆 。同 SRAM 单元一样，钟摆只有两个稳定的 配置或状态</p><p>当钟摆倾斜到最 左边或最右边时 ，它 是稳定的。从其他任何位置， 钟摆都会倒向一边或另一边。原则上， 钟摆也能 在垂直的 位置无限期地保待 平衡 ， 但是这个状态是亚稳 态的</p><p>(metastable) 最细微的 扰动也能使它倒下， 而且一旦倒下就永远不会再恢 复到垂直的位置。</p><p>由于 SRAM 存储器单元的双稳 态特性，只 要有电， 它就会永远地保持它的值。即使有干扰（例如电子噪音）来扰乱电压， 当干扰消除 时， 电路就会恢复到稳定值。</p><p>2 动 态 RAM</p><p>DR AM 将每个位存储 为对一个电 容的充电。这个电容非常小， 通常只有大约 30 毫微</p><p>微法拉 Cfe mtofarad ) - —- 3 0 X 10- is 法拉 。不过， 回想一下法拉是一个非常大的计量单位．</p><p>DR A M 存储器可以制造得 非常密集 每个单元由一个电容和一个访问晶体管组成。但是，与 SR AM 不同， D RAM 存储器单元对 干扰非常敏感。当电容的电压被扰乱之后，它就永 远不会恢复了。暴露在光线下会导致电容电压改变。实际 上， 数码照相机和摄像机中的 传感器本质上就是 DR AM 单元的阵列 。</p><p>很多原因会导致漏电 ， 使得 DR AM 单元在 10 ~ 100 毫秒时间内 失去电荷。幸运的是， 计算机运行的时钟周期是以纳秒来衡撒的 ， 所以相对而言这个保持时间是比较长的。内存系统必须周期性地通 过读出， 然后重写来 刷新内存 每一位 。有些系统也使用纠错码， 其中计算机的字会被多编码几个位（例如 64 位的字可能用 72 位来编码）， 这样一来， 电路可以发现并纠正一个字中任何单个的错误位。</p><p>图 6-2 总结 了 SRAM 和 DRAM 存 储器的特性。只要有供电， SR AM 就会保持不变。与 DRAM 不同 ， 它不需要刷新。SRAM 的 存取比 DRAM 快。SRAM 对诸 如光和电噪声这样的干扰不敏感。代价是 SRAM 单元 比 DRAM 单 元 使 用 更 多 的 晶 体 管 ， 因 而 密集度低，而且更贵，功耗更大。</p><p>SRAM DRAM</p><ol><li><p>传统的 D R A M</p><p>了1二I :心：</p><p>图 6-2 DR AM 和 SR AM 存储器的特性</p></li></ol><p>DRAM 芯片中的单元（位）被分成 d 个超单元( supercell) , 每个超单元都由 w 个 DRAM 单元组 成。一个 d X w 的 DRAM 总共存 储了 dw 位信息。超单元被组织成一个 r 行 c 列的长方形阵列， 这里 rc= d。每个超单元有形如Ci , j ) 的 地址，这 里 1 表示行，而 ）表示列。</p><p>例如，图 6-3 展示的是一个 16X 8 的 DRAM 芯片的组织，有 d = 16 个超单元， 每个超单元有 w= 8 位， r = 4 行 ，c= 4 列。带阴影的方框表示地址( 2&rsquo; 1) 处 的 超 单 元 。 信 息 通过称为引脚 ( pin) 的外部连接器流入和流出芯片。每个引脚携带一个 1 位的信号。图 6-3 给出了两组引脚： 8 个 dat a 引脚，它们 能 传 送一个字节到芯片或从芯片传出一个字节，以 及 2 个 addr 引脚， 它们携带 2 位的行 和列超单元地址。其他携带控制信息的引脚没有显示出来。</p><p>DRAM芯片</p><p>；</p><p>2 ：</p><p>a/ddr►,:</p><p>｀</p><p>列</p><p>0 I 2 3</p><p>. , 1-丁 I</p><p>（佥到C氐PU吵)</p><p>控内制存器 2</p><p>3</p><p>超单元</p><p>( 2 , I )</p><p>j</p><p>d a 七a</p><p><img src=img/a00ce5f9dece4ab87cf331f833679fb6.jpeg alt></p><p>图 6-3 一个 128 位 16 X 8 的 DRA M 芯片的高级视图</p><p>m 关千术语的注释</p><p>存储领域从来没有为 DRAM 的阵列 元素确 定一个标准的 名 字。 计算机构架师倾向于称 之为 “ 单元“，使 这个术语 具有 DRAM 存储 单元 之 意。电路 设 计 者倾向 于称之为</p><p>“宇＂，使之 具 有 主存一个字之 意。为 了避 免混淆， 我们采用 了无歧 义的术语“超单元”。</p><p>每个 DRAM 芯片被连接到某个称为内存控制 器 ( memory cont roller) 的电路， 这个电路可以一次传送 w 位到每个 DRAM 芯片或一次从每个 DRAM 芯片传出 w 位。为了读出超单元( i , j ) 的内容，内 存控制器将行地址 t 发送到 DRAM , 然后是列地址 J。 DRAM 把 超单元( i , j ) 的内容发回给控制器作为响应。行 地址 t 称为 RAS ( Row Access Strobe, 行访间选 通脉冲）请求。列地址 ］称为 CAS ( Column Access Strobe, 列访问选通脉冲）请求。注意， RAS 和 CAS 请求共享相同的 DRAM 地址引脚。</p><p>例如，要 从 图 6-3 中 16 X 8 的 DR AM 中读出超单元 ( 2 , 1), 内存控制器发送行地址</p><p>2&rsquo; 如 图 6-4a 所示。DRAM 的响应是将行 2 的整个内容都复制到一个内部行缓 冲区。接下来 ，内 存 控 制器发送列地址 1 , 如图 6-46 所示。DRAM 的响应是从行缓冲区复制出超单元 ( 2&rsquo; 1) 中 的 8 位 ，并 把它们发送到内存控制器。</p><p>DRAM芯片 DRAM芯片</p><p><img src=img/4a2ffbe672f37f752251135ff8cd6375.jpeg alt>： 列 ！</p><p><img src=img/42c1dc317ac28fd9b3bf90864cf2ef27.jpeg alt></p><p>内存</p><p>控制器</p><p><img src=img/ebd63f4e378a8cd5e2745490f6648c1c.png alt></p><p>addr</p><p><img src=img/6f1241b184be2480d32b69368973b416.jpeg alt>data</p><p><img src=img/d2a401e6a0ab3263eec738ade6d18416.jpeg alt>, &mldr;&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;..内&mldr;&mldr;部&mldr;&mldr;行&mldr;&mldr;缓&mldr;&mldr;冲..区&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;.,</p><p>、&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;..内&mldr;&mldr;&mldr;..行&mldr;.缓&mldr;..冲&mldr;..区&mldr;&mldr;&mldr;&mldr;&mldr;&mldr;：</p><p>a ) 选择行 2 ( RAS请求）</p><p>b ) 选择列 I ( CAS 请求） 图 6- 4 读 一 个 DRAM 超单元的内容</p><p>电路设计者将 DRAM 组织成二维阵列而不是线性数组的一个原因是降低芯片上地址</p><p>引 脚 的 数 晕 。 例 如 ，如 果 示 例 的 1 28 位 DRA M 被组织成一个 16 个超单 元的线 性数组，地址 为 0 ~ 15 , 那么芯片会需要 4 个地址引脚而不是 2 个 。二维阵列 组织的缺点是必须分两步 发 送 地址， 这增加了访问时间。</p><ol start=2><li><p>内存模块</p><p>DRAM 芯片封装在内存模 块( memory mod ule ) 中 ， 它 插到主板的扩展槽上。Core i7</p><p>系统使用的 240 个引脚的双列直插内存模块( Dua l lnline Memory Module, DIMM), 它以</p><p>64 位为块传送数据到内存控制器和从内存控制器传出数据。</p><p>图 6-5 展示了一个内存模块的基本思想。示例模块用 8 个 64 Mbit 的 8 M X 8 的 DRAM 芯 片 ，总共 存储 64MB(兆字节）， 这 8 个芯片编号为 0~ 7。每个超单元存储主存的一个字节，而 用 相 应超 单元 地址 为(i&rsquo; j ) 的 8 个超单元来表示主存中字节地址 A 处的 64 位字。在图 6-5 的 示例中， DRAM O 存储第一个（低位）字节， DRA M 1 存储下一个字节，依 此类 推。</p><p>要取出内存地址 A 处的一个字，内 存 控制器将 A 转换成一个超单元地址( i&rsquo; j )&rsquo; 并将它 发 送 到 内 存 模 块 ， 然 后 内 存 模 块 再 将 t 和 ］ 广播 到 每个 DRAM。作 为响应， 每个DR A M 输出它的( i&rsquo; j ) 超 单 元 的 8 位内容。模块中的电路收集这些输出，并 把 它们合并成一 个 64 位字，再 返 回 给内存控制器。</p><p>通过将多个内存模块连接到内存控制器，能 够 聚 合 成 主 存 。 在 这 种 情 况 中 ， 当控制器收 到 一 个 地 址 A 时 ， 控制器选择包含 A 的模块 k&rsquo; 将 A 转换成它的 ( i&rsquo; j ) 的 形 式，并将( i&rsquo; j ) 发 送 到 模 块 k。</p><p>练习题 6. 1 接下来， 设 r 表 示 一个 DR AM 阵列 中的行数， c 表 示 列 数， br 表 示行寻址所需的位数，从 表 示 列 寻址所 需 的位数。 对于下 面 每个 DRAM , 确定 2 的 幕数的</p></li></ol><p>阵列 维数，使 得 max(rb , be ) 最小， ma x( rb</p><p>较 大的值 。</p><p>, b, ) 是对阵 列 的行或列 寻址所需的位数中</p><table><thead><tr><th>组织</th><th>r</th><th>C</th><th>b,</th><th>bC</th><th>max(b,, b)</th></tr></thead><tbody><tr><td>16X I</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>16X4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>128X8</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>512X4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1024X4</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>addr (row= i, col= j)</p><p><img src=img/72a8ce3f3222d7a555b3721f8e087374.jpeg alt> <img src=img/cd08d5676ffd6b2f3fa3ca76acfbcd6f.jpeg alt></p><p><img src=img/afa8e4038b70ed9540549bc6e5d1c3a7.jpeg alt></p><p>63 5655 4847 4039 3231 2423 1615 8 7 0</p><h5 id=i-i-i-i-i-i-i-i-i>I I I I I I I I I
<a class=anchor href=#i-i-i-i-i-i-i-i-i>#</a></h5><p>位于主存地址 A处的64位字</p><p>口：超单元 ( i&rsquo; 八</p><p>由8个8M x 8的</p><p>DRAM组成的64MB</p><p>内存模块</p><p>内存</p><p>控制器</p><p><img src=img/02d6e5cbd1f404ef7e8276cd9c034950.jpeg alt></p><ol start=3><li><p>增强的 DRAM</p><p>图 6-5 读一个内存模块的内容</p></li></ol><p>有许多种 DRAM 存储器， 而生产厂商试图跟上迅速增长的处理器速度， 市场上就会定期推 出新的种类。每种都是基于传统的 DRAM 单元， 并进行一些优化， 提高访问基本</p><p>DRAM 单元的速度。</p><ul><li><p>快页模 式 DRAM CFast Page Mode DRAM, FPM DRAM ) 。传统的 DRAM 将超单元的 一整行复制到它的内部行缓 冲区中， 使用一个， 然后丢弃剩余的。FPM</p><p>DRAM 允许对同一行连续地访问可以 直接从行缓冲区 得到服务，从 而改进了这一点。例如，要从 一个传统的 DRAM 的行 t 中读 4 个超单元，内 存控制器必须发送 4 个 RAS / CAS 请求， 即使是行地址 1 在每个情况中都是一样的。要从一个 FPM DRAM 的同一行中读取超单元，内 存控制器发送第一个 RAS/ CAS 请求， 后面跟三个 CAS 请求。初始的RAS/ CAS请求将行1 复制到行缓冲区， 并返回 CAS 寻址的那个超单元。接下来三个超单元直接从行缓冲区获得，因此返回得比初始的超单元更快。</p></li><li><p>扩展数据捡出 DRAM ( Extended Data Out DRAM, EDO DRAM) 。FP M DRAM 的一个增强的形式，它允 许各个 CAS 信号在时间上靠得更紧密一点 。</p></li><li><p>同步 DRAM(Synchronous DRAM, SDRAM)。就它们与内存控制器通信使用一组显式的控制信号来说， 常规的、FPM 和 EOO DRAM 都是异步的。SDRAM 用与驱动内存控制器相同的外部时钟信号的上升沿来代替许多这样的控制信号。我们不会深入讨论细节， 最终效果就是SDRAM能够比那些异步的存储器更快地输出它的超单元的内容。</p><ul><li><p>双倍 数据速 率 同 步 DRAM ( Double Data-Rate Synchronous DRAM, DOR SDRAM )。DDR SDRA M 是对 S DRA M 的一种增强， 它通过使用两个时钟沿作为控制信号， 从 而使 DR AM 的速度翻倍。不同类型的 DOR SDRA M 是用提高有效 带宽的很小的预取缓冲区的大小来划分的： DDR( 2 位）、DDR2( 4 位）和DDR( 8 位）。</p></li><li><p>视 频 RA M( Video RAM, VRAM ) 。它用在图形系统的帧缓冲区中。 VRAM 的思想与 FPM DRAM 类似。两个主要区别是： 1) VRAM 的输出是通过依次对内部缓冲区的整个内 容进行移位得到的； 2) V R AM 允许对内存并行地读和写。因此， 系统可以在写下一次更新的新值（写）的同时，用帧缓冲区中的像素刷屏幕（读）。</p><p>田日DRAM 技术流行的 历史</p><p>直到 1995 年， 大 多 数 PC 都是 用 F P M DRAM 构 造的。1 996 1999 年， EDO DR AM 在市场 上占 据了主 导， 而 F P M DRAM 几乎销声 匿迹 了。 SD RAM 最早 出现在199 5 年的 高端 系统中， 到 2002 年， 大 多 数 PC 都是用 SDR AM 和 DOR SDR AM 制造的。到 2010 年之前， 大多数服务器和 桌面 系统都是 用 D DR3 SDRAM 构造的。 实际上， Intel Core i7 只支持 DDR3 SDRAM。</p><p>6 非易失性存储器</p><p>如果断电， DRAM 和 SR AM 会丢失它们的信息， 从这个意义上说， 它们是易失的 ( vola tile) 。另一方 面，非易 失性 存储器 ( nonvola tile memory ) 即使是在关电 后， 仍然保存着它们的信息。现在有很多 种非易失性存储器。由于历史原因， 虽然 RO M 中有的类型既</p><p>可以读也 可以写， 但是它们整体上都被 称为 只读 存储 器 C Read-Only Memory, ROM)。ROM 是以它们能够被重编 程（写）的次数和对它们 进行重编程所用的机制来区分的。</p><p>PROM(Programmable ROM, 可编程 RO M ) 只能被编程一次。P ROM 的每个存储器单元有一种熔丝 ( fuse) , 只能用高电 流熔断一次。</p><p>可掠 写 可编 程 RO M (Erasable Programmable ROM, EPRO M ) 有一个透明的石英窗口，允 许光到 达 存储单元。紫 外线 光 照射 过 窗 口， EP RO M 单 元就被 清 除 为 0。对E PR O M 编程是通过使用 一种把 1 写入 EP RO M 的特殊设备来完成的。EP RO M 能够被擦除和重编程的次 数的数量级可以达到 1000 次。电 子 可擦 除 PRO M C Electrically Erasable PROM, EEPROM) 类似于 EP RO M , 但是它不需要一个物理上独立的编程设备，因此可以直接在印 制电路卡上编程。E EP RO M 能够被编程的次 数的数量级可以达到 105 次。</p><p>闪存 ( flas h memory )是一类非易失性存储器， 基于 EE PRO M , 它已经成为了一种重要的存储技术 。闪存无处不在， 为大量的电子设备提供快速而持久的非易失性存储， 包括数码相机、手机、音乐 播放器、PDA 和笔记本、台式机和服务器计算机系统。在 6. 1. 3 节中， 我们会仔细研究一种新型的基于闪存的磁盘驱动器， 称为 固 态硬 盘 C Solid State Disk, SSD), 它能提供相对千传统旋转磁盘的一种更快速、更强健和更低能耗的选择。</p><p>存储在 RO M 设备中的程序通 常被称为固件 ( firmware) 。当一个计算机系统通电以后， 它 会运行存储在 ROM 中的固件。一些系统在固件中提供了少最基本的输入和输出函数一 例如 PC 的 BIOS( 基本输入／输出系统）例程。复杂的设备， 像图形卡和磁盘驱动控</p></li></ul></li></ul><p>制器， 也依赖固件翻译来自 CP U 的 I / 0 ( 输入／输出）请求。</p><p>7. 访问主存</p><p>数据流通过 称为总线 ( bus ) 的共享电子电路在处理器和 DRA M 主存之间来来 回回。 每次 CPU 和主存之间的数据传送都是通过一系列步骤来完成的， 这些步骤称为 总线事务(bus t ransact io n) 。读事务 ( read t ra nsactio n) 从主存传送数据到 CP U。写事务 ( write trans­ action) 从 CPU 传送数据到主存。</p><p>总线是一组并行的导线， 能携带地址、数据和控制信号 。取决千总线 的设计，数 据和地址信号可以共享同一组导线，也可以使用不同的。同时，两个以上的设备也能共享同一 总线。控制线携带的 信号会同步事务，并标识出当前正在被 执行的事务的类型。例如， 当前关注的这 个事务是 到主存的吗？还是到诸如磁盘控制器这 样的其他 I / 0 设备？ 这个事务是读还是写？ 总线上的信息是地址还是数据项？</p><p>图 6-6 展示了一个示例计算机系统的配置。主要部件是 CPU 芯片、我们将称为 1/ 0</p><p>桥接器 CI / 0 bridg e )的芯片组（其中包括内存控制器）， 以及组成主存的 DR AM 内存模块。这些部 件由一对总线连接起来， 其中一条总线是 系统总线( s ys tem bus ) , 它连接 CP U 和1/ 0 桥接器 ， 另一条总线是内存 总线( memor y bus) , 它连接 1/ 0 桥接器 和主存。1/ 0 桥接器将系 统总线的电子信号翻译成内 存总线的电子信号。正如我们看到的那样， I / 0 桥也将 系统总线和内存总线连接到 I/ 0 总线， 像磁盘和图形卡这样的 1/ 0 设备共享 1/ 0 总线。不过现在，我 们将注意力 集中在内存总线上。</p><p>CPU芯片</p><p>系统总线</p><p>总线接口 三</p><p>内存总线</p><p>I</p><p>图 6-6 连接 C P U 和主存的总线结构示例</p><p>m 关千总线设计的 注释</p><p>总线设 计是计算机 系统一个复杂而且 变化迅速的方面 。 不同的 厂商提 出了不同的 总线体系结构，作为产品 差异化的一种方法 。例如， Intel 系统使用称 为北桥 ( northbridg e) 和南桥(so uth bridge)的芯片组分别 将 CPU 连接到内存和 1/ 0 设备。在比较老的 Pent ium 和Core</p><p>2 系统中， 前端总 线( Fr ont Side Bus , FSB) 将 CPU 连接到北桥 。来自 AMD 的 系统将 FSB</p><p>替换为超传输 ( H yperTransport ) 互联 ， 而更新一些的 Intel Core i7 系统使用的 是快速通道</p><p>(QuickPath) 互联。这些不同 总线体 系结构的细节超 出了 本书的 范围。反之， 我们会使 用图6-6 中的 高级 总线体系结构作 为一 个运行 示例贯穿本书。 这是一个简单但是有用的 抽象， 使得我们可以很 具体， 并且可以 掌握主要思想而不必与任何私有设计的 细节绑得 太紧。</p><p>考虑当 CP U 执行一个如下加载操作时会发生什么</p><p>movq A,%rax</p><p>这里， 地址 A 的内容被加载到寄存器%r a x 中。CP U 芯片上称为总线接 口( bus interface )</p><p>的电路在总线上发起读事务。读事务是由三个步骤组成的。首先， CPU 将地址 A 放到系统 总 线 上 。 I / 0 桥将信号传递到内存总线（图6- 7a ) 。接下来，主 存 感 觉 到 内 存 总 线 上的地址 信 号 ，从 内 存 总 线 读 地址，从 DRAM 取出数据字 ，并 将 数 据 写 到内存总线。I/ 0 桥将内 存 总 线 信 号 翻译成系统总线信号， 然后沿着系统总线传递（图6-7 b ) 。最后， CPU 感觉到系统总线上的数据，从 总 线上 读数据，并 将 数 据 复 制到寄存器%r a x ( 图 6- 7c) 。</p><p>寄存器文件</p><p>总 线 接口</p><p>I / 0 桥</p><p>I I</p><p>VO桥</p><p>二 I I X</p><p><img src=img/0797008a36e8c8e2ac28faf7f1a7d445.jpeg alt>总线接 口</p><p>c ) CP U从总线读 出字x, 并将它复制到寄存器 % r a x中图 6- 7 加 载操作 mo vqA, %r a x 的内存读事务</p><p>反过来， 当 CPU 执行一个像下面这样的存储操作时</p><p>movq %rax,A</p><p>这里， 寄 存器 %r a x 的 内 容 被写到地址 A , CPU 发起写事务。同样， 有三个基本步骤。首先，</p><p>CPU 将地址放到系统总线上。内存从内存总线读出地址， 并 等待 数 据 到 达（图 6-8a) 。接下来 ， CPU 将%r a x 中 的 数 据 字 复 制到系统总线（图6-8 6 ) 。最后， 主 存 从 内 存总线读出数据字 ，并 且 将这些位存储到 DRAM 中（图 6-8 c ) 。</p><p>6. 1. 2 磁盘存储</p><p>磁盘是广为应用的保存大量数据的存储设备，存 储 数 据 的 数 量 级 可 以 达到儿百到几千千 兆 字节， 而基 千 RAM 的存储器只能有几百或几千兆字节。不过，从 磁 盘 上 读 信息 的时间 为毫秒级，比 从 DRAM 读慢了 10 万倍， 比从 S RAM 读慢了 100 万倍。</p><p>寄存器文件</p><p>亳c a</p><p>，</p><p>总线接口</p><p>VO桥</p><p>I I A</p><p>a ) CPU将地址A放到 内存 总 线。主存读出这 个 地址 ，并等待数据字寄存器文件</p><p><img src=img/e72b9392727fc9e6bbe4cc52d1847a3f.jpeg alt><img src=img/369b5bee9d905615f57f3c51f031e422.jpeg alt>主存</p><p>y</p><p>b ) CPU将数据字y放到总线上</p><p>寄存器文件</p><p>hax</p><p>总线接口</p><p>c ) 主存从总线读数据字y , 并将它存储在地址A</p><p>图 6-8 存 储 操 作 mo vq %r ax , A 的 内 存 写 事 务</p><p>i 磁盘是由 盘片 ( plat t e r ) 构成的。每个盘片有两面或者称为表 面 ( s ur fa ce ) , 表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴 ( s pin dle) , 它使得盘片以固定的旋转速率(rota tion al ra te) 旋转， 通常是 5400 1 5 000 转每分钟( Revol u t io n Per M in ute , RP M) 。磁</p><p>i 盘通常 包含一个或多个这样的盘片， 并封装在一个密封的容器内。</p><p>卜 图 6- 9a 展示了一个典型的磁盘表面的结构。每个 表面是由一组称为磁道( t rac k ) 的同</p><p>！勺 心圆组 成的。每个磁 道被划分为一组扇区 ( s e cto r ) 。 每个 扇区包含相等数量的数据位（通常叱 是 512 字节）， 这些数据编码在扇区上的磁性材料中。扇区之间由一些间隙 ( ga p ) 分 隔 开，</p><p>这些间隙中不存 储数据位。间隙存储用来标识扇区的格式化位。</p><p><img src=img/66cbd5af53105c2035d9d12d67e5898f.jpeg alt>磁盘是由 一个或多个叠放在一起的盘片组成的，它 们被封装在一个密封的包装里， 如图 6-9b 所示。整个装置通常被称为磁盘驱动 器( d is k drive ) , 我们通常简称为磁盘( dis k ) 。有时 ， 我们会称磁盘为 旋转磁盘 ( ro t at ing dis k ) , 以使之区别千基于闪 存的 固 态硬盘(SSD), SSD 是没有移动部分的 。</p><p>磁盘制 造商通常用术 语柱面 ( cy linde r ) 来描述多个盘片驱动器的构造， 这里， 柱面是所有盘片表面上到主轴中心的距离相等的磁道的集合。例如， 如果一个驱动器有三个盘片和六个面 ， 每个表面上的磁道的编号都是一致的， 那么柱面 k 就是 6 个磁道 k 的集合。</p><p><img src=img/f9a5d64d524472ef9a87369419b0d765.jpeg alt></p><p>a ) 一个盘片的视图</p><p>图 6-9 磁盘构造</p><p>柱面k</p><p><img src=img/f9471425c5e3bb6fad4c0f90013fb445.jpeg alt></p><p>主轴</p><p>b ) 多个盘片的视图</p><p>盘片0 盘片1 盘片2</p><p>2. 磁盘容量</p><p>一个磁盘上可以记录的最大位数称为它的最大容量，或 者 简 称 为 容 量。磁盘容量是由以下 技术因素决定的：</p><ul><li><p>记录密度 ( recording density)( 位／英寸）： 磁道一英寸的段中可以放入的位数。·</p></li><li><p>磁 道密度 ( t rack de nsit y) ( 道／英寸）： 从 盘片中心出发半径上一英寸的段内可以 有的磁道数。</p></li><li><p>面 密度 ( a rea l density)( 位／平方英寸）： 记 录密度与磁道密度的乘积。</p><p>磁盘制造商不懈地努力以提高面密度（从而增加容量），而 面密度每隔几年就会翻倍。最初 的磁 盘， 是 在 面密度很低的时代设计的，将 每个磁道分为数目相同的扇区， 扇区的数目是由最靠内的磁道能记录的扇区数决定的。为了保持每个磁道有固定的扇区数，越往外 的磁道扇区隔得越开。在面密度相对比较低的时候，这种方法还算合理。不过，随着面密 度的提高，扇区之间的间隙（那里没有存储数据位）变得不可接受地大。因此，现代大容蜇 磁盘使用一种称为多 区记 录( multip le zone recordi ng ) 的技术，在 这种技术中，柱 面的集合被分割成不相交的子集合，称 为记录区 ( recordi ng zone) 。每个区包含一组连续的柱面。一个区中的每个柱面中的每条磁道都有相同数量的扇区，这个扇区的数量是由该区中最里面的 磁道所能包含的扇区数确定的。</p><p>下面的公式给出了一个磁盘的容量：</p></li></ul><p>磁 盘容 量 =</p><p>字节数 X 平均扇区数 磁道数 X 表面数 X 盘片数扇区 磁道 表面 盘片 磁盘</p><p>例如， 假设我们有一个磁盘， 有 5 个盘片， 每个扇区 512 个字节， 每个面 20 000 条磁道， 每条磁道平均 300 个扇区。那么这个磁盘的容量是：</p><p>磁盘容量= 512 字 节 X 30 0 扇 区 20 000 磁道 X 2 表面 5 盘 片扇区 磁道 表面 盘片 磁盘</p><p>= 30 720 000 000 字 节</p><p>= 30. 72 GB</p><p>注意， 制 造商是以千兆字节CGB) 或兆兆字节 ( T B) 为单位来表达磁盘容量的，这里</p><p>l GB= l 沪字 节 ， 1 T B= 1012 字 节 。</p><p>田 日 － 千兆字节有多大</p><p>不幸地 ，像 K C k ilo ) 、M( mega) 、G( giga) 和 T ( tera ) 这样的前缀的含义依 赖 于上下</p><p>文。对于与 DR A M 和 SR AM 容量相 关的 计量单位， 通常 K = 210 , M = 220 , G = 2 气 而</p><p>T = 2o4</p><p>。 对 于与 像 磁 盘和网 络 这样的 I/ 0 设 备 容 量相关的 计 量 单位， 通常 K = 103 ,</p><p>M = l 06 , G = l 0 9 , 而 T = l O气 速 率和吞吐量常常也使 用这些前缀。</p><p>幸运地，对于我们通常依赖的不需要复杂计算的估计值，无论是哪种假设在实际中 都工作 得很好。例如， 230 和 10 9 之 间 的相 对差 别 不 大： ( 230 - 10 勹 / 10 9 :::::::::7 % 。 类 似，</p><p>( 240 - 1 0 12 ) / 101 2:::::::::1 0 % 。</p><p>练习题 6. 2 计算这 样一个 磁盘的容量， 它 有 2 个 盘 片 ， 10 000 个柱 面， 每条磁 道平均有 400 个扇 区 ， 而每 个扇 区有 51 2 个字 节。</p><p>3 磁盘操作</p><p>磁盘用读／写 头( rea d/ writ e hea d ) 来读写存储在磁性表面的位， 而 读 写 头 连接到一个传动 臂( act uator arm ) 一端，如 图 6- l Oa 所示。通过沿着半径轴前后移动这个传动臂， 驱动器可以 将读／写头定位在盘面上的任何磁道上。这样的机械运动称为寻道( seek ) 。一旦读／ 写头定位到了期望的磁道上， 那么当磁道上的每个位通过它的下面时，读 ／写 头 可 以 感 知到这个位的值（读该位），也可以修改这个位的值（写该位）。有多个盘片的磁盘针对每个盘 面都有一个独立的读／写头 ， 如 图 6-1 0 6 所 示。读／写头垂直排列， 一 致 行 动 。 在 任何时刻， 所有的读／写头都位于同一个柱面上。</p><p><img src=img/c9f3a18b35335526848618339af4f07c.jpeg alt>磁盘表面以固定 ,,,..,,,的旋转速率旋转 ／</p><p>,/</p><p>读／写头连到传动臂的末端．在磁盘表面上一层薄薄的气垫上飞翔</p><p><img src=img/760b9c541d034e51a6728f2ae848675e.jpeg alt>主轴</p><p>a ) 一个盘片的视图</p><p>图 6-10</p><p>磁盘的动态特性</p><p>b ) 多个盘片的视图</p><p>在传动臂末端的 读／写头在磁盘表面高度大约 0. 1 微米处的一层薄薄的气垫上飞翔（就是字面上这个意思），速度大约为80 km/ h。这可以比喻成将一座摩天大楼( 442 米高）放倒，然 后让 它在距离 地面 2. 5 cmCl 英寸）的高度上环绕地球飞行，绕 地球一天只需要 8 秒钟！在这样小的间隙里，盘 面上一粒微小的灰尘都像一块巨石。如果读／写头碰到了这样的一块巨石，读 ／写 头会停下来， 撞到盘面一 所谓的读／写头冲撞 ( head crash ) 。为此，磁盘总是 密封包装的。</p><p>磁盘以扇区大小的块来读写数据。对扇区的 访问 时间 ( acces s t im e ) 有 三个主要的部分： 寻道 时间 ( see k t im e ) 、旋转时间( rot at io na l la t ency ) 和传送时间 ( t ra ns fe r time) :</p><ul><li>寻道时间： 为了读取某个目标扇区的内容， 传 动 臂 首 先 将 读／写 头 定 位到包含目标扇区的磁道上。移动传动臂所需的时间称为寻道时间。寻道时间 T,eek 依 赖于读／写头以前的位置和传动臂在盘面上移动的速度。现代驱动器中平均寻道时间 T avg seek 是 通过对几千次对随机扇区的寻道求平均值来测扯的， 通常为 3 9 ms 。一次寻道的最大时间 T max seek 可 以 高 达 20 ms 。</li><li>旋转时间： 一旦读／写头定位到了期望的磁道， 驱动器等待目标扇区的第一个位旋转到读／写头下。这个步骤的性能依 赖于当读／写头到达目标扇区时盘面的位置以及磁盘的旋转速度。在最 坏的情况下， 读／写头刚刚错过了目标扇区，必 须 等待磁盘转一整圈。因此，最大旋转延迟（以秒为单位）是</li></ul><p>Tmax rotation=</p><p>RPM</p><p>X 60s</p><p>lmin</p><p>平均旋转时间 Tavg rotation是 Tmax rotation的 一半。</p><ul><li><p>传送时 间： 当目标扇区的 第一个位位千读／写头下时， 驱动器就可以 开始读或者写该扇区的内容了。一个扇区的 传送时间依赖于旋转速度和每条磁道的扇区数目。因此，我们可以粗略地估计一个扇区以秒为单位的平均传送时间如下</p><p>T = l X 1 X 60s</p><p>avg transfer RPM ( 平均扇 区数 ／ 磁道） lmin</p><p>我们可以估计访问一个磁盘扇区内容的平均时间 为平均 寻道时间、平均旋转延迟和平均传送时间之和。例如，考虑一个有如下参数的磁盘：</p><p>参数 值</p></li></ul><p>旋转速率</p><p>T,vg江 , k</p><p>每条磁道的平均扇区数</p><p>7200RPM</p><p>9ms</p><p>400</p><p>对于这个磁盘， 平均旋转延迟（以ms 为单位）是</p><p>Tavg rotauon = 1 / 2 X T max rotation = 1 / 2 X ( 60s / 7200 RPM) X 1000 ms / s ::::,::: 4 ms</p><p>平均传送时间是</p><p>Tavg transfer = 60/ 7200 RPM X 1/ 400 扇 区／ 磁道 X 1000 ms / s ::::,::: 0. 02 ms</p><p>总之，整个估计的访问时间是</p><p>Taccess = T, vg seek + T avg rotation + T ,vg transfer = 9 ms+ 4 ms + o. 02 ms = 13. 02 ms</p><p>这个例子说明了一些很重要的间题：</p><ul><li><p>访问一个磁盘扇区中 512 个字节的时间主要是寻道时间和旋转延迟。访问扇区中的第一个字节用了很长时间， 但是访问剩下的字节几乎不用时间。</p></li><li><p>因为寻道时间 和旋转延迟大致相 等， 所以将寻道时间乘 2 是估计磁盘访问时间的简单而合理的方法。</p></li><li><p>对存储在 SR AM 中的一个 64 位字的访问时间大约是 4n s , 对 DRAM 的访问时间是</p><p>60ns 。因此， 从内存中读一个 512 个字节扇区大小的块的时间对 SR AM 来说大约是</p><p>256n s , 对 DRAM 来说大约是 4000ns 。磁盘访问 时间， 大约 l Oms , 是 SRAM 的大约 40 000 倍， 是 DR AM 的大约 2500 倍。</p><p>沁因 练习题 6. 3 估计访问 下面这个缢盘上 一个扇 区的访问 时间（以 ms 为单 位）：</p></li></ul><p>参数</p><p>旋转速率</p><p>Tavg seek</p><p>每条磁道的平均扇区数</p><p>值</p><p>15 000RPM</p><p>8 ms</p><p>500</p><ol><li><p>逻辑磁盘块</p><p>正如我们看到的那样， 现代磁盘构造复杂， 有多个盘面， 这些盘面上有不同的记录区 。 为了对操作系统隐藏这样的复杂性， 现代磁盘将它们的构造呈现为一个简单的视图，</p></li></ol><p>一个 B 个扇区大小的逻辑块的序列， 编 号 为 o, 1, …， B —1 。 磁 盘 封装中有一个小的硬件／固件设备，称 为磁 盘控制器，维 护 着 逻辑块号和实际（物理）磁盘扇区之间的映射关系。</p><p>当操作系统想要执行一个1/0 操作时 ，例 如读一个磁盘扇区的数据到主存，操 作 系统会发</p><p>送一个命令到磁盘控制器 ，让 它读某个逻辑块号。控制器上的固件执行一个快速表查找， 将一个逻辑块号翻译成一个（盘面， 磁 道， 扇区）的三元组， 这个三元组唯一地标识了对应的物理扇区。控制器上的硬件会解释这个三元组， 将读／写头移动到适当的柱面， 等 待 扇区移动到读／写头下， 将读／写头感知到的位放到控制器上的一个小缓冲区中，然后 将它们复制到主存中。</p><p>m 格式化的磁盘容量</p><p>磁盘控制器必须对磁盘进行格式化，然后才能在该磁盘上存储数据。格式化包括用 标识扇区的信息填写扇区之间的间隙，标识出表面有故障的柱面并且不使用它们，以及 在每个 区中预留出一 组柱面作 为备 用，如 果 区中一个或多 个柱 面在磁盘使用过程中坏掉了， 就可以使 用这 些备 用的 柱面。 因 为存 在 着这些备 用的 柱面， 所以磁盘制造商所说的格式化容量比最大容量要小。</p><p>练习题 6. 4 假设 1MB 的文件由 512 个字节 的逻辑块组成， 存储在具 有如下特性的磁盘驱动器上：</p><p>对于下面的 情况， 假设程 序顺 序地读 文 件的逻 辑块， 一个接 一个， 将读／写 头定位到 第一块上的 时间 是 T avg seek+T avgrota11o n o</p><p>·A. 最好的情况： 给定 逻辑块到 磁 盘 扇 区的 最好的 可 能 的映 射（即顺序的）， 估计读这</p><p>个文件需要的最优时间（以 ms 为 单位）。</p><p>B. 随机的情况： 如果块是随机地映射到 磁 盘扇 区的， 估计读这个 文件需要的 时间（以</p><p>ms 为 单位）。</p><ol start=2><li><p>连接 1/ 0 设 备</p><p>例如图形卡、监视器、鼠标、键盘和磁盘这样的输入／输出(l / 0 ) 设备，都 是 通过 l/ 0</p><p>总线，例 如 Int el 的 外围设备 互 连( Periphe ral Component Int erconnect , PCD 总线连接到</p><p>CPU 和主存 的。系统总线和内存总线是与 CPU 相关的，与 它 们 不 同 ，诸 如 PCI 这样的 I/</p><p>0 总线设 计成与底层 CPU 无关。例如， P C 和 Mac 都可以使用 PCI 总线。图 6-11 展 示 了一个典型的 I/ 0 总线结构，它 连接了 CPU、主存和 l/ 0 设备。</p><p>虽然 l/ 0 总线比系统总线和内存总线慢，但 是 它 可以容纳种类繁多的第三方 l/ 0 设备。例如，在 图 6-11 中 ， 有 三种不同类型的设备连接到总线。</p></li></ol><ul><li><p>通用串行 总线( Universa l Serial Bus, USB)控制器是一个连接到 USB 总线的设备的中转机构， USB总线是一个广泛使用的标准， 连接各种外围 l/ 0 设备，包 括键盘、鼠标、调制解调器、数码相机、游戏操纵杆、打印机、外部磁盘驱动器和固态硬盘。 USB 3. 0 总线的最大带宽 为 625MB / s。USB 3. 1 总线的最大带宽为 1250MB/ s。</p></li><li><p>图形卡（或适配器）包含硬 件 和软件逻辑，它 们 负 责 代表 CPU 在显示器上画像素。</p></li><li><p>主机 总线适配器将 一 个 或 多 个 磁盘连接到 I/ 0 总线，使 用 的 是 一 个 特 别 的 主机总线接 口定义的通信协议。两个最常用的这样的磁盘接口是 SCSI( 读作 " scuzzy" ) 和S AT A( 读作 " sat- uh" 。SCSI 磁盘通常比 SAT A 驱动器更快但是也更贵。SCSI主机 总 线 适 配器（通常称为 SCSI 控制器）可以支持多个磁盘驱动器， 与 S AT A 适配器不 同 ， 它 只 能 支 待 一 个 驱 动 器 。</p><p>寄口存器文件日</p><p>系统总线 内存总线</p></li></ul><p>总线接口 凶,</p><p>!,&rsquo;.•·•C.·..&rsquo;",B·</p><p>USB Il三</p><p>VO总线</p><p>I</p><p>000 ;</p><p>针对诸如网络适</p><p>配器这样的其他</p><p><img src=img/8a8d7450d1f4d9571df31b237d075808.jpeg alt>I 控制器 主机总线 设备的扩展插槽</p><p>t t t</p><p>鼠标 固态 键盘 监视器</p><p>硬盘 : I 如 盘 扣 妇 l 盎 i:，</p><p>* 磁 盘</p><p>'</p><p>'</p><p>'</p><p>一一一一一 －－－－－I＇</p><p>图 6-11 总线结构示例，它连 接 CP U、主存和 I/ 0 设备</p><p>其他的设备，例如网络适配器，可以通过将适配器插入到主板上空的扩展槽中，从而 连接到 I/ 0 总线， 这些插槽提供了到总线的直接电路连接。</p><p>6 访问磁盘</p><p>虽然详细描述 I/ 0 设备是如何工作的以及如何对它们进行编程超出了我们讨论的范围 ，但 是 我们可以给你一个概要的描述。例如，图 6-12 总结 了 当 CP U 从磁盘读数据时发生的步骤。</p><p>田 0 总线设计进展</p><p>图 6-11 中的 I/ 0 总线是一个简单的抽 象，使得 我们可以 具体描述但又不必和某个 系统的细节联 系过 于紧密。 它是 基 于外 围设 备 互联 ( Peripheral Component Interconnect, PCI) 总线的， 在 2010 年前使用非 常广泛。 PCI 模型中， 系统中所有的设备共享总线 ， 一个时刻只 能有一台设备 访问这些线路。在现代系统中， 共享的 PCI 总线已经被 PCEe(PCI express) 总线取代， PCie 是 一组高速 串行 、通过开关连 接的点到点链路， 类似于你 将在第 11 章中学习到 的开关以 太网。PCie 总线， 最大吞吐率为 16GB / s , 比 PCI 总线快一个数量级 ， PCI 总线的最大吞吐率为 533MB/ s。除 了测 量出的 I/ 0 性能， 不同总线设计之间的 区别 对应用程 序 来说是不可见的 ，所以 在本书中，我 们只使 用 简单的共享总线抽象。</p><p>CP U 使用一种称为内存映射 I/ O ( memor y-ma pped I/ 0 ) 的技术来向 I/ 0 设备发射命令</p><p>（图 6-12a) 。在使用内存映射 I/ 0 的系统中， 地址空间中有一块地址是为与 I/ 0 设备 通信保留的 。每个这样的地址称为一个 I/ 0 端口 (I / 0 port ) 。当一个设备连接到总线时， 它 与一个或多个端口相关联（或它被映射到一个或多个端口）。</p><p>CPU芯片</p><p>I</p><p>寄存器文件</p><p><img src=img/bfd22e642fcfb1a59a220af68641eb9e.jpeg alt> 三］</p><p>罕</p><p>鼠标 键盘 监视器 Cf</p><p>CPU芯片</p><p>1 寄存器文件</p><p><img src=img/49de2b3bfbb66e87920e240c6b1a83c8.jpeg alt><img src=img/44c73925e97256af7f314fa7fa2cbc72.jpeg alt>已 三</p><p>雪罕 芦忑</p><p>VO总线</p><p>b ) 磁盘控制器读扇区， 并 执行到主存的DMA传送</p><p>图 6-12</p><ol><li>当 OMA传送完成时， 磁盘控制器用中断的方式通知CPU 读一个磁盘扇区</li></ol><p>来看一个简单的例子，假 设 磁 盘控制器映射到端口 OxaO 。 随 后 ， CPU 可能通过执行三个对地址 OxaO 的 存储 指 令 ，发 起 磁盘读：第 一 条 指 令 是发送一个命令字，告 诉 磁 盘发起一个读， 同时还发送了其他的参数，例如 当读完 成时 ，是否 中断 CP U( 我们会在 8. 1 节中讨论中断）。第二条指令指明应该读的逻辑块号。第三条指令指明应该存储磁盘扇区内容的主存地址。</p><p>当 CP U 发出了请求之后，在 磁 盘 执 行 读 的 时 候 ， 它 通常会做些其他的工作。回想一下， 一个 1G Hz 的 处理器时钟周期为 I ns , 在用来读磁盘的 16ms 时间里， 它 潜 在 地 可能执行 16 00 万条指令。在传输进行时，只 是 简单地等待， 什么都不做，是 一 种 极 大 的 浪费。</p><p>在磁盘控制器收到来自 CP U 的读命令之后 ，它 将逻辑块号翻译 成一个扇区地址，读该扇区的内容，然 后 将这 些内 容 直 接传送到主存，不需 要 CPU 的干涉（图6-12b) 。设 备可以自己 执行读或者写总线事 务 而不需 要 CP U 干涉的 过程， 称 为 直接 内 存 访问 ( Direct</p><p>Memory Access, DMA ) 。这种数 据传送称为 DMA 传送 CDMA trans fer ) 。</p><p>在 DMA 传送完成， 磁盘扇区的内容被安全地存储在主存中以后， 磁盘控制器通过给CPU 发送一个中断信号来通知 CPU(图 6-12c) 。基本思想是中断会发信号到 CPU 芯片的一个外部引脚上。这会 导致 CPU 暂停它当前正在做的工作， 跳转到一个操作系统例程， 这个程序会记 录下 1/0 已经完成， 然后将控制返 回到 CPU 被中断的地方。</p><p>田 日 商用磁盘的特性</p><p>磁盘制造商在他们的 网 页上公 布了许多 高级技术信息。例如， 希捷( Seagate) 公司 i 的网站 包含关 于他 们 最受 欢迎的 驱 动 器之一 Barracuda 7400 的如下信息。（远 不止如 ： 此 ! ) (S eagate. com)</p><p>，志</p><ol start=3><li><p>1. 3 固态硬盘</p><p>固态硬盘CSolid Stat e Dis k , SSD) 是一种基于闪存的存储技术（参见 6. 1. 1 节），在某些情况下是传统旋转磁盘的极有吸引力的替代产品。图 6-1 3 展示了它的基本思想。SSD 封装插到 I/ 0 总线上标准硬盘插槽（通常是 USB 或 SAT A ) 中， 行为就和其他硬盘一样， 处理来自 CP U 的读写逻辑磁 盘块的请求。一个 SSD 封装由一个或多个闪存芯片和闪存翻译层( flas h translation layer) 组成，闪 存芯片替代传统旋转磁盘中的机械驱动器， 而闪存翻译层是 一个硬件／固件设备， 扮演与磁盘控制器相同的角色，将 对逻辑块的请求翻译成对底层物理设备的访问。</p><p><img src=img/384c09da8d587d764727d67e6516af04.jpeg alt>1/0 总线</p></li></ol><p>固态硬盘 ( SSD )</p><p>- - - - - - &ndash;</p><p>！ 闪存</p><p>闪存翻译层</p><p>- - - - - - - - - -</p><p>！ 块0 块B-1</p><p>II 页 o I 页I I 口三工JI &mdash; 11 页o I 页I</p><p>..I. [勹芒了门</p><p>一一一一- - &mdash;- &mdash;- &mdash;- &mdash;&mdash;&mdash;&mdash;&ndash; &mdash;- &mdash;- &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p><p>图 6-13 固态硬盘C SS D)</p><p>图 6-14 展示了典型 SSD 的性能特性。注意， 读 SSD 比写要快。随机读和写的 性能差别 是由底层闪存基本属性决定的。如图 6-13 所示， 一个闪存由 B 个块的序列组成， 每个块由 P 页组成。通常 ， 页的大小是 512 字节~ 4KB, 块是由 32 ~ 1 28 页组成的， 块的大小</p><p>为 16 KB~ 512KB。数据是以页为单位读写的。只有在一页所属的块整个被擦除之后， 才能写这一页（通常是 指该块中的所有 位都被设 置为 1 ) 。不 过， 一旦一个块被擦除了， 块中每一个页都 可以不需 要再进行擦除就写一次。在大约进行 100 000 次重复写之后， 块就会磨损坏。一旦 一个块磨损坏之后 ， 就不能再使用了。</p><table><thead><tr><th>随机读吞吐量 (MB /s )</th><th>365MB/s</th><th>随机写吞吐童 (MB/s )</th><th>303MB/s</th></tr></thead><tbody><tr><td>平均顺序读访问时间</td><td>50µs</td><td>平均随机写访问时间</td><td>60µs</td></tr></tbody></table><p>图 6-1 4 一个商业固态硬盘的性能特性</p><p>资料来源： Intel SSD 730 产品 规 格 书[ 53] 。IOPS 是每秒 1/0 操 作 数 。吞 吐 量数 量基 于 4KB 块的 读 写</p><p>随机写很慢， 有两个原因。首先， 擦除块需要相对较长的 时间， l m s 级 的 ， 比访间页所需时 间要高一个数量级。其次， 如果写操作试图修改一个包含巳经有数据（也就是不是全为 1 ) 的页 p, 那么这个块中所有带有用数据的页都必须被复制到一个新（擦除过的）块， 然后才能 进行对页 p 的写。制造商已 经在闪存 翻译层中实现了 复杂的逻辑 ， 试图抵消擦写块的高 昂代价， 最小化内部写的次数， 但是随 机写的性能不太可能 和读一样好。</p><p>比起旋转磁盘 ， SSD 有很多优点。它们由半导体存储器构成 ， 没有移动的 部件， 因而随机访问 时间比旋转磁盘要快， 能耗更低， 同时也更结实。不过， 也有一些缺点。首先， 因为反复 写之后，闪 存块会磨损，所 以 SSD 也容易磨损。闪存翻译层中的平均 磨损( wear leveling ) 逻辑试图通 过将擦除平均分布在所 有的块上来最大化每个 块的 寿命。实际 上， 平均磨损逻 辑处理得非常好 ， 要很多 年 SSD 才会磨损坏（参考练习题6. 5 ) 。其次， SS D 每字 节比旋转磁盘 贵大约 30 倍， 因此常用的存储容量比旋转磁盘小 100 倍。不过，随 着 SSD 变得越来越受 欢迎，它 的价 格下降 得非常快，而两者 的价格差也 在减少。</p><p>在便携音乐设 备中， SSD 巳经完全的取代了旋转磁盘， 在笔记 本电脑中也越来越多地作为硬 盘的替代品， 甚至在台式机和服务器中也开始 出现了。虽然旋转磁盘还会继续存在，但 是显然， SS D 是一项重要的替代选择。</p><p>练习题 6. 5 正 如我 们 已 经 看到 的， SSD 的 一个 潜 在 的 缺 陷 是 底 层 闪 存 会磨损。例如， 图 6-14 所 示的 SSD , In tel 保证 能够经得 起 128 PB C 128 X 1015 字 节）的写。 给定 这 样的假 设， 根据下面的工 作负 载， 估计这款 SSD 的寿命（以年为 单位）：</p><ol><li>顺序写的最糟情况 ： 以 470MB/s( 该设备的平均顺序写吞吐量）的速度持续地写 SSD 。<ol><li>随机写的最糟情况 ： 以 303MB/ s( 该设备的平均随机写吞吐量）的速度持续地写 SSD 。</li><li>平均情况 ： 以 20GB/ 天（某些计 算机 制造商在他 们的 移 动计 算机 工作 负 载模 拟测 试中假设 的平 均每 天写速 率）的速度 写 SSD 。</li></ol></li></ol><p>6. 1. 4 存储技术趋势</p><p>从我们对存储技术的讨论中，可以总结出几个很重要的思想：</p><p>不同 的存储技 术有 不 同的 价格和性能折中。S RAM 比 DRAM 快一点， 而 DR AM 比磁盘要快 很多。另一方面， 快速存储总是比慢速存储要贵的。SR AM 每字节的造价比DRAM 高， DRAM 的造价又比磁 盘高得多。SSD 位千 DRAM 和旋转磁盘之间。</p><p>不同 存储技术的价格和性能属性以 截然不 同的 速率 变化 着。图 6-15 总结了从 1985 年</p><p>以来的存储技术的价格和性能属性，那 时笫 一 台 P C 刚 刚 发明不久。这些数字是从以前的商 业 杂 志 中 和 W e b 上挑选出来的。虽然它们是从非正式的调查中得到的， 但 是 这些数字还是能揭示出一些有趣的趋势。</p><p>自从 1 98 5 年以来， S RAM 技术的成本和性能基本上是以相同的速度改善的。访问时间 和 每兆字节成本下降了大约 1 0 0 倍（图6- 1 5 a ) 。不过， D RAM 和磁盘的变化趋势更大， 而 且 更 不 一 致。DRAM 每兆字节成本下降了 44 0 0 0 倍（超过了四个数量级！）， 而 DRAM的 访 问 时 间 只 下 降 了 大 约 1 0 倍（图 6- 1 5 b ) 。 磁 盘技术有和 DRAM 相同的趋势， 甚至变化更 大 。 从 1 9 8 5 年以来，磁 盘存储的每兆字节成本暴跌了 3 000 0 0 0 倍（超过了六个数量 级！），但是 访问 时 间 提高得很慢，只 有 2 5 倍 左 右（图 6- 1 5 c ) 。 这些惊人的长期趋势突出了内 存 和 磁 盘 技术的一个基本事实：增 加 密度（从而降低成本）比降低访问时间容易得多。</p><p>DRAM 和磁盘的性 能滞后 于 C P U 的性能。正如我们在图 6- 1 5 d 中看到的那样，从</p><p>1 9 8 5 年到 2 0 1 0 年， C P U 周 期 时 间 提高了 5 0 0 倍。如果我们看有效周期时间 ( e ff ec t ive cy­ cle time) 我们定义为一个单独的 C P U ( 处理器）的周期时间除以它的处理器核数一 那么 从 1 9 8 5 年到 20 1 0 年的提高还要大一些， 为 2 0 0 0 倍。C P U 性能曲线在 2 0 0 3 年附近的突然 变 化 反映的是多核处理器的出现（参见 6 . 2 节的旁注），在 这 个 分 割 点 之 后 ，单 个 核的周期时间实际上增加了一点点，然后又开始下降，不过比以前的速度要慢一些。</p><table><thead><tr><th>度量标准</th><th>1985 1990 1995 2000</th><th>2005</th><th>2010</th><th>2015</th><th>2015:1985</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>美元/MB</td><td>2900 320 256 100</td><td>75</td><td>60</td><td>25</td><td>116</td><td></td><td></td><td></td><td></td></tr><tr><td>访问时间 Cns)</td><td>150 35 15 3</td><td>2</td><td>1.5</td><td>1.3</td><td>115</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>a) SRAM趋势</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>度量标准</td><td>1985</td><td>1990</td><td>1995</td><td>2000</td><td>2005</td><td>2010</td><td>2015</td><td>2015:1985</td><td></td></tr><tr><td>美元/MB</td><td>880</td><td>100</td><td>30</td><td>I</td><td>0.1</td><td>0.06</td><td>0,02</td><td>44 000</td><td></td></tr><tr><td>访问时间 ( ns )</td><td>200</td><td>100</td><td>70</td><td>60</td><td>50</td><td>40</td><td>20</td><td>10</td><td></td></tr><tr><td>典型的大小 ( MB)</td><td>0.256</td><td>4</td><td>16</td><td>64</td><td>2000</td><td>8000</td><td>16000</td><td>62 500</td><td></td></tr><tr><td>b ) DRAM趋势</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>度量标准</td><td>1985</td><td>1990</td><td>1995</td><td>2000</td><td>2005</td><td>2010</td><td>2015</td><td>2015:1985</td><td></td></tr><tr><td>美元 !GB</td><td>100 000</td><td>8000</td><td>300</td><td>10</td><td>5</td><td>0.3</td><td>0.03</td><td>3 333 333</td><td></td></tr><tr><td>最小寻 道时间 ( ms)</td><td>75</td><td>28</td><td>10</td><td>8</td><td>5</td><td>3</td><td>3</td><td>25</td><td></td></tr><tr><td>典型的大小 (G B )</td><td>0.01</td><td>0.16</td><td>I</td><td>20</td><td>160</td><td>1500</td><td>3000</td><td>300 000</td><td></td></tr><tr><td>c ) 旋转磁盘 趋 势</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>度呈标准</td><td>1985</td><td>1990</td><td>1995</td><td>2000</td><td>2003</td><td>2005</td><td>2010</td><td>2015</td><td>2015:1985</td></tr><tr><td>Intel CPU</td><td>80 286</td><td>80 386</td><td>Pent.</td><td>P-田</td><td>Pent.4</td><td>Core2</td><td>Core i7 (n)</td><td>Core i7 (h)</td><td></td></tr><tr><td>时钟频率 ( MHz)</td><td>6</td><td>20</td><td>150</td><td>600</td><td>3300</td><td>2000</td><td>2500</td><td>3000</td><td>500</td></tr><tr><td>时钟周期 ( ns)</td><td>166</td><td>50</td><td>6</td><td>1.6</td><td>0.3</td><td>0.5</td><td>0.4</td><td>0.33</td><td>500</td></tr><tr><td>核数</td><td>I</td><td>I</td><td>I</td><td>1</td><td>l</td><td>2</td><td>4</td><td>4</td><td>4</td></tr><tr><td>有效周期时间 ( ns )</td><td>166</td><td>50</td><td>6</td><td>1.6</td><td>0.30</td><td>0.25</td><td>0.10</td><td>0.08</td><td>2075</td></tr><tr><td></td><td></td><td></td><td></td><td>d) CPU趋势</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>图 6-15 存储和处理器技术发展趋势 。2010 年的 Co re i7 使用的是 Nehalem 处理器 ，</p><p>2015 年的 Co re i7 使用的是 H as well 核</p><p>注意，虽 然 SRAM 的 性能 滞后 千 CPU 的性能， 但还是 在保待增长。不 过， DRA M 和磁盘性能与 CPU 性能之间的差距实际上是在加大的。直到 20 03 年左右多核处理器的出现， 这个性能差距都是延迟的函数， DRAM 和磁盘的访问时间比单个处理器的周期时间提高得更 慢。不过，随 着 多 核 的 出 现， 这个性能越来越成为了吞吐量的函数， 多 个 处 理 器核并发 地向 DRAM 和磁盘发请求。</p><p>图 6-1 6 清楚地表明了各种趋势，以 半 对 数 为比例( s em i-log scale ) , 画出了图 6-1 5 中的访问时间和周期时间。</p><p><img src=img/ed2a1d9e3e03ef09448cb7809295553a.jpeg alt>I00 000 000.0</p><p><img src=img/09cd8d85607f78c943c992bb339107ce.jpeg alt>10 000 000.0</p><p>I 000 000.0</p><p>JOO 000.0 &ndash;+- 磁 盘寻道时间</p><p>_._ SSD 访问 时间</p><p><img src=img/83a39e78f3f40953621e0316b0b71d49.jpeg alt>JO 000.0</p><p>1000.0</p><p>100.0</p><p>10.0</p><p>1.0</p><p>0.1</p><p>0.0</p><p>1985 1990</p><p>1995</p><p>2000 2003 2005 2010</p><p>年份</p><p>2015</p><p>, 气 ) RAM访问时间</p><p>千 SRAM访问时间</p><p>-0- CPU周期时间</p><p>今 有效CPU周期时间</p><p>图 6-16 磁 盘 、 DRAM 和 CPU 速度之间逐渐增大的差距</p><p>正如我们将在 6. 4 节中看到的那样， 现代计算机频繁地使用基千 SRAM 的高速缓存， 试图弥补处理器－内存之间的差距。这种方法行之有效是因为应用程序的一个称为局部性 (localit y ) 的 基本属性，接 下 来 我们就讨论这个间题。</p><p>练习题 6. 6 使用图 6-15c 中从 200 5 年到 2015 年的数据， 估计到 哪一年你可以以 $ 500</p><p>的价 格买到 一个 1PBC1015 字节）的 旋转磁 盘。假 设美元价值不 变（没有通货 膨胀 ）。</p><p>m 当周 期时间保持不变： 多核处理器的到来</p><p>计算机历史是由一些在工业界和整个世界产生深远变化的单个事件标记出来的。有趣 的是，这些变化点趋向于每十年发生一次： 20 世纪 50 年代 Fortra n 的提出， 20 世 纪 60 年代早期 IBM 360 的出现 ， 20 世 纪 70 年代早期 Int ernet 的曙光（当 时称为 AP RA NE T ) , 20世纪 80 年代早期 IBM PC 的出现 ，以 及 20 世 纪 90 年代万维网 ( World Wide Web) 的出现 。最近这样的事件出现在 21 世纪初， 当计 算机制造商迎 头撞 上了所谓 的“能量墙( power</p><p>wall)", 发现他们无法再像以前一样迅速地增加CPU的时钟频率了，因为如果 那样芯片的功耗会太大。解决方法是用多个小处理 器核(core ) 取代单个大处理 器，从而提 高性能，每 个完整的处理器能够独立地、与其他核 并行地执行程序。这种多核 ( m ulti- core) 方法部 分有效，因为一 个处理器的功耗正比于 P = J C寸， 这里J 是时钟频率，C 是电容，而 v 是电压。电容 C 大致上正比于面积，所 以只要所有核的总面积不变，多核 造成的能耗就能保持不变。只要特征尺寸继续按照摩尔定律指数性地下降，每 个处理器中的核数，以及每个处理 器的有效性能，都会继续增加 。</p><p>从这个时间点以后，计算机越来越快，不是因为时钟频率的增加，而是因为每个处理器 中核数的 增加，也 因为体 系结构上的创新提高了 在这些核上运行程序的效率。我们可以从图6-16 中很清楚地看到这 个趋势。CPU 周期时间在 2003 年达到最低点，然后实际上是又开始上</p><p>升的，然 后变得平稳，之后 又开始以比以前慢一些的速率下降 。不过，由 于多核处理器的出现(2004 年出现双核， 2007 年出现四核）， 有效周期时间以接近于以前的速率持续下降。</p><p>6. 2 局部性</p><p>一个编写良好的计算机程序常常具有良 好的局部性 (l o ca lit y ) 。也就是， 它们倾向于引用邻近千其 他最近引用过的数据项的数据项， 或者最近引 用过的数据项本身。这种倾向性， 被称为局部 性原理( p rin cipl e of loca lit y ) , 是一个持久的概念， 对硬件和软件系统的设计 和性能都 有着极大的影 响。</p><p>局部性通常有 两种不同的 形式： 时间局 部性( t e m po ra l lo ca l it y ) 和空间 局部性( s patial lo ca lit y) 。在一个具有良好时间局部性的程序中 ， 被引用过一次的内存位置很可能 在不远的 将来再被多次引用。在一个具有良好空间局部性的程序中 ， 如果一个内存位置被引用了一次， 那么程序很可能在不远的将来引用附 近的一 个内存位置。</p><p>程序员应该理解局部性原理，因为一般而言，有良好局部性的程序比局部性差的程序 运行得更快。现代计算 机系统的各 个层次 ， 从硬件到操作系统、再到应用 程序， 它们的设计都利用了局部性。在硬件层，局 部性原理允许计算机设计者通过引入称为高速缓存存储器的 小 而快速的存储器来保存最近被引 用的 指令和数据项， 从而提高对主存的访问速度。在操作系统级， 局部性原理允许系统使用主存作为虚拟地址空间最近被引用块的高速缓存。类似地， 操作系统用主存来缓存磁盘 文件系统中最近被使 用的磁盘块。局部性原理在应用程序的设计中也扮演着重要的角色。例如， Web 浏览器 将最近被引 用的文档放在本地磁盘上，利用的 就是时间局部性。大容屈的 Web 服务器将最近被请求的文档放在前端磁盘高速缓存中， 这些缓存能满足对这些 文档的请 求， 而不需要服务器的任何干预。</p><p>6. 2. 1 对程序数据引用的局部性</p><p>考虑图 6-17a 中的简单函数， 它对一个向员的元素求和。这个程序有良好的局部性吗？要回答这个问题， 我们来看看每个变 量的引用模式。在这个例子中，变 量 s u m 在每次循环迭代中被引用一次 ， 因此， 对于 s u m 来说 ， 有好的时间 局部性。另一方面， 因为 s um 是标量， 对于 s um 来说， 没有空间局部性。</p><p>int swnvec(int v[N])</p><p>｛</p><p>int i, sum = O;</p><p>for (i = O; i &lt; N; i++) sum+= v[i];</p><p>return sum;</p><p>地址内容</p><p>访问顺序</p><p>16</p><p>82</p><p>vI V</p><p>5</p><p>24</p><p>2 87</p><p>v 6</p><p>7</p><p>a ) 一 个具 有良好局部性的程序 b ) 向量v的引用模式 ( N = 8)</p><p>图 6-17 注意如何按照向量元素存储在内存中的顺序来访间它们</p><p>正如我们在图 6-176 中看到的， 向量 v 的元素是 被顺序读取的， 一个接一个， 按照它们存储在内存中的 顺序（为了方便， 我们假设数 组是从 地址 0 开始的）。因此， 对于变量 V, 函数有很好的空间局部性，但是时间局部性很差，因为每个向噩元素只被访问一次。因为 对千循环体中的每个变量，这个函数要么有好的空间局部性，要么有好的时间局部性，所 以我们可以断定 s umv e c 函数有良好的局部性。</p><p>我们说像 s umv e c 这 样顺序访问一个向批每个元素的函数，具 有 步 长 为 1 的引用 模 式(str ide- I reference pattern)(相对千元素的大小）。有时我们称步长为 1 的引用模式为顺序引用模式( seq uent ial reference pat tern ) 。一个连续向最中， 每隔 K 个 元 素 进 行 访 问 ， 就 称为步长为 K 的引 用模式( s t r id e- k reference pattern ) 。步长为 l 的引用模式是程序中空间局部性常见和重要的来源。一般而言，随着步长的增加，空间局部性下降。</p><p>对于引用多维数组的程序来说，步 长也是一个很重要的问题。例如，考 虑 图 6-18a 中的函数 s umarr a yr ows , 它 对 一个二维数组的元素求和。双重嵌套循环按照行优先顺序( ro w­ major order ) 读 数组 的元素。也就是，内 层 循 环读第一行的元素， 然后读第二行，依 此 类 推 。函数 s umarr a yr ows 具 有良好的空间局部性，因 为它按照数组被存储的行优先顺序来访问这个 数组（图6-186 ) 。其结果是得到一个很好的步长为 1 的引用模式 ，具有良好的空间局部性 。</p><p>int sumarrayrows (int a[M] [NJ)</p><p>｛</p><p>inti, j, sum= O;</p><p>for (i = 0 ; i &lt; M; i ++)</p><p>for (j = 0; j &lt; N; j ++) sum += a[i] [j];</p><p>return sum;</p><p>地址内容</p><p>访问顺序</p><p>。</p><p>aoo</p><p>a 01</p><p>12 16</p><p>20</p><p>a12</p><p>图 6-18</p><p>a ) 另一个具有良好局部性的程序 b ) 数组a的引用模式( M = 2, N=3)</p><p>有良好的空间局部性，是因为数组是按照与它存储在内存中一样的行优先顺序来被访问的</p><p>一些看上去很小的对程序的改动能够对它的局部性有很大的影响。例如，图 6-1 9a 中的函数 s umarr a y c o l s 计 算 的 结 果 和图 6-18a 中函数 s umar r a y r o ws 的 一 样。唯一的区别是我们交换了 1 和）的循环。这样交换循环对它的局部性有何影响？ 函数 s umarr a y c o l s 的空间局 部性很差 ，因 为它按照列顺序来扫描数组，而 不是按照行顺序。因为 C 数组在内存中是按照行顺序来存放的，结 果 就 得 到步长为 N 的引用模式， 如图 6-1 96 所示。</p><p>int surnarraycols(int a[M] [N])</p><p>｛</p><p>inti, j, sum= O;</p><p>for (j = 0; j &lt; N; j ++)</p><p>for (i = 0 ; i &lt; M; i ++)</p><p>sum+= a[i][j]; return sum，·</p><p>地址内容</p><p>访问顺序</p><p>a 01</p><p>12 16</p><p>20</p><p>a12</p><p>6. 2. 2</p><p>a ) 一个空间局部性很差的程序 b ) 数组a的引用模式( M = 2, N=3)</p><p>图 6- 1 9 函数的空间局部性很差 ， 这是因为它使用步长为 N 的引用模式来扫描</p><p>取指令的局部性</p><p>因为程序指令是存放在内存中的， CPU 必须取出（读出）这些指令，所 以 我们也能够评价一个程序关于取指令的局部性。例如，图 6-1 7 中 f or 循环体里的指令是按照连续的内存顺序执行的，因此循环有良好的空间局部性。因为循环体会被执行多次，所以它也有 很好的时间局部性。</p><p>--,</p><p>代码区别千程序数据的一个重要属性是在运行时它是不能被修改的。当程序正在执行 时， CPU 只从内存中读出它的指令。CPU 很少会重写或修改这些指令。</p><ol><li><p>2. 3 局部性小结</p><p>在这一节中， 我们介绍了局部性的基本思想， 还给出了量化评价程序中局部性的一些简单原则：</p><ul><li><p>重复引用相同变量的 程序有良 好的时间局部性。</p></li><li><p>对于具有步长为 K 的引用模式的程序， 步长越小， 空间局部性越好。具有步长为 l 的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局 部性会很差。</p></li><li><p>对千取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多， 局部性越好。</p><p>在本章后面，在我们学习了高速缓存存储器以及它们是如何工作的之后，我们会介绍 如何用高速缓存命中率和不命中率来量化局部性的概念。你还会弄明白为什么有良好局部性的程序通常比局部性差的程序运行得更快。尽管如此，了解如何看一眼源代码就能获得 对程序中局部性的高层次的认识，是程序员要掌握的一项有用而且重要的技能。 ．</p><p>练习题 6. 7 改变下面函数中循环的顺序，使得 它以步长为 1 的引用模式扫描三维数组 a :</p><p>int sumarray3d (int a[NJ [NJ [NJ)</p><p>｛</p><p>int i , j , k, sum &ldquo;&rsquo; 0 ;</p></li></ul></li></ol><p>for (i = O; i &lt; N; i++) {</p><p>for (j = O; j &lt; N; j++) {</p><p>for (k = O; k &lt; N; k++) { sum += a[k] [i] [j];</p><p>｝</p><p>｝</p><p>｝</p><p>return sum;</p><p>练习题 6 . 8 图 6- 20 中的 三个函数，以不同的 空间局部 性程度 ， 执行 相同的 操作。请对这些函数就空间局部性进行排序。解释你是如何得到排序结果的。</p><p>void clear1(point *P, int n)</p><p>｛</p><p>#define N 1000 typedef struct {</p><p>int vel[3];</p><p>int acc[3];</p><p>} point;</p><p>point p[N];</p><p>a) str uc t s 数组</p><p>图 6-20</p><p>int i , j;</p><p>for (i = O; i &lt; n; i++) { for (j = O; j &lt; 3; j++)</p><p>p[i] .vel[j] = O;</p><p>for (j = O; j &lt; 3; j++)</p><p>p[i] . acc[j] = 0;</p><p>｝</p><p>b ) c l e ar l 函数</p><p>练习题 6. 8 的代码示 例</p><p>void clear2(point *P, int n)</p><p>｛</p><p>int i, j;</p><p>for (i = 0; i &lt; n; i ++) {</p><p>for (j = 0; j &lt; 3; j++) { p [i] . vel[j] = 0;</p><p>p [i] . ace [j] = 0;</p><p>｝</p><p>｝</p><p>void clear3(point *P, int n)</p><p>｛</p><p>int i, j;</p><p>for (j = 0; j &lt; 3; j++) { for (i = O; i &lt; n; i++)</p><p>p[i] .vel[ j] = O;</p><p>for (i = O; i &lt; n; i++) p[i] .acc[j] = O;</p><p>｝</p><p>c) c l e ar 2 函数 d) c l e ar 3函数</p><p>图 6- 20 （续）</p><ol><li><p>3 存储器层次结构</p><p>6. 1 节和 6. 2 节描述了存储技术和计算机软件的一些基本的和持久的属性 ：</p><ul><li><p>存储技 术： 不同存储技术的访问 时间差异很大。速度较快 的技术每字 节的成本要比速度较慢的技术高 ， 而且容最 较小。CP U 和主存之间的速度差距在增大。</p></li><li><p>计算机软件 ： 一个编写良好的程序倾向 于展示出良 好的局部性。</p><p>计算中一个喜人的巧合是， 硬件和软件的这些 基本属性互 相补充 得很完美 。它们这种相互补充的性 质使 人想 到一种组 织存储 器 系统的方 法， 称 为 存 储 器 层 次 结 构 ( memory 加 rarchy) , 所有的现代计算 机系统中都使用了这种方法。图 6- 21 展示了一个典型的存储器层次结构。一般而言，从高层往底层走，存储设备变得更慢、更便宜和更大。在最高层</p><p>(LO), 是少量快速的 CPU 寄存器， C P U 可以在一个时钟周 期内访间它们。接下来是一个</p></li></ul></li></ol><p>更小更快和</p><p>（每字节） 成本更高的存储设备</p><p>更大</p><p>L3:</p><p>Ll :</p><p>L2</p><p>高速缓存</p><p>(SRAM)</p><p>L3</p><p>高速缓存</p><p>(SRAM)</p><p>CPU寄存器保存着从高速缓存存储器取出的字</p><p><img src=img/f18161156f1a2e609e88c74c4ca13aa1.jpeg alt>} LI 高速缓存保存着从L2 高速缓存取出的缓存行</p><p>} L2高速缓存保存着从L3</p><p>高速缓存取出的缓存行</p><p>} L3高速缓存保存着从主存高速缓存取出的缓存行</p><p>更慢和</p><p>（每字节） 成本更低的存储设备</p><p>LS:</p><p>L4: 主存 ( DRAM )</p><p><img src=img/2529d2d4d0c8106b9480b0e718195b52.jpeg alt>本地二级存储（本地磁盘）</p><p>主存保存着从本地磁盘取出的磁盘块</p><p>本地磁盘保存着从远程网络服务器磁盘上取出的文件</p><p>图 6-21 存储器层次结构</p><p>或多个小型到中型的基于 SRAM 的高速缓存存储器， 可以 在儿个 CPU 时钟周期内访问它们 。 然后是一个大的基于 DRAM 的主存， 可以在几十到几百个时钟周期内访问它们。接下 来是慢速但是容扯很大的本地磁盘。最后，有 些 系统甚至包括了一层附加的远程服务器上 的 磁 盘 ， 要通 过 网 络来访问 它 们。例 如， 像安 德鲁 文件 系统 ( Andrew File System, AFS )或者网络文件系统 ( Netwo rk File System, NFS ) 这样的分布式文件系统，允 许程序访 问 存 储在远程的网络服务器上的文件。类似地，万 维 网允 许程序访问存储在世界上任何地 方的 Web 服务器上的远程文件。</p><p>m 其他的存储器层次结构</p><p>我们向你展示了一个存储器层次结构的示例，但是其他的组合也是可能的，而且确 实也 很 常见。例如，许 多站点（包括谷歌的数据 中心 ）将本地磁盘备份到存 档的磁带上。其中有些站点，在 需要时由人工装好磁 带。 而其他 站点则是 由磁 带机 器人 自动 地完成这项任务。 无论在哪种情况中，磁 带都是存储器层 次结构中的一层， 在本地磁盘层下 面， 本 书中提到的 通用原 则也 同样 适用于它。磁 带每 宇节比 磁 盘更便 宜， 它允 许站点将本地磁｝ 盘的多 个快照存档。代价是磁带的 访问时间要比磁盘的更长。 未看另一个例子， 固 态硬盘， 在存储器层 次结构 中扮 演着越 来越重要的角 色，连接 起 DRAM 和旋转磁盘之间的鸿沟。．</p><ol><li><p>3. 1 存储器层次结构中的缓存</p><p>一般而言， 高速缓存( cache , 读作 " cas h&rdquo; ) 是 一 个 小 而快速的存储设备， 它 作 为存储在更大、也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为缓存( caching, 读作 " cashing" ) 。</p><p>存储器层次结构的中心思想是， 对于每个 k , 位于 K 层 的 更 快更小的存储设备作为位于k + l 层 的 更 大更 慢的存储设备的缓存。换句话说， 层 次结 构中的每一层都缓存来自较低一层 的 数 据 对象 。 例 如，本地 磁盘作为通过网络从远程磁盘取出的文件（例如 Web 页面）的缓存， 主存作为本地磁盘上数据的缓存， 依此类推， 直 到 最小的缓存- CPU 寄存器组。</p><p>图 6- 22 展示了存储楛层次结构中缓存的一般性概念。第 k + l 层 的 存 储 器被划分成连续 的 数 据 对 象 组块( ch unk ) , 称为块&lt; block ) 。每个块都有一个唯一的地址或名字， 使之区别 于 其 他 的 块。块可以是固定大小的（通常是这样的）， 也 可以是可变大小的（例如存储在 Web 服务器上的远程 H T ML 文件）。例如，图 6- 22 中第 k + l 层 存 储 器被划分成 16 个大小 固 定 的 块 ，编 号 为 0 ~ 15。</p><p>第K 层： 亡工丿仁工丿仁五丿仁工丿 第K 层更小、更快、更昂贵的设备</p><p>｀ 缓存着第k+l 层块的一个子集</p></li></ol><p>二 二 数据以块为大小传输</p><p>单元在层与层之间复制</p><p>亡严］二亡仁仁二二仁</p><p>第k+I 层： 1</p><p>工二三二正］巨三］</p><p>口口口三］巨三］</p><p>第k+ I层更大、更慢、更便宜的设备被划分成块</p><p>图 6-22 存储器层次结构中基本的缓存原理</p><p>类似地， 第 k 层的存储器被划分成较少的 块的集合， 每个块的 大小与 k + l 层的块的大小一样。在任何时刻 ， 第 K 层的缓存包含第 k + l 层块的 一个子集的副本。 例如， 在图 6-22 中， 第 k 层的缓存有 4 个块的空间 ， 当前包含块 4 、9、14 和 3 的副本。</p><p>数据总是以 块大小为传送单元 ( t ra nsfer un it ) 在第 k 层和第 k + I 层之间来回复制的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以 有不同的块大小。例如， 在图 6- 21 中， L l 和 LO 之间的传送通常使用的是 1 个字大小的块。 L2 和 L1 之间（以及 L 3 和 L2 之间、L4 和 L3 之间）的传送通常 使用的是几十个字 节的块。而 L 5 和 L4 之间的传送用的是大小为几百 或几千字节的块。一 般而言 ， 层次结构中较 低层（离 CP U 较远）的设备的访问时间较长， 因此为了 补偿这些较长的 访问时间，倾 向 于 使用较大的块。</p><ol><li><p>缓存命中</p><p>当程序需要第 k + l 层的某个数据对象 d 时，它 首先在当前存储在第 k 层的一个块中查找 d 。 如果 d 刚好缓存在第 k 层中， 那么就是我们所说的缓存命 中( cache h代）。该 程序直接从第 k 层读取 d , 根据存储 器层次结构的性质，这 要比从第 k + l 层读取 d 更快。例如， 一个有良好时间局部 性的程序 可以从块 14 中读出一个数据对象， 得到一个对第 k 层的缓存命中。</p></li><li><p>缓存不命中</p><p>另一 方面， 如果第 K 层中没有缓存数据对象 d , 那么就是我们所说的缓存不命中(cache miss ) 。 当发生缓存不命中时， 第 k 层的缓存从第 k + l 层缓存中取出 包含 cl 的 那个块， 如果第 k 层的缓存已经满了 ， 可能就会覆盖现存的一 个块。</p><p>覆盖一个现存的 块的过程称为替 换( replacing ) 或驱逐( evicting ) 这个块。被驱逐的这个块有时 也称为牺牲块 ( vict im blo ck) 。决定该替换哪个块是由缓存的替换 策略 ( replace­ ment polic y) 来控制的。例如， 一个具有随机替 换策略 的缓存会随机选择一 个牺牲块。一个具有 最近最少被使用CLRU) 替换策略的缓存会选择那个最后被访问的时间距现在最远的块。</p><p>在第 k 层缓存从第 k + l 层取出那个块之后， 程序就能像前面一样从 第 k 层读出 d 了。例如，在 图 6-22 中， 在第 k 层中读块 1 2 中的一个数据对象， 会导致一个缓存不命 中， 因为块 1 2 当前不 在第 k 层缓存中。一旦把块 12 从第 k + l 层复制到第 k 层之后， 它就会保持在那里，等待稍后的访问。</p></li><li><p>缓存不命中的 种类</p><p>区分不同种类的缓存不命中有时候是很有帮助的。如果第 K 层的缓存是空的 ， 那么对任何数 据对象的访问都会不命中。一个空的缓存有时被称为冷缓 存 ( cold cache), 此类不命中称为 强制性 不命中( co m pulso r y m is s ) 或冷不命 中( cold mis s ) 。冷不命中很 重要 ， 因为它们通 常是短暂的 事件 ，不会 在反复访问 存储器使得缓存暖身 ( w a r m ed up ) 之后的稳定状态中出现。</p><p><img src=img/dbc5824f5fb1d5a0fb2286949ebd4e74.jpeg alt>只要发生了不命中， 第 K 层的缓存就必须执行某个放置策略 ( place men t policy), 确定把它从第 k + l 层中取出的块放在哪里。最灵活的替 换策略是允 许来自第 k + l 层的任何块放在第 k 层的任何块中。对于存储器层次结 构中高层的缓存（靠近 CP U ) , 它们是用硬件来实现的，而且速度是最优的，这个策略实现起来通常很昂贵，因为随机地放置块，定位起 来代价很高。</p></li></ol><p>因此， 硬件缓存通常使用的是更严格的放置策略， 这个策略将第 k + l 层的某个块限制放置在第 k 层块的一个小的子集中（有时只是一个块）。例如， 在图 6- 22 中， 我们可以确定第 k + l 层的块 1 必须放置在第 k 层的块(i mod 4 ) 中。例 如， 第 k + l 层的块 0、4、8 和 1 2 会映射到第 K 层的块 O; 块 1、5、9 和 1 3 会映射到块 1 ; 依此类推。注意 ， 图 6-22 中的示例缓存使用 的就是这个策略 。</p><p>这种限制性的放置策略 会引起一种不命中，称 为冲 突不命 中( confl ict miss ) , 在这种</p><p>情况中，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓 存块， 缓存会一直不命中。例如，在图 6- 22 中，如 果程序请求块 0&rsquo; 然后块 8 , 然后块 o,</p><p>然后块 8 , 依此类推， 在第 k 层的缓存中， 对这两个块的 每次引 用都会不命中， 即使这个缓存总共可以容纳 4 个块。</p><p>程序通常是按照一系列阶段（如循环）来运行的，每个阶段访问缓存块的某个相对稳定不变的集合。例如， 一个嵌套的循环可能会 反复地访问 同一个数组的元素。这个块的集合称为这个阶段的工作 集 ( w or k ing set ) 。当 工作集的大小超过缓存的大小时， 缓存会经历容量不命 中( capacit y m iss ) 。换句话说就是， 缓存太小了， 不能处理这个工作集。</p><ol start=4><li><p>缓存管理</p><p>正如我们提到过的，存储器层次结构的本质是，每一层存储设备都是较低一层的缓 存。在每一层上，某种形式的逻辑必须管理缓存。这里，我们的意思是指某个东西要将缓 存划分成块， 在不同的层之间传送块 ， 判定是命中还是不 命中， 并处理它们。管理缓存的逻辑可以是硬件、软件， 或是两者的结 合。</p><p>例如， 编译器管理寄存器文件， 缓存层次结构的最高层。它决定当发生不命中时何时发射加载， 以及确定哪个寄存器来存放数据。Ll 、L2 和 L3 层的缓存完全是由内 置在缓存中的硬件逻辑来管理的。在一个有虚拟内存的系统中， DRAM 主存作为存储在磁盘上的数据块的缓存， 是由操作 系统 软件和 CP U 上的 地址翻译 硬件共同管理的。对千一个具 有像 AFS 这样的分 布式文件系统的机器来说， 本地磁盘作为缓存，它 是由运行在本地机器上的 AFS 客户端进程管理的。在大多数时候， 缓存都是自动运行的， 不需要程序采取特殊的或显式的行动。</p></li><li><p>3. 2 存储器层次结构概念小结</p><p>概括来说，基于缓存的存储器层次结构行之有效，是因为较慢的存储设备比较快的存 储设备更便宜， 还因 为程序倾向 千展示局部性：</p><ul><li>利 用时间局部 性： 由于时间局部性， 同一数据对象可能会被多次使用。一旦一个数据对象在第一 次不命中时被复制到缓存中 ， 我们就会期望后面对该目标有一系列的访问命中。因为缓存比低一层的存储设备更快 ， 对后面的命中的服务会比最开始的不命中快很多。<ul><li><p>利 用空间局部性 ： 块通常包 含有多个数据对象。由于空间局部性， 我们会期望后面对该块中其他对象的访问能够补偿不命中后复制该块的花费。</p><p>现代系统中到处都使用了缓存。正如从图 6-23 中能够看到的 那样， CP U 芯片、操作系统、分布式文件系统中和万维网上都使用了缓存 。各种各样硬件和软件的组合构成和管理着缓存。注意， 图 6-23 中有大量我们还未涉及的术语和缩写。在此我们包括这些术语和缩写是为了说明 缓存是多么的普遍。</p></li></ul></li></ul></li></ol><p>类型 缓存什么 被缓存在何处 延迟（周期数） 由谁管理</p><table><thead><tr><th>CPU寄存器TLB Ll 高速缓存</th><th>4节字或8字节字 地址翻译 64字节块</th><th>芯片上的CPU寄存器芯片上的TLB 芯片上的Ll 高速缓存</th><th>。 4</th><th>编译器 硬件 MMU 硬件</th></tr></thead><tbody><tr><td>L2高速缓存</td><td>64字节块</td><td>芯片上的L2高速缓存</td><td>10</td><td>硬件</td></tr><tr><td>L3高速缓存</td><td>64字节块</td><td>芯片上的L3高速缓存</td><td>50</td><td>硬件</td></tr><tr><td>虚拟内存</td><td>4KB页</td><td>主存</td><td>200</td><td>硬件 + OS</td></tr><tr><td>缓冲区缓存</td><td>部分文件</td><td>主存</td><td>200</td><td>OS</td></tr><tr><td>磁盘缓存</td><td>磁盘扇区</td><td>磁盘控制器</td><td>100 000</td><td>控制器固件</td></tr><tr><td>网络缓存</td><td>部分文件</td><td>本地磁盘</td><td>10 000 000</td><td>NFS客户</td></tr><tr><td>浏览器缓存</td><td>Web页</td><td>本地磁盘</td><td>10 000 000</td><td>Web浏览器</td></tr><tr><td>Web缓存</td><td>Web页</td><td>远程服务器磁盘</td><td>I 000 000 000</td><td>Web代理服务器</td></tr></tbody></table><p>图 6~23 缓 存 在 现 代 计 算 机 系 统 中 无 处 不 在 。 T L B : 翻译后备缓 冲器 ( T ra ns la tion Lookas ide Ruffer); MMU: 内存管理单元 ( Memory Management Unit ) ; OS: 操作系统 ( Operating System);</p><p>AFS: 安德鲁文件系统( Andrew File System) ; NFS : 网络文件系统 ( Network File System)</p><p>6. 4 高速缓存存储器</p><p><img src=img/624371d7b85fd1afd3e34c7f5046e663.jpeg alt>早期计算机系统的存储器层次结构只有三层： CPU 寄存器、DRA M 主存储 器 和磁 盘存储。不 过， 由 千 CP U 和主存之间逐渐增大的差距， 系统设计者被迫在 CPU 寄存器文件和主存之 间插入了一个小的 SRAM 高速 缓 存存储 器， 称为 L1 高 速 缓 存（一级缓存）， 如 图 6-24 所 示。L1 高速缓存的访问速度几乎和寄存器一样快，典 型 地是大约 4 个时钟周期。</p><p><img src=img/79f6bc0516e4625996eab8ed370c173a.jpeg alt>CPU芯片</p><p>系统总线 内存总线</p><p>总接线口 三］</p><p>图 6- 24 高速缓存存储器的典烈总线结构</p><p>随着 CPU 和主存之间的 性能差 距不断增大 ， 系统设计者在 Ll 高速缓存和主存之间又插入了一 个更大的高速缓存， 称为 L2 高 速缓存， 可 以 在 大 约 1 0 个时钟周期内访问到它。有些现代系统还包括有一个更大的高速缓存，称 为 L3 高 速缓存， 在 存 储 器 层 次 结 构 中 ， 它位于 L2 高速缓存和主存之间， 可以在大约 50 个周期内访问到它。虽然安排上有相当多的变化， 但是通用原则是一样的。对于下一节中的讨论， 我们会假设一个简单的存储器层次结构， CPU 和主存之间只有一个 Ll 高速缓存。</p><p>6. 4. 1 通用的高速缓存存储器组织结构</p><p>考虑一个计算机系统 ，其 中 每 个 存 储 器地址有 m 位，形 成 M = 沪 个 不 同 的 地 址 。 如</p><p>图 6 - 25 a 所 示， 这样一个机器的高速缓存被组织成一个有 5 = 2&rsquo; 个高速缓 存组( ca ch e s e t ) 的</p><p>数组。每个组包含 E 个 高 速缓存行 ( cach e line ) 。每个行是由一个 B = Z1&rsquo; 字 节的数据块( block ) 组成的，一 个 有效位 ( va lid bit ) 指明这个行是否包含有意义的信息， 还有 t = m— ( b+ s ) 个标记位( t ag bit ) ( 是 当前块的内存地址的位的一个子集）， 它 们 唯 一 地标识存储在这个高速缓存行中的块。</p><p>每行1个 每行t个有效位标记位</p><p>每个高速缓存块有B=钞字节</p><p>广，''</p><p>匠言Io I I I···IB-</p><p>组0:</p><p>匡巠 二 1。I</p><p>I I &mldr; IB-lI ｝每组珩</p><p>S=25组</p><p>组I :</p><p>国 口三口1。I I I &mldr; IB-lI</p><p>阿 勹压门I I 1 I···la-1I</p><p>匡口</p><p>组s-</p><h6 id=i-i-i--ib-1i>I I I &mldr; IB-1I
<a class=anchor href=#i-i-i--ib-1i>#</a></h6><p>匣 口巨门I I I I &mldr; IB-11</p><p>高速缓存大小C=BxE xS数据字节</p><p>a)</p><table><thead><tr><th></th><th>t位</th><th>s位</th><th>b位</th></tr></thead><tbody><tr><td>地址：</td><td></td><td></td><td></td></tr><tr><td>m-1 &lsquo;y</td><td></td><td>" y</td><td>0 八 y ,</td></tr><tr><td></td><td>标记</td><td>组索引</td><td>块偏移</td></tr></tbody></table><p>图 6- 23</p><p>b)</p><p>高 速 缓 存 ( S , E, B, m ) 的 通 用 组 织 。 a) 高 速 缓 存 是 一 个 高 速 缓 存 组 的 数 组 。 每 个 组 包 含一 个 或 多 个行 ， 每 个 行 包 含 一 个 有 效 位 ， 一 些 标 记 位 ， 以 及一 个 数 据块 ； b) 高速缓存的结构将 m 个地址位 划分 成 了 t 个标记 位 、s 个 组索 引位 和 b 个块 偏移 位</p><p>一般而言， 高速缓存的结构可以用元组 CS , E, B, m ) 来描述。高速缓存的大小（或容矗）C 指的是所有块的大小的和。标记位和有效位不包括在内。因此， C= S X E X B。</p><p>当一条加载指令指示 CP U 从 主存地址 A 中读一个字时， 它 将地址 A 发送到高速缓存。如果高速缓存正保存着地址 A 处那个字的副本，它 就立即将那个字发回给 CPU。那么高速缓存如何知道它是否包含地址 A 处那个字的副本的呢？ 高速缓存的结构使得它能通过简单地检查地址位， 找到所请求的字， 类似于使用极其简单的哈希函数的哈希表。下面介绍它是如何工作的：</p><p>参数 S 和 B 将 m 个地址位分为了三个字段，如 图 6-25b 所示。A 中 s 个组索引位是一个到 S 个组的数组的索引。第一个组是组 0 , 第二个组是组 1 , 依此类推。组索引位被解释为一个无符号整数，它告诉我们这个字必须存储在哪个组中。一旦我们知道了这个字必 须放在哪个组中， A 中 的 t 个标记位就告诉我们这个组中的哪一行包含这个字（如果有的话）。当且仅当设置了有效位并且该行的标记位与地址 A 中的标记位相匹配时，组 中的这一 行 才包含这个字。一旦我们在由组索引标识的组中定位了由标号所标识的行， 那么 b 个块偏移位给出了在 B 个字节的数据块中的字偏移。</p><p>你可能已经注意到了， 对 高速缓存的描述使用了很多符号。图 6- 26 对这些符号做了个小结，供你参考。</p><table><thead><tr><th>基本参数</th><th></th></tr></thead><tbody><tr><td>参数</td><td>描述</td></tr><tr><td>S=2&rsquo;</td><td>组数</td></tr><tr><td>E</td><td>每个组的行数</td></tr><tr><td>B=2b</td><td>块大小（字节）</td></tr><tr><td>m=log2 (M)</td><td>（主存）物理地址位数</td></tr></tbody></table><p>图 6-26 高速缓存参数小结</p><p>讫； 练习题 6. 9 下表 给出 了几 个不 同的 高速 缓存的 参数。 确定 每个高 速缓存的 高 速缓存组数 CS ) 、 标记位 数 ( t ) 、 组 索引位 数( s ) 以及块偏 移位 数 ( b) 。</p><table><thead><tr><th>高速缓存</th><th>m</th><th>C</th><th>B</th><th>E s t</th><th>s</th><th>b</th><th></th></tr></thead><tbody><tr><td>I.</td><td>32</td><td>1024</td><td>4</td><td>I</td><td></td><td></td><td></td></tr><tr><td>2.</td><td>32</td><td>1024</td><td>8</td><td>4</td><td></td><td></td><td></td></tr><tr><td>3.</td><td>32</td><td>1024</td><td>32</td><td>32</td><td></td><td></td><td></td></tr></tbody></table><ol><li><p>4. 2 直接映射高速缓存</p><p>根据 每个组的高速缓存行数 E , 高速缓存被 分为不同的类。每个组只有一行( E = l ) 的高速缓存称 为直接映射高速缓存( dir ec t- mapped cache)( 见图 6-27 ) 。直接映射高速缓存是最容易实现和理解的 ， 所以我们会以 它为例来说明一些高速缓存 工作方式的通用概念。</p><p>组0: I五邑口匡勹1 高速缓存块 I I} £=匋组 1 行</p><p>组 I : I 匡囡口三勹二五亘亘五二=:J I</p></li></ol><p>组S- 1: I匡囡口亘口1 高速缓存 块 I I</p><p>图 6-27 直 接映射高速缓存 ( £ = 1) 。 每个组只有一行</p><p>假设我们有 这样一个系统， 它有一个 CPU 、一个寄存器文件、一个 Ll 高速缓存和一个主存。当 CPU 执行一条读内存字 w 的指令， 它向 Ll 高速缓存请求这个 字。如果 Ll 高速缓存有 w 的一个缓存的副本， 那么就得到 L1 高速缓存命中， 高速缓存会很快抽取出</p><p>w, 并将它返 回给 CPU。否则就是缓存不命中， 当 Ll 高速缓存向主存请求包含 w 的块的一个副 本时， CPU 必须等待。当被请求的块最 终从内存到达时， Ll 高速缓存将这个块存放在它 的一个高速缓存行里， 从被存储的块中抽取出字 w , 然后将它返回给 CPU。高速</p><p>缓存确定一个请求是否命中，然后抽取出被请求的字的过程．分为三步： 1) 组选择； 2)</p><p>行匹配； 3 ) 字抽 取 。</p><ol><li><p>直接映射高速缓存 中的组选择</p><p>在这一步中 ， 高速缓存从 w 的地址中间抽取出 s 个组索引位。这些位被解释成一个对应千一个组号的无符号整数。换旬话来说， 如果我们把高速缓 存看成是一个关于组的一维数 组， 那么这些组索引位就是一个到这个数组的索引 。图 6-28 展示了直接映射高速缓存的组选</p><p>择是如何工作的。在这个例子中， 组索引位 00001 2 被解释为一个选择组 1 的整数索引。</p><p>组0 : I 工[] I 标记 11 高速缓存块 I I</p></li></ol><p>选择的组 ， 组I : I国豆</p><p>高速缓存块</p><p>t位 丿s 位 b位</p><p>I 标 记 1 1 I I</p><p>I 0 0 0 0 I I I</p><p>m-1</p><p>标记 组索引 块偏移</p><p>组S- 1: I 匡邑I 标记 II</p><p>高速缓存块 I I</p><p>图 6- 28 直接映射高速缓存中的组选择</p><ol><li><p>直接映射高速缓存中的 行匹配</p><p>在上一步中我们已经选择了某个组 i&rsquo; 接下来的一步就要确定是否有字 w 的一个副本存储在组 t 包含的一个高速缓存行 中。在直 接映射高速缓存 中这很容易，而 且很快，这是因为每个组只有一行。当且仅当设置了有效位， 而且高速缓存行中的标记与 w 的地址中的标记相匹配时 ， 这一行中包含 w 的一个副本。</p><p>图 6- 29 展示了直接映 射高速缓 存中行匹配是 如何工作的。在这个例子中， 选中的组中只有一个高速缓存行。这个行的有效位设置了，所以我们知道标记和块中的位是有意义 的。因为这个高速缓存行中的标记位与地址中的标记位相匹配，所以我们知道我们想要的 那个字的一个副本确实存储在这个行中。换旬话说，我们得到一个缓存命中。另一方面， 如果有效位没有设晋，或者标记不相匹配，那么我们就得到一个缓存不命中。</p></li></ol><p>选择的组 ( i ) :</p><p>L</p><p>=I? ( I ) 有效位必须设置</p><p><img src=img/f634a42a054dbcf0bef4a713f7673936.jpeg alt><img src=img/6b8fc7df745f28326e1ff828874e489f.jpeg alt>01234567</p><p>( 2 ) 高速缓存行中的标</p><p>记位必须与地址中 ＝？</p><p>的标记位相匹配; —</p><p>t位 s位</p><p>I 0110 I i</p><p>m-1</p><p>( 3 ) 如果 ( I ) 和 ( 2 ) 满足， 那么高速缓存命中，块偏移就选择起始字节。</p><p>标记 组索引 块偏移</p><p>图 6-29 直接映射高速缓存中的行匹配和字选择。在高速缓存块中， w 。表示字 w</p><p>的低位字节， W 1 是下一个字节 ，依 此 类推</p><ol><li><p>直接映射高速缓存中的 字选择</p><p>一旦命中， 我们知道 w 就在这个块中的 某个地方。最后一步确定所需要的字在块中是从 哪里开始的。如图 6- 29 所示， 块偏移位提供了所需要的字的第一个字节的偏移。就像我们把高速缓存看成一个行的数组一样，我们把块看成一个字节的数组，而字节偏移是到</p></li></ol><p>这个数组的一个索引 。在这个示例中， 块偏移位是 100 2&rsquo; 它表明 w 的副本 是从块中的字节 4 开始的（我们假设字长为 4 字节）。</p><ol><li><p>直接映射高速缓存中不命中时的行替 换</p><p>如果缓存不命中 ， 那么它需要从存储器层次结 构中的下一层取出被请求的 块， 然后将新的块存储在组索引 位指示的组中的一个高速缓存行中。一般而言， 如果组中都是有效高速缓存行了， 那么必须要驱逐出一 个现存的行。对于直接映射高速缓存来说， 每个组只包含有一行，替 换策略非 常简单： 用 新取出的行替 换当前的行。</p><ol><li><p>综合 ： 运行中的 直接映射高速缓存</p><p>高速缓 存用来选择组 和标识行的机制极其简单， 因为硬件必须在几个纳秒的时间内完成这些 工作。不过，用 这种方式来处理位是很令人因惑 的。一个具体的例子能帮助解释清楚这个过程。假 设我们有一个直接映射高速缓存 ， 描述如下</p><p>( S , E , B , m ) = ( 4 , 1, 2 , 4 )</p><p>换句话说， 高速缓存有 4 个组， 每个组一行， 每个块 2 个字节， 而地址是 4 位的。我们还假设每个字都是单字节的。当然， 这样一些假设完全是不现实的， 但是它们能使示例保持简单。</p><p>当你初学高 速缓存 时， 列举出整个地址空间并划分好位是很有帮助的， 就像我们在</p><p>图 6-3 0 对 4 位的示例所做的那样。关于这个列举出的空间， 有一些有趣的事情值得注意 ：</p></li></ol></li></ol><p>图 6-30 示例直接映射高速缓存的 4 位地址空间</p><ul><li><p>标记位和索引位连起来唯 一地标识了内存中的每个块。例如， 块 0 是由地址 0 和 1</p><p>组成的， 块 1 是由地址 2 和 3 组成的， 块 2 是由地址 4 和 5 组成的， 依此类推。</p></li><li><p>因为有 8 个内存块， 但是只有 4 个高速缓存组 ， 所以多个块会映射到同一个高速缓存组（即它们有相同的组索引）。例如， 块 0 和 4 都映射到组 0 , 块 1 和 5 都映射到组 1&rsquo; 等等。</p></li><li><p>映射到同一个高速缓存组的块由标记位唯一地标识。例如， 块 0 的标记位为 o, 而</p><p>块 4 的标记位为 1, 块 1 的标记位为 o , 而块 5 的标记位为 1, 以此类推。</p><p>让我们来模 拟一下当 CPU 执行一系列读的时候， 高速缓存的执行情况。记住对于这</p></li></ul><p>个示例，我 们假设 CPU 读 1 字节的字。虽然这种手工的模拟很乏味，你 可能想要跳过它， 但是根据我们的经验，在学生们做过几个这样的练习之前，他们是不能真正理解高速缓存 是如何工作的。</p><p>初始时，高 速缓存是空的（即每个有效位都是 0 ) :</p><p>表中的每一行都代表一个高速缓存行。第一列表明该行所属的组， 但 是 请 记 住提供这个位只 是 为了方便，实 际 上 它并 不真是高速缓存的一部分。后面四列代表每个高速缓存行的实际 的 位 。 现在，让 我们来看看当 CP U 执行一系列读时，都 发 生 了 什 么 ：</p><ol><li><p>读地址 0 的字。因为组 0 的有效位是 o, 是缓存不命中。高速缓存从内存（或低一</p><p>层的高速缓存）取出块 o , 并把这个块存储在组 0 中。然后， 高速缓存返回新取出的高速缓存 行 的 块[ OJ的 m[ O] ( 内存位置 0 的内 容）。</p></li></ol><p>。 。</p><ol><li><p>读地 址 l 的字。这次会是高速缓存命中。高速缓存立即从高速缓存行的块[ 1] 中返</p><p>回 m[ l ] 。高速缓存的状态没有变化。</p><ol><li>读地址 13 的字。由于组 2 中的高速缓存行不是有效的，所 以 有缓存不命中。高速缓 存 把 块 6 加载到组 2 中，然 后 从新 的 高速缓存行的块[ 1] 中返回 m[ 13] 。<ol><li><p>读地址 8 的字。 这会发生缓存不命中。组 0 中的高速缓存行确实是有效的， 但是标 1 记不匹配。高速缓存将块 4 加 载到组 0 中（替换读地址 0 时读入的那一行）， 然后从新的商速缓存行的块[ OJ中返回 m[ 8] 。</p><p>组 有效位 标记位 块[OJ 块[ I]</p></li></ol></li></ol></li></ol><table><thead><tr><th>I 2 3</th><th>。I 。I</th><th>I I</th><th>m[8] m[l2]</th><th>m[9] m[l3]</th></tr></thead><tbody></tbody></table><ol><li>读 地 址 0 的字。又会发生缓存不命中，因 为在前面引用地址 8 时， 我们刚好替换了块 0 。 这就是冲突不命中的一个例子，也 就是我们有足够的高速缓存空间， 但 是 却交替地引 用 映 射 到 同 一 个组的块。</li></ol><h3 id=->。 。
<a class=anchor href=#->#</a></h3><ol><li><p>直接映射高速缓存中的 冲突不命中</p><p>冲突不命中 在真实的程序中很常见，会导 致令人困惑的 性能问题。当程序访问大小为</p><p>2 的幕的数组时 ， 直接映射 高速缓存中通常 会发生冲突不命中。例如， 考虑一个计算两个向量点积的函数：</p><p>float dotprod (fl oat x[8] , fl oat y [8 ])</p><p>｛</p><p>f l oa t sum= 0. 0;</p><p>inti;</p></li></ol><p>for (i =O;i &lt; 8 ; i ++ ) sum += x [ i ] * y [i] ;</p><p>r e t ur n sum;</p><p>对于 x 和 y 来说， 这个函数有良好的空间局部性， 因此我们期望它的命中率会比较高。不幸的是 ， 并不总是如此。</p><p>假设浮点数是 4 个字节， x 被加载到从 地址 0 开始的 32 字节连续内存中 ， 而 y 紧跟在</p><p>x 之后， 从地址 32 开始。为了简便 ， 假设一个块是 16 个字节（足够容纳 4 个浮点数）， 高速缓存 由两个组组成， 高速缓存的整个 大小为 32 字节。我们会假设变量 sum 实际上存放在一个 CPU 寄存器中， 因此不需要内存引用。根据这些假设每个 x [ i ] 和 y [ i ] 会映射到相同的高速缓存 组：</p><p>在运行时， 循环的第一次迭代引用 X [ O J&rsquo; 缓存不命中会导致包含 x [OJ ~x [ 3 ) 的 块被</p><p>加载到组 0。接下来是对 y [ O ] 的引 用 ， 又一次缓存不命中，导 致包含 y [ OJ ~ y [ 3 J 的 块被复制到组 o , 覆盖前一次引用复制进来的 x 的值。在下一次迭代中， 对 X (1 ) 的引用不命中，导致 x [ OJ ~ x [ 3 ] 的 块被加载回组 o, 覆盖掉 y [ OJ ~ y [ 3 ) 的块。因而现在我们就有了</p><p>一个冲突不命中，而 且实际上后面每次 对 x 和 y 的引用都会导致冲突不 命中， 因为我们在</p><p>x 和 y 的块之间抖动( t h ra s h ) 。术语“抖动” 描述的是这样一种情况， 即高速缓存反复地加载和驱 逐相同的高速缓存块的组。</p><p>简要来说就是， 即使程序有良好的空间局部性 ， 而且我们的高速缓存中也有 足够的空间来存放 x [ i ] 和 y [ i ] 的块， 每次引用还是会导致冲突不命 中， 这是因为这些 块被映射到了同</p><p>一个高速缓存组。这种抖动导致速度下降 2 或 3 倍并不稀奇。另外， 还要 注意虽 然 我们的示例极其简单，但是对于更大、更现实的直接映射高速缓存来说，这个问题也是很真实的。</p><p>幸运的是， 一 旦 程序 员 意 识 到 了 正 在 发 生 什 么 ，就 很 容易 修 正 抖 动问 题 。 一 个 很 简 单的方法 是 在 每 个 数 组 的 结 尾 放 B 字 节 的 填 充 。 例 如 ， 不 是 将 x 定 义 为 fl oa t x (8), 而是定义成f l oa 七 x [12 ) 。 假 设 在 内 存 中 y 紧 跟 在 x 后 面 ，我 们有 下 面这 样的 从数组元素到组 的映 射：</p><p>在 x 结 尾 加 了 填 充 ， x [i ] 和 y [ i ] 现 在 就 映 射 到 了 不同 的 组 ，消除 了 抖 动 冲突不命中。</p><p>已 练习题 6. 10 在前面 d o 七p r o d 的 例 子 中 ， 在 我 们 对数 组 x 做 了 填 充之后， 所有对 x</p><p>和 y 的引用 的命 中率是 多少？</p><p>m 为什么用中间的位来做 索引</p><p>你也许 会奇怪， 为什 么 高速 缓 存 用 中间的位 来作为 组 索 引 ， 而不是 用 高 位 。 为什么 用中间的位 更好 ， 是 有 很 好 的 原 因 的 。 图 6-31 说 明 了 原 因。 如 果 高 位 用做 索引， 那么． 一些连续的 内存块就会映射到相同的 高速缓 存 块 。例如 ， 在 图 中， 头四 个块映射到笫 一</p><p>个高速 缓 存 组 ， 笫 二 个四个块映射到笫二 个组， 依 此 类推。如 果一 个程序 有良好的 空间局 部 性 ， 顺 序 扫 描 一 个数组的元素， 那么在 任 何 时 刻 ， 高速 缓 存 都 只 保 存 着一个块大小i</p><p>高位索引 中间位索引</p><p><img src=img/1379adcac3e17941685c9149b29bed99.jpeg alt>I</p><p>凶00</p><p><img src=img/1a816532639fa73800f765801212ed1a.jpeg alt>凶 01 凶 JO 卯 11</p><p>4组高速缓存</p><h1 id=heading>=
<a class=anchor href=#heading>#</a></h1><p>组索引位</p><p>图 6- 3 1 为什么用中间位来作为高速缓存的索引</p><p>的数组内容。这样对高速 缓 存 的使用效率很低。相比较 而言， 以中间位作为 索引， 相 邻的块总是 映射到不同的 高速缓存行。在这里的情况中， 高速缓存能够存 放整个大小为 C 的数 组片 ， 这里 C 是 高速 缓 存的大小。</p><p>练习题 6. 11 假想一个高 速缓存， 用 地址 的 高 s 位做 组 索 引， 那 么 内存 块连续 的 片</p><p>( ch un k ) 会被映射到 同 一个 高速 缓存组。</p><ol><li><p>每个这样的连续的数组片中有多少个块？</p></li><li><p>考虑下面的代码 ， 它 运行在 一 个高 速 缓存 形 式 为 CS , E, B, m)=(512, 1, 32,</p><ol start=32><li>的系统上 ：</li></ol><p>int array[4096];</p><p>for (i = O; i &lt; 4096; i++)</p><p>sum += array [i] ;</p></li></ol><p>在任意时刻，存储在高速缓存中的数组块的最大数量为多少？</p><ol><li><p>4. 3 组相联高速缓存</p><p>直接映射高速缓存中冲突不命中造成的问题源千每个组只有一行（或者，按 照 我们的术语来描述就是 E = l) 这个限制。组相联高速 缓 存( set as socia t ive cac he ) 放松了这条限制， 所以每个 组都保存有多千一个的高速缓存行。一个 l &lt; E &lt; C/ B 的高速缓存通常称为 E 路 组相联 高速缓存。在下一节中，我 们会讨论 E = C/ B 这种特殊情况。图 6-32 展 示了一个 2 路组相联高速缓存的结构。</p><p>组o 1 [1 门勹尸｀冒三昙I}Ea每组2竹</p></li></ol><p>组I : I围记I 标记 1 1 高速缓存块</p><p>匝 I 标记 11 高速缓存块</p><p><img src=img/a9cbdc05deddfe442ce14b5fdbfad5e3.jpeg alt>匠 I 标记 1 1</p><p>高速缓存块</p><p>组S- 1: I 匡琶J I 标 记 11 苞速缓存块</p><p>图 6-32 组相联高速缓存 O &lt; E&lt; C/ B)。在一个组相联高速缓存中， 每个组包含多于 一个行。这里的特例是一个 2 路组相联高速缓存</p><ol><li><p>组相联高速缓存中的组选择</p><p><img src=img/3bce8c884ed8cf82c71c7b550c0011ef.jpeg alt>它的组选择与直接映射高速缓存的组选择一样， 组索引位标识组。图 6-33 总结了这个原理。</p><ol><li><p>组相联高速缓存中的行匹配和字选择</p><p>组相联高速缓存中的行匹配比直接映射高速缓存中的更复杂，因 为它必须检查多个行的标记 位和有效位，以 确 定 所 请 求 的 字是 否 在 集合中。传统的内存是一个值的数组，以 地址作为输 入，并 返 回 存 储 在 那 个 地 址 的 值 。 另 一 方 面， 相联存储 器是 一 个 ( k e y , va lu e ) 对的数组 ， 以 k e y 为输入，返 回 与 输 入 的 key 相匹配的( ke y , value ) 对中的 valu e 值。因此， 我们可以 把组相联高速缓存中的每个组都看成一个小的相联存储器， ke y 是 标 记和有效位， 而 valu e 就是块的内容。</p></li></ol></li></ol><p>选择的组</p><p>组0:</p><p>会 组I :</p><p>匣口亘勹[ 匡门居勹［</p><p>匣 口亘勹1</p><p>高速缓存块高速缓存块</p><p>高速缓存块</p><p>匣口亘三]I 高速缓存块</p><p>t位 b位</p><p>组S- 1:</p><p>匡 荨 I</p><p>高速缓存块</p><p>I</p><p>m-I</p><p>标记</p><p>组索引</p><p>匝 口压口1 高速缓存块</p><p>组相联高速缓存中的组选择</p><p>图 6-34 展示了相联高速缓存中行匹配的基本思想。这里的一个重要思想就是组中的任何一行都可以包含任何映射到这个组的内存块。所以高速缓存必须搜索组中的每一行， 寻找一个有效的行，其标记与地址中的标记相匹配。如果高速缓存找到了这样一行，那么 我们就命中，块 偏移从这个块中选择一个字， 和前面一样。</p><p>=1? ( I ) 有效位必须设置</p><p><img src=img/aeffb0a2ceb68fab8383f2a0bad9e093.jpeg alt>01234567</p><p>选择的组 ( i ) :</p><p>( 2 ) 高速缓存行中某一行</p><p>的标记位必须匹配地址中的标记位。</p><p>日 I I I wo I w, Iw 2 I 叭</p><p><img src=img/bd184272ad63c9a251c9e3bcf93c3a93.jpeg alt>( 3 ) 如果 ( 1 ) 和 ( 2 ) 为真， 那么高速缓存命中，然后块偏移选择起始字节。</p><p>t位</p><p>I 0110 I</p><p>m-1</p><p>标记</p><p>s位</p><p>-:­</p><p>l b</p><p>组索引 块偏移</p><p>图 6-34</p><p>组相联高速缓存中的行匹配和字选择</p><p>3. 组相联高速缓存中不命中时的行替换</p><p>如果 CP U 请求的字不在组的任何一行中，那 么 就 是 缓 存 不 命 中 ， 高速缓存必须从内存中取出包含这个字的块。不过，一旦高速缓存取出了这个块，该替换哪个行呢？当然， 如果有一个空行，那它就是个很好的候选。但是如果该组中没有空行，那么我们必须从中 选择一个非空的行，希 望 CP U 不 会 很 快 引 用 这个被替换的行。</p><p>程序员很难在代码中利用高速缓存替换策略，所以在此我们不会过多地讲述其细节。 最简单的替换策略是随机选择要替换的行。其他更复杂的策略利用了局部性原理，以使在 比较近的 将来引用被替 换的行的概率最小。例如， 最不 常使 用 ( Leas t-F req uently-Used, LF U ) 策略会替换在过去某个时间窗口内引用次数最少的那一行。最近最少使 用 ( Least­ Recently-Used, LRU ) 策略会替换最后一次访问时间最久远的那一行。所有这些策略都需要额 外的 时间 和 硬 件 。 但 是 ，越 往存储器层次结构下面走， 远离 CPU , 一次不命中的开销就会更加昂贵，用更好的替换策略使得不命中最少也变得更加值得了。</p><p>6. 4. 4 全相联高速缓存</p><p>全相联高速 缓 存( fully associative cache) 是由一个包含所有高速缓存行的组（即E = C/</p><p>B ) 组成的。图 6-35 给出了基本结构。</p><p>匣 仁亘 三 l 厂 高速缓存块匡 口 压口 1 高速缓存块</p><p>组</p><p>E =唯一的一组中有E =C/B行</p><p>匣 口 亘 口 1 高速缓存块</p><p>图 6- 35 全相联高速缓存( E = C/ B) 。在全相联高速缓存中， 一个组包含所有的行</p><ol><li><p>全相联高速缓存中的组选择</p><p>全相联高速缓存中的组选择非常简单，因 为只 有一个组，图 6-36 做了 个 小 结 。 注 意地址中没有组索引位，地址只被划分成了一个标记和一个块偏移。</p><p>I 匡荨厂一高速缓存块</p></li></ol><p>m-1</p><p>整个高速缓存只有一个组， 所以默认总是选择组0。</p><p>t位 b位</p><p>标记 块偏移</p><p>组0 :</p><p>1 击 勹 歪 勹 1 高速缓存块匠 勹 亘口 1 高速缓存块</p><p>图 6-36 全相联高速缓存中的组选择。注意没有组索引位</p><ol start=2><li><p>全相联高速缓存中的行匹配和字选择</p><p>全相联高速缓存中的行匹配和字选择与组相联高速缓存中的是一样的， 如图 6- 37 所示。它们之间的区别主要是规模大小的问题。</p><p>=l? ( l ) 有效位必须设置</p></li></ol><p><img src=img/4498d9905609784c4deb64492f5b347c.jpeg alt><img src=img/51e206367c94a893773e3da1e92f3bf6.jpeg alt>整个高速缓存</p><p>( 2 ) 高速缓存行中某一行的 ＝？</p><p>霍昙严匹配地址中户—[—、</p><p>t位</p><p>l 0110</p><p>m-1</p><p>b位</p><p>100</p><p>( 3 ) 如果 ( I ) 和 ( 2 ) 满足，那么 高速缓存命中，然后块偏移选</p><p>择起始字节。</p><p>。I</p><p>标记 块偏移</p><p>图 6-37 全相联高速缓存中的行匹配和字选择</p><p>因为高速缓存电路必须并行地搜索许多相匹配的标记，构 造一个又大又快的相联高速缓存很困难，而且很昂贵。因此，全相联高速缓存只适合做小的高速缓存，例如虚拟内存 系统中的 翻译备用缓冲器 ( T LB) , 它缓存 页表项（见9. 6. 2 节）。</p><p>压 练习题 6. 12 下面的问题能帮助你加强理解高速缓存是如何工作的。有如下假设：</p><ul><li>内存是字节寻址的。</li><li><img src=img/54e75e78358ca994d9e4920c7b3ffec4.jpeg alt>内存访 问的 是 1 字 节 的 字（不是 4 字 节的 字）。</li></ul><p>436 笫一部分 程序结构和执行</p><ul><li>地址的宽度为 1 3 位 。<ul><li><p>高速 缓存是 2 路组相联的CE = 2 ) , 块 大小为 4 字 节 ( B = 4 ) , 有 8 个 组 ( 5 = 8 ) 。高速缓存的内容如下， 所有的数 字都是以 十 六进 制来表 示的：</p><p>2路组相联高速缓存</p><p>行0 行1</p><p>。 。</p><p>。 。</p></li></ul></li></ul><p>2 EB</p><p>3 06</p><p>OB</p><p>32 I 12 08 78 AD</p><p>4 C7 I 06 78 07 cs 05 I 40 67 C2 3B</p><p>6 91 I AO B7 26 2D FO 。</p><p>7 46 DE 1 12 co 88 37</p><p>下面的图展 示的是地址格 式（每个小方框 一个位）。指出（在图 中标 出）用来确定下列内容的字段：</p><p>co 高速缓存块偏移</p><p>CI 高速缓存组索引</p><p>CT 高速缓存标记</p><p>12 11 10 9 8 7 6 5 4 3 2 1 0</p><p>芦 练 习题 6 . 13 假 设一个程序运行在练 习题 6-1 2 中的机器上， 它引用地 址 Ox 0E 3 4 处的1 个 字 节的 字。 指 出 访问的高 速 缓存条 目和十 六 进 制 表 示 的 返 回的 高 速 缓 存 字 节值。指 出是否会发 生缓存不命 中。 如果会出 现缓存不命 中， 用 “ 一” 来表 示 “ 返回的高速缓存字节”。</p><ol><li><p>地址格式（每个小方框一个 位）：</p><p>12 11 10 9 8 7 6 5 4 3 2 1 0</p></li><li><p>内存引用：</p></li></ol><p>沁囡 练习题 6 . 14 对于存储器地址 Ox ODDS, 再做一遍 练 习 题 6 . 1 3 。</p><ol><li><p>地址格式（每个小方框一个位）；</p><p>12 11 10 9 8 7 6 5 4 3 2 I 0</p></li><li><p>内存引用：</p></li></ol><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>高速缓存块偏移 ( CO )</td><td>Ox</td></tr><tr><td></td><td></td></tr><tr><td>高速缓存组索引CC I)</td><td>Ox</td></tr><tr><td>高速缓存标记 ( C T )</td><td>Ox</td></tr><tr><td></td><td></td></tr><tr><td>高速缓存命中？ （是I否）</td><td></td></tr><tr><td>返回的高速缓存字节</td><td>Ox</td></tr></tbody></table><p>区 练习题 6. 15 对于内存 地址 Ox 1 F E4 , 再做 一遍练 习题 6. 13。</p><ol><li>地址格式（每个小方框一个位）：</li></ol><p>12 11</p><p>仁</p><ol start=2><li><p>内存引用：</p><p>10 9 8 7 6 5 ．</p><p>I I I I I I</p><p>3 2 I</p><p>［</p></li></ol><p>亿 练习题 6. 16</p><p>制内存地址。</p><p>对于练习题 6. 1 2 中的 高速 缓存 ， 列 出 所 有的 在 组 3 中会命 中的 十 六进</p><ol><li><p>4. 5 有关写的问题</p><p>正如我们看到的， 高速缓存关于读的操作非常简单。首先， 在高速缓存中查找所需字</p><p>w 的副本 。如果命中， 立即返 回字 w 给 CPU。如果 不命中，从 存储器层次结构中较低层中取出包含字 w 的块， 将这个块 存储到某个高速缓存行中（可能会驱逐一个有效的行）， 然后返回字 w 。</p><p>写的情况就要复杂一些了。假设我们要写一个已经缓 存了的字 w ( 写命 中， w r it e hit ) 。在高速缓存 更新了它的 w 的副本之后， 怎么更新 w 在层次 结构中紧接着低一层中的副本呢？ 最简单的 方法， 称为直写 ( w rit e- t h ro ug h ) , 就是立即将 w 的高速缓存块写回到紧接着的低一层中。虽然简单，但是直写的缺点是每次写都会引起总线流批。另一种方法，称为</p><p>写回 ( writ e- back ) , 尽可能地推迟更新，只有当替换算法要驱逐这个更新过的块时，才把</p><p>它写到紧接着的低一层中。由于局部性，写回能显著地减少总线流量，但是它的缺点是增 加了复 杂性。高速缓存必须为每个高速缓存行维护一个额外的修改位 ( d ir t y bit), 表明这个高速 缓存块是否被修改过。</p><p>另一个问 题是如何处理写不命中。一种方法， 称为写分配( w rite-a llocat e ) , 加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。写分配试图利用写的空间局部 性，但是缺点是每次不命中都会导致一个块从低一层传送到高速缓存。另一种方法，称为 非写 分配( not- w r ite-a lloca te ) , 避开高速缓存， 直接把这个字写到低一层中。直写高速缓存通常 是非写分配的。写回高速缓存通常是写分配的。</p><p><img src=img/22d4aaf45f1a57ad870e865ba0aaee97.jpeg alt>为写操作优 化高速缓存是一个细致而困难的问题， 在此我们只略讲皮毛。细节随系统的不同而 不同， 而且通常 是私有的， 文档记录不详细。对于试图 编写高速缓存比较友好的</p></li></ol><p>程序的程序员来说，我们建议在心里采用一个使用写回和写分配的高速缓存的模型。这样建议有几个原因。通常，由千较长的传送时间，存储器层次结构中较低层的缓存更可能使用写回， 而不是直写。例如， 虚拟内存系统（用主存作为存储在 磁盘上的 块的缓存）只使用写回。但是由于逻辑电路密度的提高，写回的高复杂性也越来越不成为阻碍了，我们在现代系统的所有层次上都能看到写回缓存。所以这种假设符合当前的趋势。假设使用写回写分配方法的另一个原因是，它与处理读的方式相对称，因为写回写分配试图利用局部性， 因此，我们可以在高层次上开发我们的程序，展示良好的空间和时间局部性，而不是试图为某一个存储器系统进行优化。</p><p>6. 4. 6 一个真实的高速缓存层次结构的解剖</p><p>到目前为止，我们一直假设高速缓存只保存程序数据。不过，实际上，高速缓存既保 存数据， 也保存指令。只保存指令的高速缓存称为 i-ca che 。只保存程序数据的高速缓存称为 d-ca che。既保存指令又包括数 据的高速缓存称为统 一的 高速缓存( unified cache ) 。现代处理器包括独立的 i- cache 和 cl- ca che 。这样做有很多原因。有两个独立 的高速缓存， 处理器能够同时读一个指令字和一个数据字。i-cache 通常是只 读的， 因此比较简单。通常会针对不同的访问模式来优化这两个高速缓存，它们可以有不同的块大小，相联度和容量。使 用不同的高速缓存也确保了数据访问不会与指令访问形成冲突不命中，反过来也是一样， 代价就是可能会引起容量不命中增加。</p><p>图 6-38 给出了 Intel Core i7 处理器的高速缓存层次结构。每个 CPU 芯片有四个核。每个核有自己私有的 L l i-cac he 、L l cl- cache 和 L2 统一的高速缓存。所有的核共享片上L3 统一的高速缓存。这个层次结构的一个有趣的特性是所有的 SRAM 高速缓存存储器都 在 CP U 芯片上。</p><p><img src=img/95c959c591b7a638f8c23d17614ab2d9.jpeg alt><img src=img/bb31930aaf79036aef598308ab503a0d.jpeg alt>处理器封装</p><p>L3统一的高速缓存</p><p>- &lsquo;-. - - - - - _-&rsquo;&ndash; - - - - - -气产尸产 ) J :</p><p><img src=img/b03c8cdd0409dc488f8eee66c80caf08.jpeg alt><img src=img/ed5174927d32ce2c72ee3ca9da81ee17.jpeg alt></p><p>图 6- 38 Intel Core i7 的高速缓 存层次结构</p><p>图 6-39 总结了 Core i7 高速缓存的 基本特性。</p><table><thead><tr><th>高速缓存类型</th><th>访问时间（周期）</th><th>高速缓存大小 CC)</th><th>相联度 ( £ )</th><th>块大小 CB )</th><th>组数 ( S )</th></tr></thead><tbody><tr><td>LI i-cache</td><td>4</td><td>32KB</td><td>8</td><td>648</td><td>64</td></tr><tr><td>LI d-cache</td><td>4</td><td>32KB</td><td>8</td><td>64B</td><td>64</td></tr><tr><td>L2统一的高速缓存</td><td>10</td><td>256KB</td><td>8</td><td>64B</td><td>512</td></tr><tr><td>L3统一的高速缓存</td><td>40-75</td><td>8MB</td><td>16</td><td>64B</td><td>8192</td></tr></tbody></table><p>6. 4. 7</p><p>图 6-39 Core i7 高速缓存层次结构的特性</p><p>高速缓存参数的性能影响</p><p>有许多指标来衡量高速缓存的性能：</p><ul><li>不命 中率 ( m is s r a t e ) 。在一 个程序执行或程序的一部分执行期间，内 存引用不命中的比率。它是这样计算的： 不命 中数 量／引 用数 量。<ul><li><p>命中率( h it ra t e ) 。命 中的内存引用比率。它等于 1 一不命 中率。</p></li><li><p>命中时间 ( h it t im e ) 。从高速缓存传送一个字到 C P U 所需的时间， 包括组选择、行确认和字选择的时 间。对于 L1 高速缓存来说，命 中时间的数量级是几个时钟周期。</p></li><li><p>不命 中处罚 ( m is s p e n al t y ) 。由于不命中所需要的额外的时间。L1 不命中需要从 L2 得到服务的处罚 ，通常 是数 10 个周期 ；从 L3 得到服 务的处罚， 50 个周期；，从 主存得到的服务的处罚 ， 200 个周期。</p><p>优化高速缓存的成本和性能的折中是一项很精细的工作， 它需要在现实的基准程序代码上进行大量的模拟， 因此超出了我们讨论的范酣。不过， 还是可以认识一些定 性的折 中考量的。</p></li></ul></li></ul><ol><li><p>高速缓存大小的影响</p><p>一方面，较大的高速缓存可能会提高命中率。另一方面，使大存储器运行得更快总是 要难一些的 。结果， 较大的高速缓存可能会增加命中时间。这解释了为什么 L1 高速缓存比 L2 高速缓存小 ，以 及为什么 L2 高速缓存比 L3 高速缓存小 。</p></li><li><p>块大小的 影响</p><p>大的块有利有弊。一方面，较大的块能利用程序中可能存在的空间局部性，帮助提高 命中率。 不过， 对于给定的高速缓存 大小， 块越大就 意味着高速缓存行数越少，这 会损害时间局部性比空间局部性更好的程序中的命中率。较大的块对不命中处罚也有负面影响， 因为块越大 ， 传送时间就越长。现代系统（如C o r e i7 ) 会折中使高速缓存块包含 64 个字节。</p></li><li><p>相联度的 影响</p><p>这里的问 题是参数 E 选择的影响 ， E 是每个组中高速缓存行数。较高的相联度（也就是 E 的值较大）的优点是降低了高速缓存 由于冲突不 命中出现抖动的可能性。不过， 较高的相联 度会造成 较高的成本。较高的相联度实现起来很昂 贵， 而且很 难使之速度变快。每一行需要更多的标 记位， 每一行需 要额外的 LRU 状态位和额外的控制逻辑。较高的相联度会增加命中时间，因为复杂性增加了，另外，还会增加不命中处罚，因为选择牺牲行的 复杂性 也增加了。</p><p>相联度的选择最终变成了命中时间 和不命中处罚 之间的折中。传统上， 努力争取时钟频率的高性能系统会 为 L1 高速缓存选择较低的相联度（这里的不命中处罚 只是几 个周期）， 而在不 命中处罚比较高的较低层上使用比较小的相联度。例 如， I n t e l Core i7 系统中， L1 和 L2 高速缓存 是 8 路组相联的， 而 L3 高速缓存是 16 路组相联的。</p></li><li><p>写策略的 影响</p><p>直写高 速缓存比较容易实现， 而且能使用独立于高速缓存的写缓冲 区 ( w r it e buffer),</p><p>用来更 新内存。此外， 读不命中开销没这么大， 因为它们不会触发内存写。另一方面，写</p></li></ol><p>回高速缓存引起的传送比较少，它允 许更多的到内存的带宽用于执行 OMA 的 1/0 设备。此外 ， 越往层次结构下面走 ， 传送时间增加， 减少传送的数量就变得更 加重要。一般而言， 高速缓存越往下 层，越 可能使用写回而不是直写。</p><p>日 日 高速缓存行、组和块有什么区别？</p><p>很容易混淆高速缓存行、组和块之间的区别。让我们来回顾一下这些概念，确 保概念清晰：</p><ul><li>块是一个固定大小的信息 包， 在高速缓存和主存（或下一层高速缓存）之间来回传送。<ul><li><p>行是高速 缓存中的一个容 器，存 储块以及其他信 息（例如 有效位和标记位）。</p></li><li><p>组是一个或 多 个行的集合 。直接映 射高速 缓存中的组只由一行组成。组相联和全相联高速缓存中的 组是由多 个行组成的。</p><p>在直接映射高速缓 存中， 组和行实际上 是等价的 。不过 ， 在相联高速缓存中， 组和行是很不一 样的， 这两个词 不能互换 使用。</p><p>因为一 行总是存储一个块 ， 术语“行” 和“块“ 通常互换 使用。例如， 系统专 家总是说高速缓 存的“行大小＂， 实际上 他们指 的是块大小。这样的 用 法十分普遍，只要你理解块和行 之间的 区别 ， 它不会 造成任何误会。</p></li></ul></li></ul><ol><li><p>5 编写高速缓存友好的代码</p><p>在 6. 2 节中， 我们介绍了局部性的思想， 而且定性地谈了一下什么会具有良好的局部性。明白了高速缓存存储器是如何工作的，我们就能更加准确一些了。局部性比较好的程 序更容易有较低的不命中率，而不命中率较低的程序往往比不命中率较高的程序运行得更 快。因此，从 具 有良好局部性的意义上来说 ， 好的程序员 总是应该试着去编写高速缓存友 好( ca c he fr ie nd ly ) 的代码。下面就是我们用来确保代码高速缓存友好的基本方法 。</p><ol><li><p>让最常见的情况运 行得快。程序通常把大部分时间都花在少僵的核心函数上，而这些函数通常把大部分时间都 花在了 少量循环上。所以要把注意力集中在核心函数里的循环上， 而忽略其他部分。</p><p>2 ) 尽量减 小每 个循 环 内部 的缓存不命 中数量。在其他条件（例如加载和存储的总次</p><p>数）相同的情况下， 不命中率较低的循环运行得更快。</p><p>为了看看实际上这是怎么工作的 ， 考虑 6. 2 节中的函数 s umv e c :</p><p>int sumvec(int v[N])</p><p>｛</p><p>inti, sum= O;</p></li></ol></li></ol><p>for (i = 0; i &lt; N; i ++) sum+= v[i];</p><p>return sum;</p><p>这个函数高速缓存友好吗？ 首先， 注意对 于局部变量 1 和 s um, 循环体有良好的时间局部性。实际上，因为它们都是局部变量，任何合理的优化编译器都会把它们缓存在寄存器文 件中， 也就是存储器层次结 构的最高层中。现在考虑一下对向量 v 的步长为 1 的引用。一般而言， 如果一个高速缓存的块大小为 B 字节， 那么一个步长为 K 的引用模式（这里 k 是以字为单位的）平均每次循环迭代 会有 m in ( 1 , (wordsize X k) / B) 次缓存不命中。当 k = l 时 ，它 取最小值， 所以对 v 的步长为 1 的引用确实是高速缓存友好的。例如，假 设 v 是块对齐的， 字为 4 个字节， 高速缓存块为 4 个字，而 高速缓存初始为空（冷高速缓存）。然</p><p>后，无 论 是 什 么 样的高速缓存结构，对 v 的 引 用 都 会得到下面的命中和不命中模式：</p><p>v [ i l i=O i=I i=2 i=3 i=4 i=S i=6 i=7</p><p>1 访问顺序， 命中[h]或不命中 [m] I/ I [ml I 2 [h] I 3 (h] I 4 [h] I 5 [m) I 6 [h] I 7 [h] 8 [h]</p><p>在这个例子中，对 v [ O] 的 引 用 会 不命中， 而相应的包含 v [ O] ~ v [ 3 ] 的 块 会 被从内存加载到 高速缓存中。因此， 接下来三个引用都会命中。对 v [ 4 ] 的引 用会导致不命中， 而一个新 的块被加载到高速缓存中， 接下来的三个引用都命中，依 此类推。总的来说， 四 个引用中， 三个会命中，在 这种冷缓存的情况下， 这是我们所能做到的最好的情况了。</p><p>总之，简 单 的 s u mv e c 示例说明了两个关千编写高速缓存友好的代码的重要问题：</p><ul><li><p>对 局 部 变量的反复引用是好的，因 为编译器能够将它们缓存在寄存器文件中（时间局部性）。</p></li><li><p>步长为 1 的引用模式是好的，因 为存储器层次结构中所有层次上的缓存都是将数据存储为连续的块（空间局部性）。</p><p>在对多维数组进行操作的程序中， 空间局 部性尤其重要。例如， 考 虑 6. 2 节 中 的</p><p>s umar r a y r o ws 函 数 ，它 按 照 行 优 先 顺 序对一个二维数组的元素求 和：</p><p>int s umarr a yr o 甘 s (int a[M] [NJ)</p><p>｛</p><p>inti, j, sum= O;</p></li></ul><p>for (i = 0; i &lt; M; i ++)</p><p>for (j = O; j &lt; N; j++) sum += a[i] [j];</p><p>return sum;</p><p>由于 C 语言以行优先顺序存储数组，所 以 这 个函数中的内循环有与 s u rnv e c 一样好的步长为 1 的访问 模式 。例如，假 设 我们对这个高速缓存做与对 s urnv e c 一 样的假设。那么对数组 a 的引用会得到下面的命中和不命中模式：</p><p><img src=img/12e7787ca0409048a1b196c4de4ae6f8.jpeg alt>a [ i J f j J J=O</p><p>J = I</p><p>)=2</p><p>)=3</p><p>}=4</p><p>j=5</p><p>j=6</p><p>j=7</p><p>但是如果我们做一个看似无伤大雅的改变—— 交换循环的次序，看 看 会 发生 什么 ：</p><p>int sumarraycols(int a[M] [N])</p><p>｛</p><p>inti, j, sum= O;</p><p>for (j = 0; j &lt; N; j++)</p><p>for (i = 0; i &lt; M; i ++) sum += a [i] [j] ;</p><p>return sum;</p><p>在这种情况中， 我们是一列一列而不是一行一行地扫描数组的。如果我们够幸运， 整 个数组都在 高速缓存中，那 么 我们也会有相同的不命中率 1/ 4。不过， 如果数组比高速缓存要</p><p>大（更可能出现这种情况）， 那 么 每 次 对 a [il [j l 的 访 问 都 会 不 命 中！</p><table><thead><tr><th></th><th>a [il [j l</th><th>)=0</th><th>J=I</th><th>j=2</th><th>J=3</th><th>J = 4</th><th>j=5</th><th>J=6</th><th>j = 7</th><th></th></tr></thead><tbody><tr><td></td><td>i = 0</td><td>I [m)</td><td>5 [m)</td><td>9[m]</td><td>13 [m]</td><td>17 [m)</td><td>21 (m]</td><td>25 (m]</td><td>29 (m)</td><td></td></tr><tr><td></td><td>i = I</td><td>2 [m)</td><td>6 (m)</td><td>IO[m)</td><td>141m)</td><td>18 [m)</td><td>22 [m)</td><td>26(m]</td><td>30 fm]</td><td></td></tr><tr><td></td><td>i=2</td><td>3 [m)</td><td>7[m]</td><td>II [m]</td><td>15 [m)</td><td>19[m]</td><td>23 [m)</td><td>27 [m)</td><td>31 (m]</td><td></td></tr><tr><td></td><td>i= 3</td><td>4[m]</td><td>8 [m)</td><td>12 [m)</td><td>16 [ml</td><td>20 [m]</td><td>24 [m)</td><td>28 [m]</td><td>32 [m)</td><td></td></tr></tbody></table><p>较 高 的不 命 中 率 对 运 行 时 间 可 以 有 显 著 的 影 响 。 例 如 ， 在 桌 面 机 器 上 ， s u mar r a y­ r o ws 运 行 速 度 比 s u marr a y c o l s 快 25 倍。总之 ， 程 序 员 应 该 注 意 他 们 程 序 中 的 局部性， 试着编写利用局部性的程序。</p><p>; 练习题 6. 17 在信号处理和科学计算的应用中，转置矩阵的行和列是一个很重要的问题。从局部性的角 度 来 看， 它 也 很 有 趣， 因 为 它 的 引 用 模 式 既 是 以行 为 主 ( ro w­ w is e ) 的， 也 是以 列 为 主( co l u m n- w is e ) 的。例如， 考虑下面的转暨 函数：</p><p>typedef int array[2] [2];</p><p>3 void transposel(array dst, array src)</p><p>4 {</p><p>inti, j;</p><p>7 for (i = O; i &lt; 2; i++) {</p><p>8 for (j = O; j &lt; 2; j++) {</p><p>9 dst [j] [i] = src[i] [j] ; 10 }</p><p>｝</p><p>12 }</p><p>假设 在一 台具 有如下属性的机器上运行这段代码 ：</p><ul><li>sizeof (int) ==4。<ul><li>sr c 数组从地址 0 开始 ， d s t 数组从地址 1 6 ( 十进制）开始。</li></ul></li><li>只有一个 L1 数据高速缓存， 它是 直接映射的、直写和 写分 配的， 块 大小为 8 个字节。</li><li>这个高 速 缓存总的大小 为 1 6 个 数据 字 节 ， 一开始是 空 的。</li><li>对 sr c 和 d s t 数组 的访问 分别是读和 写 不命 中的唯 一来 源。</li></ul><ol><li><p>对每个r o w 和 c o l , 指明 对 s r c [ row] [col ) 和 d s t [row] [col ] 的 访问是命中( h)</p><p>还是 不命 中( m ) 。 例如， 读 s r c [OJ [ OJ 会 不命 中， 写 d s t [ O J [ OJ 也不命 中。</p></li></ol><p>d s t 数组</p><p>列0 列 l</p><p>m 0行</p><p>1行</p><ol start=2><li>对于一个大小 为 32 数据 字 节的高速缓存重 复这 个练 习。</li></ol><p>sr c数组</p><p>列0 列l</p><p>m</p><p>沁 员 练习题 6. 18 最 近 一 个很 成 功 的 游 戏 S im A q ua rium 的 核心就是 一 个 紧 密 循 环 ( tight loo p ) , 它计算 256 个 海藻( algae ) 的平均位置。 在一 台具 有块大小为 16 字 节 ( B = 1 6 ) 、整个大小为 10 24 字 节的直接映射数据缓存的机器 上测量它的高速缓存性能。 定 义如下：</p><table><thead><tr><th></th><th>struct</th><th>algae_position {</th></tr></thead><tbody><tr><td>2</td><td>int</td><td>x;</td></tr><tr><td>3</td><td>int</td><td>y;</td></tr><tr><td>4</td><td>} ;</td><td></td></tr></tbody></table><p>struct algae_position grid[16] [16]; int total_x = 0, total_y = O; inti, j;</p><p>还有如下假设：</p><ul><li><p>sizeof ( i n t ) ==4 。</p></li><li><p>g r i d 从内存地 址 0 开始。</p></li><li><p>这个高速缓存开始时是空的。</p></li><li><p>唯一的内存 访问是 对数 组 gr i d 的元素的 访问。放在寄存器中。</p><p>确定下面代码的高速缓存性能：</p><p>for (i = O; i &lt; 16; i++) {</p><p>for (j = 0; j &lt; 16; j++) { total_x += grid[i] [j] .x;</p></li></ul><p>变量 i 、 j 、total x和七0 七a l y 存</p><p>｝</p><p>for (i = O; i &lt; 16; i++) {</p><p>for (j = O; j &lt; 16; j++) { total_y += grid[i] [j] .y;</p><p>10 ｝</p><p>11 ｝</p><ol><li><p>读总数是多少？</p></li><li><p>缓存不命中的读总数是多少？</p></li><li><p>不命中率是多少？</p><p>饬 练习题 6. 19 给定 练 习题 6. 18 的假设， 确定下列代码的高速缓存性能：</p><p>for (i = O; i &lt; 16; i++){</p><p><img src=img/b7c0ec3652983c62b0e8a72a248551c5.jpeg alt>for (j = 0; j &lt; 16; j++) { total_x +=grid[j] [i] .x; total_y +=grid[j] [i] .y;</p><p>｝</p><p>｝</p></li><li><p>读总数是多少？</p></li><li><p>高速缓存不命中的读总数是多少？</p></li><li><p>不命中率是多少？</p></li><li><p>如果高速缓存有两倍大，那么不命中率会是多少呢？</p><p><img src=img/8d7b9df90f8f59cd6497f574e63fb5f1.jpeg alt>讫§ 练习题 6. 20 给定 练 习题 6. 18 的假 设， 确定 下列代码 的高 速缓存 性能 ：</p><p>for (i = O; i &lt; 16; i++){</p><p>for (j = O; j &lt; 16; j++) { total_x +=grid[i] [j] .x; totaLy +=grid[i] [j] .y;</p><p>｝</p><p>｝</p></li><li><p>读总数是多少？</p></li><li><p>高速缓存不命中的读总数是多少？</p></li><li><p>不命中率是多少？</p></li><li><p>如果高速缓存有两倍大，那么不命中率会是多少呢？</p></li></ol><p>6. 6 综合：高速缓存对程序性能的影响</p><p>本节通过研究高速缓存对运行在实际机器上的程序的性能影响，综合了我们对存储器层次结构的讨论。</p><p>6. 6. 1 存储器山</p><p>一个程序从存储系统中读数据的速率称为读吞吐 量( r e a d throughput), 或者有时称为读带宽( r e a d b a n d w id t h ) 。如果一个程序在 s 秒的时间段内读 n 个字节，那 么 这段时间内的读吞吐量就等于 n / s , 通常以兆字节每秒( M B / s ) 为单位。</p><p>如果我们要编写一个程序，它从 一个紧密程序循环( t ig h t program loop) 中发出一系列读请求 ，那 么测 量出 的读 吞 吐 量能让我们看到对于这个读序列来说的存储系统的性能。图 6-40</p><p>code/mem/mountainlmountain.c</p><p>long data[MAXELEMS];</p><p>2</p><p>I* The global array we&rsquo;ll be traversing *f</p><ol><li><p>I* test - Iterate over first &ldquo;elems&rdquo; elements of array &ldquo;data&rdquo; with</p><ol><li><p>* stride of &ldquo;stride&rdquo;, using 4 x 4 loop unrolling. s *I</p><p>6 int test (int elems, int stride)</p><p>7 {</p></li></ol></li><li><p>long i, sx2 = stride*2, sx3 = stride*3, sx4 = stride*4;</p></li><li><p>long accO = 0, accl = 0, acc2 = 0, acc3 = O; 1o long length = el ems;</p><p>11 long limit = length - sx4; 12</p></li><li><p>/* Combine 4 elements at a time *I</p></li><li><p>for (i = O; i &lt; 1i 工 t ; i += sx4) {</p></li><li><p>accO = accO + data [i] ;</p></li><li><p>accl = acc1 + data[i+stride];</p></li><li><p>acc2 = acc2 + data[i +sx2] ;</p></li><li><p>acc3 = acc3 + data[i +sx3] ; 19 }</p><p>20</p></li><li><p>I* Finish any remaining elements *I</p></li><li><p>for (; i &lt; length; i+=stride) {</p></li><li><p>accO = accO + data [i] ; 24 }</p><p>25 return ((accO + accl) + (acc2 + acc3)); 26 }</p><p>27</p><p>28 I* run - Run test(elems, stride) andreturn read throughput (MB/s). &ldquo;size&rdquo; is in bytes, &ldquo;stride&rdquo; is in array elements, and Mhz is CPU clock frequency in Mhz.</p></li></ol><p>32 double run (int size, int stride, double Mhz) 33 {</p><ol><li>double cycles;</li><li>int elerns = size / sizeof (double) ; 36</li><li>test (elerns, stride); I* Warm up the cache *I</li><li>cycles = fcyc2(test, elerns, stride, 0); I* Call test(elerns,stride) *I</li><li>return (size / stride) / (cycles / Mhz); I* Convert cycles to MB/s *I 40 }</li></ol><p>code/memlmountain/mountain.c</p><p>图 6-40 测量和计 算读吞吐量的函数。我们可以通过以不同的 s i ze ( 对应千时间局部性）和</p><p>s tr i d e ( 对应于空间局部性）的值来调用r un 函数， 产生某台计算机的存储器山</p><p>给出了一对测量某个读序列读吞吐量的函数。</p><p>t e s t 函数通过以 步长 s tr i de 扫描一个数组的头 e l e ms 个元素来产生读序列。为了提高内 循环中 可用 的并行性， 使用了 4 X 4 展开（见5. 9 节）。r un 函数是一个包装函数， 调用 t e 江 函数， 并返回测最出的读吞吐量。第 37 行对 t e s t 函数的词用会对高速缓存做暖身。第 38 行的 f c yc 2 函数以参数 e l e ms 调用 t e s t 函数， 并估计 t e s t 函数的运行时间，以 CP U 周期为单位。注意，r un 函数的参数 s i ze 是以字节为单 位的， 而 t e s t 函数对应的参数 e l e ms 是以数组元素为单位的。另外 ， 注意 第 39 行将 MB/ s 计算为 1矿字节／秒， 而不是 220 字节／秒。</p><p>r un 函数的参数 s i ze 和 s tr i de 允许我们控制产生出的读序列的时间和空间局部性程度。 s i ze 的值越小， 得到的工作集越小 ， 因此时间局部性越好。s tr i de 的值越小， 得到的空间 局部性越好。如果我们反复以 不同的 s i ze 和 s tr i de 值调用r un 函数， 那么我们就能 得到一个读带 宽的时间和空间 局部性的二维函数， 称为存储器山 ( memor y moun­ tain )[ ll 2] 。</p><p>每个计算 机都有表明它存储器系统的能力特色的唯一的存储器山。例如， 图 6- 41 展示了 Intel Core i7 系统的存储器山。在这个例子中， s i ze 从 16KB 变到 128K B, stride 从 1 变到 1 2 个元素，每 个元素是一个 8 个字节的 l o ng i nt 。</p><p>空间局部性</p><p>的斜坡</p><p><img src=img/ec15805065e1d960967ecf35dec0761b.jpeg alt>16000</p><p>4000</p><p>2000</p><p>Core i7 Haswell</p><p>2.1 GHz</p><p>32 KB LI 高速缓存</p><p>256 KB L2高速缓存</p><p>8MB L3高速缓存</p><p>64B块大小</p><p>时间局部性</p><p>山脊</p><p>3 1.28K</p><p>512K</p><p>2M</p><p>盓</p><p>128M</p><p>大小（字节）</p><p>图 6- 41 存储器山。展示了读吞吐量， 它是时间 和空间局部性的函数</p><p>这座 Core i7 山的地形地势展现了一个很丰富 的结构。垂直千大小轴的是四条山脊， 分别对应 千工作 集完 全在 Ll 高速缓存、LZ 高速缓存、L3 高速缓存和主存 内的时间局部性区域。注意 ， Ll 山脊的最高点（那里 CP U 读速率为 14GB / s ) 与主存山脊的最 低点（那里</p><p>CPU 读速率 为 900M B/ s) 之间的差别有一个 数量级。</p><p>在 LZ、 L3 和主存山脊上，随 着步长的增加， 有一个空间局部性的斜坡， 空间局部性下降。注意，即使当工作集太大，不能全都装进任何一个高速缓存时，主存山脊的最高点 也比它的最低点高 8 倍。因此，即 使是当程序的时间局部性很差时， 空间局部性仍然能补救，并且是非常重要的。</p><p>有一条特别有趣的平 坦的山脊线， 对于步长 1 垂直于步长轴， 此时读吞吐輩相对保持不变， 为 1 2GB/ s , 即使工作集超出了 L1 和 L2 的大小。这显然是由 于 Core i7 存储器系统中的硬件预取( prefe tch ing ) 机制， 它 会自动 地识别顺序的、步长为 1 的引用模式， 试图在一些块被访问之前， 将它们取到高 速缓存中。虽然文档里没有记录这种预取算法的 细节， 但是从存储器山可以明显池看到这个算法对小步长效果最好 这也是代码中要使用步长 为 1 的顺序访问的另一个理由。</p><p>如果我们从这座山 中取出一个片段， 保持步长为常数， 如图 6-42 所示， 我们就能很 清楚地看到高速缓存的大小和时间局部性对性能的影响了。大小最大为 32KB 的工作集完全能放进 Ll cl-c ache 中， 因此， 读都是由 L1 来服务的， 吞吐最保持在峰值 12GB/ s 处。大小最大为 256KB 的工作集完全能放进统一的 L2 高速缓存中 ， 对千大小 最大为 8 M , 工作集完全 能放进统一的 L3 高速缓存中。更大的工作集大小 主要由主存来 服务。</p><p>14 000</p><p>12 000</p><p>10 000</p><p>乏芦 8000</p><p><img src=img/84158c99ae4ab69cbd7e821b296a897f.jpeg alt>、</p><p>主存区域 L3高速缓存区域</p><p>LI高速</p><p>L2高速缓存区域 缓存区域</p><p>i 6000</p><p>4000</p><p>2000</p><p>0 .</p><p>工作集大小（字节）</p><p>图 6-42 存储 器山中时间局部性的山脊。这幅图展示了图 6-41 中 s 七r i cte = S 时 的 一 个 片段</p><p>L2 和 L3 高速缓存区域最左边的边缘上读吞吐量的下降很有趣， 此时工作集大小为256K B 和 8 MB, 等于对应的高速缓 存的大小。为什么会出现这样的下降， 还不是完全清楚 。要确认的唯一方法就是执行一个详细的高速缓存模 拟， 但是这些下降很有可能是与其他数据和代码行的冲突造成的。</p><p>以相反的方向横切这座山，保持工作集大小不变，我们从中能看到空间局部性对读吞吐量 的影响。例如， 图 6-43 展示了丁作集大小固定为 4MB 时的片段。这个片段是沿着图 6- 41 中的L3 山脊切的，这里， 工作集完全能够放到 L3 高速缓存中， 但是对 L2 高速缓存来说太大了。</p><p>注意随着步长从 1 个字增长到 8 个字， 读吞吐量是如何平稳地下降的。在山的这个区域中， L2 中的读不命中会导致一个块从 L3 传送到 L2。后 面在 L2 中这个块上会有一定数量的命中， 这是取决千步长的 。随着步长的增加， L 2 不命中与 L2 命中的比值也增加了。因为服务不命中要比命中更慢， 所以读吞 吐量也下降了。一旦步长达到了 8 个字， 在这个系统上就等于块的 大小 64 个字节了， 每个读请求在 L2 中都会不命中， 必 须从 L3 服务。</p><p>因此， 对于至少为 8 个字的步长来说， 读吞吐最是一个常数速率， 是由从 L3 传送高速缓存块到 L2 的速率决定的。</p><p>12 000</p><p>10 000</p><p><img src=img/cefe3deadc287401c02b924fdc6726cc.jpeg alt>8000</p><p>6000</p><p>4000</p><p>2000</p><p>s1 s2 s3 s4 s5 s6 s7 s8</p><p>步长 ( X 8字节）</p><p>s9 s10 s11</p><p>图 6-43 一个空间局部性的斜坡。这幅图展示了图 6-41 中大小= 4MB 时的一个片段</p><p>总结一下我们对存储器山的讨论，存储器系统的性能不是一个数字就能描述的。相 反，它是一座时间和空间局部性的山，这座山的上升高度差别可以超过一个数量级。明智 的程序员会试图构造他们的程序，使得程序运行在山峰而不是低谷。目标就是利用时间局 部性， 使得频繁使用的 字从 L1 中取出， 还要 利用空间局部性， 使得尽可能多的字从一个L1 高速缓存行 中访问到。</p><p>讫 练习题 6. 21 利用 图 6-41 中的存储器 山来估计从 L1 d- ca c h e 中读 一个 8 字 节的 字所需要的 时间（以 CPU 周期为 单位）。</p><ol><li><p>6. 2. 重新排列循环以提高空间局部性</p><p>考虑一对 n X n 矩阵相乘的问题： C= AB 。例如， 如果 n = 2 , 那么</p><p>[ C11C 12 ] = [ au a12][加b 12 ] C21 c22 a 21a22 b21 b22</p><p>其中</p><p>c11 =a11b11 +a12b21</p><p>C1z = a 11 如 + a12 b22</p><p>c21 = a 21 b11 +a22 b21 C22 = a 21 如 + a 22b 22</p><p>矩阵乘法 函数通常是用 3 个嵌套的循环来实现的，分别 用 索引 z、 1 和K 来标识。如果改变循环的次 序， 对代码进行一些其他的小改动， 我们就能 得到矩阵乘法的 6 个在功能上等价的版本 ， 如图 6-44 所示。每个版本都以它循环的顺 序来唯一地标识。</p><p>在高层次来看， 这 6 个版本是非常相似的。如果加 法是可结 合的， 那么每个版本计算出的结果完全 一样气 每个版本总共都执行 O ( n3 ) 个操作， 而加法和乘法的数量相同。A</p></li></ol><p>8 正如我们在第 2 章中学到的 ，浮点 加法是可交换的 ， 但是通常是 不可结 合的。实际 上，如果 矩阵不 把极大的数和极小的数混在一起一存储物理属性的矩阵常常这样，那么假设浮点加法是可结合的也是合理的。</p><p>和B 的 矿个 元素中的每一个都要读 n 次；计 算 C 的 示 个 元素中的 每一个都要对 n 个值求和。不过，如果分析最里层循环迭代的行为，我们发现在访问数量和局部性上还是有区别的。为了分析，我们做了如下假设： - - ,.三</p><ul><li><p>每个数组都是一个 do ub l e 类型的 n X n 的数组， s i z e o f (d o ub l e ) = B。</p></li><li><p>只 有一个高速缓存，其 块大小为 32 字节( B = 32 ) 。 ＇，</p></li><li><p>数组大小 n 很大， 以至于矩阵的 一行都不能完全装进 Ll 高速缓存中。</p><p>·编译器将局部变量存储到寄存器中，因此循环内对局部变量的引用不需要任何加载</p></li></ul><p>或存储指令</p><p>codelm.emlmatmult/mm.c for (i = 0; i &lt;::i;i; i++)</p><p>for (j = 0; j &lt; n; j ++)</p><p>sum= 0.0;</p><p>for (k = 0; k &lt; n ;, k++)</p><p>sum += A[i] [kl*B[k] [j];</p><p>for (j for</p><p>, &lsquo;Cl-</p><p>code/memlmatmultlmm.c</p><p>== O; j &lt; &rsquo;n; · j ++)</p><p>(i a;= 0 ; i &lt; n ; i ++) {</p><ul><li><p>sum = 0., , ,,,</p><p>, f or , (k = 0; k &lt; n; k++)</p><p>&rsquo; ··· · s um ,f = A [i] [k] *B [k] [j];</p></li></ul><p>C [i] [j] += suin;</p><ul><li><p>; ·; . ,.</p><p>C[il[j] += sum;</p></li></ul><p>·&rsquo;·_;, • h ide/ me成lmatmultlmm.,c - ＿</p><p>code/mem/matmultlmm.c</p><p>. • _ a) ij k版 本 、． ． ， ｀ 一 ,.. ,:._.,· . _,.. ,,• • _b) j ik版本 ， ． ． ．</p><p>, • &rsquo; : : .,·</p><ul><li><p>;,, : ., &lsquo;、 . . . ．．屯: ..,. .</p><p>• .,.. ,,·. ,• , _, , ,. · I &lsquo;· . &mldr;_-</p><p>., &rsquo; , . , r· .. ..· ,&rsquo;•_,</p></li></ul><p>code/mem/matmultlinm.c code/mem/matm it&rsquo;Wmm.c</p><p>C .&rsquo; , . &rsquo; . . . . • ·,: · &rsquo; . .•. · , .· , ·, ., . , . . .. , &rsquo; . &rsquo;&rsquo; , j l &rsquo; •.- ., , , , ．、.•··. .. ·.&rsquo;&rsquo; t.,r. •.· · ·&rsquo;&rsquo; · 千·二J- ，</p><p>,> ＇</p><p>, · , : f or · ( j &rsquo; ==· O; j &lt; Ii; j +&rsquo;+) , &rsquo; ··• f &rsquo; fo r &rsquo; &rsquo; Ck •,;; O; &lsquo;.k &lsquo;&lt; ri;&rsquo; k ++) ·····-</p><p>2 ;· &lsquo;.&lt; &lt; .&rsquo; fo r ( k: =, &lsquo;O; k &lt; ri.; k ++) { i- ;•. · , :_• ; :2 ·, ,, ;;, _&lsquo;f or \ f; ,,;_ o ;&rsquo; j &lt;: n ;;-;j ++f { &lsquo;一，心 t 1</p><p>3 . .. _,·.</p><p>._ · .: r.</p><p>:;,- J3[k]{jJ,; ., -:.</p><p>:i .. ·,. ;,.· '</p><p>) 3 ;; ; , i &lsquo;. ) • :• r . r= _B[k} .f jJ ,;: >&rsquo;::i ) -1&rsquo; ; ;., ;:,: . :fi 心</p><p>4 for (i = O; i &lt; n; i++) 4 for (i =;o, O; _, i</p><p>社吵 ．，</p><ul><li>, 、 . . ! ..!</li></ul><p>5 , C[i] [j] += A[i] [k]*r; . . 5 C i)(jJ += A[i] [k]*r;</p><p>/ _.,:&ndash; · ·, &rsquo; }_ :-, :• . _ ; . :, -,-: . ,, · ; : , . i : - .·,.. ;. 6 &rsquo; \_: ·&rsquo;·: j:&rsquo; f: : &rsquo; ,; ·&rsquo;.,&rsquo;. .:·</p><p>codelmem/matmult/mm.c</p><p>, , &rsquo; 飞 ；｀ ＇ ＇， 、</p><p>．令</p><p>钉</p><p>c) j ld版本</p><p>codelmem/matmultlmm.c</p><p>d ) 炉版本</p><p>code/mem/matmultlmm.c</p><p>,; . ;&rsquo;, .. . . . , \</p><p>, &rsquo; , . . . . ··, ,,,•</p><p>&lsquo;产 i ,&rsquo; ,</p><p>.,.</p><p>for (k = O; k &lt; Ii; k++,) · -, : . ..</p><p>· · ·</p><p>f or &rsquo; Ci -&rsquo; &lsquo;= b;、.i</p><p>&lt; ri;· i ++) &lsquo;. . , ｀</p><p>for (i = O; i &lt; n; i++) { i ,</p><p>r = A (i] [k] ; , • ,</p><p>for (j = O; j &lt; n; j++) C[i] [j] += r*B[k] [j];</p><p>｝</p><p>codelmemlmatmultlmm.c</p><p>e ) 的版本</p><p>f o 士 ( k = O; k &lt; n; k++) { r = A[i][k];</p><p>for (j = O; j &lt; n; j++)</p><p>C [i] [j] += A [i] [k] *r; rt d t</p><p>心:• &lt; }</p><p>code/mem/matmultlmm.c</p><p>f) ikj版本</p><p>图 6- 44 矩阵乘法的六个版本。每：个 版本都以它循环的顺序来唯一地标识</p><p>, _,. ,: _;. . &lsquo;! '</p><p>_ ; , , . , .. .</p><p>．～, -</p><p>户:·, 占&rsquo;</p><p>_: l .:: f. ·. &lsquo;<em>..,-: ·</em>:..-,;:- &mldr; :·: . . ·-": ; ·,, _ _.,i</p><p>.,.>.._,.,.,,·;&rsquo;··七,; ;一．，,．, /，:＇}·;; 言获</p><p>图 6;,45总结了我们对内循环的分析结果。注意6个版本成对地形成了 3个等价类，&rsquo;;._用内循环中访问的矩阵对来表示每个类。例如. 版本 ij k 和ji k 是类f.-1$的成员，: 因为它们在最内层的循环中引用的是矩阵A和I?(而不是C),。对千每个类，我们统计了每个内循环</p><p>迭代中加载（读）和存储（）写的数量，每次循环迭代中对A、B 和C的引用在高速缓存中丕</p><p>命中的数量，以及每次迭代缓存不命中的总数。</p><p>* 类 AB 例程的内循环（图t 44a 和图 6— b)以步长1 扫描数组 A 的- 行汗 因为每个高</p><p>速缓存块保存四个 8 字节的字，A 的不命中率是每次迭代不 命中 0·.-25 次。另 一方 面，内</p><p>循环以步长 n 扫描数组B 的一列。因 为 n 很大，每次对数组 B 的访问都会不命中，所以每次迭代总共会有 1 心 5 次不命中。</p><p>矩阵乘法版本</p><p>&lsquo;, • (类）;··,.</p><p>匕 、 &rsquo; . '</p><p>ijk &amp;jik (AB)</p><p>｀｀</p><p>丿kt& kji (AC)</p><ul><li>kij & ikj(BC)</li></ul><p>图 6-45</p><p>每次迭代</p><p>加载次数 存储次数 A未命中次数 B未命中次数 C未命中次数 未命中总次数</p><p>0.25 1.00 0.00 1.25</p><p>1.00 0.00 LOO 2.00</p><p>0.00 0.25 0.25 0.50</p><p>矩阵乘法内循环的分析。6 个版本分为 3 个等价类，用 内循 环中访问 的数组对来 表示</p><p>类 AC 例程的内循环（图6-44c 和图5 _:4 4d ) 有、一些问题。每次迭代执行两个加载和一个存储（相对千类AB例 程， 它们执行 2 个 加载而没有存储）。内循环以步长n 扫描A 和C 的列。名结 果是每次加载都会不命中 ，所 以每次迭代总共有两个不命中。注意 ， 与类AB例程</p><p>相比，交换循环降低了空间局部 性。</p><p>BC 例程（图6 44e 和图 5:_44f)展示了一个很有趣的折中： 使用了两个加载和一个存储 ，</p><p>它们比 AB 例程多需要一个内存操作。另一方 面， 因为内循环以步长为 1 的访问模式按行</p><p>扫描B和c ·, 每 次迭代每个数组上的不命中率只有0 : 25 次不命中，所 以每次迭代总 共有</p><p>o·:so个不命中。</p><p>图 6 4 6 小结了一个Cotei7 系统上矩阵乘法各个版本的性能 。这个图画出了测量出的每次内循环迭代所需 的CPU周期数作为数组大小( n) 的函数。、</p><p>100</p><p>睾</p><p>; &lsquo;. \·: : , :· : \ : .</p><p>子</p><p>太</p><p>，.&rsquo;</p><p>50 100 150 200 250 300 350 400 450 500 550 600 650 7 的</p><p>！ 飞 ．，．、·,:.:;-:&rsquo;</p><p>数组大小( n ) ..</p><p>图 6- 46 Core· 17 矩阵乘法性能</p><p>_·: .-,_</p><p>;_ , · :</p><p>对千这幅图有很多有意思的地方值得注意：</p><ul><li>对于大的 n 值， 即使每个版本都执行相同数量的浮点算术操作 ， 最快的版本比最慢</li></ul><p>、 的 版本运行得快几乎 40 俨口。</p><p>. : . .</p><ul><li><p>每次迭代内存引用和不命中数量都相同的一对版本，有大致相同的测最性能。</p><p>) • 内 存行为最糟糕的两个版本，就每次迭代 的访问 数量和不命中数量 而言，明 显地比</p><p>其他4个 版本运行得慢 ， 其他 4 个版本有较少的不命中 次数或者较少的 访问次数， 或者兼而有之。</p></li><li><p>, • 在这个情况中 、， 与 内 存访问总数相比， 不命中率是一个更好的性能预测指标。例</p></li></ul><p>如，即 使 类 BC 例 程( 2 个 加 载和 1 个存储）在内循环中比类 AB 例程( 2 个加载）执行更多的内存引用，类 BC 例程（每次迭代有 0. 5 个不命中）比类AB 例程（每次迭代有</p><p>1. 25 个不命中）性能还是要好很多。</p><ul><li><p>对于大的 n 值，最 快 的 一对版本( ki j 和心 ）的性能保持不变。虽然这个数组远大于任何 SR A M 高速缓存存储器， 但 预 取 硬件足够聪明，能 够 认 出 步 长为 1 的访问模式 ，而 且速度足够快能够跟上内循环中的内存访问。这是设计这个内存系统的 Intel 的 工 程师所做的一项极好成就，向 程 序 员 提 供了甚至更多的鼓励，鼓 励 他们开发出具有良好空间局部性的程序。</p><p>Li 使用分块来提高时间局部性</p><p>有一项很有趣的技术， 称为 分 块( blocking ) , 它可以提高内循环的时间局部性。分块的大致思想是将一 个程 序 中的数 据结构组织 成的 大的 片 ( ch unk ) , 称 为 块 C blo ck) 。</p><p>（在这个上下文中，“块” 指的是一个应 用级 的数据组块， 而 不是 高速 缓 存块。）这样构造程序，使 得 能够将一个片加 栽到 Ll 高 速 缓 存中， 并在这个片 中进行 所需的所有的读和写， 然后 丢掉这个片 ，加 栽下一 个片 ，依 此类推 。</p><p>与为提 高空 间局部性所做 的简单循环变换 不同 ， 分块使得代码更难阅读和理解。由于这个原因 ， 它最适合 于优 化编译 器或 者频繁执行的库函数。由于 Core i7 有完善 的预取硬 件， 分块不会 提高矩阵 乘在 Core i7 上的性能。不过， 学习和理解这项技 术还是很有趣的， 因为它是 一个通用的 概念， 可以在一些没有 预取的 系统 上获得极大的性能收益。</p></li></ul><ol><li><p>6. 3 在程序中利用局部性</p><p>正如我们看到的，存储系统被组织成一个存储设备的层次结构，较小、较快的设备靠近顶部，较大、较慢的设备靠近底部。由千采用了这种层次结构，程序访问存储位置的实际速率不是一个数字能描述的。相反，它是一个变化很大的程序局部性的函数（我们称之为存储器山），变化可以有几个数量级。有良好局部性的程序从快速的高速缓存存储器中访问它的大部分数据。局部性差的程序从相对慢速的 DRA M 主存中访问它的大部分数据。</p><p>理解存储器层次结构本质的程序员能够利用这些知识编写出更有效的程序，无论具体 的存储系统结构是怎样的。特别地， 我们推荐下列技术：</p><ul><li>将你的注意力集中在内循环上，大部分计算和内存访问都发生在这里。</li></ul></li></ol><ul><li><p>通过按照数据对象存储在内存中的顺序、以步长为 1 的来读数据，从 而使得你程序中的空间局部性最大。</p></li><li><p>一旦从存储器中读入了一个数据对象， 就 尽 可 能 多 地 使 用 它 ，从 而 使 得 程序中的时间局部性最大。</p><p>6. 7 小结</p><p>基本存储技术包括随机存储器 ( RAM) 、非易失性存储器( ROM) 和磁盘。 RAM 有两种基本类型。 静态 RAM(SRAM) 快一些， 但是也贵一些， 它既可以用做 CPU 芯片上的高速缓存 ， 也可以用做芯片下的高速缓存。动态 RAM( DRAM) 慢一点，也便宜一些， 用做主存和图形帧缓 冲区。即使是在关电的时候 ，</p><p>ROM 也能保持它们的信息， 可以用来存储固件 。旋转磁盘是机械的非易失性存储设备 ， 以每个位很低的成本保存大量的数据，但是其访问时间比 DRAM 长得多 。固态硬盘( SSD) 基丁非易失性的闪存 ， 对某些应用来说，越来越成为旋转磁盘的具有吸引力的替代产品。</p><p>一般而言， 较快的存储技术每个位会更贵 ， 而且容量更小。这些技术的价格和性能属性正在以显 著</p></li></ul><p>厅-</p><p>笫 6 章 存储器层次结构 451</p><p>不同的速度变化着 。特别地， DRAM 和磁盘访问时间 远远大于 CPU 周期时间。系统 通过将存储器组织成存储设备的层次结构来弥补这些差异，在这个层次结构中，较小、较快的设备在顶部，较大、较慢的设备在底部。因为编写良好的程序有好的局部性，大多数数据都可以从较高层得到服务，结果就是存储系统能以较高层的速度运行，但却有较低层的成本和容社。</p><p>程序员可以通过编写有良好空间和时间局部性的程序来显著地改进程序的运行时间。利用基于</p><p>SRAM的高速缓存 存储器特别重要 。主要从高速缓存取数据的程序能 比主要从内 存取数据的程序 运行得快得多 。</p><p>参考文献说明</p><p>内存和磁盘技术 变化得很快 。根据我们的 经验， 最好的技术信息 来源是制造商维 护的 Web 页面。像Micron、Toshiba 和 Samsung 这样的公 司， 提供了丰富的当前有关内存设备的技术信息。Seagate 和Western D屯ital 的页 面也提供了类 似的有关 磁盘的有用信息。</p><p>关于电路和逻辑设计的教科书提供了关于内存技术的详细信息[ 58 , 89] 。IEEE Spect rum 出版了 一系列有关 DRAM 的综述文章[ 55] 。计算机体系结构国际 会议( ISCA) 和高性能计算机体系结构 ( HPCA) 是关于 DRAM 存储性能特性的公 共论坛[ 28 , 29 , 18 ] 。</p><p>Wilkes 写了第一篇关千高速缓 存存储器的论文[ 117] 。Smith 写了一篇经典的综述[ 104] 。 Przyby lski 编写了一本 关于高速缓存设计的权威著作[ 86] 。 Hennessy 和 Patterson 提供了对高 速缓 存设计问题的全面讨论[ 46] 。Levinthal 写了一篇有关 Intel Core i7 的全面性能 指南[ 70] 。</p><p>Stricker 在[ 112] 中介绍了存储楛山的思想， 作为对存储 器系统的 全面描 述， 并且在后来的 工作描述中非正式 地提出了 术语“存储器山＂。编译器研究者通过 自动执行我们 在 6. 6 节中讨论过的那些手工代码转换来增加 局部性[ 22, 32, 66. 72, 79, 87 , 119] 。Carter 和他的 同事们提出了一个高速缓存 可知晓 的内存控制器 (cac he-aware memory contro ller) [ 17] 。其他的研究 者开 发出了 高速缓存不知晓的 ( cache obliv­</p><p>ious)算法，它被设 计用来在不明确知 道底层高速 缓存存储 器结构的情况下也能运行得很好[ 30, 38, 39,</p><p>9] 。</p><p>关于构造和使用磁 盘存储设备也有大最的论 著。许多存储技术研究 者找寻 方法，将 单个的磁盘集合成更大、更健壮 和更安 全的存储池[ 20 , 40 , 41, 83, 121] 。其他研究 者找寻利用高速 缓存和局部性来改进磁盘 访问性能的方法[ 12, 21] 。像 Exokernel 这样的系统提供了更多的对磁盘和存储 器资 源的 用户级控制[ 57] 。像安 德鲁文件系统[ 78] 和 Coda[94] 这样的 系统， 将存储器层 次结构扩展到了计算机网络和移动笔记本电脑。 Schindler 和 Ganger 开发了一个有趣的工具 ， 它能自动描述 SCSI 磁盘驱动器的构造和性能[ 95] 。研究者正 在研究构 造和使用基于闪存的 SSD的技术[ 8 , 81] 。</p><p>家庭作业</p><p>•• 6. 22</p><p>假设要求你设计一个每条磁道位数固定的旋转磁盘。你知道每条磁道的位数是由最里层磁道的周 长决定的，可以假设它就是中间那个圆洞的周长。因此，如果你把磁盘中间的洞做得大一点，每 条磁道的 位数就会增大 ， 但是总的 磁道数会减少 。如果用 r 来表示盘面的 半径， X • r 表示圆洞的半径， 那么 x 取什么值能使这个 磁盘的容量最大？</p><p><img src=img/e7d9233c275aa4a2a823ea2ba820ceff.jpeg alt>估计访问 下面这个 磁盘上扇区的平均时间（以ms 为单位）：</p><p>假设一个 2MB 的文件， 由 512 个字节的逻辑块组 成，存储 在具 有下述特性的磁 盘驱动器上 ：</p><p>;&rsquo;. ·:&rsquo;·, ,,)</p><p>. .</p><p>&rsquo; · &rsquo; ) .. ,</p><p>&lt; -.气&rsquo;- -&rsquo;</p><ul><li><p>6 .&lsquo;&lsquo;2 5</p><p>对于下面的 每种情况 ， 假设程序顺序 地读文件的逻辑块， 一个接一个， 并且对第一个块定位读／ 写头的时间 等于 T&mldr; ,.. k + T吓 g rotat,on o</p></li></ul><ol><li><p>最好情况： 估计在所有可能的逻辑块到磁盘扇区的映射上读该文件所需 要的 最优时间（以ms 为单位）。</p></li><li><p>随 机情况 ：．估计如果块是随机映射到磁盘扇区上时读 该文件所需要 的时间（以ins为单位）。</p><p>下 面的表给出了一些不同的高速缓存的 参数。对千每个 高速缓存，填 写出表中缺失的字段。记住</p><p>m 是物理地址的 位数，C 是高速缓存大小（数据字节数）， B 是以 字节为 单位的块大小， E 是相联</p><p>、度 ，S 是高速缓存组数， t 是标记位数，s是组索引位数，而 b 是块偏移位数。、 ; &lsquo;..•: : &lsquo;、</p></li></ol><p>::</p><p>} .., i;</p><p>•&rsquo; '</p><p>.,.,.</p><ul><li><p>6 . 26 下面的表给出了一些 不同的高速缓存的 参数。你的任务是填写 出表中缺失的字段。记住 m炟物理</p><p>地址的 位数， C 是高速缓存大小（数据字节数）， B 是以字节为单位的 块大小， E 是相联度， S是高速缓存组数， t 是标记位数， s 是组索引位数，而 b 是块偏移位数。</p></li></ul><p>,&rsquo;) -: ci ··.. ,:, , :&lsquo;c&rsquo;</p><ul><li>6 . 27 这个问题是关于练习题 6. 12 中的 高速缓存的。</li></ul><ol><li><p>列出 所有会在组 1 中命中的十六进制内 存地址。</p></li><li><p>列出所有会 在组 6 中命中的十六进制内存地址 。</p><p>•• 6.-!2 , 这 个问题是关于练习题 6. 12 中的高速缓 存的。</p><p>A. 列 出所有会在组 2 中命中的十六进制内 存地址。</p></li></ol><ul><li>. &mldr;,, . B. 列出所有会在组 4中 命中的十六进制内存地址。</li></ul><ol><li><p>列出所有会在组 5 中命中的十六进制内存地址。</p></li><li><p>列出所有会 在组 7 中命中的十六进 制内存地 址。</p><p>•• 6 29 假设我们有一个具有如下属性的系统：</p><ul><li>内存 是字节寻址的 。</li><li>内存访问是对 1字 节字的（而不是 4 字 节字）。</li><li>地址宽 12 位。</li></ul></li></ol><p>I&rsquo;</p><p>i ;- , ; :</p><p>/ ·..</p><p>、，</p><p>、 1&rsquo;. •&rsquo; .&rsquo;.: &rsquo; . . ,· ,</p><ul><li>高速缓存是两路组相联 的CE = 2) , 块大小为 4 字节 ( B = 4) , 有 4 个组CS = 4) 。高 速缓存的内 容如下，所有的地址 、标记和值都以十六进制表示 ：＇</li></ul><p>组索引 标记 有效位 字节0 字节l</p><p>字节2</p><p>字节3</p><p>00</p><p>:.83</p><p>.0. 0</p><p>83</p><p>｀</p><p>40</p><p>- FE ,</p><p>＿44</p><p>. .</p><p>41 &lsquo;. I .42</p><p>97 cc</p><p>45 46</p><p>—</p><p>·43</p><p>DO 47</p><p>&lsquo;" ,,,.</p><ol><li><p>a,</p><p>,.,,•.·. ·&rsquo;. 、，.</p><p>＇ ,1 :: ·"，＇ 坎</p></li></ol><p>; -,</p><p>； , 2</p><p>&lsquo;I ＿一</p><dl><dt>40</dt><dd><p>. .48 49</p></dd></dl><p>-;- 古 ～． ；</p><p>． ，</p><p>. 4A ., . .、.．. 4B J</p><p>;; I ; II : I</p><p>9A CO,</p><p><img src=img/95a52fc8b871f4a01127e5a34a0f092c.jpeg alt></p><p>,&rsquo;, 03 Ff</p><ol><li><p>下面的图给出了 一个地址的格式（每个小框表示一位）。指出用来确定下列信息的字段（在图中标号出来）：</p><p>co 高速缓 存块偏移＿</p></li></ol><p>CI 高速缓 存组索引～</p><p>CT 高速缓存标记</p><p>&lsquo;.; J ;_.., . &rsquo; 、 、 ；</p><p>12 11 ·_·- lO ·· 9 8 &rsquo; -&lsquo;7 . • .&lsquo;6 ·· -5· •· 4</p><h5 id=-i-i--i--i-i--i---i-i>. I I -I · I I:-· ,I&ndash;• I··-·"°I
<a class=anchor href=#-i-i--i--i-i--i---i-i>#</a></h5><ol><li>对于下面每个内存访问 ，当 它 们是按照列出来的顺 序执行时， 指出是高速缓存命中还是不命中。如果可以从高速缓存中的信息 推断出来 ，请 也给出读出的 值。</li></ol><p>. ,), · '</p><ul><li>6. 30 假设我们有一个具有如下属性的系统：<ul><li><p>内存是字节寻址的？ 飞｀ &rsquo; ;:: • 飞</p><p>.• 内存访问是对 1 字节字的（而不是4 字节字）。，..c: .· •: :</p><p>• 地址宽13 位。 ,· _; , .· ." ·:, •· ;- ·· ;</p></li><li><p>高速缓存是四路组相联 的( £ = . 4) &rsquo; 块大小为 4 字节( B = 4 ) , 有 8 个组 ( 5 = 8 ) 。</p><p>考虑下 面的高速缓存 状态。所有的地址、标记和值都以十 六进制表示。每组有 4 行 ，索引 列</p><p>包含组索引。标记列包含每 一行的标记值。V列包含每一行的有效位。字节 0 ~ 3 列包含每一行 的数据， 标号从左向右，字 节 0在 左边。</p></li></ul></li></ul><p>. . . ,i&rsquo;· 一,,;· &lsquo;&rsquo;··&rsquo;</p><p>·, . . . &rsquo; . , , . &lsquo;.&lt;· &rsquo; , · .. , . . . ., .. . ·•</p><p>4 路组相联高速缓存</p><p>., . .. ,.</p><p>; , ,; &lsquo;.·,, ;</p><ol><li>这个高速缓 存的大小 ( C ) 是多少字节？</li><li>下面的图 给出了一个地址的格式（每个小框表示一位）。指出用来确定下列信息的字段（在图中</li></ol><p>标号出来）：</p><p>co 高速缓存块偏移</p><ul><li>&lsquo;&mldr;;-</li></ul><p>!- . . - ·&rsquo; . '</p><p>安</p><p>CI 高速缓存组索引</p><p>CT 高速缓存标记</p><p>12 11 10 9 8 7 6 5 4 3 2 I 0</p><p>** 6. 31 假设程序使用作业 6. 30 中的高速缓存，引 用位于地 址 Ox071 A 处 的 1 字节字。用 十六 进制表示出它所访间的高速缓存条目，以及返回的高速缓存字节值。指明是否发生了高速缓存不命中。如果 有高速缓存不命中，对千＂返回的高速缓存字节＂输人”一＂。提示：注意那些有效位！</p><ol><li><p>地址格式（每个小框表示一位）：</p><p>12 11 10 9 8 7 6 5 4 3 2 1 0</p></li><li><p>内存引用：</p></li></ol><p>•• 6 . 32 对千内存地址 Ox1 6 E8 重复作业 6. 31。</p><ol><li><p>地址格式（每个小框表示一位）：</p><p>12 11 IO 9 8 7 6 5 4 3 2 I 0</p></li><li><p>内存引用：</p></li></ol><p>•• 6 . 33 对于作业 6. 30 中的高速 缓存 ，列 出会在组 2 中命中的 8 个内存地址（以十六进制表示）。</p><p>•• 6. 34 考虑下面的矩阵转置函数：</p><p>typedef int array[4] [4];</p><p>2</p><p>3 void transpose2(array dst, array src)</p><p>4 {</p><p>5 int i, j;</p><p>6</p><p>7 for (i = o; i &lt; 4; i ++) {</p><p>8 for (j = O; j &lt; 4; j++) {</p><p>9 dst [j] [i] z src [i] [j];</p><p>10 }</p><p>11 }</p><p>12 }</p><p>假设这段代码运行在一台具有如下属性的机器上：</p><ul><li>s i ze o f (i n t ) ==4 。</li><li>数组 sr c 从地址 0 开始 ， 而数组 d s t 从地址 64 开始（十进制）。<ul><li><p>只有一个 L1 数据高速缓存 ，它是直接映射 、直写、写分配的， 块大小为 1 6 字节。</p></li><li><p>这个高速缓 存总共有 32 个数据字节 ， 初始为空 。</p></li><li><p>对 s r c 和 d 江 数组的访问分别是读和写不命中的唯一来 源。</p><p>对于每个r ow 和 c o l , 指明对 sr c [row] [c ol ] 和 ds t [row] [col ] 的访间是命中Ch) 还是不命 中Cm) 。例如，读 sr c [0] [ 0] 会不命中， 而写 ds t [0] [0 ]也会不命中。</p><p>d s t 数组 sr c 数组</p></li></ul></li></ul><table><thead><tr><th></th><th>列0</th><th>列1</th><th>列2</th><th>列3</th><th>列0 列1 列2 列3</th></tr></thead><tbody><tr><td>行0</td><td>m</td><td></td><td></td><td></td><td>行0 m</td></tr><tr><td>行1</td><td></td><td></td><td></td><td></td><td>行1</td></tr><tr><td>行2</td><td></td><td></td><td></td><td></td><td>行2</td></tr><tr><td>行3</td><td></td><td></td><td></td><td></td><td>行3</td></tr></tbody></table><p>.. 6. 35</p><p>对于一个总大小为 128 数据字节的高 速缓存 ，重复 练习题 6. 34。</p><p>d s t 数组</p><p>s r c 数组</p><table><thead><tr><th></th><th>列0 列l 列2 列3</th><th></th><th>列0 列l 列2 列3</th></tr></thead><tbody><tr><td>行0</td><td>m</td><td>行0</td><td>m</td></tr><tr><td>行l</td><td></td><td>行1</td><td></td></tr><tr><td>行2</td><td></td><td>行2</td><td></td></tr><tr><td>行3</td><td></td><td>行3</td><td></td></tr></tbody></table><p>•• 6. 36</p><p>这道题测试你 预测 C 语言代码的高速缓存行 为的能力。对下 面这段代码 进行分析 ：</p><p>int X [2] [128] ;</p><p>int i;</p><p>int sum= O;</p><p>for (i,. O; i &lt; 128; i++) { sum +: x [O] [i] * x [1] [i] ;</p><p>｝</p><p>拿拿 6. 37</p><p>假设我们在下列条件下执行这段代码：</p><ul><li>s i ze o f (i n t ) ==4 。</li><li>数组 x 从内存地址 OxO 开始 ，按 照行优先顺序存储 。</li><li>在下面每种情 况中， 高速缓存最开始时 都是空的 。</li><li>唯一的内存访间是对数组 x 的条目进行访问。其他所有的 变量都存储 在寄存器中。给定这些假设，估计下列情况中的不命中率；</li></ul><ol><li><p>情况 1 : 假设高速缓 存是 512 字节，直 接映射， 高速缓存 块大小 为 1 6 字节。不命中率是多少？</p></li><li><p>情况 2 : 如果我们把高速 缓存的大小 翻倍到 1024 字节，不 命中率是多 少？</p></li><li><p>情况 3 : 现在假设高 速缓存是 51 2 字节， 两路组相联， 使用 LRU 替换策略 ， 高速缓存块 大小为</p><p>1 6 字节。不命中率是多 少？</p></li><li><p>对于情况 3&rsquo; 更大的高速缓存 大小会帮助降 低不命中率吗？为什么能或者为什么不能？</p></li><li><p>对于情况 3, 更大的块大小会帮 助降低不命中率吗？ 为什么能或者 为什么不能？</p><p>这道题也是测试你 分析 C 语言代码的高速缓存行 为的能力 。假设我们在下列条件下 执行图 6-47 中的 3 个求 和函数 ：</p></li></ol><ul><li><p>s i ze of (i n t ) ==4 。</p></li><li><p>机器有 4K B 直接映射的高速缓存，块 大小为 16 字节。</p></li><li><p>在两个循环中 ， 代码只对数组数据进行内存访问 。循环索引 和值 sum 都存放在寄存器中 。</p></li><li><p>数组 a 从内存地址 Ox 08000000 处开始存储。</p><p>对于 N = 64 和 N = 60 两种情况， 在表中填写它们大概的 高速缓 存不命中率 。</p></li></ul><p>,- ,.:</p><p>,i: _&rsquo;.&rsquo;;</p><p>'</p><p>, 、 ; . : . '</p><p>｀令，，·.·.</p><p>typedef int ar r&rsquo;ay_t [N] [N]; &rsquo; ·&rsquo;· ,-.·</p><p>·i ,&rsquo; .• •.·,&rsquo;</p><p>3 ， int</p><p>4 ｛</p><p>5</p><p>6</p><p>7</p><p>9</p><p>sum.A(array_t a)</p><p>int i, j;</p><p>.. int sum = O，·</p><p>for (i = O; i &lt; N; i++)</p><p>for (j = O; j _&lt; N; j++) { sum += a [i] [j] ;</p><p>10 ｝ ·一</p><p>. , &rsquo; '</p><p>．..1．. 1</p><p>12</p><p>1·3•</p><p>14</p><p>15</p><p>16</p><p>17</p><p>return sum;</p><p>} ..</p><p>•,. (&rsquo; &lsquo;•</p><p>i nt . sumB(arr.ay_t a)</p><p>{ .</p><p>int i,&lsquo;j;</p><p>ints 山 q = O;</p><p>, .._</p><p>18 for (j = 0; j &lt; N; j++)</p><ul><li><p>19</p><p>i or (-i</p><p>= -0; i : &lt; N; i ++) {\ : :•</p><p>. ·. ,·. .: ·.</p></li></ul><p>20</p><p>21 ｝</p><p>sum += a[i] [j];</p><p>-.-,-::</p><p>22 return sum;</p><p>23</p><p>24</p><p>25 int sU1DC(array_t a) 26 ｛</p><ol><li>inti, j;</li><li>intsum= O，·</li></ol><p>J&rsquo;&rsquo;;</p><p>,</p><p>, . . . ..</p><p>又． .、; ; i >&rsquo;</p><p>29 for (j = O; j &lt; N; j&rsquo;+=2)&rsquo;</p><p>30 for (i = O; i &lt; N; i+=2) {</p><p>31 sum:, +,;, fa [i l[ j l t,</p><p>a[i+1] [jl . . 迁</p><p>32</p><p>33</p><p>3斗．，，．</p><p>35</p><p>,,,·,r.</p><p>｝</p><p>｝</p><p>e t ur n ·s 11m; 1 '</p><p>+ a,[i] [j+1] + a[i+1] [j+1]) ; ,</p><p>，人 &lt;,· &rsquo; .</p><p>气， ＇＇， ＇</p><p>&rsquo; ,,，</p><p>．，＇｀｀，</p><p>; 、 ; ; 、 . '</p><p>,.,, 心</p><p>, 、 &lsquo;::-</p><p>｀ ＇</p><p>\•. ,• 图，64- 7 · 作业5 :·37 中引 用 的函数 ;·. &mldr; • &mldr; 、· I ,</p><ul><li><p>6. 3.8 , ;iM决定在白纸上印黄方格 ， 做成 Pos t l t 小贴纸。在打印过程中，他们需要设置方格中每个点的</p><p>CMYK( 蓝色， 红色， 黄色， 黑色）值。3M 雇佣你判定下面算法在一个 具有2 048 字节、直接映射、</p><p>块大小为 32 字节的数据高速缓存上的效率。，有 如下定义：</p></li></ul><p>1 struct point_colo;r:.: { .": · . ·</p><p>2 int c;</p><p>;.</p><p>&rsquo; : &ldquo;i ,·</p><p>&rsquo; &rsquo; &lsquo;;&rsquo; ; . '</p><p>．． ． ．</p><p>_、&rsquo;;I . .</p><p>7</p><ol><li>-j &rsquo; St 如 ct point_color _s quar e (16) (16);</li></ol><p>t ; 、<em>-.: .: :·: i &lsquo;- .嘈; 1 ;;</em>-f· ·&rsquo;. , ,: &lsquo;&lsquo;j 心</p><p>心·:; :.::, :•i .·:&rsquo;:·: . !&rsquo; : i-; ·:\,: : ;•&rsquo;: ,-. g.</p><ol start=2><li>inti, j;</li></ol><p>有 如下 假设</p><p>、： ，</p><p>:-, &mldr;I-; ·&rsquo;</p><p>! 、:&rsquo;, ·.&rsquo;, •.&rsquo;, 心 俨</p><p>,.., .</p><ul><li>s i zeof (i n t ) ==4。</li><li>s qu ar e 起始千内存 地址 0。</li><li><dl><dt>高速缓存初始为空。</dt><dd><p>-· :,;-•·.·</p></dd></dl></li></ul><p>..</p><ul><li>唯一的内存访问是对于 s q ua r e 数组中的元 素。变量 i 和］存放在寄存器中。.</li></ul><p>. .&rdquo; , ·&rsquo;· 『</p><p>确定下列代码的高速缓存性能：</p><p>&lt;&lsquo;T > . &lsquo;,.</p><p>,: •</p><p>for (i = O; i &lt; 16; i++){</p><p>for ( j = O; j &lt; 16; j++) { square[i] [j] .c = O;</p><p>s quar e [ i ] [ j ] . m = O;</p><p>square[i] [j] .y = 1;</p><p>square[i] [j] .k = O;</p><p>., ·• : : : • .i:&rsquo;. •.</p><ul><li>&rsquo; &lsquo;,&rsquo;, .</li></ul><p>&lsquo;&rsquo;?,&rsquo;</p><p>｝</p><p>* .&rsquo;、</p><p>, . 矗 · 、</p><p>.,;· C, \ I&rsquo;</p><p>,,.&lsquo;&lsquo;良</p><p>： ．＇；＇ ．，</p><ol><li>写总数是多少？</li><li>在高速缓存中不命中的写总数是多少？</li><li>不命中率是多少？</li></ol><p>·.:</p><ul><li><p>. ,.., . ．</p><p>．：，&mldr;• ;! . (</p><p>： 一 ，, ．： , ,..、</p></li></ul><p>．人、飞</p><ul><li>6. 39</li></ul><p>给定作业 6. 38 中的假设，确定 下列代码的 高速缓存性 能：寸</p><p>&rsquo; . ．.,.,.，&mldr;.. ., &mldr;</p><p>,. .&rsquo; ,_; ,-;&rsquo;, t·.&rsquo;</p><p>for (i = O; i &lt; 16; i++){</p><p>for (j = O; j &lt; 16; j++) { square [j] [i] . c = 0;</p><p>square[j] [i] .m = O;</p><p>．％ , . 、; , ..</p><p>square CiJ [iJ _.y= 1寸</p><p>square [j] [i] . k = 0;</p><ul><li><p>&rsquo; .:,</p><p>＼， • . \ I</p><p>" - : ,,&rsquo;,. . '</p><p>.，.，</p><p>:, ,， ,.&rsquo;．</p><p>＇，户</p></li></ul><p>:&ndash;, : ·</p><p>&rsquo; (· 中 ，l &lsquo;· &rsquo; "</p><p>，飞： ， ." .,..&rsquo;</p><ol><li>写总数是多少？<ol><li>在高速缓存中不命 中的写总数 是多少？</li></ol></li></ol><p>&lsquo;> ! '</p><p>. :, · ·: ! .&rsquo;</p><p>" ! &rsquo; &lsquo;. 、. .</p><p>,:、、</p><ol><li><p>不命中率是多少?</p><p>.. ! &rsquo; ! :·.. &mldr; 、 、勹</p><p>,,, ; • : 气· 、 , .&rsquo;</p><p>.. ., . &mldr;</p><p>一、宁 ，：</p></li></ol><ul><li>6. 40 给定作业 6. 38 中的假设，确定下列代码的 高速缓存性能 ：</li></ul><p>;,,-.,;.、: ::,</p><p>for &rsquo; O : ,..; d;</p><p>．＼＇，</p><p>i _&lt;. &rsquo; i 6 ; i +&rsquo;+-) 1&rsquo; {&rsquo; :·: ·1</p><p>- ,: : '</p><p>,,.. ·::&rsquo; ; I,</p><p>2</p><p>:i: . . .&rsquo; 3 ,: :&rsquo;::·,: ;·- &rsquo; ,:</p><p>for (j = O; j &lt; 16 ; j++) {</p><p>, ,, squ e[iJ [j] .y, = 1,;</p><p>} " .,,&rsquo;:&rsquo;&rsquo;</p><p>! ! !,•! &mldr;.</p><p>个_;、: ,,·.一•;</p><p>l:&rsquo;; .·</p><p>4·&rsquo;. . .,. ..</p><p>f :, &rsquo; &rsquo; :, ·•·:.2 , ,, ; .·,. :·:, .,-:</p><p>, , &rsquo; '</p><p>&lsquo;,,</p><p>·.,</p><p>&rsquo; , ·" , ,&rsquo;</p><p>6 ; ,. f 吐 心 : ,: =, , O/ : i , &lt;; ,16 ; i,</p><p>++) . { · ·</p><p>\, : :- :&lt;.&rsquo;·I</p><p>:·&rsquo;</p><p>，＇，: ,.</p><p>. &rsquo; `、!·&rsquo; ,;.._-,·&rsquo;</p><p>7 for (j = O; j &lt; 16; j ++) {</p><ol><li><p>square [i] [j].c = 0 ; 、·!!t</p></li><li><p>square[i] [j] .m = O ;</p></li><li><p>square [i] [j] .k = 0 ;</p><p>11</p></li></ol><p>;;、上</p><p>. ,,..</p><p>,,,</p><p>＇ 、 ,. J , , :. 心 ；，"- j •• r , ·., '</p><p>,; _ &rsquo; .</p><p>12</p><ol><li>写总数是多少？</li><li>在高速缓存中不命中的写总数是多少？</li></ol><p>(</p><p>" :· . > , &rsquo; .• 飞 ．</p><p>.-·" :夕 ， ．；</p><p>..- _-. :. : :</p><p>&rsquo; . 一 飞，. i .•. ..&rsquo;. &rsquo; 飞”</p><p>，</p><p>.·,</p><p>l-;:,</p><ol start=3><li>不命中率是多少&rsquo;!.) '</li></ol><p>•• 6. 41</p><p>！，飞</p><p>你正在编写一个新的 30 游戏 ， 希望能名利双收.,。现 在正在写 一个 函数｝ 使得在画下一帧之前先清空屏幕 缓冲区 。工 作的屏幕是 640-X 480 像 素数组 ＇。工 作的机器有一个 64K B 直接映 射高速缓 存，</p><p>1:-,</p><p>每行 4个字节； 使用下面的C语言数据结构： I · &rsquo; ; &rsquo; &rsquo; ·. . &rsquo; " .,. : . .. . l ·.. i _-&rsquo; . ; \;: ·&rsquo;·.,:, /&rsquo;.&rsquo;</p><p>&rsquo; . &rsquo; . ,:, " \ : ; &rsquo; " ; &rsquo; ·&rsquo; &rsquo; ., " &rsquo; : &rsquo; ·. . /; &lsquo;·. 、..,., • ,,_·. ·; ;</p><p>, 1 ,,sfr uc, t</p><p>P} Xe l {</p><ul><li>、: ｀仁</li><li>&rsquo; :&rsquo;,·</li></ul><p>2 . .</p><p>• 七h at:&rsquo; • r; &lsquo;&rsquo;&rsquo;、:(,&ndash;&rsquo;.;: :: : &rsquo; &rsquo; ·.&rsquo;. •.. &lsquo;.&rsquo; 户 、 ， &rsquo; : . '</p><p>I &rsquo; 、</p><p>. .. . ,</p><p>;;:; · : .··- 3 : ,:: ;;, ch 吐 g; .-:-: '</p><p>,,_,. :、i . 、,&rsquo;、:·> ·:-:: :·;,: '</p><p>．才I i；，r</p><p>char b; char a;</p><p>};</p><p>struct pixel buffer[480] [640]; int i, j;</p><p>char•cptr; int•iptr;</p><p>有如下假设：</p><ul><li><p>s i ze o f (c har ) ==l 和 s i ze c f (i n t ) ==4 。</p><ul><li>b u f f er 起 始 于内存地址 0。</li></ul></li><li><p>高速缓存初始为空 。</p></li><li><p>唯一的内存访问是对千 b u f f er 数组中元素的访问 。变昼 1 、j 、c p tr 和 i p tr 存放在寄存器中。下面代码中百分之多少的写会在高速缓存中不命中？</p><p>for (j = 0; j &lt; 640; j ++) {</p><p>for (i = O; i &lt; 480; i++){</p><p>buff er [i ] [ j] r. • O;</p><p>buffer[i] [j] .g• O;</p><p>buffer[i] [j] . b • O;</p><p>buffer[i) [j] .a = O;</p><p>｝</p><p>｝</p></li></ul><p>** 6. 42</p><p>•• 6. 43</p><p>*＊* 6. 44</p><p>:: 6 45</p><p>给定作业 6. 41 中 的 假 设 ，下 面代码中百分之多少的写会在高速缓存中不命中？</p><p>char•cptr = (char•) buffer;</p><p>for (; cptr &lt; (((char *) buff er) + 640 * 480 * 4) ; cptr++)</p><ul><li>cptr 一 O;</li></ul><p>给定作业 6. 41 中 的 假设 ，下 面代 码中百分之多少的写会在高速缓存中不命中？</p><p>int *iptr z (int•)buffer;</p><p>for(; iptr &lt; ((int•)buffer+ 640•480); iptr++)</p><p>*iptr = 0;</p><p>从 CS : A P P 的网站上下载 mo u n t a i n 程 序， 在你最喜欢的 PC/ L in u x 系统上运行它。根据结果估计你 系统上的高速缓存的大小。</p><p>在这项任务中，你 会把在第 5 章和第 6 章中学习到的概念应用到一个内存使用频繁的代码的优化 问 船 上。考虑一个复制并 转置一个类型为 i n t 的 N X N 矩阵的过程。也 就是， 对 于源矩阵 S 和目的矩阵 D , 我们要将每个元素 S; ,J 复制到 d,., 。只用一个简单的循环就能实现这段代码：</p><p>void transpose(int•dst, int•src, int dim)</p><p>｛</p><p>int i, j;</p><p>for (is O; i &lt; dim; i++)</p><p>for (j = O; j &lt; dim; j++)</p><p>dst [j•dim + i ] 一 s r c [i*dim + j];</p><p>:: 6 . 46</p><p>这里 ，过 程的参数是指向目的矩阵 ( d s t ) 和源矩阵 ( s r c ) 的指针，以 及矩阵的大小 N ( d i m) 。 你的工作是设计一个运行得尽可能快的转置函数。</p><p>这是练习题 6. 45 的一个有趣的变体。考虑将一个有向图 g 转换成它对应的无向图 g &rsquo; 。图 g &rsquo; 有一条</p><p>从 顶点 u 到顶点 v 的边，当 且仅当原图 g 中有一条 u 到 u 或者 v 到 u 的边。图 g 是由如下的它的邻接 矩阵( adjacenc y ma t rix ) G 表示的。如果 N 是 g 中顶点的数量， 那 么 G 是 一 个 N X N 的 矩阵，</p><p>它 的 元 素是全 0 或者全 1。假设 g 的顶点是这样命名的： V o , V 1 , …, “平 1 。 那 么 如 果 有一条从 v,</p><p>到 v,的 边，那 么 G [ i] [ 月 为 1, 否则为 0。注意， 邻 接矩阵对角线上的元素总是 1, 而无向图的邻</p><p>接矩阵是对称的。只用一个简单的循环就能实现这段代码：</p><p>void col_convert(int *G, int dim) { int i, j;</p><p>for (i = O; i &lt; dim; i++)</p><p>for (j = O; j &lt; dim; j++)</p><p>G [j *dim + i] = G [j *dim + i] 11 G[ 江 di m + j];</p><p>你的工作是设计一个运行得尽可能快的函数。同前面一样，要提出一个好的解答，你需要应用在第5 章和第 6 章中所学 到的概念。</p><p>练习题答案</p><p>6 1 这里的思 想是通过使 纵横比 ma x(r , c)/min(r, c)最小， 使得地址位数最小。换句话说， 数组越接近于正方形，地址位数越少。</p><table><thead><tr><th>组织</th><th>r</th><th>C</th><th>b，</th><th>be</th><th>max(b,, b)</th></tr></thead><tbody><tr><td>16X l</td><td>4</td><td>4</td><td>2</td><td>2</td><td>2</td></tr><tr><td>16X4</td><td>4</td><td>4</td><td>2</td><td>2</td><td>2</td></tr><tr><td>128X8</td><td>16</td><td>8</td><td>4</td><td>3</td><td>4</td></tr><tr><td>512X4</td><td>32</td><td>16</td><td>5</td><td>4</td><td>5</td></tr><tr><td>!024X4</td><td>32</td><td>32</td><td>5</td><td>5</td><td>5</td></tr></tbody></table><p>6 2 这个小练习的主旨是确保你理解柱面和磁道之间的关系。一旦你弄明白了这个关系，那问题就很简单了：</p><p>磁盘容量= 51 2 字节 X 400 扇 区数</p><p>X 10 000 磁道数 X 2 表面数 X 2 盘 片数</p><p>扇区 track</p><p>=8 192 000 000 字 节</p><p>=8. 192GB</p><p>表面 盘片 磁盘</p><p>6 3</p><p>6 4</p><p><img src=img/dcfd16bc6bdbfee745b9fd0103eaf9ae.jpeg alt></p><p>6. 5</p><p>对这个问题的解答是对磁盘访问 时间公式的直接应用 。平均旋转时间（以ms 为单位）为</p><p>T., g ,ot,11on = 1 / 2 X T max rntallon = 1 / 2 X (60s/15 000RPM) X lOOOms/s""" 2ms</p><p>平均传送时间为</p><p>T,vg,,,n,r«= (60s/15 000RPM) X 1 / 500 扇 区／磁 道 X l OOOms / s ,::::: 0. 008ms</p><p>总的来说，总的预计访问时间为</p><p>T,cms = T, vg seek + T,vg ,oi,11on + T, vg mnsfe, = 8ms + 2ms + 0. 008ms """ 1 Oms</p><p>这道题很好的检查了你对影响磁盘性能的因素的理解。首先我们需要确定这个文件和磁盘的一些基本属性。这个文件由 2000 个 512 字节的逻辑块组成。对于磁盘， T avg seek = 5 ms&rsquo;Tmax rnt,t1on = 6 ms&rsquo; 而 T., . &lsquo;°&rsquo; &ldquo;&rsquo; o• = 3ms 。</p><ol><li><p>最好情 况： 在好的情况中 ， 块被映射到连续的扇区， 在同一柱面上 ， 那样就可以一块接一块地</p><p>读， 不用移动读／写头。一旦读／写头定位到了第一个扇区，需 要磁盘转两整圈（每圈 1000 个扇区）来读所有 2000 个块。所 以， 读这个文件的总时间为 Ta,g seek + T.,g ,oi,1;on + 2 X T max ,om;on = 5 +</p><p>3 + 12 = 20ms 。</p></li><li><p>随机的情况： 在这种情 况中，块 被随机地映射到扇区上 ， 读 2000 块中的每一块都需 要 Tavg seek +</p></li></ol><p>T .v. , o., uon ms, 所以读这个文件的总时间为( T&mldr; mk + T .,., 0 1 a,;on) X 2000 = 16 OOOmsCl 6 秒！）。 你现在可以看到为什么清理磁盘碎片是个好主意！</p><p>这是一个简单的练习，让 你对 SSD 的可行性有一些有趣的了解。回想一下对于磁盘， l P B = 109</p><p>MB 。 那么下面对单位的直接翻译得到了下 面的每种情 况的预测时间：</p><p>A. 最糟糕悄况顺序写( 470 MB/ s ) : (1 09 X 128) X Cl / 470 ) X Cl/(86 400X 365) ) ,:::::8 年。</p><p>B. 最糟糕情况随 机写( 303 MB/ s): 0 0 X.128) X (l / 303 ) .X (111/ ( 8 6· 400 X 365 )、)</p><p>1 3年 。 心</p><p>6. 6</p><p>c. 平均情况( 20G B/ 天）： (109 X 128) X0 / 20 000) X0 / 65) :&ldquo;&ldquo;1,7- 535 年。 "&rdquo; &lsquo;.&rsquo;-&rsquo;,:. 、，、</p><p>所以即使 SSD 连续工作 ， 也能持续至少 8 年时间， 这大于大多数计算机的 预期寿命 。</p><p>在 2005 年到 2015 年的 10 年间，旋 转磁盘的单位价格下降 了大约, 16 6 倍，这 意味着价格大约每 18 个月下降 2 倍。假设这个趋势 一直持续 ， l P B 的 存储设备 ，在2 0.15 年 花费-3.0 000 美元， 在 7 次这种 2 倍的下降之后会降到 500 美元以下。因为这种下降每 i&rsquo;s 个月发生一次 ， 我们 可以 预期在大约</p><p>20 25 年， 可以用 500 美元买到 l P B 的存储设备。</p><p>6. 7 为 了创建一个步长为1 的引用模式 ，必须改变循 环的次序 ， 使得最右边的索引变化得最快 ：</p><p>int s uma 工r ay3d ( i nt a[N] [NJ [NJ)</p><p>｛</p><p>inti, j, k, sum= O;</p><p>＇&rsquo;,,．，．.,，</p><p>.&rsquo; ＇， '&rsquo;</p><p>..\ , &lsquo;.., • ,</p><p>心 for</p><p>廿(k = O;&rdquo; k &rsquo; &lt; N,：;&rsquo;&rsquo; k++) { &rsquo; '</p><p>for (i = 0; i &lt; N; i ++) {</p><p>for (j = O; j &lt; N; j++) {</p><p>&rsquo; ·,,&rsquo;</p><p>,_ · · &lsquo;· .. .:</p><ul><li>·, . 处</li></ul><p>; _: ,&rsquo; ·&rsquo; 寸i</p><p>-- . }</p><p>｝</p><p>S&rsquo;\llD += a [k] [i) [j] ;</p><p>;. .、；，一：</p><p>return sum;</p><p>这是一个很重要的思想。模式。． ．</p><p>.＇、,:、:-</p><p>要保证 你理解了 为什么这种循环次序改变就能得到一个步长为 1 的访问</p><p>fs 解 决这个问题的关键在干想象出 数组是S如何在内存中排列的，然 飞后分析引用模式。！ 函 数 l e ar l 以</p><p>步长为 1 的引用模式访问 数组， 因此明显地具有最好的空间局部性。函数 c l e a r 2 依次扫描 N 个结构中的每一个 ， 这是好的，但是在每个结构中，它以 步长不为 1 的模式跳 到下列相 对于结构起始位置的偏移处： 0 、12 、4 、16 、8、20。所以 c l e a r 2 的空间局部性比 c l .e ar l 的要差。函数 c l ea r 3 不仅在每个结 构中跳来跳去， 而且还从结构跳到结构， 所以 c,l e. r.3 的空间局部性比 c l e a r 2 和 c l e ar l 都 要差。</p><p>6. 9</p><p>; 1</p><p>，．，．</p><p>6. 10</p><p>这个解答是对图 6-26 中各种高速缓存参数定义的直接应用。不那么令人兴奋，但 是在能真正理解</p><p>高速缓存如何工作之前， 你需要理解高速缓存的结构是如何 导致这样划分地址位的 。&lsquo;r•: ·t 、</p><p>填充消除了 冲突不 命中。因此，四分之 三的引用 是命中的。</p><p>6 门 有时候，｀理 解为什 么某种思想是不好的，能够帮助你理解为什么另一种 是好的。,( 这 里 ，我 们看到</p><p>•.•＇，-&rsquo;、i</p><p>6. 12</p><p>的 坏的想 法是用高位来索引高速缓存， 而不是用 中间的位。</p><p>A 用高位做索引 ， 每个连续的 数组片( chun灼由 2&rsquo; 个块组成 ，；这 里 t 是 标记位数。因此，数组头</p><p>2&rsquo; 个连续的块都 会映射到组 o, 接下来的 2&rsquo; 个块会映 射到组 1 . 依此类推o.: :&rsquo;. 习</p><p>B, 对于直接映射高速缓存( S ,.: E ,, B, •1?1! :&rdquo;"&rsquo;:( 51 2 ,、1, 3-2, &lt;32h · 高速缓 存容量是 &lsquo;.512 个 3 2 字节的块 ，每个高速缓存行中 有 t = l 8 个标记位。因此，数组中头 沪个块会映射到组 o, 接下来沪个块会映射到组 l 。因为我们的 数组只由 ( 409 (] X 4 ) / 32 =;c51? 个块组成，所以数组中所有的块都</p><p>＼！ 被 映射到组 0。因此＇，在任 何时刻、，、高 速缓存 至多只能保存七个数组块，，&lsquo;即使 数 组足够小，能 够完全放到高速缓 存中。i 很明显，，用高位 做 索引 不能充分利用高速缓存。｀ ＇＇：， 炉</p><p>两个低位是块偏移( CO) • 然后是 3 位的组索引( CI) , 剩下的位作为标记 &lt;CT ) &lsquo;.- 厂 _;;,· &lsquo;.</p><p>～ 笫 6 章 存储器层次结构 461</p><p>, ,• • I</p><p>;&rsquo;. .·, .: &rsquo; : 1,2 · · 11; 10</p><p>9. · 8 .:,7: · · 6 .. 5 : 4 : .• 3 .•.2 : ·i l 久。</p><p>>.,., .,&rsquo;</p><p>lcTlcTlcT</p><p>CT . I CT . I CT lcr I CT I c 1 」CI ·1 .C&rsquo;</p><p>I I.co I co I</p><p>6. 13</p><p>,;,,</p><p>地址： Ox0E34 .&rsquo;、</p><ol><li><p>地址格式（每个小格子表示一个位）：</p><p>．，户，．．</p><p>．&rsquo;．,· ·&rsquo; ，</p><p>; , :;</p><p>＇．， ．．．，；． ；；｀</p></li></ol><p>, ＇ , -12 · 11. 10 9 8· :. 7 6 . 5 4 . . 3 2 I . 0</p><p>I O I 1&rsquo; I 1 I 1 I O 1· .0 I O·1 i - l · 1. I. o I 1 口</p><p>:,. . ,.,.</p><ol start=2><li><p>内存引用：</p><p>CT. · C L CT CT CT CT CT ct C.l</p><p>CI cr c o · c o· ·</p><p>, : ,, :; &rsquo; 、. . ·;· .•</p></li></ol><p>(; ··.:.·.&rsquo;::&rsquo;·;!&rsquo;:/ ·.&rsquo;; &lsquo;:: -:.,. :.: 、: ;;.-, • •</p><p>&rsquo; ,._,</p><p>6. 14</p><p>:一. .. &mldr; .-</p><p>地址： Ox0DD5 一</p><ol><li>地址格式（每个小格子表示一个位）：<ul><li><p>/ ,.</p><p>12 · , 11·. 10 ·· · 9 8 7 : 6 ·· 5</p></li></ul></li></ol><p>:、·</p><p>-4 3 2 I 0</p><p>I O I I. , I· 1 1 · I , I 1· .l r o , · 1</p><p>I I O I I I</p><p>:，,;&lt; :··: - ; / : &ldquo;,:: .-,;;: er &lt; CT :. er : CT : CJ; · CT . CT CT.•·</p><p>&mldr; . fB; 内存引用： •·.. .-..: :;-·( .&rsquo;、:.&rsquo;,1 : &lsquo;,、:：·,·&rsquo;</p><p>CI 甲</p><p>．， 俨:，,. :. ..</p><p>CI· CO , CO</p><p>&lsquo;; ; · : ,·</p><p>;, / ,:·;::,:r :i\f·</p><p>心，：，八: !,&lt; 1 ; 女, · i : &rsquo; ;,, ; ;:: ; ·\</p><p>::，:; ,&rsquo;•. ::. .;. &lsquo;, , .;; :</p><p>,;&rsquo;, ,; &lsquo;.:&rsquo;:/ ;·· , ·;</p><p>. .- &rsquo; ..&ndash; . !，&rsquo;,., ．． ． ，</p><p>· ·&rsquo;:&rsquo; : , 丿</p><p>.</p><p>, ,., ｀＇</p><p>·,, . ,·</p><p>， &rsquo; &rsquo; :&rsquo;; &rsquo; &rsquo; " . -</p><p>l ,_ _. . ，</p><p>&lt;· ·&rsquo;</p><p>-、i . _.&rsquo;,-;</p><p>;., -</p><p>6. 15 地址： OxlFF4 &rsquo; •. , · 人. &rsquo; ; &mldr;.·,,, ; ，</p><p>. •· &rsquo; ! &lsquo;:</p><ol><li>地址格式（每个小格子表示一个位）：</li></ol><p>&lsquo;•. .; . ..&rsquo;</p><p>仑 ,.-. _,.</p><p>，</p><p>12 11 10 9 8 7 •, : •.,6 . 5</p><p>3· /!· 2 · . ·r: &rsquo; d</p><p>. 令 .</p><p>、:.</p><p>I 1 I I I 1 I 1 I I I I I I I I</p><p>::: >-,: : CT>,. c t, , C T :/ :CT, CT &lt; CT ·&rsquo; . er :·CT</p><p>已</p><p>CI·</p><p>0 I I &lsquo;I 。 1。 |</p><p>Cl ·,; •Cl • CO :&rsquo;.CO ;. ;,;</p><p>．、．,.</p><p>B.</p><p>.• .</p><p>I•.,i-&rsquo;.>, ; : : : &lsquo;. : &rsquo; ·,</p><p>,- .•· >,&rsquo; ; :</p><p>\ ··•,</p><p>,&rsquo;:&rsquo;.,</p><ul><li><p>.. : ;&rsquo;</p></li><li><p>,, ,. ．</p><p>, &ldquo;,C -&rsquo;;</p></li></ul><p>: 、乒 &rsquo; .,.._..,·.&lt;.;-&rsquo;· ,··J .</p><p>一 声 ，</p><dl><dt>! .-,; •:- &lt;: 、 』;</dt><dd><p>&rsquo; •:·( ,;,</p></dd></dl><p>&lsquo;.&rsquo;.·; _; ;</p><p>; , ,! ; ( , , •:</p><p>" 勹&rsquo;.,.:. ( - ..-</p><p>-)r·</p><p>> 一 j? 气 ，&rsquo;. t ,&rsquo;</p><p>&lt; :,, ;•;&lt; &lsquo;.</p><p>I ; !,</p><p>6.16 这个问题是练习题6&rsquo;. 12-::练习题6. 15 的 一种逆 过程，要 求你反向 工作，从高速缓存 的内 容推出</p><p>觅:.,!.</p><p>.•.</p><p>会在某个组中命中的地址 。在这种情况中，组 3 包含一个有效行．，标 记为 Ox32。因 为组中只有一</p><p>个有效行， 4 个地址会命中。这些地址的二进制形式为 ·o&rsquo;on: o io611 。因此，在组 3中 命中的</p><p>4 个十六进制地址是 ： Ox06 4C、 Ox0 64D、 Ox0 64E 和 Ox0 64F。</p><p>6 17 A. 解决这个问 题的关键是想象 出图 6-48 中的图像。注意，每个高 速缓存行只包含数组的一 个行， 高速缓存正好只够保存一个数组， 而且对于所有的 i , sr c 和 ds t 的行 t 映射到同一个高速缓存行。因为高速缓存不够大，不足以</p><p>主存</p><p>容纳这两个数组，所以对一个数组的 o</p><p>引用总是驱逐出另一个数组的有用的 src { 16</p><p>行。例如， 对 ds t (OJ (O J 写会驱逐当我 dst {</p><p>们读 sr c [OJ [ O J 时 加载进 来的那一行。</p><p>高速缓存</p><p>雷</p><p>所以，当我们 接下来读 sr c [ O J ( l J 时， 会有一个不命中。</p><p>图 6&ndash;18 练 习题 6. 17 的图</p><ol start=2><li><p>当高速缓存为 32 字节时 ， 它足够大， 能容纳这两个数组。因此，所 有的不命中都是开始时的冷不命中。</p><p>ds t 数组 sr c数组</p><p>列0 列l 列0 列1</p></li></ol><p>行行0l</p><p>m m</p><p>m m I</p><p>行0 m m</p><p>行1 m h</p><p>ds t 数组 sr c 数组</p><p>列0 列l 列0 列1</p><p>行行 m h 行0 m h</p><p>m h 行1 m h</p><ol><li><p>18 每个 16 字节的高速缓存行包含着两个 连续的 a l ga e_yos i t i on 结构。每个 循环按照内存顺序访问这些结构，每次读一个整数元索。所以，每个循环的模式就是不命中、命中、不命中、命中，依此类推。注意， 对于这个问题， 我们不 必实际列举出读和不命中的 总数， 就能预测出不命中率。</p><ol><li><p>读总数是多少? 512 个读。</p></li><li><p>缓存不命中的读总数是多少? 256 个不命中。</p><p>C. 不命中率是多少? 256/ 512 = 50 %。</p><p>6 19 对这个问题的关键是注意到这个 高速缓存只能保存数组的 1 / 2。所以 ，按 照列顺序来 扫描数组的第二部分会 驱逐扫描第一部分时 加载进来的那些行。例 如， 读 gr i d [8 ) [OJ 的第一个元索会驱逐当我们读 gr i d [OJ [ OJ 的 元素时加载进来的 那一行。这一行也包含 gr i d [ OJ [1 )。所 以， 当我们开始扫描下一列时， 对 g r i d [O) [ 1 ) 第一个元素的引用会不命中 。</p></li></ol></li><li><p>读总数是多少? 512 个读。</p></li><li><p>缓存不命中的读总数是多少? 256 个不命中。</p><p>c. 不命中率是多少? 256/ 512 = 50 % 。</p><p>D. 如果高速缓存有两倍大，那么不命中率会是多少呢？如果高速缓存有现在的两倍大，那么它能够保存整个 g r 沁 数组。所有的不命中都 会是开始时的 冷不命中 ， 而不命中率会是 1/ 4 = 25% 。</p></li><li><p>20 这个循环有很好的步长 为 1 的引用模式 ， 因此所有的不命中都是最开始时的 冷不命中。</p><ol><li><p>读总数是多少? 512 个读。</p></li><li><p>缓存不命中的读总数是多少? 128 个不命中。</p><p>c. 不命中率是多少? 128 / 512 = 25 % 。</p><p>D. 如果高速缓存 有两倍大， 那么不命中率会是多少呢？无论高速缓 存的大小 增加多少， 都不会改变不命中率，因为冷不命中是不可避免的。</p><p>6 21 从 Ll 的吞吐晕峰值是大约 12 OOOMB/ s , 时钟频率是 2100 MH z, 而每次读访问都是以 8 字节 l ong 类型为单位的 。所以，从 这张图中我们 可以估计出在这台机器 上从 Ll 访间一个字需要大约 2100/ 12 OOOX8=1. 4::::::1. 5 周期＇ 比正常访问 口 的延迟 4 周期快大约 2. 5 倍o 这是由于 4 X 4 的循环展开得到的并行允 许同时进行多个加载操作 。</p></li></ol></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><ul><li></li></ul></li><li><a href=#img1129d8f07f3deaf9439a791f1cce81d1jpeg之-imgbae90b00348e3e736832474da360f580jpeg><img src=img/1129d8f07f3deaf9439a791f1cce81d1.jpeg alt>之 <img src=img/bae90b00348e3e736832474da360f580.jpeg alt></a><ul><li></li><li><a href=#->。 。</a></li></ul></li></ul></li><li><a href=#heading>=</a><ul><li><ul><li></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>