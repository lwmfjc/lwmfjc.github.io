<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="第 12 章
C H A P T E R 12 . . . _
并发编程
正如我们在第 8 章学到的 ， 如果逻辑控制流在时间上重叠， 那么它们就是并发的 ( concu rr e nt ) 。这种常见的现象称为并发 ( co nc urr e ncy ) , 出现在计算机系统的许多不同层面上。硬件 异常处理程序、进程和 L in ux 信号处理程序都是 大家很熟悉的例子。
到目前为止，我们主要将并发看做是一种操作系统内核用来运行多个应用程序的机 制。但是， 并发不仅仅局限 于内核。它也可以在应用程序中 扮演重要角色。例如，我 们已经看到 Linux 信号处理程序如何允许应用响应异步事件， 例如用户键入 C t rl + C , 或者程序访问虚拟内存的 一个未定义的区域。应用级并发在其他情况下 也是很有用的：


访问慢速 1/0 设备。当一个应用正在等待来自慢速 1/ 0 设备（例如磁盘）的数据到达时，内 核会运行其他进程，使 CP U 保持繁忙。每个应用都可以按照类似的方式， 通过交替 执行 I/ 0 请求和其他有用的工作来利用并发。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC12%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="随记"><meta property="og:title" content="随记"><meta property="og:description" content="第 12 章
C H A P T E R 12 . . . _
并发编程
正如我们在第 8 章学到的 ， 如果逻辑控制流在时间上重叠， 那么它们就是并发的 ( concu rr e nt ) 。这种常见的现象称为并发 ( co nc urr e ncy ) , 出现在计算机系统的许多不同层面上。硬件 异常处理程序、进程和 L in ux 信号处理程序都是 大家很熟悉的例子。
到目前为止，我们主要将并发看做是一种操作系统内核用来运行多个应用程序的机 制。但是， 并发不仅仅局限 于内核。它也可以在应用程序中 扮演重要角色。例如，我 们已经看到 Linux 信号处理程序如何允许应用响应异步事件， 例如用户键入 C t rl + C , 或者程序访问虚拟内存的 一个未定义的区域。应用级并发在其他情况下 也是很有用的：
访问慢速 1/0 设备。当一个应用正在等待来自慢速 1/ 0 设备（例如磁盘）的数据到达时，内 核会运行其他进程，使 CP U 保持繁忙。每个应用都可以按照类似的方式， 通过交替 执行 I/ 0 请求和其他有用的工作来利用并发。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Index | 随记</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC12%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/><link rel=stylesheet href=/book.min.61c2259501b059453d6e3b0551df29ef9de07bb5236b73baae9ac80bb6f5e94c.css integrity="sha256-YcIllQGwWUU9bjsFUd8p753ge7Uja3O6rprIC7b16Uw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.88a9c3f176e54f4c3ffea2412170e98449f2385ea3509e1104716949edcb89e9.js integrity="sha256-iKnD8XblT0w//qJBIXDphEnyOF6jUJ4RBHFpSe3Liek=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>随记</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><a href=/zh/docs/technology/>技术</a><ul><li><input type=checkbox id=section-d2e5dc71fe2274ddaa089e125f33ae58 class=toggle>
<label for=section-d2e5dc71fe2274ddaa089e125f33ae58 class="flex justify-between"><a role=button>My SQL</a></label><ul><li><input type=checkbox id=section-385256c91dd6127cb06668afb2ab262b class=toggle>
<label for=section-385256c91dd6127cb06668afb2ab262b class="flex justify-between"><a role=button>mysql_进阶_施磊</a></label><ul><li><a href=/zh/docs/technology/MySQL/advanced_shilei/05/>05日志</a></li><li><a href=/zh/docs/technology/MySQL/advanced_shilei/04/>04事务</a></li><li><a href=/zh/docs/technology/MySQL/advanced_shilei/03/>03存储引擎</a></li><li><a href=/zh/docs/technology/MySQL/advanced_shilei/02/>02增删改查</a></li><li><a href=/zh/docs/technology/MySQL/advanced_shilei/01/>01基础知识</a></li></ul></li><li><input type=checkbox id=section-b36f39b28986b079f4216fd3e38bfa3e class=toggle>
<label for=section-b36f39b28986b079f4216fd3e38bfa3e class="flex justify-between"><a role=button>My Sql是怎样运行的</a></label><ul><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC26%E7%AB%A0_%E5%86%99%E4%BD%9C%E6%9C%AC%E4%B9%A6%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>第26章_写作本书时用到的一些重要的参考资料</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC25%E7%AB%A0_%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E8%80%81%E5%A4%A7%E9%9A%BE-%E9%94%81/>第25章_工作面试老大难-锁</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC24%E7%AB%A0_%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%9A%E5%B9%85%E9%9D%A2%E5%AD%94-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC/>第24章_一条记录的多幅面孔-事务的隔离级别与MVCC</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC23%E7%AB%A0_%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%E4%B8%8B/>第23章_后悔了怎么办-undo日志(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC22%E7%AB%A0_%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%E4%B8%8A/>第22章_后悔了怎么办-undo日志(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC21%E7%AB%A0_%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%E4%B8%8B/>第21章_说过的话就一定要办到-redo日志(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC20%E7%AB%A0_%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%E4%B8%8A/>第20章_说过的话就一定要办到-redo日志(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC19%E7%AB%A0_%E4%BB%8E%E7%8C%AB%E7%88%B7%E8%A2%AB%E6%9D%80%E8%AF%B4%E8%B5%B7-%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/>第19章_从猫爷被杀说起-事务简介</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC18%E7%AB%A0_%E8%B0%83%E8%8A%82%E7%A3%81%E7%9B%98%E5%92%8CCPU%E7%9A%84%E7%9F%9B%E7%9B%BE-InnoDB%E7%9A%84BufferPool/>第18章_调节磁盘和CPU的矛盾-InnoDB的BufferPool</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC17%E7%AB%A0_%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-optimizer_trace%E8%A1%A8%E7%9A%84%E7%A5%9E%E5%99%A8%E5%8A%9F%E6%95%88/>第17章_神兵利器-optimizer_trace表的神器功效</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC16%E7%AB%A0_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8B/>第16章_查询优化的百科全书-Explain详解(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC15%E7%AB%A0_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8A/>第15章_查询优化的百科全书-Explain详解(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC14%E7%AB%A0_%E4%B8%8D%E5%A5%BD%E7%9C%8B%E5%B0%B1%E8%A6%81%E5%A4%9A%E6%95%B4%E5%AE%B9-MySQL%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96%E5%86%85%E5%90%AB%E5%85%B3%E4%BA%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%BA%8C%E4%B8%89%E4%BA%8B%E5%84%BF/>第14章_不好看就要多整容-MySQL基于规则的优化(内含关于子查询优化二三事儿)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC13%E7%AB%A0_%E5%85%B5%E9%A9%AC%E6%9C%AA%E5%8A%A8%E7%B2%AE%E8%8D%89%E5%85%88%E8%A1%8C-InnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E7%9A%84/>第13章_兵马未动粮草先行-InnoDB统计数据是如何收集的</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC12%E7%AB%A0_%E8%B0%81%E6%9C%80%E4%BE%BF%E5%AE%9C%E5%B0%B1%E9%80%89%E8%B0%81-MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/>第12章_谁最便宜就选谁-MySQL基于成本的优化</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC10%E7%AB%A0_%E6%9D%A1%E6%9D%A1%E5%A4%A7%E8%B7%AF%E9%80%9A%E7%BD%97%E9%A9%AC-%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/>第10章_条条大路通罗马-单表访问方法</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC9%E7%AB%A0_%E5%AD%98%E6%94%BE%E9%A1%B5%E7%9A%84%E5%A4%A7%E6%B1%A0%E5%AD%90-InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/>第9章_存放页的大池子-InnoDB的表空间</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC8%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%B6-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/>第8章_数据的家-MySQL的数据目录</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC7%E7%AB%A0_%E5%A5%BD%E4%B8%9C%E8%A5%BF%E4%B9%9F%E5%BE%97%E5%85%88%E5%AD%A6%E4%BC%9A%E6%80%8E%E4%B9%88%E7%94%A8-B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/>第7章_好东西也得先学会怎么用-B+树索引的使用</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC6%E7%AB%A0_%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A7%98%E7%B1%8D-B+%E6%A0%91%E7%B4%A2%E5%BC%95/>第6章_快速查询的秘籍-B+树索引</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC5%E7%AB%A0-%E7%9B%9B%E6%94%BE%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%A7%E7%9B%92%E5%AD%90-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/>第5章 盛放记录的大盒子-InnoDB数据页结构</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC4%E7%AB%A0_%E4%BB%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E8%AF%B4%E8%B5%B7-InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/>第4章_从一条记录说起-InnoDB记录结构</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC3%E7%AB%A0_%E4%B9%B1%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/>第3章_乱码的前世今生-字符集和比较规则</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC2%E7%AB%A0_MySQL%E7%9A%84%E8%B0%83%E6%8E%A7%E6%8C%89%E9%92%AE-%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/>第2章_MySQL的调控按钮-启动选项和系统变量</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC1%E7%AB%A0_%E8%A3%85%E4%BD%9C%E8%87%AA%E5%B7%B1%E6%98%AF%E4%B8%AA%E5%B0%8F%E7%99%BD-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86MySQL/>第1章_装作自己是个小白-重新认识MySQL</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC0%E7%AB%A0_%E4%B8%87%E9%87%8C%E9%95%BF%E5%BE%81%E7%AC%AC%E4%B8%80%E6%AD%A5%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81-%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E7%9A%84%E9%98%85%E8%AF%BB%E6%9C%AC%E5%B0%8F%E5%86%8C/>第0章_万里长征第一步(非常重要)-如何愉快的阅读本小册</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC11%E7%AB%A0_%E4%B8%A4%E4%B8%AA%E8%A1%A8%E7%9A%84%E4%BA%B2%E5%AF%86%E6%8E%A5%E8%A7%A6-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/>第11章_两个表的亲密接触-连接的原理</a></li></ul></li><li><input type=checkbox id=section-14acbe73a39f7c2e8d055bbdbab560d6 class=toggle>
<label for=section-14acbe73a39f7c2e8d055bbdbab560d6 class="flex justify-between"><a role=button>_MySQL是怎样运行的_</a></label><ul><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/08/>08数据的家--MySQL的数据目录</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/07/>07B+数索引的使用</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/06/>06B+树索引</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/05/>05InnoDB数据页结构</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/04/>04InnoDB记录存储结构</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/03/>03字符集和比较规则</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/02/>02启动选项和系统变量</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/01/>01初识MySQL</a></li></ul></li><li><input type=checkbox id=section-522269efe4a436e18b16a29ff12d542d class=toggle>
<label for=section-522269efe4a436e18b16a29ff12d542d class="flex justify-between"><a role=button>高性能 My SQL</a></label><ul><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83/>封面-版权</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC9%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96/>第9章操作系统和硬件优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC8%E7%AB%A0%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/>第8章优化服务器设置</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC7%E7%AB%A0MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/>第7章MySQL高级特性</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC6%E7%AB%A0%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>第6章查询性能优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC5%E7%AB%A0%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/>第5章创建高性能的索引</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC4%E7%AB%A0Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/>第4章Schema与数据类型优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC3%E7%AB%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/>第3章服务器性能剖析</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC2%E7%AB%A0MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/>第2章MySQL基准测试</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC1%E7%AB%A0MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2/>第1章MySQL架构与历史</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC16%E7%AB%A0MySQL%E7%94%A8%E6%88%B7%E5%B7%A5%E5%85%B7/>第16章MySQL用户工具</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC15%E7%AB%A0%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/>第15章备份与恢复</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC14%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82%E4%BC%98%E5%8C%96/>第14章应用层优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC13%E7%AB%A0%E4%BA%91%E7%AB%AF%E7%9A%84MySQL/>第13章云端的MySQL</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC12%E7%AB%A0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/>第12章高可用性</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC11%E7%AB%A0%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84MySQL/>第11章可扩展的MySQL</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC10%E7%AB%A0%E5%A4%8D%E5%88%B6/>第10章复制</a></li></ul></li><li><input type=checkbox id=section-33ad04dc8d65b11ab6b2d2e0964c3c89 class=toggle>
<label for=section-33ad04dc8d65b11ab6b2d2e0964c3c89 class="flex justify-between"><a role=button>进阶(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MySQL/bl_sgg_/96-00/>mysql高阶_sgg 96-00</a></li></ul></li></ul></li><li><input type=checkbox id=section-d9652e1d39ed08192f3dd99c4361d9ad class=toggle checked>
<label for=section-d9652e1d39ed08192f3dd99c4361d9ad class="flex justify-between"><a role=button>SpringCloud</a></label><ul><li><span>SpringCloud</span><ul><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E5%B0%81%E9%9D%A2-%E7%9B%AE%E5%BD%95/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC10%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7I_O/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC11%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC12%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ class=active>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC2%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC4%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC5%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC6%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC7%E7%AB%A0-%E9%93%BE%E6%8E%A5/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC9%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C-2-6/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%92%8C%E9%80%9A%E4%BF%A1-10-12/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-7-9/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E9%99%84%E5%BD%95A-%E5%B0%81%E5%BA%95/>Index</a></li></ul></li></ul></li><li><input type=checkbox id=section-1dd4601389ea65ef400f95373226aee0 class=toggle>
<label for=section-1dd4601389ea65ef400f95373226aee0 class="flex justify-between"><a role=button>Linux</a></label><ul><li><input type=checkbox id=section-eb3a110e9a221e46d625b63087e91152 class=toggle>
<label for=section-eb3a110e9a221e46d625b63087e91152 class="flex justify-between"><a role=button>SHELL编程(learnLinuxTV)_</a></label><ul><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/16-18/>16-18</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/12-15/>12-15</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/11DataStreams/>11DataStreams</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/07-10/>07-10</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/06ExitCode/>06ExitCode</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/05If/>05If</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/01-04/>01-04</a></li></ul></li><li><input type=checkbox id=section-cd7838d42e3d9f745d945ce90940f02e class=toggle>
<label for=section-cd7838d42e3d9f745d945ce90940f02e class="flex justify-between"><a role=button>韩顺平老师_</a></label><ul><li><a href=/zh/docs/technology/Linux/hanshunping_/52-x/>52-X</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/40-51/>linux_韩老师_40-51</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/28-39/>linux_韩老师_28-39</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/21-27/>linux_韩老师_21-33</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/12-20/>linux_韩老师_12-20</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/07-11/>linux_韩老师_07-11</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/01-06/>linux_韩老师_01-06</a></li></ul></li><li><a href=/zh/docs/technology/Linux/_TheLinuxCommandsHandbook_/>_TheLinuxCommandsHandbook_</a></li><li><a href=/zh/docs/technology/Linux/basic/>基本操作</a></li><li><a href=/zh/docs/technology/Linux/create_clone/>vmware上linux主机的安装和克隆</a></li></ul></li><li><input type=checkbox id=section-9f56b27db6873dfaab68a13a9088b050 class=toggle>
<label for=section-9f56b27db6873dfaab68a13a9088b050 class="flex justify-between"><a role=button>Reg Exp</a></label><ul><li><input type=checkbox id=section-e7092def48f35456be32e3b6257559e4 class=toggle>
<label for=section-e7092def48f35456be32e3b6257559e4 class="flex justify-between"><a role=button>基础(CoreySchafer)_</a></label><ul><li><a href=/zh/docs/technology/RegExp/baseCoreySchafer_/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class=toggle>
<label for=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class="flex justify-between"><a role=button>Hugo</a></label><ul><li><input type=checkbox id=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class=toggle>
<label for=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class="flex justify-between"><a role=button>主题</a></label><ul><li><a href=/zh/docs/technology/Hugo/themes/PaperMod/01/>使用PaperMode</a></li></ul></li><li><input type=checkbox id=section-d72f299b202b2766d1efe5fb807ed184 class=toggle>
<label for=section-d72f299b202b2766d1efe5fb807ed184 class="flex justify-between"><a role=button>基础(Giraffe学院)_</a></label><ul><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced20-23/>hugo进阶学习20-23</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced17-19/>hugo进阶学习17-19</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced11-16/>hugo进阶学习11-15</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced01-10/>hugo进阶学习01-10</a></li></ul></li></ul></li><li><input type=checkbox id=section-43be5f3c9fb2465efc746ae00240e4b3 class=toggle>
<label for=section-43be5f3c9fb2465efc746ae00240e4b3 class="flex justify-between"><a role=button>Obsidian</a></label><ul><li><a href=/zh/docs/technology/Obsidian/border-theme/>border-theme背景图片问题</a></li><li><a href=/zh/docs/technology/Obsidian/obsidian-theme/>obsidian-theme</a></li><li><a href=/zh/docs/technology/Obsidian/plugin/>plugin</a></li></ul></li><li><input type=checkbox id=section-7123c56777444b2f7157631dd88ad8f6 class=toggle>
<label for=section-7123c56777444b2f7157631dd88ad8f6 class="flex justify-between"><a role=button>Redis</a></label><ul><li><input type=checkbox id=section-e6cea4f92582460cfa10699a07a10e32 class=toggle>
<label for=section-e6cea4f92582460cfa10699a07a10e32 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/19-A/>redis_尚硅谷_19-A</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/18/>redis_尚硅谷_18</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/12-17/>redis_尚硅谷_12-17</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/06-11/>redis_尚硅谷_06-11</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/01-05/>redis_尚硅谷_01-05</a></li></ul></li><li><a href=/zh/docs/technology/Redis/rsync-use/>rsync使用</a></li><li><a href=/zh/docs/technology/Redis/redis-cluster/>redis集群搭建</a></li></ul></li><li><input type=checkbox id=section-a94b8d7740a71c28fc6e0f89885b2468 class=toggle>
<label for=section-a94b8d7740a71c28fc6e0f89885b2468 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><input type=checkbox id=section-64c6733376d70496ded44b4ef3db6718 class=toggle>
<label for=section-64c6733376d70496ded44b4ef3db6718 class="flex justify-between"><a role=button>_深入理解Java虚拟机_</a></label><ul><li><a href=/zh/docs/technology/JVM/_understanding_the_jvm_/03/>03垃圾收集器与内存分配策略</a></li></ul></li></ul></li><li><input type=checkbox id=section-e8f515fe7fc71d283363385aa363c2dd class=toggle>
<label for=section-e8f515fe7fc71d283363385aa363c2dd class="flex justify-between"><a role=button>其他</a></label><ul><li><a href=/zh/docs/technology/Other/kaoshi/>科目</a></li><li><a href=/zh/docs/technology/Other/pc_base/>电脑基础操作</a></li></ul></li><li><input type=checkbox id=section-f54112ca99b135fbc484938888b1f1a2 class=toggle>
<label for=section-f54112ca99b135fbc484938888b1f1a2 class="flex justify-between"><a href=/zh/docs/technology/Review/>面试</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/>JavaGuide</a><ul><li><input type=checkbox id=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class=toggle>
<label for=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class="flex justify-between"><a role=button>数据库</a></label><ul><li><input type=checkbox id=section-e7660273cef85dff1f39af04a42bd062 class=toggle>
<label for=section-e7660273cef85dff1f39af04a42bd062 class="flex justify-between"><a role=button>MySQL</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0606lymysql-query-execution-plan/>mysql执行计划</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0611lymysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0610lymysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0609lyindex-invalidation-caused-by-implicit-conversion/>MySQL中的隐式转换造成的索引失效</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0608lysome-thoughts-on-database-storage-time/>MySQL数据库时间类型数据存储建议</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0605lyhow-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0604lyinnodb-implementation-of-mvcc/>innodb引擎对MVCC的实现</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0603lytransaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0602lymysql-logs/>日志</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0601lymysql-index/>索引</a></li></ul></li><li><input type=checkbox id=section-680d077436e58b0cad0a63ed8edb5f53 class=toggle>
<label for=section-680d077436e58b0cad0a63ed8edb5f53 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/diagram/>redis问题图解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0703ly3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0704lyredis-memory-fragmentation/>redis内存碎片</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0702lyredis-spec-data-structure/>redis特殊数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0701lyredis-base-data-structures/>redis基本数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0706lyredis-questions-02/>redis面试题02</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0705lyredis-questions-01/>redis面试题01</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0503lysql-question-01/>sql常见面试题总结01</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0504lysql-syntax-summary/>sql语法基础知识总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0502lycharactor-set/>字符集详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0501lybasis/>数据库基础</a></li></ul></li><li><input type=checkbox id=section-a1b717b4079938cc0efe574541b240b8 class=toggle>
<label for=section-a1b717b4079938cc0efe574541b240b8 class="flex justify-between"><a role=button>系统设计</a></label><ul><li><input type=checkbox id=section-9eaf95f03abf595bfdf838c4b4cdb2ef class=toggle>
<label for=section-9eaf95f03abf595bfdf838c4b4cdb2ef class="flex justify-between"><a role=button>安全</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly06ly_sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly05ly_design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly04ly_sso-intro/>sso单点登录</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly03ly_jwt-advantages-disadvantages/>jwt身份认证优缺点</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly02ly_jwt-intro/>jwt-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly01ly_basis-of-authority-certification/>认证授权基础概念详解</a></li></ul></li><li><input type=checkbox id=section-79417049c90714c6ddbf18a3c3958148 class=toggle>
<label for=section-79417049c90714c6ddbf18a3c3958148 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/unit-test/>单元测试</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/software-engineering/>软件工程简明教程</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/restful/>restFul</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/web-real-time-message-push/>web-real-time-message-push</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/schedule-task/>Java定时任务详解</a></li></ul></li><li><input type=checkbox id=section-0a9533f3005d615c696f74456e46d269 class=toggle>
<label for=section-0a9533f3005d615c696f74456e46d269 class="flex justify-between"><a role=button>高可用</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly05ly_performance-test/>性能测试入门</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly04ly_timout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly03ly_limit-request/>服务限流详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly02ly_redundancy/>冗余设计</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly01ly_high-availability-system-design/>高可用系统设计指南</a></li></ul></li><li><input type=checkbox id=section-e36f94f48e5027e7cbd39b7f7bbc249c class=toggle>
<label for=section-e36f94f48e5027e7cbd39b7f7bbc249c class="flex justify-between"><a role=button>高性能</a></label><ul><li><input type=checkbox id=section-581624dd7aa25a150f706312689ba446 class=toggle>
<label for=section-581624dd7aa25a150f706312689ba446 class="flex justify-between"><a role=button>RocketMQ</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-questions/>rocketmq常见面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-intro/>rocketmq介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/base/>message-queue</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly02ly_cdn/>cdn</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly01ly_read-and-write-separation-and-library-subtable/>数据库读写分离&分库分表详解</a></li></ul></li><li><input type=checkbox id=section-a6916634f1b5324076467df4cc9ac3b5 class=toggle>
<label for=section-a6916634f1b5324076467df4cc9ac3b5 class="flex justify-between"><a role=button>分布式系统</a></label><ul><li><input type=checkbox id=section-0c8e62b6137b614e01882e2a88ea5daf class=toggle>
<label for=section-0c8e62b6137b614e01882e2a88ea5daf class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/raft-algorithm/>raft算法</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/paxos-algorithm/>paxos算法</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/cap_base-theorem/>CAP&amp;BASE 理论</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly08ly_zookeeper-in-action/>zookeeper实战</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly07ly_zookeeper-plus/>zookeeper进阶</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly06ly_zookeeper-intro/>zookeeper介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly04ly_rpc-http/>rpc_http</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly05ly_rpc-intro/>rpc基础及面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly03ly_distributed-lock/>分布式锁</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly02ly_distributed-id/>分布式id</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly01ly_api-gateway/>api网关</a></li></ul></li><li><input type=checkbox id=section-ce3cbb53c62f67624e4ab24a5a14298a class=toggle>
<label for=section-ce3cbb53c62f67624e4ab24a5a14298a class="flex justify-between"><a role=button>框架</a></label><ul><li><input type=checkbox id=section-dbe480810d1877286936b38cdb5e9229 class=toggle>
<label for=section-dbe480810d1877286936b38cdb5e9229 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><input type=checkbox id=section-30b916f2071579e2468767a2562433d9 class=toggle>
<label for=section-30b916f2071579e2468767a2562433d9 class="flex justify-between"><a role=button>原理</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle3/>Mybatis原理系列(3)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle2/>Mybatis原理系列(2)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle1/>Mybatis原理系列(1)</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/MyBatis-interview/>Mybatis面试</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/conditional_on_class/>ConditionalOnClass实践</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly05ly_springboot-auto-assembly/>SpringBoot自动装配原理</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly04ly_spring-design-patterns/>spring 设计模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly03ly_spring-transaction/>Spring事务详情</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly02ly_spring-annotations/>Spring/SpringBoot常用注解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/>spring 常见面试题总结</a></li></ul></li><li><input type=checkbox id=section-1f6733a85e33dcc22aabbf820e3ef963 class=toggle>
<label for=section-1f6733a85e33dcc22aabbf820e3ef963 class="flex justify-between"><a role=button>开发工具</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/git/>git</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/maven/>maven</a></li></ul></li><li><input type=checkbox id=section-c01151f806b917cd0ecc4cffa72c3402 class=toggle>
<label for=section-c01151f806b917cd0ecc4cffa72c3402 class="flex justify-between"><a role=button>Java基础</a></label><ul><li><input type=checkbox id=section-26625a0c4c0bffef02640966ca545537 class=toggle>
<label for=section-26625a0c4c0bffef02640966ca545537 class="flex justify-between"><a role=button>并发</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly030301lyatomicpre/>Atomic预备知识</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0311lycompletablefuture-intro/>completablefuture-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0310lythreadlocal/>ThreadLocal详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0309lyatomic-classes/>Atomic原子类介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0308lyaqs-details/>aqs详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0307lyconcurrent-collections/>java常见并发容器</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0306lythread-pool-best/>线程池最佳实践</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0305lyjava-thread-pool/>java线程池详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0304lyjmm/>java内存模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0303lyconcurrent-03/>并发03</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03122lylock_escalation/>锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated2/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03121lyobject-concurrent/>对象内存布局和对象头</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0302lyconcurrent-02/>并发02</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0301lyconcurrent-01/>并发01</a></li></ul></li><li><input type=checkbox id=section-8f747d8f024fbfe2b392a25696e01266 class=toggle>
<label for=section-8f747d8f024fbfe2b392a25696e01266 class="flex justify-between"><a role=button>IO</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0203lyio-model/>io模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0202lyio-design-patterns/>io设计模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0201lyio/>io基础</a></li></ul></li><li><input type=checkbox id=section-7d26c3d37b0e4678a1ec776265992903 class=toggle>
<label for=section-7d26c3d37b0e4678a1ec776265992903 class="flex justify-between"><a role=button>集合</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0105lysource-code-concurrenthashmap/>ConcurrentHashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0106lysource-code-hashmap/>HashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0104lysource-code-ArrayList/>ArrayList源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0103lycollections-precautions-for-use/>集合使用注意事项</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0102lycollection_2/>集合_2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0101lycollection_1/>集合_1</a></li></ul></li><li><input type=checkbox id=section-7027a9bc1d603892e7826da81b333f38 class=toggle>
<label for=section-7027a9bc1d603892e7826da81b333f38 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0011lysyntactic_sugar/>语法糖</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0010lyjava_spi/>java_spi</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0009lyunsafe_class/>unsafe类</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0008lybig_decimal/>big_decimal</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0007lyproxy_pattern/>Java代理模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0006lyreflex/>java-reflex</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0005lyserialize/>Java序列化详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0004lypassbyvalue/>为什么Java中只有值传递</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0003lyjava_guide_basic_3/>javaGuide基础3</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0002lyjava_guide_basic_2/>javaGuide基础2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0001lyjava_guide_basic_1/>javaGuide基础1</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0408lyjdk-monitoring-and-troubleshooting-tools/>jvm监控和故障处理工具 总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0406lyjvm-params/>jvm参数</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0403lyclass-structure/>类文件结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0405lyclassloader-detail/>类加载器详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0404lyclassloader-process/>类加载过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0402lygarbage-collection/>java垃圾回收</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0407lyjvm-intro/>jvm-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0401lymemory-area/>memory-area</a></li></ul></li><li><input type=checkbox id=section-04d967d6579d47b35ececb3d233024f1 class=toggle>
<label for=section-04d967d6579d47b35ececb3d233024f1 class="flex justify-between"><a role=button>计算机基础</a></label><ul><li><input type=checkbox id=section-316b43351a75a19ac6dec86ad1a48c45 class=toggle>
<label for=section-316b43351a75a19ac6dec86ad1a48c45 class="flex justify-between"><a role=button>数据结构</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/heap/>堆</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li></ul></li></ul></li><li><input type=checkbox id=section-09d19e9c6f50e4706fe8b6d358c441ce class=toggle>
<label for=section-09d19e9c6f50e4706fe8b6d358c441ce class="flex justify-between"><a role=button>Ssm</a></label><ul><li><a href=/zh/docs/technology/Review/ssm/scope_transaction/>作用域及事务</a></li></ul></li><li><input type=checkbox id=section-11f3d4afcbd3591ad3ee5d79993e29d7 class=toggle>
<label for=section-11f3d4afcbd3591ad3ee5d79993e29d7 class="flex justify-between"><a role=button>Java基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Review/basics/member_variables_and_local_variables/>成员变量与局部变量</a></li><li><a href=/zh/docs/technology/Review/basics/recursion_and_iteration/>递归与迭代</a></li><li><a href=/zh/docs/technology/Review/basics/method_parameter_passing_mechanism/>方法的参数传递机制</a></li><li><a href=/zh/docs/technology/Review/basics/class_and_instance_initialization/>类、实例初始化</a></li><li><a href=/zh/docs/technology/Review/basics/singleton_design_pattern/>单例设计模式</a></li><li><a href=/zh/docs/technology/Review/basics/self_incrementing_variable/>自增变量</a></li></ul></li></ul></li><li><input type=checkbox id=section-2fa8d2f95840b0143e19fcee5ee1ad97 class=toggle>
<label for=section-2fa8d2f95840b0143e19fcee5ee1ad97 class="flex justify-between"><a role=button>SpringCloud</a></label><ul><li><input type=checkbox id=section-b7a5506013de8d65cad1cac0f659f728 class=toggle>
<label for=section-b7a5506013de8d65cad1cac0f659f728 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/springCloud/bl_zhouyang_/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-5057ba12f456498454476dc11b58648b class=toggle>
<label for=section-5057ba12f456498454476dc11b58648b class="flex justify-between"><a role=button>Git</a></label><ul><li><input type=checkbox id=section-55d261358c84b4996ac8d7851d37ccf8 class=toggle>
<label for=section-55d261358c84b4996ac8d7851d37ccf8 class="flex justify-between"><a role=button>基础(尚硅谷视频)_</a></label><ul><li><a href=/zh/docs/technology/Git/git_sgg_/19-26/>19-26_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg_/09-18/>09-18_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg_/01-08/>01-08_git_尚硅谷</a></li></ul></li></ul></li><li><input type=checkbox id=section-d8f59257917ebff8da82fd22583ae10c class=toggle>
<label for=section-d8f59257917ebff8da82fd22583ae10c class="flex justify-between"><a role=button>Maven</a></label><ul><li><input type=checkbox id=section-9b52bdf229c64237c3a478dc6a533410 class=toggle>
<label for=section-9b52bdf229c64237c3a478dc6a533410 class="flex justify-between"><a role=button>进阶(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/advance_dljd_/01-21/>01-21 maven多模块管理_动力节点</a></li></ul></li><li><input type=checkbox id=section-3b2851b4ae70cae160ce8f24dba7236a class=toggle>
<label for=section-3b2851b4ae70cae160ce8f24dba7236a class="flex justify-between"><a role=button>基础(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/base_dljd_/31-43/>31-43 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd_/17-30/>17-30 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd_/01-16/>01-16 maven基础_动力节点</a></li></ul></li></ul></li><li><input type=checkbox id=section-d2ff9acb1ec90bec89f165361ced2010 class=toggle>
<label for=section-d2ff9acb1ec90bec89f165361ced2010 class="flex justify-between"><a role=button>算法</a></label><ul><li><input type=checkbox id=section-d1faa468beb89fe27a31308721f74c82 class=toggle>
<label for=section-d1faa468beb89fe27a31308721f74c82 class="flex justify-between"><a role=button>_算法(第四版)_</a></label><ul><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/3.2.1/>算法红皮书 3.2.1</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/3.1.1-3.1.7/>算法红皮书 3.1.1-3.1.7</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.5/>算法红皮书 2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.4/>算法红皮书 2.4</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.1.2-2.1.3/>算法红皮书 2.1.2-2.1.3</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.1.1/>算法红皮书 2.1.1</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.5.1-1.5.3/>算法红皮书 1.5.1-1.5.3</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.4.1-1.4.10/>算法红皮书 1.4.1-1.4.10</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.3.3.1-1.3.4/>算法红皮书1.3.3.1-1.3.4</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.3.1.1-1.3.2.5/>算法红皮书 1.3.1.1-1.3.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.2.1-1.2.5/>算法红皮书 1.2.1-1.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.1.6-1.1.11/>算法红皮书 1.1.6-1.1.11</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.1.1-1.1.5/>算法红皮书 1.1.1-1.1.5</a></li></ul></li></ul></li><li><input type=checkbox id=section-b414f13e51dbc5e90231aa49f06e7237 class=toggle>
<label for=section-b414f13e51dbc5e90231aa49f06e7237 class="flex justify-between"><a role=button>My Batis Plus</a></label><ul><li><input type=checkbox id=section-0e4fa61015701c3d99296175840aa5d3 class=toggle>
<label for=section-0e4fa61015701c3d99296175840aa5d3 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/40-57/>mybatis-plus-sgg-40-57</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/19-39/>mybatis-plus-sgg-19-39</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/12-18/>mybatis-plus-sgg-12-18</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/01-11/>mybatis-plus-sgg-01-11</a></li></ul></li><li><a href=/zh/docs/technology/MyBatis-Plus/official/hello/>官方的hello-world</a></li></ul></li><li><input type=checkbox id=section-1e5a67821c47d147a096480c75e0d7c4 class=toggle>
<label for=section-1e5a67821c47d147a096480c75e0d7c4 class="flex justify-between"><a role=button>Flowable</a></label><ul><li><input type=checkbox id=section-0a06ca67446b7a26392adaea7b2dc30f class=toggle>
<label for=section-0a06ca67446b7a26392adaea7b2dc30f class="flex justify-between"><a role=button>基础(波哥)_</a></label><ul><li><a href=/zh/docs/technology/Flowable/boge_blbl_/03-others/>boge-03-其他</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_6/>boge-02-flowable进阶_6</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_5/>boge-02-flowable进阶_5</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_4/>boge-02-flowable进阶_4</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_3/>boge-02-flowable进阶_3</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_2/>boge-02-flowable进阶_2</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_1/>boge-02-flowable进阶_1</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/01-base/>boge-01-flowable基础</a></li></ul></li><li><input type=checkbox id=section-6019d9043956834af14f96c2f7dcd5ca class=toggle>
<label for=section-6019d9043956834af14f96c2f7dcd5ca class="flex justify-between"><a role=button>官方文档</a></label><ul><li><a href=/zh/docs/technology/Flowable/offical/05/>Flowable-05-spring-boot</a></li><li><a href=/zh/docs/technology/Flowable/offical/04/>Flowable-04-spring</a></li><li><a href=/zh/docs/technology/Flowable/offical/03/>Flowable-03-api</a></li><li><a href=/zh/docs/technology/Flowable/offical/02/>Flowable-02-Configuration</a></li><li><a href=/zh/docs/technology/Flowable/offical/01/>Flowable-01-GettingStarted</a></li></ul></li><li><a href=/zh/docs/technology/Flowable/zsx_design/01/>zsx_flowable_design01</a></li></ul></li><li><input type=checkbox id=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class=toggle>
<label for=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class="flex justify-between"><a role=button>Rocket Mq</a></label><ul><li><input type=checkbox id=section-8c49e88e8756a0a7b3e45abde3117dd5 class=toggle>
<label for=section-8c49e88e8756a0a7b3e45abde3117dd5 class="flex justify-between"><a role=button>基础(黑马)_</a></label><ul><li><a href=/zh/docs/technology/RocketMQ/heima_/05advance/>05高级功能</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/04case/>04案例</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/03messagetype/>03收发消息</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/02buildcluster/>02双主双从集群搭建</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/01base/>01rocketmq学习</a></li></ul></li></ul></li><li><input type=checkbox id=section-dcbf6163d9f750f7cc3b9417d1386331 class=toggle>
<label for=section-dcbf6163d9f750f7cc3b9417d1386331 class="flex justify-between"><a href=/zh/docs/technology/Interview/>Interview</a></label><ul><li><input type=checkbox id=section-c8fd55079fae864a8c659fb14cbb379e class=toggle>
<label for=section-c8fd55079fae864a8c659fb14cbb379e class="flex justify-between"><a role=button>Cs Basics</a></label><ul><li><input type=checkbox id=section-ac5cd91bf1acc2a16a9dbdfa9c17f629 class=toggle>
<label for=section-ac5cd91bf1acc2a16a9dbdfa9c17f629 class="flex justify-between"><a role=button>Algorithms</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/common-data-structures-leetcode-recommendations/>常见数据结构经典LeetCode题目推荐</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/linkedlist-algorithm-problems/>几道常见的链表算法题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/string-algorithm-problems/>几道常见的字符串算法题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/the-sword-refers-to-offer/>剑指offer部分编程题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/classical-algorithm-problems-recommendations/>经典算法思想总结（含LeetCode题目推荐）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/10-classical-sorting-algorithms/>十大经典排序算法总结</a></li></ul></li><li><input type=checkbox id=section-f435ca39dd71dd7765b81dd8ec05c344 class=toggle>
<label for=section-f435ca39dd71dd7765b81dd8ec05c344 class="flex justify-between"><a role=button>Data Structure</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/heap/>Index</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/bloom-filter/>布隆过滤器</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/red-black-tree/>红黑树</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li><li><input type=checkbox id=section-fa182df3abee2343aa6c977c2a75dda2 class=toggle>
<label for=section-fa182df3abee2343aa6c977c2a75dda2 class="flex justify-between"><a role=button>Network</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/network/computer-network-xiexiren-summary/>《计算机网络》（谢希仁）内容总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/arp/>ARP 协议详解(网络层)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/dns/>DNS 域名系统详解（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http1.0-vs-http1.1/>HTTP 1.0 vs HTTP 1.1（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http-vs-https/>HTTP vs HTTPS（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http-status-codes/>HTTP 常见状态码总结（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/nat/>NAT 协议详解（网络层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/osi-and-tcp-ip-model/>OSI 和 TCP/IP 网络分层模型详解（基础）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/tcp-reliability-guarantee/>TCP 传输可靠性保障（传输层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/tcp-connection-and-disconnection/>TCP 三次握手和四次挥手（传输层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/the-whole-process-of-accessing-web-pages/>访问网页的全过程（知识串联）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/other-network-questions/>计算机网络常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/other-network-questions2/>计算机网络常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/network-attack-means/>网络攻击常见手段总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/application-layer-protocol/>应用层常见协议总结（应用层）</a></li></ul></li><li><input type=checkbox id=section-76856ab8063b8754553c166410441284 class=toggle>
<label for=section-76856ab8063b8754553c166410441284 class="flex justify-between"><a role=button>Operating System</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/linux-intro/>Linux 基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/shell-intro/>Shell 编程基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-01/>操作系统常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-02/>操作系统常见面试题总结(下)</a></li></ul></li></ul></li><li><input type=checkbox id=section-fa219a2fa1e454bccf1abf45b7e68c8e class=toggle>
<label for=section-fa219a2fa1e454bccf1abf45b7e68c8e class="flex justify-between"><a role=button>Database</a></label><ul><li><input type=checkbox id=section-1e90eaf849a2719b2603214b93639e7c class=toggle>
<label for=section-1e90eaf849a2719b2603214b93639e7c class="flex justify-between"><a role=button>Elasticsearch</a></label><ul><li><a href=/zh/docs/technology/Interview/database/elasticsearch/elasticsearch-questions-01/>Elasticsearch常见面试题总结(付费)</a></li></ul></li><li><input type=checkbox id=section-36fcdf6608f26e92ce7bb1e95612ca73 class=toggle>
<label for=section-36fcdf6608f26e92ce7bb1e95612ca73 class="flex justify-between"><a role=button>Mongodb</a></label><ul><li><a href=/zh/docs/technology/Interview/database/mongodb/mongodb-questions-01/>MongoDB常见面试题总结（上）</a></li><li><a href=/zh/docs/technology/Interview/database/mongodb/mongodb-questions-02/>MongoDB常见面试题总结（下）</a></li></ul></li><li><input type=checkbox id=section-1681ed9defad2064b37ff3e603cd509c class=toggle>
<label for=section-1681ed9defad2064b37ff3e603cd509c class="flex justify-between"><a role=button>Mysql</a></label><ul><li><a href=/zh/docs/technology/Interview/database/mysql/innodb-implementation-of-mvcc/>InnoDB存储引擎对MVCC的实现</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-query-cache/>MySQL查询缓存详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/some-thoughts-on-database-storage-time/>MySQL日期类型选择建议</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-logs/>MySQL三大日志(binlog、redo log和undo log)详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/transaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-index/>MySQL索引详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/index-invalidation-caused-by-implicit-conversion/>MySQL隐式转换造成索引失效</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-query-execution-plan/>MySQL执行计划分析</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-auto-increment-primary-key-continuous/>MySQL自增主键一定是连续的吗</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/how-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/a-thousand-lines-of-mysql-study-notes/>一千行 MySQL 学习笔记</a></li></ul></li><li><input type=checkbox id=section-7b494a9accb20a42d3eb50307ebf95b8 class=toggle>
<label for=section-7b494a9accb20a42d3eb50307ebf95b8 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Interview/database/redis/3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-data-structures-02/>Redis 3 种特殊数据类型详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-data-structures-01/>Redis 5 种基本数据类型详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-questions-01/>Redis常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-questions-02/>Redis常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-common-blocking-problems-summary/>Redis常见阻塞原因总结</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-persistence/>Redis持久化机制详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-cluster/>Redis集群详解(付费)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-memory-fragmentation/>Redis内存碎片详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-skiplist/>Redis为什么用跳表实现有序集合</a></li><li><a href=/zh/docs/technology/Interview/database/redis/cache-basics/>缓存基础常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-delayed-task/>如何基于Redis实现延时任务</a></li></ul></li><li><input type=checkbox id=section-0b495945d7d1c7bace636f2809188369 class=toggle>
<label for=section-0b495945d7d1c7bace636f2809188369 class="flex justify-between"><a role=button>SQL</a></label><ul><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-01/>SQL常见面试题总结（1）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-02/>SQL常见面试题总结（2）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-03/>SQL常见面试题总结（3）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-04/>SQL常见面试题总结（4）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-05/>SQL常见面试题总结（5）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-syntax-summary/>SQL语法基础知识总结</a></li></ul></li><li><a href=/zh/docs/technology/Interview/database/nosql/>NoSQL基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/database/basis/>数据库基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/database/character-set/>字符集详解</a></li></ul></li><li><input type=checkbox id=section-9bc7f274474a2d4825bfb7e0f835ec9f class=toggle>
<label for=section-9bc7f274474a2d4825bfb7e0f835ec9f class="flex justify-between"><a role=button>Distributed System</a></label><ul><li><input type=checkbox id=section-4aa0a804a8f6d6d2745a8f9d92dbae63 class=toggle>
<label for=section-4aa0a804a8f6d6d2745a8f9d92dbae63 class="flex justify-between"><a role=button>Distributed Process Coordination</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-in-action/>ZooKeeper 实战</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus/>ZooKeeper相关概念总结(进阶)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro/>ZooKeeper相关概念总结(入门)</a></li></ul></li><li><input type=checkbox id=section-917636e43923e143cb27e958ae247d83 class=toggle>
<label for=section-917636e43923e143cb27e958ae247d83 class="flex justify-between"><a role=button>Protocol</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/cap-and-base-theorem/>CAP & BASE理论详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/gossip-protocl/>Gossip 协议详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/paxos-algorithm/>Paxos 算法详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/raft-algorithm/>Raft 算法详解</a></li></ul></li><li><input type=checkbox id=section-5f212fdd6451198aab8e6d9d1c28c4d2 class=toggle>
<label for=section-5f212fdd6451198aab8e6d9d1c28c4d2 class="flex justify-between"><a role=button>Rpc</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/dubbo/>Dubbo常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/rpc-intro/>RPC基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/httprpc/>有了 HTTP 协议，为什么还要有 RPC ？</a></li></ul></li><li><a href=/zh/docs/technology/Interview/distributed-system/api-gateway/>API网关基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/spring-cloud-gateway-questions/>Spring Cloud Gateway常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-id/>分布式ID介绍&实现方案总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-id-design/>分布式ID设计指南</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-configuration-center/>分布式配置中心常见问题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-transaction/>分布式事务常见解决方案总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-lock-implementations/>分布式锁常见实现方案总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-lock/>分布式锁介绍</a></li></ul></li><li><input type=checkbox id=section-20eb042d5085894960b2b40cdde1bd95 class=toggle>
<label for=section-20eb042d5085894960b2b40cdde1bd95 class="flex justify-between"><a role=button>High Availability</a></label><ul><li><a href=/zh/docs/technology/Interview/high-availability/timeout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/limit-request/>服务限流详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/high-availability-system-design/>高可用系统设计指南</a></li><li><a href=/zh/docs/technology/Interview/high-availability/fallback-and-circuit-breaker/>降级&熔断详解(付费)</a></li><li><a href=/zh/docs/technology/Interview/high-availability/redundancy/>冗余设计详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/performance-test/>性能测试入门</a></li></ul></li><li><input type=checkbox id=section-d863e9c02108d739d2116dee6c3f0df2 class=toggle>
<label for=section-d863e9c02108d739d2116dee6c3f0df2 class="flex justify-between"><a role=button>High Performance</a></label><ul><li><a href=/zh/docs/technology/Interview/high-performance/cdn/>CDN工作原理详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/disruptor-questions/>Disruptor常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/kafka-questions-01/>Kafka常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/rabbitmq-questions/>RabbitMQ常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/rocketmq-questions/>RocketMQ常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/sql-optimization/>常见SQL优化手段总结（付费）</a></li><li><a href=/zh/docs/technology/Interview/high-performance/read-and-write-separation-and-library-subtable/>读写分离和分库分表详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/load-balancing/>负载均衡原理及算法详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/deep-pagination-optimization/>深度分页介绍及优化建议</a></li><li><a href=/zh/docs/technology/Interview/high-performance/data-cold-hot-separation/>数据冷热分离详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/message-queue/>消息队列基础知识总结</a></li></ul></li><li><input type=checkbox id=section-2874dffbab1645c0b90b66f58878baeb class=toggle>
<label for=section-2874dffbab1645c0b90b66f58878baeb class="flex justify-between"><a role=button>High Quality Technical Articles</a></label><ul><li><input type=checkbox id=section-043c9e2ae521f883513d71615d921b93 class=toggle>
<label for=section-043c9e2ae521f883513d71615d921b93 class="flex justify-between"><a role=button>Advanced Programmer</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant/>程序员的技术成长战略</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/programmer-quickly-learn-new-technology/>程序员如何快速学习新技术</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/seven-tips-for-becoming-an-advanced-programmer/>给想成长为高级别开发同学的七条建议</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work/>工作五年之后，对技术和业务的思考</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/meituan-three-year-summary-lesson-10/>美团三年，总结的10条血泪教训</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road/>十年大厂成长之路</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/20-bad-habits-of-bad-programmers/>糟糕程序员的 20 个坏习惯</a></li></ul></li><li><input type=checkbox id=section-5a7311ea7fe807f97a6fa93dffde10b6 class=toggle>
<label for=section-5a7311ea7fe807f97a6fa93dffde10b6 class="flex justify-between"><a role=button>Interview</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/some-secrets-about-alibaba-interview/>阿里技术面试的一些秘密</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/technical-preliminary-preparation/>从面试官和候选者的角度谈如何准备技术初试</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/summary-of-spring-recruitment/>普通人的春招总结（阿里、腾讯offer）</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology/>如何在技术初试中考察程序员的技术能力</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/screen-candidates-for-packaging/>如何甄别应聘者的包装程度</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/my-personal-experience-in-2021/>校招进入飞书的个人经验</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer/>一位大龄程序员所经历的面试的历炼和思考</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-of-get-offer-from-over-20-big-companies/>斩获 20+ 大厂 offer 的面试经验分享</a></li></ul></li><li><input type=checkbox id=section-bf0bb8140b840e0af3c2632b6b73e609 class=toggle>
<label for=section-bf0bb8140b840e0af3c2632b6b73e609 class="flex justify-between"><a role=button>Personal Experience</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/four-year-work-in-tencent-summary/>从校招入职腾讯的四年工作总结</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao/>滴滴和头条两年后端工作经验分享</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/huawei-od-275-days/>华为 OD 275 天后，我进了腾讯！</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/8-years-programmer-work-summary/>一个中科大差生的 8 年程序员工作总结</a></li></ul></li><li><input type=checkbox id=section-8166233fd6553926230055376f2b97f6 class=toggle>
<label for=section-8166233fd6553926230055376f2b97f6 class="flex justify-between"><a role=button>Programmer</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/efficient-book-publishing-and-practice-guide/>程序员高效出书避坑和实践指南</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/how-do-programmers-publish-a-technical-book/>程序员怎样出版一本技术书</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/high-value-certifications-for-programmers/>程序员最该拿的几种高含金量证书</a></li></ul></li><li><input type=checkbox id=section-b607a393d7717c448e31e58c8972bbba class=toggle>
<label for=section-b607a393d7717c448e31e58c8972bbba class="flex justify-between"><a role=button>Work</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/32-tips-improving-career/>32条总结教你提升职场经验</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/employee-performance/>聊聊大厂的绩效考核</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/get-into-work-mode-quickly-when-you-join-a-company/>新入职一家公司如何快速进入工作状态</a></li></ul></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/readme/>Index</a></li></ul></li><li><input type=checkbox id=section-5680a0cf00b09d8470dc67fa0a170b89 class=toggle>
<label for=section-5680a0cf00b09d8470dc67fa0a170b89 class="flex justify-between"><a role=button>Java</a></label><ul><li><input type=checkbox id=section-6e2eabf08cfe622d9921e3edfa11e55a class=toggle>
<label for=section-6e2eabf08cfe622d9921e3edfa11e55a class="flex justify-between"><a role=button>Basis</a></label><ul><li><a href=/zh/docs/technology/Interview/java/basis/java-keyword-summary/>Index</a></li><li><a href=/zh/docs/technology/Interview/java/basis/bigdecimal/>BigDecimal 详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/spi/>Java SPI 机制详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/proxy/>Java 代理模式详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/reflection/>Java 反射机制详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/unsafe/>Java 魔法类 Unsafe 详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/serialization/>Java 序列化详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/syntactic-sugar/>Java 语法糖详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/why-there-only-value-passing-in-java/>Java 值传递详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-01/>Java基础常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-03/>Java基础常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-02/>Java基础常见面试题总结(中)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/generics-and-wildcards/>泛型&通配符详解</a></li></ul></li><li><input type=checkbox id=section-b9f81b31813c0f4b2cd6e884ad0c0511 class=toggle>
<label for=section-b9f81b31813c0f4b2cd6e884ad0c0511 class="flex justify-between"><a role=button>Collection</a></label><ul><li><a href=/zh/docs/technology/Interview/java/collection/arrayblockingqueue-source-code/>ArrayBlockingQueue 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/arraylist-source-code/>ArrayList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/concurrent-hash-map-source-code/>ConcurrentHashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/copyonwritearraylist-source-code/>CopyOnWriteArrayList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/delayqueue-source-code/>DelayQueue 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/hashmap-source-code/>HashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-questions-01/>Java集合常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-questions-02/>Java集合常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-precautions-for-use/>Java集合使用注意事项总结</a></li><li><a href=/zh/docs/technology/Interview/java/collection/linkedhashmap-source-code/>LinkedHashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/linkedlist-source-code/>LinkedList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/priorityqueue-source-code/>PriorityQueue 源码分析（付费）</a></li></ul></li><li><input type=checkbox id=section-8cc9034354bdd549787a43bea3c7c40c class=toggle>
<label for=section-8cc9034354bdd549787a43bea3c7c40c class="flex justify-between"><a role=button>Concurrent</a></label><ul><li><a href=/zh/docs/technology/Interview/java/concurrent/aqs/>AQS 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/atomic-classes/>Atomic 原子类总结</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/cas/>CAS 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/completablefuture-intro/>CompletableFuture 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-collections/>Java 常见并发容器总结</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-thread-pool-summary/>Java 线程池详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-thread-pool-best-practices/>Java 线程池最佳实践</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-01/>Java并发常见面试题总结（上）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-03/>Java并发常见面试题总结（下）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-02/>Java并发常见面试题总结（中）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/jmm/>JMM（Java 内存模型）详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/threadlocal/>ThreadLocal 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/reentrantlock/>从ReentrantLock的实现看AQS的原理及应用</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/optimistic-lock-and-pessimistic-lock/>乐观锁和悲观锁详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/virtual-thread/>虚拟线程常见问题总结</a></li></ul></li><li><input type=checkbox id=section-498d2cde022f952a6751a7ebd2a53aeb class=toggle>
<label for=section-498d2cde022f952a6751a7ebd2a53aeb class="flex justify-between"><a role=button>Io</a></label><ul><li><a href=/zh/docs/technology/Interview/java/io/io-basis/>Java IO 基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/java/io/io-model/>Java IO 模型详解</a></li><li><a href=/zh/docs/technology/Interview/java/io/io-design-patterns/>Java IO 设计模式总结</a></li><li><a href=/zh/docs/technology/Interview/java/io/nio-basis/>Java NIO 核心知识总结</a></li></ul></li><li><input type=checkbox id=section-9ee5b42dd6a7edc6e1c0a1c88bde9426 class=toggle>
<label for=section-9ee5b42dd6a7edc6e1c0a1c88bde9426 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/technology/Interview/java/jvm/memory-area/>Java内存区域详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jdk-monitoring-and-troubleshooting-tools/>JDK监控和故障处理工具总结</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-garbage-collection/>JVM垃圾回收详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-in-action/>JVM线上问题排查和性能调优案例</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-intro/>大白话带你认识 JVM</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/class-loading-process/>类加载过程详解</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/classloader/>类加载器详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/class-file-structure/>类文件结构详解</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-parameters-intro/>最重要的JVM参数总结</a></li></ul></li><li><input type=checkbox id=section-aad47cdb4b5f179b406c6cf1c6282621 class=toggle>
<label for=section-aad47cdb4b5f179b406c6cf1c6282621 class="flex justify-between"><a role=button>New Features</a></label><ul><li><a href=/zh/docs/technology/Interview/java/new-features/java8-tutorial-translate/>Index</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java10/>Java 10 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java11/>Java 11 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java12-13/>Java 12 & 13 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java14-15/>Java 14 & 15 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java16/>Java 16 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java17/>Java 17 新特性概览（重要）</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java18/>Java 18 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java19/>Java 19 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java20/>Java 20 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java21/>Java 21 新特性概览(重要)</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java22-23/>Java 22 & 23 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java9/>Java 9 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java8-common-new-features/>Java8 新特性实战</a></li></ul></li></ul></li><li><input type=checkbox id=section-f77457e1ea013328645923186d400509 class=toggle>
<label for=section-f77457e1ea013328645923186d400509 class="flex justify-between"><a role=button>System Design</a></label><ul><li><input type=checkbox id=section-a9a8bf9713340a4888a6db9d8f8eda42 class=toggle>
<label for=section-a9a8bf9713340a4888a6db9d8f8eda42 class="flex justify-between"><a role=button>Basis</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/basis/RESTfulAPI/>RestFul API 简明教程</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/unit-test/>单元测试到底是什么？应该怎么做？</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/software-engineering/>软件工程简明教程</a></li></ul></li><li><input type=checkbox id=section-3bbccee656befcd0673c7a7ef7393710 class=toggle>
<label for=section-3bbccee656befcd0673c7a7ef7393710 class="flex justify-between"><a role=button>Framework</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/async1/>Async 注解原理分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/Async/>Async 注解原理分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/ioc-and-aop/>IoC & AOP详解（快速搞懂）</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/mybatis/mybatis-interview/>MyBatis常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/netty/>Netty常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/springboot-source-code/>Spring Boot核心源码解读（付费）</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-transaction/>Spring 事务详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-design-patterns-summary/>Spring 中的设计模式详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-common-annotations/>Spring&amp;SpringBoot常用注解总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-boot-auto-assembly-principles/>SpringBoot 自动装配原理详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/springboot-knowledge-and-questions-summary/>SpringBoot常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-knowledge-and-questions-summary/>Spring常见面试题总结</a></li></ul></li><li><input type=checkbox id=section-2baa7507d4a9ede0d38490ad77045e56 class=toggle>
<label for=section-2baa7507d4a9ede0d38490ad77045e56 class="flex justify-between"><a role=button>Security</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/security/jwt-intro/>JWT 基础概念详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/advantages-and-disadvantages-of-jwt/>JWT 身份认证优缺点分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/sso-intro/>SSO 单点登录详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/encryption-algorithms/>常见加密算法总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/basis-of-authority-certification/>认证授权基础概念详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/data-desensitization/>数据脱敏方案总结</a></li></ul></li><li><a href=/zh/docs/technology/Interview/system-design/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/>Index</a></li><li><a href=/zh/docs/technology/Interview/system-design/schedule-task/>Java 定时任务详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/web-real-time-message-push/>Web 实时消息推送详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/design-pattern/>设计模式常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/system-design-questions/>系统设计常见面试题总结(付费)</a></li></ul></li><li><input type=checkbox id=section-b12b3763d379141770d4fa07f12c73ec class=toggle>
<label for=section-b12b3763d379141770d4fa07f12c73ec class="flex justify-between"><a role=button>Tools</a></label><ul><li><input type=checkbox id=section-b6832c2bda30f11dca94b5d9440b112e class=toggle>
<label for=section-b6832c2bda30f11dca94b5d9440b112e class="flex justify-between"><a role=button>Docker</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/docker/docker-intro/>Docker核心概念总结</a></li><li><a href=/zh/docs/technology/Interview/tools/docker/docker-in-action/>Docker实战</a></li></ul></li><li><input type=checkbox id=section-e383b654b47946dea2499bcb3c4bac31 class=toggle>
<label for=section-e383b654b47946dea2499bcb3c4bac31 class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/git/github-tips/>Github实用小技巧总结</a></li><li><a href=/zh/docs/technology/Interview/tools/git/git-intro/>Git核心概念总结</a></li></ul></li><li><input type=checkbox id=section-05546e7a7af454a542b00fa4a34f43a5 class=toggle>
<label for=section-05546e7a7af454a542b00fa4a34f43a5 class="flex justify-between"><a role=button>Gradle</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/gradle/gradle-core-concepts/>Gradle核心概念总结</a></li></ul></li><li><input type=checkbox id=section-139d2af6b95c327fa03497bf63e3a4f4 class=toggle>
<label for=section-139d2af6b95c327fa03497bf63e3a4f4 class="flex justify-between"><a role=button>Maven</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/maven/maven-core-concepts/>Maven核心概念总结</a></li><li><a href=/zh/docs/technology/Interview/tools/maven/maven-best-practices/>Maven最佳实践</a></li></ul></li></ul></li></ul></li><li><a href=/zh/docs/technology/Markdown/_SuperTutorial_/>Markdown超级教程</a></li></ul></li><li class=book-section-flat><a href=/zh/docs/problem/>问题解决</a><ul><li><input type=checkbox id=section-ef3324c710f7241c89fc009a5f576fbc class=toggle>
<label for=section-ef3324c710f7241c89fc009a5f576fbc class="flex justify-between"><a role=button>Linux</a></label><ul><li><a href=/zh/docs/problem/Linux/20250331/>平板安装linuxDeploy的问题简记</a></li><li><a href=/zh/docs/problem/Linux/20230919/>Linux操作符问题</a></li><li><a href=/zh/docs/problem/Linux/20230819/>Debian问题处理3</a></li><li><a href=/zh/docs/problem/Linux/20230817/>Debian问题处理2</a></li><li><a href=/zh/docs/problem/Linux/20230815/>Debian问题处理1</a></li><li><a href=/zh/docs/problem/Linux/20230803/>安卓手机及平板安装linuxDeploy的问题简记</a></li><li><a href=/zh/docs/problem/Linux/20230523/>zsh卸载后root无法登录及vm扩容centos7报错处理</a></li><li><a href=/zh/docs/problem/Linux/20221101/>post</a></li></ul></li><li><input type=checkbox id=section-ab4f1dd893a7409a00858148e98c245c class=toggle>
<label for=section-ab4f1dd893a7409a00858148e98c245c class="flex justify-between"><a role=button>Other</a></label><ul><li><a href=/zh/docs/problem/Other/01/>如何搜索</a></li></ul></li><li><input type=checkbox id=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class=toggle>
<label for=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/problem/JVM/20230526/>JDK代理和CGLIB代理</a></li><li><a href=/zh/docs/problem/JVM/2023052302/>linux中调试open jdk</a></li></ul></li><li><input type=checkbox id=section-a028a45b205904a783d0c60e8a184391 class=toggle>
<label for=section-a028a45b205904a783d0c60e8a184391 class="flex justify-between"><a role=button>Hexo</a></label><ul><li><a href=/zh/docs/problem/Hexo/01/>hexo在线查看pdf</a></li></ul></li><li><input type=checkbox id=section-1c55bf7a5578a7de17cc1ee45681106b class=toggle>
<label for=section-1c55bf7a5578a7de17cc1ee45681106b class="flex justify-between"><a role=button>Idea</a></label><ul><li><a href=/zh/docs/problem/Idea/01/>问题01</a></li></ul></li><li><input type=checkbox id=section-66dd985e53d8e0b78efdab983762411c class=toggle>
<label for=section-66dd985e53d8e0b78efdab983762411c class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/problem/Git/01/>git使用ssh连不上</a></li></ul></li><li><input type=checkbox id=section-9440d21f7eb9f8cf7f45b16969ab18dc class=toggle>
<label for=section-9440d21f7eb9f8cf7f45b16969ab18dc class="flex justify-between"><a role=button>Hugo</a></label><ul><li><a href=/zh/docs/problem/Hugo/p1/>hugo踩坑</a></li><li><a href=/zh/docs/problem/Hugo/01a/>图片测试(hugo踩坑)</a></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/life/>生活</a><ul><li><input type=checkbox id=section-c7f767205668758142bb8053263cc14f class=toggle>
<label for=section-c7f767205668758142bb8053263cc14f class="flex justify-between"><a role=button>往日归档</a></label><ul><li><a href=/zh/docs/life/archive/20231026/>成就</a></li><li><a href=/zh/docs/life/archive/20231013/>沉没</a></li><li><a href=/zh/docs/life/archive/20230913/>鲇鱼后思</a></li><li><a href=/zh/docs/life/archive/20230912/>病愈 有感</a></li><li><a href=/zh/docs/life/archive/20220724/>人为什么要结婚(找对象)</a></li><li><a href=/zh/docs/life/archive/20220416/>《作酒》有感</a></li><li><a href=/zh/docs/life/archive/20121226/>2021年最后一个周日</a></li><li><a href=/zh/docs/life/archive/20231021/>沉沦</a></li></ul></li><li><a href=/zh/docs/life/20250103/>随想</a></li><li><a href=/zh/docs/life/dailyExcerpt/>每日摘抄</a></li><li><a href=/zh/docs/life/20240626/>知命不惧 日日自新</a></li><li><a href=/zh/docs/life/20231227/>起床临感</a></li><li><a href=/zh/docs/life/20231101/>20231101</a></li></ul></li><li class=book-section-flat><span>文化</span><ul><li><input type=checkbox id=section-b8eda9fc7502eac7b68386b9c9edef56 class=toggle>
<label for=section-b8eda9fc7502eac7b68386b9c9edef56 class="flex justify-between"><a role=button>汉字就是这么来的</a></label><ul><li><a href=/zh/docs/culture/%E6%B1%89%E5%AD%97%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E6%9D%A5%E7%9A%84/01%E8%B5%B0%E8%BF%9B%E6%B1%89%E5%AD%97%E4%B8%96%E7%95%8C/>01走进汉字世界</a></li></ul></li><li><input type=checkbox id=section-36af101672fdef38bd3af078cbe1e845 class=toggle>
<label for=section-36af101672fdef38bd3af078cbe1e845 class="flex justify-between"><a role=button>天纪</a></label><ul><li><span>人间道</span><ul><li><input type=checkbox id=section-c36005c9ebaefb7d6ad1c4b3beef5892 class=toggle>
<label for=section-c36005c9ebaefb7d6ad1c4b3beef5892 class="flex justify-between"><a role=button>下经</a></label><ul><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/64%E7%81%AB%E6%B0%B4%E6%9C%AA%E6%BF%9F/>64火水未濟</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/63%E6%B0%B4%E7%81%AB%E6%97%A2%E6%BF%9F/>63水火既濟</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/62%E9%9B%B7%E5%B1%B1%E5%B0%8F%E9%81%8E/>62雷山小過</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/61%E9%A2%A8%E6%BE%A4%E4%B8%AD%E5%AD%9A/>61風澤中孚</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/60%E6%B0%B4%E6%BE%A4%E7%AF%80/>60水澤節</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/59%E9%A2%A8%E6%B0%B4%E6%B8%99/>59風水渙</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/58%E5%85%8C%E7%88%B2%E6%BE%A4/>58兌爲澤</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/57%E5%B7%BD%E7%82%BA%E9%A2%A8/>57巽為風</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/56%E7%81%AB%E5%B1%B1%E6%97%85/>56火山旅</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/55%E9%9B%B7%E7%81%AB%E8%B1%90/>55雷火豐</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/54%E9%9B%B7%E6%BE%A4%E6%AD%B8%E5%A6%B9/>54雷澤歸妹</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/53%E9%A2%A8%E5%B1%B1%E6%BC%B8/>53風山漸</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/52%E8%89%AE%E7%82%BA%E5%B1%B1/>52艮為山</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/51%E9%9C%87%E7%88%B2%E9%9B%B7/>51震爲雷</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/50%E7%81%AB%E9%A2%A8%E9%BC%8E/>50火風鼎</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/49%E6%BE%A4%E7%81%AB%E9%9D%A9/>49澤火革</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/48%E6%B0%B4%E9%A2%A8%E4%BA%95/>48水風井</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/47%E6%BE%A4%E6%B0%B4%E5%9B%B0/>47澤水困</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/46%E5%9C%B0%E9%A2%A8%E5%8D%87/>46地風升</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/45%E6%BE%A4%E5%9C%B0%E8%90%83/>45澤地萃</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/44%E5%A4%A9%E9%A2%A8%E5%A7%A4/>44天風姤</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/43%E6%BE%A4%E5%A4%A9%E5%A4%AC/>43澤天夬</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/42%E9%A2%A8%E9%9B%B7%E7%9B%8A/>42風雷益</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/41%E5%B1%B1%E6%BE%A4%E6%90%8D/>41山澤損</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/40%E9%9B%B7%E6%B0%B4%E8%A7%A3/>40雷水解</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/39%E6%B0%B4%E5%B1%B1%E8%B9%87/>39水山蹇</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/38%E7%81%AB%E6%BE%A4%E7%9D%BD/>38火澤睽</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/37%E9%A2%A8%E7%81%AB%E5%AE%B6%E4%BA%BA/>37風火家人</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/36%E5%9C%B0%E7%81%AB%E6%98%8E%E5%A4%B7/>36地火明夷</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/35%E7%81%AB%E5%9C%B0%E6%99%89/>35火地晉</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/34%E9%9B%B7%E5%A4%A9%E5%A4%A7%E5%A3%AF/>34雷天大壯</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/33%E5%A4%A9%E5%B1%B1%E9%81%AF/>33天山遯</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/32%E9%9B%B7%E9%A2%A8%E6%81%86/>32雷風恆</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8B%E7%BB%8F/31%E6%BE%A4%E5%B1%B1%E5%92%B8/>31澤山咸</a></li></ul></li><li><input type=checkbox id=section-15975a28a78c108ecbf451806d35782b class=toggle>
<label for=section-15975a28a78c108ecbf451806d35782b class="flex justify-between"><a role=button>上经</a></label><ul><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/30%E9%9B%A2%E7%82%BA%E7%81%AB/>30離為火</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/29%E5%9D%8E%E7%88%B2%E6%B0%B4/>29坎爲水</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/28%E6%BE%A4%E9%A2%A8%E5%A4%A7%E9%81%8E/>28澤風大過</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/27%E5%B1%B1%E9%9B%B7%E9%A0%A4/>27山雷頤</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/26%E5%B1%B1%E5%A4%A9%E5%A4%A7%E7%95%9C/>26山天大畜</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/25%E5%A4%A9%E9%9B%B7%E6%97%A0%E5%A6%84/>25天雷无妄</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/24%E5%9C%B0%E9%9B%B7%E5%BE%A9/>24地雷復</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/23%E5%B1%B1%E5%9C%B0%E5%89%9D/>23山地剝</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/22%E5%B1%B1%E7%81%AB%E8%B3%81/>22山火賁</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/21%E7%81%AB%E9%9B%B7%E5%99%AC%E5%97%91/>21火雷噬嗑</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/20%E9%A2%A8%E5%9C%B0%E8%A7%80/>20風地觀</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/19%E5%9C%B0%E6%BE%A4%E8%87%A8/>19地澤臨</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/18%E5%B1%B1%E9%A2%A8%E8%A0%B1/>18山風蠱</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/17%E6%BE%A4%E9%9B%B7%E9%9A%A8/>17澤雷隨</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/16%E9%9B%B7%E5%9C%B0%E8%B1%AB/>16雷地豫</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/15%E5%9C%B0%E5%B1%B1%E8%AC%99/>15地山謙</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/14%E7%81%AB%E5%A4%A9%E5%A4%A7%E6%9C%89/>14火天大有</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/13%E5%A4%A9%E7%81%AB%E5%90%8C%E4%BA%BA/>13天火同人</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/12%E5%A4%A9%E5%9C%B0%E5%90%A6/>12天地否</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/11%E5%9C%B0%E5%A4%A9%E6%B3%B0/>11地天泰</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/10%E5%A4%A9%E6%B3%BD%E5%B1%A5/>10天澤履</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/09%E9%A2%A8%E5%A4%A9%E5%B0%8F%E7%95%9C/>09風天小畜</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/08%E6%B0%B4%E5%9C%B0%E6%AF%94/>08水地比</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/07%E5%9C%B0%E6%B0%B4%E5%B8%AB/>07地水師</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/06%E5%A4%A9%E6%B0%B4%E8%AE%BC/>06天水讼</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/05%E6%B0%B4%E5%A4%A9%E9%9C%80/>05水天需</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/04%E5%B1%B1%E6%B0%B4%E8%92%99/>04山水蒙</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/03%E6%B0%B4%E9%9B%B7%E5%B1%AF/>03水雷屯</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/02%E5%9D%A4%E4%B8%BA%E5%9C%B0/>02坤爲地</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/%E4%B8%8A%E7%BB%8F/01%E4%B9%BE%E4%B8%BA%E5%A4%A9/>01乾爲天</a></li></ul></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/0%E5%BA%8F/>序</a></li></ul></li></ul></li><li><input type=checkbox id=section-2caf93f41e261fb08fbc8abd7e4170d5 class=toggle>
<label for=section-2caf93f41e261fb08fbc8abd7e4170d5 class="flex justify-between"><a role=button>论语</a></label><ul><li><input type=checkbox id=section-0d6e955a0862e2b200af0e2a2f889dd6 class=toggle>
<label for=section-0d6e955a0862e2b200af0e2a2f889dd6 class="flex justify-between"><a role=button>论语译注 杨伯峻</a></label><ul><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/19%E5%AD%90%E5%BC%A0%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B9%9D/>19子张篇第十九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/13%E5%AD%90%E8%B7%AF%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%89/>13子路篇第十三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/09%E5%AD%90%E7%BD%95%E7%AF%87%E7%AC%AC%E4%B9%9D/>09子罕篇第九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/06%E9%9B%8D%E4%B9%9F%E7%AF%87%E7%AC%AC%E5%85%AD/>06雍也篇第六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/20%E5%B0%A7%E6%9B%B0%E7%AF%87%E7%AC%AC%E4%BA%8C%E5%8D%81/>20尧曰篇第二十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/17%E9%98%B3%E8%B4%A7%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%83/>17阳货篇第十七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/12%E9%A2%9C%E6%B8%8A%E7%AF%87%E7%AC%AC%E5%8D%81%E4%BA%8C/>12颜渊篇第十二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/01%E5%AD%A6%E8%80%8C%E7%AF%87%E7%AC%AC%E4%B8%80/>01学而篇第一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/10%E4%B9%A1%E5%85%9A%E7%AF%87%E7%AC%AC%E5%8D%81/>10乡党篇第十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/14%E5%AE%AA%E9%97%AE%E7%AF%87%E7%AC%AC%E5%8D%81%E5%9B%9B/>14宪问篇第十四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/11%E5%85%88%E8%BF%9B%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%80/>11先进篇第十一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/18%E5%BE%AE%E5%AD%90%E7%AF%87%E7%AC%AC%E5%8D%81%E5%85%AB/>18微子篇第十八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/02%E4%B8%BA%E6%94%BF%E7%AF%87%E7%AC%AC%E4%BA%8C/>02为政篇第二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AF%87%E7%AC%AC%E5%8D%81%E4%BA%94/>15卫灵公篇第十五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/08%E6%B3%B0%E4%BC%AF%E7%AF%87%E7%AC%AC%E5%85%AB/>08泰伯篇第八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/07%E8%BF%B0%E8%80%8C%E7%AF%87%E7%AC%AC%E4%B8%83/>07述而篇第七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/%E8%AF%95%E8%AE%BA-%E5%AF%BC%E8%A8%80-%E4%BE%8B%E8%A8%80/>试论-导言-例言</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/04%E9%87%8C%E4%BB%81%E7%AF%87%E7%AC%AC%E5%9B%9B/>04里仁篇第四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/16%E5%AD%A3%E6%B0%8F%E7%AF%87%E7%AC%AC%E5%8D%81%E5%85%AD/>16季氏篇第十六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AF%87%E7%AC%AC%E4%BA%94/>05公冶长篇第五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/03%E5%85%AB%E4%BD%BE%E7%AF%87%E7%AC%AC%E4%B8%89/>03八佾篇第三</a></li></ul></li><li><input type=checkbox id=section-3c0bd8b9ce8b9615dcc02b6df6e7788e class=toggle>
<label for=section-3c0bd8b9ce8b9615dcc02b6df6e7788e class="flex justify-between"><a role=button>论语的生活智慧</a></label><ul><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/01%E5%AD%A6%E5%A4%A9%E7%AC%AC%E4%B8%80/>01学天第一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/02%E4%B8%BA%E6%94%BF%E7%AC%AC%E4%BA%8C/>02为政第二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/03%E5%85%AB%E4%BD%BE%E7%AC%AC%E4%B8%89/>03八佾第三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/04%E9%87%8C%E4%BB%81%E7%AC%AC%E5%9B%9B/>04里仁第四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AC%AC%E4%BA%94/>05公治长第五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/06%E9%9B%8D%E4%B9%9F%E7%AC%AC%E5%85%AD/>06雍也第六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/07%E8%BF%B0%E8%80%8C%E7%AC%AC%E4%B8%83/>07述而第七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/08%E6%B3%B0%E4%BC%AF%E7%AC%AC%E5%85%AB/>08泰伯第八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/09%E5%AD%90%E7%BD%95%E7%AC%AC%E4%B9%9D/>09子罕第九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/10%E4%B9%A1%E5%85%9A%E7%AC%AC%E5%8D%81/>10乡党第十</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/11%E5%85%88%E8%BF%9B%E7%AC%AC%E5%8D%81%E4%B8%80/>11先进第十一</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/12%E9%A2%9C%E6%B8%8A%E7%AC%AC%E5%8D%81%E4%BA%8C/>12颜渊第十二</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/13%E5%AD%90%E8%B7%AF%E7%AC%AC%E5%8D%81%E4%B8%89/>13子路第十三</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/14%E5%AE%AA%E9%97%AE%E7%AC%AC%E5%8D%81%E5%9B%9B/>14宪问第十四</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AC%AC%E5%8D%81%E4%BA%94/>15卫灵公第十五</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/16%E5%AD%A3%E6%B0%8F%E7%AC%AC%E5%8D%81%E5%85%AD/>16季氏第十六</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/17%E9%98%B3%E8%B4%A7%E7%AC%AC%E5%8D%81%E4%B8%83/>17阳货第十七</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/18%E5%BE%AE%E5%AD%90%E7%AC%AC%E5%8D%81%E5%85%AB/>18微子第十八</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/19%E5%AD%90%E5%BC%A0%E7%AC%AC%E5%8D%81%E4%B9%9D/>19子张第十九</a></li><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7/20%E5%B0%A7%E6%97%A5%E7%AC%AC%E4%BA%8C%E5%8D%81/>20尧日第二十</a></li></ul></li></ul></li><li><input type=checkbox id=section-daa70c3e612b40fe4050f5185bb12608 class=toggle>
<label for=section-daa70c3e612b40fe4050f5185bb12608 class="flex justify-between"><a role=button>恰同学少年</a></label><ul><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AE%80%E4%BB%8B-%E4%BD%9C%E8%80%85/>简介-作者</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/>经典语录</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC1%E7%AB%A0-%E7%AC%AC5%E7%AB%A0/>第1章-第5章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC11%E7%AB%A0-%E7%AC%AC15%E7%AB%A0/>第11章-第15章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC16%E7%AB%A0-%E7%AC%AC20%E7%AB%A0/>第16章-第20章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC6%E7%AB%A0-%E7%AC%AC10%E7%AB%A0/>第6章-第10章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC21%E7%AB%A0-%E7%AC%AC25%E7%AB%A0/>第21章-第25章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/%E7%AC%AC26%E7%AB%A0-%E7%AC%AC29%E7%AB%A0/>第26章-第29章</a></li></ul></li><li><input type=checkbox id=section-ab50087f003d55e32dba86fb838050b9 class=toggle>
<label for=section-ab50087f003d55e32dba86fb838050b9 class="flex justify-between"><a role=button>如何阅读一本书</a></label><ul><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E9%99%84%E5%BD%95/>附录</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AE%80%E4%BB%8B-%E5%BA%8F%E8%A8%80/>简介-序言</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%B8%80%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E5%B1%82%E6%AC%A1/>第一篇 阅读的层次</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E5%9B%9B%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E6%9C%80%E7%BB%88%E7%9B%AE%E6%A0%87/>第四篇 阅读的最终目标</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%B8%89%E7%AF%87_%E9%98%85%E8%AF%BB%E4%B8%8D%E5%90%8C%E8%AF%BB%E7%89%A9%E7%9A%84%E6%96%B9%E6%B3%95/>第三篇 阅读不同读物的方法</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E7%AC%AC%E4%BA%8C%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1_%E5%88%86%E6%9E%90%E9%98%85%E8%AF%BB/>第二篇 阅读的第三个层次：分析阅读</a></li></ul></li><li><input type=checkbox id=section-3c72e7201480f45e35bf243c48374c4a class=toggle>
<label for=section-3c72e7201480f45e35bf243c48374c4a class="flex justify-between"><a role=button>古代天文历法讲座</a></label><ul><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E9%99%84%E5%BD%95-%E9%99%84%E8%A1%A8-%E5%90%8E%E8%AE%B0/>附录-附表-后记</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC6%E8%AE%B2-%E7%AC%AC7%E8%AE%B2/>第6讲-第7讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC4%E8%AE%B2-%E7%AC%AC5%E8%AE%B2/>第4讲-第5讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%AC%AC1%E8%AE%B2-%E7%AC%AC3%E8%AE%B2/>第1讲-第3讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/%E7%89%88%E6%9D%83-%E5%BA%8F-%E5%89%8D%E8%A8%80/>版权-序-前言</a></li></ul></li><li><input type=checkbox id=section-9d5fdf0456d3af9d5079c94a509d2900 class=toggle>
<label for=section-9d5fdf0456d3af9d5079c94a509d2900 class="flex justify-between"><a role=button>置身事内</a></label><ul><li><a href=/zh/docs/culture/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/%E4%B8%8B%E7%AF%87/>下篇</a></li><li><a href=/zh/docs/culture/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/%E4%B8%8A%E7%AF%87/>上篇</a></li></ul></li><li><input type=checkbox id=section-2968790b5f933a15ae8f870afe7ff8b9 class=toggle>
<label for=section-2968790b5f933a15ae8f870afe7ff8b9 class="flex justify-between"><a role=button>中国通史(吕思勉)</a></label><ul><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8B%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%96%87%E5%8C%96%E5%8F%B2/>下编-中国文化史</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8A%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%8F%B2/>上编-中国政治史</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83-%E8%AF%BB%E5%90%8E-%E8%87%AA%E5%BA%8F/>封面-版权-读后-自序</a></li></ul></li><li><input type=checkbox id=section-77e618b9fdc931e63e2343a70dbe6630 class=toggle>
<label for=section-77e618b9fdc931e63e2343a70dbe6630 class="flex justify-between"><a role=button>资治通鉴</a></label><ul><li><input type=checkbox id=section-196ebc38f91a63032ca3483e389aa4c5 class=toggle>
<label for=section-196ebc38f91a63032ca3483e389aa4c5 class="flex justify-between"><a role=button>周纪</a></label><ul><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/>基本知识</a></li><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/001%E5%91%A8%E7%BA%AA%E4%B8%80/>001周纪一</a></li></ul></li></ul></li><li><input type=checkbox id=section-5aa85019131e2605fa7465dc987f590d class=toggle>
<label for=section-5aa85019131e2605fa7465dc987f590d class="flex justify-between"><a role=button>增广贤文</a></label><ul></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/test/>测试</a><ul><li><a href=/zh/docs/test/test2/>test2</a></li><li><a href=/zh/docs/test/mytest/>test</a></li><li><a href=/zh/docs/test/hello2/>pdfTest</a></li></ul></li></ul><ul><li><a href=/zh/posts/>博客</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Index</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#12-1-基千进程的并发编程>12. 1 基千进程的并发编程</a></li><li><a href=#5-用信号量同步线程>5 用信号量同步线程</a></li></ul></li><li><a href=#ctfil>CTfil</a><ul><li></li></ul></li></ul></li><li><a href=#img01c11eb8a9ab4d7f84a33d5078a24e2bjpeg勹><img src=img/01c11eb8a9ab4d7f84a33d5078a24e2b.jpeg alt>勹"</a></li><li><a href=#勹->勹, ,</a><ul><li><ul><li></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><p>第 12 章</p><p>C H A P T E R 12 . . . _</p><p>并发编程</p><p>正如我们在第 8 章学到的 ， 如果逻辑控制流在时间上重叠， 那么它们就是并发的 ( concu rr e nt ) 。这种常见的现象称为并发 ( co nc urr e ncy ) , 出现在计算机系统的许多不同层面上。硬件 异常处理程序、进程和 L in ux 信号处理程序都是 大家很熟悉的例子。</p><p>到目前为止，我们主要将并发看做是一种操作系统内核用来运行多个应用程序的机 制。但是， 并发不仅仅局限 于内核。它也可以在应用程序中 扮演重要角色。例如，我 们已经看到 Linux 信号处理程序如何允许应用响应异步事件， 例如用户键入 C t rl + C , 或者程序访问虚拟内存的 一个未定义的区域。应用级并发在其他情况下 也是很有用的：</p><ul><li><p>访问慢速 1/0 设备。当一个应用正在等待来自慢速 1/ 0 设备（例如磁盘）的数据到达时，内 核会运行其他进程，使 CP U 保持繁忙。每个应用都可以按照类似的方式， 通过交替 执行 I/ 0 请求和其他有用的工作来利用并发。</p></li><li><p>与人交互。和计算机交互的人要求计算机有同时执行多个任务的能力。例如，他们 在打印一个文档时， 可能想要调整一个窗口的大小。现代视窗系统利用并发来提供这种能力。每次用户请求某种操作（比如通过单击鼠标）时， 一个独立的并发逻辑流被创建来执行这个操作。</p></li><li><p>通过推迟工作以降低延迟。有时，应用程序能够通过推迟其他操作和并发地执行它 们， 利用并发来降低某些操作的延 迟。比如， 一个动态内存分配器可以通过推迟合并， 把它放到一个运行在较低优先级上的 并发“合并“ 流中， 在有空闲的 CP U 周期时充分利用这些空闲周期，从 而降低单个 fr e e 操作的延迟。</p></li><li><p>服务多个网 络客户端。 我们在第 11 章中学习的迭代网络服务器是不现实的， 因为它们一次只能为一个客户端提供服务。因此， 一个慢速的客户端可能会导致服务 器拒绝为所有其他客户端服务。对千一个真正的服务器来说，可能期望它每秒为成百上千的 客户端提供服务，由千一个慢速客户端导致拒绝为其他客户端服务，这是不能接受 的。一个更好的方法是创建一个并发服务器，它为每个客户端创建一个单独的逻辑 流。这就允许服务器同时为多个客户端服务 ， 并且也避免了慢速客户端独占 服务器。</p></li><li><p>在多核机器上进行并行计算。许多现代系统都配备多核处理器，多核处理器中包含 有多个 CP U。被划分成并发流的应用程序通常在多 核机器上比 在单处理器机器上运行得快， 因为这些流会并行执行， 而不是交错执行。</p><p>使用应用级并 发的应用程序称为并发程序 ( co nc ur re nt pro g ra m ) 。现代操作系统提供了三种基本的构造并发程序的方法：</p></li><li><p>进程。用这种方法 ，每 个逻辑控制流都是一个进程， 由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的进程间通信( in te r proces s communication, IPC) 机制。</p></li><li><p>I/ 0 多路 复用。 在这种形式的并发编程中 ， 应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程 序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程， 所以所有的流都共享同一个地址空间。</p></li><li><p>线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把 线程看成是其他两种方式的混合体， 像进程流一样由内核进行调度，而 像 1/0 多路复用流一样共享同一个虚拟地址空间。</p><p>本章研究这兰种不同的并发编程技术。为了使我们的讨论比较具体，我们始终以同一个应用为例一 11. 4. 9 节中的迭代 echo 服务器的并 发版本。</p></li></ul><h3 id=12-1-基千进程的并发编程>12. 1 基千进程的并发编程
<a class=anchor href=#12-1-%e5%9f%ba%e5%8d%83%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b>#</a></h3><p>构造并发程序 最简单的方法就是用进程，使 用 那些大家都很熟悉的函数， 像 f o r k、 e xe c 和 wa i t p 过 。 例如， 一个构造并发服务器的自然方法就是， 在父进程中接受 客户端连接请求，然后创建一个新的子进程来为每个新客户端提供服务。</p><p><img src=img/9170308c487c408d13c9c46ae317f052.jpeg alt>为了了解这是如何工作的，假设我们有两个客户端和一个服务器，服务器正在监听一 个监听描述符（比如指述符 3) 上的连接请求 。现在假设服务器接受了客户端 1 的连接请求， 并返回一个已连接描述符（比如指述符 4 ) , 如图 12-1 所示。在接受 连接请求之后，服务器派生一个子进程，这个子进程获得服务器描述符表的完整副本。子进程关闭它的副本中的 监听描述符 3&rsquo; 而父进程关闭 它的已连接描述符 4 的副本， 因为不再需要这些描述符了。这就得到了图 12- 2 中的状态， 其中子进程正 忙于为客户端提供服务。</p><p>三一＿一、一＿、归接请求</p><p>c l i e n t f d</p><p>三</p><p>clientfd</p><p>--、&ndash; listenfd(3) connfd(4)</p><p>clientfd</p><p>三cl i en 七 f d</p><p>listenfd(3)</p><p>图 1 2-1 第一步：服务器接受客户端的连接请求 图 12- 2 第二步：服务器派生一个子进程为这个客户端服务</p><p>因为父、子进程中的已连接描述符都指向同一个文件表表项，所以父进程关闭它的已连接描述符的副本是至关重要的。否则 ， 将永不会释放巳连接描述符 4 的文件表条目 ，而且由此引起的内存泄涌将最终消耗光可用的内存，使系统崩溃。</p><p>现在， 假设在父进程为客户端 1 创建了子进程之后，它 接受一个新的客 户端 2 的连接请求， 并返回一个新的已连接描述符（比如描述符 5) , 如图 12-3 所示。然后，父进程 又派生另一个子进程， 这个子进程用已连接描述符 5 为它的客户端提供服务， 如图 12-4 所示。此时， 父进程正在等待下一个连接请求，而两个子进程正在并发地为它们各自的客户端提供服务。</p><p><img src=img/02bf1a7b6a129ba2a14f87d07c45db69.jpeg alt><img src=img/8d9f6ad9c2fdeab53cf54bf088e69ec1.jpeg alt>clientfd listenfd(3)</p><p>clientfd</p><p>listenfd(3)</p><p>, &rsquo; connfd(5)</p><p><img src=img/789e9bd6017ef030322d7092ad261d55.jpeg alt>巨</p><p>图12-3 第三步：服务器接受另一个连接请求 图 12-4 第四步：服务器派生另一个子进程为新的客户端服务</p><ol><li><p>1. 1 基于进程的并发服务器</p><p>图12-5 展示了一个基千进程 的并发 ech o 服务器的代码。第 29 行调用的 e c h o 函数来自于图 1 1- 21。关于这个服务器 ， 有几点重要内容需要说明：</p><ul><li>首先， 通常服务器会运行很长的时间， 所以我们必须 要包括一个 S IG C H L D 处理程序， 来回收僵死( zo m bie ) 子进程的 资 源（第4 9 行）。因为当 S IG C H L D 处理程序执行时， S IG C H LD 信号 是阻塞的， 而 L in u x 信号是不排队的， 所以 SIGC H LD 处理程序必须准备好回收多个僵死子进程的资源。</li></ul></li></ol><ul><li>其次， 父子进程必须关闭 它们各自的 c o n n f d ( 分别为第 33 行和第 30 行）副本。就像我们已经提到过的，这对父进程而言尤为重要，它必须关闭它的已连接描述符， 以避免内存泄漏。</li><li>最后， 因为套接字的文件表表项中的引用计数， 直到父子进程的 c o n n f d 都关闭了， 到客户端的连接才会终止。</li></ul><p>code/condechoserverp.c</p><ol><li><p>#include &ldquo;csapp.h&rdquo;</p></li><li><p>void echo(int connfd);</p><p>3</p><p>4 void sigchld_handler(int sig)</p><p>5 {</p><p>6 while (waitpid(-1, 0, WNOHANG) > 0)</p><p>7</p><p>8 return;</p><p>9 }</p><p>10</p><p>11 int main(int argc, char **argv)</p><p>12 {</p><p>13 int listenfd, connfd;</p><p>14 socklen_t clientlen;</p></li><li><p>struct sockaddr_storage clientaddr;</p><p>16</p></li><li><p>7 if (argc != 2) {</p></li><li><p>fprintf(stderr, &ldquo;usage: %s &lt;port>\n&rdquo;, argv[O]);</p></li><li><p>exit (0);</p><p>20 }</p><p>21</p></li><li><p>Signal(SIGCHLD, sigchld_handler);</p></li><li><p>listenfd = Open_listenfd (argv [1]) ;</p><p>24 while (1) {</p></li><li><p>clientlen = sizeof(struct sockaddr_storage);</p></li><li><p>connfd = Accept (listenfd, (SA *) &amp;clientaddr, &amp;clientlen) ;</p><p>27 if (Fork() == 0) {</p></li></ol><p>28</p><p>29</p><p>30</p><p>31</p><p>32 }</p><p>Close(listenfd) ; echo(connfd); Close(connfd); exit(O);</p><p>I* Child closes its listening socket *I I* Child services client *I</p><p>I* Child closes connection with client *I I* Child exits *I</p><p>33 Close(connfd); I* Parent closes connected socket (important!) *I</p><p>34 }</p><p>35 }</p><p>code/condechoserverp.c</p><p>图 12-5 基于进程的并发 echo 服务器 。父进程 派生一个 子进程来 处理每个新的 连接请求</p><p>12 . 1. 2 进程的优劣</p><p>对于在父、子进程间共享状态信息，进程有一个非常清晰的模型：共享文件表，但是不共享用户地址空间。进程有独立的地址空间既是优点也是缺点。这样一来， 一个进程不可能不小心覆盖另一个进程的虚拟内存，这就消除了许多令人迷惑的错误—— 这是一个明显的优点。</p><p>另一方面，独立的地址空间使得进程共享状态信息变得更加困难。为了共享信息，它 们必须使用显式的 IPC C进程间通信）机制。（参见下面的 旁注。）基于进程的设计的另一个缺点是， 它们往往比较慢， 因为进程控制 和 IPC 的开销很高。</p><p>日日Unix IPC</p><p>在本 书中 ， 你已经遇到 好几个 IPC 的例子了。 笫 8 章中的 wa i t p i d 函数和信号是基本的 IPC 机制， 它们 允许进程发 送小消息 到 同一主机 上的 其他进程。笫 11 章的套接宇接口是 IPC 的一种重要 形式， 它允许 不同主机 上的进程交换任 意的 字 节流。 然而，术语 U n ix IPC 通常指的是所有 允许进程和 同一台主机上其他 进程进行 通信的 技术。其中包括管道、先进先出( FIF O) 、 系统 V 共享内存， 以及 系统 V 信号量( s e m a p h o r e ) 。这些机 制超 出了我 们的讨论范围。 K e r r is k 的著作[ 62] 是很 好的参考资料。</p><p>凶 练习题 12. 1 在图 1 2-5 中， 并发 服 务器的 第 33 行上， 父 进 程 关 闭 了 巳连 接 描述符后， 子进 程仍 然能够使 用该 描述 符和 客户端 通信。 为 什么？</p><p>练习题 12. 2 如果 我们 要 删除 图 1 2-5 中关 闭 巳连 接描述 符的 第 30 行，从 没有内存泄漏的角度来说，代码将仍然是正确的。为什么？</p><ol><li><p>2 基千 1/ 0 多路复用的并发编程</p><p>假设要求你编写一个 e ch o 服务器，它 也 能对用户从标准输入键入的交互命令做出响应。在这种情况下 ， 服务器必须响应 两个互相独立的 I/ 0 事件： 1) 网络客户端发 起连接请求， 2 ) 用 户在键盘上 键人命令行。我们先 等待哪个事件呢？ 没有哪个选择是理想的。如果在 a c c e p t 中等待一个连接请求， 我们就不能响应输入的命令。类似地， 如果在r e a d 中等待一个输入命令，我们就不能响应任何连接请求。</p><p>针对这种困 境的一个解决 办法就是 1/ 0 多路复用 CI/ 0 m u lt ip le x in g ) 技术。基本的思路就 是使用 s e l e c t 函数， 要求内核挂起进程，只 有在一个或多个 I/ 0 事件发生后，才将控制返回给应用程序，就像在下面的示例中一样：</p><ul><li>当集合{O, 4}中任意描述符准备好读时返回。<ul><li><p>当集合 { 1, 2 , 7}中任意描述符准备好写时返回。</p></li><li><p>如果在等待一个 I/ 0 事件发生时过了 152. 13 秒， 就超时。</p><p>s e l e c 七是一个复杂的 函数， 有许多不同的使用场景。我们将只讨论第一种场景： 等待一组描述符准备好读。全面的讨论请参考[ 62, 110] 。</p></li></ul></li></ul></li></ol><p>#include &lt;sys/select.h></p><p>int select(int n, fd_set *fdset, NULL, NULL, NULL);</p><p>返回已准备 好的描述符的 非零的个数 ， 若出错 则 为一 1。</p><p>FD_ZERO(fd_set *fdset); FD_CLR(int fd, fd_set *fdset); FD_SET(int fd, fd_set *fdset); FD_ISSET(int fd, fd_set *fdset);</p><p>I* Clear all bits in fdset *I I* Clear bit fd in fdset *I I* Turn on bit fd in fdset *I</p><p>/* Is bit fd in fdset on? *I</p><p>处理 描述符 集合的 宏。</p><p>s e l e c t 函数处理类型为 f d _s e t 的集合，也 叫做描述符集合 。逻辑上， 我们将描述符集合看成一个大小为 n 的位向量（在2. 1 节中介绍过）：</p><p>b,,_1 , &mldr; , b1 , b。</p><p>每个位 从对应于描述符 k 。当且仅当从 = l , 描述符 k 才表明是 描述符集合的一个元素。只允许你对描述符集合做三件事： 1 ) 分配它们， 2 ) 将一个此种类型的变量赋值给另一个变量， 3 ) 用 F D_ ZERO、F D_S ET 、FD_CLR 和 F D_ISS ET 宏来修改 和检查它们。</p><p>针对我们的 目的， s e l e c t 函数有两个输入： 一个称为读 集合 的描述符集合( f d s e t ) 和该读集合的基数( n ) ( 实际上是任何描述符集合的最大基数）。s e l e c t 函数会一直阻塞， 直到读集合中至少有一个 描述符准备好可以读 。当且仅当一个从该描述符读取一个字节的请求不会阻塞时， 描述符 k 就表示准备 好可以 读了。s e l e c t 有一个副作用， 它修改参数f d s e t 指向的 f d _ s e t , 指明读集合的一个子集，称 为准备 好集合 ( read y set) , 这个集合是由读集合中准备好可以 读了的描述符组成的。该函数返回的值指明了准备好集合的基 数。注意， 由于这个副作用， 我们必 须在每次调用 s e l e c t 时都更新读集合。</p><p>理解 s e l e c t 的最好办法是研究一个具体例子。图 12-6 展示了可以如何利用 s e l e c t 来实现一个迭代 echo 服务器， 它也可以接受标准输入上的用户命令。一开始， 我们用图 11-1 9 中的 op e n_止 s t e n f d 函数打开一个监听描述符（第1 6 行）， 然后使用 F D_ ZE RO 创建一个空的读集合（第18 行）：</p><p>listenfd</p><p>3 2</p><p>read_set (0) : 曰</p><p>stdin</p><p>1 0</p><p>二</p><p>接下来， 在第 19 和 20 行中， 我们定义由描述符 0 ( 标准输入）和描述符 3 ( 监听描述符）组成的读集合：</p><p>listenfd stdin</p><p>3 2 1 0</p><p>read_set ({O, 3)) : I 1 I 1 I 1 I</p><p>在这里， 我们开始典 型的服务器循环 。但是我们不调用 a c c e p七函数来等待一个连接请求，而 是调用 s e l e 吐 函数， 这个函数会一直阻塞， 直到监听描述符或者标准输入准备好可以读（第24 行）。例如，下 面是 当用户按回车键， 因此使得标准输入描述符变为可读时， s e l e c t 会返回的r e a d y_ s 包 的值：</p><p>listenfd stdin</p><p>3 2 1 0</p><p>ready_set ({O}): I 1 1 I 1 I</p><p>一旦 s e l e c t 返回， 我们就用 F D _ ISSET 宏指令来确定哪个描述符 准备好可以读了。如果是标准输入准备好了（第25 行）， 我们就调用 c omma nd 函数，该 函数在返回到主程序前， 会读、解析和响应命令。如果是监听描述符准备好了（第27 行）， 我们就调用 a c c e p t 来得到一个已 连接描述符 ， 然后调用图 11-22 中的 e c ho 函数， 它会将来自客户端的每一行又回送回去， 直到客户端关闭 这个连接中它的那一端。</p><p>虽然这个程序是使用 s e l e c t 的一个很好示例，但 是它仍然留下了一些问题待解决。问题是一旦它连接到某个客户端，就会连续回送输入行，直到客户端关闭这个连接中它的那一 端。因此，如果键入一个命令到标准输人，你将不会得到响应，直到服务器和客户端之间结</p><p>束。一个更好的方法是更细粒度的多路复用，服务器每次循环（至多）回送一个文本行。</p><p>code/co nd se lect. c</p><p>#include &ldquo;csapp.h&rdquo;</p><ol><li><p>void echo(int connfd);</p></li><li><p>void command(void);</p><p>4</p><p>5 int main(int argc, char **argv)</p><p>6 {</p></li><li><p>int listenfd, connfd;</p></li><li><p>socklen_t clientlen;</p></li><li><p>struct sockaddr_storage clientaddr;</p></li><li><p>fd_set read_set, ready_set;</p><p>11</p></li><li><p>if (argc != 2) {</p></li><li><p>fprintf(stderr, &ldquo;usage: %s &lt;port>\n&rdquo;, argv[O));</p></li><li><p>exit(O);</p><p>15 }</p><p>16 listenfd = Open_listenfd(argv[1]); 17</p></li><li><p>FD_ZERO(&amp;read_set); I* Clear read set *I</p></li><li><p>FD_SET(STDIN_FILENO, &amp;read_set); I* Add stdin to read set *I</p></li><li><p>FD_SET(listenfd, &amp;read_set); I* Add listenfd to read set *I 21</p></li><li><p>while (1) {</p></li><li><p>ready_set = read_set;</p></li><li><p>Select(listenfd+1, &amp;ready_set, NULL, NULL, NULL);</p></li><li><p>if (FD_ISSET(STDIN_FILENO, &amp;ready_set))</p></li><li><p>command(); I* Read command line from stdin *I</p></li><li><p>if (FD_ISSET(listenfd, &amp;ready_set)) {</p></li></ol><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33 }</p><p>34 }</p><p>35</p><p>clientlen = sizeof(struct sockaddr_storage);</p><p>connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); echo(connfd); I* Echo client input until EDF *I Close(connfd);</p><ol><li>void command(void) {</li><li>char buf[MAXLINE];</li><li>if (! Fgets (buf , MAXLINE, st din))</li><li>exit(O); I* EOF *I</li><li>printf("%s", buf); I* Process the input command *I 41 }</li></ol><p>codelcondselect.c</p><p>图 12-6 使用 1/ 0 多路复用的 迭代 echo 服务器。服务器使用 s e l e c t</p><p>等待监听描述符上的连接请求和标准输人上的命令</p><p>沁目 练习题 12. 3 在 L i n u x 系统 里，在标 准输入 上键入 C t rl + D 表 示 EOF 。 图 12-6 中的程序阻塞在 对 s e l e c t 的调 用上 时，如果 你键 入 C t rl + D 会发 生什 么？</p><p>12. 2. 1 基千 1/ 0 多 路 复用的并发事件驱动服务器</p><p>I / 0 多路复用可以用做并发事件 驱动( e ve n t- d r ive n ) 程序的基础， 在事件驱动程序中， 某些事件会导致流向前推进。一般的思路是将逻辑流模型化为状态机。不严格地说，一个</p><p><img src=img/3e5d2873e9e2555edbdaa046e638c91e.jpeg alt>状态机 ( s t a t e m a c h in e ) 就是一组状 态 ( s t a t e ) 、输 入事件 ( in p u t e ve n t ) 和转移 ( t ra n s it io n ) , 其中转移是将状态和输入事件映射到状态。每个转移是将一 个（输入状态， 输入事件）对映射到一个输出状态。自循环 ( s e lf - lo o p ) 是同一输入和输出状态之间的转移。通常把状态机画成有向图，其中节点表示状态，有向弧表示转移，而弧上的标号表示输入事件。一个状 态机从某种初始状态开始执行。每个输入事件都会引发一个从当前状态到下一状态的 转移。</p><p>对于每个新的 客户端 k , 基于 1/ 0 多路复用的 并发服务器会创建一个新的状态机</p><p>Sk&rsquo; 并将它和巳连接描述符d k 联系起来。如图 12-7 所示， 每个状态机 Sk 都有一个状态( &ldquo;等待描述符 d k 准备好可读&rdquo;)、一 个输入事件（＂描述符 d k 准备好 可以读了")和一个转移</p><p>（“从描述符 d k 读一个文本行")。 图 12- 7 并发事件驱动echo 服务器中逻辑流的状态机</p><p>服务器使用 1/ 0 多路复用 ， 借助 s e l e c t 函数检测输入事件的发生。当每个已连接描述符准备好可读时，服务器就为相应的状态机执行转移，在这里就是从描述符读和写回一 个文本行。</p><p>图 1 2-8 展示了一个基于 1/ 0 多路复用的并发事件驱动服务器的完整示 例代码。一个</p><p>p o o l 结构里维护着活动客户端的集合（第3 11 行）。在调用 i n i t _ p o o l 初始化 池（第27 行）之后， 服务器进入一个无限循环。在 循环的 每次 迭代中， 服务器调用 s e l e c t 函数来检测两种不同类型的输入事件： a ) 来自一个新客户端的连接请 求到达， b ) 一个已存在的客户端的已连接描述符准 备好可以 读了。当一个连接请求到达时（第35 行）， 服务器打开连接（第37 行）， 并调用 a d d _ c l i e n t 函数， 将该客户端添加到池里（第38 行）。最后， 服务器调用 c h e c k_ c l i e n t s 函数， 把来自每个 准备好的已连接描述符 的一个文本行回送回去</p><p>（第 42 行）。</p><p>code/condechoservers.c</p><p>1 #include &ldquo;csapp.h&rdquo;</p><ol><li><p>typedef struct { /• Represents a pool of connected descriptors•/</p></li><li><p>int maxfd; I• Largest descriptor in read_set•I</p></li><li><p>fd_set read_set; I• Set of all active descriptors•I</p></li><li><p>fd_set ready_set; I• Subset of descriptors ready for reading•/</p></li><li><p>int nready; /• Number of ready descriptors from select•I</p></li><li><p>int maxi; /• High water index into client array•/</p></li><li><p>int clientfd [FD_SETSIZE) ; /• Set of active descriptors•/</p></li><li><p>rio_t clientrio[FD_SETSIZE); I* Set of active read buffers•/</p></li><li><p>} pool;</p><p>12</p><p>13 int byte_cnt = 0; I* Counts total bytes received by server•/</p><p>14</p><p>15 int main(int argc, char **argv)</p><p>16 {</p></li><li><p>int listenfd, connfd;</p></li><li><p>socklen_t clientlen;</p></li><li><p>struct sockaddr_storage clientaddr;</p></li></ol><p>图12-8 基 于 I/ 0 多路复用的并发 echo 服务器。每次服务器迭代都回送来自每个准备好的描述符的文本行</p><ol start=4><li><p>static pool pool; 21</p></li><li><p>if (argc != 2) {</p></li><li><p>fprintf(stderr, &ldquo;usage: %s &lt;port>\n&rdquo;, argv[O]);</p></li><li><p>exit(O);</p><p>25 ｝</p></li><li><p>listenfd = Open_listenfd(argv[1]);</p></li><li><p>init_pool(listenfd, &amp;pool); 28</p></li><li><p>while (1) {</p></li><li><p>I* Wait for listening/connected descriptor(s) to become ready *I</p></li><li><p>poolr. eady_s et = pool.read_set;</p></li></ol><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44 ｝</p><p>pool.nready = Select(pool.maxfd+l, &amp;pool.ready_set, NULL, NULL, NULL);</p><p>I* If 让 s t eni ng descriptor ready, add new client to pool *I if (FD_ISSET (listenfd, &amp;pool. ready_set)) {</p><p>clientlen = sizeof(struct sockaddr_storage);</p><p>connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen); add_client(connfd, &amp;pool);</p><p>｝</p><p>I* Echo a text line from each ready connected descriptor *I check_clients(&amp;pool);</p><p>codelcondechoservers.c</p><p>图 12-8 ( 续 ）</p><p>i n it _p o o l 函数（图1 2- 9 ) 初始化客户端池。 c l i e n t f d 数组表示已连接描述符的集合， 其中整数—1 表示一个可用的 槽位。初始时，已 连接描述符集合是空的（第5 ~ 7 行），而且监听描 述符是 s e l e c t 读集合中唯 一的描述符（第1 0 ~ 1 2 行）。</p><p>cod e/cond echoservers .c</p><p>void init_pool(int listenfd, pool *p)</p><p>3 I* Initially, there are no connected descriptors *I inti;</p><p>p->maxi = -1;</p><p>6 for (i=O; i&lt; FD_SETSIZE; i++)</p><p>p->clientfd[i] = -1;</p><p>8</p><ol><li><p>I* Initially, listenfd is only member of select read set *I</p></li><li><p>p->maxfd = listenfd;</p></li><li><p>FD_ZERO(&amp;p->read_set);</p></li><li><p>FD_SET(listenfd, &amp;p->read_set);</p><p>13 }</p></li></ol><p>code/co nd echoservers .c</p><p>图 12-9 init pool 初 始 化 活动客户端池</p><p>a d d _ c li e n t 函数（图1 2- 1 0 ) 添加一个新的客户端到活动客户端池中。在 c li e n tf d 数组中找到一个空槽位后，服务器将这个巳连接描述符添加到数组中，并初始化相应的 R I O 读缓冲区 ， 这样一 来我们就能够对这个描述符调用r i o _ r e a d l i n e b ( 第 8 ~ 9 行）。然</p><p>后， 我们将 这个已连接描述符添加到 s e l e c t 读集合（第12 行）， 并更新该池的一些全局属性。ma x f d 变量（第15 16 行）记录了 s e l e 立 的最大文件描述符。ma x i 变量（第17 18 行）记录的是 到 c l i e n t f d 数组的最大索引， 这样 c h e c k_ c l i e n t s 函数就无需搜索整个数组了。</p><p>code/condechoservers.c</p><p>1 void add_client(int connfd, pool *p)</p><p>2 {</p><p>3 inti;</p><p>4 p->nready&ndash;;</p><p>s for (i = O; i &lt; FD_SETSIZE; i++) I* Find an available slot *I</p><p>6 if (p->clientfd[i] &lt; 0) {</p><p>7 I* Add connected descriptor to the pool *I</p><p>8 p->clientfd[i] = connfd;</p><p>9 Rio_readinitb(&amp;p->clientrio[i], connfd);</p><p>10</p><p>11 I* Add the descriptor to descriptor set *I</p><p>12 FD_SET(connfd, &amp;p->read_set);</p><p>13</p><ol><li><p>I* Update max descriptor and pool high water mark *I</p></li><li><p>if (connfd > p->maxfd)</p></li><li><p>p->maxfd = connfd;</p></li><li><p>if (i > p->maxi)</p></li><li><p>p->maxi = i;</p></li><li><p>break;</p><p>20 }</p></li><li><p>if (i == FD_SETSIZE) / * Couldn&rsquo;t find an empty slot *I</p></li><li><p>app_error(&ldquo;add_client error: Toomany clients&rdquo;);</p><p>23 }</p><p>code/condechoservers.c</p></li></ol><p>图 1 2-10 add_c l i e nt 向池中添加一个新的客户端连接</p><p>图 12-11 中的 c he c k_ c l i e n t s 函数回送来自每个 准备好的已连接描述符的一个文本行。如果成功地从描述符读取了一个文本行， 那么就将该文本行回送到客户端（第15 18 行）。注意，在 第 15 行我们维护着一个从所有客户端接收到的 全部字节的 累计值。如果因为客户端关闭这个连接中它的那一端， 检测到 EOF , 那么将关闭这边的连接端（第23 行）， 并 从池中清除掉这个描述符（第24 25 行）。</p><p>根据图 1 2- 7 中的有限状态模型， s e l e c t 函数检测到输入事件， 而 a d d _ c l i e 吐 函数创建一个新 的逻辑流（状态机）。c h e c k _ c l i e n t s 函数回送输入行，从 而执行状态转移， 而且当客户端完成文本行发送时，它还要删除这个状态机。</p><p>沁囡 练习题 12 . 4 图 1 2-8 所 示的 服 务器中， 我们 在每次调 用 s e l e 立 之前都 立 即小心地重新初 始化 p o o l .r e a d y_ s e t 变量。 为什 么？</p><p>豆 日 事件驱 动的 We b 服务器</p><p>尽管有 12. 2. 2 节中说 明的缺点， 现代高性能服务器（ 例如 N od e. js 、ng in x 和 T or­ na do ) 使用的都是 基于 1/ 0 多路 复用的 事件 驱动的 编程 方式 ， 主要是因为相 比于进程和线程的 方式 ， 它有明 显的性能优势。</p><p>code/condechoservers. c</p><p>void check_clients(pool *p)</p><p>2 {</p><p>3 inti, connfd, n;</p><p>4 char buf[MAXLINE];</p><p>5 rio_t rio;</p><p>6</p><p>7 for (i = O; (i &lt;= p->maxi) && (p->nready > 0); i++) {</p><p>8 connfd = p->clientfd [i] ;</p><p>9 rio = p->clientrio[i];</p><p>10</p><p>11 /* If the descriptor is ready, echo a text line from it *I</p><p>12 if ((connfd > 0) && (FD_ISSET(connfd, &amp;p->ready_set))) {</p><p>13 p->nready&ndash;;</p><ol><li><p>if ((n = Rio_readlineb (&amp;rio, buf, MAXLINE)) ! = 0) {</p></li><li><p>byte_cnt += n;</p></li><li><p>printf(&ldquo;Server received %d (%d total) bytes on fd %d\n&rdquo;,</p></li><li><p>n, byte_cnt, connfd);</p><p>18 Rio_writen(connfd, buf, n);</p><p>19 ｝</p><p>20</p><p>21 I* EDF detected, remove descriptor from pool *I</p><p>22 else {</p></li><li><p>Close(connfd);</p></li><li><p>FD_CLR(connfd, &amp;p->read_set);</p></li><li><p>p->clientfd [i] = -1;</p><p>26 }</p><p>27 }</p><p>28 }</p><p>29 }</p></li></ol><p>code/condechoservers.c</p><p>图 12-11 check cl i ent s 服务准备好的 客户 端连接</p><p>12. 2. 2 1/ 0 多 路 复用技术的优劣</p><p>图 12-8 中的服务器提供了一个 很好的基于 I/ 0 多路复用的事件驱动编程的优缺点示例。事件驱动设计的一个优点是，它比基千进程的设计给了程序员更多的对程序行为的控制。例如，我们可以设想编写一个事件驱动的并发服务器，为某些客户端提供它们需要的服务，而这对于基于进程的并发服务器来说，是很困难的。</p><p>另一个优点是， 一个基千 I/ 0 多路复用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部地址空间。这使得在流之间共享数据变得很容 易。一个与作为单 个进程运行相关的优点是， 你可以利用熟悉的调试工具， 例如 GDB, 来调试你的并发服务器，就像对顺序程序那样。最后，事件驱动设计常常比基于进程的设 计要高效得多，因为它们不需要进程上下文切换来调度新的流。</p><p>事件驱动设计一个明显的 缺点就是编码复杂。我们的事件驱动的并 发 echo 服务器需要的代码比基于进程的服务器多三倍，并且很不幸，随着并发粒度的减小，复杂性还会上升。这 里的粒度是指每个逻辑流每个时间片执行的指令数量。例如，在示例并发服务器中，并发粒 度就是读一个完整的文本行所需要的指令数 量。只要某个逻辑流正忙于读一个文本行， 其他逻辑流就不可能有进展 。对我们的例子来说这没有问题， 但是它使得在“故意只发送部分文</p><p>本行然后就停止＂的恶意客户端的攻击面前，我们的事件驱动服务器显得很脆弱。修改事件 驱动服务器来处理部分文本行不是一个简单的任务，但是基千进程的设计却能处理得很好， 而且是自动处理的。基于事件的设计另一个重要的缺点是它们不能充分利用多核处理器。</p><p>12. 3 基于线程的并发编程</p><p>到目前为止，我们已经看到了两种创建并发逻辑流的方法。在第一种方法中，我们为 每个流使用了单独的进程。内核会自动调度每个进程，而每个进程有它自己的私有地址空 间，这 使得流共享数据很困难。在第二种方法中， 我们 创建自己的逻辑流， 并利用 I/ 0 多路复用来显式地调度流。因为只有一个进程，所有的流共享整个地址空间。本节介绍第三 种方法 基千线程，它是这两种方法的混合。</p><p>线程 ( t hread ) 就是运行在进程上下 文中的逻辑流。在本书里迄今为止， 程序都是由每个进程中一个线程组成的。但是现代系统也允许我们编写一个进程里同时运行多个线程的程序。线 程由内核自动调度。每个线程都有它自己的 线程上 下文( t h read context), 包括一个唯一的整数线程 ID ( T hread ID, T ID) 、栈、栈指针、程序 计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。</p><p>基千线程的逻辑流结合 了基于进程 和基于 I/ 0 多路复用的流的特性。同进程一样， 线程由内核 自动调度 ，并且内核通过一个 整数 ID 来识别线程。同 基于 I/ 0 多路复用的流一样，多个线程运行在单一进程的上下文中，因此共享这个进程虚拟地址空间的所有内容， 包括它的代码、数据、堆、共享库和打开的文件。</p><p>12. 3. 1 线程执行模型</p><p>多线程的执行模型在某些方面和多进程的执行模型是相似的。思考图 12-12 中的示例。每个进程开始生命周期时都是单一线程， 这个线程称为主线程 ( main t hread ) 。在某一时刻，主线程创建一个对等线程(peer thread) , 从这个时间点开始，两个线程就并发地运行。最后，因为主线程执行一个 慢 速 系 统 调 用， 例 如 r e a d 或 者</p><p>sleep, 或者因为被系统的间隔计时器中断，控制就会通过上下文切换传递到对等</p><p>时间</p><p>线程1 线程2</p><p>（对等线程）</p><p>－－－－－－－－－－－－－－－－－－－－－－－－－－－</p><p>…- - &mdash;&mdash;- &ndash; &mdash;-r&mdash;&mdash;&ndash; }线程上下文切换</p><p>:：：:：：：一二：二勹｝线程上下文切换二：：三二：：｝线程上下文切换</p><p>图12-12 并发线程执行</p><p>线程。对等线程会执行一段时间，然后控制传递回主线程，依次类推。</p><p>在一些重要的方面，线程执行是不同于进程的。因为一个线程的上下文要比一个进程的上下文小得多，线程的上下文切换要比进程的上下文切换快得多。另一个不同就是线程不像进程那样，不是按照严格的父子层次来组织的。和一个进程相关的线程组成一个对等</p><p>（线程）池，独立于其他线程创建的线程。主线程和其他线程的区别仅在于它总是进程中第 一个运行的线程。对等（线程）池概念的主要影响是，一个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止。另外，每个对等线程都能读写相同的共享数据。</p><ol><li><p>3 . 2 Pos ix 线程</p><p>Posix 线程( P t hreads ) 是在 C 程序中处理线程的一个标准接口。它最早出现在 1995</p></li></ol><p>年， 而且在所有的 L in u x 系统上都 可用。P t h r ea d s 定义了大约 60 个函数，允 许程序创建、杀死和回收线程，与对等线程安全地共享数据，还可以通知对等线程系统状态的变化。</p><p>图 12-13 展示了一个简单的 P t h rea ds 程序。主线程创建一个 对等线程， 然后等待它的终止。对等线程输出 " He l l o , world! \ n" 并且终止。当主线 程检测到对等线 程终止后， 它就通过调用 e x i t 终止该进程。这是我们看到的第一个线程化的程序， 所以让我们仔细地解析它。线程的代码和本地数据被封装在一个线程例 程( t h r ead ro u t in e) 中。正如第二行里的原型所示，每个线程例程都以一个通用指针作为输入，并返回一个通用指针。如果想 传递多个参数给线程例程，那么你应该将参数放到一个结构中，并传递一个指向该结构的 指针。相似地，如果想要线程例程返回多个参数，你可以返回一个指向一个结构的指针。</p><p>code/cone/hello.c</p><p>#include &ldquo;csapp.h&rdquo;</p><p>2 void *thread(void *vargp);</p><p>3</p><p>4 int main()</p><p>5 {</p><p>6 pthread_t tid;</p><p>7 Pthread_create(&amp;tid, NULL, thread, NULL);</p><p>8 Pthread_join(tid, NULL);</p><p>9 exit(O);</p><p>10 }</p><p>11</p><p>12 void *thread(void *vargp) I* Thread routine *I</p><p>13 {</p><p>14 printf(&ldquo;Hello, world!\n&rdquo;);</p><p>15 return NULL;</p><p>16 }</p><p>codelcondhello.c</p><p>图 1 2- 1 3 hello.c: 使用 Pthreads 的 " Hello , world!" 程序</p><p>第 4 行标出了主线程代码的 开始。主线程声明了一个本地变僵 t 过， 可以用来存放对等线程的 ID( 第 6 行）。主线程通过调用 p t hr e a d _ cr e a 七e 函数创建一个新的对等线程（第</p><p>7 行）。当对 p t hr e a d _ c r e a t e 的调用返回时， 主线程和新创建的对等线程同时运行， 并且 t i d 包含新线程的 ID。通过在第 8 行调用 p t hr e a d _ j o i n , 主线程等待对等线程终止。最后， 主线程调用 e x 江（第9 行）， 终止当时运行在这个 进程中的所有线程（在这个示例中就只有主线程）。</p><p>第 12 ~ 1 6 行定义了对等线程的 例程。它只 打印一个字符串， 然后就通过执行第 15 行中的r e 七ur n 语句来终止对等线程 。</p><p>12. 3. 3 创建线程</p><p>线程通过调用 p t hr e a d _cr e a 七e 函数来创建其他线程。</p><p>#include &lt;pthread.h></p><p>typedef void *(func) (void *);</p><p>int pthread_create(pthread_t *tid, pthread_attr_t *attr,</p><p>func *f, void *arg);</p><p>若成功则返回 o, 若出错 则 为 非零。</p><p>p t hr e a d_ cr e a t e 函数创建一个新的线程， 并带着一个输入变量 ar g , 在新线程的上下文中运行线程例 程 f 。能用 a t 七r 参 数来改变新创建线程的 默认属性 。改变这些属性已超出我们 学习的范围， 在我们的示 例中，总 是用一个为 N U L L 的 a t tr 参数来调用p t h r e a d_ cr e a 七e 函数。</p><p>当 p t h r e a d _ cr e a t e 返回时 ， 参数 t i d 包含新创建线程的 ID 。新线程可以通过调用</p><p>p t hr e a d_ s e l f 函数来获得它自己的线 程 ID。</p><p>#include &lt;pthread.h></p><p>pthread_t pthread_self(void);</p><p>返回调用 者的 线 程 ID .</p><ol><li><p>3. 4 终止线程</p><p>一个线程是以下列方式之一来终止的：</p><ul><li>当顶层的线程例程返回时 ， 线程会隐式地终 止。<ul><li><p>通过调用 p 七hr e a d _ e x i t 函数， 线程会显 式地终 止。如果主线程调用 p t hr e a d _e x ­</p><p>l 七，它 会等待所有其他对等线程终止，然 后再终止主线程和整个进程， 返回值为</p><p>thread r et urn。</p></li></ul></li></ul></li></ol><p>#include &lt;pthread.h></p><p>void pthread_exit(void *thread_return);</p><p>从不返回。</p><ul><li>某个对等线程调用 Lin ux 的 e x i t 函数，该 函数终止进程以 及所有与该进程相关的线程。<ul><li>另一个对等线程 通过以 当前线程 ID 作为参数调用 p t h r e a d _ c a n c e l 函数来终止当前线程。</li></ul></li></ul><p>#include &lt;pthread.h></p><p>int pthread_cancel(pthread_t tid);</p><p>若成功则返回o , 若 出错 则 为 非零。</p><p>12. 3. 5 回收己终止线程的资源</p><p>线程通过 调用 p 七hr e a d _ j o i n 函数等待其他线程终止。</p><p>#include &lt;pthread.h></p><p>int pthread_join(pthread_t tid, void **thread_return);</p><p>若成功则返 回 o, 若出错则为非零。</p><p>p t hr e a d_ j o i n 函数会阻塞， 直到线程 t i d 终止， 将线程例程返回的通用( v o i d * ) 指针赋值为 t h r e a d _r e t ur n 指向的位置， 然后回收己终 止线程占用的所有内存资源。</p><p>注意 ， 和 L in u x 的 wa i t 函数不同， p t hr e a d _ j o i n 函数只能等待一个指定的线程终止。没有办法让 p t hr e a d _ wa i t 等待任意一个线程终 止。这使得代码更加复杂， 因为它 迫</p><p>使我们去使用其他一些不那么直观的机制来检测进程的 终止。实际上， S t eve ns 在[ ll O] 中就很有说服力地论证了这是规范中的一个错误。</p><p>12. 3. 6 分离线程</p><p>在任何一个时间点上， 线程是可结合的 ( joina ble ) 或者是 分离的( detached ) 。一个可结合的线程能够被其他线程收回和杀死。在被其他线程回收之前 ， 它的内存资源（例如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终 止时由系统自动释放。</p><p>默认情况下 ，线 程被创建成可结合的。为了避免内存泄漏， 每个可结合线程都应该要</p><p>么被其 他线程显式 地收回， 要么通过调用 p t h r e a d_d e t a c h 函数被分离。</p><p>#include &lt;pthread.h></p><p>int pthread_detach(pthread_t tid);</p><p>若成功则返回 0 , 若 出错 则 为 非零。</p><p>p t hr e a d_d e t a c h 函数分离可结合线程 t 过。线程能够通过以 p t hr e a d_ s e l f ()为参数的 p t hr e a d _de t a c h 调用来分离它们自己。</p><p>尽管我们的一些例子会使用 可结合 线程，但 是在现实程序中，有 很好的理由要使用分</p><p>离的线程。例如， 一个高性能 W eb 服务器可能在每次收到 W e b 浏览器的连接请求 时都创建一个新的对等线程。因为每个连接都是由一个单独的线程独立处理的，所以对千服务器 而言，就很没有必要（实际上也不愿意）显式地等待每个对等线程终止。在这种情况下，每 个对等线程都应该在它开始处理请求之前分离它自身，这样就能在它终止后回收它的内存 资源了。</p><p>12. 3. 7 初始化线程</p><p>p t hr e a d_onc e 函数允许你初始化与线程例程相关的 状态。</p><p>#include &lt;pthread.h></p><p>pthread_once_t once_control = PTHREAD_ONCE_INIT; int pthread_once(pthread_once_t *once_control,</p><p>void (*init_routine)(void));</p><p>总是返回o.</p><p>o n c e _c o n tr o l 变量是一 个全局或者静态变量 ，总 是被初始化为 PT H READ_ONCE_ I NIT 。当你第一次用参数 on c e _ c o n tr o l 调用 p t hr e a d _ o nce 时， 它调用 m江 r ou­</p><p>tine, 这是一个没有输入参数 、也不返回什么的函数。接下来的以 o nc e _c on t r o l 五参数的 p t hr e a d _o nc e 调用不做任何事情。无论何时， 当你需要动态初始化多个线程共享的全局变量时， p t hr e a d _ o n c e 函数是很有用的。我们将在 1 2. 5. 5 节里看到一个示例。</p><p>12. 3. 8 基千线程的并发服务器</p><p>图 12-14 展示了基于线程的并发 echo 服务器的代码。整体结构类似于基于进程的设计。主线程不断地等待连接请求，然后创建一个对等线程处理该请求。虽然代码看似简</p><p>单， 但是有几个普遍而且有些 微妙的问题需要我们更 仔细地看一 看。第一个问题是当我们调用 p t hr e a d _ cr e a t e 时， 如何将已连接描述符传递给对等线 程。最明 显的方法就是传递一个指向这个描述符的指针，就像下面这样</p><p>connfd = Accept(listenfd, (SA*) &amp;clientaddr, &amp;clientlen); Pthread_create(&amp;tid, NULL, thread, &amp;connfd);</p><p>然后，我们让对等线程间接引用这个指针，并将它赋值给一个局部变量，如下所示</p><p>void *thread(void *vargp) {</p><p>int connfd = *((int *)vargp);</p><p>code/co吹n chosevrert.c</p><ol start=7><li><p>clientlen=sizeof (struct sockaddr_storage);</p></li><li><p>connfdp = Malloc(sizeof(int));</p></li><li><p>• connf dp = Accept(listenfd, (SA•) &amp;clientaddr, &amp;clientlen);</p></li><li><p>Pthread_create(&amp;tid, NULL, thread, connfdp); 24 }</p><p>25 }</p><p>26</p></li><li><p>I• Thread routine•I</p></li><li><p>void•thread(void•vargp)</p><p>29 {</p></li><li><p>int connf d = * ((int *)vargp) ;</p></li><li><p>Pthread_detach(pthread_self ());</p></li><li><p>Free(vargp);</p></li><li><p>echo(connfd) ;</p></li><li><p>Close(connfd);</p></li><li><p>return NULL;</p><p>36 }</p></li></ol><p>code/condechoservert.c</p><p>图 12-1 4 基于线程的 并发 echo 服务器</p><p>然而， 这样可能会出错， 因为它在对 等线程的赋值语句和主线程的 a c c e p t 语句间引入了竞争 ( race ) 。如果赋值语句在下一个 a c ce p t 之前完成， 那么对等线程中的局部变量c o nn f d就得到正确的描述符值。然而， 如果赋值语句是在 a c c e p t 之后才完成的， 那么对等线程中的 局部变量 c o n nf d 就得到下一次连接的描述符值。那么不幸的结果就是， 现在两个线程在同一个描述符上执行输入和输出。为了避免这种潜在的致命竞争，我们必须将 a c ce p七返回的每个已连接描述符分配到它自己的动态分配的内存块， 如第 20 21 行所示。我们 会在 12. 7. 4 节中回过来讨论竞争的问题。</p><p>另一个问题是在线程例程中避免内存泄漏。既然不显式地收回线程， 就必须分离每个线程，使 得在它终止时它的内存资源能够被收回（第31 行）。更进一步， 我们必须小心释放主线程分配的内存块（第32 行）。</p><p>沁氐 练习题 12. 5 在图 12- 5 中基 于进 程的服务器中， 我们 在两个位置小心 地关 闭 了 已连接描述 符： 父进 程和子进程。 然而，在 图 1 2-14 中基 于线程 的服务器中， 我们只在 一个位置关闭了巳连接描述符：对等线程。为什么？</p><p>12. 4 多线程程序中的共享变量</p><p>从程序员的角度来看，线程很有吸引力的一个方面是多个线程很容易共享相同的程序 变量。然而， 这种共享也是很棘手的。为了编写正确的多线程程序， 我们 必须对所谓的 共享以及它是如何工作的有很清楚的了解。</p><p>为了理解 C 程序中的一个变量是否是共享的， 有一些基本的问题要解答： 1) 线程的基础内存模型是什么? 2 ) 根据这个 模型， 变量实例是如何映 射到内存的? 3 ) 最后， 有多少线程引用这些实例？一个变量是共享的，当且仅当多个线程引用这个变董的某个实例。</p><p>为了让 我们对共享的讨论具 体化， 我们将使用图 12-15 中的程序作为运行示例。尽管有些人为的痕迹， 但是它仍然值得研究， 因为它说明 了关于共享的许多细微之处。示例程序由一个创建了两个对等线程的主线程组成。主线程传递一个唯一的 ID 给每个 对等线程， 每个对等线程利用这个 ID 输出一条个性化的信息， 以及调用该线程例程的总次数。</p><p>12 . 4. 1 线程内存模型</p><p>一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文， 包括线程 ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值。每个线程和其他线程一起共享进程上下文的剩余部分。这包括整个用户虚拟地址空间，它是由只读文本</p><p>（代码）、读／写数据、堆以及所有的共享库代码和数据区域组成的。线程也共享相同的打开文件的集合。</p><p>从实际操作的角度来说 ，让 一个线程去读或写另一个线程的寄存器值是不可能的。另一方面， 任何线程都可以访问共享虚拟内存的任意位置。如果某个线程修改 了一个内存位置， 那么其他每个线程最终都能 在它读这个位 置时发现这个变化。因此，寄 存器是从不共享的， 而虚拟内存总是共享的 。</p><p>各自独立的线程栈的内存模型不是那么整齐清楚的。这些栈被保存在虚拟地址空间的 栈区域中， 并且通常是被相应的线程独立 地访问 的。我们说通常而不是总是， 是因为不同的线程栈是不对其他线程设防的 。所以， 如果一个线程以某种方式得到一个指向其他线程栈的指针， 那么它就可以 读写这个栈的任何部分。示例程序在第 26 行 展示了这一点， 其中对等线程直接通过全局变量 p tr 间接引用主线程的栈的内容。</p><p>code/condsharing.c</p><p>#include &ldquo;csapp.h&rdquo;</p><ol><li>#define N 2<ol><li>void *thread(void *vargp);</li></ol></li></ol><p>5 char **ptr; I* Global variable *I</p><p>6</p><p>7 int main()</p><p>8 {</p><ol><li><p>int i;</p></li><li><p>pthread_t tid;</p></li><li><p>char *msgs [NJ = {</p></li><li><p>&ldquo;Hello from foo&rdquo;,</p></li><li><p>&ldquo;Hello from bar&rdquo;</p><p>14 };</p><p>15</p></li><li><p>ptr = msgs;</p></li><li><p>for (i = O; i &lt; N; i++)</p></li><li><p>Pthread_create(&amp;tid, NULL, thread, (void *)i);</p></li><li><p>Pthread_exit (NULL) ; 20 }</p><p>21</p><p>22 void *thread(void *vargp)</p><p>23 {</p></li><li><p>int myid = (int)vargp;</p></li><li><p>static int cnt = 0;</p></li><li><p>printf(" [%d]: %s (cnt=%d)\n", myid, ptr[myid], ++cnt);</p></li><li><p>return NULL;</p><p>28 }</p></li></ol><p>code/condsharing.c</p><p>图 12-1:i 说明共享不同方面的示例程序</p><ol><li><p>4. 2 将变星映射到内存</p><p>多线程的 C 程序中变量根据它们的存储类 型被映射到虚拟内存：</p><ul><li>全局 变量。 全局变量是定义在函数之外的变量。在运行时， 虚拟内存的读／写区域只包含每个 全局变量的一 个实例， 任何线程都可以引用。例如， 第 5 行声明的全局变量 p tr 在虚拟内存的读／写区域中有一个运行时实例。当一个变量只有一个实例时， 我们只用 变量名（在这里就是 p tr ) 来表示这个实例。</li><li>本地自动 变量。 本地自动变量就是定义在函数内部但是没有 s 七a t i c 属性的变量。在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例。即使多个线程 执行同一个线程例程时也是如此。例如， 有一个本地变量 t i d 的实例，它 保存在主线程的栈中。我们用 巨 d . m 来表示这个实例。再来看一个例子， 本地变量 my 过 有两个实例 ， 一个在对等线程 0 的栈内， 另一个在对等线程 1 的栈内。我们将这两个实例分别表示为 my i d . p O 和 my i d . p l 。</li><li>本地静 态变量。 本地静态变量是定义在函数内部并有 s t a t i c 属性的变量。和全局变量一样， 虚拟内存的读／写区域只包含在程序中声明的每个本地静态变量的一个实例。例如， 即使示例程序中的每个对等线程都 在第 25 行声明了 c n t , 在运行时， 虚拟内存的读／写区域中也只有一个 c n t 的实例。每个对等线程都读和写这个实例。</li></ul></li></ol><p>12. 4. 3 ，.±f:. 吉示亘 立旦</p><p>我们说一个变量 v 是共享的 ，当 且 仅 当它的一个实例被一个以上的线程引用。例如， 示例程序中的变量 c n t 就是共享的，因 为它只有一个运行时实例，并 且这个实例被两个对等线程引用。在另一方面， my 过 不 是 共 享 的 ， 因 为它的两个实例中每一个都只被一个线程引用。然而，认 识 到像 ms g s 这样的本地自动变量也能被共享是很重要的。</p><p>饬 练习题 12. 6</p><ol><li>利用 12. 4 节 中的分析， 为 图 12-1 5 中的 示 例 程 序在下 表的每 个条目中填写 “ 是“ 或者“ 否＂。在第 一列 中， 符号 v. t 表 示 变 量 v 的 一个实例 ， 它 驻 留在线程 t 的本地栈中， 其中 t 要 么是 m( 主 线程），要么是 p O( 对等线程 0 ) 或者 p l ( 对等 线程 1 ) 。</li></ol><table><thead><tr><th>变量实例 ptr cnt i.m msgs.m myid.po myi d . p l</th><th>主线程引用的？</th><th>对等线程0引用的？</th><th>对等线程1引用的？</th></tr></thead><tbody></tbody></table><ol start=2><li>根据 A 部分的分析， 变 量 p tr 、 c n t 、 1 、 ms g s 和 my 过 哪 些是 共享的？</li></ol><h3 id=5-用信号量同步线程>5 用信号量同步线程
<a class=anchor href=#5-%e7%94%a8%e4%bf%a1%e5%8f%b7%e9%87%8f%e5%90%8c%e6%ad%a5%e7%ba%bf%e7%a8%8b>#</a></h3><p>共享变量是十分方便，但 是 它 们也引 入了同 步错 误 ( s ynch ro nization er ro r ) 的可能性。考</p><p>虑图 12-16 中的程序 b a d c n t . c , 它创建了两个线程， 每个线程都对共享计数变量 c nt 加 1。</p><p>cod e/conclb ad cnt.c</p><ol><li><p>I* WARNING : This code is buggy! *I</p><ol><li><p>#include &ldquo;csapp.h&rdquo;</p><p>3</p><p>4 void *thread(void *vargp); I* Thread routine prototype *I</p><p>5</p></li></ol></li><li><p>I* Global shared variable *I</p></li><li><p>volatile long cnt = 0; I* Counter *I</p><p>8</p><p>9 int main(int argc, char **argv)</p><p>10 {</p></li><li><p>long niters;</p></li><li><p>pthread_t tid1, tid2;</p><p>13</p></li><li><p>I* Check input argument *I</p></li><li><p>if (argc != 2) {</p></li><li><p>printf(&ldquo;usage: %s &lt;niters>\n&rdquo;, argv[O]);</p></li><li><p>exit(O);</p><p>18 }</p><p>19 niters = atoi(argv [1]);</p><p>20</p></li><li><p>I* Create threads and wait for them to finish *I</p></li><li><p>Pthread_create(&amp;tid1, 皿 L, thread, &amp;niters);</p><p>图12- 16 ba dc nt . c, 一个同步不正确的计数器程序</p></li></ol><table><thead><tr><th>23</th><th>Pthread_create(&amp;tid2, 皿 L, thread,</th><th>&amp;niters);</th></tr></thead><tbody><tr><td>24</td><td>Pthread_join(tid1, NULL);</td><td></td></tr><tr><td>25</td><td>Pthread_join (tid2, NULL) ;</td><td></td></tr><tr><td>26</td><td></td><td></td></tr><tr><td>27</td><td>I* Check result *I</td><td></td></tr><tr><td>28</td><td>if Cent != (2 * niters))</td><td></td></tr><tr><td>29</td><td>printf(&ldquo;BODM! cnt=%ld\n&rdquo;, cnt);</td><td></td></tr><tr><td>30</td><td>else</td><td></td></tr><tr><td>31</td><td>printf (&ldquo;DK cnt=%ld\n&rdquo;, cnt);</td><td></td></tr></tbody></table><p>32 exit(O); 33 }</p><p>34</p><ol><li><p>I* Thread routine *I</p></li><li><p>void *thread(void *vargp) 37 {</p><p>38 long i, niters = *((long *)vargp); 39</p></li><li><p>for (i = O; i &lt; niters; i++)</p></li><li><p>cnt++;</p><p>42</p><p>43 return NULL;</p><p>44 }</p></li></ol><p>codelcondbadcnt.c</p><p>图 12-16 (续）</p><p>因为每个线 程都对计数器增加了 n i t er s 次， 我们预计它的最终值是 2 X n i t er s 。这看上去简单 而直接 。然而， 当在 L in u x 系统上运行 b a d c n t . c 时，我 们不仅得到错误的答案，而且每次得到的答案都还不相同！</p><p>linux> ./badcnt 1000000 BOOM! cnt=1445085</p><p>linux> ./badcnt 1000000 BOOM! cnt=1915220</p><p>linux> ./badcnt 1000000 BOOM! cnt=1404746</p><p>那么哪里出错 了呢？为了清晰地理解 这个问题， 我们需要研究计数器循环（第40 41 行）的汇编代码， 如图 1 2- 1 7 所示。我们发现， 将线程 1 的循环代码分解成 五个部分是很有帮助的：</p><ul><li><p>H , : 在循环头部的指令块。</p></li><li><p>L,: 加载共享变量 c n t 到累加寄存器%r d x , 的 指令， 这里%r d x , 表示线程 1 中的寄存器%r d x 的 值。</p></li><li><p>U, : 更新（增加） %r d x, 的指令。</p></li><li><p>s,: 将%r d x ; 的 更新值存回到共享变量 c n t 的指令。</p></li><li><p>T;: 循环尾部的指令块。</p><p>注意头和尾只操作本地栈变量 ， 而 L, 、U,和 S ,操作共享计数器变量的内容。</p><p>当 b a d c n t . c 中的两个对等线程在一 个单处理器上并发运行时， 机器指 令以某种顺序一个接一个地完成。因此，每个并发执行定义了两个线程中的指令的某种全序（或者交 叉）。不幸的是，这些顺序中的一些将会产生正确结果，但是其他的则不会。</p></li></ul><p>线程的汇编代码</p><p>线程 的C代码</p><p>f o r (i =O ; i &lt; ni 七 e r s ; i++) 1</p><p>圈畛</p><p>cnt++;</p><p>H,: 头</p><p><img src=img/3dd856d1f38bb94e960525b3c025f62d.jpeg alt>L, : 加载c nt</p><p>u,: 更新c nt</p><p>S;: 存储c nt</p><p>T, : 尾</p><p>图 1 2-1 7 ba dc nt . c 中计数器循环（第40~ 41 行）的汇编代码</p><p>这里有个关键点：一般而言，你没有办法预剧操作系统是否将为你的线程选择一个正 确的顺序。例如，图 1 2-1 8 a 展 示了一个正确的指令顺序的分步操作。在每个线程更新了共享变量 e n 七之 后 ，它 在 内 存 中 的 值 就 是 2 , 这正是期望的值。</p><p>另一方面，图 1 2-1 8 b 的 顺 序产生一个不正确的 c n t 的值。会发生这样的问题是因为， 线 程 2 在 第 5 步加载 c n t , 是在第 2 步线程 1 加载 c n t 之后， 而在第 6 步线程 1 存储它的更新值之前。因此， 每个线程最终都会存储一个值为 1 的更新后的计数器值。我们能够借 助千一种叫做进度图 ( p ro g r es s g ra p h ) 的 方法来阐明这些正确的和不正确的指令顺序的概念， 这个图我们将在下一节中介绍。</p><p>a ) 正确的顺序 b ) 不正确的顺序</p><p>图 1 2-18 badc nt . c 中第一次循环迭代的指令顺 序</p><p>凶 练习题 12 . 7 根据 b a d c n t . c 的指令顺序 完成 下表：</p><p>。</p><p>这种顺 序会产 生 一个正确的 c n t 值吗？</p><p>12 . 5 . 1 进度图</p><p>进度图( pro g res s g ra ph ) 将 n 个并发线程的执行模型化为一条 n 维笛卡儿空间中的轨迹线。每条轴 k 对应于线程 k 的进度。每个点 ( Ii , lz , …, J" ) 代表线程 k ( k = l , … ， n )已经完成 了指令 Ik这一状态。图的原点对应于没有任何线程完成一 条指令 的初始状态。</p><p>图 1 2-19 展示了 b a d c n t . c 程序第一 次循环 迭代的二维进度图 。水平轴对应于线程 1,</p><p>垂直轴对应于线程 2。点 CL 1, S 2) 对应于线程 1 完成了 L1 而线程 2 完成了 S2的状态。</p><p>进度图将 指令执行模型化 为从一种状态到另一种状态的转换 ( t ra ns it io n ) 。转换 被表示为一条从一点到相邻点的有向边。合法的 转换是向右（线程 1 中的一条指令完成）或者向上</p><p>（线程 2 中的一条指令完成）的。两条指令不能在同一时刻完成一 对角线转换是不允许的。程序决不会反向运行，所以向下或者向左移动的转换也是不合法的。</p><p>一个程序的执行历史被模型化为状态空间 中的一条轨迹线。图 12-20 展示了下面指令顺序对应的轨迹线：</p><h6 id=h1-l1-u1-h2-l2-s1-t1--u2--s-2--t-2>H1, L1, U1, H2, L2, S1, T1 , U2 , S 2 , T 2
<a class=anchor href=#h1-l1-u1-h2-l2-s1-t1--u2--s-2--t-2>#</a></h6><p>线程2 线程2</p><p>(L．,, S2)</p><h6 id=s2-s2>S2 S2
<a class=anchor href=#s2-s2>#</a></h6><p>U2 Ui</p><h6 id=l2-l2>L2 L2
<a class=anchor href=#l2-l2>#</a></h6><p>H2</p><p>H , L1 U1 S1 Tl</p><p>线程l</p><p>Hi</p><p>H, L, U,</p><p>S, T,</p><p>线程l</p><p>图 12- 1 9</p><p>badcnt . c 第一次循环迭代的进度图</p><p>图 12-20</p><p>一个轨迹线示例</p><p>对于线程 i&rsquo; 操作共享变量 c n t 内容的指令( L; , U;, S; ) 构成了一个（关于共享变量</p><p>c让 的）临界区 ( crit ica l section), 这个临界区不应该和其他进程的临界区交替执行。换句话说，我们想要确保每个线程在执行它的临界区中的指令时，拥有对共享变量的互斥的访问 ( m ut uall y exclusive access ) 。通常这种现象称为互斥 ( m ut ua l e xcl us io n ) 。</p><p>在进度图 中， 两个临界区的交集形成的状态空间区域称为不安 全区 ( unsafe regio n ) 。图 12-21 展示了变量 c吐 的不安全区。注意 ， 不安全区和与它交界的状态相毗邻， 但并不包括这些状态。例如， 状态CH 1 , H z) 和CS 1 , Uz) 毗邻不安全区， 但是它们并不是不安全区的一部分。绕开不安全 区的轨迹线叫做安全轨迹线( sa fe t ra jector y) 。相反， 接触到任何 不安全区的轨迹线就叫做不 安全轨迹线 ( unsa fe t ra jecto r y ) 。图 12- 21 给出了示例程序ba d e n七 . c 的 状态空间中的安全和不安全轨迹线。上面的 轨迹线绕开了不安全区域的左边和上边，所 以是安全的。下面的轨 迹线穿 越不安全区， 因此是不安全的 。</p><p>任何安全轨迹线都将正确地更新共享计数器。为了保证线程化程序示例的正确执行（实 际上任何共享全局数据结构的并发程序的正确执行）我们必须以某种方式同步线程，使它们 总是有一条安全轨迹线。一个经典的方法是基于信号量的思想， 接下来我们就介绍它。</p><p>饬 练习题 12 . 8 使用 图 1 2-21 中的 进度 图， 将下列 轨迹 线划分为 安全的 或者 不 安全 的。</p><h6 id=a-h1-l1-u1-s1-h2--l-2--u2--s-2--t-2--t1>A. H1, L1, U1, S1, H2 , L 2 , U2 , S 2 , T 2 , T1
<a class=anchor href=#a-h1-l1-u1-s1-h2--l-2--u2--s-2--t-2--t1>#</a></h6><table><thead><tr><th>B. H2</th><th>,</th><th>L 2</th><th>,</th><th>H 1 , L 1 , U1, S1,</th><th>T1,</th><th>U2, 5 2 , T 2</th></tr></thead><tbody><tr><td>C. H 1</td><td>,</td><td>H2,</td><td></td><td>L 2 , U2 , S2 , L1, 线程2</td><td>U1,</td><td>S1, T1, T2</td></tr></tbody></table><p><img src=img/950d49a36890602e7ea6a628769c77f9.jpeg alt>T,</p><p>s,</p><p>写 c nt 的 j u,</p><h6 id=l2>L2
<a class=anchor href=#l2>#</a></h6><p>HJ</p><p>H1 L1 亿 SI T, 线程1</p><p>写 cnt 的临界区</p><p>图 12-21 安全和不安全轨迹线。临界区的交集形成了不安全区。绕开不安全区的轨迹线能够正确更新计数器变量</p><ol><li><p>5. 2 信号量</p><p>Edsger Dijkstra, 并发编程领域的先锋人物，提出了一种经典的解决同步不同执行线程问题的方法， 这种方法是基千一种叫做信号 量( s em a p ho re ) 的特殊类型变量的。信号 量 s 是具有非负整数值的全局变量，只 能由两种特殊的操作来处理，这两 种操作称为 P 和 V :</p><ul><li><p>PCs): 如果 s 是非零的， 那么 P 将 s 减 1, 并且立即返回。如果 s 为零， 那么就挂起这个线程， 直到 s 变为非 零，而 一个 V 操作会重启 这个线程。在重启之后， P 操作将 s 减 1, 并将控制返回给调用者。</p></li><li><p>V(s): V操作将 s 加 1 。如果有任何线程阻 塞在 P 操作等待 s 变成非零， 那么 V 操作会重启这些线程中的一个 ， 然后该线程将 s 减 1, 完成它的 P 操作。</p><p>P 中的测试和减 1 操作是不可分割的，也 就是说， 一旦预测信号量 s 变为非 零， 就会将 s 减 1, 不能有中断。V 中的加 1 操作也是不可分割的，也 就是加载、加 1 和存储信号量的过程中没有中断。注意 ， V 的定义中没有定义等待线程被重启动的顺序。唯一的要求是 V 必须只能重启一个正在等待的线 程。 因此 ， 当有多个线程 在等待 同一个信号量时 ，你不能预 测 V 操作要重启哪 一个线程。</p><p>P 和 V 的定义确保了一个正在运行的程序绝不 可能进入这样一种状态 ，也 就是一个正确初始化了 的信号量有一个负值。这个属性称为信号量不 变性( se m a pho re invariant), 为控制并发程序的轨迹线提供了强有力的工具，在下一节中我们将看到。</p><p>P os ix 标准定义了许多操作信号量的函数。</p></li></ul></li></ol><p>#include &lt;semaphore.h></p><p>int sem_init(sem_t•sem, 0, unsigned int value); int sem_wait(sem_t•s); /• P(s)•I</p><p>int sem_post(sem_t•s); I• V(s)•I</p><p>返回： 若 成 功 则为 0 , 若 出错 则为 一1.</p><p>s e m_ i n i t 函数 将 信 号 量 s e m 初 始 化 为 v a l u e 。每个信号最在使用前必须初始化。针对我们的目的，中 间 的 参 数 总 是 零 。 程 序分别通过调用 s e m_ wa 江 和 s e m_ p o 江 函 数 来执行 P 和 V 操作。为了简明，我 们更喜欢使用下面这些等价的 P 和 V 的包装函数：</p><p>#include &ldquo;csapp. h&rdquo;</p><p>void P(sem_t *s); I* Wrapper function for sem_wa i t *I void V(sem_t *s ) ; I* Wr apper f un ct i o n for s e m_pos t *I</p><p>返 回 ： 无 。</p><p>匮目P 和 V 名字的起源</p><p>E dsge r Dijk s t ra0 930 —20 0 2 ) 出生于荷 兰。名 字 P 和 V 来源 于荷 兰语 单词 P ro ber en</p><p>（测试）和V e r h og e n ( 增加）。</p><ol><li><p>5. 3 使用信号量来实现互斥</p><p>信号量提供了一种很方便的方法来确保对共享变量的互斥访问。基本思想是将每个共 享变量（或者一组相关的共享变量）与一个信号量 s ( 初始为 1 ) 联系起来， 然后用 P Cs ) 和 V Cs ) 操 作 将相应的临界区包围起来。</p><p>以这种方式来保护共享变量的信号量叫做二元信号量 ( b in a r y s e m a p ho r e ) , 因为它的值总是 0 或者 1 。以提供互斥为目的的二元信号量常常也称为互 斥 锁 ( m ut ex ) 。在一个互斥锁上执行 P 操作称为对互斥锁加锁。类 似地， 执 行 V 操 作 称 为对互斥锁 解锁。对一个互斥锁加了锁但是还没有解锁的线程称为占 用这 个互斥锁。一个被用作一组可用资源的计数器的信号量被称为计数信号量。</p><p>图 1 2- 22 中的进度图展示了我们如何利用二元信号量来正确地同步计数器程序示例。每个状态都标出了该状态中信号量 s 的值。关键思想是这种 P 和 V 操作的结合创建了一组</p><p>线程2</p></li></ol><p>.0 .0</p><p>T,</p><p>．0 ．0</p><p>.0 .0 ．I ．I</p><p>．0 ．0 ．I</p><p>V(s) 。</p><p>一1</p><p>S, ：</p><p>禁止区 。</p><p>·· ··-··I···········-··I····,·- ·I ·&rsquo;•···</p><p>。 。 : - I</p><p>卜·：</p><p>.- I</p><p>- I - I i</p><p>;.</p><p>u, 。 。</p><p>L 2 0 。</p><p>不安全区</p><p>1- 1 - I - I - I ．</p><p>；·一··I············-···I··············-·1······-··1··!·•&rsquo;· 。</p><p>P (s )</p><p>0 .0 .0 0</p><h2 id=ctfil>CTfil
<a class=anchor href=#ctfil>#</a></h2><p>,1-f</p><p>0 0 0</p><p>线 程1</p><p>H , P (s ) L1 U1 SI V(s) T1</p><p>图 12-22 使用信号量来互斥。s&lt; O 的不可行状态定义了一个禁 止区， 禁止区完全包括了不安全区， 阻止了实际可行的轨迹线接触到不安全区</p><p>状态， 叫做禁止 区( fo r b idde n region) , 其中 s&lt; O。 因为信号量的不变性 ， 没有实际可行的轨迹线能够包含禁止区中的状态。而且， 因为禁止区完全包括了不 安全区， 所以没有实际可行的轨迹线能够接触不安全区的任何部分。因此，每条实际可行的轨迹线都是安全的， 而且不管运行时指令顺序是怎样的，程序都会正确地增加计数器值。</p><p>从可操作的意义上来说， 由 P 和 V 操作创建的禁止区使得在任何时间点上， 在被包围的临 界区中， 不可能有多个线程在执行 指令。换句话说，信 号量操作确保了对临界区的互斥访问 。</p><p>总的来说， 为了用信号量正确同步图 1 2-1 6 中的计数器程序示例，我 们首先声 明一个信号量 mu 七e x :</p><p>volatile long cnt = O; I* Counter *I</p><p>sem_t mutex; I* Semaphore that protects counter *I</p><p>然后在主例程中将 mu t e x 初始化 为 1 :</p><p>Sem_init(&amp;mutex, 0, 1); I* mutex = 1 *I</p><p>最后， 我们通 过把在线程例程中对共享变僵 c n t 的更新包围 P 和 V 操作， 从而保护它们：</p><p>for (i = O; i &lt; niters; i++) { P(&amp;mutex);</p><p>cnt++;</p><p>V(&amp;mutex);</p><p>｝</p><p>当我们运行这个正确同步的程序时，现在它每次都能产生正确的结果了。</p><p>linux> ./goodcnt 1000000 OK cnt=2000000</p><p>linux> ./goodcnt 1000000 OK cnt=2000000</p><p>m 进度图的 局限性</p><p>进度图给了我们一种较好的方法，将在单处理器上的并发程序执行可视化，也帮助 我们理解为什么需要同步。然而，它们确实也有局限性，特别是对于在多处理器上的并 发执行，在 多处 理器上一 组 CPU/ 高速缓 存对共享同一 个主 存。多 处理 器的 工作方式是进度图不能解释的 。特别是 ，一 个多处理 器内存 系统可以 处于一 种状态，不 对应 于进度图中任何轨迹线。不 管如何 ， 结论总是一样的 ： 无论是 在单处理 器还是 多处 理器上运行程序， 都要 同步你 对共享 变量的 访问。</p><ol><li><p>5. 4 利用信号量来调度共享资源</p><p>除了提供互斥之外，信 号量的另一个重要作用是调度对共享资源的访问。在这种场景中， 一个线程用信号量操作来通知另一个线程， 程序状 态中的某个条件已经为真了。两个经典而有用的例子是生产者－消费者和读者－写者问 题。</p><p>1 生产者－消费者问题</p><p>图 1 2- 23 给出了生产者－消费者问 题。生产者 和消费者线程共享一个有 n 个槽的有限缓 冲区。生产者线程反复地生成新的项目 ( item ) , 并把它们插入到缓冲区中。消费者线程不断地</p></li></ol><p>从缓冲区中取出这些项目，然后消费（使用）它们。也可能有多个生产者和消费者的变种。</p><p><img src=img/31d0ba10420bdde7d1c5772778c7aaef.jpeg alt></p><p>图 12- 23 生产者－消费者问题。生产者产生项目并把它们插入到一个有限的缓冲区中。消费者从缓冲区中取出这些项目，然后消费它们</p><p>因为插入和取出项目都涉及更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。如果缓冲区是满的</p><p>（没有空的槽位），那么生产者必须等待直到有一个槽位变为可用。与之相似，如果缓冲区 是空的（没有可取用的项目），那么消费者必须等待直到有一个项目变为可用。</p><p>生产者－消费者的相互作用在现实系统中是很普遍的。例如，在一个多媒体系统中， 生产者编码视频帧，而消费者解码并在屏幕上呈现出来。缓冲区的目的是为了减少视频流的抖动，而这种抖动是由各个帧的编码和解码时与数据相关的差异引起的。缓冲区为生产者提供了一个槽位池，而为 消费者提供一个已编码的帧池。另一个常见的示例是图形用户接口设计。生产者检测到鼠 标和键盘事件， 并将它们插入到缓 冲区中。消费者以某种基于优先级的方式从缓冲区取出这些事件，并显示在屏幕上。</p><p>在本节 中， 我们 将开发一个简单的包， 叫做 SBUF , 用来构造生产者－消费者程序。在下一节里 ， 我们会看到如何 用它来构造一个基千预 线程化( pr et h rea d in g ) 的有趣的并发服务器。SBUF 操作类型为 s b u f _ t 的有限缓冲区（图1 2- 24 ) 。项目存放在一个动态分配的</p><p>n 项整数数组 ( b u f ) 中。fr o n t 和r e ar 索引值记录该数组中的 第一项 和最后一项。三个信号量同步对缓冲区的 访问。mu t e x 信号量提供互斥的缓冲区访问 。s l o t s 和 i t e ms 信号 量分别记录空槽位和可用项目 的数量。</p><p>typedef struct { int *buf;</p><p>I* Buffer array *I</p><p>code/condsbuf h</p><p>int n;</p><p>int front; int rear; sem_t mutex; sem_t slots; sem_t items;</p><p>} sbuf_t;</p><p>I* Maximum number of slots *I</p><p>I* buf[(front+1)%n] is first item *I I* buf[rear%n] is last item *I</p><p>I* Protects accesses to buf *I I* Counts available slots *I I* Counts available items *I</p><p>code/condsbuf.h</p><p>图 l 2-24 sbuf_t: SBUF 包使用的有限缓 冲区</p><p>图 1 2- 25 给出 了 SBU F 函数的实现。 s b u f _ i n i t 函数为缓 冲区 分配堆内存，设 置f r o n 七和 r e ar 表示一个空的缓冲区 ， 并为三个 信号量赋初始值。这个函数在调用其他三个函数中的任何一个之前调用一次。s b u f _ d e i n 江 函数是当应用程序使用完缓冲区时 ， 释放缓冲区存储的 。s b u f _ i n s er t 函数等待一个可用的槽 位， 对互斥锁加锁， 添加项目， 对互斥锁解锁， 然后宣布有一个新项目可用。s b u f _r e mo v e 函数是与 s b u f _ i n s er t 函数对称的。在等待一个可用的缓冲区项目之后，对互斥锁加锁，从缓冲区的前面取出该项目， 对互斥锁解锁， 然后发信号通知一个新的槽位可供使用 。</p><p>code/condsbu肛</p><ol><li><p>#include II csapp. h11</p><ol><li><p>#include 11sbuf .h11</p><p>3</p></li></ol></li><li><p>I* Create an empty, bounded, shared FIFO buffer with n slots *I</p></li><li><p>void sbuf_init(sbuf_t *sp, int n)</p><p>6 {</p></li><li><p>sp->buf = Calloc(n, sizeof(int));</p></li><li><p>sp->n = n; I* Buffer holds max of n items *I</p></li><li><p>sp->front = sp->rear = 0; I* Empty buffer iff front == rear *I 1O Sem_init (&amp;sp->mutex, 0, 1); I* Binary semaphore for locking *I</p></li><li><p>Sem_init(&amp;sp->slots, 0, n); I* Initially, buf has n empty slots *I</p></li><li><p>Sem_init(&amp;sp->items, O, 0); I* Initially, bufhas zero data items *I</p><p>13 }</p><p>14</p></li><li><p>I* Clean up buffer sp *I</p></li><li><p>void sbuf_deinit(sbuf_t *Sp)</p><p>17 {</p><p>18 Free(sp->buf);</p><p>19 }</p><p>20</p></li><li><p>I* Insert item onto the rear of shared buffer sp *I</p></li><li><p>void sbuf_insert(sbuf_t *Sp, int item) 23 {</p></li><li><p>P (&amp;sp->slots); I* Wait for available slot *I</p></li><li><p>P (&amp;sp->mutex); I* Lock the buffer *I</p></li><li><p>sp->buf [ (++s p- >r ea 工）%(sp->n)] = item; I* Insert the item *I</p></li><li><p>V(&amp;sp->mutex); I* Unlock the buffer *I</p></li><li><p>V(&amp;sp->items); I* Announce available item *I</p><p>29 }</p><p>30</p></li><li><p>I* Remove and return the first item from buffer sp *I</p></li><li><p>int sbuf_remove(sbuf_t *Sp)</p><p>33 {</p></li><li><p>int item·</p></li><li><p>P(&amp;sp->items); I* Wait for available item *I</p></li><li><p>P(&amp;sp->mutex); I* Lock the buffer *I</p></li><li><p>item= sp->buf[(++sp->front)%(sp->n)]; I* Remove the item *I</p></li><li><p>V(&amp;sp->mutex); I* Unlock the buffer *I</p></li><li><p>V(&amp;sp->slots); I* Announce available slot *I</p></li><li><p>return item;</p><p>41 }</p></li></ol><p>code/condsbu肛</p><p>图 12- 25 SBUF: 同步对有限缓冲区并发访问的包</p><p>练习题 12. 9 设 p 表 示 生产 者数 量， c 表 示 消费者数量， 而 n 表 示 以项目单元 为单 位</p><p>的缓冲 区大小。对于下 面的每个场景 ， 指 出 s b u f _ i n s er t 和 s b u f _ r e mo v e 中的互斥锁信号量是否是必需的。</p><ol><li>p = I , c = 1 , n > l<ol><li>p = I , c = 1 , n = I</li></ol></li></ol><h5 id=p-i-cl-ni>p> I, c>l, n=I
<a class=anchor href=#p-i-cl-ni>#</a></h5><p>2 读者－者写问题</p><p>读者－者写问题是互斥问题的一个概括。一组并发的线程要访问一个共享对象， 例如</p><p>一个主存中的数据结构，或 者一个磁盘上的数据库。有些线程只读对象， 而其 他 的 线 程只修改对象。修改对象的线程叫做写者。只读对象的线程叫做读者。写者必须拥有对对象的 独占的访问，而读者可以和无限多个其他的读者共享对象。一般来说，有无限多个并发的 读者和写者。</p><p>读者－写者交互在现实系统中很常见。例如，一个在线航空预定系统中，允许有 无限多个客户同时查看座位分配，但是正在预订座位的客户必须拥有对数据库的独占 的访问。再来看另一个例子， 在 一个多线程缓 存 Web 代理中， 无 限 多 个 线 程可以从共享页面缓存中取出已有的页面，但是任何向缓存中写入一个新页面的线程必须拥有 独占的访问。</p><p>读者－写者问题有几个变种，分别基于读者和写者的优先级。第一类读者－写者问题，读者优先，要求不要让读者等待，除非已经</p><p>把使用对象的权限赋予了一个写者。换旬</p><p>话说，读者不会因为有一个写者在等待而等待。第二类读者－写者问题，写者优先， 要求一旦一个写者准备好可以写，它就会尽可能快地完成它的写操作。同第一类问题不同，在一个写者后到达的读者必须等待，即使这个写者也是在等待。</p><p>图 12-26 给出了一个对第一类读者－ 写者问题的解答。同许多同步问题的解 答一样，这个解答很微妙，极具欺骗性 地简单。信号量 w 控制对访问共享对象 的临界区的访问。信号量 mu t e x 保 护 对共享变量 r e a d c n t 的访问，r e a d c n t 统计当前在临界区中的读者数量。每当一 个写者进入临界区时， 它 对 互 斥锁 w 加锁 ， 每当它离 开 临 界 区 时， 对 w 解 锁 。这就保证了任意时刻临界区中最多只有 一个写者。另一方面，只有第一个进入 临界区的读者对 w 加 锁 ， 而 只 有 最 后 一个 离 开临界区的读 者对 w 解 锁 。 当 一个读者进入和离开临界区时，如果还有其 他读者在临界区中，那么这个读者会忽 略互斥锁 w。这 就意味着只要还有一个读者占用互斥锁 w, 无限多数量的读者可以没有障碍地进入临界区。</p><p>对这两种读者－写者问题的正确解答可能导致饥饿 ( s ta r va t io n ) , 饥饿就是一</p><p>I* Global va工ia bl e s *I</p><p>int readcnt; I* Initially= 0 *I</p><p>sem_t mutex, w; I* Both initially= 1 *I</p><p>void reader(void)</p><p>｛</p><p>while (1) {</p><p>P(&amp;mutex); readcnt++;</p><p>if (readcnt == 1) I* First in *I</p><p>P(&amp;w); V(&amp;mutex);</p><p>I* Critical section *I I* Reading happens *I</p><p>P(&amp;mutex); readcnt&ndash;;</p><p>if (readcnt == 0) I* Last out *I</p><p>V(&amp;w); V(&amp;mutex);</p><p>void writer(void)</p><p>｛</p><p>while (1) {</p><p>P(&amp;w);</p><p>I* Critical section *I I* Writing happens *I</p><p>V(&amp;w);</p><p>个线程无限期地阻塞，无法进展。例如，</p><p>图 12-26 所示的解答中，如 果 有 读 者 不 断地到达，写者就可能无限期地等待。</p><p>图 12-26 对第一类读者－写者问题的解答。读者优先级高于写者</p><p>练习题 12. 10 图 12- 26 所 示的 对 第 一 类 读者－写者问题的 解答给 予 读 者 较 高 的 优先级，但是从某种意义上说，这种优先级是很弱的，因为一个离开临界区的写者可能重 启一个在等待的写者，而不是一个在等待的读者。描述出一个场景，其中这种弱优先 级会导致一群写者使得一个读者饥饿。</p><p>应I _其他同步机 制</p><p>我们已经向你展示了如何利用信号量来同步线程，主要是因为它们简单、经典，并且 有一个清晰的语义模型。但是你应该知道还是存在 着其他 同步技 术的。例如 ， Ja va 线程是用一种叫做 Java 监控器(J ava Monitor) [ 48] 的机制来同步的 ， 它提供了对 信号量 互斥 和调度能力的更高级 别的抽 象； 实际 上，监控 器 可以 用信号量来 实现。再 来看一 个例 子， Pthrea ds 接口定义了一组对互斥锁和条件 变量的 同步 操作。Pthreads 互斥锁 被用 来实现互斥。条件 变量用来调 度对共享资源的访问， 例如在一个生产者－消费者程序中的有限缓冲区。</p><p>12 . 5. 5 综合：基千预线程化的并发服务器</p><p>我们已 经知道了如何使用信号量来访问 共享变量和调度对共享资源的访问。为了帮 助你更清晰地理解这些思想，让 我们把它们应用到一个基千称为预线程化( pret hread ing )技术的并发服务器上。</p><p><img src=img/3eb51c417054ab5f06bd1748d41e68b1.jpeg alt>在图 1 2-14 所示的并发服务器中， 我们为每一个新客户端创建了一个新线程。这种方法的缺点是我们为每一个新客户端创建一个新线程，导致不小的代价。一个基于预线程化 的服务器试图通过使用如图 1 2-27 所示的生产者－消费者模型来 降低这种开销。服务器是由一个主线程和一组工作者线程构 成的。主线程不断地接受来自客户端的连接请求， 并将得到的连接描述符放 在一个有限缓冲区中。每一个工作 者线程反复 地从共享缓冲区中 取出描述符， 为客户端 服务， 然后等待下一个描述符。</p><p>图 1 2- 27 预线程化的并发服务器的组织结构。一组现有的线程不断地取出</p><p>和处理来自有限缓冲区的已连接描述符</p><p>图 12-28 显示了我们怎样用 SBUF 包来实现一个预线程化的并发 echo 服务器。 在初始化了缓冲区 s b u f ( 第 24 行）后， 主线程创建 了一组工作者线程（第25 ~ 26 行）。然后它进 入了无限的服务器循 环，接 受连接 请求， 并将得到的巳 连接描述符插入到缓冲区 s b uf 中。每个工作者线程的行为都非常简单。它等待直到它能从缓冲区中取出一个已连接描述符</p><p>（第39 行），然后调用 e c ho_c nt 函数回送客户端的输入。</p><p>图 12-29 所示的函数 e c ho_c n t 是图 11-22 中的 e c ho 函数的一个版本， 它在全局变量b yt e _c nt 中记录了从所有客户端接收到的累计字节数。这是一段值得研究的有趣代码， 因为它向你展示了一个从线程例程 调用的初始化 程序包的 一般技术。在这种情况中， 我们</p><p>需要初始化 b y t e _ c n t 计数器和 rnu t e x 信号量。一个方法是 我们为 SBUF 和 R I O 程序包使用过的， 它要求主线程显式地调用一个初始化函数。另外一个方法， 在此显示的， 是当第一次有某个线程调用e c h o _ c n t 函数时， 使 用 p t hr e a d _ o n c e 函数（第 19 行）去调用初始化函数。这个方法的优点是它使程序包的使用更加容易。这种方法的缺点是每一次调用 e c h o _ c n t 都会导致调用 p t hr e a d_ o n c e 函数， 而在大多数时候它没有做什么有用的事。</p><p>co d e/co nd ech os ervert-p re.c</p><p>#include &ldquo;csapp.h&rdquo;</p><ol><li>#include &ldquo;sbuf .h&rdquo;</li><li>#define NTHREADS 4</li><li>#define SBUFSIZE 16</li><li>void echo_cnt(int connf d) ;</li><li>void *thread(void *vargp);</li></ol><p>9 sbuf_t sbuf; I* Shared buffer of connected descriptors *I 10</p><p>11 int main(int ar gc, char **argv)</p><p>12 {</p><ol><li><p>int i , listenfd, connfd;</p></li><li><p>socklen_t cl i ent l en;</p></li><li><p>struct sockaddr_storage clientaddr;</p></li><li><p>pthread_t tid;</p></li><li><p>if (argc != 2) {</p></li><li><p>fprintf(stderr, &ldquo;usage: %s &lt;port>\n&rdquo;, argv[O]);</p></li><li><p>e x i t (O) ;</p><p>21</p><p>22 listenfd = Open_listenfd(argv[1]) ;</p><p>23</p></li><li><p>sbuf_init(&amp;sbuf, SBUFSI ZE) ;</p></li><li><p>for (i = O; i &lt; NTHREADS; i ++) I* Create worker threads *I 26&rsquo; Pt hr e a d _cr ea t e (&amp;t i d , NULL, thread, NULL);</p><p>27</p></li><li><p>while (1) {</p></li><li><p>clientlen = sizeof (struct sockaddr_s t or ag e ) ;</p></li><li><p>connfd = Accept (listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</p></li><li><p>sbuf_insert(&amp;sbuf, connf d) ; I* Insert connfd in buffer *I 32</p><p>33 }</p><p>34</p><p>35 void *thread(void *vargp) 36 {</p></li><li><p>Pt hr e ad _de t a c h ( pt hr e ad _s e lf O);</p></li><li><p>while (1) {</p></li><li><p>int connfd = sbuf_remove(&amp;sbuf); I* Remove c onn f d from buffer *I</p></li></ol><p>40</p><p>41</p><p>42</p><p>43 }</p><p>echo_cnt(connfd); Cl os e ( conn f d ) ;</p><p>I* Service client *I</p><p>code/con吹choservert-pre.c</p><p>图12- 28 一个预线程化的并发 echo 服务器。这个 服务器使用的是有一个生产者和多个消费者的生产者－消费者模型</p><p>code/cone/echo-cnt.c</p><p>#include &ldquo;csapp.h&rdquo;</p><p>3 static int byte_cnt; I* Byte counter *I</p><p>4 static sem_t mutex; I* and the mutex that protects it *I</p><p>6 static void init_echo_cnt(void)</p><p>7 {</p><p>8 Sem_init(&amp;mutex, 0, 1);</p><p>9 byte_cnt = O;</p><p>10 }</p><p>12 void echo_cnt(int connfd)</p><p>13 {</p><p>14 int n·</p><ol><li><p>char buf[MAXLINE];</p></li><li><p>rio_t rio;</p></li><li><p>static pthread_once_t once= PTHREAD_ONCE_INIT;</p><p>18</p></li><li><p>Pthread_once(&amp;once, init_echo_cnt);</p></li><li><p>Rio_readinitb(&amp;rio, connfd);</p></li><li><p>while ((n = Rio_readlineb (&amp;rio, buf, MAXLINE)) ! = 0) {</p></li><li><p>P (&amp;mutex);</p></li><li><p>byte_cnt += n;</p></li><li><p>printf (11server received %d CJ 儿 d total) bytes on fd %d\n",</p></li><li><p>n, byte_cnt, connfd);</p></li><li><p>V (&amp;mutex) ;</p></li><li><p>Rio_writen(connfd, buf, n);</p><p>28</p><p>29 }</p><p>code/conc/echo.-ccnt</p><p>图 12- 29 echo_cnt, echo 的一个版本， 它对从客户端接收的所有字节计数</p></li></ol><p>一旦 程序包 被初始化， e c h o _ c n t 函 数 会 初始化 RIO 带 缓 冲区的 I/ 0 包（第 20 行），然 后 回 送 从 客 户端接收到的每一个文本行。注意，在 第 23 25 行 中 对共享变量 b yt e _ c n t 的访问是被 P 和 V 操作保护的。</p><p>团 日 基千线程的事件驱动程序</p><p>I/ 0 多路 复 用不 是 编写事件 驱动程序的唯一方 法。 例如 ， 你可能已经注意到我们刚才开发的并发的预线程化的服务器实际上是一个事件驱动服务器，带有主线程和工作者 线程的简单状态机。主线程有两种状态(&ldquo;等待连接请求”和”等待可用的缓冲区槽 位&rdquo;)、两个 I/ 0 事件( &ldquo;连接请求到 达” 和 ＂缓 冲区槽 位 变为 可用&rdquo; )和 两个转换( &ldquo;接受连接请求” 和 “ 插 入 缓 冲区项 目&rdquo; )。 类似 地， 每个工作者线程有一个状 态( " 等待 可用的缓冲项目")、 一个 I/ 0 事件（＂缓冲区项 目 变为 可用" )和 一个转换( &ldquo;取出缓 冲区项 目&rdquo;)。</p><p>12. 6 使用线程提高并行性</p><p>到目前为止，在对并发的研究中，我们都假设并发线程是在单处理器系统上执行的。</p><p>然而，大多数现代机器具有多核处理器。并发程序通常在这样的机器上运行得更快，因为 操作系统内核在多个核上并行地调度这些并发线程，而不是在单个核上顺序地调度。在像 繁忙的 Web 服务 器、数据库服务器和大型科学计算代码这样的应用中利用这样的并行性是至关重要的， 而且在像 Web 浏览骈、电子表格处理程序和文档处理程序这样的主流应用中，并行性也变得越来越有用。 所有的程序</p><p>图 12- 30 给出了顺 序、并发和并行程序之间的 口五五示</p><p>集合关系。所有程序的集合能够被划分成不相交</p><p>的顺序程序集合和并发程序的集合。写顺序程序只有一条逻辑流。写并发程序有多条并发流。并行程序是一个运行在多个处理器上的并发程序。因此，并行程序的集合是并发程序集合的真子集。</p><p>并行程序的详细处理超出了本书讲述的范围，</p><p>三 顺序程序</p><p>图 12 -30 顺序、并发和并行程序</p><p>集合之间的关系</p><p>但是研究一个非常简单的示例程序能够帮助你理解并行编程的一些重要的方面。例如，考 虑我们如何并行地对一列整数 o, …, n - l 求和。当然， 对于这个特殊的问 题， 有闭合形式表达式的 解答（译者注： 即有现成的公 式来计算它， 即和等 千 n ( n - 1 ) / 2) , 但是尽管如</p><p>此，它是一个简洁和易于理解的示例，能让我们对并行程序做一些有趣的说明。</p><p>将任务分 配到不同线 程的最 直接方法是将序列划分成 t 个不相交的区域， 然后给 t 个不同的线程每个 分配一个区域。为了简单， 假设 n 是 t 的倍数， 这样每个 区域有 n / t 个元素。让我们来看看多个线程并行处理分配给它们的区域的不同方法。</p><p>最简单也最直接的选择是将线程的和放入一个共享全局变量中，用互斥锁保护这个变 量。图 12-31 给出了我们会如何实 现这种方法。在第 28 ~ 33 行， 主线程创建对等线程 ，然 后等待它们结束。注意 ， 主线程传递给每个对等线程一个小整数，作为唯一的线程ID。每个对等线程会用它的线 程 ID 来决定它应该计算序列的哪一部分。这个向对等线程传递一个小的唯一的线程1D 的思想是一项通用技术 ， 许多并行应用中都用到了它。在对等线程终止后， 全局变鼠 gs um 包含着最终的和。然后主线程用闭合形式解答来验证结果（第36~ 37 行）。</p><p>code/condpsum-mutex.c</p><p>#include &ldquo;csapp.h&rdquo;</p><p>2 #define MAXTHREADS 32</p><p>4 void *surn_rnutex(void *vargp); I* Thread routine *I</p><p>6 I* Global sha工ed va 工i abl e s *I</p><ol><li><p>long gsurn = O; I* Global sum *I</p></li><li><p>long nelerns_per_thread; I* Number of elements to sum *I</p><p>9 sem_t rnutex; I* Mutex to protect global sum *I</p><p>10</p><p>11 int rnain(int argc, char **argv)</p><p>12 {</p><ol><li><p>long i, nelems, log_nelems, nthreads, myid[MAXTHREADS];</p></li><li><p>pthread_t tid[MAXTHREADS];</p><p>15</p><p>16 I* Get input arguments *I</p><p>图12-31 ps um- mut ex 的主程序， 使用多个线程将 一个序列元素的和放入一个用互斥锁保护的共享全局变扯中</p></li></ol></li></ol><table><thead><tr><th>17</th><th></th><th>if (argc != 3) {</th></tr></thead><tbody><tr><td>18</td><td></td><td>printf(&ldquo;Usage: %s &lt;nthreads> &lt;log_nelems>\n&rdquo;, argv[O]);</td></tr><tr><td>19</td><td></td><td>exit(O);</td></tr><tr><td>20</td><td></td><td>｝</td></tr><tr><td>21</td><td></td><td>nthreads = atoi(argv[1]);</td></tr><tr><td>22</td><td></td><td>log_nelems = atoi(argv[2]);</td></tr><tr><td>23</td><td></td><td>nelems = (1L«log_nelems);</td></tr><tr><td>24</td><td></td><td>nelems_per_thread = nelems / nthreads;</td></tr><tr><td>25</td><td></td><td>sem_init(&amp;mutex, 0, 1);</td></tr><tr><td>26</td><td></td><td></td></tr><tr><td>27</td><td></td><td>I* Create peer threads and wait for them to finish *I</td></tr><tr><td>28</td><td></td><td>for (i = O; i &lt; nthreads; i++) {</td></tr><tr><td>29</td><td></td><td>myid[i] = i;</td></tr><tr><td>30</td><td></td><td>Pthread_create(&amp;tid[i], NULL, sum_mutex, &amp;myid[i]);</td></tr><tr><td>31</td><td></td><td>｝</td></tr><tr><td>32</td><td></td><td>for (i = O; i &lt; nthreads; i++)</td></tr><tr><td>33</td><td></td><td>Pthread_join(tid[i], NULL);</td></tr><tr><td>34</td><td></td><td></td></tr><tr><td>35</td><td></td><td>I* Check final answer *I</td></tr><tr><td>36</td><td></td><td>if (gsum != (nelems * (nelems-1))/2)</td></tr><tr><td>37</td><td></td><td>printf(&ldquo;Error: result=%ld\n&rdquo;, gsum);</td></tr><tr><td>38</td><td></td><td></td></tr><tr><td>39</td><td></td><td>exit(O);</td></tr><tr><td>40</td><td>｝</td><td></td></tr><tr><td></td><td></td><td>code/condpsum-mutex.c</td></tr><tr><td></td><td></td><td>图 12-31 (续）</td></tr></tbody></table><p>图 12-32 给出了每个对等线程执行的函数。在第 4 行 中 ，线 程 从 线 程 参 数 中 提取出线程 ID , 然后用这个 ID 来决定它要计算的序列区域（第5~ 6 行）。在第 9 ~ 13 行中，线 程在它的那部分序列上迭代操作， 每次迭代都更新共享全局变量 g s um。 注 意 ， 我们很小心地用 P 和 V 互斥操作来保护每次更新。</p><p>code/condpsum-mutex.c</p><p>I* Thread routine for psum-mutex.c *I void *sum_mutex(void *vargp)</p><p>｛</p><p>long myid = *((long *)vargp); I* Extract the thread ID *I long start= myid * nelems_per_thread; I* Start element index *I long end= start+ nelems_per_thread; I* End element index *I long i;</p><p>for (i = start; i &lt; end; i++) { P(&amp;mutex);</p><p>gsum += i;</p><p>V(&amp;mutex);</p><p>｝</p><p>return NULL;</p><p>code/condpsum-mutex.c</p><p>图 12-32 ps um- mu七e x 的线程例程。每个对 等线程将各 自的 和累加进一个用互斥锁保护的共享全局变量中</p><p>我们在一个四核系统上， 对一个大小为 n = 沪 的序列运行 p s um- mutex, 测量它的运行时间（以秒为单位），作为线程数的函数，得到的结果难懂又令人奇怪：</p><p>线程数</p><p>版本 16</p><p>ps um- mut e x I 68 432 I 719 I 552 I 599</p><p>程序单线程顺序运行时非常慢，几乎比多线程并行运行时慢了一个数量级。不仅如 此， 使用的核数越多 ，性 能越差。造成性能差的原因是相对于内存更新操作的开销，同 步操作( P 和 V ) 代价太大。这突显了并行编程的一项重要教训 ： 同 步 开销 巨 大，要 尽 可能 避免。如果无可避免 ， 必须要 用尽可能 多的有用计算 弥补这 个开销。</p><p>在我们的例子中，一种避免同步的方法是让每个对等线程在一个私有变量中计算它自 己的 部分和， 这个私有 变量不与其他任何线程共享， 如图 12-33 所示。主线程（图中未显示）定义一个全局 数组 p s u m, 每个对等线程 1 把它的部分和累积在 p s u m [ i ] 中。因为小 心地给了每个对等线程一个不同的内存位置来更新， 所以不需要用互斥锁来保护这些更新。唯一需要同步的地方是主线程必须等待所有的子线程完成。在对等线程结束后， 主线程把p s um 向 量的元素加起来， 得到最终的结果。</p><p>code/condpsum-array.c</p><p>I* Thread routine for psum-array.c *I</p><p>2 void *sum_array(void *vargp)</p><p>3 {</p><p>long myid = *((long *)vargp); I* Extract the thread ID *I</p><p>5 long start= myid * nelems_per_thread; I* Start element index *I</p><p>6 long end= start+ nelems_per_thread; I* End element index *I</p><p>7 long i;</p><p>8</p><p>9 for (i = start; i &lt; end; i++) {</p><p>10 psum[myid] += i;</p><p>11 }</p><p>12 return NULL;</p><p>13 }</p><p>cod e/ cond ps um-array.c</p><p>图 12- 33 psum- ar r a y 的线程例程。每个对 等线程把它的 部分和</p><p>累积在一个私有数组元 素中 ， 不与其他任何 对等线程共享该元素</p><p>在四核系统上运行 p s u m- arr a y 时 ，我 们看到它比 p s um- mu t e x 运行得快好几个数量级：</p><p>版本</p><p>psum-mutex I 68.00</p><p>psum-array 7.26</p><p>432.00</p><p>3.64</p><p>线程数</p><p>4</p><p>719.00</p><p>1.91</p><p>552.00</p><p>1.85</p><p>16</p><p>599.00</p><p>1.84</p><p>在第 5 章中， 我们学 习到了如何使用局部变量来 消除不必要的内存引用。图 12-34 展示了如何应用这项原则，让每个对等线程把它的部分和累积在一个局部变量而不是全局变 量中。当在四核机器上运行 p s u m- l o c a l 时， 得到一组新 的递减的运行时 间：</p><table><thead><tr><th></th><th>线程数</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>版本</td><td>l</td><td>2</td><td>4</td><td>8</td><td>16</td></tr><tr><td>psum-mutex</td><td>68.00</td><td>432.00</td><td>719.00</td><td>552.00</td><td>599.00</td></tr><tr><td>psum-array</td><td>7.26</td><td>3.64</td><td>1.91</td><td>1.85</td><td>1.84</td></tr><tr><td>ps um- l oc a l</td><td>1.06</td><td>0.54</td><td>0.28</td><td>0.29</td><td>0.30</td></tr></tbody></table><p>code/condpsum-local.c</p><p>I* Thread routine for psum-local. c */</p><p>void•sum_local(void•vargp)</p><p>｛</p><p>long myid =•((long•)vargp); /• Extract the thread ID•I</p><p>long start= myid * nelems_per_thread; I* Start element index•/ long end= start+ nelems_per_thread; /• End element index•/</p><p>long i, sum= O; 。</p><p>for (i = start; i &lt; end; i++) { sum+= i;</p><p>｝</p><p>psum[myid] = sum; return NULL;</p><p>code/condpsum-local.c</p><p>图 1 2-34 ps um- l oca l 的 线程例程 。每个对等线 程把它的部分 和累积在一 个局部变昼中</p><p>从这个练习可以学习到一个重要的 经验， 那就是写并行程序相当棘手。对代码看上去很小的改动可能会对性能有极大的影响 。</p><p>刻画并行程序的性能</p><p>图 1 2-35 给 出 了图 12-34 中 程 序psum- l oca l 的运行时间，它 是线程数的函数。在每个 情况下， 程序运行在一个有四个处理器核的系统上，对一个n = 23 1 个元素的 序列求 和。我 们 看 到，随着线程数的增加，运行时间下降，直到增加到四个线程，此时，运行时间趋于平稳 ，甚 至开始有点 增加。</p><p>1.2</p><p>1.0</p><p>0.2</p><p>0 . 3</p><p>4 16</p><p>线程</p><p>在理想的情况中，我们会期望运行时间随着核数的增加线性下降。也就是说，</p><p>图 12-35 ps um- l o ca l 的 性 能（图 1 2-34) 。用四个处理器核对一个 沪 个元素序列求 和</p><p>我们会期望线程数每增加一倍 ， 运行时间 就下降一半。确实是这样， 直到到达 t> 4 的时候， 此时四个核中的每一个都忙于运行 至少一个线程。随着线程数量的增加， 运行时间实际上增加了一点儿， 这是由于在一个核上多个线程上下文切换的开销 。由于这个原 因， 并行程序常常被写为每个核上只运行一个线程。</p><p>虽然绝对运行时间是衡 量程序性能的终极标 准， 但是还是有一些有用的相 对衡量标准能够说明并行 程序有多好地利用了潜在的并行性 。并行程序的加速比( s peed u p) 通常定义为</p><p>Sp= -T1</p><h6 id=tp>Tp
<a class=anchor href=#tp>#</a></h6><p>这里 p 是处理器核的数量， 吓 是在 K 个核上的运行时间。这个公式有时被称为 强扩展(strong scaling)。当 九是程序顺序执行版本的执行时间时， Sp 称为绝对加 速比 ( a bsol ute speed up) 。当 九是程序并 行版本在一个核上的执行时间时， Sp 称为相对加速比 ( re lat ive speed up) 。绝对加速比比相 对加速比能更真实地衡量并行的好处。即使是当并行程序在 一个处理器上运行时，也常常会受到同步开销的影响，而这些开销会人为地增加相对加速比的数值， 因为它们增 加了分子的大小。另一方面， 绝对加速比比相对加速比更难以测量， 因为测量绝对加 速比需要程序的 两种不同的 版本。对于复杂的并行代码， 创建一个独立的顺序版本可能不太实际，或者因为代码太复杂，或者因为源代码不可得。</p><p>一种相关的 测量量称为效 率( eff icie nc y) , 定义为</p><p>Ep Sp T1</p><h6 id=p-p-t-p>p p T p
<a class=anchor href=#p-p-t-p>#</a></h6><p>通常表示为范围 在( 0 , 1 0 0 ] 之间的百分比。效率是对由于并行化造成的开销的衡量。具 有高效率的程序比效率低的程序在有用的工作上花费更多的时间，在同步和通信上花费更少 的时间。</p><p>效率是因为我们的问题非常容易并行化。在实际中，很少会这样。数十年</p><p>图 12-36 图 12-35 中执行时间的加速比和并行效 率</p><p>来， 并行编程一直是一个很活跃的 研究领域。随着商用多核机器的出现， 这些机器的核数每几年就翻一番，并行编程会继续是一个深入、困难而活跃的研究领域。</p><p>． 加速比还有另外一面， 称为 弱扩展 ( w ea k scaling) , 在增加处理器数掀的同时， 增加问题的规模， 这样随着处理器数量的增加， 每个处理器执行的工作量保持不变。在这种描述中，加 速比和效率被表达为单 位时间 完成的工作总量。 例如， 如果 将处理器数量翻倍， 同时 每个小时也做了两倍的工作量， 那么我们就有线性 的加速比和 1 00 % 的效率。</p><p>弱扩展常常是比强扩展更真实的衡量值， 因为它更准确地反映 了我们用更大的机器做更多的工作的愿望。对于科学计算程序来说尤其如此，科学计算问题的规模很容易增加， 更大的问题规模直接就意味着更好地预测。不过， 还是有一些应用的规模不那么容易增加， 对于这样的 应用，强 扩展是更合适的。例如， 实时信号处 理应用所执行的工作量常常是由产生信号的物理传感器的属性决 定的。改变工 作总量需要用不同的物理传感器， 这不太实际或者不太必要。对于这类应用， 我们通常想要用并行来尽可能快地完成定量的工作。</p><p>练习题 12. 11 对于下表中的并行程序，填写空白处。假设使用强扩展。</p><table><thead><tr><th>线程 (t)</th><th>1</th><th>2</th><th>4</th></tr></thead><tbody><tr><td>核 (p )</td><td>1</td><td>2</td><td>4</td></tr><tr><td>运行时间 ( TP )</td><td>12</td><td>8</td><td>6</td></tr><tr><td>加速比 ( Sp )</td><td></td><td>1.5</td><td></td></tr><tr><td>效率 ( EP )</td><td>100%</td><td></td><td>50%</td></tr></tbody></table><p>12. 7 其他并发问题</p><p>你可能已经注意到了，一旦我们要求同步对共享数据的访问，那么事情就变得复杂得 多了。迄今为止，我 们已经看到了用千互斥和生产者－消费者同步的技术， 但 这仅仅是冰山一角。同步从根本上说是很难的问题， 它引 出 了 在普通的顺序程序中不会出现的问题。这一小节是关于你在写并发程序时需 要注意的一些问题的（非常不完整的）综述。为了让事情具体化，我们将以线程为例描述讨论。不过要记住，这些典型问题是任何类型的并发流 操作共享资源时都会出现的。</p><p>12. 7. 1 线程安全</p><p>当用线程编写程序时， 必须 小 心 地编写那些具有称为线程安全性 ( t h read s afe t y ) 属性的函数。一个函数被称为线程安 全的 ( t h read- s a fe ) , 当且仅当被多个并发线程反复地调用时，它 会 一 直 产 生正确的结果。如果一个函数不是线程安全的， 我们就说它是线程不安 全的 ( t h rea d- un s a fe ) 。</p><p>我们能够定义出四个（不相交的）线程不安全函数类：</p><p>笫 1 类： 不保护共享 变量的函数。我们在图 12-1 6 的 吐r e a d 函数中就已经遇到了这样的问 题，该 函数 对 一 个 未受保护的全局计数器变量加 1。将这类线程不安全函数变成线程安全的，相对而言比较容易： 利用像 P 和 V 操作这样的同步操作来保护共享的变量。这个方法的优点是在调 用程序中不需要做任何修改。缺点是同步操作将减慢程序的执行时间。</p><p>笫 2 类 ：保 持跨越多 个调 用的状态的 函数。一个伪随机数生成器是这类线程不安全函</p><p>数的简单例子。请参考图 1 2-37 中的伪随机数生成器程序包。r a n d 函数是线程不安全的， 因 为 当前调用的结果依赖于前次调用的中间结果。当调用 sr a nd 为r a nd 设置了一个种子后， 我们从一个单线程中反复地调用 r a nd , 能够预期得到一个可重复的随机数字序列。然而， 如果 多 线 程调用r a n d 函数 ， 这种假设就不再成立了。</p><p>code/cond rand.c</p><p>unsigned next_seed = 1;</p><p>3 I* rand - return pseudorandom integer in the range 0.. 32767 *I</p><p>4 unsigned rand(void)</p><p>6 next_seed = next_seed*1103515245 + 12543;</p><p>7 return (unsigned)(next_seed»16) % 32768;</p><p>10 I* srand - set the initial seed for rand() *I</p><p>11 void srand(unsigned new_seed)</p><p>12 {</p><p>13 next_seed = new_seed;</p><p>14 }</p><p>code/condrand.c</p><p>图 12-37 一个线程不安全的伪随机数生成器（基于 [ 61] )</p><p>使得像r a n d 这样的函数线程安全的唯一方式是重写它，使 得 它 不再使用任何 s 七a t i c</p><p>数据，而是依靠调用者在参数中传递状态信息。这样做的缺点是，程序员现在还要被迫修</p><p>改调用程序中的代码。在一个大的程序中，可能有成百上千个不同的调用位置，做这样的修改将是非常麻烦的，而且容易出错。</p><p>笫 3 类： 返回指向静 态 变 量的 指针的 函数。某些函数， 例如 c t i me 和 g e t h o s 亡</p><p>byname, 将计算结果放在一个 s ta tic 变量中，然 后返回一个指向这个变量的指针。如果我们从并发线程中调用这些函数，那么将可能发生灾难，因为正在被一个线程使用的结果会被另一个线程悄悄地覆盖了。</p><p>有两种方法来处理这类线程不安全函数。一种选择是重写函数，使得调用者传递存放结 果的变量的地址。这就消除了所有共享数据， 但是它要求程序员能够修改函数的源代码。</p><p>如果线程不安全函数是难以修改或不可能修改的（例如，代码非常复杂或是没有源代 码可用）， 那么另外一种选择就是使用加锁－复制( lock-a n d- co p y ) 技术。基本思想是将线程不安全函数与互斥锁联系起来。在每一个涸用位置，对互斥锁加锁，调用线程不安全函 数，将函数返回的结果复制到一个私有的内存位置，然后对互斥锁解锁。为了尽可能地减 少对调用者的修改，你应该定义一个线程安全的包装函数，它执行加锁－复制，然后通过 调用这个包装函数来取代所有对线程不安全函数的调用。例如， 图 12-38 给出了 c 巨 me 的一个线程安全的版本，利用的就是加锁－复制技术。</p><p>code/condctime-ts.c</p><p>char *ctime_ts(const time_t *timep, char *privatep)</p><p>2 {</p><p>3 char *sharedp;</p><p>4</p><p>5 P(&amp;mutex);</p><p>6 sharedp = ctime(timep);</p><p>7 strcpy(privatep, sharedp); I* Copy string from sha 工 ed to private *I</p><p>8 V(&amp;mutex);</p><p>9 return privatep;</p><p>10 }</p><p>code/condctime-ts.c</p><p>图 12-38 C 标准库函数 c t i me 的线程安全的包装函数。使用加锁－复制技术调用一个第3 类线程不安全函数</p><p>笫 4 类： 调用线程 不安 全函数的 函数。如果 函数 f 调用线程不安全函数 g , 那么 f 就是线程不安全的吗？ 不一定。如果 g 是第 2 类函数， 即依赖于跨越多次 调用的 状态， 那么</p><p>J 也是线程不安全的， 而且除了重写 g 以外， 没有什么办法。然而， 如果 g 是第 1 类或者</p><p>第 3 类函数， 那么只要你用一 个互斥锁保护调用位置和任何 得到的共享数据， J 仍 然可能是线程安全的。在图 1 2-38 中我们看到了一个这种情况很好的示例， 其中我们使用加锁－ 复制编写了一 个线程安全函数，它 调用了一个线程不安全的函数。</p><p>所有的函数</p><ol><li><p>7. 2 可重入性</p><p>有一类重要的线程安全函数，叫做可重入函数( ree n t ra nt function) , 其特点在于它们具有这样一种属性：当它们被多个线程调用时，不会引用任何共享数据。尽管线程安全和可重入有时会</p></li></ol><p>线程安全函数</p><p>三 线程不安全函数</p><p>（不正确地）被用做同义词，但是它们之间还是有 图 12-39 可重入函数、线程安全函数和线程</p><p>清晰的技术 差别， 值得留意。图 12-39 展示了可 不安全函数之间的集合关系</p><p>重入函数、线程安全函数和线程不安全函数之间的集合关系。所有函数的集合被划分成不 相交的线程安全和线程不安全函数集合。可重入函数集合是线程安全函数的一个真子集。 可重入函数通常要比不可重入的线程安全的函数高效一些，因为它们不需要同步操</p><p>作。更进一步来说，将 第 2 类线程不安全函数转化为线程安全函数的唯一方法就是重写它，使 之 变为可重入的。例如，图 1 2- 40 展 示了图 1 2-37 中 r a nd 函数的一个可重入的版本。关键思想是我们用一个调用者传递进来的指针取代了静态的 ne x t 变量。</p><p>code/condrand-r.c I* rand_r - return a pseudorandom integer on 0 .. 32767 *I</p><p>int rand_r(unsigned int *nextp)</p><p>｛</p><p>*nextp = *nextp * 1103515245 + 12345;</p><p>return (unsigned int)(*nextp / 65536) % 32768;</p><p>｝</p><p>codelcondrand-r.c</p><p>图 12-40 rand_r: 图 12-37 中的 r a nd 函数的可重入版本</p><p>检查某个函数的代码并先验地断定它是可重入的，这可能吗？不幸的是，不一定能这 样。如果所有的函数参数都是传值传递的（即没有指针），并且所有的数据引用都是本地的 自动栈变量（即没有引用静态或全局变量），那么函数就是显式 可 重入的 ( ex plicitl y reen­</p><p>trant), 也就是说，无论它是被如何调用的，都可以断言它是可重入的。</p><p>然而， 如果把假设放宽松一点 ，允 许显式可重入函数中一些参数是引用传递的（即允许它们传递指针），那 么 我们就得到了一个隐式可重入的 ( im plicitl y ree nt ra n t ) 函数，也 就是说，如果调用线程小心地传递指向非共享数据的指针，那么它是可重入的。例如，图 1 2-40 中的r a nd_r 函数就是隐式可重入的。</p><p>我们总是使用术语 可重入的 ( ree nt ra nt ) 既包括显式可重入函数也包括隐式可重入函数。然而，认 识 到 可重入性有时既是调用者也是被调用者的属性，并 不 只 是 被询用者单独的属性是非常重要的。</p><p>练习题 12 . 12 图 12-38 中的 ct ime_t s 函数是线程安全的，但不是可重入的。请解释说明。</p><p>1 2 . 7. 3 在线程化的程序中使用已存在的库函数</p><p>大多数 Lin u x 函数，包 括定义在标准 C 库中的函数（例如 ma l l o c 、 fr e e 、r e a l l o c 、</p><p>pr i n t f 和 s c a n f ) 都 是 线 程 安 全的，只 有一小部分是例外。图 1 2-41 列出了常见的例外。</p><p>（参考[ 110] 可以得到一个完整的列表。）s tr t o k 函数是一个已弃用的（不推荐使用）函数。 a s c t i me 、 c t i me 和 l oc a l t i me 函数 是 在 不同时间和数据格式间相互来回转换时经常使用的函数。ge t ho s t b yna me 、 g e t h o s t b ya d dr 和 i ne t _ n t oa 函数是已弃用的网络编程函数，已 经分别被可重入的 ge t a ddr i n f o 、ge t na me i n f o 和 i ne t _ nt o p 函数取代（见第 11 章）。除了 r a nd 和 s tr t o k 以外 ，所 有这些线程不安全函数都是第 3 类的，它 们 返 回 一 个 指向静态变量的指针。如果我们需要在一个线程化的程序中调用这些函数中的某一个，对 调用者来说最不惹麻烦的方法是加锁－复制。然而，加锁－复制方法有许多缺点。首先，额 外的同步降低了程序的速度。第二，像 g e t h o s t b yn a me 这样的函数返回指向复杂结构的结构的指针，要 复 制 整个结构层次，需 要 深层复制 ( dee p copy) 结构。第三，加 锁－复 制方法对像r a nd 这样依赖跨越调用的静态状态的第 2 类函数并不有效。</p><p>线程不安全函数 线程不安全类 Linux 线程安全版本</p><p>rand strtok asctime ctime</p><p>gethostbyaddr gethostbyname inet_ntoa localtime</p><p>rand_r strtok_r asctime_r ctime_r</p><p>gethostbyaddr_r gethostbyname_r</p><p>（无）</p><p>localtime_r</p><p>图12-4 1 常见的线程不安全的库函数</p><p>因此， L in u x 系统提供大多数线程不安全函数的可重入版本。可重入版本的名字总是以" r " 后缀结尾。例如， a s c 巨 me 的可重 入版本就叫做 a s c 巨 me _r 。我 们建议尽可能地使用这些函数。</p><h5 id=12-7-4-竞争>12. 7. 4 竞争
<a class=anchor href=#12-7-4-%e7%ab%9e%e4%ba%89>#</a></h5><p>当一个程序的正确性依赖于一个线程要在另一个线程到y达点之前到达它的控制流中的x 点时， 就会发生竞争( ra ce) 。通常发生竞争是因为程序员假定线程将按照某种特殊的轨迹线穿过执行状态空间， 而忘记了另一条准则规定：多 线程的程序必须对任何可行的轨迹线都正确工。作</p><p>例子是理解竞争本质的最简单的方法。让我们来 看看图 12-42 中的简单程序。主线程创建了四个对等线程， 并传递一个指向一个唯一的整数 ID 的指针到每个 线程。每个 对等线程复制它的参数中传递的 ID 到一个局部变量中（第22 行）， 然后输出一个包含这个 ID 的信息。它看上去足够简单，但是当我们在系统上运行这个程序时，我们得到以下不正确的结果：</p><p>linux> ./race</p><p>Hello from thread 1 Hello from thread 3 Hello from thread 2 Hello from thread 3</p><p>code/condrace.c</p><p>I* WARNING: This code is buggy! ＊／</p><p>#include &ldquo;csapp.h&rdquo;</p><p>#define N 4</p><p>void *thread(void *vargp); int main()</p><p>｛</p><p>pthread_t tid[N]; int i;</p><p>for (i = O; i &lt; N; i++) Pthread_create(&amp;tid[i],</p><p>for (i = O; i &lt; N; i++)</p><p>NULL, thread, &amp;i);</p><p>Pthread_join(tid[i], exit(O);</p><p>NULL);</p><p>图 1 2-42 一个具有竞争的程序</p><p>18</p><ol><li><p>I* Thread routine *I</p><ol><li><p>void *thread(void *vargp)</p><p>21 ｛</p></li></ol></li><li><p>int myid = *((int *)vargp);</p></li><li><p>printf(&ldquo;Hello from thread %d\n&rdquo;, myid);</p></li><li><p>return NULL;</p><p>25 ｝</p></li></ol><p>code/condrace.c</p><p>图 12- 42 （续）</p><p>问 题 是由每个对等线程和主线程之间的竞争引起的。你能发现这个竞争吗？ 下面是发生的 情况 。当主线程在第 1 3 行创建了一个对等线程，它 传递了一个指向本地栈变量 t 的指针。在此时，竞 争 出现在下一次在第 1 2 行对 1 加 1 和第 22 行参数的间接引用和赋值之间。如果对等线程在主线程执 行第 1 2 行对 t 加 1 之前就执行了第 22 行， 那么 my i d 变量就得到正确的 ID。否则，它 包含的就会是其他线程的 ID。令人惊慌的是， 我们是否得到正确的答案依赖千内核是如何调度线程 的执行的。在我们的 系统中它失败了 ， 但是在其他系统中，它可 能就能正确工作 ， 让程序员“幸福地” 察觉 不到程序的严重错误。</p><p>为了消除竞争，我 们可以动态地为每个整数 ID 分配一个独立的块， 并且传递给线程例程一个指向这个块的指针， 如图 1 2- 43 所示（第1 2 1 4 行）。请注意 线程例程必须释放这些块以避免内存泄漏。</p><p>code/condnorace.c</p><p>#include &ldquo;csapp.h&rdquo;</p><p>#define N 4</p><p>void *thread(void *vargp); int main()</p><p>｛</p><p>pthread_t tid[N]; inti, *ptr;</p><p>for (i = O; i &lt; N; i++) {</p><p>ptr = Malloc(sizeof(int));</p><p>*ptr = i;</p><p>Pthread_create(&amp;tid[i],</p><p>｝</p><p>NULL, thread, ptr);</p><p>for (i = O; i &lt; N; i++) Pthread_join(tid[i],</p><p>exit(O);</p><p>NULL);</p><p>I* Thread routine *I</p><p>void *thread(void *vargp)</p><p>｛</p><p>int myid = * ((int *)vargp) ; Free (vargp) ;</p><p>printf(&ldquo;Hello from thread %d\n&rdquo;, myid); return NULL;</p><p>｝</p><p>code/condnorace.c</p><p>图 12 -43 图 12-42 中程序的一个没有竞争的正确版本</p><p>当我们在系统上运行这个程序时，现在得到了正确的结果：</p><p>linux> ./norace Hello from thread 0 Hello from thread 1 Hello from thread 2 Hello from thread 3</p><p>练习题 12. 13 在图 12-43 中， 我们可能想 要在 主线程中的 第 1 4 行后立即 释放 巳分 配的内存块，而不是在对等线程中释放它。但是这会是个坏注意。为什么？</p><p>练习题 12. 14</p><ol><li>在图 12-43 中， 我们 通过 为每 个整数 ID 分配 一个 独 立的 块来消除竟争。 给出 一个不调用 ma l l o c 或者 f r e e 函数的不 同的 方 法。</li><li>这种方法的利弊是什么？</li></ol><p>12. 7. 5 死锁</p><p>信号量引 入了一种 潜在的令人厌恶的运行时错误， 叫做死锁 ( d eadlock ) , 它指的是一组线程被阻塞了，等待一个永远也不会为真的条件。进度图对于理解死锁是一个无价的工 具。例如，图 1 2-44 展示了一对用两个信号晕来实现互斥的线程的进程图。从 这幅图中， 我们能够得到一些关于死锁的重要知识：</p><p><img src=img/268364c4dd3b97f0c27857ff02797a3b.jpeg alt>线程2</p><p>V(s)</p><p>V(t)</p><p>P(s)</p><p>死锁区</p><h1 id=img01c11eb8a9ab4d7f84a33d5078a24e2bjpeg勹><img src=img/01c11eb8a9ab4d7f84a33d5078a24e2b.jpeg alt>勹"
<a class=anchor href=#img01c11eb8a9ab4d7f84a33d5078a24e2bjpeg%e5%8b%b9>#</a></h1><p>P(s)···P(t)··· V(s) · · ·V(t)</p><p>图12-44 一个会死锁的程序的进度图</p><p>线程1</p><ul><li><p>程序员使用 P 和 V 操作顺序不当， 以至于两个 信号量的禁止区域 重叠。如果某个执行轨迹线碰巧到达了死锁状态 d , 那么就不可能有进一步的进展了，因为重叠的禁止区域阻塞了每个合法方向上的进展。换句话说，程序死锁是因为每个线程都在等 待其他线程执行一个根不可能发 生的 V 操作。</p></li><li><p>重叠的禁止区域引起了一组称为死锁区域 ( d ead lo ck r eg io n ) 的状态。如果一个轨迹线碰巧到达了一个死锁区域中的状态，那么死锁就是不可避免的了。轨迹线可以进 入死锁区域，但是它们不可能离开。</p></li><li><p>死锁是一个相当困难的问题，因为它不总是可预测的。一些幸运的执行轨迹线将绕开死 锁区域，而其他的 将会陷入 这个区域。图 12-44展示了每种情况的一个示例。对于程序员来说， 这其中隐含的着实令人惊慌。你可以运行一个程序 1000 次不出任何问题，但是下一次它就死锁了。或者程序在一台机器上可能运行得很好，但 是 在另外 的 机 器 上就会死锁。最糟糕的是，错误常常是不可重复的，因为不同的执行有不同的轨迹线。</p><p>程序死锁有很多原因，要避免死锁一般而言是很困难的。然而，当使用二元信号量来 实现互斥时 ，如 图 1 2- 44 所示，你 可以应用下面的简单而有效的规则来避免死锁：</p><p>互斥锁加锁顺序规则： 给 定所有互斥操作的一个全序 ，如 果 每 个线程都是以一种顺序荻得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。</p><p>例如， 我们可以通过这样的方法来解决图 12-44 中的死锁问题： 在 每个线程中先对 s</p><p>加锁 ，然 后 再 对 t 加锁。图 12-45 展示了得到的进度图。</p><p>线程2</p></li></ul><p><img src=img/0945ce788e0c2f17402b2375ad5c76a4.png alt>V(s)</p><p>V(t)</p><p>P(t)</p><h1 id=勹->勹, ,
<a class=anchor href=#%e5%8b%b9->#</a></h1><p>· · · P (s) · ··P(t)··· V(s) · · ·V(t)</p><p>图 12 -45 一个无死锁程 序的进度图</p><p>线程1</p><p>心 练习题 12 . 15 思考下面的程序，它试图使用一对信号量来实现互斥。</p><table><thead><tr><th>初始时： 线程1: P(s);</th><th>s</th><th>=</th><th>1,</th><th>t = 0 . 线程2: P(s);</th></tr></thead><tbody><tr><td>V(s);</td><td></td><td></td><td></td><td>V(s);</td></tr><tr><td>P(t); V(t);</td><td></td><td></td><td></td><td>P(t); V(t);</td></tr></tbody></table><ol><li>画出这个程序的进度图。<ol><li>它总是会死锁吗？</li><li>如果是，那么对初始信号量的值做哪些简单的改变就能消除这种潜在的死锁呢？</li><li>画 出 得到 的无死锁程 序的进度图。</li></ol></li></ol><p>12. 8 小结</p><p>一个并发程序是由在时间上重叠的一组逻辑流组成的。在这 一章中， 我们学习了三种不同的构建并发程序的机制 ： 进程、1/ 0 多路复用和线程。我们以一个并发网络服务器作为贯穿全章的应用程序。</p><p>进程是由内核自动调度的，而且因为它们有各自独立的虚拟地址空间，所以要实现共享数据，必须 要有显式的 IPC 机制。事件驱动程 序创建它们自己的并发逻辑流， 这些逻辑流被模型化为状态机，用1/ 0 多路复用来显式 地调度这些 流。因 为程 序运行 在一个单一进程中 ， 所以在流之间 共享数据速度很快 而且很容易。线程是这些方法的混合 。同基千进程的 流一样， 线程也是由内 核自动调度的。同基千 I/ 0 多路复用的流一样 ， 线程是运行 在一个单一进程的上下 文中的 ，因 此可以快速而方便地共 享数据 。</p><p>无论哪种并发机制 ，同 步对共享数据的并 发访问 都是一个困难的问 题。提出对信号 量的 P 和 V 操作就是为了帮助解决这个问题。信号量操作可以用来提供对共享数据的互斥访问，也对诸如生产者－消费者 程序中有限缓 冲区和读者－写者系统中的共享对象这样的资源访 间进行调度。一个并发预线程化的 echo 服务器提供了信号 量使用场景的很好的例子。</p><p>并发也引入了其他一些困难的问题。被线程调用的 函数必须具有一种称为线 程安 全的属性。我们定义了四类线程不安全的函数，以及一些将它们变为线程安全的建议。可重入函数是线程安全函数的一个 真子集，它不访问任何共享数据。可重入函数通常比不可重入函数更为有效，因为它们不需要任何同步 原语。竞争和死锁是并发 程序中出 现的另一些 困难的间题。当程序员错误地假设逻辑流该 如何 调度时 ， 就会发生竞争。当一个流等待一个永远不会发生的事件时，就会产生死锁。</p><h4 id=参考文献说明>参考文献说明
<a class=anchor href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae%e8%af%b4%e6%98%8e>#</a></h4><p>信号蜇操作是 D咄s t ra 提出的 [ 31] 。进度图的概念是 Coff ma n [ 23] 提出的， 后来由 Ca rso n 和 R e yn­ olds [ 16] 形式化的 。Co ur tois 等人[ 25] 提出了读者－写者问题。操作系统教科 书更详 细地 描述了经典的同步问题， 例如哲学家进餐问 题、打睦睡的理发师问 题和吸烟者问 题 [ 102 , 106, 113] 。Buten hof 的书[ 15] 对 P o six 线程接口有全 面的描述。Birrell [ 7] 的论文对线程编程以 及线程编程中容易遇到的问 题做了很好的介绍。 R einde rs 的书[ 90] 描述了 C I C + + 库，简化了线 程化程序的设 计和实现。有一些 课本讲述了多核系统上并行编程的 基础知识 [ 47 , 71] 。P ug h 描述了 Ja va 线程通过内存进行交互的方式的缺陷，并提出了替代的内存模型 [ 88 ] 。G us tafso n 提出了替代强扩展的 弱扩展加速模型 [ 43] 。</p><h4 id=家庭作业>家庭作业
<a class=anchor href=#%e5%ae%b6%e5%ba%ad%e4%bd%9c%e4%b8%9a>#</a></h4><ul><li><p>12 16 编写 he ll o . c ( 图 12-13 ) 的一个版本， 它创建和回收 n 个可结 合的对等线程，其 中 n 是一个命令行参数。</p></li><li><p>12 17 A. 图 12-46 中的程序有一个 b ug 。要求线程睡眠一秒钟 ， 然后输出一 个字符串。然而 ， 当在 我们</p><p>的系统上运行它时 ，却 没有任何输 出。为什么？</p></li></ul><p>/• WA 邸 I NG: This code is bu 邸 ;y! •/</p><ol><li><p>#include &ldquo;csapp.h&rdquo;</p><ol><li><p>void•thread(void•vargp);</p><p>4</p><p>5 int main()</p><p>6 {</p><p>7 pthread_t tid;</p><p>8</p><p>9 Pthread_create(&amp;tid, NULL, thread, NULL);</p><p>10 exit(O);</p><p>11 }</p><p>12</p></li></ol></li><li><p>/• Thread routine•/</p></li><li><p>void•thread(void•vargp)</p><p>15 {</p></li><li><p>Sleep(1);</p></li><li><p>printf(&ldquo;Hello, world!\n&rdquo;);</p></li><li><p>return NULL;</p><p>19 }</p><p>code/condhellobug.c</p></li></ol><p>codelconclhellobug.c</p><p>图 12-46 练习题 12. 17 的有 bug 的程序</p><p>B. 你可以通过用两个 不同的 P th reads 函数调 用中的一个替代第 10 行中的 e x 让 函数来 改正这个错误。选哪一个呢？</p><ul><li><p>12. 18 用图 1 2-21 中的进度图， 将下面的 轨迹线分类 为安全或者不安全的。</p><p>A. H2 , L2 , U2 , H, , L1 , S2 , U 1 , S, , T1 , T2</p><p>B. H 2 , H1, L1 , U, , S1 , L 2, T, , U2, S 2 , T2</p><p>C. H1 , L1 , H 2 , L2, U2, S2, U, , S , , T1 , T2</p><p>•• 12 . 19 图 1 2- 2 6 中第一类读 者－写者问题的解答 给予 读者的是有些弱的优先级， 因为读者在离开它的临界区时，可能会重启一个正在等待的写者，而不是一个正在等待的读者。推导出一个解答，它给 予读者更强的优先级，当写者离开它的临界区的时候，如果有读者正在等待的话，就总是重启一 个正在等待的读者。</p><p>\* 12. 20 考虑读者－写者问题的一个更简单的变种 ，即 最多只有 N 个读者。推导 出一个解答 ，给 予读者和</p><p>写者同等的优先级，即等待中的读者和写者被赋予对资源访问的同等的机会。提示：你可以用一个计数信号蜇和一个互斥锁来解决这个问 题。</p><p>:: 12. 21 推导出第二类读者－写者问题的一个解答，在此写者的优先级高于读者。</p><p>•• 12. 22 检查一下你对 s e l e吐 函数的理 解，请 修改图 12-6 中的服务器， 使得它在主服务 器的每次迭代中最多只回送一个文本行。</p><p>•• 12. 23 图 1 2-8 中的事件驱动并 发 echo 服务器是 有缺陷的 ， 因为一个恶意的 客户端能够通过发送部分的文本行，使服务器拒绝为其他客户端服务。编写一个改进的服务器版本，使之能够非阻塞地处理 这些部分文本行。</p><ul><li><p>12. 24 RIO I/ 0 包中的 函数(1 0. 5 节）都是线程安全的 。它们也都是可重入函数吗？</p></li><li><p>12. 25 在图 1 2-28 中的预线程化的并发 echo 服务器中， 每个线程都调用 e c ho _ c nt 函数（图12-29 ) 。e c ho_c n t 是线程安全的吗？ 它是可重人的吗？为什么是或 为什么不是呢？</p><p>*/ 12. 26 用加锁－复制技术来实现 g e t ho s t b yna me 的 一个线程安全而又不 可重入 的版本， 称为 ge t hos t -</p><p>b yna me _ t s 。一个正确的解答是使用由互斥 锁保护的 ho s t e nt 结构的深层副本 。</p><p>• • 12. 27 一些网络编程的教科书建议用以下的方法来读 和写套接字 ： 和客户端交互之前 ， 在同一个打开的已连接套 接字描述符上 ，打开两个标 准 I/ 0 流， 一个用来读， 一个用来写 ：</p><p>FILE•fpin, •fpout;</p></li></ul></li></ul><p>fpin = fdopen(sockfd, &ldquo;r&rdquo;);</p><p>fpout = fdopen(sockfd, &ldquo;w&rdquo;);</p><p>当服务器完成和客户端的交互之后，像下面这样关闭两个流：</p><p>fclose(fpin); fclose(fpout);</p><p>然而，如果你试图在基千线程的并发服务器上尝试这种方式，将制造一个致命的竞争条件。请解释。</p><ul><li>12 28 在图 12-45 中，将 两个 V 操作的顺序交换 ， 对程序死锁是否 有影响？ 通过画出四 种可能情况的 进度图来证明你的答案：</li></ul><table><thead><tr><th>情况</th><th>l</th><th>情况</th><th>2</th><th>情况</th><th>3</th><th>情况</th><th>4</th></tr></thead><tbody><tr><td>线程 l</td><td>线程2</td><td>线程 1</td><td>线程2</td><td>线程 l</td><td>线程2</td><td>线程 l</td><td>线程2</td></tr><tr><td>P (s ) P(t)</td><td>P(s) P(t)</td><td>P(s) P(t)</td><td>P(s) P(t)</td><td>P(s) P(t )</td><td>P(s) P(t )</td><td>P(s) P(t)</td><td>P(s) P(t)</td></tr><tr><td>V(s)</td><td>V(s)</td><td>V(s)</td><td>V(t)</td><td>V(t)</td><td>V(s)</td><td>V(t)</td><td>V(t)</td></tr><tr><td>V(t)</td><td>V(t)</td><td>V(t)</td><td>V(s)</td><td>V(s)</td><td>V(t)</td><td>V(s)</td><td>V(s)</td></tr></tbody></table><ul><li>12. 29 下面的程序会死锁吗？为什么会或者为什么不会？</li></ul><p>初始时： a= 1, b = 1, c = 1</p><p>线程1 : 线程2 :</p><p>P(a); P(c);</p><p>P(b); P(b);</p><p>V(b); V(b);</p><p>P(c); V(c);</p><p>V(c);</p><p>V(a);</p><ul><li><p>12. 30 考虑下面这个会死锁的程序。</p><p>初始时： a= 1, b = 1, c = 1</p></li></ul><p>线程1 : 线程2: 线程3:</p><p>P(a); P(c); P(c);</p><p>P(b); P(b); V(c);</p><p>V(b); V(b); P(b);</p><p>P(c); V(c); P(a);</p><p>V(c); P(a); V(a);</p><p>V(a); V(a); V(b);</p><ol><li><p>列出每个线程同时占用的一对互斥锁。</p></li><li><p>如果 a &lt; b&lt; c , 那么哪个线程违背了互斥锁加锁顺序规则？</p></li><li><p>对于这些线程，指出一个新的保证不会发生死锁的加锁顺序。</p><p>*.* 12. 31 实现标准 I/ 0 函数 f ge t s 的一个版本，叫 做 t f ge t s , 假如它在 5 秒之内 没有从标 准输入 上接收到一个输入行，那么就超时，并返回 一个 NU LL 指针。你的函数应该实现在一个叫做 t f ge t s - pr oc . c 的包中，使用 进程、信号和非本地跳转 。它不应该使用 Linux 的 a l a rm 函数。使用图 12-47 中的驱动程序测试你的结果。</p></li></ol><p>1 #include &ldquo;csapp.h&rdquo;</p><p>2</p><p>3 char *tfgets (char *s, int size, FILE *stream);</p><p>4</p><p>5 int main()</p><p>6 {</p><p>7 char buf [MAXLINE] ;</p><p>8</p><p>9 if (tfgets(buf, MAXLINE, stdin) == NULL)</p><p>10 printf(&ldquo;BOOM!\n&rdquo;);</p><p>11 else</p><p>12 printf(&ldquo;o/.s&rdquo;, buf);</p><p>13</p><p>14 exit(O);</p><p>15 }</p><p>codelcond tfgets-main.c</p><p>code/contfdgets-main.c</p><p>图 12-47 家庭作业题 12. 31~12. 33 的驱动程序</p><p>*.* 12. 32 使用 s e l e c t 函数来实现练习题 12. 31 中 t f ge t s 函数的一个版本。你的 函数应该在一个叫做 t f ­ ge t s -s e l e c t . c 的包中实现。用练习题 12. 31 中的驱 动程序测试你的结果 。你可以假定标准输人被赋值为描述符 0。</p><p>·.· 12. 33 实现练习 题 12. 31 中 t f ge t s 函数的一个线程化的版本。你的函数应该在一个叫做 t f ge t s ­ t hr e a d . c 的包中实现。用练习题 12. 31 中的驱动程序测试你的结果。</p><p>·: 12. 34 编写一个 N X M 矩阵乘法核心函数的并行线程化版本。比较它的性能 与顺序的版本的性能。</p><p>·: 12. 35 实现一个基于进程的 T I NY Web 服务器的并发版本 。你的解答应该为每一个新的 连接请求创建一个新的子进程。使用一 个实际的 Web 浏览器来测试你的 解答。</p><ul><li>: 12. 36 实现一个基于 l/ 0 多路复用的 T IN Y Web 服务器的并 发版本。使用一个实际的 Web 浏览器来测试你的解答。</li></ul><dl><dt>** 12. 37 实现一个基于线程的 T INY Web 服务器的并发版本 。你的解答 应该为 每一个新的连接请求创建 一个新的线 程。使用一 个实际的 Web 浏览器来 测试你的 解答 。</dt><dd><p>: 12. 38 实现一个 T INY Web 服务器的并发预线 程化的 版本。你的解答应该 根据当前的 负载， 动态地增加或减少线 程的数目 。一个策略是当缓 冲区变满时 ， 将线程数晟 翻倍 ， 而当缓 冲区 变为空 时， 将线程数目 减半。使用一 个实际的 Web 浏览器来 测试你的 解答 。</p></dd></dl><p>:: 12. 39 Web 代理是 一个在 Web 服务器和浏览 器之间 扮演中间角色 的程序。浏 览器不是直接连接服务器以获取 网页， 而是与代理连接 ， 代理再将请求转发给服务器。当服 务器响 应代理 时， 代理将响应发送给浏览器。为了这个试验 ， 请你编写一个简单的可以过滤和记 录请求 的 Web 代理：</p><ol><li>试验的第一部分中 ， 你要建立以接收请求的代理， 分析 HT T P , 转发请求给服务 器， 并且返回结果给浏览 器。你的代理将所有请求 的 URL 记录在磁盘上 一个日志文件中 ，同时它还要阻塞所有对包含 在磁盘上一 个过滤文件 中的 URL 的请求。<ol><li><p>试验的第二部分中， 你要升级代理 ， 它通过派生一个独立的线程来处理每一个请求， 使得 代理能够一次处理多个打开的连接。当你的代理在等待远程服务器响应一个请求使它能服务于 一个浏览器时，它应该可以处理来自另一个浏览器未完成的请求。</p><p>使用一个 实际的 Web 浏览骈来 检验你的 解答。</p></li></ol></li></ol><p>练习题答案</p><p>12. 1 当父进 程派生子 进程时 ，它 得到一个已连接描 述符的副本， 并将相关文件 表中的引用计数从 1 增加到 2。当父进程关闭 它的描述符 副本时 ，引 用 计数就从 2 减少到 1。因为内 核不会关闭一个文件， 直到文件表中它的引用计数值 变为零 ， 所以子进程这边的 连接端将保持 打开。</p><p>12. 2 当一个 进程因为某种原因终止时 ，内 核 将关闭所有打开的 描述符。因此， 当子进 程退出时， 它的已连接文件描述符的副本也将被自动关闭。</p><p>12. 3 回想一下， 如果一个从描述符中读 一个字节的请求不 会阻塞， 那么这个描述符 就准备好 可以读 了。</p><p>假如 EOF 在一个描述符上为 真， 那么描述符也 准备好可读了 ， 因为读操作将立 即返回一个零返回码，表示 EOF。因此，键入 Ctrl+ D 会导致 s e l e c t 函数返回， 准备好的 集合中有描述符 0。</p><p>12. 4 因为变最 poo l . r e ad_ s e t 既作为输入参数 也作为输出 参数， 所以 我们在每一次调用 s e l e c t 之前都重新初始化它。在输入时 ， 它包含读集合 。在输出 ， 它包含准备好的 集合。</p><p>12. 5 因为线程运行在同一个进程中 ， 它们都共享相同 的描述符表。无论有多少线程使用这个已 连接描述符， 这个已 连接描述符的 文件表的引 用计数都等于 1。因此， 当我们用完它时， 一个 c l os e 操作就足以 释放与这个已 连接描述符 相关的内存资源了。</p><ol><li>6 这里的 主要的思 想是， 栈变址是私有的 ， 而全局和静态变扯是共享的。诸如 c nt 这样的 静态变量有点小麻烦， 因为共享是限制 在它们的函数范围内的一—召：这个例子中， 就是线程例程 。<ol><li>下面就是 这张表 ：</li></ol></li></ol><table><thead><tr><th>变量实例</th><th>被主线程引用？</th><th>被对等线程0引用？</th><th>被对等线程1引用？</th></tr></thead><tbody><tr><td>ptr</td><td>定曰</td><td>定曰</td><td>定曰</td></tr><tr><td>cnt</td><td>否</td><td>定曰</td><td>定曰</td></tr><tr><td>i . m</td><td>定曰</td><td>否</td><td>否</td></tr><tr><td>ms g s . m</td><td>是</td><td>是</td><td>定El</td></tr><tr><td>myid.pO</td><td>否</td><td>是</td><td>否</td></tr><tr><td>myi d . p l</td><td>否</td><td>否</td><td>是</td></tr></tbody></table><p>说明：</p><ul><li>p tr : 一个被主线程写 和被对等线程读的 全局变谜。<ul><li>c nt : 一个静态变储， 在内存中只有一个实例 ，被 两个对等线程读和写。<ul><li>i.m: 一个存储在主线程栈中的本 地自动变 釐。虽然它的 值被传递给对等线程，但 是对等线程也绝 不会在栈中引用它 ， 因此它不是 共享的。</li></ul></li></ul></li><li>msgs . m: 一个存储在 主线程栈中的 本地自动变量 ， 被两个对等线 程通过 p tr 间接地引用 。</li><li>myid. 0 和 my 过 . 1 : 一个本地自 动变量的实 例， 分别驻留在对等线 程 0 和线程 1 的栈中。<ol><li><p>变量 ptr 、c nt 和 ms g s 被多于一个线程引用， 因此它们是 共享的。</p><p>12. 7 这里的重要思想是，你不能假设当内核调度你的线程时会如何选择顺序。</p></li></ol></li></ul><p>变量 c nt 最终有一 个不正确的 值 1。</p><p>12. 8 这道题简单地测试你 对进度图中安全和不安 全轨迹线的理解。像 A 和 C 这样的轨迹线绕开了临界区，是安全的，会产生正确的结果。</p><p>A. H1, L1, U1 , S1, H , , L,, U , , S,, T,, Ti : 安 全 的</p><p>B. H, , L, , H1 , L1 , U1 , S1 , Ti , U, , S, , T, : 不 安 全 的</p><p>C. H, , H,, L, , U,, S,, Li , Ui, S 1 , T1 , T,: 安全的</p><p>12. 9 A.p=l, c=l, n> l : 是，互斥锁是需要的，因为生产者和消费者会并发地访间缓冲区。</p><ol><li><p>p=l, c = l , n=l, 不是， 在这种情况中 不需要互斥锁 信号量 ， 因为一个非空的缓 冲区就等千满的缓冲区。当缓冲区包含一个项目时，生产者就被阻塞了。当缓冲区为空时，消费者就被阻 塞了。所以 在任意时刻 ，只 有一个线 程可以访间缓 冲区 ， 因此不用互斥锁也能保证互斥 。</p></li><li><p>p>l, c>l, n=l: 不是， 在这种情况中 ， 也不需要互斥锁 ，原因 与前面一种情况相同。</p><p>12 10 假设一个特殊的 信号量实现为每一 个信号 量使用了 一个 LI FO 的线 程栈。当一个线程在 P 操作中阻塞在一个信号蜇 上，它的 ID 就被压入栈中 。类似地， V 操作从栈中弹出栈顶的线程 ID, 并重启这个线程。根据这个栈的实现，一个在它的临界区中的竞争的写者会简单地等待，直到在它释 放这个信号量之前另一个写 者阻塞 在这个信号 量上。在这种场景中， 当两个写者来回地传递控制权时， 正在等待的读者可能会永远地等待下去。</p><p>注意， 虽然用 FIF O 队列而不是用 LIFO 更符合直觉 ， 但是使用 LIFO 的栈也 是对的， 而且也没有违反 P 和 V 操作的语义。</p><p>12. 11 这道题简单地检查你对加速比和并行效率的理解：</p></li></ol><table><thead><tr><th>线程( t )</th><th>I</th><th>2</th><th>4</th></tr></thead><tbody><tr><td>核 (p )</td><td>I</td><td>2</td><td>4</td></tr><tr><td>运行时间( T,,)</td><td>12</td><td>8</td><td>6</td></tr><tr><td>加速比CSP )</td><td>I</td><td>1.5</td><td>2</td></tr><tr><td>效率&lt;EP )</td><td>100%</td><td>75%</td><td>50%</td></tr></tbody></table><p>12 . 12 ct i me—t s 函数不是可重入函数， 因为每次调用都共享相同的由 get hos tb yname 函数返回的 s t at i c 变量。然而， 它是线程安全的，因 为对共享变扯的访问是被 P 和 V 操作保护的， 因此是互斥的。</p><p>12. 13 如果在第 14 行调用了 p 七hr e a d _cr e a t e 之后， 我们立即释放块， 那么将引入一个新的竞争， 这次竞争发 生在主线程对 fr e e 的调用 和线程例程中第 24 行的赋值语句之间。</p><p>12. 14 A. 另一种方法是直接传递整数 i , 而不是传递一 个指向 1 的指针：</p><p>for Ci = 0; i &lt; N; i++)</p><p>Pthread_create(&amp;tid[i], NULL, thread, (void•)i);</p><p>在线程例程中 ，我们将参数强 制转换成一个 i nt 类型， 并将它赋值给 rnyi d : int myid = (int) vargp;</p><p>B. 优点是它通过消除对 ma l l o c 和 fr e e 的 调用降低了开销。一个明显的缺点是， 它假设指针至少和 i n t 一样大。即便 这种假设 对于所有的 现代系统来说都为真， 但是它对千那 些过去遗留下来的或今后的系统来说可能就不为真了。</p><p>12. 15 A. 原始的程序的 进度图如图 12-48 所示。</p><p>线程2</p><p>V(t)</p><p>P(t)</p><p>V(s)</p><p>勹(,)</p><p>t 的 禁止区</p><p>三 t 的禁止区</p><p>· · · P(s) .. ·V(s) ..·P(t) ..·V(t)</p><p>图 12- 48 一个有死锁的程序的进度图</p><p>线程1</p><ol><li>因为任何可行的轨迹最终都陷入死锁状态中，所以这个程序总是会死锁。</li><li>为了消除 潜在的死锁， 将二元信号蜇 t 初始化为 1 而不是 0。</li><li>改成后的程序的进度图 如图 12-49 所示。线程2</li></ol><p>V(t) 三</p><p>P(t)</p><p>V(s) 三</p><p>勹"'</p><p>· · ·P(s)··· V(s) · · · P(t) · · ·V(t)</p><p>图 12- 49 改正后的无死锁的程序的进度图</p><p>线程1</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#12-1-基千进程的并发编程>12. 1 基千进程的并发编程</a></li><li><a href=#5-用信号量同步线程>5 用信号量同步线程</a></li></ul></li><li><a href=#ctfil>CTfil</a><ul><li></li></ul></li></ul></li><li><a href=#img01c11eb8a9ab4d7f84a33d5078a24e2bjpeg勹><img src=img/01c11eb8a9ab4d7f84a33d5078a24e2b.jpeg alt>勹"</a></li><li><a href=#勹->勹, ,</a><ul><li><ul><li></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>