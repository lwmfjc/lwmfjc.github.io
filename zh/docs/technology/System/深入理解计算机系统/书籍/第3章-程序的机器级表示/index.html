<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="第 3 章
—- CH APTER 3

  程序的机器级表示
  #

计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写 存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集 和操作系 统遵循的 惯例， 经过一系列的 阶段生成 机器代码 。GCC C 语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后
GCC调用汇编 器和 链接器， 根据汇编代码生成可执行的机器代码。在本章中， 我们会近距离地观察机器代码，以及人类可读的表示 汇编代码。
当我们用高级语言 编程的时候（例如C 语言， Java 语言更是如此）， 机器屏蔽了 程序的 细节，即机器级的实现。与此相反，当用汇编代码编程的时候（就像早期的计算），程序员必须 指定程序用来执行计算的低级指令。高级语言提供的抽象级别比较高，大多数时候，在这种 抽象级别上工作效率会更高，也更可靠。编译器提供的类型检查能帮助我们发现许多程序错 误，并能够保证按照一致的方式来引用和处理数据。通常情况下，使用现代的优化编译器产 生的代码至少与一个熟练的汇编语言程序员手工编写的代码一样有效。最大的优点是，用高级 语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关的。 那么为什么我们还要花时间学习机器代码呢？即使编译器承担了生成汇编代码的大部
分工作，对千严谨的程序员来说，能够阅读和理解汇编代码仍是一项很重要的技能。以适 当的命令行选项调用编译器，编译器就会产生一个以汇编代码形式表示的输出文件。通过 阅读这些汇编代码，我们能够理解编译器的优化能力，并分析代码中隐含的低效率。就像 我们将在 第 5 章中体会到的那样， 试图最大化一 段关键代码性能的程序员 ， 通常会尝试源代码的各种形式，每次编译并检查产生的汇编代码，从而了解程序将要运行的效率如何。 此外，也有些时候，高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为。例 如，第 12 章会讲到，用线程包写并 发程序时 ，了 解不同的线程是如何共享程序数 据或保持数据私有的，以及准确知道如何在哪里访问共享数据，都是很重要的。这些信息在机器代码 级是可见的。另外再举一个例子，程序遭受攻击（使得恶意软件侵扰系统）的许多方式中，都涉及程序存储运行时控制信息的方式的细节。许多攻击利用了系统程序中的漏洞重写信息， 从而获得了系统的控制权。了解这些漏洞是如何出现的，以及如何防御它们，需要具备程序 机器级表示的知识。程序员学习汇编代码的需求随着时间的推移也发生了变化，开始时要求 程序员能直接用汇编语言编写程序，现在则要求他们能够阅读和理解编译器产生的代码。
在本章 中， 我们 将详细学习一 种特别的 汇编语 言，了 解如何将 C 程序编译成这种形式的机器代码。阅读编译器产生的汇编代码，需要具备的技能不同千手工编写汇编代码。我 们必须 了解典型的编译器在将 C 程序结 构变换成 机器代码时所做的转换 。相对于 C 代码表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换 慢速操作，甚至将递归计算变换成迭代计算。源代码与对应的汇编代码的关系通常不太容易 理解一一－就像要拼出的 拼图与盒子上图 片的设 计有点不太一样。这是一种逆向 工程 ( reverse engineering ) — 通过研究 系统 和逆向工作， 来试图了解系统 的创建过程。 在这里， 系统是一个机器产生的汇编语言程序，而不是由人设计的某个东西。这简化了逆向工程的任"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"><meta property="og:site_name" content="随记"><meta property="og:title" content="随记"><meta property="og:description" content="第 3 章
—- CH APTER 3
程序的机器级表示 # 计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写 存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集 和操作系 统遵循的 惯例， 经过一系列的 阶段生成 机器代码 。GCC C 语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后
GCC调用汇编 器和 链接器， 根据汇编代码生成可执行的机器代码。在本章中， 我们会近距离地观察机器代码，以及人类可读的表示 汇编代码。
当我们用高级语言 编程的时候（例如C 语言， Java 语言更是如此）， 机器屏蔽了 程序的 细节，即机器级的实现。与此相反，当用汇编代码编程的时候（就像早期的计算），程序员必须 指定程序用来执行计算的低级指令。高级语言提供的抽象级别比较高，大多数时候，在这种 抽象级别上工作效率会更高，也更可靠。编译器提供的类型检查能帮助我们发现许多程序错 误，并能够保证按照一致的方式来引用和处理数据。通常情况下，使用现代的优化编译器产 生的代码至少与一个熟练的汇编语言程序员手工编写的代码一样有效。最大的优点是，用高级 语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关的。 那么为什么我们还要花时间学习机器代码呢？即使编译器承担了生成汇编代码的大部
分工作，对千严谨的程序员来说，能够阅读和理解汇编代码仍是一项很重要的技能。以适 当的命令行选项调用编译器，编译器就会产生一个以汇编代码形式表示的输出文件。通过 阅读这些汇编代码，我们能够理解编译器的优化能力，并分析代码中隐含的低效率。就像 我们将在 第 5 章中体会到的那样， 试图最大化一 段关键代码性能的程序员 ， 通常会尝试源代码的各种形式，每次编译并检查产生的汇编代码，从而了解程序将要运行的效率如何。 此外，也有些时候，高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为。例 如，第 12 章会讲到，用线程包写并 发程序时 ，了 解不同的线程是如何共享程序数 据或保持数据私有的，以及准确知道如何在哪里访问共享数据，都是很重要的。这些信息在机器代码 级是可见的。另外再举一个例子，程序遭受攻击（使得恶意软件侵扰系统）的许多方式中，都涉及程序存储运行时控制信息的方式的细节。许多攻击利用了系统程序中的漏洞重写信息， 从而获得了系统的控制权。了解这些漏洞是如何出现的，以及如何防御它们，需要具备程序 机器级表示的知识。程序员学习汇编代码的需求随着时间的推移也发生了变化，开始时要求 程序员能直接用汇编语言编写程序，现在则要求他们能够阅读和理解编译器产生的代码。
在本章 中， 我们 将详细学习一 种特别的 汇编语 言，了 解如何将 C 程序编译成这种形式的机器代码。阅读编译器产生的汇编代码，需要具备的技能不同千手工编写汇编代码。我 们必须 了解典型的编译器在将 C 程序结 构变换成 机器代码时所做的转换 。相对于 C 代码表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换 慢速操作，甚至将递归计算变换成迭代计算。源代码与对应的汇编代码的关系通常不太容易 理解一一－就像要拼出的 拼图与盒子上图 片的设 计有点不太一样。这是一种逆向 工程 ( reverse engineering ) — 通过研究 系统 和逆向工作， 来试图了解系统 的创建过程。 在这里， 系统是一个机器产生的汇编语言程序，而不是由人设计的某个东西。这简化了逆向工程的任"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Index | 随记</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://lwmfjc.github.io/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/><link rel=stylesheet href=/book.min.8cec3a17310cf1804783c64adc1262d2887f4c1c55a3b42660027130b0b10b7e.css integrity="sha256-jOw6FzEM8YBHg8ZK3BJi0oh/TBxVo7QmYAJxMLCxC34=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.116c08a0e278612b9931254024f1e81f0e1af56fce17c3ba69107cbf0c18a85a.js integrity="sha256-EWwIoOJ4YSuZMSVAJPHoHw4a9W/OF8O6aRB8vwwYqFo=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>随记</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><span>文化</span><ul><li><input type=checkbox id=section-7250d6792296ec189294f493afb55cab class=toggle>
<label for=section-7250d6792296ec189294f493afb55cab class="flex justify-between"><a role=button>史记</a></label><ul><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/001%E7%AC%AC%E4%B8%80%E5%8D%B7%E4%BA%94%E5%B8%9D%E6%9C%AC%E7%BA%AA%E7%AC%AC%E4%B8%80/>001第一卷五帝本纪第一</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/002%E7%AC%AC%E4%BA%8C%E5%8D%B7%E5%A4%8F%E6%9C%AC%E7%BA%AA%E7%AC%AC%E4%BA%8C/>002第二卷夏本纪第二</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/003%E7%AC%AC%E4%B8%89%E5%8D%B7%E6%AE%B7%E6%9C%AC%E7%BA%AA%E7%AC%AC%E4%B8%89/>003第三卷殷本纪第三</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/004%E7%AC%AC%E5%9B%9B%E5%8D%B7%E5%91%A8%E6%9C%AC%E7%BA%AA%E7%AC%AC%E5%9B%9B/>004第四卷周本纪第四</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/005%E7%AC%AC%E4%BA%94%E5%8D%B7%E7%A7%A6%E6%9C%AC%E7%BA%AA%E7%AC%AC%E4%BA%94/>005第五卷秦本纪第五</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/006%E7%AC%AC%E5%85%AD%E5%8D%B7%E7%A7%A6%E5%A7%8B%E7%9A%87%E6%9C%AC%E7%BA%AA%E7%AC%AC%E5%85%AD/>006第六卷秦始皇本纪第六</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/007%E7%AC%AC%E4%B8%83%E5%8D%B7%E9%A1%B9%E7%BE%BD%E6%9C%AC%E7%BA%AA%E7%AC%AC%E4%B8%83/>007第七卷项羽本纪第七</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/008%E7%AC%AC%E5%85%AB%E5%8D%B7%E9%AB%98%E7%A5%96%E6%9C%AC%E7%BA%AA%E7%AC%AC%E5%85%AB/>008第八卷高祖本纪第八</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/009%E7%AC%AC%E4%B9%9D%E5%8D%B7%E5%90%95%E5%A4%AA%E5%90%8E%E6%9C%AC%E7%BA%AA%E7%AC%AC%E4%B9%9D/>009第九卷吕太后本纪第九</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/010%E7%AC%AC%E5%8D%81%E5%8D%B7%E5%AD%9D%E6%96%87%E6%9C%AC%E7%BA%AA%E7%AC%AC%E5%8D%81/>010第十卷孝文本纪第十</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/011%E7%AC%AC%E5%8D%81%E4%B8%80%E5%8D%B7%E5%AD%9D%E6%99%AF%E6%9C%AC%E7%BA%AA%E7%AC%AC%E5%8D%81%E4%B8%80/>011第十一卷孝景本纪第十一</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/012%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%8D%B7%E5%AD%9D%E6%AD%A6%E6%9C%AC%E7%BA%AA%E7%AC%AC%E5%8D%81%E4%BA%8C/>012第十二卷孝武本纪第十二</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/013%E7%AC%AC%E5%8D%81%E4%B8%89%E5%8D%B7%E5%90%B4%E5%A4%AA%E4%BC%AF%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%B8%80/>013第十三卷吴太伯世家第一</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/014%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%8D%B7%E9%BD%90%E5%A4%AA%E5%85%AC%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%BA%8C/>014第十四卷齐太公世家第二</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/015%E7%AC%AC%E5%8D%81%E4%BA%94%E5%8D%B7%E9%B2%81%E5%91%A8%E5%85%AC%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%B8%89/>015第十五卷鲁周公世家第三</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/016%E7%AC%AC%E5%8D%81%E5%85%AD%E5%8D%B7%E7%87%95%E5%8F%AC%E5%85%AC%E4%B8%96%E5%AE%B6%E7%AC%AC%E5%9B%9B/>016第十六卷燕召公世家第四</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/017%E7%AC%AC%E5%8D%81%E4%B8%83%E5%8D%B7%E7%AE%A1%E8%94%A1%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%BA%94/>017第十七卷管蔡世家第五</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/018%E7%AC%AC%E5%8D%81%E5%85%AB%E5%8D%B7%E9%99%88%E6%9D%9E%E4%B8%96%E5%AE%B6%E7%AC%AC%E5%85%AD/>018第十八卷陈杞世家第六</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/019%E7%AC%AC%E5%8D%81%E4%B9%9D%E5%8D%B7%E5%8D%AB%E5%BA%B7%E5%8F%94%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%B8%83/>019第十九卷卫康叔世家第七</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/020%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%8D%B7%E5%AE%8B%E5%BE%AE%E5%AD%90%E4%B8%96%E5%AE%B6%E7%AC%AC%E5%85%AB/>020第二十卷宋微子世家第八</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/021%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E5%8D%B7%E6%99%8B%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%B9%9D/>021第二十一卷晋世家第九</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/022%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%8D%B7%E6%A5%9A%E4%B8%96%E5%AE%B6%E7%AC%AC%E5%8D%81/>022第二十二卷楚世家第十</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/023%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E5%8D%B7%E8%B6%8A%E7%8E%8B%E5%8F%A5%E8%B7%B5%E4%B8%96%E5%AE%B6%E7%AC%AC%E5%8D%81%E4%B8%80/>023第二十三卷越王句践世家第十一</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/024%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%8D%B7%E9%83%91%E4%B8%96%E5%AE%B6%E7%AC%AC%E5%8D%81%E4%BA%8C/>024第二十四卷郑世家第十二</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/025%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E5%8D%B7%E8%B5%B5%E4%B8%96%E5%AE%B6%E7%AC%AC%E5%8D%81%E4%B8%89/>025第二十五卷赵世家第十三</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/026%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E5%8D%B7%E9%AD%8F%E4%B8%96%E5%AE%B6%E7%AC%AC%E5%8D%81%E5%9B%9B/>026第二十六卷魏世家第十四</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/027%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E5%8D%B7%E9%9F%A9%E4%B8%96%E5%AE%B6%E7%AC%AC%E5%8D%81%E4%BA%94/>027第二十七卷韩世家第十五</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/028%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E5%8D%B7%E7%94%B0%E6%95%AC%E4%BB%B2%E5%AE%8C%E4%B8%96%E5%AE%B6%E7%AC%AC%E5%8D%81%E5%85%AD/>028第二十八卷田敬仲完世家第十六</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/029%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D%E5%8D%B7%E5%AD%94%E5%AD%90%E4%B8%96%E5%AE%B6%E7%AC%AC%E5%8D%81%E4%B8%83/>029第二十九卷孔子世家第十七</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/030%E7%AC%AC%E4%B8%89%E5%8D%81%E5%8D%B7%E9%99%88%E6%B6%89%E4%B8%96%E5%AE%B6%E7%AC%AC%E5%8D%81%E5%85%AB/>030第三十卷陈涉世家第十八</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/031%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80%E5%8D%B7%E5%A4%96%E6%88%9A%E4%B8%96%E5%AE%B6%E7%AC%AC%E5%8D%81%E4%B9%9D/>031第三十一卷外戚世家第十九</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/032%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%8C%E5%8D%B7%E6%A5%9A%E5%85%83%E7%8E%8B%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%BA%8C%E5%8D%81/>032第三十二卷楚元王世家第二十</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/033%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%89%E5%8D%B7%E8%8D%86%E7%87%95%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80/>033第三十三卷荆燕世家第二十一</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/034%E7%AC%AC%E4%B8%89%E5%8D%81%E5%9B%9B%E5%8D%B7%E9%BD%90%E6%82%BC%E6%83%A0%E7%8E%8B%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C/>034第三十四卷齐悼惠王世家第二十二</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/035%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%8D%B7%E8%90%A7%E7%9B%B8%E5%9B%BD%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89/>035第三十五卷萧相国世家第二十三</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/036%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AD%E5%8D%B7%E6%9B%B9%E7%9B%B8%E5%9B%BD%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B/>036第三十六卷曹相国世家第二十四</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/037%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%8D%B7%E7%95%99%E4%BE%AF%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94/>037第三十七卷留侯世家第二十五</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/038%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AB%E5%8D%B7%E9%99%88%E4%B8%9E%E7%9B%B8%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD/>038第三十八卷陈丞相世家第二十六</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/039%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B9%9D%E5%8D%B7%E7%BB%9B%E4%BE%AF%E5%91%A8%E5%8B%83%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83/>039第三十九卷绛侯周勃世家第二十七</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/040%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%8D%B7%E6%A2%81%E5%AD%9D%E7%8E%8B%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB/>040第四十卷梁孝王世家第二十八</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/041%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%80%E5%8D%B7%E4%BA%94%E5%AE%97%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D/>041第四十一卷五宗世家第二十九</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/042%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%8D%B7%E4%B8%89%E7%8E%8B%E4%B8%96%E5%AE%B6%E7%AC%AC%E4%B8%89%E5%8D%81/>042第四十二卷三王世家第三十</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/043%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%8D%B7%E4%BC%AF%E5%A4%B7%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B8%80/>043第四十三卷伯夷列传第一</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/044%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%8D%B7%E7%AE%A1%E6%99%8F%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%8C/>044第四十四卷管晏列传第二</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/045%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%94%E5%8D%B7%E8%80%81%E5%AD%90%E9%9F%A9%E9%9D%9E%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B8%89/>045第四十五卷老子韩非列传第三</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/046%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E5%8D%B7%E5%8F%B8%E9%A9%AC%E7%A9%B0%E8%8B%B4%E5%88%97%E4%BC%A0%E7%AC%AC%E5%9B%9B/>046第四十六卷司马穰苴列传第四</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/047%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%8D%B7%E5%AD%99%E5%AD%90%E5%90%B4%E8%B5%B7%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%94/>047第四十七卷孙子吴起列传第五</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/048%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AB%E5%8D%B7%E4%BC%8D%E5%AD%90%E8%83%A5%E5%88%97%E4%BC%A0%E7%AC%AC%E5%85%AD/>048第四十八卷伍子胥列传第六</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/049%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%8D%B7%E4%BB%B2%E5%B0%BC%E5%BC%9F%E5%AD%90%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B8%83/>049第四十九卷仲尼弟子列传第七</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/050%E7%AC%AC%E4%BA%94%E5%8D%81%E5%8D%B7%E5%95%86%E5%90%9B%E5%88%97%E4%BC%A0%E7%AC%AC%E5%85%AB/>050第五十卷商君列传第八</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/051%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%80%E5%8D%B7%E8%8B%8F%E7%A7%A6%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B9%9D/>051第五十一卷苏秦列传第九</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/052%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E5%8D%B7%E5%BC%A0%E4%BB%AA%E5%88%97%E4%BC%A0%E7%AC%AC%E5%8D%81/>052第五十二卷张仪列传第十</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/053%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%8D%B7%E6%A8%97%E9%87%8C%E5%AD%90%E7%94%98%E8%8C%82%E5%88%97%E4%BC%A0%E7%AC%AC%E5%8D%81%E4%B8%80/>053第五十三卷樗里子甘茂列传第十一</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/054%E7%AC%AC%E4%BA%94%E5%8D%81%E5%9B%9B%E5%8D%B7%E7%A9%B0%E4%BE%AF%E5%88%97%E4%BC%A0%E7%AC%AC%E5%8D%81%E4%BA%8C/>054第五十四卷穰侯列传第十二</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/055%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%94%E5%8D%B7%E7%99%BD%E8%B5%B7%E7%8E%8B%E7%BF%A6%E5%88%97%E4%BC%A0%E7%AC%AC%E5%8D%81%E4%B8%89/>055第五十五卷白起王翦列传第十三</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/056%E7%AC%AC%E4%BA%94%E5%8D%81%E5%85%AD%E5%8D%B7%E5%AD%9F%E5%AD%90%E8%8D%80%E5%8D%BF%E5%88%97%E4%BC%A0%E7%AC%AC%E5%8D%81%E5%9B%9B/>056第五十六卷孟子荀卿列传第十四</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/057%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%83%E5%8D%B7%E5%AD%9F%E5%B0%9D%E5%90%9B%E5%88%97%E4%BC%A0%E7%AC%AC%E5%8D%81%E4%BA%94/>057第五十七卷孟尝君列传第十五</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/058%E7%AC%AC%E4%BA%94%E5%8D%81%E5%85%AB%E5%8D%B7%E5%B9%B3%E5%8E%9F%E5%90%9B%E8%99%9E%E5%8D%BF%E5%88%97%E4%BC%A0%E7%AC%AC%E5%8D%81%E5%85%AD/>058第五十八卷平原君虞卿列传第十六</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/059%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B9%9D%E5%8D%B7%E9%AD%8F%E5%85%AC%E5%AD%90%E5%88%97%E4%BC%A0%E7%AC%AC%E5%8D%81%E4%B8%83/>059第五十九卷魏公子列传第十七</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/060%E7%AC%AC%E5%85%AD%E5%8D%81%E5%8D%B7%E6%98%A5%E7%94%B3%E5%90%9B%E5%88%97%E4%BC%A0%E7%AC%AC%E5%8D%81%E5%85%AB/>060第六十卷春申君列传第十八</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/061%E7%AC%AC%E5%85%AD%E5%8D%81%E4%B8%80%E5%8D%B7%E8%8C%83%E9%9B%8E%E8%94%A1%E6%B3%BD%E5%88%97%E4%BC%A0%E7%AC%AC%E5%8D%81%E4%B9%9D/>061第六十一卷范雎蔡泽列传第十九</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/062%E7%AC%AC%E5%85%AD%E5%8D%81%E4%BA%8C%E5%8D%B7%E4%B9%90%E6%AF%85%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%8C%E5%8D%81/>062第六十二卷乐毅列传第二十</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/063%E7%AC%AC%E5%85%AD%E5%8D%81%E4%B8%89%E5%8D%B7%E5%BB%89%E9%A2%87%E8%94%BA%E7%9B%B8%E5%A6%82%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80/>063第六十三卷廉颇蔺相如列传第二十一</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/064%E7%AC%AC%E5%85%AD%E5%8D%81%E5%9B%9B%E5%8D%B7%E7%94%B0%E5%8D%95%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C/>064第六十四卷田单列传第二十二</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/065%E7%AC%AC%E5%85%AD%E5%8D%81%E4%BA%94%E5%8D%B7%E9%B2%81%E4%BB%B2%E8%BF%9E%E9%82%B9%E9%98%B3%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89/>065第六十五卷鲁仲连邹阳列传第二十三</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/066%E7%AC%AC%E5%85%AD%E5%8D%81%E5%85%AD%E5%8D%B7%E5%B1%88%E5%8E%9F%E8%B4%BE%E7%94%9F%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B/>066第六十六卷屈原贾生列传第二十四</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/067%E7%AC%AC%E5%85%AD%E5%8D%81%E4%B8%83%E5%8D%B7%E5%90%95%E4%B8%8D%E9%9F%A6%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94/>067第六十七卷吕不韦列传第二十五</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/068%E7%AC%AC%E5%85%AD%E5%8D%81%E5%85%AB%E5%8D%B7%E5%88%BA%E5%AE%A2%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD/>068第六十八卷刺客列传第二十六</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/070%E7%AC%AC%E4%B8%83%E5%8D%81%E5%8D%B7%E8%92%99%E6%81%AC%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB/>070第七十卷蒙恬列传第二十八</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/071%E7%AC%AC%E4%B8%83%E5%8D%81%E4%B8%80%E5%8D%B7%E5%BC%A0%E8%80%B3%E9%99%88%E9%A6%80%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D/>071第七十一卷张耳陈馀列传第二十九</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/072%E7%AC%AC%E4%B8%83%E5%8D%81%E4%BA%8C%E5%8D%B7%E9%AD%8F%E8%B1%B9%E5%BD%AD%E8%B6%8A%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B8%89%E5%8D%81/>072第七十二卷魏豹彭越列传第三十</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/073%E7%AC%AC%E4%B8%83%E5%8D%81%E4%B8%89%E5%8D%B7%E9%BB%A5%E5%B8%83%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80/>073第七十三卷黥布列传第三十一</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/074%E7%AC%AC%E4%B8%83%E5%8D%81%E5%9B%9B%E5%8D%B7%E6%B7%AE%E9%98%B4%E4%BE%AF%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%8C/>074第七十四卷淮阴侯列传第三十二</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/075%E7%AC%AC%E4%B8%83%E5%8D%81%E4%BA%94%E5%8D%B7%E9%9F%A9%E4%BF%A1%E5%8D%A2%E7%BB%BE%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%89/>075第七十五卷韩信卢绾列传第三十三</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/076%E7%AC%AC%E4%B8%83%E5%8D%81%E5%85%AD%E5%8D%B7%E7%94%B0%E5%84%8B%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B8%89%E5%8D%81%E5%9B%9B/>076第七十六卷田儋列传第三十四</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/077%E7%AC%AC%E4%B8%83%E5%8D%81%E4%B8%83%E5%8D%B7%E6%A8%8A%E9%83%A6%E6%BB%95%E7%81%8C%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94/>077第七十七卷樊郦滕灌列传第三十五</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/078%E7%AC%AC%E4%B8%83%E5%8D%81%E5%85%AB%E5%8D%B7%E5%BC%A0%E4%B8%9E%E7%9B%B8%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AD/>078第七十八卷张丞相列传第三十六</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/079%E7%AC%AC%E4%B8%83%E5%8D%81%E4%B9%9D%E5%8D%B7%E9%83%A6%E7%94%9F%E9%99%86%E8%B4%BE%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83/>079第七十九卷郦生陆贾列传第三十七</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/080%E7%AC%AC%E5%85%AB%E5%8D%81%E5%8D%B7%E5%82%85%E9%9D%B3%E8%92%AF%E6%88%90%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AB/>080第八十卷傅靳蒯成列传第三十八</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/081%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B8%80%E5%8D%B7%E5%88%98%E6%95%AC%E5%8F%94%E5%AD%99%E9%80%9A%E5%88%97%E4%BC%A0%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B9%9D/>081第八十一卷刘敬叔孙通列传第三十九</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/082%E7%AC%AC%E5%85%AB%E5%8D%81%E4%BA%8C%E5%8D%B7%E5%AD%A3%E5%B8%83%E6%A0%BE%E5%B8%83%E5%88%97%E4%BC%A0%E7%AC%AC%E5%9B%9B%E5%8D%81/>082第八十二卷季布栾布列传第四十</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/083%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B8%89%E5%8D%B7%E8%A2%81%E7%9B%8E%E6%99%81%E9%94%99%E5%88%97%E4%BC%A0%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%80/>083第八十三卷袁盎晁错列传第四十一</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/084%E7%AC%AC%E5%85%AB%E5%8D%81%E5%9B%9B%E5%8D%B7%E5%BC%A0%E9%87%8A%E4%B9%8B%E5%86%AF%E5%94%90%E5%88%97%E4%BC%A0%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C/>084第八十四卷张释之冯唐列传第四十二</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/085%E7%AC%AC%E5%85%AB%E5%8D%81%E4%BA%94%E5%8D%B7%E4%B8%87%E7%9F%B3%E5%BC%A0%E5%8F%94%E5%88%97%E4%BC%A0%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89/>085第八十五卷万石张叔列传第四十三</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/086%E7%AC%AC%E5%85%AB%E5%8D%81%E5%85%AD%E5%8D%B7%E7%94%B0%E5%8F%94%E5%88%97%E4%BC%A0%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B/>086第八十六卷田叔列传第四十四</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/087%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B8%83%E5%8D%B7%E6%89%81%E9%B9%8A%E4%BB%93%E5%85%AC%E5%88%97%E4%BC%A0%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%94/>087第八十七卷扁鹊仓公列传第四十五</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/088%E7%AC%AC%E5%85%AB%E5%8D%81%E5%85%AB%E5%8D%B7%E5%90%B4%E7%8E%8B%E6%BF%9E%E5%88%97%E4%BC%A0%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD/>088第八十八卷吴王濞列传第四十六</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/089%E7%AC%AC%E5%85%AB%E5%8D%81%E4%B9%9D%E5%8D%B7%E9%AD%8F%E5%85%B6%E6%AD%A6%E5%AE%89%E4%BE%AF%E5%88%97%E4%BC%A0%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83/>089第八十九卷魏其武安侯列传第四十七</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/090%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%8D%B7%E9%9F%A9%E9%95%BF%E5%AD%BA%E5%88%97%E4%BC%A0%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AB/>090第九十卷韩长孺列传第四十八</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/091%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%80%E5%8D%B7%E6%9D%8E%E5%B0%86%E5%86%9B%E5%88%97%E4%BC%A0%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D/>091第九十一卷李将军列传第四十九</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/092%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%BA%8C%E5%8D%B7%E5%8C%88%E5%A5%B4%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%94%E5%8D%81/>092第九十二卷匈奴列传第五十</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/093%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%89%E5%8D%B7%E5%8D%AB%E5%B0%86%E5%86%9B%E9%AA%A0%E9%AA%91%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%80/>093第九十三卷卫将军骠骑列传第五十一</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/094%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%9B%9B%E5%8D%B7%E5%B9%B3%E6%B4%A5%E4%BE%AF%E4%B8%BB%E7%88%B6%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C/>094第九十四卷平津侯主父列传第五十二</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/095%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%BA%94%E5%8D%B7%E5%8D%97%E8%B6%8A%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89/>095第九十五卷南越列传第五十三</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/096%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%85%AD%E5%8D%B7%E4%B8%9C%E8%B6%8A%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%94%E5%8D%81%E5%9B%9B/>096第九十六卷东越列传第五十四</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/097%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B8%83%E5%8D%B7%E6%9C%9D%E9%B2%9C%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%94/>097第九十七卷朝鲜列传第五十五</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/098%E7%AC%AC%E4%B9%9D%E5%8D%81%E5%85%AB%E5%8D%B7%E8%A5%BF%E5%8D%97%E5%A4%B7%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%94%E5%8D%81%E5%85%AD/>098第九十八卷西南夷列传第五十六</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/099%E7%AC%AC%E4%B9%9D%E5%8D%81%E4%B9%9D%E5%8D%B7%E5%8F%B8%E9%A9%AC%E7%9B%B8%E5%A6%82%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%83/>099第九十九卷司马相如列传第五十七</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/100%E7%AC%AC%E4%B8%80%E7%99%BE%E5%8D%B7%E6%B7%AE%E5%8D%97%E8%A1%A1%E5%B1%B1%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%94%E5%8D%81%E5%85%AB/>100第一百卷淮南衡山列传第五十八</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/101%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%80%E5%8D%B7%E5%BE%AA%E5%90%8F%E5%88%97%E4%BC%A0%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B9%9D/>101第一百零一卷循吏列传第五十九</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/102%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E4%BA%8C%E5%8D%B7%E6%B1%B2%E9%83%91%E5%88%97%E4%BC%A0%E7%AC%AC%E5%85%AD%E5%8D%81/>102第一百零二卷汲郑列传第六十</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/103%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%89%E5%8D%B7%E5%84%92%E6%9E%97%E5%88%97%E4%BC%A0%E7%AC%AC%E5%85%AD%E5%8D%81%E4%B8%80/>103第一百零三卷儒林列传第六十一</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/104%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E5%9B%9B%E5%8D%B7%E9%85%B7%E5%90%8F%E5%88%97%E4%BC%A0%E7%AC%AC%E5%85%AD%E5%8D%81%E4%BA%8C/>104第一百零四卷酷吏列传第六十二</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/105%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E4%BA%94%E5%8D%B7%E5%A4%A7%E5%AE%9B%E5%88%97%E4%BC%A0%E7%AC%AC%E5%85%AD%E5%8D%81%E4%B8%89/>105第一百零五卷大宛列传第六十三</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/106%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E5%85%AD%E5%8D%B7%E6%B8%B8%E4%BE%A0%E5%88%97%E4%BC%A0%E7%AC%AC%E5%85%AD%E5%8D%81%E5%9B%9B/>106第一百零六卷游侠列传第六十四</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/107%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B8%83%E5%8D%B7%E4%BD%9E%E5%B9%B8%E5%88%97%E4%BC%A0%E7%AC%AC%E5%85%AD%E5%8D%81%E4%BA%94/>107第一百零七卷佞幸列传第六十五</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/108%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E5%85%AB%E5%8D%B7%E6%BB%91%E7%A8%BD%E5%88%97%E4%BC%A0%E7%AC%AC%E5%85%AD%E5%8D%81%E5%85%AD/>108第一百零八卷滑稽列传第六十六</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/109%E7%AC%AC%E4%B8%80%E7%99%BE%E9%9B%B6%E4%B9%9D%E5%8D%B7%E6%97%A5%E8%80%85%E5%88%97%E4%BC%A0%E7%AC%AC%E5%85%AD%E5%8D%81%E4%B8%83/>109第一百零九卷日者列传第六十七</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/110%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%8D%B7%E9%BE%9F%E7%AD%96%E5%88%97%E4%BC%A0%E7%AC%AC%E5%85%AD%E5%8D%81%E5%85%AB/>110第一百一十卷龟策列传第六十八</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/111%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%80%E5%8D%B7%E8%B4%A7%E6%AE%96%E5%88%97%E4%BC%A0%E7%AC%AC%E5%85%AD%E5%8D%81%E4%B9%9D/>111第一百一十一卷货殖列传第六十九</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/112%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%BA%8C%E5%8D%B7%E5%A4%AA%E5%8F%B2%E5%85%AC%E8%87%AA%E5%BA%8F%E7%AC%AC%E4%B8%83%E5%8D%81/>112第一百一十二卷太史公自序第七十</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/113%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%89%E5%8D%B7%E7%A4%BC%E4%B9%A6%E7%AC%AC%E4%B8%80/>113第一百一十三卷礼书第一</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/114%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%9B%9B%E5%8D%B7%E4%B9%90%E4%B9%A6%E7%AC%AC%E4%BA%8C/>114第一百一十四卷乐书第二</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/115%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%BA%94%E5%8D%B7%E5%BE%8B%E4%B9%A6%E7%AC%AC%E4%B8%89/>115第一百一十五卷律书第三</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/116%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%85%AD%E5%8D%B7%E5%8E%86%E4%B9%A6%E7%AC%AC%E5%9B%9B/>116第一百一十六卷历书第四</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/117%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B8%83%E5%8D%B7%E5%A4%A9%E5%AE%98%E4%B9%A6%E7%AC%AC%E4%BA%94/>117第一百一十七卷天官书第五</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/118%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E5%85%AB%E5%8D%B7%E5%B0%81%E7%A6%85%E4%B9%A6%E7%AC%AC%E5%85%AD/>118第一百一十八卷封禅书第六</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/119%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%80%E5%8D%81%E4%B9%9D%E5%8D%B7%E6%B2%B3%E6%B8%A0%E4%B9%A6%E7%AC%AC%E4%B8%83/>119第一百一十九卷河渠书第七</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/120%E7%AC%AC%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E5%8D%B7%E5%B9%B3%E5%87%86%E4%B9%A6%E7%AC%AC%E5%85%AB/>120第一百二十卷平准书第八</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/121%E7%AC%AC%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E4%B8%80%E5%8D%B7%E6%8A%A5%E4%BB%BB%E5%AE%89%E4%B9%A6/>121第一百二十一卷报任安书</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/122%E7%AC%AC%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%8D%B7%E4%B8%89%E4%BB%A3%E4%B8%96%E8%A1%A8%E7%AC%AC%E4%B8%80%E8%A1%A8%E7%95%A5/>122第一百二十二卷三代世表第一（表略）</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/123%E7%AC%AC%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E4%B8%89%E5%8D%B7%E5%8D%81%E4%BA%8C%E8%AF%B8%E4%BE%AF%E5%B9%B4%E8%A1%A8%E7%AC%AC%E4%BA%8C%E8%A1%A8%E7%95%A5/>123第一百二十三卷十二诸侯年表第二（表略）</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/124%E7%AC%AC%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E5%9B%9B%E5%8D%B7%E5%85%AD%E5%9B%BD%E5%B9%B4%E8%A1%A8%E7%AC%AC%E4%B8%89%E8%A1%A8%E7%95%A5/>124第一百二十四卷六国年表第三（表略）</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/125%E7%AC%AC%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E4%BA%94%E5%8D%B7%E7%A7%A6%E6%A5%9A%E4%B9%8B%E9%99%85%E6%9C%88%E8%A1%A8%E7%AC%AC%E5%9B%9B%E8%A1%A8%E7%95%A5/>125第一百二十五卷秦楚之际月表第四（表略）</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/126%E7%AC%AC%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E5%85%AD%E5%8D%B7%E6%B1%89%E5%85%B4%E4%BB%A5%E6%9D%A5%E8%AF%B8%E4%BE%AF%E5%B9%B4%E8%A1%A8%E7%AC%AC%E4%BA%94%E8%A1%A8%E7%95%A5/>126第一百二十六卷汉兴以来诸侯年表第五（表略）</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/127%E7%AC%AC%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E4%B8%83%E5%8D%B7%E9%AB%98%E7%A5%96%E5%8A%9F%E8%87%A3%E4%BE%AF%E8%80%85%E5%B9%B4%E8%A1%A8%E7%AC%AC%E5%85%AD%E8%A1%A8%E7%95%A5/>127第一百二十七卷高祖功臣侯者年表第六（表略）</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/128%E7%AC%AC%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E5%85%AB%E5%8D%B7%E6%83%A0%E6%99%AF%E9%97%B4%E4%BE%AF%E8%80%85%E5%B9%B4%E8%A1%A8%E7%AC%AC%E4%B8%83%E8%A1%A8%E7%95%A5/>128第一百二十八卷惠景间侯者年表第七（表略）</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/129%E7%AC%AC%E4%B8%80%E7%99%BE%E4%BA%8C%E5%8D%81%E4%B9%9D%E5%8D%B7%E5%BB%BA%E5%85%83%E4%BB%A5%E6%9D%A5%E4%BE%AF%E8%80%85%E5%B9%B4%E8%A1%A8%E7%AC%AC%E5%85%AB%E8%A1%A8%E7%95%A5/>129第一百二十九卷建元以来侯者年表第八（表略）</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/130%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E5%8D%B7%E5%BB%BA%E5%85%83%E4%BB%A5%E6%9D%A5%E7%8E%8B%E5%AD%90%E4%BE%AF%E8%80%85%E5%B9%B4%E8%A1%A8%E7%AC%AC%E4%B9%9D%E8%A1%A8%E7%95%A5/>130第一百三十卷建元以来王子侯者年表第九（表略）</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/131%E7%AC%AC%E4%B8%80%E7%99%BE%E4%B8%89%E5%8D%81%E4%B8%80%E5%8D%B7%E6%B1%89%E5%85%B4%E4%BB%A5%E6%9D%A5%E5%B0%86%E7%9B%B8%E5%90%8D%E8%87%A3%E5%B9%B4%E8%A1%A8%E7%AC%AC%E5%8D%81%E8%A1%A8%E7%95%A5/>131第一百三十一卷汉兴以来将相名臣年表第十（表略）</a></li><li><a href=/zh/docs/culture/%E5%8F%B2%E8%AE%B0/000%E5%8F%B8%E9%A9%AC%E8%BF%81%E7%9A%84%E7%94%9F%E5%B9%B3%E5%92%8C%E8%91%97%E4%BD%9C/>司马迁的生平和著作</a></li></ul></li><li><input type=checkbox id=section-18fde80c90250c72545c5f504b8f609a class=toggle>
<label for=section-18fde80c90250c72545c5f504b8f609a class="flex justify-between"><a role=button>孫子新注</a></label><ul><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/01%E8%A8%88%E7%AF%87/>01計篇</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/02%E4%BD%9C%E6%88%B0%E7%AF%87/>02作戰篇</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/03%E8%AC%80%E6%94%BB%E7%AF%87/>02作戰篇</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/04%E5%BD%A2%E7%AF%87/>04形篇</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/05%E5%8B%A2%E7%AF%87/>05勢篇</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/06%E8%99%9A%E5%AF%A6%E7%AF%87/>06虚實篇</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/07%E8%BB%8D%E7%88%AD%E7%AF%87/>07軍爭篇</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/08%E4%B9%9D%E8%AE%8A%E7%AF%87/>08九變篇</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/09%E8%A1%8C%E8%BB%8D%E7%AF%87/>09行軍篇</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/10%E5%9C%B0%E5%BD%A2%E7%AF%87/>10地形篇</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/11%E4%B9%9D%E5%9C%B0%E7%AF%87/>11九地篇</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/12%E7%81%AB%E6%94%BB%E7%AF%87/>12火攻篇</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/13%E7%94%A8%E9%96%93%E7%AF%87/>13用間篇</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/%E7%89%88%E6%9D%83/>版权</a></li><li><a href=/zh/docs/culture/%E5%AD%AB%E5%AD%90%E6%96%B0%E6%B3%A8/%E5%8F%83%E8%80%83%E6%9B%B8%E7%9B%AE/>參考書目</a></li></ul></li><li><input type=checkbox id=section-ad0fe4bf3e016d8699659caece6c7816 class=toggle>
<label for=section-ad0fe4bf3e016d8699659caece6c7816 class="flex justify-between"><a role=button>易经</a></label><ul><li><input type=checkbox id=section-2aed3d829b0cad8a9881f15ad9c8f868 class=toggle>
<label for=section-2aed3d829b0cad8a9881f15ad9c8f868 class="flex justify-between"><a role=button>解读易经 傅佩荣</a></label><ul><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/00a%E5%89%8D%E8%A8%80%E4%B8%80_%E6%98%93%E7%BB%8F%E8%BF%99%E6%9C%AC%E4%B9%A6/>00a前言一_易经这本书</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/00b%E5%89%8D%E8%A8%80%E4%BA%8C_%E6%98%93%E7%BB%8F%E7%9A%84%E9%AD%85%E5%8A%9B/>00b前言二_易经的魅力</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/01%E4%B9%BE%E5%8D%A6/>01乾卦䷀</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/02%E5%9D%A4%E5%8D%A6/>02坤卦䷁</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/03%E5%B1%AF%E5%8D%A6/>03屯卦䷂</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/04%E8%92%99%E5%8D%A6/>04蒙卦䷃</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/05%E9%9C%80%E5%8D%A6/>05需卦䷄</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/06%E8%AE%BC%E5%8D%A6/>06讼卦䷅</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/07%E5%B8%88%E5%8D%A6/>07师卦䷆</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/08%E6%AF%94%E5%8D%A6/>08比卦䷇</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/09%E5%B0%8F%E7%95%9C%E5%8D%A6/>09小畜卦䷈</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/10%E5%B1%A5%E5%8D%A6/>10履卦䷉</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/11%E6%B3%B0%E5%8D%A6/>11泰卦䷊</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/12%E5%90%A6%E5%8D%A6/>12否卦䷋</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/13%E5%90%8C%E4%BA%BA%E5%8D%A6/>13同人卦䷌</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/14%E5%A4%A7%E6%9C%89%E5%8D%A6/>14大有卦䷍</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/15%E8%B0%A6%E5%8D%A6/>15谦卦䷎</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/16%E8%B1%AB%E5%8D%A6/>16豫卦䷏</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/17%E9%9A%8F%E5%8D%A6/>17随卦䷐</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/18%E8%9B%8A%E5%8D%A6/>18蛊卦䷑</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/19%E4%B8%B4%E5%8D%A6/>19临卦䷒</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/20%E8%A7%82%E5%8D%A6/>20观卦䷓</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/21%E5%99%AC%E5%97%91%E5%8D%A6/>21噬嗑卦䷔</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/22%E8%B4%B2%E5%8D%A6/>22贲卦䷕</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/23%E5%89%A5%E5%8D%A6/>23剥卦䷖</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/24%E5%A4%8D%E5%8D%A6/>24复卦䷗</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/25%E6%97%A0%E5%A6%84%E5%8D%A6/>25无妄卦䷘</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/26%E5%A4%A7%E7%95%9C%E5%8D%A6/>26大畜卦䷙</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/27%E9%A2%90%E5%8D%A6/>27颐卦䷚</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/28%E5%A4%A7%E8%BF%87%E5%8D%A6/>28大过卦䷛</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/29%E4%B9%A0%E5%9D%8E%E5%8D%A6/>29习坎卦䷜</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/30%E7%A6%BB%E5%8D%A6/>30离卦䷝</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/31%E5%92%B8%E5%8D%A6/>31咸卦䷞</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/32%E6%81%92%E5%8D%A6/>32恒卦䷟</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/33%E9%81%81%E5%8D%A6/>33遁卦䷠</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/34%E5%A4%A7%E5%A3%AE%E5%8D%A6/>34大壮卦䷡</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/35%E6%99%8B%E5%8D%A6/>35晋卦䷢</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/36%E6%98%8E%E5%A4%B7%E5%8D%A6/>36明夷卦䷣</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/37%E5%AE%B6%E4%BA%BA%E5%8D%A6/>37家人卦䷤</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/38%E7%9D%BD%E5%8D%A6/>38睽卦䷥</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/39%E8%B9%87%E5%8D%A6/>39蹇卦䷦</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/40%E8%A7%A3%E5%8D%A6/>40解卦䷧</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/41%E6%8D%9F%E5%8D%A6/>41损卦䷨</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/42%E7%9B%8A%E5%8D%A6/>42益卦䷩</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/43%E5%A4%AC%E5%8D%A6/>43夬卦䷪</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/44%E5%A7%A4%E5%8D%A6/>44姤卦䷫</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/45%E8%90%83%E5%8D%A6/>45萃卦䷬</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/46%E5%8D%87%E5%8D%A6/>46升卦䷭</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/47%E5%9B%B0%E5%8D%A6/>47困卦䷮</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/48%E4%BA%95%E5%8D%A6/>48井卦䷯</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/49%E9%9D%A9%E5%8D%A6/>49革卦䷰</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/50%E9%BC%8E%E5%8D%A6/>50鼎卦䷱</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/51%E9%9C%87%E5%8D%A6/>51震卦䷲</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/52%E8%89%AE%E5%8D%A6/>52艮卦䷳</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/53%E6%B8%90%E5%8D%A6/>53渐卦䷴</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/54%E5%BD%92%E5%A6%B9%E5%8D%A6/>54归妹卦䷵</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/55%E4%B8%B0%E5%8D%A6/>55丰卦䷶</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/56%E6%97%85%E5%8D%A6/>56旅卦䷷</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/57%E5%B7%BD%E5%8D%A6/>57巽卦䷸</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/58%E5%85%91%E5%8D%A6/>58兑卦䷹</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/59%E6%B6%A3%E5%8D%A6/>59涣卦䷺</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/60%E8%8A%82%E5%8D%A6/>60节卦䷻</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/61%E4%B8%AD%E5%AD%9A%E5%8D%A6/>61中孚卦䷼</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/62%E5%B0%8F%E8%BF%87%E5%8D%A6/>62小过卦䷽</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/63%E6%97%A2%E6%B5%8E%E5%8D%A6/>63既济卦䷾</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/64%E6%9C%AA%E6%B5%8E%E5%8D%A6/>64未济卦䷿</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E8%A7%A3%E8%AF%BB%E6%98%93%E7%BB%8F_%E5%82%85%E4%BD%A9%E8%8D%A3/%E5%8D%A6-%E7%AC%A6%E5%8F%B7/>卦 符号</a></li></ul></li><li><input type=checkbox id=section-bff051e0f1f25e769ddc2a9bb543289a class=toggle>
<label for=section-bff051e0f1f25e769ddc2a9bb543289a class="flex justify-between"><a role=button>易经的智慧 傅佩荣</a></label><ul><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E6%99%BA%E6%85%A7_%E5%82%85%E4%BD%A9%E8%8D%A3/00%E5%B0%81%E9%9D%A2_%E8%87%AA%E5%BA%8F_%E7%9B%AE%E5%BD%95/>00封面_自序_目录</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E6%99%BA%E6%85%A7_%E5%82%85%E4%BD%A9%E8%8D%A3/01%E7%AC%AC%E4%B8%80%E7%AB%A0_%E6%98%93%E7%BB%8F%E6%98%AF%E4%BB%80%E4%B9%88/>01第一章_易经是什么</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E6%99%BA%E6%85%A7_%E5%82%85%E4%BD%A9%E8%8D%A3/02%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E6%98%93%E7%BB%8F%E7%9A%84%E7%94%B1%E6%9D%A5/>02第二章_易经的由来</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E6%99%BA%E6%85%A7_%E5%82%85%E4%BD%A9%E8%8D%A3/03%E7%AC%AC%E4%B8%89%E7%AB%A0_%E6%98%93%E7%BB%8F%E7%9A%84%E5%8D%A6%E8%B1%A1/>03第三章_易经的卦象</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E6%99%BA%E6%85%A7_%E5%82%85%E4%BD%A9%E8%8D%A3/04%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E8%87%AA%E5%BC%BA%E4%B8%8D%E6%81%AF_%E4%B9%BE%E5%8D%A6/>04第四章_自强不息_乾卦</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E6%99%BA%E6%85%A7_%E5%82%85%E4%BD%A9%E8%8D%A3/05%E7%AC%AC%E4%BA%94%E7%AB%A0_%E5%8E%9A%E5%BE%B7%E8%BD%BD%E7%89%A9_%E5%9D%A4%E5%8D%A6/>05第五章_厚德载物_坤卦</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E6%99%BA%E6%85%A7_%E5%82%85%E4%BD%A9%E8%8D%A3/06%E7%AC%AC%E5%85%AD%E7%AB%A0_%E9%9D%9E%E5%90%89%E5%88%99%E5%88%A9_%E8%B0%A6%E5%8D%A6/>06第六章_非吉则利_谦卦</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E6%99%BA%E6%85%A7_%E5%82%85%E4%BD%A9%E8%8D%A3/07%E7%AC%AC%E4%B8%83%E7%AB%A0_%E9%9D%A2%E5%AF%B9%E5%9B%B0%E5%A2%83%E7%9A%84%E6%99%BA%E6%85%A7_%E5%B1%AF%E5%8D%A6%E4%B9%A0%E5%9D%8E%E5%8D%A6%E8%B9%87%E5%8D%A6%E5%9B%B0%E5%8D%A6/>07第七章_面对困境的智慧_屯卦、习坎卦、蹇卦、困卦</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E6%99%BA%E6%85%A7_%E5%82%85%E4%BD%A9%E8%8D%A3/08%E7%AC%AC%E5%85%AB%E7%AB%A0_%E8%87%AA%E6%B1%82%E5%A4%9A%E7%A6%8F%E7%9A%84%E6%96%B9%E6%B3%95_%E6%8D%9F%E5%8D%A6%E5%B1%A5%E5%8D%A6%E4%BA%95%E5%8D%A6%E9%BC%8E%E5%8D%A6/>08第八章_自求多福的方法_损卦、履卦、井卦、鼎卦</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E6%99%BA%E6%85%A7_%E5%82%85%E4%BD%A9%E8%8D%A3/09%E7%AC%AC%E4%B9%9D%E7%AB%A0_%E6%98%93%E7%BB%8F%E7%9A%84%E7%8E%B0%E4%BB%A3%E6%84%8F%E4%B9%89/>09第九章_易经的现代意义</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E6%99%BA%E6%85%A7_%E5%82%85%E4%BD%A9%E8%8D%A3/10%E7%AC%AC%E5%8D%81%E7%AB%A0_%E6%98%93%E7%BB%8F%E9%97%AE%E7%AD%94%E5%BD%95/>10第十章_易经问答录</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E6%99%BA%E6%85%A7_%E5%82%85%E4%BD%A9%E8%8D%A3/11%E9%99%84%E5%BD%95_%E5%8F%A4%E4%BA%BA%E7%94%A8%E6%98%93%E7%BB%8F%E5%8D%A0%E5%8D%A6%E9%A2%84%E6%B5%8B%E7%A4%BA%E4%BE%8B/>11附录_古人用《易经》占卦预测示例</a></li></ul></li><li><input type=checkbox id=section-e1196fb3cb63ebecd110473024b09a8e class=toggle>
<label for=section-e1196fb3cb63ebecd110473024b09a8e class="flex justify-between"><a role=button>易经的奥秘 曾仕强</a></label><ul><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/00%E7%89%88%E6%9D%83%E4%BF%A1%E6%81%AF/>00版权信息</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/01%E7%AC%AC%E4%B8%80%E9%9B%86_%E4%BD%95%E4%B8%BA%E6%98%93%E7%BB%8F/>01第一集_何为《易经》</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/02%E7%AC%AC%E4%BA%8C%E9%9B%86_%E4%BD%95%E4%B8%BA%E9%98%B4%E9%98%B3/>02第二集_何为阴阳</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/03%E7%AC%AC%E4%B8%89%E9%9B%86_%E4%BD%95%E4%B8%BA%E5%A4%AA%E6%9E%81/>03第三集_何为太极</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/04%E7%AC%AC%E5%9B%9B%E9%9B%86_%E4%BD%95%E4%B8%BA%E5%85%AB%E5%8D%A6/>04第四集_何为八卦</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/05%E7%AC%AC%E4%BA%94%E9%9B%86_%E5%85%AB%E5%8D%A6%E6%88%90%E5%9B%BE/>05第五集_八卦成图</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/06%E7%AC%AC%E5%85%AD%E9%9B%86_%E4%B8%89%E7%94%BB%E4%B8%BA%E5%8D%A6/>06第六集_三画为卦</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/07%E7%AC%AC%E4%B8%83%E9%9B%86_%E6%98%93%E6%9C%89%E4%B8%89%E4%B9%89/>07第七集_易有三义</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/08%E7%AC%AC%E5%85%AB%E9%9B%86_%E5%96%84%E6%98%93%E4%B8%8D%E5%8D%9C/>08第八集_善易不卜</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/09%E7%AC%AC%E4%B9%9D%E9%9B%86_%E5%8D%A6%E6%9C%89%E4%BD%95%E7%94%A8/>09第九集_卦有何用</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/10%E7%AC%AC%E5%8D%81%E9%9B%86_%E6%98%93%E7%BB%8F%E7%9A%84%E6%80%9D%E7%BB%B4/>10第十集_易经的思维</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/11%E7%AC%AC%E5%8D%81%E4%B8%80%E9%9B%86_%E8%A7%A3%E8%AF%BB%E4%B9%BE%E5%8D%A6/>11第十一集_解读乾卦</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/12%E7%AC%AC%E5%8D%81%E4%BA%8C%E9%9B%86_%E8%A7%A3%E8%AF%BB%E5%9D%A4%E5%8D%A6/>12第十二集_解读坤卦</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/13%E7%AC%AC%E5%8D%81%E4%B8%89%E9%9B%86_%E4%B9%BE%E5%9D%A4%E4%BA%BA%E7%94%9F/>13第十三集_乾坤人生</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/14%E7%AC%AC%E5%8D%81%E5%9B%9B%E9%9B%86_%E7%A0%B4%E8%A7%A3%E5%91%BD%E8%BF%90/>14第十四集_破解命运</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/15%E7%AC%AC%E5%8D%81%E4%BA%94%E9%9B%86_%E6%98%93%E7%BB%8F%E4%B8%8E%E5%AE%B6%E5%BA%AD/>15第十五集_易经与家庭</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/16%E7%AC%AC%E5%8D%81%E5%85%AD%E9%9B%86_%E5%8D%A6%E7%9A%84%E8%B1%A1%E6%95%B0%E7%90%86/>16第十六集_卦的象数理</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/17%E7%AC%AC%E5%8D%81%E4%B8%83%E9%9B%86_%E8%B6%85%E8%B6%8A%E5%90%89%E5%87%B6/>17第十七集_超越吉凶</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/18%E7%AC%AC%E5%8D%81%E5%85%AB%E9%9B%86_%E5%9B%9E%E5%88%B0%E5%8E%9F%E7%82%B9/>18第十八集_回到原点</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/19%E9%99%84%E5%BD%95/>19附录</a></li></ul></li><li><input type=checkbox id=section-49026efbf3a2ca66d1b2eff303f6a89a class=toggle>
<label for=section-49026efbf3a2ca66d1b2eff303f6a89a class="flex justify-between"><a role=button>用易经的观点读透三国演义 曾仕强</a></label><ul><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E7%94%A8%E6%98%93%E7%BB%8F%E7%9A%84%E8%A7%82%E7%82%B9%E8%AF%BB%E9%80%8F%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89_%E6%9B%BE%E4%BB%95%E5%BC%BA/00%E7%AE%80%E4%BB%8B_%E5%89%8D%E8%A8%80/>00简介_前言</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E7%94%A8%E6%98%93%E7%BB%8F%E7%9A%84%E8%A7%82%E7%82%B9%E8%AF%BB%E9%80%8F%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89_%E6%9B%BE%E4%BB%95%E5%BC%BA/01%E7%AC%AC%E4%B8%80%E9%83%A8_%E6%A1%83%E5%9B%AD%E4%B8%89%E7%BB%93%E4%B9%89/>01第一部_桃园三结义</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E7%94%A8%E6%98%93%E7%BB%8F%E7%9A%84%E8%A7%82%E7%82%B9%E8%AF%BB%E9%80%8F%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89_%E6%9B%BE%E4%BB%95%E5%BC%BA/02%E7%AC%AC%E4%BA%8C%E9%83%A8_%E8%AF%B8%E8%91%9B%E4%BA%AE%E4%B8%8B%E5%B1%B1/>02第二部_诸葛亮下山</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E7%94%A8%E6%98%93%E7%BB%8F%E7%9A%84%E8%A7%82%E7%82%B9%E8%AF%BB%E9%80%8F%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89_%E6%9B%BE%E4%BB%95%E5%BC%BA/03%E7%AC%AC%E4%B8%89%E9%83%A8_%E5%A4%A7%E6%84%8F%E5%A4%B1%E8%8D%86%E5%B7%9E/>03第三部_大意失荆州</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E7%94%A8%E6%98%93%E7%BB%8F%E7%9A%84%E8%A7%82%E7%82%B9%E8%AF%BB%E9%80%8F%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89_%E6%9B%BE%E4%BB%95%E5%BC%BA/04%E7%AC%AC%E5%9B%9B%E9%83%A8_%E4%B8%89%E5%9B%BD%E5%BD%92%E4%B8%80%E7%BB%9F/>04第四部_三国归一统</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E7%94%A8%E6%98%93%E7%BB%8F%E7%9A%84%E8%A7%82%E7%82%B9%E8%AF%BB%E9%80%8F%E4%B8%89%E5%9B%BD%E6%BC%94%E4%B9%89_%E6%9B%BE%E4%BB%95%E5%BC%BA/05%E7%BB%93%E8%AF%AD_%E5%90%8E%E8%AF%AD/>05结语_后语</a></li></ul></li><li><input type=checkbox id=section-68b993cd49d32577da732a864ffe726a class=toggle>
<label for=section-68b993cd49d32577da732a864ffe726a class="flex justify-between"><a role=button>易经真的很容易 曾仕强</a></label><ul><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93_%E6%9B%BE%E4%BB%95%E5%BC%BA/00%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83-%E5%89%8D%E8%A8%80/>00封面-版权-前言</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93_%E6%9B%BE%E4%BB%95%E5%BC%BA/01%E6%98%93%E7%BB%8F%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%AD%A6%E9%97%AE/>01易经是什么样的学问</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93_%E6%9B%BE%E4%BB%95%E5%BC%BA/02%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A9%E4%BA%BA%E5%8F%AF%E4%BB%A5%E5%90%88%E4%B8%80/>02为什么天人可以合一</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93_%E6%9B%BE%E4%BB%95%E5%BC%BA/03%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%90%88%E7%90%86%E5%AE%9A%E4%BD%8D/>03为什么需要合理定位</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93_%E6%9B%BE%E4%BB%95%E5%BC%BA/04%E8%83%BD%E9%A2%84%E6%B5%8B%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%8F%98%E5%8C%96%E5%90%97/>04能预测未来的变化吗</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93_%E6%9B%BE%E4%BB%95%E5%BC%BA/05%E6%80%8E%E6%A0%B7%E8%B6%8B%E5%90%89%E9%81%BF%E5%87%B6/>05怎样趋吉避凶</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93_%E6%9B%BE%E4%BB%95%E5%BC%BA/06%E9%81%93%E5%BE%B7%E4%BF%AE%E5%85%BB%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%9A%E4%BA%BA%E7%9A%84%E6%A0%B9%E6%9C%AC/>06道德修养为什么是做人的根本</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93_%E6%9B%BE%E4%BB%95%E5%BC%BA/07%E5%AE%87%E5%AE%99%E5%8F%AF%E8%83%BD%E6%B0%B8%E7%BB%AD%E7%BB%8F%E8%90%A5%E5%90%97/>07宇宙可能永续经营吗</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93_%E6%9B%BE%E4%BB%95%E5%BC%BA/08%E6%98%93%E7%BB%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E5%BC%80%E5%A7%8B%E7%9A%84/>08易经是怎样开始的</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93_%E6%9B%BE%E4%BB%95%E5%BC%BA/09%E6%98%93%E5%AD%A6%E7%9A%84%E7%A5%9E%E6%98%AF%E4%BB%80%E4%B9%88/>09易学的神是什么</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93_%E6%9B%BE%E4%BB%95%E5%BC%BA/10%E6%98%93%E5%AD%A6%E7%9A%84%E5%8A%9F%E8%83%BD%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/>10易学的功能到底是什么</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93_%E6%9B%BE%E4%BB%95%E5%BC%BA/11%E9%99%84%E5%BD%95/>11附录</a></li><li><a href=/zh/docs/culture/%E6%98%93%E7%BB%8F/%E6%98%93%E7%BB%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E5%AE%B9%E6%98%93_%E6%9B%BE%E4%BB%95%E5%BC%BA/12%E7%BB%93%E8%AF%AD/>12结语</a></li></ul></li></ul></li><li><input type=checkbox id=section-b8eda9fc7502eac7b68386b9c9edef56 class=toggle>
<label for=section-b8eda9fc7502eac7b68386b9c9edef56 class="flex justify-between"><a href=/zh/docs/culture/%E6%B1%89%E5%AD%97%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E6%9D%A5%E7%9A%84/>汉字就是这么来的</a></label><ul><li><a href=/zh/docs/culture/%E6%B1%89%E5%AD%97%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E6%9D%A5%E7%9A%84/01%E8%B5%B0%E8%BF%9B%E6%B1%89%E5%AD%97%E4%B8%96%E7%95%8C/>01走进汉字世界</a></li><li><a href=/zh/docs/culture/%E6%B1%89%E5%AD%97%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E6%9D%A5%E7%9A%84/02%E5%AD%97%E9%87%8C%E5%AD%97%E5%A4%96%E7%9A%84%E5%A4%A9%E6%96%87%E5%9C%B0%E7%90%86/>02字里字外的天文地理</a></li><li><a href=/zh/docs/culture/%E6%B1%89%E5%AD%97%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E6%9D%A5%E7%9A%84/03%E5%AD%97%E9%87%8C%E5%AD%97%E5%A4%96%E7%9A%84%E4%BA%BA%E6%96%87%E5%8E%86%E5%8F%B2/>03字里字外的人文历史</a></li><li><a href=/zh/docs/culture/%E6%B1%89%E5%AD%97%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E6%9D%A5%E7%9A%84/04%E5%AD%97%E9%87%8C%E5%AD%97%E5%A4%96%E7%9A%84%E4%BA%BA%E4%BD%93%E4%B8%96%E7%95%8C/>04字里字外的人体世界</a></li><li><a href=/zh/docs/culture/%E6%B1%89%E5%AD%97%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E6%9D%A5%E7%9A%84/05%E5%AD%97%E9%87%8C%E5%AD%97%E5%A4%96%E7%9A%84%E8%A1%A3%E9%A3%9F%E4%BD%8F%E8%A1%8C/>05字里字外的衣食住行</a></li><li><a href=/zh/docs/culture/%E6%B1%89%E5%AD%97%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E6%9D%A5%E7%9A%84/06%E5%AD%97%E9%87%8C%E5%AD%97%E5%A4%96%E7%9A%84%E5%8A%A8%E7%89%A9%E7%8E%8B%E5%9B%BD/>06字里字外的动物王国</a></li></ul></li><li><input type=checkbox id=section-c7ea0063270bf340e4cc8dfe7d4589a3 class=toggle>
<label for=section-c7ea0063270bf340e4cc8dfe7d4589a3 class="flex justify-between"><a role=button>哲学与人生1 傅佩荣</a></label><ul><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F1_%E5%82%85%E4%BD%A9%E8%8D%A3/00%E5%BA%8F/>00序</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F1_%E5%82%85%E4%BD%A9%E8%8D%A3/01%E7%AC%AC%E4%B8%80%E7%AB%A0_%E5%93%B2%E5%AD%A6%E6%98%AF%E4%BB%80%E4%B9%88/>01第一章_哲学是什么</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F1_%E5%82%85%E4%BD%A9%E8%8D%A3/02%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E6%80%9D%E6%83%B3%E6%96%B9%E6%B3%95/>02第二章_思想方法</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F1_%E5%82%85%E4%BD%A9%E8%8D%A3/03%E7%AC%AC%E4%B8%89%E7%AB%A0_%E4%BA%BA%E6%80%A7%E7%9A%84%E7%9C%9F%E7%9B%B8/>03第三章_人性的真相</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F1_%E5%82%85%E4%BD%A9%E8%8D%A3/04%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E7%A5%9E%E8%AF%9D%E4%B8%8E%E6%82%B2%E5%89%A7/>04第四章_神话与悲剧</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F1_%E5%82%85%E4%BD%A9%E8%8D%A3/05%E7%AC%AC%E4%BA%94%E7%AB%A0_%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95/>05第五章_苏格拉底</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F1_%E5%82%85%E4%BD%A9%E8%8D%A3/06%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%AD%98%E5%9C%A8%E4%B8%BB%E4%B9%89/>06第六章_存在主义</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F1_%E5%82%85%E4%BD%A9%E8%8D%A3/07%E7%AC%AC%E4%B8%83%E7%AB%A0_%E8%8D%92%E8%B0%AC%E4%B9%8B%E8%B6%85%E8%B6%8A/>07第七章_荒谬之超越</a></li></ul></li><li><input type=checkbox id=section-c255d4a0bea09841973b3fb8a1471969 class=toggle>
<label for=section-c255d4a0bea09841973b3fb8a1471969 class="flex justify-between"><a role=button>哲学与人生2 傅佩荣</a></label><ul><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F2_%E5%82%85%E4%BD%A9%E8%8D%A3/00%E5%BA%8F/>00序</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F2_%E5%82%85%E4%BD%A9%E8%8D%A3/01%E7%AC%AC%E4%B8%80%E7%AB%A0_%E4%B8%AD%E5%9B%BD%E5%93%B2%E5%AD%A6%E7%9A%84%E8%B5%B7%E6%BA%90%E4%B8%8E%E7%89%B9%E8%B4%A8/>01第一章_中国哲学的起源与特质</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F2_%E5%82%85%E4%BD%A9%E8%8D%A3/02%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%84%92%E5%AE%B6%E7%9A%84%E9%A3%8E%E6%A0%BC/>02第二章_儒家的风格</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F2_%E5%82%85%E4%BD%A9%E8%8D%A3/03%E7%AC%AC%E4%B8%89%E7%AB%A0_%E9%81%93%E5%AE%B6%E7%9A%84%E6%99%BA%E6%85%A7/>03第三章_道家的智慧</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F2_%E5%82%85%E4%BD%A9%E8%8D%A3/04%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E8%89%BA%E6%9C%AF%E4%B8%8E%E5%AE%A1%E7%BE%8E/>04第四章_艺术与审美</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F2_%E5%82%85%E4%BD%A9%E8%8D%A3/05%E7%AC%AC%E4%BA%94%E7%AB%A0_%E5%AE%97%E6%95%99%E4%B8%8E%E6%B0%B8%E6%81%92/>05第五章_宗教与永恒</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F2_%E5%82%85%E4%BD%A9%E8%8D%A3/06%E7%AC%AC%E5%85%AD%E7%AB%A0_%E6%95%99%E8%82%B2%E4%B8%8E%E8%87%AA%E6%88%91/>06第六章_教育与自我</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F2_%E5%82%85%E4%BD%A9%E8%8D%A3/07%E7%AC%AC%E4%B8%83%E7%AB%A0_%E6%96%87%E5%8C%96%E7%9A%84%E8%A7%86%E9%87%8E/>07第七章_文化的视野</a></li><li><a href=/zh/docs/culture/%E5%93%B2%E5%AD%A6%E4%B8%8E%E4%BA%BA%E7%94%9F2_%E5%82%85%E4%BD%A9%E8%8D%A3/08%E7%BB%93%E8%AE%BA_%E6%96%87%E5%8C%96%E7%9A%84%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B/>08结论_文化的未来展望</a></li></ul></li><li><input type=checkbox id=section-59494cdffcfc4d128fce9ed53d0023ca class=toggle>
<label for=section-59494cdffcfc4d128fce9ed53d0023ca class="flex justify-between"><a role=button>儒家</a></label><ul><li><input type=checkbox id=section-70a18b0985602634ce75629972810b42 class=toggle>
<label for=section-70a18b0985602634ce75629972810b42 class="flex justify-between"><a role=button>向善的孟子 傅佩荣</a></label><ul><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/00%E7%9B%AE%E5%BD%95_%E8%87%AA%E5%BA%8F/>00目录_自序</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/01%E7%AC%AC%E4%B8%80%E7%AB%A0_%E6%9C%80%E5%A7%94%E5%B1%88%E7%9A%84%E5%9C%A3%E4%BA%BA/>01第一章_最委屈的圣人</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/02%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%9C%A3%E4%BA%BA%E7%9A%84%E8%B6%B3%E8%BF%B9/>02第二章_圣人的足迹</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/03%E7%AC%AC%E4%B8%89%E7%AB%A0_%E4%BA%BA%E4%B9%8B%E5%88%9D%E6%80%A7%E5%90%91%E5%96%84/>03第三章_人之初，性向善</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/04%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E5%87%A1%E5%9C%A3%E5%8F%AA%E5%9C%A8%E4%B8%80%E5%BF%B5%E9%97%B4/>04第四章_凡圣只在一念间</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/05%E7%AC%AC%E4%BA%94%E7%AB%A0_%E4%BB%81%E8%80%85%E6%97%A0%E6%95%8C/>05第五章_仁者无敌</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/06%E7%AC%AC%E5%85%AD%E7%AB%A0_%E4%BA%8E%E6%88%91%E5%BF%83%E6%9C%89%E6%88%9A%E6%88%9A%E7%84%89/>06第六章_于我心有戚戚焉</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/07%E7%AC%AC%E4%B8%83%E7%AB%A0_%E5%84%92%E5%AE%B6%E7%AC%AC%E4%B8%80%E8%BE%A9%E6%89%8B/>07第七章_儒家第一辩手</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/08%E7%AC%AC%E5%85%AB%E7%AB%A0_%E4%BF%AE%E8%BA%AB%E5%85%88%E5%85%BB%E6%B5%A9%E7%84%B6%E6%B0%94/>08第八章_修身先养浩然气</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/09%E7%AC%AC%E4%B9%9D%E7%AB%A0_%E4%BA%BA%E7%9A%86%E5%8F%AF%E4%BB%A5%E4%B8%BA%E5%B0%A7%E8%88%9C/>09第九章_人皆可以为尧舜</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/10%E7%AC%AC%E5%8D%81%E7%AB%A0_%E8%B0%A6%E8%B0%A6%E5%90%9B%E5%AD%90%E5%BD%93%E5%A6%82%E6%98%AF/>10第十章_谦谦君子当如是</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/11%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E7%9C%9F%E8%AF%9A%E8%87%AA%E5%BE%97%E5%BF%AB%E4%B9%90/>11第十一章_真诚自得快乐</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/12%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0_%E5%90%9B%E5%AD%90%E4%B9%90%E4%BA%AB%E4%BA%BA%E7%94%9F/>12第十二章_君子乐享人生</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/13%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0_%E6%95%99%E4%BA%A6%E5%A4%9A%E6%9C%AF%E6%AC%B2%E5%85%B6%E8%87%AA%E5%BE%97/>13第十三章_教亦多术，欲其自得</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/14%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0_%E5%AD%A6%E4%BA%8E%E5%9C%A3%E4%BA%BA%E4%B9%8B%E9%97%A8/>14第十四章_学于圣人之门</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/15%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0_%E5%90%9B%E6%9C%89%E9%81%93%E8%87%A3%E6%9C%89%E8%8A%82/>15第十五章_君有道，臣有节</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/16%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0_%E5%90%91%E4%B8%8A%E7%9A%84%E4%BA%BA%E7%94%9F%E5%A2%83%E7%95%8C/>16第十六章_向上的人生境界</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/17%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0_%E5%8D%83%E5%8F%A4%E8%AE%AE%E4%BA%9A%E5%9C%A3/>17第十七章_千古议亚圣</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/18%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0_%E5%AD%9F%E5%AD%90%E9%AB%98%E9%A3%8E%E5%B8%B8%E5%9C%A8/>18第十八章_孟子高风常在</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/19%E7%9B%B8%E5%85%B3%E4%BA%BA%E5%91%98%E8%AF%84%E4%BB%B7/>19相关人员评价</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E5%90%91%E5%96%84%E7%9A%84%E5%AD%9F%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/20%E5%AD%9F%E5%AD%90%E5%85%A8%E6%96%87/>20孟子全文</a></li></ul></li><li><input type=checkbox id=section-120a41b1a2703b36bbe5034334897354 class=toggle>
<label for=section-120a41b1a2703b36bbe5034334897354 class="flex justify-between"><a role=button>论语三百讲 傅佩荣</a></label><ul><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/00a%E7%89%88%E6%9D%83%E9%A1%B5/>00a版权页</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/00b%E7%9B%AE%E5%BD%95_%E5%89%8D%E8%A8%80/>00b目录_前言</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/01%E5%AD%A6%E8%80%8C%E7%AC%AC%E4%B8%80/>01学而第一</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/02%E4%B8%BA%E6%94%BF%E7%AC%AC%E4%BA%8C/>02为政第二</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/03%E5%85%AB%E4%BD%BE%E7%AC%AC%E4%B8%89/>03八佾第三</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/04%E9%87%8C%E4%BB%81%E7%AC%AC%E5%9B%9B/>04里仁第四</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AC%AC%E4%BA%94/>05公冶长第五</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/06%E9%9B%8D%E4%B9%9F%E7%AC%AC%E5%85%AD/>06雍也第六</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/07%E8%BF%B0%E8%80%8C%E7%AC%AC%E4%B8%83/>07述而第七</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/08%E6%B3%B0%E4%BC%AF%E7%AC%AC%E5%85%AB/>08泰伯第八</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/09%E5%AD%90%E7%BD%95%E7%AC%AC%E4%B9%9D/>09子罕第九</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/10%E4%B9%A1%E5%85%9A%E7%AC%AC%E5%8D%81/>10乡党第十</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/11%E5%85%88%E8%BF%9B%E7%AC%AC%E5%8D%81%E4%B8%80/>11先进第十一</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/12%E9%A2%9C%E6%B8%8A%E7%AC%AC%E5%8D%81%E4%BA%8C/>12颜渊第十二</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/13%E5%AD%90%E8%B7%AF%E7%AC%AC%E5%8D%81%E4%B8%89/>13子路第十三</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/14%E5%AE%AA%E9%97%AE%E7%AC%AC%E5%8D%81%E5%9B%9B/>14宪问第十四</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AC%AC%E5%8D%81%E4%BA%94/>15卫灵公第十五</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/16%E5%AD%A3%E6%B0%8F%E7%AC%AC%E5%8D%81%E5%85%AD/>16季氏第十六</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/17%E9%98%B3%E8%B4%A7%E7%AC%AC%E5%8D%81%E4%B8%83/>17阳货第十七</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/18%E5%BE%AE%E5%AD%90%E7%AC%AC%E5%8D%81%E5%85%AB/>18微子第十八</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/19%E5%AD%90%E5%BC%A0%E7%AC%AC%E5%8D%81%E4%B9%9D/>19子张第十九</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E4%B8%89%E7%99%BE%E8%AE%B2_%E5%82%85%E4%BD%A9%E8%8D%A3/20%E5%B0%A7%E6%9B%B0%E7%AC%AC%E4%BA%8C%E5%8D%81/>20尧曰第二十</a></li></ul></li><li><input type=checkbox id=section-97da4aa736cdb94ac8947fb0d7639081 class=toggle>
<label for=section-97da4aa736cdb94ac8947fb0d7639081 class="flex justify-between"><a role=button>论语的生活智慧 曾仕强</a></label><ul><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/00%E5%B0%81%E9%9D%A2-%E4%B9%A6%E5%90%8D-%E5%89%8D%E8%A8%80-%E7%BC%96%E8%80%85-%E7%9B%AE%E5%BD%95/>00封面-书名-前言-编者-目录</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/01%E5%AD%A6%E5%A4%A9%E7%AC%AC%E4%B8%80/>01学天第一</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/02%E4%B8%BA%E6%94%BF%E7%AC%AC%E4%BA%8C/>02为政第二</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/03%E5%85%AB%E4%BD%BE%E7%AC%AC%E4%B8%89/>03八佾第三</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/04%E9%87%8C%E4%BB%81%E7%AC%AC%E5%9B%9B/>04里仁第四</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AC%AC%E4%BA%94/>05公冶长第五</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/06%E9%9B%8D%E4%B9%9F%E7%AC%AC%E5%85%AD/>06雍也第六</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/07%E8%BF%B0%E5%A4%A9%E7%AC%AC%E4%B8%83/>07述天第七</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/08%E6%B3%B0%E4%BC%AF%E7%AC%AC%E5%85%AB/>08泰伯第八</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/09%E5%AD%90%E7%BD%95%E7%AC%AC%E4%B9%9D/>09子罕第九</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/10%E4%B9%A1%E5%85%9A%E7%AC%AC%E5%8D%81/>10乡党第十</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/11%E5%85%88%E8%BF%9B%E7%AC%AC%E5%8D%81%E4%B8%80/>11先进第十一</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/12%E9%A2%9C%E6%B8%8A%E7%AC%AC%E5%8D%81%E4%BA%8C/>12颜渊第十二</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/13%E5%AD%90%E8%B7%AF%E7%AC%AC%E5%8D%81%E4%B8%89/>13子路第十三</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/14%E5%AE%AA%E9%97%AE%E7%AC%AC%E5%8D%81%E5%9B%9B/>14宪问第十四</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AC%AC%E5%8D%81%E4%BA%94/>15卫灵公第十五</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/16%E5%AD%A3%E6%B0%8F%E7%AC%AC%E5%8D%81%E5%85%AD/>16季氏第十六</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/17%E9%98%B3%E8%B4%A7%E7%AC%AC%E5%8D%81%E4%B8%83/>17阳货第十七</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/18%E5%BE%AE%E5%AD%90%E7%AC%AC%E5%8D%81%E5%85%AB/>18微子第十八</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/19%E5%AD%90%E5%BC%A0%E7%AC%AC%E5%8D%81%E4%B9%9D/>19子张第十九</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E7%9A%84%E7%94%9F%E6%B4%BB%E6%99%BA%E6%85%A7_%E6%9B%BE%E4%BB%95%E5%BC%BA/20%E5%B0%A7%E6%9B%B0%E7%AC%AC%E4%BA%8C%E5%8D%81/>20尧曰第二十</a></li></ul></li><li><input type=checkbox id=section-509f91c15ba24d31c9e40009ff8a20cc class=toggle>
<label for=section-509f91c15ba24d31c9e40009ff8a20cc class="flex justify-between"><a role=button>论语译注 杨伯峻</a></label><ul><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/00%E8%AF%95%E8%AE%BA-%E5%AF%BC%E8%A8%80-%E4%BE%8B%E8%A8%80/>00试论-导言-例言</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/01%E5%AD%A6%E8%80%8C%E7%AF%87%E7%AC%AC%E4%B8%80/>01学而篇第一</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/02%E4%B8%BA%E6%94%BF%E7%AF%87%E7%AC%AC%E4%BA%8C/>02为政篇第二</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/03%E5%85%AB%E4%BD%BE%E7%AF%87%E7%AC%AC%E4%B8%89/>03八佾篇第三</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/04%E9%87%8C%E4%BB%81%E7%AF%87%E7%AC%AC%E5%9B%9B/>04里仁篇第四</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AF%87%E7%AC%AC%E4%BA%94/>05公冶长篇第五</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/06%E9%9B%8D%E4%B9%9F%E7%AF%87%E7%AC%AC%E5%85%AD/>06雍也篇第六</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/07%E8%BF%B0%E8%80%8C%E7%AF%87%E7%AC%AC%E4%B8%83/>07述而篇第七</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/08%E6%B3%B0%E4%BC%AF%E7%AF%87%E7%AC%AC%E5%85%AB/>08泰伯篇第八</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/09%E5%AD%90%E7%BD%95%E7%AF%87%E7%AC%AC%E4%B9%9D/>09子罕篇第九</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/10%E4%B9%A1%E5%85%9A%E7%AF%87%E7%AC%AC%E5%8D%81/>10乡党篇第十</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/11%E5%85%88%E8%BF%9B%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%80/>11先进篇第十一</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/12%E9%A2%9C%E6%B8%8A%E7%AF%87%E7%AC%AC%E5%8D%81%E4%BA%8C/>12颜渊篇第十二</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/13%E5%AD%90%E8%B7%AF%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%89/>13子路篇第十三</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/14%E5%AE%AA%E9%97%AE%E7%AF%87%E7%AC%AC%E5%8D%81%E5%9B%9B/>14宪问篇第十四</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AF%87%E7%AC%AC%E5%8D%81%E4%BA%94/>15卫灵公篇第十五</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/16%E5%AD%A3%E6%B0%8F%E7%AF%87%E7%AC%AC%E5%8D%81%E5%85%AD/>16季氏篇第十六</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/17%E9%98%B3%E8%B4%A7%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B8%83/>17阳货篇第十七</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/18%E5%BE%AE%E5%AD%90%E7%AF%87%E7%AC%AC%E5%8D%81%E5%85%AB/>18微子篇第十八</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/19%E5%AD%90%E5%BC%A0%E7%AF%87%E7%AC%AC%E5%8D%81%E4%B9%9D/>19子张篇第十九</a></li><li><a href=/zh/docs/culture/%E5%84%92%E5%AE%B6/%E8%AE%BA%E8%AF%AD%E8%AF%91%E6%B3%A8_%E6%9D%A8%E4%BC%AF%E5%B3%BB/20%E5%B0%A7%E6%9B%B0%E7%AF%87%E7%AC%AC%E4%BA%8C%E5%8D%81/>20尧曰篇第二十</a></li></ul></li></ul></li><li><input type=checkbox id=section-93435cb83cb478de829a9e274c3539ca class=toggle>
<label for=section-93435cb83cb478de829a9e274c3539ca class="flex justify-between"><a role=button>道家</a></label><ul><li><input type=checkbox id=section-394be5662b6b83a88d4e5d4b76e690f3 class=toggle>
<label for=section-394be5662b6b83a88d4e5d4b76e690f3 class="flex justify-between"><a role=button>人生困惑问庄子 傅佩荣</a></label><ul><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/00%E6%80%BB%E5%BA%8F/>00总序</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/01%E7%AC%AC%E4%B8%80%E7%AB%A0_%E5%BA%84%E5%AD%90%E4%BD%95%E8%AE%B8%E4%BA%BA%E4%B9%9F/>01第一章_庄子何许人也</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/02%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E8%B4%AB%E5%9B%B0%E4%B8%8E%E5%BF%AB%E4%B9%90/>02第二章_贫困与快乐</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/03%E7%AC%AC%E4%B8%89%E7%AB%A0_%E4%B9%89%E4%B8%8E%E5%88%A9%E4%B9%8B%E9%97%B4/>03第三章_义与利之间</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/04%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E4%B8%8D%E4%B8%BA%E5%90%8D%E6%89%80%E7%B4%AF/>04第四章_不为名所累</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/05%E7%AC%AC%E4%BA%94%E7%AB%A0_%E9%9D%A2%E5%AF%B9%E7%94%9F%E8%80%81%E7%97%85%E6%AD%BB/>05第五章_面对生老病死</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/06%E7%AC%AC%E5%85%AD%E7%AB%A0_%E4%B8%8E%E4%BB%96%E4%BA%BA%E7%9B%B8%E5%A4%84/>06第六章_与他人相处</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/07%E7%AC%AC%E4%B8%83%E7%AB%A0_%E4%B8%8A%E4%B8%8B%E7%BA%A7%E7%9B%B8%E5%A4%84%E7%9A%84%E8%89%BA%E6%9C%AF/>07第七章_上下级相处的艺术</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/08%E7%AC%AC%E5%85%AB%E7%AB%A0_%E5%BF%AB%E4%B9%90%E5%BD%93%E5%AD%9D%E5%AD%90/>08第八章_快乐当孝子</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/09%E7%AC%AC%E4%B9%9D%E7%AB%A0_%E4%B8%8E%E8%87%AA%E5%B7%B1%E5%92%8C%E8%B0%90/>09第九章_与自己和谐</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/10%E7%AC%AC%E5%8D%81%E7%AB%A0_%E4%B8%8E%E8%87%AA%E7%84%B6%E5%92%8C%E8%B0%90/>10第十章_与自然和谐</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/11%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0_%E4%BA%89%E4%B8%8E%E4%B8%8D%E4%BA%89/>11第十一章_争与不争</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/12%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0_%E4%B8%8D%E8%A6%81%E8%BF%B7%E4%BF%A1%E7%AE%97%E5%91%BD/>12第十二章_不要迷信算命</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/13%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0_%E4%B9%A6%E6%9C%AC%E4%B8%8E%E6%99%BA%E6%85%A7/>13第十三章_书本与智慧</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/14%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0_%E6%8A%8A%E5%B7%A5%E4%BD%9C%E5%8F%98%E6%88%90%E8%89%BA%E6%9C%AF/>14第十四章_把工作变成艺术</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E4%BA%BA%E7%94%9F%E5%9B%B0%E6%83%91%E9%97%AE%E5%BA%84%E5%AD%90_%E5%82%85%E4%BD%A9%E8%8D%A3/15%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0_%E9%80%8D%E9%81%A5%E4%BA%BA%E7%94%9F%E7%9A%84%E6%9C%80%E9%AB%98%E5%A2%83%E7%95%8C/>15第十五章_逍遥人生的最高境界</a></li></ul></li><li><input type=checkbox id=section-8b7dcb82a57fa8dbdf08babbba0c0814 class=toggle>
<label for=section-8b7dcb82a57fa8dbdf08babbba0c0814 class="flex justify-between"><a role=button>道德经 曾仕强</a></label><ul><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E9%81%93%E5%BE%B7%E7%BB%8F_%E6%9B%BE%E4%BB%95%E5%BC%BA/00%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83/>00封面-版权</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E9%81%93%E5%BE%B7%E7%BB%8F_%E6%9B%BE%E4%BB%95%E5%BC%BA/01%E4%B8%8A%E7%AF%87_%E9%81%93%E5%BE%B7%E7%BB%8F%E7%9A%84%E5%A5%A5%E7%A7%98/>01上篇_道德经的奥秘</a></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E9%81%93%E5%BE%B7%E7%BB%8F_%E6%9B%BE%E4%BB%95%E5%BC%BA/02%E4%B8%8B%E7%AF%87_%E9%81%93%E5%BE%B7%E7%BB%8F%E4%B8%8E%E7%94%9F%E6%B4%BB/>02下篇_道德经与生活</a></li></ul></li><li><a href=/zh/docs/culture/%E9%81%93%E5%AE%B6/%E5%BA%84%E5%AD%90%E5%BF%83%E5%BE%97_%E5%82%85%E4%BD%A9%E8%8D%A3/>庄子心得_傅佩荣</a></li></ul></li><li><input type=checkbox id=section-158b0483296f0af9f79535517398c058 class=toggle>
<label for=section-158b0483296f0af9f79535517398c058 class="flex justify-between"><a role=button>美满的亲子关系 曾仕强</a></label><ul><li><a href=/zh/docs/culture/%E7%BE%8E%E6%BB%A1%E7%9A%84%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB_%E6%9B%BE%E4%BB%95%E5%BC%BA/00%E7%9B%AE%E5%BD%95_%E5%BA%8F_%E5%89%8D%E8%A8%80/>00目录_序_前言</a></li><li><a href=/zh/docs/culture/%E7%BE%8E%E6%BB%A1%E7%9A%84%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB_%E6%9B%BE%E4%BB%95%E5%BC%BA/01%E7%AC%AC%E4%B8%80%E7%AB%A0_%E5%AE%B6%E5%BA%AD%E9%9C%80%E8%A6%81%E8%89%AF%E5%A5%BD%E7%9A%84%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB/>01第一章_家庭需要良好的亲子关系</a></li><li><a href=/zh/docs/culture/%E7%BE%8E%E6%BB%A1%E7%9A%84%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB_%E6%9B%BE%E4%BB%95%E5%BC%BA/02%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB%E5%86%B3%E5%AE%9A%E4%BA%8E%E6%95%99%E5%85%BB%E8%A7%82%E5%BF%B5/>02第二章_亲子关系决定于教养观念</a></li><li><a href=/zh/docs/culture/%E7%BE%8E%E6%BB%A1%E7%9A%84%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB_%E6%9B%BE%E4%BB%95%E5%BC%BA/03%E7%AC%AC%E4%B8%89%E7%AB%A0_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E6%9B%B4%E9%87%8D%E8%A7%86%E5%AE%B6%E5%BA%AD%E6%95%99%E8%82%B2/>03第三章_现代人更重视家庭教育</a></li><li><a href=/zh/docs/culture/%E7%BE%8E%E6%BB%A1%E7%9A%84%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB_%E6%9B%BE%E4%BB%95%E5%BC%BA/04%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E7%88%B6%E6%AF%8D%E5%BF%85%E9%A1%BB%E8%B4%9F%E8%B5%B7%E5%BA%94%E8%B4%9F%E7%9A%84%E8%B4%A3%E4%BB%BB/>04第四章_父母必须负起应负的责任</a></li><li><a href=/zh/docs/culture/%E7%BE%8E%E6%BB%A1%E7%9A%84%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB_%E6%9B%BE%E4%BB%95%E5%BC%BA/05%E7%AC%AC%E4%BA%94%E7%AB%A0_%E5%AD%90%E5%A5%B3%E5%BA%94%E8%AF%A5%E5%85%BB%E6%88%90%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BF%83%E6%80%81/>05第五章_子女应该养成正确的心态</a></li><li><a href=/zh/docs/culture/%E7%BE%8E%E6%BB%A1%E7%9A%84%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB_%E6%9B%BE%E4%BB%95%E5%BC%BA/06%E7%AC%AC%E5%85%AD%E7%AB%A0_%E5%85%B1%E5%90%8C%E9%87%87%E5%8F%96%E9%80%82%E5%BD%93%E7%9A%84%E6%95%99%E5%85%BB%E6%96%B9%E6%B3%95/>06第六章_共同采取适当的教养方法</a></li><li><a href=/zh/docs/culture/%E7%BE%8E%E6%BB%A1%E7%9A%84%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB_%E6%9B%BE%E4%BB%95%E5%BC%BA/07%E7%AC%AC%E4%B8%83%E7%AB%A0_%E4%B8%AD%E5%AD%A6%E4%BB%A5%E5%89%8D%E5%90%8C%E5%AD%A9%E5%AD%90%E4%B8%80%E8%B5%B7%E7%94%9F%E6%B4%BB/>07第七章_中学以前同孩子一起生活</a></li><li><a href=/zh/docs/culture/%E7%BE%8E%E6%BB%A1%E7%9A%84%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB_%E6%9B%BE%E4%BB%95%E5%BC%BA/08%E7%AC%AC%E5%85%AB%E7%AB%A0_%E4%B8%AD%E5%AD%A6%E9%98%B6%E6%AE%B5%E8%BA%AB%E5%BF%83%E5%8F%98%E5%8C%96%E5%BE%88%E5%89%A7%E7%83%88/>08第八章_中学阶段身心变化很剧烈</a></li><li><a href=/zh/docs/culture/%E7%BE%8E%E6%BB%A1%E7%9A%84%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB_%E6%9B%BE%E4%BB%95%E5%BC%BA/09%E7%AC%AC%E4%B9%9D%E7%AB%A0_%E5%A4%A7%E5%AD%A6%E6%97%B6%E6%9C%9F%E5%BC%95%E5%AF%BC%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%96%B9%E5%90%91/>09第九章_大学时期引导未来的方向</a></li><li><a href=/zh/docs/culture/%E7%BE%8E%E6%BB%A1%E7%9A%84%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB_%E6%9B%BE%E4%BB%95%E5%BC%BA/10%E7%AC%AC%E5%8D%81%E7%AB%A0_%E6%88%90%E5%B9%B4%E4%BB%A5%E5%90%8E%E4%BA%AB%E5%8F%97%E6%97%A2%E6%88%90%E7%9A%84%E5%85%B3%E7%B3%BB/>10第十章_成年以后享受既成的关系</a></li><li><a href=/zh/docs/culture/%E7%BE%8E%E6%BB%A1%E7%9A%84%E4%BA%B2%E5%AD%90%E5%85%B3%E7%B3%BB_%E6%9B%BE%E4%BB%95%E5%BC%BA/11%E7%BB%93%E8%AF%AD_%E5%8F%82%E8%80%83%E7%9B%AE%E5%BD%95/>11结语_参考目录</a></li></ul></li><li><input type=checkbox id=section-711d44dd7136a33357492960652309e0 class=toggle>
<label for=section-711d44dd7136a33357492960652309e0 class="flex justify-between"><a role=button>领导与被领导的艺术 曾仕强</a></label><ul><li><a href=/zh/docs/culture/%E9%A2%86%E5%AF%BC%E4%B8%8E%E8%A2%AB%E9%A2%86%E5%AF%BC%E7%9A%84%E8%89%BA%E6%9C%AF_%E6%9B%BE%E4%BB%95%E5%BC%BA/00%E7%9B%AE%E5%BD%95/>00目录</a></li><li><a href=/zh/docs/culture/%E9%A2%86%E5%AF%BC%E4%B8%8E%E8%A2%AB%E9%A2%86%E5%AF%BC%E7%9A%84%E8%89%BA%E6%9C%AF_%E6%9B%BE%E4%BB%95%E5%BC%BA/01%E7%AC%AC%E4%B8%80%E7%AB%A0_%E6%9B%B9%E6%93%8D_%E4%B9%B1%E4%B8%AD%E5%8F%96%E8%83%9C%E7%9A%84%E6%9D%83%E8%B0%8B%E4%B9%8B%E9%81%93/>01第一章_曹操_乱中取胜的权谋之道</a></li><li><a href=/zh/docs/culture/%E9%A2%86%E5%AF%BC%E4%B8%8E%E8%A2%AB%E9%A2%86%E5%AF%BC%E7%9A%84%E8%89%BA%E6%9C%AF_%E6%9B%BE%E4%BB%95%E5%BC%BA/02%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E5%AD%99%E6%9D%83_%E5%A4%B9%E7%BC%9D%E6%B1%82%E7%94%9F%E7%9A%84%E5%AE%88%E4%B8%9A%E4%B9%8B%E9%81%93/>02第二章_孙权_夹缝求生的守业之道</a></li><li><a href=/zh/docs/culture/%E9%A2%86%E5%AF%BC%E4%B8%8E%E8%A2%AB%E9%A2%86%E5%AF%BC%E7%9A%84%E8%89%BA%E6%9C%AF_%E6%9B%BE%E4%BB%95%E5%BC%BA/03%E7%AC%AC%E4%B8%89%E7%AB%A0_%E5%88%98%E5%A4%87_%E4%BB%A5%E4%BB%81%E4%B8%BA%E6%9C%AC%E7%9A%84%E7%94%A8%E4%BA%BA%E4%B9%8B%E9%81%93/>03第三章_刘备_以仁为本的用人之道</a></li><li><a href=/zh/docs/culture/%E9%A2%86%E5%AF%BC%E4%B8%8E%E8%A2%AB%E9%A2%86%E5%AF%BC%E7%9A%84%E8%89%BA%E6%9C%AF_%E6%9B%BE%E4%BB%95%E5%BC%BA/04%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E8%AF%B8%E8%91%9B%E4%BA%AE_%E8%BF%90%E7%AD%B9%E5%B8%B7%E5%B9%84%E7%9A%84%E6%99%BA%E8%B0%8B%E4%B9%8B%E9%81%93/>04第四章_诸葛亮_运筹帷幄的智谋之道</a></li><li><a href=/zh/docs/culture/%E9%A2%86%E5%AF%BC%E4%B8%8E%E8%A2%AB%E9%A2%86%E5%AF%BC%E7%9A%84%E8%89%BA%E6%9C%AF_%E6%9B%BE%E4%BB%95%E5%BC%BA/05%E7%AC%AC%E4%BA%94%E7%AB%A0_%E5%85%B3%E7%BE%BD_%E5%85%BC%E9%A1%BE%E5%8E%9F%E5%88%99%E7%9A%84%E5%BF%A0%E4%B9%89%E4%B9%8B%E9%81%93/>05第五章_关羽_兼顾原则的忠义之道</a></li><li><a href=/zh/docs/culture/%E9%A2%86%E5%AF%BC%E4%B8%8E%E8%A2%AB%E9%A2%86%E5%AF%BC%E7%9A%84%E8%89%BA%E6%9C%AF_%E6%9B%BE%E4%BB%95%E5%BC%BA/06%E7%AC%AC%E5%85%AD%E7%AB%A0_%E8%B5%B5%E4%BA%91_%E8%B0%A6%E9%80%8A%E4%BD%8E%E8%B0%83%E7%9A%84%E5%8D%8F%E4%BD%9C%E4%B9%8B%E9%81%93/>06第六章_赵云_谦逊低调的协作之道</a></li></ul></li><li><input type=checkbox id=section-e9ff8c3dd13f841ba86769671d268546 class=toggle>
<label for=section-e9ff8c3dd13f841ba86769671d268546 class="flex justify-between"><a role=button>人性的奥秘 曾仕强</a></label><ul><li><a href=/zh/docs/culture/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/00%E7%9B%AE%E5%BD%95_%E5%89%8D%E8%A8%80/>00目录_前言</a></li><li><a href=/zh/docs/culture/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/01%E7%AC%AC%E4%B8%80%E7%AB%A0_%E4%BA%BA%E4%BA%BA%E9%83%BD%E9%80%83%E4%B8%8D%E5%BC%80%E7%9A%84%E4%BA%BA%E6%80%A7%E5%BC%B1%E7%82%B9/>01第一章_人人都逃不开的人性弱点</a></li><li><a href=/zh/docs/culture/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/02%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E4%BA%BA%E7%B1%BB%E4%BD%95%E4%BB%A5%E6%9C%89%E5%BC%B1%E7%82%B9/>02第二章_人类何以有弱点</a></li><li><a href=/zh/docs/culture/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/03%E7%AC%AC%E4%B8%89%E7%AB%A0_%E4%BA%BA%E7%B1%BB%E5%8E%86%E5%8F%B2%E5%B0%B1%E6%98%AF%E5%BD%BC%E6%AD%A4%E5%88%A9%E7%94%A8%E5%BC%B1%E7%82%B9%E7%9A%84%E5%8E%86%E5%8F%B2/>03第三章_人类历史就是彼此利用弱点的历史</a></li><li><a href=/zh/docs/culture/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/04%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E5%90%91%E9%94%99%E8%B5%B0_%E5%BC%B1%E7%82%B9%E5%B0%B1%E6%98%AF%E7%BC%BA%E7%82%B9/>04第四章_向错走_弱点就是缺点</a></li><li><a href=/zh/docs/culture/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/05%E7%AC%AC%E4%BA%94%E7%AB%A0_%E5%90%91%E5%AF%B9%E8%B5%B0_%E5%BC%B1%E7%82%B9%E4%B9%9F%E6%98%AF%E4%BC%98%E7%82%B9/>05第五章_向对走_弱点也是优点</a></li><li><a href=/zh/docs/culture/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/06%E7%AC%AC%E5%85%AD%E7%AB%A0_%E4%B8%BB%E5%8A%A8%E6%98%BE%E7%A4%BA%E5%BC%B1%E7%82%B9%E8%BF%98%E6%98%AF%E6%8A%80%E5%B7%A7%E9%9A%90%E8%97%8F%E5%BC%B1%E7%82%B9/>06第六章_主动显示弱点还是技巧隐藏弱点</a></li></ul></li><li><input type=checkbox id=section-220a2a130cdc34fbe5de37ff79ad9cce class=toggle>
<label for=section-220a2a130cdc34fbe5de37ff79ad9cce class="flex justify-between"><a role=button>情绪的奥秘 曾仕强</a></label><ul><li><a href=/zh/docs/culture/%E6%83%85%E7%BB%AA%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/00%E7%9B%AE%E5%BD%95_%E5%BC%95%E8%A8%80/>00目录_引言</a></li><li><a href=/zh/docs/culture/%E6%83%85%E7%BB%AA%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/01%E7%AC%AC%E4%B8%80%E7%AB%A0_%E4%B8%AD%E5%9B%BD%E4%BA%BA%E4%B8%BA%E4%BB%80%E4%B9%88%E7%88%B1%E7%94%9F%E6%B0%94/>01第一章_中国人为什么爱生气</a></li><li><a href=/zh/docs/culture/%E6%83%85%E7%BB%AA%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/02%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E8%87%AA%E5%B7%B1%E6%98%AF%E6%83%85%E7%BB%AA%E8%B4%9F%E5%80%BA%E7%9A%84%E5%88%B6%E9%80%A0%E8%80%85/>02第二章_自己是情绪负债的制造者</a></li><li><a href=/zh/docs/culture/%E6%83%85%E7%BB%AA%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/03%E7%AC%AC%E4%B8%89%E7%AB%A0_%E7%94%A8%E7%90%86%E6%99%BA%E6%9D%A5%E6%8C%87%E5%AF%BC%E6%83%85%E7%BB%AA/>03第三章_用理智来指导情绪</a></li><li><a href=/zh/docs/culture/%E6%83%85%E7%BB%AA%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/04%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E8%87%AA%E5%B7%B1%E6%89%8D%E6%98%AF%E6%83%85%E7%BB%AA%E7%9A%84%E4%B8%BB%E5%AE%B0%E8%80%85/>04第四章_自己才是情绪的主宰者</a></li><li><a href=/zh/docs/culture/%E6%83%85%E7%BB%AA%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/05%E7%AC%AC%E4%BA%94%E7%AB%A0_%E4%BA%BA%E8%A6%81%E7%9C%8B%E5%BC%80%E4%B8%8D%E8%A6%81%E7%9C%8B%E7%A0%B4/>05第五章_人要看开不要看破</a></li><li><a href=/zh/docs/culture/%E6%83%85%E7%BB%AA%E7%9A%84%E5%A5%A5%E7%A7%98_%E6%9B%BE%E4%BB%95%E5%BC%BA/06%E7%AC%AC%E5%85%AD%E7%AB%A0_%E6%8C%96%E6%8E%98%E5%86%85%E5%BF%83%E7%9A%84%E8%87%AA%E5%B7%B1%E5%96%84%E5%BE%85%E5%A4%9A%E5%8F%98%E7%9A%84%E6%83%85%E7%BB%AA/>06第六章_挖掘内心的自己，善待多变的情绪</a></li></ul></li><li><a href=/zh/docs/culture/%E6%B4%BB%E7%9D%80/>活着</a></li><li><input type=checkbox id=section-e17ff368fc19f19c3f48633004418234 class=toggle>
<label for=section-e17ff368fc19f19c3f48633004418234 class="flex justify-between"><a role=button>中国历代政治得失</a></label><ul><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/00%E7%9B%AE%E5%BD%95_%E5%BA%8F/>00目录_序</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/01%E7%AC%AC%E4%B8%80%E8%AE%B2_%E6%B1%89%E4%BB%A3/>01第一讲_汉代</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/02%E7%AC%AC%E4%BA%8C%E8%AE%B2_%E5%94%90%E4%BB%A3/>02第二讲_唐代</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/03%E7%AC%AC%E4%B8%89%E8%AE%B2_%E5%AE%8B%E4%BB%A3/>03第三讲_宋代</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/04%E7%AC%AC%E5%9B%9B%E8%AE%B2_%E6%98%8E%E4%BB%A3/>04第四讲_明代</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/05%E7%AC%AC%E4%BA%94%E8%AE%B2_%E6%B8%85%E4%BB%A3/>05第五讲_清代</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1/06%E6%80%BB%E8%AE%BA/>06总论</a></li></ul></li><li><input type=checkbox id=section-5458643b5cc681aeb7589a30c20b5eca class=toggle>
<label for=section-5458643b5cc681aeb7589a30c20b5eca class="flex justify-between"><a role=button>万历十五年</a></label><ul><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/00a%E7%89%88%E6%9D%83-%E8%87%AA%E5%BA%8F/>00a版权-自序</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/00b%E7%BB%8F%E5%85%B8%E7%9A%84%E5%8E%86%E7%A8%8B/>00b经典的历程</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/01%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B8%87%E5%8E%86%E7%9A%87%E5%B8%9D/>01第一章万历皇帝</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/02%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%A6%96%E8%BE%85%E7%94%B3%E6%97%B6%E8%A1%8C/>02第二章首辅申时行</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/03%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%96%E9%97%B4%E5%B7%B2%E6%97%A0%E5%BC%A0%E5%B1%85%E6%AD%A3/>03第三章世间已无张居正</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/04%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%B4%BB%E7%9D%80%E7%9A%84%E7%A5%96%E5%AE%97/>04第四章活着的祖宗</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/05%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%B5%B7%E7%91%9E_%E5%8F%A4%E6%80%AA%E7%9A%84%E6%A8%A1%E8%8C%83%E5%AE%98%E5%83%9A/>05第五章海瑞_古怪的模范官僚</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/06%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%88%9A%E7%BB%A7%E5%85%89_%E5%AD%A4%E7%8B%AC%E7%9A%84%E5%B0%86%E9%A2%86/>06第六章戚继光_孤独的将领</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/07%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%9D%8E%E8%B4%BD_%E8%87%AA%E7%9B%B8%E5%86%B2%E7%AA%81%E7%9A%84%E5%93%B2%E5%AD%A6%E5%AE%B6/>07第七章李贽_自相冲突的哲学家</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/08%E9%99%84%E5%BD%95/>08附录</a></li><li><a href=/zh/docs/culture/%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4/09%E5%8F%82%E8%80%83%E4%B9%A6%E7%9B%AE/>09参考书目</a></li></ul></li><li><input type=checkbox id=section-25bf8aa304781904e13d45dd3ed174ca class=toggle>
<label for=section-25bf8aa304781904e13d45dd3ed174ca class="flex justify-between"><a role=button>国学的天空_傅佩荣</a></label><ul><li><a href=/zh/docs/culture/%E5%9B%BD%E5%AD%A6%E7%9A%84%E5%A4%A9%E7%A9%BA_%E5%82%85%E4%BD%A9%E8%8D%A3/00%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83-%E5%89%8D%E8%A8%80/>00封面-版权-前言</a></li><li><a href=/zh/docs/culture/%E5%9B%BD%E5%AD%A6%E7%9A%84%E5%A4%A9%E7%A9%BA_%E5%82%85%E4%BD%A9%E8%8D%A3/01%E7%AC%AC%E4%B8%80%E9%83%A8%E5%AD%94%E5%AD%90%E7%9A%84%E7%9C%9F%E8%AF%9A/>01第一部孔子的真诚</a></li><li><a href=/zh/docs/culture/%E5%9B%BD%E5%AD%A6%E7%9A%84%E5%A4%A9%E7%A9%BA_%E5%82%85%E4%BD%A9%E8%8D%A3/02%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%AD%9F%E5%AD%90%E7%9A%84%E5%90%91%E5%96%84/>02第二部孟子的向善</a></li><li><a href=/zh/docs/culture/%E5%9B%BD%E5%AD%A6%E7%9A%84%E5%A4%A9%E7%A9%BA_%E5%82%85%E4%BD%A9%E8%8D%A3/03%E7%AC%AC%E4%B8%89%E9%83%A8%E8%80%81%E5%AD%90%E7%9A%84%E6%99%BA%E6%85%A7/>03第三部老子的智慧</a></li><li><a href=/zh/docs/culture/%E5%9B%BD%E5%AD%A6%E7%9A%84%E5%A4%A9%E7%A9%BA_%E5%82%85%E4%BD%A9%E8%8D%A3/04%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%BA%84%E5%AD%90%E7%9A%84%E9%80%8D%E9%81%A5/>04第四部庄子的逍遥</a></li></ul></li><li><input type=checkbox id=section-abcb4c073d0fcf577d195a21f3ae1356 class=toggle>
<label for=section-abcb4c073d0fcf577d195a21f3ae1356 class="flex justify-between"><a role=button>吕氏春秋</a></label><ul><li><input type=checkbox id=section-df956b6b30dd627463161f30d1304d59 class=toggle>
<label for=section-df956b6b30dd627463161f30d1304d59 class="flex justify-between"><a role=button>01上册</a></label><ul><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/01%E5%AD%9F%E6%98%A5%E7%BA%AA%E7%AC%AC%E4%B8%80/>01孟春纪第一</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/02%E4%BB%B2%E6%98%A5%E7%BA%AA%E7%AC%AC%E4%BA%8C/>02仲春纪第二</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/03%E5%AD%A3%E6%98%A5%E7%BA%AA%E7%AC%AC%E4%B8%89/>03季春纪第三</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/04%E5%AD%9F%E5%A4%8F%E7%BA%AA%E7%AC%AC%E5%9B%9B/>04孟夏纪第四</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/05%E4%BB%B2%E5%A4%8F%E7%BA%AA%E7%AC%AC%E4%BA%94/>05仲夏纪第五</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/06%E5%AD%A3%E5%A4%8F%E7%BA%AA%E7%AC%AC%E5%85%AD/>06季夏纪第六</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/07%E5%AD%9F%E7%A7%8B%E7%BA%AA%E7%AC%AC%E4%B8%83/>07孟秋纪第七</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/08%E4%BB%B2%E7%A7%8B%E7%BA%AA%E7%AC%AC%E5%85%AB/>08仲秋纪第八</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/09%E5%AD%A3%E7%A7%8B%E7%BA%AA%E7%AC%AC%E4%B9%9D/>09季秋纪第九</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/10%E5%AD%9F%E5%86%AC%E7%BA%AA%E7%AC%AC%E5%8D%81/>10孟冬纪第十</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/11%E4%BB%B2%E5%86%AC%E7%BA%AA%E7%AC%AC%E5%8D%81%E4%B8%80/>11仲冬纪第十一</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/12%E5%AD%A3%E5%86%AC%E7%BA%AA%E7%AC%AC%E5%8D%81%E4%BA%8C/>12季冬纪第十二</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/13%E6%9C%89%E5%A7%8B%E8%A7%88%E7%AC%AC%E4%B8%80/>13有始览第一</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/14%E5%AD%9D%E8%A1%8C%E8%A7%88%E7%AC%AC%E4%BA%8C/>14孝行览第二</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/15%E6%85%8E%E5%A4%A7%E8%A7%88%E7%AC%AC%E4%B8%89/>15慎大览第三</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/01%E4%B8%8A%E5%86%8C/16%E5%85%88%E8%AF%86%E8%A7%88%E7%AC%AC%E5%9B%9B/>16先识览第四</a></li></ul></li><li><input type=checkbox id=section-bf3fd867cbcfac38434b2e2eddaf0f0e class=toggle>
<label for=section-bf3fd867cbcfac38434b2e2eddaf0f0e class="flex justify-between"><a role=button>02下册</a></label><ul><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/02%E4%B8%8B%E5%86%8C/17%E5%AE%A1%E5%88%86%E8%A7%88%E7%AC%AC%E4%BA%94/>17审分览第五</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/02%E4%B8%8B%E5%86%8C/18%E5%AE%A1%E5%BA%94%E8%A7%88%E7%AC%AC%E5%85%AD/>18审应览第六</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/02%E4%B8%8B%E5%86%8C/19%E7%A6%BB%E4%BF%97%E8%A7%88%E7%AC%AC%E4%B8%83/>19离俗览第七</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/02%E4%B8%8B%E5%86%8C/20%E6%81%83%E5%90%9B%E8%A7%88%E7%AC%AC%E5%85%AB/>20恃君览第八</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/02%E4%B8%8B%E5%86%8C/21%E5%BC%80%E6%98%A5%E8%AE%BA%E7%AC%AC%E4%B8%80/>21开春论第一</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/02%E4%B8%8B%E5%86%8C/22%E6%85%8E%E8%A1%8C%E8%AE%BA%E7%AC%AC%E4%BA%8C/>22慎行论第二</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/02%E4%B8%8B%E5%86%8C/23%E8%B4%B5%E7%9B%B4%E8%AE%BA%E7%AC%AC%E4%B8%89/>23贵直论第三</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/02%E4%B8%8B%E5%86%8C/24%E4%B8%8D%E8%8B%9F%E8%AE%BA%E7%AC%AC%E5%9B%9B/>24不苟论第四</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/02%E4%B8%8B%E5%86%8C/25%E4%BC%BC%E9%A1%BA%E8%AE%BA%E7%AC%AC%E4%BA%94/>25似顺论第五</a></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/02%E4%B8%8B%E5%86%8C/26%E5%A3%AB%E5%AE%B9%E8%AE%BA%E7%AC%AC%E5%85%AD/>26士容论第六</a></li></ul></li><li><a href=/zh/docs/culture/%E5%90%95%E6%B0%8F%E6%98%A5%E7%A7%8B/00%E4%B9%A6%E5%90%8D-%E5%89%8D%E8%A8%80-%E7%9B%AE%E5%BD%95/>书名-前言-目录</a></li></ul></li><li><input type=checkbox id=section-36af101672fdef38bd3af078cbe1e845 class=toggle>
<label for=section-36af101672fdef38bd3af078cbe1e845 class="flex justify-between"><a role=button>天纪</a></label><ul><li><span>人间道</span><ul><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/00%E5%BA%8F/>00序</a></li><li><input type=checkbox id=section-461d19122e053a1503a94eb8e0ea19a3 class=toggle>
<label for=section-461d19122e053a1503a94eb8e0ea19a3 class="flex justify-between"><a role=button>上经</a></label><ul><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/01%E4%B9%BE%E4%B8%BA%E5%A4%A9/>01乾爲天</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/02%E5%9D%A4%E4%B8%BA%E5%9C%B0/>02坤爲地</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/03%E6%B0%B4%E9%9B%B7%E5%B1%AF/>03水雷屯</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/04%E5%B1%B1%E6%B0%B4%E8%92%99/>04山水蒙</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/05%E6%B0%B4%E5%A4%A9%E9%9C%80/>05水天需</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/06%E5%A4%A9%E6%B0%B4%E8%AE%BC/>06天水讼</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/07%E5%9C%B0%E6%B0%B4%E5%B8%AB/>07地水師</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/08%E6%B0%B4%E5%9C%B0%E6%AF%94/>08水地比</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/09%E9%A2%A8%E5%A4%A9%E5%B0%8F%E7%95%9C/>09風天小畜</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/10%E5%A4%A9%E6%B3%BD%E5%B1%A5/>10天澤履</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/11%E5%9C%B0%E5%A4%A9%E6%B3%B0/>11地天泰</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/12%E5%A4%A9%E5%9C%B0%E5%90%A6/>12天地否</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/13%E5%A4%A9%E7%81%AB%E5%90%8C%E4%BA%BA/>13天火同人</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/14%E7%81%AB%E5%A4%A9%E5%A4%A7%E6%9C%89/>14火天大有</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/15%E5%9C%B0%E5%B1%B1%E8%AC%99/>15地山謙</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/16%E9%9B%B7%E5%9C%B0%E8%B1%AB/>16雷地豫</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/17%E6%BE%A4%E9%9B%B7%E9%9A%A8/>17澤雷隨</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/18%E5%B1%B1%E9%A2%A8%E8%A0%B1/>18山風蠱</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/19%E5%9C%B0%E6%BE%A4%E8%87%A8/>19地澤臨</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/20%E9%A2%A8%E5%9C%B0%E8%A7%80/>20風地觀</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/21%E7%81%AB%E9%9B%B7%E5%99%AC%E5%97%91/>21火雷噬嗑</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/22%E5%B1%B1%E7%81%AB%E8%B3%81/>22山火賁</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/23%E5%B1%B1%E5%9C%B0%E5%89%9D/>23山地剝</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/24%E5%9C%B0%E9%9B%B7%E5%BE%A9/>24地雷復</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/25%E5%A4%A9%E9%9B%B7%E6%97%A0%E5%A6%84/>25天雷无妄</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/26%E5%B1%B1%E5%A4%A9%E5%A4%A7%E7%95%9C/>26山天大畜</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/27%E5%B1%B1%E9%9B%B7%E9%A0%A4/>27山雷頤</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/28%E6%BE%A4%E9%A2%A8%E5%A4%A7%E9%81%8E/>28澤風大過</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/29%E5%9D%8E%E7%88%B2%E6%B0%B4/>29坎爲水</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/01%E4%B8%8A%E7%BB%8F/30%E9%9B%A2%E7%82%BA%E7%81%AB/>30離為火</a></li></ul></li><li><input type=checkbox id=section-651fbb09f503c9ca1190ecab15ff4a85 class=toggle>
<label for=section-651fbb09f503c9ca1190ecab15ff4a85 class="flex justify-between"><a role=button>下经</a></label><ul><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/31%E6%BE%A4%E5%B1%B1%E5%92%B8/>31澤山咸</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/32%E9%9B%B7%E9%A2%A8%E6%81%86/>32雷風恆</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/33%E5%A4%A9%E5%B1%B1%E9%81%AF/>33天山遯</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/34%E9%9B%B7%E5%A4%A9%E5%A4%A7%E5%A3%AF/>34雷天大壯</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/35%E7%81%AB%E5%9C%B0%E6%99%89/>35火地晉</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/36%E5%9C%B0%E7%81%AB%E6%98%8E%E5%A4%B7/>36地火明夷</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/37%E9%A2%A8%E7%81%AB%E5%AE%B6%E4%BA%BA/>37風火家人</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/38%E7%81%AB%E6%BE%A4%E7%9D%BD/>38火澤睽</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/39%E6%B0%B4%E5%B1%B1%E8%B9%87/>39水山蹇</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/40%E9%9B%B7%E6%B0%B4%E8%A7%A3/>40雷水解</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/41%E5%B1%B1%E6%BE%A4%E6%90%8D/>41山澤損</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/42%E9%A2%A8%E9%9B%B7%E7%9B%8A/>42風雷益</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/43%E6%BE%A4%E5%A4%A9%E5%A4%AC/>43澤天夬</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/44%E5%A4%A9%E9%A2%A8%E5%A7%A4/>44天風姤</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/45%E6%BE%A4%E5%9C%B0%E8%90%83/>45澤地萃</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/46%E5%9C%B0%E9%A2%A8%E5%8D%87/>46地風升</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/47%E6%BE%A4%E6%B0%B4%E5%9B%B0/>47澤水困</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/48%E6%B0%B4%E9%A2%A8%E4%BA%95/>48水風井</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/49%E6%BE%A4%E7%81%AB%E9%9D%A9/>49澤火革</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/50%E7%81%AB%E9%A2%A8%E9%BC%8E/>50火風鼎</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/51%E9%9C%87%E7%88%B2%E9%9B%B7/>51震爲雷</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/52%E8%89%AE%E7%82%BA%E5%B1%B1/>52艮為山</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/53%E9%A2%A8%E5%B1%B1%E6%BC%B8/>53風山漸</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/54%E9%9B%B7%E6%BE%A4%E6%AD%B8%E5%A6%B9/>54雷澤歸妹</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/55%E9%9B%B7%E7%81%AB%E8%B1%90/>55雷火豐</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/56%E7%81%AB%E5%B1%B1%E6%97%85/>56火山旅</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/57%E5%B7%BD%E7%82%BA%E9%A2%A8/>57巽為風</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/58%E5%85%8C%E7%88%B2%E6%BE%A4/>58兌爲澤</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/59%E9%A2%A8%E6%B0%B4%E6%B8%99/>59風水渙</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/60%E6%B0%B4%E6%BE%A4%E7%AF%80/>60水澤節</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/61%E9%A2%A8%E6%BE%A4%E4%B8%AD%E5%AD%9A/>61風澤中孚</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/62%E9%9B%B7%E5%B1%B1%E5%B0%8F%E9%81%8E/>62雷山小過</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/63%E6%B0%B4%E7%81%AB%E6%97%A2%E6%BF%9F/>63水火既濟</a></li><li><a href=/zh/docs/culture/%E5%A4%A9%E7%BA%AA/%E4%BA%BA%E9%97%B4%E9%81%93/02%E4%B8%8B%E7%BB%8F/64%E7%81%AB%E6%B0%B4%E6%9C%AA%E6%BF%9F/>64火水未濟</a></li></ul></li></ul></li></ul></li><li><input type=checkbox id=section-daa70c3e612b40fe4050f5185bb12608 class=toggle>
<label for=section-daa70c3e612b40fe4050f5185bb12608 class="flex justify-between"><a role=button>恰同学少年</a></label><ul><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/00%E7%AE%80%E4%BB%8B-%E4%BD%9C%E8%80%85/>00简介-作者</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/01%E7%AC%AC1%E7%AB%A0-%E7%AC%AC5%E7%AB%A0/>01第1章-第5章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/02%E7%AC%AC6%E7%AB%A0-%E7%AC%AC10%E7%AB%A0/>02第6章-第10章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/03%E7%AC%AC11%E7%AB%A0-%E7%AC%AC15%E7%AB%A0/>03第11章-第15章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/04%E7%AC%AC16%E7%AB%A0-%E7%AC%AC20%E7%AB%A0/>04第16章-第20章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/05%E7%AC%AC21%E7%AB%A0-%E7%AC%AC25%E7%AB%A0/>05第21章-第25章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/06%E7%AC%AC26%E7%AB%A0-%E7%AC%AC29%E7%AB%A0/>06第26章-第29章</a></li><li><a href=/zh/docs/culture/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/07%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/>07经典语录</a></li></ul></li><li><input type=checkbox id=section-ab50087f003d55e32dba86fb838050b9 class=toggle>
<label for=section-ab50087f003d55e32dba86fb838050b9 class="flex justify-between"><a role=button>如何阅读一本书</a></label><ul><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/00%E7%AE%80%E4%BB%8B-%E5%BA%8F%E8%A8%80/>00简介-序言</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/01%E7%AC%AC%E4%B8%80%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E5%B1%82%E6%AC%A1/>01第一篇_阅读的层次</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/02%E7%AC%AC%E4%BA%8C%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%B1%82%E6%AC%A1_%E5%88%86%E6%9E%90%E9%98%85%E8%AF%BB/>02第二篇_阅读的第三个层次_分析阅读</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/03%E7%AC%AC%E4%B8%89%E7%AF%87_%E9%98%85%E8%AF%BB%E4%B8%8D%E5%90%8C%E8%AF%BB%E7%89%A9%E7%9A%84%E6%96%B9%E6%B3%95/>03第三篇_阅读不同读物的方法</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/04%E7%AC%AC%E5%9B%9B%E7%AF%87_%E9%98%85%E8%AF%BB%E7%9A%84%E6%9C%80%E7%BB%88%E7%9B%AE%E6%A0%87/>04第四篇_阅读的最终目标</a></li><li><a href=/zh/docs/culture/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/05%E9%99%84%E5%BD%95/>05附录</a></li></ul></li><li><input type=checkbox id=section-3c72e7201480f45e35bf243c48374c4a class=toggle>
<label for=section-3c72e7201480f45e35bf243c48374c4a class="flex justify-between"><a role=button>古代天文历法讲座</a></label><ul><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/00%E7%89%88%E6%9D%83-%E5%BA%8F-%E5%89%8D%E8%A8%80/>00版权-序-前言</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/01%E7%AC%AC1%E8%AE%B2-%E7%AC%AC3%E8%AE%B2/>01第1讲-第3讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/02%E7%AC%AC4%E8%AE%B2-%E7%AC%AC5%E8%AE%B2/>02第4讲-第5讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/03%E7%AC%AC6%E8%AE%B2-%E7%AC%AC7%E8%AE%B2/>03第6讲-第7讲</a></li><li><a href=/zh/docs/culture/%E5%8F%A4%E4%BB%A3%E5%A4%A9%E6%96%87%E5%8E%86%E6%B3%95%E8%AE%B2%E5%BA%A7/04%E9%99%84%E5%BD%95-%E9%99%84%E8%A1%A8-%E5%90%8E%E8%AE%B0/>04附录-附表-后记</a></li></ul></li><li><input type=checkbox id=section-9d5fdf0456d3af9d5079c94a509d2900 class=toggle>
<label for=section-9d5fdf0456d3af9d5079c94a509d2900 class="flex justify-between"><a role=button>置身事内</a></label><ul><li><a href=/zh/docs/culture/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/01%E4%B8%8A%E7%AF%87/>01上篇</a></li><li><a href=/zh/docs/culture/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/02%E4%B8%8B%E7%AF%87/>02下篇</a></li></ul></li><li><input type=checkbox id=section-51674e319d079fc9a9944a0500f74ff3 class=toggle>
<label for=section-51674e319d079fc9a9944a0500f74ff3 class="flex justify-between"><a role=button>中国通史 吕思勉</a></label><ul><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2_%E5%90%95%E6%80%9D%E5%8B%89/00%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83-%E8%AF%BB%E5%90%8E-%E8%87%AA%E5%BA%8F/>00封面-版权-读后-自序</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2_%E5%90%95%E6%80%9D%E5%8B%89/01%E4%B8%8A%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%8F%B2/>01上篇-中国政治史</a></li><li><a href=/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2_%E5%90%95%E6%80%9D%E5%8B%89/02%E4%B8%8B%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%96%87%E5%8C%96%E5%8F%B2/>02下篇-中国文化史</a></li></ul></li><li><input type=checkbox id=section-77e618b9fdc931e63e2343a70dbe6630 class=toggle>
<label for=section-77e618b9fdc931e63e2343a70dbe6630 class="flex justify-between"><a role=button>资治通鉴</a></label><ul><li><input type=checkbox id=section-196ebc38f91a63032ca3483e389aa4c5 class=toggle>
<label for=section-196ebc38f91a63032ca3483e389aa4c5 class="flex justify-between"><a role=button>周纪</a></label><ul><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/001%E5%91%A8%E7%BA%AA%E4%B8%80/>001周纪一</a></li><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/>基本知识</a></li></ul></li></ul></li><li><input type=checkbox id=section-362045e222c56ebea46dd002b63dafc5 class=toggle>
<label for=section-362045e222c56ebea46dd002b63dafc5 class="flex justify-between"><a role=button>南明史</a></label><ul><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/00%E7%89%88%E6%9D%83_%E5%BA%8F_%E5%87%A1%E4%BE%8B/>00版权_序_凡例</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/01%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%98%8E%E6%9C%9D%E8%A6%86%E4%BA%A1%E5%90%8E%E7%9A%84%E5%85%A8%E5%9B%BD%E5%BD%A2%E5%8A%BF/>01第一章 明朝覆亡后的全国形势</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/02%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%BC%98%E5%85%89%E6%9C%9D%E5%BB%B7%E7%9A%84%E5%BB%BA%E7%AB%8B/>02第二章 弘光朝廷的建立</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/03%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%BC%98%E5%85%89%E6%9C%9D%E5%BB%B7%E7%9A%84%E5%81%8F%E5%AE%89%E6%B1%9F%E6%B7%AE/>03第三章 弘光朝廷的偏安江淮</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/04%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%A7%E9%A1%BA%E6%94%BF%E6%9D%83%E7%9A%84%E8%A6%86%E4%BA%A1/>04第四章 大顺政权的覆亡</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/05%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%BC%98%E5%85%89%E6%94%BF%E6%9D%83%E7%9A%84%E7%93%A6%E8%A7%A3/>05第五章 弘光政权的瓦解</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/06%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B8%85%E5%BB%B7%E7%BB%9F%E6%B2%BB%E8%80%85%E6%8E%A8%E8%A1%8C%E7%9A%84%E6%B0%91%E6%97%8F%E5%BE%81%E6%9C%8D%E5%92%8C%E6%B0%91%E6%97%8F%E5%8E%8B%E8%BF%AB%E6%94%BF%E7%AD%96/>06第六章 清廷统治者推行的民族征服和民族压迫政策</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/07%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%90%84%E5%9C%B0%E6%8A%97%E6%B8%85%E8%BF%90%E5%8A%A8%E7%9A%84%E5%85%B4%E8%B5%B7/>07第七章 各地抗清运动的兴起</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/08%E7%AC%AC%E5%85%AB%E7%AB%A0-%E9%9A%86%E6%AD%A6%E6%94%BF%E6%9D%83%E5%90%8C%E9%B2%81%E7%9B%91%E5%9B%BD%E7%9A%84%E4%BA%89%E7%AB%8B/>08第八章 隆武政权同鲁监国的争立</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/09%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%9A%86%E6%AD%A6%E6%94%BF%E6%9D%83%E7%9A%84%E4%BD%9C%E4%B8%BA%E5%92%8C%E8%A6%86%E8%B4%A5/>09第九章 隆武政权的作为和覆败</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/10%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%A4%A7%E9%A1%BA%E5%86%9B%E8%81%94%E6%98%8E%E6%8A%97%E6%B8%85/>10第十章 大顺军联明抗清</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/11%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%A4%A7%E8%A5%BF%E5%86%9B%E7%9A%84%E7%BB%8F%E8%90%A5%E4%BA%91%E5%8D%97/>11第十一章 大西军的经营云南</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/12%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E9%83%91%E6%88%90%E5%8A%9F%E8%B5%B7%E5%85%B5%E4%B8%8E%E9%B2%81%E7%9B%91%E5%9B%BD%E5%9C%A8%E6%B5%99%E9%97%BD%E6%8A%97%E6%B8%85/>12第十二章 郑成功起兵与鲁监国在浙闽抗清</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/13%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%B0%B8%E5%8E%86%E6%9C%9D%E5%BB%B7%E7%9A%84%E5%BB%BA%E7%AB%8B/>13第十三章 永历朝廷的建立</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/14%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%83%91%E6%88%90%E5%8A%9F%E5%9C%A8%E9%97%BD%E7%B2%A4%E6%B2%BF%E6%B5%B7%E5%9C%B0%E5%8C%BA%E7%9A%84%E5%86%9B%E4%BA%8B%E6%B4%BB%E5%8A%A8/>14第十四章 郑成功在闽粤沿海地区的军事活动</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/15%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E5%90%B4%E8%83%9C%E5%85%86%E7%8E%8B%E5%85%89%E6%B3%B0%E7%AD%89%E7%9A%84%E5%8F%8D%E6%B8%85/>15第十五章 吴胜兆、王光泰等的反清</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/16%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E9%87%91%E5%A3%B0%E6%A1%93%E6%9D%8E%E6%88%90%E6%A0%8B%E7%9A%84%E5%8F%8D%E6%B8%85%E5%BD%92%E6%98%8E/>16第十六章 金声桓、李成栋的反清归明</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/17%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-%E5%8C%97%E6%96%B9%E5%90%84%E7%9C%81%E7%9A%84%E5%8F%8D%E6%B8%85%E8%BF%90%E5%8A%A8/>17第十七章 北方各省的反清运动</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/18%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-16481649%E5%B9%B4%E6%B9%96%E5%8D%97%E6%88%98%E5%B1%80/>18第十八章 1648—1649年湖南战局</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/19%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0-%E6%B0%B8%E5%8E%86%E6%9C%9D%E5%BB%B7%E5%86%85%E9%83%A8%E7%9A%84%E5%85%9A%E4%BA%89/>19第十九章 永历朝廷内部的党争</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/20%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0-%E6%B8%85%E5%86%9B%E6%94%BB%E5%8D%A0%E6%A1%82%E6%9E%97%E5%B9%BF%E5%B7%9E/>20第二十章 清军攻占桂林、广州</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/21%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%A4%A7%E8%A5%BF%E5%86%9B%E7%9A%84%E8%81%94%E6%98%8E%E6%8A%97%E6%B8%85/>21第二十一章 大西军的联明抗清</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/22%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0-16511653%E5%B9%B4%E6%B5%99%E9%97%BD%E8%B5%A3%E6%8A%97%E6%B8%85%E5%8A%BF%E5%8A%9B%E7%9A%84%E6%B6%88%E9%95%BF/>22第二十二章 1651—1653年浙闽赣抗清势力的消长</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/23%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%AD%99%E5%8F%AF%E6%9C%9B%E9%83%A8%E7%BD%B2%E7%9A%84%E6%B9%98%E6%A1%82%E5%B7%9D%E5%85%A8%E9%9D%A2%E5%8F%8D%E6%94%BB/>23第二十三章 孙可望部署的湘、桂、川全面反攻</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/24%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0-%E6%B8%85%E5%BB%B7%E5%8A%A0%E5%BC%BA%E6%8E%A8%E8%A1%8C%E4%BB%A5%E6%B1%89%E5%88%B6%E6%B1%89%E6%94%BF%E7%AD%96/>24第二十四章 清廷加强推行以汉制汉政策</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/25%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E7%AB%A0-%E6%9D%8E%E5%AE%9A%E5%9B%BD%E7%9A%84%E4%B8%A4%E6%AC%A1%E8%BF%9B%E5%86%9B%E5%B9%BF%E4%B8%9C/>25第二十五章 李定国的两次进军广东</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/26%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E7%AB%A0-1654%E5%B9%B4%E4%BC%9A%E5%B8%88%E9%95%BF%E6%B1%9F%E7%9A%84%E6%88%98%E7%95%A5%E8%AE%BE%E6%83%B3/>26第二十六章 1654年会师长江的战略设想</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/27%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E7%AB%A0-%E6%9D%8E%E5%AE%9A%E5%9B%BD%E8%BF%8E%E6%B0%B8%E5%8E%86%E5%B8%9D%E5%85%A5%E4%BA%91%E5%8D%97%E5%92%8C%E5%AD%99%E5%8F%AF%E6%9C%9B%E7%9A%84%E9%99%8D%E6%B8%85/>27第二十七章 李定国迎永历帝入云南和孙可望的降清</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/28%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E7%AB%A0-%E6%B8%85%E5%86%9B%E5%A4%A7%E4%B8%BE%E8%BF%9B%E6%94%BB%E8%A5%BF%E5%8D%97%E5%8F%8A%E6%B0%B8%E5%8E%86%E6%9C%9D%E5%BB%B7%E7%9A%84%E6%92%AD%E8%BF%81/>28第二十八章 清军大举进攻西南及永历朝廷的播迁</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/29%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D%E7%AB%A0-%E9%83%91%E6%88%90%E5%8A%9F%E5%BC%A0%E7%85%8C%E8%A8%80%E9%95%BF%E6%B1%9F%E4%B9%8B%E5%BD%B9/>29第二十九章 郑成功、张煌言长江之役</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/30%E7%AC%AC%E4%B8%89%E5%8D%81%E7%AB%A0-%E6%B0%B8%E5%8E%86%E6%9C%9D%E5%BB%B7%E7%9A%84%E8%A6%86%E4%BA%A1/>30第三十章 永历朝廷的覆亡</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/31%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%80%E7%AB%A0-%E9%83%91%E6%88%90%E5%8A%9F%E6%94%B6%E5%A4%8D%E5%8F%B0%E6%B9%BE/>31第三十一章 郑成功收复台湾</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/32%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%A4%94%E4%B8%9C%E6%8A%97%E6%B8%85%E5%9F%BA%E5%9C%B0%E7%9A%84%E8%A6%86%E7%81%AD/>32第三十二章 夔东抗清基地的覆灭</a></li><li><a href=/zh/docs/culture/%E5%8D%97%E6%98%8E%E5%8F%B2/33%E5%BC%95%E7%94%A8_%E5%90%8E%E8%AE%B0/>33引用_后记</a></li></ul></li><li><input type=checkbox id=section-3779d2959b0683623b8763733c4394b9 class=toggle>
<label for=section-3779d2959b0683623b8763733c4394b9 class="flex justify-between"><a role=button>左传</a></label><ul><li><a href=/zh/docs/culture/%E5%B7%A6%E4%BC%A0/00%E5%89%8D%E8%A8%80/>00前言</a></li><li><a href=/zh/docs/culture/%E5%B7%A6%E4%BC%A0/01%E9%9A%90%E5%85%AC/>01隐公</a></li><li><a href=/zh/docs/culture/%E5%B7%A6%E4%BC%A0/02%E6%A1%93%E5%85%AC/>02桓公</a></li><li><a href=/zh/docs/culture/%E5%B7%A6%E4%BC%A0/03%E5%BA%84%E5%85%AC/>03庄公</a></li><li><a href=/zh/docs/culture/%E5%B7%A6%E4%BC%A0/04%E9%97%B5%E5%85%AC/>04闵公</a></li><li><a href=/zh/docs/culture/%E5%B7%A6%E4%BC%A0/05%E5%83%96%E5%85%AC/>05僖公</a></li><li><a href=/zh/docs/culture/%E5%B7%A6%E4%BC%A0/06%E6%96%87%E5%85%AC/>06文公</a></li><li><a href=/zh/docs/culture/%E5%B7%A6%E4%BC%A0/07%E5%AE%A3%E5%85%AC/>07宣公</a></li><li><a href=/zh/docs/culture/%E5%B7%A6%E4%BC%A0/08%E6%88%90%E5%85%AC/>08成公</a></li><li><a href=/zh/docs/culture/%E5%B7%A6%E4%BC%A0/09%E8%A5%84%E5%85%AC/>09襄公</a></li><li><a href=/zh/docs/culture/%E5%B7%A6%E4%BC%A0/10%E6%98%AD%E5%85%AC/>10昭公</a></li><li><a href=/zh/docs/culture/%E5%B7%A6%E4%BC%A0/11%E5%AE%9A%E5%85%AC/>11定公</a></li><li><a href=/zh/docs/culture/%E5%B7%A6%E4%BC%A0/12%E5%93%80%E5%85%AC/>12哀公</a></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/life/>生活</a><ul><li><a href=/zh/docs/life/dailyExcerpt/>00每日摘抄</a></li><li><a href=/zh/docs/life/20231101/>20231101灭亡</a></li><li><a href=/zh/docs/life/20231227/>20231227起床临感</a></li><li><a href=/zh/docs/life/20240626/>20240626知命不惧 日日自新</a></li><li><a href=/zh/docs/life/20250904/>2025-09-04</a></li><li><a href=/zh/docs/life/20250103/>20250103理</a></li><li><a href=/zh/docs/life/20250831/>20250831关于算命的思索</a></li><li><input type=checkbox id=section-c7f767205668758142bb8053263cc14f class=toggle>
<label for=section-c7f767205668758142bb8053263cc14f class="flex justify-between"><a role=button>往日归档</a></label><ul><li><a href=/zh/docs/life/archive/20121226/>20121226-2021年最后一个周日</a></li><li><a href=/zh/docs/life/archive/20220416/>20220416《作酒》有感</a></li><li><a href=/zh/docs/life/archive/20220724/>20220724人为什么要结婚(找对象)</a></li><li><a href=/zh/docs/life/archive/20230912/>20230912病愈 有感</a></li><li><a href=/zh/docs/life/archive/20230913/>20230913鲇鱼后思</a></li><li><a href=/zh/docs/life/archive/20231013/>20231013沉没</a></li><li><a href=/zh/docs/life/archive/20231021/>20231021沉沦</a></li><li><a href=/zh/docs/life/archive/20231026/>20231026成就</a></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/problem/>问题解决</a><ul><li><input type=checkbox id=section-ef3324c710f7241c89fc009a5f576fbc class=toggle>
<label for=section-ef3324c710f7241c89fc009a5f576fbc class="flex justify-between"><a role=button>Linux</a></label><ul><li><a href=/zh/docs/problem/Linux/20230815/>Debian问题处理1</a></li><li><a href=/zh/docs/problem/Linux/20230817/>Debian问题处理2</a></li><li><a href=/zh/docs/problem/Linux/20230819/>Debian问题处理3</a></li><li><a href=/zh/docs/problem/Linux/20230919/>Linux操作符问题</a></li><li><a href=/zh/docs/problem/Linux/20221101/>post</a></li><li><a href=/zh/docs/problem/Linux/20230523/>zsh卸载后root无法登录及vm扩容centos7报错处理</a></li><li><a href=/zh/docs/problem/Linux/20230803/>安卓手机及平板安装linuxDeploy的问题简记</a></li><li><a href=/zh/docs/problem/Linux/20250331/>平板安装linuxDeploy的问题简记</a></li></ul></li><li><input type=checkbox id=section-ab4f1dd893a7409a00858148e98c245c class=toggle>
<label for=section-ab4f1dd893a7409a00858148e98c245c class="flex justify-between"><a role=button>Other</a></label><ul><li><a href=/zh/docs/problem/Other/01/>如何搜索</a></li></ul></li><li><input type=checkbox id=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class=toggle>
<label for=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/problem/JVM/20230526/>JDK代理和CGLIB代理</a></li><li><a href=/zh/docs/problem/JVM/2023052302/>linux中调试open jdk</a></li></ul></li><li><input type=checkbox id=section-a028a45b205904a783d0c60e8a184391 class=toggle>
<label for=section-a028a45b205904a783d0c60e8a184391 class="flex justify-between"><a role=button>Hexo</a></label><ul><li><a href=/zh/docs/problem/Hexo/01/>hexo在线查看pdf</a></li></ul></li><li><input type=checkbox id=section-1c55bf7a5578a7de17cc1ee45681106b class=toggle>
<label for=section-1c55bf7a5578a7de17cc1ee45681106b class="flex justify-between"><a role=button>Idea</a></label><ul><li><a href=/zh/docs/problem/Idea/01/>问题01</a></li></ul></li><li><input type=checkbox id=section-66dd985e53d8e0b78efdab983762411c class=toggle>
<label for=section-66dd985e53d8e0b78efdab983762411c class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/problem/Git/01/>git使用ssh连不上</a></li></ul></li><li><input type=checkbox id=section-9440d21f7eb9f8cf7f45b16969ab18dc class=toggle>
<label for=section-9440d21f7eb9f8cf7f45b16969ab18dc class="flex justify-between"><a role=button>Hugo</a></label><ul><li><a href=/zh/docs/problem/Hugo/p1/>hugo踩坑</a></li><li><a href=/zh/docs/problem/Hugo/01a/>图片测试(hugo踩坑)</a></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/technology/>技术</a><ul><li><input type=checkbox id=section-d9652e1d39ed08192f3dd99c4361d9ad class=toggle checked>
<label for=section-d9652e1d39ed08192f3dd99c4361d9ad class="flex justify-between"><a role=button>System</a></label><ul><li><span>SpringCloud</span><ul><li><input type=checkbox id=section-34c1382ca3a0d6868e10683db155c5f7 class=toggle>
<label for=section-34c1382ca3a0d6868e10683db155c5f7 class="flex justify-between"><a role=button>视频笔记</a></label><ul><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/05MachineLevelProgramming01Basic/>05MachineLevelProgramming01Basic</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/06Machine-LevelProgramming02Control/>06Machine-LevelProgramming02Control</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/07MachineLevelProgramming03Procedures/>07MachineLevelProgramming03Procedures</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/08MachineLevelProgramming04Data/>08MachineLevelProgramming04Data</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/16SystemLevelI_O/>16SystemLevelI_O</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/21NetworkProgramming01/>21NetworkProgramming01</a></li></ul></li><li><input type=checkbox id=section-c5bcefb305c982df1e56b6f496a0df25 class=toggle checked>
<label for=section-c5bcefb305c982df1e56b6f496a0df25 class="flex justify-between"><a role=button>书籍</a></label><ul><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E5%B0%81%E9%9D%A2-%E7%9B%AE%E5%BD%95/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC10%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E7%BA%A7I_O/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC11%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC12%E7%AB%A0-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC1%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC2%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC3%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/ class=active>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC4%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC5%E7%AB%A0-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC6%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC7%E7%AB%A0-%E9%93%BE%E6%8E%A5/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC9%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C-2-6/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E7%A8%8B%E5%BA%8F%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%92%8C%E9%80%9A%E4%BF%A1-10-12/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-7-9/>Index</a></li><li><a href=/zh/docs/technology/System/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%B9%A6%E7%B1%8D/%E9%99%84%E5%BD%95A-%E5%B0%81%E5%BA%95/>Index</a></li></ul></li></ul></li></ul></li><li><input type=checkbox id=section-79ad4ec36247c32c4cd2190b9ba6b65a class=toggle>
<label for=section-79ad4ec36247c32c4cd2190b9ba6b65a class="flex justify-between"><a role=button>Markdown</a></label><ul><li><a href=/zh/docs/technology/Markdown/_SuperTutorial_/>Markdown超级教程</a></li><li><a href=/zh/docs/technology/Markdown/EpubsToMd/>将epub文件转换为md文件</a></li></ul></li><li><input type=checkbox id=section-2fb98c56480f40c379c8653613ac5510 class=toggle>
<label for=section-2fb98c56480f40c379c8653613ac5510 class="flex justify-between"><a role=button>Cpp</a></label><ul><li><input type=checkbox id=section-0bf9e6fc3c3b29b6dfa5edcdd6349f4a class=toggle>
<label for=section-0bf9e6fc3c3b29b6dfa5edcdd6349f4a class="flex justify-between"><a href=/zh/docs/technology/cpp/chernoCPP/>Cherno Cpp</a></label><ul><li><a href=/zh/docs/technology/cpp/chernoCPP/01-/>01-</a></li></ul></li><li><a href=/zh/docs/technology/cpp/leetcode/>154【杂项】算竞常用_C++_STL_用法</a></li><li><a href=/zh/docs/technology/cpp/qt/>qt学习</a></li></ul></li><li><input type=checkbox id=section-d2e5dc71fe2274ddaa089e125f33ae58 class=toggle>
<label for=section-d2e5dc71fe2274ddaa089e125f33ae58 class="flex justify-between"><a role=button>My SQL</a></label><ul><li><input type=checkbox id=section-385256c91dd6127cb06668afb2ab262b class=toggle>
<label for=section-385256c91dd6127cb06668afb2ab262b class="flex justify-between"><a role=button>mysql_进阶_施磊</a></label><ul><li><a href=/zh/docs/technology/MySQL/advanced_shilei/01/>01基础知识</a></li><li><a href=/zh/docs/technology/MySQL/advanced_shilei/02/>02增删改查</a></li><li><a href=/zh/docs/technology/MySQL/advanced_shilei/03/>03存储引擎</a></li><li><a href=/zh/docs/technology/MySQL/advanced_shilei/04/>04事务</a></li><li><a href=/zh/docs/technology/MySQL/advanced_shilei/05/>05日志</a></li></ul></li><li><input type=checkbox id=section-b36f39b28986b079f4216fd3e38bfa3e class=toggle>
<label for=section-b36f39b28986b079f4216fd3e38bfa3e class="flex justify-between"><a role=button>My Sql是怎样运行的</a></label><ul><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC0%E7%AB%A0_%E4%B8%87%E9%87%8C%E9%95%BF%E5%BE%81%E7%AC%AC%E4%B8%80%E6%AD%A5%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81-%E5%A6%82%E4%BD%95%E6%84%89%E5%BF%AB%E7%9A%84%E9%98%85%E8%AF%BB%E6%9C%AC%E5%B0%8F%E5%86%8C/>第0章_万里长征第一步(非常重要)-如何愉快的阅读本小册</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC10%E7%AB%A0_%E6%9D%A1%E6%9D%A1%E5%A4%A7%E8%B7%AF%E9%80%9A%E7%BD%97%E9%A9%AC-%E5%8D%95%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/>第10章_条条大路通罗马-单表访问方法</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC11%E7%AB%A0_%E4%B8%A4%E4%B8%AA%E8%A1%A8%E7%9A%84%E4%BA%B2%E5%AF%86%E6%8E%A5%E8%A7%A6-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86/>第11章_两个表的亲密接触-连接的原理</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC12%E7%AB%A0_%E8%B0%81%E6%9C%80%E4%BE%BF%E5%AE%9C%E5%B0%B1%E9%80%89%E8%B0%81-MySQL%E5%9F%BA%E4%BA%8E%E6%88%90%E6%9C%AC%E7%9A%84%E4%BC%98%E5%8C%96/>第12章_谁最便宜就选谁-MySQL基于成本的优化</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC13%E7%AB%A0_%E5%85%B5%E9%A9%AC%E6%9C%AA%E5%8A%A8%E7%B2%AE%E8%8D%89%E5%85%88%E8%A1%8C-InnoDB%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%B6%E9%9B%86%E7%9A%84/>第13章_兵马未动粮草先行-InnoDB统计数据是如何收集的</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC14%E7%AB%A0_%E4%B8%8D%E5%A5%BD%E7%9C%8B%E5%B0%B1%E8%A6%81%E5%A4%9A%E6%95%B4%E5%AE%B9-MySQL%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E4%BC%98%E5%8C%96%E5%86%85%E5%90%AB%E5%85%B3%E4%BA%8E%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E4%BA%8C%E4%B8%89%E4%BA%8B%E5%84%BF/>第14章_不好看就要多整容-MySQL基于规则的优化(内含关于子查询优化二三事儿)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC15%E7%AB%A0_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8A/>第15章_查询优化的百科全书-Explain详解(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC16%E7%AB%A0_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E7%99%BE%E7%A7%91%E5%85%A8%E4%B9%A6-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8B/>第16章_查询优化的百科全书-Explain详解(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC17%E7%AB%A0_%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-optimizer_trace%E8%A1%A8%E7%9A%84%E7%A5%9E%E5%99%A8%E5%8A%9F%E6%95%88/>第17章_神兵利器-optimizer_trace表的神器功效</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC18%E7%AB%A0_%E8%B0%83%E8%8A%82%E7%A3%81%E7%9B%98%E5%92%8CCPU%E7%9A%84%E7%9F%9B%E7%9B%BE-InnoDB%E7%9A%84BufferPool/>第18章_调节磁盘和CPU的矛盾-InnoDB的BufferPool</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC19%E7%AB%A0_%E4%BB%8E%E7%8C%AB%E7%88%B7%E8%A2%AB%E6%9D%80%E8%AF%B4%E8%B5%B7-%E4%BA%8B%E5%8A%A1%E7%AE%80%E4%BB%8B/>第19章_从猫爷被杀说起-事务简介</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC1%E7%AB%A0_%E8%A3%85%E4%BD%9C%E8%87%AA%E5%B7%B1%E6%98%AF%E4%B8%AA%E5%B0%8F%E7%99%BD-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86MySQL/>第1章_装作自己是个小白-重新认识MySQL</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC20%E7%AB%A0_%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%E4%B8%8A/>第20章_说过的话就一定要办到-redo日志(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC21%E7%AB%A0_%E8%AF%B4%E8%BF%87%E7%9A%84%E8%AF%9D%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%A6%81%E5%8A%9E%E5%88%B0-redo%E6%97%A5%E5%BF%97%E4%B8%8B/>第21章_说过的话就一定要办到-redo日志(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC22%E7%AB%A0_%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%E4%B8%8A/>第22章_后悔了怎么办-undo日志(上)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC23%E7%AB%A0_%E5%90%8E%E6%82%94%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E-undo%E6%97%A5%E5%BF%97%E4%B8%8B/>第23章_后悔了怎么办-undo日志(下)</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC24%E7%AB%A0_%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%9A%E5%B9%85%E9%9D%A2%E5%AD%94-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC/>第24章_一条记录的多幅面孔-事务的隔离级别与MVCC</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC25%E7%AB%A0_%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E8%80%81%E5%A4%A7%E9%9A%BE-%E9%94%81/>第25章_工作面试老大难-锁</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC26%E7%AB%A0_%E5%86%99%E4%BD%9C%E6%9C%AC%E4%B9%A6%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/>第26章_写作本书时用到的一些重要的参考资料</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC2%E7%AB%A0_MySQL%E7%9A%84%E8%B0%83%E6%8E%A7%E6%8C%89%E9%92%AE-%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/>第2章_MySQL的调控按钮-启动选项和系统变量</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC3%E7%AB%A0_%E4%B9%B1%E7%A0%81%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/>第3章_乱码的前世今生-字符集和比较规则</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC4%E7%AB%A0_%E4%BB%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E8%AF%B4%E8%B5%B7-InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84/>第4章_从一条记录说起-InnoDB记录结构</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC5%E7%AB%A0-%E7%9B%9B%E6%94%BE%E8%AE%B0%E5%BD%95%E7%9A%84%E5%A4%A7%E7%9B%92%E5%AD%90-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/>第5章 盛放记录的大盒子-InnoDB数据页结构</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC6%E7%AB%A0_%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84%E7%A7%98%E7%B1%8D-B+%E6%A0%91%E7%B4%A2%E5%BC%95/>第6章_快速查询的秘籍-B+树索引</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC7%E7%AB%A0_%E5%A5%BD%E4%B8%9C%E8%A5%BF%E4%B9%9F%E5%BE%97%E5%85%88%E5%AD%A6%E4%BC%9A%E6%80%8E%E4%B9%88%E7%94%A8-B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/>第7章_好东西也得先学会怎么用-B+树索引的使用</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC8%E7%AB%A0_%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%B6-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/>第8章_数据的家-MySQL的数据目录</a></li><li><a href=/zh/docs/technology/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/%E7%AC%AC9%E7%AB%A0_%E5%AD%98%E6%94%BE%E9%A1%B5%E7%9A%84%E5%A4%A7%E6%B1%A0%E5%AD%90-InnoDB%E7%9A%84%E8%A1%A8%E7%A9%BA%E9%97%B4/>第9章_存放页的大池子-InnoDB的表空间</a></li></ul></li><li><input type=checkbox id=section-14acbe73a39f7c2e8d055bbdbab560d6 class=toggle>
<label for=section-14acbe73a39f7c2e8d055bbdbab560d6 class="flex justify-between"><a role=button>_MySQL是怎样运行的_</a></label><ul><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/01/>01初识MySQL</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/02/>02启动选项和系统变量</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/03/>03字符集和比较规则</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/04/>04InnoDB记录存储结构</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/05/>05InnoDB数据页结构</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/06/>06B+树索引</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/07/>07B+数索引的使用</a></li><li><a href=/zh/docs/technology/MySQL/_how_mysql_run_/08/>08数据的家--MySQL的数据目录</a></li></ul></li><li><input type=checkbox id=section-522269efe4a436e18b16a29ff12d542d class=toggle>
<label for=section-522269efe4a436e18b16a29ff12d542d class="flex justify-between"><a role=button>高性能 My SQL</a></label><ul><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC10%E7%AB%A0%E5%A4%8D%E5%88%B6/>第10章复制</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC11%E7%AB%A0%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84MySQL/>第11章可扩展的MySQL</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC12%E7%AB%A0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/>第12章高可用性</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC13%E7%AB%A0%E4%BA%91%E7%AB%AF%E7%9A%84MySQL/>第13章云端的MySQL</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC14%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82%E4%BC%98%E5%8C%96/>第14章应用层优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC15%E7%AB%A0%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/>第15章备份与恢复</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC16%E7%AB%A0MySQL%E7%94%A8%E6%88%B7%E5%B7%A5%E5%85%B7/>第16章MySQL用户工具</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC1%E7%AB%A0MySQL%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2/>第1章MySQL架构与历史</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC2%E7%AB%A0MySQL%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/>第2章MySQL基准测试</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC3%E7%AB%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/>第3章服务器性能剖析</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC4%E7%AB%A0Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/>第4章Schema与数据类型优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC5%E7%AB%A0%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/>第5章创建高性能的索引</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC6%E7%AB%A0%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>第6章查询性能优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC7%E7%AB%A0MySQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/>第7章MySQL高级特性</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC8%E7%AB%A0%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE/>第8章优化服务器设置</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E7%AC%AC9%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96/>第9章操作系统和硬件优化</a></li><li><a href=/zh/docs/technology/MySQL/_%E9%AB%98%E6%80%A7%E8%83%BDMySQL_/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83/>封面-版权</a></li></ul></li><li><input type=checkbox id=section-33ad04dc8d65b11ab6b2d2e0964c3c89 class=toggle>
<label for=section-33ad04dc8d65b11ab6b2d2e0964c3c89 class="flex justify-between"><a role=button>进阶(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MySQL/bl_sgg_/96-00/>mysql高阶_sgg 96-00</a></li></ul></li></ul></li><li><input type=checkbox id=section-1dd4601389ea65ef400f95373226aee0 class=toggle>
<label for=section-1dd4601389ea65ef400f95373226aee0 class="flex justify-between"><a role=button>Linux</a></label><ul><li><a href=/zh/docs/technology/Linux/_TheLinuxCommandsHandbook_/>_TheLinuxCommandsHandbook_</a></li><li><input type=checkbox id=section-eb3a110e9a221e46d625b63087e91152 class=toggle>
<label for=section-eb3a110e9a221e46d625b63087e91152 class="flex justify-between"><a role=button>SHELL编程(learnLinuxTV)_</a></label><ul><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/01-04/>01-04</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/05If/>05If</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/06ExitCode/>06ExitCode</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/07-10/>07-10</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/11DataStreams/>11DataStreams</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/12-15/>12-15</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/16-18/>16-18</a></li></ul></li><li><a href=/zh/docs/technology/Linux/create_clone/>vmware上linux主机的安装和克隆</a></li><li><input type=checkbox id=section-cd7838d42e3d9f745d945ce90940f02e class=toggle>
<label for=section-cd7838d42e3d9f745d945ce90940f02e class="flex justify-between"><a role=button>韩顺平老师_</a></label><ul><li><a href=/zh/docs/technology/Linux/hanshunping_/52-x/>52-X</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/01-06/>linux_韩老师_01-06</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/07-11/>linux_韩老师_07-11</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/12-20/>linux_韩老师_12-20</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/21-27/>linux_韩老师_21-33</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/28-39/>linux_韩老师_28-39</a></li><li><a href=/zh/docs/technology/Linux/hanshunping_/40-51/>linux_韩老师_40-51</a></li></ul></li><li><a href=/zh/docs/technology/Linux/basic/>基本操作</a></li></ul></li><li><input type=checkbox id=section-9f56b27db6873dfaab68a13a9088b050 class=toggle>
<label for=section-9f56b27db6873dfaab68a13a9088b050 class="flex justify-between"><a role=button>Reg Exp</a></label><ul><li><input type=checkbox id=section-e7092def48f35456be32e3b6257559e4 class=toggle>
<label for=section-e7092def48f35456be32e3b6257559e4 class="flex justify-between"><a role=button>基础(CoreySchafer)_</a></label><ul><li><a href=/zh/docs/technology/RegExp/baseCoreySchafer_/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class=toggle>
<label for=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class="flex justify-between"><a role=button>Hugo</a></label><ul><li><input type=checkbox id=section-d72f299b202b2766d1efe5fb807ed184 class=toggle>
<label for=section-d72f299b202b2766d1efe5fb807ed184 class="flex justify-between"><a role=button>基础(Giraffe学院)_</a></label><ul><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced01-10/>hugo进阶学习01-10</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced11-16/>hugo进阶学习11-15</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced17-19/>hugo进阶学习17-19</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy_/advanced20-23/>hugo进阶学习20-23</a></li></ul></li><li><input type=checkbox id=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class=toggle>
<label for=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class="flex justify-between"><a role=button>主题</a></label><ul><li><a href=/zh/docs/technology/Hugo/themes/PaperMod/01/>使用PaperMode</a></li></ul></li></ul></li><li><input type=checkbox id=section-43be5f3c9fb2465efc746ae00240e4b3 class=toggle>
<label for=section-43be5f3c9fb2465efc746ae00240e4b3 class="flex justify-between"><a role=button>Obsidian</a></label><ul><li><a href=/zh/docs/technology/Obsidian/border-theme/>border-theme背景图片问题</a></li><li><a href=/zh/docs/technology/Obsidian/obsidian-theme/>obsidian-theme</a></li><li><a href=/zh/docs/technology/Obsidian/plugin/>plugin</a></li></ul></li><li><input type=checkbox id=section-7123c56777444b2f7157631dd88ad8f6 class=toggle>
<label for=section-7123c56777444b2f7157631dd88ad8f6 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Redis/redis-cluster/>redis集群搭建</a></li><li><a href=/zh/docs/technology/Redis/rsync-use/>rsync使用</a></li><li><input type=checkbox id=section-e6cea4f92582460cfa10699a07a10e32 class=toggle>
<label for=section-e6cea4f92582460cfa10699a07a10e32 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/01-05/>redis_尚硅谷_01-05</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/06-11/>redis_尚硅谷_06-11</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/12-17/>redis_尚硅谷_12-17</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/18/>redis_尚硅谷_18</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af_/19-A/>redis_尚硅谷_19-A</a></li></ul></li></ul></li><li><input type=checkbox id=section-a94b8d7740a71c28fc6e0f89885b2468 class=toggle>
<label for=section-a94b8d7740a71c28fc6e0f89885b2468 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><input type=checkbox id=section-64c6733376d70496ded44b4ef3db6718 class=toggle>
<label for=section-64c6733376d70496ded44b4ef3db6718 class="flex justify-between"><a role=button>_深入理解Java虚拟机_</a></label><ul><li><a href=/zh/docs/technology/JVM/_understanding_the_jvm_/03/>03垃圾收集器与内存分配策略</a></li></ul></li></ul></li><li><input type=checkbox id=section-2fa8d2f95840b0143e19fcee5ee1ad97 class=toggle>
<label for=section-2fa8d2f95840b0143e19fcee5ee1ad97 class="flex justify-between"><a role=button>SpringCloud</a></label><ul><li><input type=checkbox id=section-b7a5506013de8d65cad1cac0f659f728 class=toggle>
<label for=section-b7a5506013de8d65cad1cac0f659f728 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/springCloud/bl_zhouyang_/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-f54112ca99b135fbc484938888b1f1a2 class=toggle>
<label for=section-f54112ca99b135fbc484938888b1f1a2 class="flex justify-between"><a href=/zh/docs/technology/Review/>面试</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/>JavaGuide</a><ul><li><input type=checkbox id=section-c01151f806b917cd0ecc4cffa72c3402 class=toggle>
<label for=section-c01151f806b917cd0ecc4cffa72c3402 class="flex justify-between"><a role=button>Java基础</a></label><ul><li><input type=checkbox id=section-8f747d8f024fbfe2b392a25696e01266 class=toggle>
<label for=section-8f747d8f024fbfe2b392a25696e01266 class="flex justify-between"><a role=button>IO</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0201lyio/>io基础</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0203lyio-model/>io模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0202lyio-design-patterns/>io设计模式</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0402lygarbage-collection/>java垃圾回收</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0407lyjvm-intro/>jvm-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0406lyjvm-params/>jvm参数</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0408lyjdk-monitoring-and-troubleshooting-tools/>jvm监控和故障处理工具 总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0401lymemory-area/>memory-area</a></li><li><input type=checkbox id=section-26625a0c4c0bffef02640966ca545537 class=toggle>
<label for=section-26625a0c4c0bffef02640966ca545537 class="flex justify-between"><a role=button>并发</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated2/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0308lyaqs-details/>aqs详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly030301lyatomicpre/>Atomic预备知识</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0309lyatomic-classes/>Atomic原子类介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0311lycompletablefuture-intro/>completablefuture-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0307lyconcurrent-collections/>java常见并发容器</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0304lyjmm/>java内存模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0305lyjava-thread-pool/>java线程池详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0310lythreadlocal/>ThreadLocal详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0301lyconcurrent-01/>并发01</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0302lyconcurrent-02/>并发02</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0303lyconcurrent-03/>并发03</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03121lyobject-concurrent/>对象内存布局和对象头</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03122lylock_escalation/>锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0306lythread-pool-best/>线程池最佳实践</a></li></ul></li><li><input type=checkbox id=section-7027a9bc1d603892e7826da81b333f38 class=toggle>
<label for=section-7027a9bc1d603892e7826da81b333f38 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0008lybig_decimal/>big_decimal</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0010lyjava_spi/>java_spi</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0006lyreflex/>java-reflex</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0001lyjava_guide_basic_1/>javaGuide基础1</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0002lyjava_guide_basic_2/>javaGuide基础2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0003lyjava_guide_basic_3/>javaGuide基础3</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0007lyproxy_pattern/>Java代理模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0005lyserialize/>Java序列化详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0009lyunsafe_class/>unsafe类</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0004lypassbyvalue/>为什么Java中只有值传递</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0011lysyntactic_sugar/>语法糖</a></li></ul></li><li><input type=checkbox id=section-7d26c3d37b0e4678a1ec776265992903 class=toggle>
<label for=section-7d26c3d37b0e4678a1ec776265992903 class="flex justify-between"><a role=button>集合</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0104lysource-code-ArrayList/>ArrayList源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0105lysource-code-concurrenthashmap/>ConcurrentHashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0106lysource-code-hashmap/>HashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0101lycollection_1/>集合_1</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0102lycollection_2/>集合_2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0103lycollections-precautions-for-use/>集合使用注意事项</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0404lyclassloader-process/>类加载过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0405lyclassloader-detail/>类加载器详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0403lyclass-structure/>类文件结构</a></li></ul></li><li><input type=checkbox id=section-a6916634f1b5324076467df4cc9ac3b5 class=toggle>
<label for=section-a6916634f1b5324076467df4cc9ac3b5 class="flex justify-between"><a role=button>分布式系统</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly01ly_api-gateway/>api网关</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly04ly_rpc-http/>rpc_http</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly05ly_rpc-intro/>rpc基础及面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly06ly_zookeeper-intro/>zookeeper介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly07ly_zookeeper-plus/>zookeeper进阶</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly08ly_zookeeper-in-action/>zookeeper实战</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly02ly_distributed-id/>分布式id</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly03ly_distributed-lock/>分布式锁</a></li><li><input type=checkbox id=section-0c8e62b6137b614e01882e2a88ea5daf class=toggle>
<label for=section-0c8e62b6137b614e01882e2a88ea5daf class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/cap_base-theorem/>CAP&amp;BASE 理论</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/paxos-algorithm/>paxos算法</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/raft-algorithm/>raft算法</a></li></ul></li></ul></li><li><input type=checkbox id=section-0a9533f3005d615c696f74456e46d269 class=toggle>
<label for=section-0a9533f3005d615c696f74456e46d269 class="flex justify-between"><a role=button>高可用</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly04ly_timout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly03ly_limit-request/>服务限流详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly01ly_high-availability-system-design/>高可用系统设计指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly02ly_redundancy/>冗余设计</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly05ly_performance-test/>性能测试入门</a></li></ul></li><li><input type=checkbox id=section-e36f94f48e5027e7cbd39b7f7bbc249c class=toggle>
<label for=section-e36f94f48e5027e7cbd39b7f7bbc249c class="flex justify-between"><a role=button>高性能</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly02ly_cdn/>cdn</a></li><li><input type=checkbox id=section-581624dd7aa25a150f706312689ba446 class=toggle>
<label for=section-581624dd7aa25a150f706312689ba446 class="flex justify-between"><a role=button>RocketMQ</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/base/>message-queue</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-questions/>rocketmq常见面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-intro/>rocketmq介绍</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly01ly_read-and-write-separation-and-library-subtable/>数据库读写分离&分库分表详解</a></li></ul></li><li><input type=checkbox id=section-04d967d6579d47b35ececb3d233024f1 class=toggle>
<label for=section-04d967d6579d47b35ececb3d233024f1 class="flex justify-between"><a role=button>计算机基础</a></label><ul><li><input type=checkbox id=section-316b43351a75a19ac6dec86ad1a48c45 class=toggle>
<label for=section-316b43351a75a19ac6dec86ad1a48c45 class="flex justify-between"><a role=button>数据结构</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/heap/>堆</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li></ul></li><li><input type=checkbox id=section-1f6733a85e33dcc22aabbf820e3ef963 class=toggle>
<label for=section-1f6733a85e33dcc22aabbf820e3ef963 class="flex justify-between"><a role=button>开发工具</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/git/>git</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/maven/>maven</a></li></ul></li><li><input type=checkbox id=section-ce3cbb53c62f67624e4ab24a5a14298a class=toggle>
<label for=section-ce3cbb53c62f67624e4ab24a5a14298a class="flex justify-between"><a role=button>框架</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/conditional_on_class/>ConditionalOnClass实践</a></li><li><input type=checkbox id=section-dbe480810d1877286936b38cdb5e9229 class=toggle>
<label for=section-dbe480810d1877286936b38cdb5e9229 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/MyBatis-interview/>Mybatis面试</a></li><li><input type=checkbox id=section-30b916f2071579e2468767a2562433d9 class=toggle>
<label for=section-30b916f2071579e2468767a2562433d9 class="flex justify-between"><a role=button>原理</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle1/>Mybatis原理系列(1)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle2/>Mybatis原理系列(2)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle3/>Mybatis原理系列(3)</a></li></ul></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/>spring 常见面试题总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly04ly_spring-design-patterns/>spring 设计模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly02ly_spring-annotations/>Spring/SpringBoot常用注解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly05ly_springboot-auto-assembly/>SpringBoot自动装配原理</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly03ly_spring-transaction/>Spring事务详情</a></li></ul></li><li><input type=checkbox id=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class=toggle>
<label for=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class="flex justify-between"><a role=button>数据库</a></label><ul><li><input type=checkbox id=section-e7660273cef85dff1f39af04a42bd062 class=toggle>
<label for=section-e7660273cef85dff1f39af04a42bd062 class="flex justify-between"><a role=button>MySQL</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0604lyinnodb-implementation-of-mvcc/>innodb引擎对MVCC的实现</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0610lymysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0611lymysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0603lytransaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0608lysome-thoughts-on-database-storage-time/>MySQL数据库时间类型数据存储建议</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0606lymysql-query-execution-plan/>mysql执行计划</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0609lyindex-invalidation-caused-by-implicit-conversion/>MySQL中的隐式转换造成的索引失效</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0605lyhow-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0602lymysql-logs/>日志</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0601lymysql-index/>索引</a></li></ul></li><li><input type=checkbox id=section-680d077436e58b0cad0a63ed8edb5f53 class=toggle>
<label for=section-680d077436e58b0cad0a63ed8edb5f53 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0703ly3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0701lyredis-base-data-structures/>redis基本数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0705lyredis-questions-01/>redis面试题01</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0706lyredis-questions-02/>redis面试题02</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0704lyredis-memory-fragmentation/>redis内存碎片</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0702lyredis-spec-data-structure/>redis特殊数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/diagram/>redis问题图解</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0503lysql-question-01/>sql常见面试题总结01</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0504lysql-syntax-summary/>sql语法基础知识总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0501lybasis/>数据库基础</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0502lycharactor-set/>字符集详解</a></li></ul></li><li><input type=checkbox id=section-a1b717b4079938cc0efe574541b240b8 class=toggle>
<label for=section-a1b717b4079938cc0efe574541b240b8 class="flex justify-between"><a role=button>系统设计</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/schedule-task/>Java定时任务详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/web-real-time-message-push/>web-real-time-message-push</a></li><li><input type=checkbox id=section-9eaf95f03abf595bfdf838c4b4cdb2ef class=toggle>
<label for=section-9eaf95f03abf595bfdf838c4b4cdb2ef class="flex justify-between"><a role=button>安全</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly02ly_jwt-intro/>jwt-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly03ly_jwt-advantages-disadvantages/>jwt身份认证优缺点</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly04ly_sso-intro/>sso单点登录</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly06ly_sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly05ly_design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly01ly_basis-of-authority-certification/>认证授权基础概念详解</a></li></ul></li><li><input type=checkbox id=section-79417049c90714c6ddbf18a3c3958148 class=toggle>
<label for=section-79417049c90714c6ddbf18a3c3958148 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/restful/>restFul</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/unit-test/>单元测试</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/software-engineering/>软件工程简明教程</a></li></ul></li></ul></li></ul></li><li><input type=checkbox id=section-09d19e9c6f50e4706fe8b6d358c441ce class=toggle>
<label for=section-09d19e9c6f50e4706fe8b6d358c441ce class="flex justify-between"><a role=button>Ssm</a></label><ul><li><a href=/zh/docs/technology/Review/ssm/scope_transaction/>作用域及事务</a></li></ul></li><li><input type=checkbox id=section-11f3d4afcbd3591ad3ee5d79993e29d7 class=toggle>
<label for=section-11f3d4afcbd3591ad3ee5d79993e29d7 class="flex justify-between"><a role=button>Java基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Review/basics/member_variables_and_local_variables/>成员变量与局部变量</a></li><li><a href=/zh/docs/technology/Review/basics/singleton_design_pattern/>单例设计模式</a></li><li><a href=/zh/docs/technology/Review/basics/recursion_and_iteration/>递归与迭代</a></li><li><a href=/zh/docs/technology/Review/basics/method_parameter_passing_mechanism/>方法的参数传递机制</a></li><li><a href=/zh/docs/technology/Review/basics/class_and_instance_initialization/>类、实例初始化</a></li><li><a href=/zh/docs/technology/Review/basics/self_incrementing_variable/>自增变量</a></li></ul></li></ul></li><li><input type=checkbox id=section-e8f515fe7fc71d283363385aa363c2dd class=toggle>
<label for=section-e8f515fe7fc71d283363385aa363c2dd class="flex justify-between"><a role=button>其他</a></label><ul><li><a href=/zh/docs/technology/Other/pc_base/>电脑基础操作</a></li><li><a href=/zh/docs/technology/Other/kaoshi/>科目</a></li></ul></li><li><input type=checkbox id=section-5057ba12f456498454476dc11b58648b class=toggle>
<label for=section-5057ba12f456498454476dc11b58648b class="flex justify-between"><a role=button>Git</a></label><ul><li><input type=checkbox id=section-55d261358c84b4996ac8d7851d37ccf8 class=toggle>
<label for=section-55d261358c84b4996ac8d7851d37ccf8 class="flex justify-between"><a role=button>基础(尚硅谷视频)_</a></label><ul><li><a href=/zh/docs/technology/Git/git_sgg_/01-08/>01-08_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg_/09-18/>09-18_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg_/19-26/>19-26_git_尚硅谷</a></li></ul></li></ul></li><li><input type=checkbox id=section-d8f59257917ebff8da82fd22583ae10c class=toggle>
<label for=section-d8f59257917ebff8da82fd22583ae10c class="flex justify-between"><a role=button>Maven</a></label><ul><li><input type=checkbox id=section-3b2851b4ae70cae160ce8f24dba7236a class=toggle>
<label for=section-3b2851b4ae70cae160ce8f24dba7236a class="flex justify-between"><a role=button>基础(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/base_dljd_/01-16/>01-16 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd_/17-30/>17-30 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd_/31-43/>31-43 maven基础_动力节点</a></li></ul></li><li><input type=checkbox id=section-9b52bdf229c64237c3a478dc6a533410 class=toggle>
<label for=section-9b52bdf229c64237c3a478dc6a533410 class="flex justify-between"><a role=button>进阶(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/advance_dljd_/01-21/>01-21 maven多模块管理_动力节点</a></li></ul></li></ul></li><li><input type=checkbox id=section-d2ff9acb1ec90bec89f165361ced2010 class=toggle>
<label for=section-d2ff9acb1ec90bec89f165361ced2010 class="flex justify-between"><a role=button>算法</a></label><ul><li><input type=checkbox id=section-d1faa468beb89fe27a31308721f74c82 class=toggle>
<label for=section-d1faa468beb89fe27a31308721f74c82 class="flex justify-between"><a role=button>_算法(第四版)_</a></label><ul><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.1.1-1.1.5/>算法红皮书 1.1.1-1.1.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.1.6-1.1.11/>算法红皮书 1.1.6-1.1.11</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.2.1-1.2.5/>算法红皮书 1.2.1-1.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.3.1.1-1.3.2.5/>算法红皮书 1.3.1.1-1.3.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.4.1-1.4.10/>算法红皮书 1.4.1-1.4.10</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.5.1-1.5.3/>算法红皮书 1.5.1-1.5.3</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.1.1/>算法红皮书 2.1.1</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.1.2-2.1.3/>算法红皮书 2.1.2-2.1.3</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.4/>算法红皮书 2.4</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/2.5/>算法红皮书 2.5</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/3.1.1-3.1.7/>算法红皮书 3.1.1-3.1.7</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/3.2.1/>算法红皮书 3.2.1</a></li><li><a href=/zh/docs/technology/Algorithm/_algorithhms_4th_/1.3.3.1-1.3.4/>算法红皮书1.3.3.1-1.3.4</a></li></ul></li></ul></li><li><input type=checkbox id=section-b414f13e51dbc5e90231aa49f06e7237 class=toggle>
<label for=section-b414f13e51dbc5e90231aa49f06e7237 class="flex justify-between"><a role=button>My Batis Plus</a></label><ul><li><a href=/zh/docs/technology/MyBatis-Plus/official/hello/>官方的hello-world</a></li><li><input type=checkbox id=section-0e4fa61015701c3d99296175840aa5d3 class=toggle>
<label for=section-0e4fa61015701c3d99296175840aa5d3 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/01-11/>mybatis-plus-sgg-01-11</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/12-18/>mybatis-plus-sgg-12-18</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/19-39/>mybatis-plus-sgg-19-39</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg_/40-57/>mybatis-plus-sgg-40-57</a></li></ul></li></ul></li><li><input type=checkbox id=section-1e5a67821c47d147a096480c75e0d7c4 class=toggle>
<label for=section-1e5a67821c47d147a096480c75e0d7c4 class="flex justify-between"><a role=button>Flowable</a></label><ul><li><a href=/zh/docs/technology/Flowable/zsx_design/01/>zsx_flowable_design01</a></li><li><input type=checkbox id=section-6019d9043956834af14f96c2f7dcd5ca class=toggle>
<label for=section-6019d9043956834af14f96c2f7dcd5ca class="flex justify-between"><a role=button>官方文档</a></label><ul><li><a href=/zh/docs/technology/Flowable/offical/01/>Flowable-01-GettingStarted</a></li><li><a href=/zh/docs/technology/Flowable/offical/02/>Flowable-02-Configuration</a></li><li><a href=/zh/docs/technology/Flowable/offical/03/>Flowable-03-api</a></li><li><a href=/zh/docs/technology/Flowable/offical/04/>Flowable-04-spring</a></li><li><a href=/zh/docs/technology/Flowable/offical/05/>Flowable-05-spring-boot</a></li></ul></li><li><input type=checkbox id=section-0a06ca67446b7a26392adaea7b2dc30f class=toggle>
<label for=section-0a06ca67446b7a26392adaea7b2dc30f class="flex justify-between"><a role=button>基础(波哥)_</a></label><ul><li><a href=/zh/docs/technology/Flowable/boge_blbl_/01-base/>boge-01-flowable基础</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_1/>boge-02-flowable进阶_1</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_2/>boge-02-flowable进阶_2</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_3/>boge-02-flowable进阶_3</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_4/>boge-02-flowable进阶_4</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_5/>boge-02-flowable进阶_5</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/02-advance_6/>boge-02-flowable进阶_6</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl_/03-others/>boge-03-其他</a></li></ul></li></ul></li><li><input type=checkbox id=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class=toggle>
<label for=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class="flex justify-between"><a role=button>Rocket Mq</a></label><ul><li><input type=checkbox id=section-8c49e88e8756a0a7b3e45abde3117dd5 class=toggle>
<label for=section-8c49e88e8756a0a7b3e45abde3117dd5 class="flex justify-between"><a role=button>基础(黑马)_</a></label><ul><li><a href=/zh/docs/technology/RocketMQ/heima_/01base/>01rocketmq学习</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/02buildcluster/>02双主双从集群搭建</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/03messagetype/>03收发消息</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/04case/>04案例</a></li><li><a href=/zh/docs/technology/RocketMQ/heima_/05advance/>05高级功能</a></li></ul></li></ul></li><li><input type=checkbox id=section-dcbf6163d9f750f7cc3b9417d1386331 class=toggle>
<label for=section-dcbf6163d9f750f7cc3b9417d1386331 class="flex justify-between"><a href=/zh/docs/technology/Interview/>Interview</a></label><ul><li><input type=checkbox id=section-c8fd55079fae864a8c659fb14cbb379e class=toggle>
<label for=section-c8fd55079fae864a8c659fb14cbb379e class="flex justify-between"><a role=button>Cs Basics</a></label><ul><li><input type=checkbox id=section-ac5cd91bf1acc2a16a9dbdfa9c17f629 class=toggle>
<label for=section-ac5cd91bf1acc2a16a9dbdfa9c17f629 class="flex justify-between"><a role=button>Algorithms</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/common-data-structures-leetcode-recommendations/>常见数据结构经典LeetCode题目推荐</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/linkedlist-algorithm-problems/>几道常见的链表算法题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/string-algorithm-problems/>几道常见的字符串算法题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/the-sword-refers-to-offer/>剑指offer部分编程题</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/classical-algorithm-problems-recommendations/>经典算法思想总结（含LeetCode题目推荐）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/algorithms/10-classical-sorting-algorithms/>十大经典排序算法总结</a></li></ul></li><li><input type=checkbox id=section-f435ca39dd71dd7765b81dd8ec05c344 class=toggle>
<label for=section-f435ca39dd71dd7765b81dd8ec05c344 class="flex justify-between"><a role=button>Data Structure</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/heap/>Index</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/bloom-filter/>布隆过滤器</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/red-black-tree/>红黑树</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li><li><input type=checkbox id=section-fa182df3abee2343aa6c977c2a75dda2 class=toggle>
<label for=section-fa182df3abee2343aa6c977c2a75dda2 class="flex justify-between"><a role=button>Network</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/network/computer-network-xiexiren-summary/>《计算机网络》（谢希仁）内容总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/arp/>ARP 协议详解(网络层)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/dns/>DNS 域名系统详解（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http1.0-vs-http1.1/>HTTP 1.0 vs HTTP 1.1（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http-vs-https/>HTTP vs HTTPS（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/http-status-codes/>HTTP 常见状态码总结（应用层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/nat/>NAT 协议详解（网络层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/osi-and-tcp-ip-model/>OSI 和 TCP/IP 网络分层模型详解（基础）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/tcp-reliability-guarantee/>TCP 传输可靠性保障（传输层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/tcp-connection-and-disconnection/>TCP 三次握手和四次挥手（传输层）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/the-whole-process-of-accessing-web-pages/>访问网页的全过程（知识串联）</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/other-network-questions/>计算机网络常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/other-network-questions2/>计算机网络常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/network-attack-means/>网络攻击常见手段总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/network/application-layer-protocol/>应用层常见协议总结（应用层）</a></li></ul></li><li><input type=checkbox id=section-76856ab8063b8754553c166410441284 class=toggle>
<label for=section-76856ab8063b8754553c166410441284 class="flex justify-between"><a role=button>Operating System</a></label><ul><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/linux-intro/>Linux 基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/shell-intro/>Shell 编程基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-01/>操作系统常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-02/>操作系统常见面试题总结(下)</a></li></ul></li></ul></li><li><input type=checkbox id=section-fa219a2fa1e454bccf1abf45b7e68c8e class=toggle>
<label for=section-fa219a2fa1e454bccf1abf45b7e68c8e class="flex justify-between"><a role=button>Database</a></label><ul><li><input type=checkbox id=section-1e90eaf849a2719b2603214b93639e7c class=toggle>
<label for=section-1e90eaf849a2719b2603214b93639e7c class="flex justify-between"><a role=button>Elasticsearch</a></label><ul><li><a href=/zh/docs/technology/Interview/database/elasticsearch/elasticsearch-questions-01/>Elasticsearch常见面试题总结(付费)</a></li></ul></li><li><input type=checkbox id=section-36fcdf6608f26e92ce7bb1e95612ca73 class=toggle>
<label for=section-36fcdf6608f26e92ce7bb1e95612ca73 class="flex justify-between"><a role=button>Mongodb</a></label><ul><li><a href=/zh/docs/technology/Interview/database/mongodb/mongodb-questions-01/>MongoDB常见面试题总结（上）</a></li><li><a href=/zh/docs/technology/Interview/database/mongodb/mongodb-questions-02/>MongoDB常见面试题总结（下）</a></li></ul></li><li><input type=checkbox id=section-1681ed9defad2064b37ff3e603cd509c class=toggle>
<label for=section-1681ed9defad2064b37ff3e603cd509c class="flex justify-between"><a role=button>Mysql</a></label><ul><li><a href=/zh/docs/technology/Interview/database/mysql/innodb-implementation-of-mvcc/>InnoDB存储引擎对MVCC的实现</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-query-cache/>MySQL查询缓存详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/some-thoughts-on-database-storage-time/>MySQL日期类型选择建议</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-logs/>MySQL三大日志(binlog、redo log和undo log)详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/transaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-index/>MySQL索引详解</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/index-invalidation-caused-by-implicit-conversion/>MySQL隐式转换造成索引失效</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-query-execution-plan/>MySQL执行计划分析</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/mysql-auto-increment-primary-key-continuous/>MySQL自增主键一定是连续的吗</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/how-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/technology/Interview/database/mysql/a-thousand-lines-of-mysql-study-notes/>一千行 MySQL 学习笔记</a></li></ul></li><li><input type=checkbox id=section-7b494a9accb20a42d3eb50307ebf95b8 class=toggle>
<label for=section-7b494a9accb20a42d3eb50307ebf95b8 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Interview/database/redis/3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-data-structures-02/>Redis 3 种特殊数据类型详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-data-structures-01/>Redis 5 种基本数据类型详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-questions-01/>Redis常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-questions-02/>Redis常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-common-blocking-problems-summary/>Redis常见阻塞原因总结</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-persistence/>Redis持久化机制详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-cluster/>Redis集群详解(付费)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-memory-fragmentation/>Redis内存碎片详解</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-skiplist/>Redis为什么用跳表实现有序集合</a></li><li><a href=/zh/docs/technology/Interview/database/redis/cache-basics/>缓存基础常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/database/redis/redis-delayed-task/>如何基于Redis实现延时任务</a></li></ul></li><li><input type=checkbox id=section-0b495945d7d1c7bace636f2809188369 class=toggle>
<label for=section-0b495945d7d1c7bace636f2809188369 class="flex justify-between"><a role=button>SQL</a></label><ul><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-01/>SQL常见面试题总结（1）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-02/>SQL常见面试题总结（2）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-03/>SQL常见面试题总结（3）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-04/>SQL常见面试题总结（4）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-questions-05/>SQL常见面试题总结（5）</a></li><li><a href=/zh/docs/technology/Interview/database/sql/sql-syntax-summary/>SQL语法基础知识总结</a></li></ul></li><li><a href=/zh/docs/technology/Interview/database/nosql/>NoSQL基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/database/basis/>数据库基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/database/character-set/>字符集详解</a></li></ul></li><li><input type=checkbox id=section-9bc7f274474a2d4825bfb7e0f835ec9f class=toggle>
<label for=section-9bc7f274474a2d4825bfb7e0f835ec9f class="flex justify-between"><a role=button>Distributed System</a></label><ul><li><input type=checkbox id=section-4aa0a804a8f6d6d2745a8f9d92dbae63 class=toggle>
<label for=section-4aa0a804a8f6d6d2745a8f9d92dbae63 class="flex justify-between"><a role=button>Distributed Process Coordination</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-in-action/>ZooKeeper 实战</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus/>ZooKeeper相关概念总结(进阶)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro/>ZooKeeper相关概念总结(入门)</a></li></ul></li><li><input type=checkbox id=section-917636e43923e143cb27e958ae247d83 class=toggle>
<label for=section-917636e43923e143cb27e958ae247d83 class="flex justify-between"><a role=button>Protocol</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/cap-and-base-theorem/>CAP & BASE理论详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/gossip-protocl/>Gossip 协议详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/paxos-algorithm/>Paxos 算法详解</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/protocol/raft-algorithm/>Raft 算法详解</a></li></ul></li><li><input type=checkbox id=section-5f212fdd6451198aab8e6d9d1c28c4d2 class=toggle>
<label for=section-5f212fdd6451198aab8e6d9d1c28c4d2 class="flex justify-between"><a role=button>Rpc</a></label><ul><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/dubbo/>Dubbo常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/rpc-intro/>RPC基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/rpc/httprpc/>有了 HTTP 协议，为什么还要有 RPC ？</a></li></ul></li><li><a href=/zh/docs/technology/Interview/distributed-system/api-gateway/>API网关基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/spring-cloud-gateway-questions/>Spring Cloud Gateway常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-id/>分布式ID介绍&实现方案总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-id-design/>分布式ID设计指南</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-configuration-center/>分布式配置中心常见问题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-transaction/>分布式事务常见解决方案总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-lock-implementations/>分布式锁常见实现方案总结</a></li><li><a href=/zh/docs/technology/Interview/distributed-system/distributed-lock/>分布式锁介绍</a></li></ul></li><li><input type=checkbox id=section-20eb042d5085894960b2b40cdde1bd95 class=toggle>
<label for=section-20eb042d5085894960b2b40cdde1bd95 class="flex justify-between"><a role=button>High Availability</a></label><ul><li><a href=/zh/docs/technology/Interview/high-availability/timeout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/limit-request/>服务限流详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/high-availability-system-design/>高可用系统设计指南</a></li><li><a href=/zh/docs/technology/Interview/high-availability/fallback-and-circuit-breaker/>降级&熔断详解(付费)</a></li><li><a href=/zh/docs/technology/Interview/high-availability/redundancy/>冗余设计详解</a></li><li><a href=/zh/docs/technology/Interview/high-availability/performance-test/>性能测试入门</a></li></ul></li><li><input type=checkbox id=section-d863e9c02108d739d2116dee6c3f0df2 class=toggle>
<label for=section-d863e9c02108d739d2116dee6c3f0df2 class="flex justify-between"><a role=button>High Performance</a></label><ul><li><a href=/zh/docs/technology/Interview/high-performance/cdn/>CDN工作原理详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/disruptor-questions/>Disruptor常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/kafka-questions-01/>Kafka常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/rabbitmq-questions/>RabbitMQ常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/rocketmq-questions/>RocketMQ常见问题总结</a></li><li><a href=/zh/docs/technology/Interview/high-performance/sql-optimization/>常见SQL优化手段总结（付费）</a></li><li><a href=/zh/docs/technology/Interview/high-performance/read-and-write-separation-and-library-subtable/>读写分离和分库分表详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/load-balancing/>负载均衡原理及算法详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/deep-pagination-optimization/>深度分页介绍及优化建议</a></li><li><a href=/zh/docs/technology/Interview/high-performance/data-cold-hot-separation/>数据冷热分离详解</a></li><li><a href=/zh/docs/technology/Interview/high-performance/message-queue/message-queue/>消息队列基础知识总结</a></li></ul></li><li><input type=checkbox id=section-2874dffbab1645c0b90b66f58878baeb class=toggle>
<label for=section-2874dffbab1645c0b90b66f58878baeb class="flex justify-between"><a role=button>High Quality Technical Articles</a></label><ul><li><input type=checkbox id=section-043c9e2ae521f883513d71615d921b93 class=toggle>
<label for=section-043c9e2ae521f883513d71615d921b93 class="flex justify-between"><a role=button>Advanced Programmer</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant/>程序员的技术成长战略</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/programmer-quickly-learn-new-technology/>程序员如何快速学习新技术</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/seven-tips-for-becoming-an-advanced-programmer/>给想成长为高级别开发同学的七条建议</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work/>工作五年之后，对技术和业务的思考</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/meituan-three-year-summary-lesson-10/>美团三年，总结的10条血泪教训</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road/>十年大厂成长之路</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/20-bad-habits-of-bad-programmers/>糟糕程序员的 20 个坏习惯</a></li></ul></li><li><input type=checkbox id=section-5a7311ea7fe807f97a6fa93dffde10b6 class=toggle>
<label for=section-5a7311ea7fe807f97a6fa93dffde10b6 class="flex justify-between"><a role=button>Interview</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/some-secrets-about-alibaba-interview/>阿里技术面试的一些秘密</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/technical-preliminary-preparation/>从面试官和候选者的角度谈如何准备技术初试</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/summary-of-spring-recruitment/>普通人的春招总结（阿里、腾讯offer）</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology/>如何在技术初试中考察程序员的技术能力</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/screen-candidates-for-packaging/>如何甄别应聘者的包装程度</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/my-personal-experience-in-2021/>校招进入飞书的个人经验</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer/>一位大龄程序员所经历的面试的历炼和思考</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-of-get-offer-from-over-20-big-companies/>斩获 20+ 大厂 offer 的面试经验分享</a></li></ul></li><li><input type=checkbox id=section-bf0bb8140b840e0af3c2632b6b73e609 class=toggle>
<label for=section-bf0bb8140b840e0af3c2632b6b73e609 class="flex justify-between"><a role=button>Personal Experience</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/four-year-work-in-tencent-summary/>从校招入职腾讯的四年工作总结</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao/>滴滴和头条两年后端工作经验分享</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/huawei-od-275-days/>华为 OD 275 天后，我进了腾讯！</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/8-years-programmer-work-summary/>一个中科大差生的 8 年程序员工作总结</a></li></ul></li><li><input type=checkbox id=section-8166233fd6553926230055376f2b97f6 class=toggle>
<label for=section-8166233fd6553926230055376f2b97f6 class="flex justify-between"><a role=button>Programmer</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/efficient-book-publishing-and-practice-guide/>程序员高效出书避坑和实践指南</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/how-do-programmers-publish-a-technical-book/>程序员怎样出版一本技术书</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/programmer/high-value-certifications-for-programmers/>程序员最该拿的几种高含金量证书</a></li></ul></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/readme/>Index</a></li><li><input type=checkbox id=section-b607a393d7717c448e31e58c8972bbba class=toggle>
<label for=section-b607a393d7717c448e31e58c8972bbba class="flex justify-between"><a role=button>Work</a></label><ul><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/32-tips-improving-career/>32条总结教你提升职场经验</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/employee-performance/>聊聊大厂的绩效考核</a></li><li><a href=/zh/docs/technology/Interview/high-quality-technical-articles/work/get-into-work-mode-quickly-when-you-join-a-company/>新入职一家公司如何快速进入工作状态</a></li></ul></li></ul></li><li><input type=checkbox id=section-5680a0cf00b09d8470dc67fa0a170b89 class=toggle>
<label for=section-5680a0cf00b09d8470dc67fa0a170b89 class="flex justify-between"><a role=button>Java</a></label><ul><li><input type=checkbox id=section-6e2eabf08cfe622d9921e3edfa11e55a class=toggle>
<label for=section-6e2eabf08cfe622d9921e3edfa11e55a class="flex justify-between"><a role=button>Basis</a></label><ul><li><a href=/zh/docs/technology/Interview/java/basis/java-keyword-summary/>Index</a></li><li><a href=/zh/docs/technology/Interview/java/basis/bigdecimal/>BigDecimal 详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/spi/>Java SPI 机制详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/proxy/>Java 代理模式详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/reflection/>Java 反射机制详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/unsafe/>Java 魔法类 Unsafe 详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/serialization/>Java 序列化详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/syntactic-sugar/>Java 语法糖详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/why-there-only-value-passing-in-java/>Java 值传递详解</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-01/>Java基础常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-03/>Java基础常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/java-basic-questions-02/>Java基础常见面试题总结(中)</a></li><li><a href=/zh/docs/technology/Interview/java/basis/generics-and-wildcards/>泛型&通配符详解</a></li></ul></li><li><input type=checkbox id=section-b9f81b31813c0f4b2cd6e884ad0c0511 class=toggle>
<label for=section-b9f81b31813c0f4b2cd6e884ad0c0511 class="flex justify-between"><a role=button>Collection</a></label><ul><li><a href=/zh/docs/technology/Interview/java/collection/arrayblockingqueue-source-code/>ArrayBlockingQueue 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/arraylist-source-code/>ArrayList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/concurrent-hash-map-source-code/>ConcurrentHashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/copyonwritearraylist-source-code/>CopyOnWriteArrayList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/delayqueue-source-code/>DelayQueue 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/hashmap-source-code/>HashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-questions-01/>Java集合常见面试题总结(上)</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-questions-02/>Java集合常见面试题总结(下)</a></li><li><a href=/zh/docs/technology/Interview/java/collection/java-collection-precautions-for-use/>Java集合使用注意事项总结</a></li><li><a href=/zh/docs/technology/Interview/java/collection/linkedhashmap-source-code/>LinkedHashMap 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/linkedlist-source-code/>LinkedList 源码分析</a></li><li><a href=/zh/docs/technology/Interview/java/collection/priorityqueue-source-code/>PriorityQueue 源码分析（付费）</a></li></ul></li><li><input type=checkbox id=section-8cc9034354bdd549787a43bea3c7c40c class=toggle>
<label for=section-8cc9034354bdd549787a43bea3c7c40c class="flex justify-between"><a role=button>Concurrent</a></label><ul><li><a href=/zh/docs/technology/Interview/java/concurrent/aqs/>AQS 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/atomic-classes/>Atomic 原子类总结</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/cas/>CAS 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/completablefuture-intro/>CompletableFuture 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-collections/>Java 常见并发容器总结</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-thread-pool-summary/>Java 线程池详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-thread-pool-best-practices/>Java 线程池最佳实践</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-01/>Java并发常见面试题总结（上）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-03/>Java并发常见面试题总结（下）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-02/>Java并发常见面试题总结（中）</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/jmm/>JMM（Java 内存模型）详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/threadlocal/>ThreadLocal 详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/reentrantlock/>从ReentrantLock的实现看AQS的原理及应用</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/optimistic-lock-and-pessimistic-lock/>乐观锁和悲观锁详解</a></li><li><a href=/zh/docs/technology/Interview/java/concurrent/virtual-thread/>虚拟线程常见问题总结</a></li></ul></li><li><input type=checkbox id=section-498d2cde022f952a6751a7ebd2a53aeb class=toggle>
<label for=section-498d2cde022f952a6751a7ebd2a53aeb class="flex justify-between"><a role=button>Io</a></label><ul><li><a href=/zh/docs/technology/Interview/java/io/io-basis/>Java IO 基础知识总结</a></li><li><a href=/zh/docs/technology/Interview/java/io/io-model/>Java IO 模型详解</a></li><li><a href=/zh/docs/technology/Interview/java/io/io-design-patterns/>Java IO 设计模式总结</a></li><li><a href=/zh/docs/technology/Interview/java/io/nio-basis/>Java NIO 核心知识总结</a></li></ul></li><li><input type=checkbox id=section-9ee5b42dd6a7edc6e1c0a1c88bde9426 class=toggle>
<label for=section-9ee5b42dd6a7edc6e1c0a1c88bde9426 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/technology/Interview/java/jvm/memory-area/>Java内存区域详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jdk-monitoring-and-troubleshooting-tools/>JDK监控和故障处理工具总结</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-garbage-collection/>JVM垃圾回收详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-in-action/>JVM线上问题排查和性能调优案例</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-intro/>大白话带你认识 JVM</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/class-loading-process/>类加载过程详解</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/classloader/>类加载器详解（重点）</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/class-file-structure/>类文件结构详解</a></li><li><a href=/zh/docs/technology/Interview/java/jvm/jvm-parameters-intro/>最重要的JVM参数总结</a></li></ul></li><li><input type=checkbox id=section-aad47cdb4b5f179b406c6cf1c6282621 class=toggle>
<label for=section-aad47cdb4b5f179b406c6cf1c6282621 class="flex justify-between"><a role=button>New Features</a></label><ul><li><a href=/zh/docs/technology/Interview/java/new-features/java8-tutorial-translate/>Index</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java10/>Java 10 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java11/>Java 11 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java12-13/>Java 12 & 13 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java14-15/>Java 14 & 15 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java16/>Java 16 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java17/>Java 17 新特性概览（重要）</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java18/>Java 18 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java19/>Java 19 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java20/>Java 20 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java21/>Java 21 新特性概览(重要)</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java22-23/>Java 22 & 23 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java9/>Java 9 新特性概览</a></li><li><a href=/zh/docs/technology/Interview/java/new-features/java8-common-new-features/>Java8 新特性实战</a></li></ul></li></ul></li><li><input type=checkbox id=section-f77457e1ea013328645923186d400509 class=toggle>
<label for=section-f77457e1ea013328645923186d400509 class="flex justify-between"><a role=button>System Design</a></label><ul><li><input type=checkbox id=section-a9a8bf9713340a4888a6db9d8f8eda42 class=toggle>
<label for=section-a9a8bf9713340a4888a6db9d8f8eda42 class="flex justify-between"><a role=button>Basis</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/basis/RESTfulAPI/>RestFul API 简明教程</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/unit-test/>单元测试到底是什么？应该怎么做？</a></li><li><a href=/zh/docs/technology/Interview/system-design/basis/software-engineering/>软件工程简明教程</a></li></ul></li><li><input type=checkbox id=section-3bbccee656befcd0673c7a7ef7393710 class=toggle>
<label for=section-3bbccee656befcd0673c7a7ef7393710 class="flex justify-between"><a role=button>Framework</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/async1/>Async 注解原理分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/Async/>Async 注解原理分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/ioc-and-aop/>IoC & AOP详解（快速搞懂）</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/mybatis/mybatis-interview/>MyBatis常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/netty/>Netty常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/springboot-source-code/>Spring Boot核心源码解读（付费）</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-transaction/>Spring 事务详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-design-patterns-summary/>Spring 中的设计模式详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-common-annotations/>Spring&amp;SpringBoot常用注解总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-boot-auto-assembly-principles/>SpringBoot 自动装配原理详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/springboot-knowledge-and-questions-summary/>SpringBoot常见面试题总结(付费)</a></li><li><a href=/zh/docs/technology/Interview/system-design/framework/spring/spring-knowledge-and-questions-summary/>Spring常见面试题总结</a></li></ul></li><li><a href=/zh/docs/technology/Interview/system-design/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/>Index</a></li><li><input type=checkbox id=section-2baa7507d4a9ede0d38490ad77045e56 class=toggle>
<label for=section-2baa7507d4a9ede0d38490ad77045e56 class="flex justify-between"><a role=button>Security</a></label><ul><li><a href=/zh/docs/technology/Interview/system-design/security/jwt-intro/>JWT 基础概念详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/advantages-and-disadvantages-of-jwt/>JWT 身份认证优缺点分析</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/sso-intro/>SSO 单点登录详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/encryption-algorithms/>常见加密算法总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/basis-of-authority-certification/>认证授权基础概念详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/security/data-desensitization/>数据脱敏方案总结</a></li></ul></li><li><a href=/zh/docs/technology/Interview/system-design/schedule-task/>Java 定时任务详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/web-real-time-message-push/>Web 实时消息推送详解</a></li><li><a href=/zh/docs/technology/Interview/system-design/design-pattern/>设计模式常见面试题总结</a></li><li><a href=/zh/docs/technology/Interview/system-design/system-design-questions/>系统设计常见面试题总结(付费)</a></li></ul></li><li><input type=checkbox id=section-b12b3763d379141770d4fa07f12c73ec class=toggle>
<label for=section-b12b3763d379141770d4fa07f12c73ec class="flex justify-between"><a role=button>Tools</a></label><ul><li><input type=checkbox id=section-b6832c2bda30f11dca94b5d9440b112e class=toggle>
<label for=section-b6832c2bda30f11dca94b5d9440b112e class="flex justify-between"><a role=button>Docker</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/docker/docker-intro/>Docker核心概念总结</a></li><li><a href=/zh/docs/technology/Interview/tools/docker/docker-in-action/>Docker实战</a></li></ul></li><li><input type=checkbox id=section-e383b654b47946dea2499bcb3c4bac31 class=toggle>
<label for=section-e383b654b47946dea2499bcb3c4bac31 class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/git/github-tips/>Github实用小技巧总结</a></li><li><a href=/zh/docs/technology/Interview/tools/git/git-intro/>Git核心概念总结</a></li></ul></li><li><input type=checkbox id=section-05546e7a7af454a542b00fa4a34f43a5 class=toggle>
<label for=section-05546e7a7af454a542b00fa4a34f43a5 class="flex justify-between"><a role=button>Gradle</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/gradle/gradle-core-concepts/>Gradle核心概念总结</a></li></ul></li><li><input type=checkbox id=section-139d2af6b95c327fa03497bf63e3a4f4 class=toggle>
<label for=section-139d2af6b95c327fa03497bf63e3a4f4 class="flex justify-between"><a role=button>Maven</a></label><ul><li><a href=/zh/docs/technology/Interview/tools/maven/maven-core-concepts/>Maven核心概念总结</a></li><li><a href=/zh/docs/technology/Interview/tools/maven/maven-best-practices/>Maven最佳实践</a></li></ul></li></ul></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/test/>测试</a><ul><li><a href=/zh/docs/test/hello2/>pdfTest</a></li><li><a href=/zh/docs/test/mytest/>test</a></li><li><a href=/zh/docs/test/test2/>test2</a></li></ul></li></ul><ul><li><a href=/zh/posts/>博客</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>Index</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><ul><li></li><li><a href=#尸>尸</a></li></ul></li><li><a href=#三三三三>三三三三</a><ul><li></li></ul></li></ul></li><li><a href=#勹>勹</a><ul><li><ul><li></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><p>第 3 章</p><p>—- CH APTER 3</p><h5 id=程序的机器级表示>程序的机器级表示
<a class=anchor href=#%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%9c%ba%e5%99%a8%e7%ba%a7%e8%a1%a8%e7%a4%ba>#</a></h5><p>计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写 存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集 和操作系 统遵循的 惯例， 经过一系列的 阶段生成 机器代码 。GCC C 语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后</p><p>GCC调用汇编 器和 链接器， 根据汇编代码生成可执行的机器代码。在本章中， 我们会近距离地观察机器代码，以及人类可读的表示 汇编代码。</p><p>当我们用高级语言 编程的时候（例如C 语言， Java 语言更是如此）， 机器屏蔽了 程序的 细节，即机器级的实现。与此相反，当用汇编代码编程的时候（就像早期的计算），程序员必须 指定程序用来执行计算的低级指令。高级语言提供的抽象级别比较高，大多数时候，在这种 抽象级别上工作效率会更高，也更可靠。编译器提供的类型检查能帮助我们发现许多程序错 误，并能够保证按照一致的方式来引用和处理数据。通常情况下，使用现代的优化编译器产 生的代码至少与一个熟练的汇编语言程序员手工编写的代码一样有效。最大的优点是，用高级 语言编写的程序可以在很多不同的机器上编译和执行，而汇编代码则是与特定机器密切相关的。 那么为什么我们还要花时间学习机器代码呢？即使编译器承担了生成汇编代码的大部</p><p>分工作，对千严谨的程序员来说，能够阅读和理解汇编代码仍是一项很重要的技能。以适 当的命令行选项调用编译器，编译器就会产生一个以汇编代码形式表示的输出文件。通过 阅读这些汇编代码，我们能够理解编译器的优化能力，并分析代码中隐含的低效率。就像 我们将在 第 5 章中体会到的那样， 试图最大化一 段关键代码性能的程序员 ， 通常会尝试源代码的各种形式，每次编译并检查产生的汇编代码，从而了解程序将要运行的效率如何。 此外，也有些时候，高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为。例 如，第 12 章会讲到，用线程包写并 发程序时 ，了 解不同的线程是如何共享程序数 据或保持数据私有的，以及准确知道如何在哪里访问共享数据，都是很重要的。这些信息在机器代码 级是可见的。另外再举一个例子，程序遭受攻击（使得恶意软件侵扰系统）的许多方式中，都涉及程序存储运行时控制信息的方式的细节。许多攻击利用了系统程序中的漏洞重写信息， 从而获得了系统的控制权。了解这些漏洞是如何出现的，以及如何防御它们，需要具备程序 机器级表示的知识。程序员学习汇编代码的需求随着时间的推移也发生了变化，开始时要求 程序员能直接用汇编语言编写程序，现在则要求他们能够阅读和理解编译器产生的代码。</p><p>在本章 中， 我们 将详细学习一 种特别的 汇编语 言，了 解如何将 C 程序编译成这种形式的机器代码。阅读编译器产生的汇编代码，需要具备的技能不同千手工编写汇编代码。我 们必须 了解典型的编译器在将 C 程序结 构变换成 机器代码时所做的转换 。相对于 C 代码表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换 慢速操作，甚至将递归计算变换成迭代计算。源代码与对应的汇编代码的关系通常不太容易 理解一一－就像要拼出的 拼图与盒子上图 片的设 计有点不太一样。这是一种逆向 工程 ( reverse engineering ) — 通过研究 系统 和逆向工作， 来试图了解系统 的创建过程。 在这里， 系统是一个机器产生的汇编语言程序，而不是由人设计的某个东西。这简化了逆向工程的任</p><p>务，因为产生的代码遵循比较规则的模式，而且我们可以做试验，让编译器产生许多不同程序的代码。本章提供了许多示例和大量的练习，来说明汇编语言和编译器的各个不同方面。精通细节是理解更深和更基本概念的先决条件。有人说：“我理解了一般规则，不愿意劳神去学习细节！”他们实际上是在自欺欺人。花时间研究这些示例、完成练习并对照提供的答案来检查你的答案，是非常关键的。</p><p>我们的表述基千 x86-64, 它是现在笔记本电脑和台式机中最常见处理器的机器语言，也是驱动大型数据中心和超级计算机的最常见处理器的机器语言。这种语言的历史悠久，开始于 Intel 公司 1978 年的第一个 16 位处理器 ， 然后扩展为 32 位， 最近又扩展到 64 位。一路以来，逐渐增加了很多特性，以更好地利用巳有的半导体技术，以及满足市场需求。这些进步中很多是 Intel 自己驱动的 ， 但它的对手 AMD( Advanced Micro Devices)也作出了重要的贡献。演化的结果是得到一个相当奇特的设计，有些特性只有从历史的观点来看才有意义，它还具有 提供后向兼容性的特性，而现代编译器和操作系统早已不再使用这些特性。我们将关注</p><p>GCC 和 Linux 使用的那些特性， 这样可以 避免 x86-64 的大量复杂性 和许多隐秘特性。</p><p>我们 在技术讲解之 前，先 快速浏览 C 语言、汇编代码以及机器代码之间 的关系。然后介绍 x86-64 的细节 ， 从数据的表示 和处理以及控制的实现开始。了解如何 实现 C 语言中的控制结构， 如 if 、wh i l e 和 s wi t c h 语句。之后 ， 我们会 讲到过程的实 现， 包括程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变最的存储。接着，我们会考虑在机器级如何实现像数组、结构和联合这样的数据结构。有了这些机器级编程的背景知识，我们会讨论内存访问越界的问题，以及系统容易遭受缓冲区溢出攻击的问题。在这一部分的结尾， 我们会 给出一 些用 GDB 调试器检查机器级程序运行时行为的 技巧。本章的最后展示了包含浮点数据和操作的代码的机器程序表示。</p><p>- IA32 编程</p><p>IA32, x86- 64 的 32 位前身，是 Intel 在 1985 年提出的 。几十年 来一 直是 Intel 的机 器语言之选。今天出售的 大多数 x86微处理器，以及这些机 器上安装的 大多数操作 系统， 都是为运行 x86-64设计的。不过 ， 它们也可以向后 兼容执行 IA32 程序。所以，很 多应用 程序还是基于 IA32 的。除此之外， 由于硬件或 系统软件的限制， 许多已有的 系统不能够执行 x86-64。</p><p>IA32 仍然是一种重要的机 器语言。学习过 x86-64会使你很容易地学会 IA32 机器语言。</p><p>计算机工业已经完成从 32 位到 64 位机器的过渡 。32 位机器只能使用大概 4GB( 沪 字节）的随机访问存储器。存储器价格急剧下降，而我们对计算的需求和数据的大小持续增 加， 超越这个 限制既经 济上可行又有技术上的需要。当前的 64 位机器能够使用多达256T B( 248 字节）的内存空间 ， 而且很容易 就能扩展至 16EB ( 26 4 字节）。虽然很难想象一台机器需要这么大的内存， 但是回想 20 世纪 70 和 80 年代， 当 32 位机器开始普及的时候，</p><p>4GB 的内存看上去也是超级大的 。</p><p>我们的 表述集 中于以现代操作 系统为目标， 编译 C 或类似编 程语言时， 生成的 机器级程序类型 。x86-64 有一些 特性是 为了 支持遗留下来的 微处理器早期 编程风格 ， 在此，我 们不试图去描述这些特性 ， 那时候大部分代码都是手工编写的， 而程序员 还在努力与 16 位机器允许的有限地址空间奋战。</p><ol start=2><li><p>1 历史观点</p><p>Intel 处理器系列俗称 x86, 经历了一个长期的、不断进化的发展过程。开始时，它是第</p></li></ol><p>一代单芯片 、16 位微处理器之一， 由千当时 集成电 路技术水 平十分 有限， 其中做了很多妥协。以后，它不断地成长，利用进步的技术满足更高性能和支持更高级操作系统的需求。</p><p>以下列举 了一些 In tel 处理器的模型， 以及它们的一些关键特性， 特别是影响机器级编程的特性。我们用实现这些处理器所需要的品体管数量来说明演变过程的复杂性。其 中， " K" 表示 1000 , " M" 表示 1 000 000, 而 " G" 表示 1 000 000 000 。</p><p>8086(1978 年， 29K 个晶体管）。它是第一代单芯片、16 位微处理器之一。 8088 是 8086</p><p>的一个变 种， 在 8086 上增 加了一个 8 位外部总线， 构成最初的 IBM 个人计算机的心脏。</p><p>IBM 与当时还不强大的微软签订合同 ， 开发 MS-DOS 操作系统。最初的机器型号有32 768 字节的内存和两个软驱（没有硬盘驱动器）。从体系结构上来说 ， 这些机器只有 655 360 字节的地址空间 地址只有 20 位长（可寻址范围为 1 048 576 字节）， 而操作系统保 留了 393 216 字节自用。 1980 年， Int el 提出了 8087 浮点 协处理器( 45K 个晶体管）， 它与一个 8086 或 8088处理器一同运行 ， 执行浮点指令 。8087 建立了 x86 系列的浮点模型 ， 通常被称为 " x87"。</p><p>80286(1 982 年， 13 4K 个晶体管）。增加了更多的寻址模式（现在巳 经废弃了）， 构成了 IBM PC- AT 个人计算机的基础， 这种计算 机是 MS Windows 最初的使用平台。</p><p>i386(1 985 年， 275K 个晶体管）。将体系结构扩展到 32 位。增 加了平坦寻址模式 ( flat addressing model) , Linux 和最近版本的 Windows 操作系统都是使用的这种模式。这是</p><p>Intel 系列中第一台全 面支持 U nix 操作系统的机器。</p><p>i486 (1 989 年， 1. 2M 个晶体管）。改善了性能， 同时将浮点 单元集成到了处 理器芯片上，但是指令集没有明显的改变。</p><p>Pentium (1 993 年， 3. l M 个晶体管）。改善了性能， 不过只对指令集 进行了小 的扩展。</p><p>PentiumP ro(1 995 年， 5. 5M 个晶体管）。引入全新的处理器设计， 在内部被称为 P 6</p><p>微体系 结构。指令集 中增加了一类 ”条件传送 ( cond iti onal move) " 指令。</p><p>Pentium/ MMX C1997 年， 4. 5M 个晶体管）。在 Pentium 处理器中增加了一类新的处理整数 向量的指令 。每个数据大小 可以是 1、2 或 4 字节。每个向量 总长 64 位。</p><p>Pentium 11(1 997 年， 7M 个晶体管）。P6 微体系结构的延伸。</p><p>Pentium 111(1 999 年， 8. 2M 个晶体管）。引入了 SSE , 这是一类处理整数或浮点数向最的指令 。每个数 据可以是 1、2 或 4 个字节， 打包成 128 位的向量。由 千芯片上包括了二级高速缓 存， 这种芯片后来的 版本最多使用了 24M 个品体管。</p><p>Pentium 4 ( 2000 年， 42M 个晶体管）。SSE 扩展 到了 SSE 2 , 增加了新的数据类型（包括双精 度浮点数）， 以及针对这些格式的 144 条新指令。有了这些 扩展， 编译器可以 使用</p><p>SSE 指令（而不是x87 指令）， 来编译浮点 代码。</p><p>Pentium 4E ( 2004 年， 1 25M 个晶体管）。增加了超线程 ( hypert hreading ) , 这种技术可以在 一个处理器上同时运行 两个程序； 还增 加了 EM64T , 它是 In tel 对 AMD 提出的对</p><p>IA32 的 64 位扩展的 实现， 我们称之为 x86-64 。</p><p>Core 2( 2006 年， 291 M 个晶体管）。回归到类似于 P6 的微体系结 构。Intel 的第一个多核微处理器，即多处理器实现在一个芯片上。但不支持超线程。</p><p>Core i7, Nehalem ( 2008 年， 781 M 个晶体管）。既支持超线程， 也有多核， 最初的版</p><p>本支持每个核上执行两个程序，每个芯片上最多四个核。</p><p>Core i7, Sandy Brid ge( 20 11 年， 1. 1 7G 个晶体管）。引入了 AV X , 这是对 SSE 的扩展， 支持把数 据封装 进 256 位的向量。</p><p>Core i7, H aswe ll ( 2013 年， 1. 4G 个晶体管）。将AV X 扩展 至 AV X2 , 增加了更多的</p><p>指令和指令格式。</p><p>每个后继处理器的设计都是后向兼容的一较早版本上编译的代码可以在较新的处理 器上运行。正如我们看到的那样，为了保持这种进化传统，指令集中有许多非常奇怪的东 西。Int el 处理器 系列 有好几个名字， 包括 IA 32 , 也就是 " Intel 32 位 体系结构 &lt; Intel Architecture 32-bit) &ldquo;, 以及最新的 In tel6 4 , 即 IA32 的 64 位扩展， 我们也称为 x86-64 。最常用的名字是 " x86&rdquo; , 我们用它指 代整个 系列 ， 也反映了直到 i486 处理器命名的惯例。</p><p>m 摩尔定律 ( Moo re &rsquo; s Law)</p><p>如果我们画 出各种不同的 Int el 处理 器 中晶 体管的 数量与 它们 出现 的年份 之间的 图( y 轴为晶 体管数 量的 对数值）， 我们能够 看 出， 增长是 很显著的。画一条拟合这些数 据的线， 可以 看到晶 体管数 量以每年 大约 37 % 的速率增 加， 也就是 说， 晶体管数 量每 26 个月就 会翻一 番。在 x86 微处理 器的 历 史上 ， 这种增长已经持 续 了好几十年 。</p><p>Intel微处理器的复杂性</p><p><img src=img/c744ace95a7f55507ea5bbf1b47e9bfd.jpeg alt>I.OE+ 10</p><p>LOE+ 09</p><p>Neha。lem◊</p><p><img src=img/a56c86886fb61fc4d0859372f03d2229.jpeg alt>Pentium4 夕ePentium4</p><p>／Core 2 Duo</p><p>I.OE+ 05</p><p>I.OE+ 04</p><p>1975 1980 1985 1990 1995 2000 2005 2010 2015</p><p>年份</p><p>1965 年， G ordon Moore, Intel 公 司的创始 人， 根据当时 的芯片技术（那时他们能够在一个芯 片 上制造有 大约 64 个晶 体管的电 路）做出推 断， 预测在 未来 10 年， 芯片 上的晶体管数量每年都会翻一番 。这个预测就称为摩 尔定律。正如事实证明的那样， 他的预测有点乐观， 而且 短视。在超过50 年中， 半导体工业一直能够使得晶体管数目每 18 个月翻一倍。</p><p>对计算机技术的其他方面，也有类似的呈指数增长的情况出现，比如磁盘和半导体 存储 器的 存储 容量。 这些惊人的 增长速度一 直是 计 算机 革命的 主要驱动力。</p><p>这些年来 ， 许多公司生产出了 与 Inte l 处理器兼 容的处理器， 能够运行完全相同 的机器级程序。其 中， 领头的是 AMD。数年来， AMD 在技术上紧跟 In tel, 执行的市场策略是： 生产性能 稍低但是价格更便宜的处理器。2002 年， AMD 的处理器变得更加有竞争力， 它们率先突破了 可商用微处理器的 1G H z 的时钟速度屏障， 并且引 入了广泛采用的</p><p>IA32 的 64 位扩展 x86-64。虽 然我们讲的是 Inte l 处理器， 但是对于其竞争对手生产的与之兼容的处理器来说 ， 这些表述也同样成 立。</p><p>对于由 CCC 编译器产生的 、在 Linux 操作系统平台上运行的程序 ， 感兴趣的人大多并不关心 x86 的复杂性。最初的 8086 提供的内 存模型和它在 80286 中的扩展 ， 到 i386 的时候就都已经过时了。原来的x87 浮点指令到引入 SSE2 以后就过时了 。虽然在 x86-64 程序中 ， 我们能看到历史发展的痕迹 ， 但 x86 中许多最晦涩难懂的特性已经不会出现了。</p><p>3. 2 程序编码</p><p>假设一个 C 程序， 有两个 文件 p l. c 和 p 2 . c 。我们用 Unix 命令行编译这些代码 ：</p><p>linux> gee -Og -op p1.e p2.e</p><p>命令 g e e 指的就是 GCC C 编译器。因 为这是 Lin u x 上默认的编译器， 我们也可以 简单地用 cc 来启 动它。编译 选项 - Oge 告诉编译器使用 会生成符合原 始 C 代码整体结 构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和 初始源 代码之间的 关系非常难以 理解。因 此我们会使 用- Og 优化作为学 习工具 ， 然后当我们增加优化级别时，再看会发生什么。实际中，从得到的程序的性能考虑，较高级别的优 化（例如， 以选项 - 0 1 或- 0 2 指定）被认为是 较好的 选择。</p><p>实际上 gee 命令调用了一 整套的 程序 ， 将源代码转化成可执行代码。首先， C 预 处理器扩展源代码 ， 插入所有用 #i ne l ude 命令指定的文件， 并扩展所有用#de f i ne 声明指定的宏。其 次， 编译 器产生两个源文件的 汇编代码 ， 名字分别为 p l. s 和 p 2 . s 。接下 来， 汇编器会 将汇编代码转化成二 进制 目标 代码文 件 p l. o 和 p 2 . o 。目 标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。最后，链接器将两 个目标代码 文件与实现库函数（例如 p r i n t f ) 的代码合并 ， 并产生最终 的可执行代码文件 p</p><p>（由命令行指示符 - o p 指定的）。可执行代码是我们要考虑的 机器代码的 第二种形式， 也就是处理器执 行的代码格式 。我们会在第 7 章更详细地介绍 这些不同形式的机器代码 之间的关系以及链接的过程。</p><ol><li><p>2. 1 机器级代码</p><p>正如在 1. 9. 3 节中讲 过的那样， 计算机系统 使用了多种不同形式的抽象 ， 利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。第一种是由指令集 体 系结构或指令 集 架构 O ns tru et ion Set Arehiteeture, ISA ) 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数</p><p>ISA, 包括 x86-64 , 将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可 以采取 措施保证整体行为与 ISA 指定的顺序执行的行为完全一致。第二种抽象是 ， 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系 统的实际实现是将多个硬件存储器和操作系统软件组合起来， 这会在第 9 章中讲到。</p><p>在整个编译过程中 ， 编译器会完成大部分的工作 ， 将把用 C 语言提供的 相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码表示非常接近于机器代 码。与机器代码的二进制格式 相比， 汇编代码的 主要特点 是它用可读性更好的文本格式 表示。能够理解汇编代码 以及它与原始C 代码的联系， 是理解计算机如何执行程序的关键一步。</p><p>x86-64 的机器代码 和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态都是可见的：</p><ul><li>程序计数 器（通常称为 " PC" , 在 x86-64 中用%r i p 表示）给出将要执行的下一条指令在内存中的地址。</li></ul></li></ol><p>8 GCC 版本 4. 8 引入了这个优化等级。较早的 CCC 版本 和其他 一些非 G U 编译器不认 识这个选项 。对这样一些编译器， 使用一级优化（由命令行标志-0 1 指定）可能是最好的选择， 生成的代码能 够符合原始程序的结构。</p><ul><li><p>整数寄存器文件包含 16 个命名的位置， 分别存储 64 位的值。这些寄存器可以存储地址</p><p>（对应于 C 语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态， 而其他的寄存器用来保存临时数据， 例如过程的参数和局部变量， 以及函数的返回值。</p></li><li><p>条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或 数据流中的 条件变化 ， 比如说用来实现 if 和 wh i l e 语句。</p></li><li><p>一组向量寄存器 可以存放一个或多个 整数或 浮点 数值。</p><p>虽然 C 语言提供了一种模型， 可以在内存中声明 和分配各种数 据类型的对象， 但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。 C 语言中的聚合数据类型， 例如数组和结构，在机器代码中用一组连续的字节来表示。即使是对标量数据类型，汇编代码 也不区分有符号或无符号整数，不区分各种类型的指针，甚至于不区分指针和整数。</p><p>程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调 用和返回的运行时栈 ，以 及用户分 配的内存块（比如说用 ma l l o c 库函数分配的）。正如前面提到的，程序内存用虚拟地址来寻址。在任意给定的时刻，只有有限的一部分虚拟地址 被认为是合法的。例如， x86-64 的虚拟地址是由 64 位的字来表示的。在目前的实现中，</p><p>这些地址的高 16 位必须设置为 o, 所以一个地址实际 上能 够指定的是 2 4 8 或 64T B 范围内</p><p>的一个字节。较为典型的程序只会访问几兆字节或几千兆字节的数据。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。</p><p>一条机器指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加， 在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些 指令的序列，从而实现（像算术表达式求值、循环或过程调用和返回这样的）程序结构。</p></li></ul><p>田 日 不断变化的 生成 代码的 格式</p><p>在本书的 表述中，我们给 出的 代码是由特定版本的 GCC 在特定的命令行选项设置下产 生的 。如 果你在自己 的机 器上编 译代码， 很有可能 用到 其他的 编译 器或 者不 同版本的 GCC , 因 而会产 生不同的代 码。 支持 GCC 的 开源社区 一 直在修 改代码产 生 器，试图根据微处理 器制 造商提供的 不断 变化的代码规则 ，产 生更有效的 代码。</p><p>本书示例的目标是展示如何查看汇编代码，并将它反向映射到高级编程语言中的结 构。你需要 将这些技 术应 用到 你的 特定的编译 器产 生的 代码格 式上 。</p><ol><li><p>2. 2 代码示例</p><p>假设我们写 了一个 C 语言代码文 件 ms t or e . c , 包含如下的函数定义：</p><p>long mult2(long, long);</p></li></ol><p>void multstore(long x, long y, long *dest) { long t = mult2(x, y);</p><p>*dest = t;</p><p>｝</p><p>在命令行 上使用 &ldquo;-s&rdquo; 选项 ， 就能看到 C 语言编译器产生的 汇编代码 ：</p><p>linux> gee -Og -S mstore.e</p><p>这会使 GCC 运行 编译 器， 产生一个汇编文件 ms t or e . s , 但是不做其他进一步的工作。（通常情况下，它还会继续调用汇编器产生目标代码文件）。</p><p>汇编代码文件包含各种声明，包括下面几行：</p><p>multstore: pushq %rbx</p><p>movq %rdx, %rbx</p><p>call mult2</p><p>movq %rax, (%rbx)</p><p>popq %rbx ret</p><p>上面代码 中每个缩进去的行都对应于一条机器指令。比如， p us hq 指令表示应该 将寄存器％</p><p>r bx 的内容压入程序栈中。这段代码中已经除去了所有关于局部变星名或数据类型的信息 。如果我们 使用 " - c" 命令行选项， GCC 会编译并 汇编该 代码：</p><p>linux> gee -Og -e mstore.e</p><p>这就会 产生目标 代码文件 ms t or e . o , 它是二进制格式的， 所以无法直接查看。1 368 字节的文件 ms t or e . o 中有一段 1 4 字节的序列， 它的十六进制 表示为：</p><p>53 48 89 d3 e8 00 00 00 00 48 89 03 Sb c3</p><p>这就是上面列出的汇编指令对应的目标代码。从中得到一个重要信息，即机器执行的程序只 是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。</p><p>m 如何展 示程序的 字节表示</p><p>要展示程序（比 如说 ms t or e ) 的二进制目 标代码， 我们 用反汇编 器（ 后 面会 讲到）确定该过程的代码 长度是 1 4 宇 节。 然后， 在文件 ms t or e . o 上运行 GNU 调试工具 GOB, 输入命令 ：</p><p>(gdb) x/14xb multstore</p><p>这条命令 告诉 GOB 显示（ 简写 为 &rsquo; x &rsquo; ) 从 函 数 mu l t s t or e 所处地 址开始的 1 4 个十 六进 制格式表 示（也简写为 &rsquo; x &rsquo; ) 的 宇 节（ 简写 为 &rsquo; b &rsquo; ) 。 你会发现， GOB 有很 多 有用的 特性可以用来 分析机 器级程序 ， 我们会 在 3. 10. 2 节中讨 论。</p><p>要查看机器代码 文件的内容， 有一类称为反汇 编 器 ( dis assem bier ) 的程序非常有用。这些程 序根据机器代码产生一 种类似于汇编代码的 格式。在 Lin u x 系统中， 带｀－扩命令行标志的程序 OBJDUMP ( 表示 " o bject d um p" ) 可以充当这个角色：</p><p>linux> objdump -d mstore.o</p><p>结果如下（这里，我们在左边增加了行号，在右边增加了斜体表示的注解）： Disassembly of function multstore in binary file mst or e . o 0000000000000000 &lt;multstore>:</p><p>Offset Bytes</p><p>0: 53</p><p>1: 48 89 d3</p><p>4: e8 00 00 00 00</p><p>9: 48 89 03</p><p>c: 5b</p><p>d: c3</p><p>Equivalent assembly language</p><p>push %rbx</p><p>mov %rdx,%rbx</p><p>callq 9 &lt;multstore+Ox9> mov %rax, (%rbx)</p><p>pop %rbx retq</p><p>在左边 ， 我们看到按照前 面给出 的字节顺序排列的 14 个十六 进制字节值， 它们分成了若干组 ， 每组有 1 ~ 5 个字节。每组都是一条指令 ， 右边是等价的 汇编语言 。</p><p>其中一些关千机器代码和它的反汇编表示的特性值得注意：</p><ul><li><p>x8 6- 64 的指令长 度从 1 到 1 5 个字节不等。 常用 的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。</p><p>·设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指 令。例如 ，只 有指令 p us h q % r b x 是以字节值 53 开头的 。</p></li><li><p>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。</p></li><li><p>反汇编器使 用的指令命名规则与 GCC 生成的汇编代码使用的有些细微 的差别。在我们的示 例中， 它省略了很 多指令结尾的 &rsquo; q &rsquo; 。这些后缀是大小指示符， 在大多数情况中可以省略。相反， 反汇编器 给 c a l l 和r e t 指令添加了＇矿后缀， 同样， 省略这些后缀也没有问题。</p><p>生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件 中必须含有一个 ma i n 函数。假设在文件 ma i n . c 中有下面这样的 函数：</p><p>#include &lt;stdio.h></p><p>void multstore(long, long, long*); int main() {</p><p>long d;</p><p>multstore(2, 3, &amp;d); printf(&ldquo;2 * 3 &ndash;> %1d\n&rdquo;, d); return O;</p><p>｝</p><p>long mult2(long a, long b) { longs= a* b; returns;</p><p>｝</p></li></ul><p>然后， 我们用 如下方法生成 可执行 文件 pr o g : linux> gee -Og -o prog main.e mstore.e</p><p>文件 pr og 变成了 8 655 个字节， 因为它不仅包含了 两个 过程的 代码 ， 还包 含了用来启动和终止程序的 代码， 以及用来与操作 系统交互的 代码。我 们也可以反汇编 pr o g 文件：</p><p>linux> objdump -d prog</p><p>反汇编器会抽取出各种代码序列，包括下面这段： Disassembly of function sum mul tstore binary file prog 0000000000400540 &lt;multstore>:</p><p>这段代码与 ms t or e . c 反汇编产生的 代码几乎完全一样。其 中一个主要的 区别是左边</p><p>列出的地址不同一—－链接器将这段代码的地址移到了一段不同的地址范围中。第二个不同 之处在千链接器 填上了 c a l l q 指令调 用函数 mu l t 2 需要使用的地址（反汇编代码第 4 行）。链接器的任 务之一就是为函数调用 找到匹 配的函数的 可执行 代码的位置。最后一个区别是多了两行代码（第 8 和 9 行）。这两条指 令对程序没有影响 ， 因为它们 出现在返回指令后面</p><p>（第 7 行）。插入这些指 令是为了使函数代码变为 1 6 字节， 使得就存储器系统性能而言， 能更好地放置下一个代码块。</p><ol><li><p>2. 3 关千格式的注解</p><p>GCC 产生的汇编代码 对我们来说有点 儿难读。一 方面， 它包含一些我们不需要关心的信息，另一方面，它不提供任何程序的描述或它是如何工作的描述。例如，假设我们用 如下命令 生成文件 ms t or e . s 。</p><p>linux> gee -Og -S mstore.e</p><p>mstore. s 的完整内 容如下：</p></li></ol><p>.file</p><p>.text</p><p>.globl</p><p>.t ype multstore:</p><p>pushq movq call movq popq ret</p><p>&ldquo;010-mstore.c&rdquo;</p><p>multstore</p><p>multstore, @function</p><p>%rbx</p><p>%rdx, %rbx mult2</p><p>%rax, (%rbx)</p><p>%rbx</p><p>.size multstore, .-multstore</p><p>.ident &ldquo;GCC: (Ubuntu 4.8.1-2ubuntu1-12.04) 4.8.1&rdquo;</p><p>.section .not e . GNU-stack, 1111 ,@progbits</p><p>．所有以｀．开，头的行都是 指导汇编器和链 接器工作的伪指令。我们通常可以忽略这些行。另 一方面， 也没有关于指令的用途以及它们 与源代码之间 关系的解释说明。</p><p>为了更清楚地说明汇编代码，我们用这样一种格式来表示汇编代码，它省略了大部分</p><p>伪指令 ， 但包括行 号和解释性说明。对于我们的示例 ， 带解释的汇编代码 如下：</p><p>void multstore(long x, long y, l ong • des t )</p><p>x in %rdi , y in multstore:</p><p>r%s i , dest in %rdx</p><p>通常我们只会给出与讨论内容相关的代码行。每一行的左边都有编号供引用，右边是 注释 ， 简单地 描述指令 的效果以及它与原始 C 语言代码中的 计算操作的关 系。这 是一种汇编语言程序员写代码的风格。</p><p>我们还提供网络旁注，为专门的机器语言爱好者提供一些资料。一个网络旁注描述的 是 IA32 机器代码 。有了 x8 6-64 的背景 ， 学习 IA 32 会相当简 单。另外一个网络旁 注简要</p><p>描述了在C 语言中插入汇编代码的方法。对千一些应用程序， 程序员必须用汇编代码来访问机器的低级特性。一种方法是用汇编代码编写整个函数， 在链接阶段把它们和 C 函数组合起来。另一种方法是利用 GCC 的支持，直 接在 C 程序中嵌入汇编代码。</p><p>日 日 ATT 与 Inte l 汇编代码格式</p><p>我们的 表述是 AT T ( 根据 " AT & T " 命名的， AT & T 是运营贝 尔 实验 室 多 年的公司）格式的 汇编代码， 这 是 GCC 、 OBJDUMP 和其他一 些我们使 用的 工具的默认格式。其他一些编程工具， 包括 Micro s of t 的 工具， 以 及 未 自 Int el 的 文档， 其 汇 编代码都是</p><p>Intel 格式的。这两种 格 式在许多 方 面 有所不 同。 例如 ，使 用 下述命令行， GCC 可以 产</p><p>生 mul t s t or e 函数的 Intel 格 式的代码：</p><p>linux> gee -Og -S -masm=intel mstore.e</p><p>这个命令得到下列汇编代码：</p><p>multstore: push rbx</p><p>mov rbx, rdx</p><p>call mult2</p><p>mov QWORD PTR [rbx], rax pop rbx</p><p>ret</p><p>我们看到 Intel 和 AT T 格式在如下方 面有 所不同 ：</p><ul><li><p>Intel 代码省略了指示大小的后 缀。我们看到指令 pus h 和 mov , 而不是 pus hq 和 movq 。</p><ul><li>I ntel 代码省略 了寄存器名 宇前面的 飞 ＇符号， 用的 是 r bx , 而不是 %r bx 。</li></ul></li><li><p>Intel 代码用 不 同的 方式来描 述内存中的位置 ， 例如是 &rsquo; QWORD PTR r[</p><p>, ( %r bx ) &rsquo; 。</p><p>bx ) &rsquo; 而 不是</p></li><li><p>在带有多 个操 作数的指令情况下， 列 出操 作数的顺序相反。当 在 两种格式之间进行转换的时候 ， 这一点非 常令人 困 惑。</p><p>虽 然在我们的表 述中不使 用 In tel 格 式， 但 是 在 来 自 Int el 和 Microso f t 的 文档 中， 你会遇到 它。</p></li></ul><p>日 百 五 一 把 C 程序和汇编代码结合起来</p><p>虽 然 C 编译 器在 把程序中表 达的 计算转换到机 器代 码方 面表 现出 色，但 是 仍 然有一些机 器特 性是 C 程序访问不 到 的。例 如 ， 每 次 x86- 64 处理 器执 行 算术或逻辑运 算 时， 如 果得 到 的 运算 结果的低 8 位 中有偶数 个 1, 那 么 就会把 一 个名为 P F 的 1 位 条件码(condition code) 标志设 置 为 1, 否则 就设置 为 0。 这里的 PF 表 示 " par it y flag ( 奇偶标志）”。 在 C 语言中计算这个信 息需要至 少 7 次移位、掩码和异或运算（参见习题 2. 65) 。即使 作 为 每 次算术或逻辑运算的 一部分，硬 件都完成 了这项计算， 而 C 程序却无法知道 PF 条件码标志的值。在程序中插入几条汇编代码指令就能很容易地 完成 这项任务。</p><p>在 C 程序中插 入汇编代码有两种方法。 笫一 种是， 我们可以 编写 完整 的函数，放 进一个独立的 汇编代码文件 中， 让汇编 器和 链 接 器把 它 和 用 C 语 言 书 写的代码合并起 来。笫 二 种 方法是 ， 我们 可以 使 用 GCC 的内联 汇编(i nline assem bly) 特性， 用 as m 伪指令可 以在 C 程序中 包含 简短的汇编 代码。这种方 法的 好处是减 少 了与 机器相关的 代码量。</p><p>当然， 在 C 程序 中 包含 汇 编代码使得这些代 码与 某 类特 殊的机器相 关（例如 x86-</p><p>64), 所以只应该在想要的特性只能以此种方式才能访问到时才使用它。</p><p>3. 3 数据格式</p><p>由千是从 16 位体系结构扩展成 32 位的 ， I ntel 用术语 ”字( word )" 表示 16 位数据类型。因此， 称 32 位数为“ 双字 ( double words)", 称 64 位数 为“ 四 字 ( quad words ) " 。图 3-1 给出了 C 语言基本数据类型对应的 x86-64 表示。标准 i n t 值存储为双字( 32 位）。指针（在此用 c har * 表示）存储为 8 字节的四字， 64 位机器本来就预期如此。x86-64 中， 数据类型 l ong 实现为 64 位，允 许表示的 值范围较大。本章代码示 例中的大部分都使 用了指针和 l ong 数据类型， 所以都是四字操作。x86-64 指令集同 样包括完 整的 针对字节、字和双字的指令。</p><table><thead><tr><th>C 声明</th><th>Intel 数据类型</th><th>汇编代码后缀</th><th>大小（字节）</th></tr></thead><tbody><tr><td>char</td><td>字节</td><td>b</td><td>1</td></tr><tr><td>short</td><td>字</td><td>w</td><td>2</td></tr><tr><td>int</td><td>双字</td><td>1</td><td>4</td></tr><tr><td>long</td><td>四字</td><td>q</td><td>8</td></tr><tr><td>char*</td><td>四字</td><td>q</td><td>8</td></tr><tr><td>float</td><td>单精度</td><td>s</td><td>4</td></tr><tr><td>double</td><td>双精度</td><td>1</td><td>8</td></tr></tbody></table><p>图 3-1 C 语言数据类型在 x86-64 中的大小。在 64 位机器中 ， 指针长 8 字节</p><p>浮点 数主要有 两种形式 ： 单精度 ( 4 字节）值， 对应于 C 语言数据类型 fl oa t ; 双精度</p><p>(8 字节）值， 对应千 C 语言数据类型 d oub l e 。x86 家族的微处理器历史上实现过对一种特殊的 80 位(1 0 字节）浮点格式进行全套的浮点 运算（参见家庭作业 2. 86) 。可以 在 C 程序中用声明 l ong do ub l e 来指定这种格 式。不过我们不建议使用 这种格式 。它不能移植到其他类型的机器上，而且实现的硬件也不如单精度和双精度算术运算的高效。</p><p>如图所示， 大多数 GCC 生成的 汇编代码指令都有一个字符的后缀， 表明 操作数的大小。例如，数据传送指令有四个变种： mov b ( 传送字节）、mov w ( 传送字）、mov l ( 传送双字）和movq ( 传送四字）。后缀＇口用来表示双字， 因为 32 位数被看成是“长字 ( l o ng w or d) " 。注意， 汇编代码也 使用后缀&rsquo; l &rsquo; 来表示 4 字节整数 和 8 字节双精度浮点 数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存辞。</p><p>3. 4 访问信息</p><p>一个 x86-64 的中央处理单元( CPU ) 包含一组 16 个存储 64 位值的通 用 目 的寄存 器。这些寄存器用来存储 整数数 据和指针。图 3-2 显示了这 16 个寄存器。它们的名字都以%r 开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。最 初的 8086 中有 8 个 16 位的寄存器， 即图 3-2 中的%a x 到%bp 。 每个寄存器都有特殊的用</p><p>途， 它们的名字就反映 了这些不同的用途。扩展到 IA32 架构时， 这些寄存器也扩展成 32 ／</p><p>位寄存器， 标号从%e a x 到%e bp 。 扩展到 x86-64 后，原 来的 8 个寄存器扩展成 64 位， 标</p><p>号从 r% a x 到%r bp 。除此之外 ， 还增加了 8 个新的寄存器， 它们的 标号是按照新的命名规</p><p>则制定的 ：从 %r 8 到%r 1 5。</p><p>31</p><p>%eax</p><p>%ebx [%bx</p><p>7 0</p><p>雪返回值</p><p>二 l 被调用者保存</p><p>毛r d i</p><p>%r bp</p><p>%ecx</p><p>%edx</p><p>毛e s i</p><p>I%bp</p><p>二 | 第4 个参数</p><p>二二］第3个参数三 l 第2个参数工 二 l 第1个参数</p><p>三|被调用者保存</p><p>% r s p %esp</p><p>%r 8 %r8d</p><p>%r9d [%r9w</p><p>%r10d [%rl0w</p><p>%r ll [ %r l l d [ %rllw</p><p>%r l 2 %rl2d [ %rl2w</p><p>%r l 3 %r 1 3d [%rl3w</p><p>%r l 4d [%rl4w</p><p>%rl5d [%r15w</p><p>三 l 栈指针</p><p>二 l 第5个参数</p><p>三 | 第 6 个 参 数</p><p>二 l 调用者保存</p><p>匡 l 调用者保存</p><p>三 l 被调用者保存</p><p>二|被调用者保存严 l 被调用者保存三 l 被调用者保存</p><p>图 3- 2 整数 寄存器。所有 16 个寄存器的低位部分都可以作为字节、字(1 6 位）、双字( 32 位）和四字( 64 位）数字来访问</p><p>如图 3-2 中嵌 套的方框标 明的， 指令可以 对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节 ， 1 6 位操作可以访问最低的 2 个字节， 32 位操作 可以访问最低的 4 个字节 ， 而 64 位操作 可以访问整个寄存 器。</p><p>在后面的章 节中， 我们会展现很 多指令， 复制和生成 1 字节、2 字节、4 字节和 8 字节值。当这些指令以寄存器作为目标 时， 对于生成小 于 8 字节结果的指令， 寄存器中剩下的字节会怎 么样， 对此有两条规则： 生成 1 字节和 2 字节数字的 指令会保持剩下的字节不变； 生成 4 字节数字的指令会把高位 4 个字节置为 0 。后面这条规则是作为从 IA32 到x86-64 的扩展的一部分 而采用的 。</p><p>就像图 3-2 右边的解释说 明的那样， 在常见的程序里不同的寄存器扮演不同的角色。其中最特别的是栈指针%r s p , 用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。另外 15 个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。更重要 的</p><p>是，有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值， 以及存储 局部和临时数据。我们会 在描述过程的实现时（特别是在 3. 7 节中）， 讲述这些惯例。</p><p>3. 4. 1 操作数指示符</p><p>大多数指令有 一个或多个操作数( o p e ra n d ) , 指示出执行一个操作中要使用的源数据值，以及放 置结果的 目的位置。 x86-64 支持多 种操作数格式（参见图 3-3 ) 。源数据值可以以常数形式 给出 ， 或是从寄存器或内存中读出。结果 可以 存放在寄存器或内存中。因此， 各种不同的 操作数的 可能 性被分为三种类型。第一种类型是立 即数( im m e d ia t e ) , 用来表示常数 值。在 A T T 格式的汇编代 码中， 立即数的书写 方式是｀＄＇后面跟一 个用标准 C 表示法 表示的整数 ， 比如， $ - 5 77 或$0x1 F。不同的指令允许的立即数值范围不同， 汇编器会自动选 择最紧凑的 方式进行 数值编码。第二种类型是寄存 器 ( r eg is t e r ) , 它表示某个寄存器的 内容， 1 6 个寄存器的低位 1 字节、2 字节、4 字节或 8 字节中的一个作为操作数，这些字节 数分别 对应于 8 位、16 位、32 位或 64 位。在图 3-3 中， 我们用符号r a 来表示任意寄存器 a , 用引用 R[r a] 来表示它的值， 这是 将寄存 器集合看成一个数组 R , 用寄存器标识 符作为索引。</p><p>第三类操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内 存位置。 因为将内存 看成一个很大的字节数组， 我们用符号 凶[ Ad d r ] 表示对存储在内 存中从地址 Ad d r 开始的 b 个字节值 的引用。为了 简便， 我们 通常省去下标 b。</p><p>如图 3-3 所示 ， 有多种不同的寻址模 式，允 许不同形式的内存引用。表中底部用语法</p><p>Imm(rb, r;, s) 表示的 是最常用的形式。这样的引用有四个组成部分： 一个立即数偏移</p><p>Imm, 一个基址寄存器r b&rsquo; 一个变址寄存器r ,和一个比例因子 s , 这里 s 必须是1、2、4 或者</p><p>8。基址和变址寄存器都必须是 64 位寄存器。有效地址被计算为 I m m + R[r b] + R[r ;] • s。引用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况，只是省略 了某些部分 。正如我们 将看到的 ， 当引用数组 和结构元素时 ， 比较复杂的寻址模式是很有用的。</p><table><thead><tr><th>类型</th><th>格式</th><th>操作数值</th><th>名称</th></tr></thead><tbody><tr><td>立即数</td><td>$Imm</td><td>Imm</td><td>立即数寻址</td></tr><tr><td>寄存器</td><td>ra</td><td>R[r. ]</td><td>寄存器寻址</td></tr><tr><td>存储器</td><td>Imm</td><td>M[Imm]</td><td>绝对寻址</td></tr><tr><td>存储器</td><td>(r.)</td><td>M[R[r。]]</td><td>间接寻址</td></tr><tr><td>存储器</td><td>lmm(r.)</td><td>M[Imm+R[r.]]</td><td>（基址＋偏移量）寻址</td></tr><tr><td>存储器</td><td>(rb, r;)</td><td>M[R[r.J+R[r,]]</td><td>变址寻址</td></tr><tr><td>存储器</td><td>Jmm(r., r,)</td><td>M[Jmm+R[r.]+R[r,]]</td><td>变址寻址</td></tr><tr><td>存储器</td><td>(,r,, s)</td><td>M[R[r;) · s]</td><td>比例变址寻址</td></tr><tr><td>存储器</td><td>/mm(,r,,s)</td><td>M[/mm+R[r,J · s]</td><td>比例变址寻址</td></tr><tr><td>存储器</td><td>(rb, r;,s)</td><td>M[R[rb ]+R[r;] · s]</td><td>比例变址寻址</td></tr><tr><td>存储器</td><td>Imm(r b, r,, s)</td><td>M[/mm+R[r.]+R[r,]·s]</td><td>比例变址寻址</td></tr></tbody></table><p>图 3-3 操作数格式 。操作数 可以 表示立即数（常数）值、寄存器 值或是 来自内存的值 。比例因子 s 必须 是 1、2、4 或者 8</p><p>霆 练习题 3. 1 假设下面的值存放在指明的内存地址和寄存器中：</p><p>寄存器 值</p><p>%r a x</p><p>%r c x</p><p>OxlOO Oxl</p><p>填写下表，给出所示操作数的值：</p><p>%r dx Ox3</p><table><thead><tr><th>操作数</th><th>值</th></tr></thead><tbody><tr><td>令r a x</td><td></td></tr><tr><td>Ox104</td><td></td></tr><tr><td>$0xl08</td><td></td></tr><tr><td>( %r a x )</td><td></td></tr><tr><td>4(%rax)</td><td></td></tr><tr><td>9(%rax, 毛r dx )</td><td></td></tr><tr><td>260 (%rcx, 号r dx )</td><td></td></tr><tr><td>OxFC (, %r c x , 4)</td><td></td></tr><tr><td>( % r a x, %r d x, 4)</td><td></td></tr></tbody></table><p>3. 4. 2 数据传送指令</p><p>最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功 能。我们会介绍多种不同的数据传送指令，它们或者源和目的类型不同，或者执行的转换不同，或者具有的一些副作用不同。在我们的讲述中，把许多不同的指令划分成指令类， 每一类中的指令执行相同的操作，只不过操作数大小不同。</p><p>图 3-4 列出的是最简单形式的数据传 送指令- MOV 类。这些指令把数据从 源位 置复制到目 的位 置， 不做任 何变 化。MOV 类 由 四条 指令 组 成： mov b 、 mov w、 mov l 和mov q 。 这些指令都 执行同样的操作； 主要区别在于它们操作的数据大小不同： 分别是 l 、</p><p>2、 4 和 8 字节。</p><table><thead><tr><th>指令</th><th>效果</th><th>描述</th><th></th></tr></thead><tbody><tr><td>MOV</td><td>S, D</td><td>D+-S</td><td>传送</td></tr><tr><td>movb</td><td></td><td>R 壬 I</td><td>传送字节</td></tr><tr><td>rnovw</td><td></td><td></td><td>传送字</td></tr><tr><td>movl</td><td></td><td></td><td>传送双字</td></tr><tr><td>movq movabsq</td><td>I, R</td><td></td><td>传送四字 传送绝对的四字</td></tr></tbody></table><p>图 3- 4 简单的数据传送指令</p><p>源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置， 要么是一个寄存器或者 ， 要么是一个内存地址。x86-64 加了一 条限制， 传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令—— 第一条指令 将源值加载到寄存 器中， 第二条将该寄存 器值写 人目的位置。参考图 3-2 , 这些指令的寄存 器操作数 可以是 16 个寄存器有标号部分中的任意一个 ， 寄存器部</p><p>分的大小必须与指令最后一个字符( &rsquo; b&rsquo; , &rsquo; w&rsquo; , &rsquo; l &rsquo; 或 &rsquo; q &rsquo; ) 指定的大小 匹配。大多数情况中， MOV 指令只会更新目的操作数指定的那些寄存器字节或内存位置。 唯一的例外是mov l 指令以 寄存器作 为目的 时， 它会把该寄存器的高 位 4 字节设置为 0 。造成这个 例外的原因是 x 8 6- 6 4 采用的 惯例， 即任何为寄存 器生成 3 2 位值的指令都会把该寄存器的高位部</p><p>分置成 0。</p><p>下面的 MOV 指令示例给出了源和目的类型的 五种可能的组合。记住 ， 第一个是源操作数，第二个是目的操作数：</p><p>movl $0x4050,%eax movw %bp,%sp</p><p>movb (%rdi,%rcx),%al movb $-17, (%rsp) movq %rax,-12(%rbp)</p><p>Immedi a t e - - Regi s t er , 4 bytes Register&ndash;Register, 2 bytes Memor y 一 Regi s t er , 1 byte</p><p>Immediate&ndash;Memory, 1 byte</p><p>Register&ndash;Memory, 8 bytes</p><p>图 3- 4 中记录的 最后一条指令是处 理 6 4 位立即数数据的。常规的 mo v q 指令只能以表示为 3 2 位补码数字的 立即数作为源操作数 ， 然后把这个值 符号扩展得 到 6 4 位的值， 放到目的位置 。mo v a b s q 指令能够以任意 6 4 位立即数值作 为源操 作数， 并且只能以寄存器作为目的。</p><p>图 3- 5 和图 3- 6 记录的是 两类数 据移动指令， 在将 较小的源值 复制到较 大的目的时使</p><p>用。所有这些指 令都把数据从源（在寄存器或内 存中）复制到目的寄存器。MOVZ 类中的指令把目 的中剩余的字节填充 为 o , 而 MOVS 类中的指令通过符号 扩展来填 充， 把源操作</p><p>的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符：第一个 字符指定源的大小，而第二个指明目的的大小。正如看到的那样，这两个类中每个都有三 条指令 ， 包括了所有的 源大小 为 1 个和 2 个字节、目的 大小为 2 个和 4 个的 情况 ， 当然只考虑目的大千源的情况。</p><table><thead><tr><th>指令</th><th>效果</th><th>描述</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>MOVZ</td><td>S,</td><td>R</td><td>R-</td><td>零扩展 ( S )</td><td>以零扩展进行 传送</td></tr><tr><td>mov zb w mo v zbl movzwl movzbq movzwq</td><td></td><td>将做了笭扩展的 字节传 送到字将做了零扩展的 字节传送到 双字将做了零扩展的 字传送 到双字将做了笭 扩展的字节传送 到四字 将做了零扩展的 字传送 到四字</td><td></td><td></td><td></td></tr></tbody></table><p>图 3-5 零扩展数据传送指令。这些指令以寄存器或内存地址作为源，以寄存器作为目的</p><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>MOVS S, R</td><td>R- 符号扩展 (S )</td><td>传送符号扩展的字节</td></tr><tr><td>movsbw movsbl movswl movsbq movswq movslq cltq</td><td>告r a x - 符号扩展（告ea x)</td><td>将做了符号扩展的字节传送到字 将做了符号扩展的字节传送到双字将做了符号扩展的字传送到 双字将做了符号扩展的字节传送到四字将做了符 号扩展的 字传送到四字 将做了符号扩展的双字传送到四字 把%ea x 符号扩展到 r% a x</td></tr></tbody></table><p>图 3-6 符号扩展数据传送指令。MO VS 指令以 寄存器或内 存地址作 为源 ，以 寄存器作为目的 。c l t q 指令只作用于寄存器 %e a x 和 %r a x</p><p>因日 理解数据传送如何 改变目的寄存器</p><p>正如我们描述的那样，关于数据传送指令是否以及如何修改目的寄存器的高位字节有两种不同的方法。下面这段代码序列会说明其差别：</p><p>movabsq $0x0011223344556677, %rax ¾rax = 0011223344556677</p><table><thead><tr><th>movb</th><th>$-1,</th><th>%al</th><th>¾rax = 00112233445566FF</th></tr></thead><tbody><tr><td>mo四</td><td>$- 1 ,</td><td>%ax</td><td>¾rax = 001122334455FFFF</td></tr><tr><td>movl</td><td>$-1,</td><td>%eax</td><td>¾rax = OOOOOOOOFFFFFFFF</td></tr><tr><td>movq</td><td>$-1,</td><td>%rax</td><td>¾rax = FFFFFFFFFFFFFFFF</td></tr></tbody></table><p>在接下来的讨论中 ， 我们使用十六进制表示 。在这个例子中 ，笫 1 行的指令把寄存器％</p><p>r a x 初始化 为位 模式 0011 223344556677 。剩下的指令的 海操作数值是立即数值 一1 。回想一</p><p>1 的十六进制表 示形如 FF… F, 这里 F 的数量是 表述中 宇 节数量的 两倍。因此 movb 指令</p><p>（第 2 行）把%r a x 的低位宇节设 置为 F F, 而 mo vw 指令（第3 行）把低2 位字节 设置为 FFFF, 剩下的 宇节保持 不 变。 mov l 指令（第 4 行）将低4 个宇 节设置为 FFFFFFFF, 同 时把 高位 4 宇节设 置为 00000000 。最后 movq 指令（第5 行）把整个寄存器设置为 FFFFFFFFFFFFFFFF。</p><p>注意图 3-5 中并没有一 条明确的指令把 4 字节源值 零扩展 到 8 字节目的。这样的 指令逻辑上应该被命名为 mo v z l q , 但是并没有这样的指令。不过，这样的数据传送可以用以寄存器为目的的 mov l 指令来实现。这一技 术利用的属性是， 生成 4 字节 值并以寄存器作为目的 的指令会把高 4 字节置为 0。对于 64 位的目标， 所有三种源类 型都有对应的符号 扩展传送，而只有两种较小的源类型有零扩展传送。</p><p>图 3-6 还给出 c l 七q 指令。这条指令 没有操作数： 它总是以寄存器%e a x 作为源，%r a x 作为符号扩展结果的目的。它的效果与指令 mov s l q %eax, %r a x 完全一致 ， 不过编码更紧凑。</p><p>; 练习题 3. 2 对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。（例 如， mov 可以 被 重写成 mo v b 、 mo v w、 mo v l 或者 mo v q 。)</p><p>mov_ mov— mov</p><p>%eax, (%rsp) (%rax), %dx</p><p>$0xFF, %bl</p><p>mov_</p><p>Cir儿</p><p>s p , %r dx , 4) , %dl</p><p>mov_ mov</p><p>(%rdx), %rax</p><p>%dx, (%rax)</p><p>日 字节传送指令比较</p><p>下面这个示例说明了不同的数据传送指令如何 改变或者不改 变目的的 高位宇节。仔细观</p><p>察可以发现， 三个字节传送指令 movb 、 movs bq 和 mov zbq 之间有细微的差别。 示例如下 ：</p><p>movabsq $0x0011223344556677, %rax movb $0xAA, %dl</p><p>movb %dl,%al movsbq %dl,%rax movzbq %dl,%rax</p><p>¼rax = 0011223344556677 7.dl = AA</p><p>¼rax = 00112233445566AA</p><p>¼rax = FFFFFFFFFFFFFFAA 7.rax = OOOOOOOOOOOOOOAA</p><p>在下 面的 讨论中，所有的值都使 用十六进制 表示。代码的 头 2 行将寄存 器%r a x 和%dl分别初始化 为 0011223344556677 和 AA。 剩下的 指令都是将%r dx 的低位宇 节复 制到 %r a x的低位 宇节。 movb 指令（笫3 行）不改 变其 他宇节。根据源宇节的 最高位， mov s bq 指令（第4 行）将其他 7 个宇节设为全 1 或全 0。由于十六进制 A 表示二进制值 1 01 0, 符号扩展会把高位宇节都设 置为 F F。mov zbq 指令（笫 5 行）总是将其他7 个字节全都设 置为 0 。</p><p>讫 练习题 3. 3 当我们调用汇编器的时候，下面代码的每一行都会产生一个错误消息。 解释每一行都是哪里出了错。</p><p>movb $0xF, (%ebx) movl %rax, (%rsp) movw (%rax),4(%rsp) movb %al,%s1</p><p>movq %rax,$0x123 movl %eax,%rdx movb %si, 8(%rbp)</p><ol><li><p>4. 3 数据传送示例</p><p>作为一个使用数 据传送 指令的 代码示例 ， 考虑图 3-7 中所示的数据交换函数， 既有 C</p><p>代码 ， 也有 GCC 产生的汇编代码 。</p></li></ol><p>long exchange(long *xp, long y)</p><p>｛</p><p>long x = *xp;</p><p>*xp = y; return x;</p><p>｝</p><ol><li>C语言代码</li></ol><p>long exchange(long•xp, long y)</p><p>xp 江 肚 d工， y 卫1 %rsi exchange:</p><p>movq (%rdi), %rax</p><p>movq %rsi, (%rdi) ret</p><p>Get x at xp. Set as return val ue . Store y at xp</p><p>Ret ru n .</p><p>b ) 汇编代码</p><p>图 3-7 exch ange 函数的 C 语言和汇 编代码。寄存器 r% 中 和r%</p><p>s i 分别 存放参数 xp 和 y</p><p>如图 3-7 b 所示， 函数 e x c h a ng e 由三条指令实现： 两个数据传送 C mov q ) , 加上一条返回函数 被调用点 的指令 Cr e t ) 。 我们 会在 3. 7 节中讲述函数调用和返回的细节。在此之前，知道参数通过寄存器传递给函数就足够了。我们对汇编代码添加注释来加以说明。函数通过把值存储 在寄存器 %r a x 或该寄存器的某个低 位部分 中返回。</p><p>当过程开始 执行时 ， 过程参数 xp 和 y 分别存储在寄存器%r d i 和%r s i 中。 然后， 指 令 2 从内存中读出 x , 把它存放 到寄存 器%r a x 中， 直接实现了 C 程序中的 操作 x=*xp。稍后， 用寄存器%r a x 从这个函数返回一个值， 因而返回值就是 x。指令 3 将 y 写入到寄存器%r d i 中的 x p 指向的内存位置， 直接实 现了操作*x p =y。这个例子说明了如何用 MOV 指令从内 存中读值到寄存 器（第2 行）， 如何从 寄存器写到内存（第 3 行）。</p><p>关于这段汇编代码有 两点值得注意。首先， 我们看到 C 语言中所谓的 ”指针” 其 实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存 器。其次 ， 像 x 这样的局 部变量通常 是保存在寄存器中 ， 而不是内 存中。访问 寄存器比访问内存要快得多。</p><p>芦 练习题 3 . 4 假设 变量 s p 和 d p 被声明 为 类型</p><p>src_t *sp; dest_t *dp;</p><p>这里 sr c _ t 和 d e s t _ 七 是用 t y p e d e f 声明 的数 据类型。 我们 想使 用 适 当的数据传 送指令来实现 下 面的操作</p><p>*dp = (dest_t) *sp;</p><p>假设 s p 和 d p 的值分别存储在寄 存器 %r d i 和%r s i 中。 对千表 中的 每个表 项，给出实现指定 数据传 送的 两条指令。其中第 一条指 令应该从内存 中读 数， 做适 当的 转换，并设置寄存器 %r a x 的适 当部 分。 然后， 第二条 指令 要把 %r a x 的 适 当部 分写到内存。 在这两种情况中 ， 寄存器的部分可以是 %r a x 、%e a x 、%a x 或 %a l , 两者可以互不相同。</p><p>记住 ， 当 执行 强制类型 转换 既 涉及 大小 变化又 涉及 C 语言中符号 变化 时 ， 操作 应该先 改 变大 小( 2. 2. 6 节）。</p><table><thead><tr><th>src t</th><th>de s 七 七</th><th>指令</th></tr></thead><tbody><tr><td>long</td><td>long</td><td>mo vq ( 号r di ) , 号r a x movq %r a x, 伐r s i )</td></tr><tr><td>char</td><td>int</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>char</td><td>unsigned</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>unsigned char</td><td>long</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>int</td><td>char</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>unsigned</td><td>unsigned char</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td>char</td><td>short</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>一 指针的一些示例</p><p>函数 e x c h a n g e ( 图 3- 7a ) 提供了一 个关 于 C 语言中指针使 用的 很好说明。参数 x p 是一 个指向 l o n g 类型的 整数的指针， 而 y 是一个 l o n g 类型的 整数。语句</p><p>long x = *xp;</p><p>表示我 们将 读存储在 x p 所指位 置中的 值， 并将它存 放到名 字 为 x 的局部 变量 中。 这个读操 作称 为指 针的间接 引 用 ( po in t er dereferencing), C 操作符＊ 执行指针的间接 引 用。</p><p>语句</p><p>*XP = y;</p><p>正好相反 它将 参数 y 的值 写到 x p 所指的 位置。这也是 指针 间接 引用的 一种形式（所以有操作符＊），但是它表明的是一个写操作，因为它在赋值语句的左边。</p><p>下 面是调用 e x c h a ng e 的一个实际例 子：</p><p>long a= 4;</p><p>long b = exchange(&amp;a, 3);</p><p>printf(&ldquo;a = %ld, b = %ld\n&rdquo;, a, b);</p><p>这段代码会打印出：</p><p>a= 3, b = 4</p><p>C 操作符 ＆（称为“取 址” 操作符）创建一个指针 ， 在本例 中， 该指针 指向保存局 部 变量 a 的位置。 然后 ， 函数 e x c ha nge 将用 3 覆盖存储在 a 中的 值， 但是返回原来的 值 4 作为函数的值。 注意如何将指针传递给 e xc ha ng e , 它能修改存在某个远处位置的数据。</p><p>区 练习题 3. 5 已知信息如下。将一个原型为</p><p>void decodel(long•xp, long *YP, long•zp);</p><p>的函数编译成汇编代码，得到如下代码：</p><p>vo1d decode1 (long *xp, long *YP, long *zp) xp in¼rdi , yp in¼rsi , zp in¼rdx</p><p>decode!:</p><p>movq (%rdi), %r8</p><p>movq (%rsi), %rcx</p><p>movq (%rdx), %rax</p><p>movq %r8, (%rsi) movq %rcx, (%rdx) movq %rax, (%rdi) ret</p><p>参数 x p 、 y p 和 z p 分别存 储在对 应的寄 存器 %r d i 、%r s i 和%r d x 中。</p><p>请写 出 等效于 上 面 汇编 代码 的 d e c o d e l 的 C 代码。</p><p>3. 4. 4 压入和弹出栈数据</p><p>最后两个数据传送操作可以 将数据压入程序栈 中，以 及从程序栈 中弹出数据， 如图 3-8 所示。正如我们将看到的，栈在处理过程调用中起到至关重要的作用。栈是一种数据结 构， 可以添加或者 删除值， 不过要遵循 ”后进先 出” 的原则。通过 p us h 操作把数据压入栈中 ， 通过 po p 操作删除数据； 它具有一个属性： 弹出的 值永远是最 近被压 入而且仍然在栈中的值。栈可以实现为一个数组，总是从数组的一端插入和删除元素。这一端被称为栈顶 。在 x86-64 中， 程序栈存 放在内 存中某个区域。如图 3-9 所示， 栈向下增长， 这样一来，栈顶元素的地址是所有栈中元素地址中最低的。（根据惯例，我们的栈是倒过来画的，栈 ＂顶” 在图的底部。）栈指针%r s p 保存着栈顶元 素的地址。</p><p>图 3-8 入栈和出栈指令</p><p>p u s hq 指令的功能是 把数据压入到栈上 ， 而 p o p q 指令是弹出 数据。这些指令都只有一个操作数 一一 压入的数 据源和弹出的 数据目的 。</p><p>将一个四字值 压入栈中， 首先要将栈指针减 8 , 然后将值写到新的栈顶地址。因此， 指令 p u s h q %r b p 的行为等价 于下面两条指 令：</p><p>subq $8,%rsp movq %rbp, (%rsp)</p><p>Decrement stack pointer Store 7.rbp on stack</p><p>它们之间的区别是在机器代码中 p us hq 指令编码为 1 个字节 ， 而上面那两条指令一共需 要</p><p>8 个字节。图 3-9 中前两栏给出的是， 当%r s p 为 Ox1 08 , %r a x 为 Ox1 23 时， 执行指令pushq %r a x 的效果。首先%r s p 会减 8 , 得到 Ox l OO, 然后会将 Ox1 23 存放到内存地址Ox l OO 处 。</p><p>最初</p><p>%rax</p><p>pushq %rax</p><p>popq %rdx</p><p>%rdx</p><p>¾rsp</p><p>栈＂底” 栈＂底” 栈＂底”</p><p>地址增大</p><p><img src=img/72f1727ece2ea1f6106d607386390881.jpeg alt>Oxl08 Oxl08 Ox108</p><p>栈＂顶” Ox!OO</p><p>Oxl23</p><p>栈“顶”</p><p>Oxl23</p><p>栈“顶”</p><p>图 3-9 栈操作说明 。根据惯例， 我们的栈是倒过来画的， 因而栈 ＂顶” 在底部。x86-64 中， 栈向低地址方向增长， 所以压栈是减小栈指针（寄存器%r s p) 的值， 并将数据存放到内存中，而出栈是从内存中读数据，并增加栈指针的值</p><p>弹出一个四字的操作包括从栈顶位 置读出数 据， 然后将栈指针加 8。因此， 指令 p op q</p><p>%r a x 等价千下面两条指令 ：</p><p>movq (%rsp),%rax addq $8,%rsp</p><p>Read 7.rax from stack Increment stack pointer</p><p>图 3-9 的第三栏说明 的是在执行 完 p us hq 后立即执行 指令 po pq %r d x 的效果。先从内存中读出值 Ox1 23 , 再写到寄存器%r d x 中， 然后， 寄存器%r s p 的值将增加回到 Ox10 8 。如图中所示， 值 Ox1 23 仍然会保持 在内存位置 Ox l OO 中， 直到被覆盖（例如被另一条入栈操作覆盖）。无论如何，% rs p 指向的 地址总是栈顶 。</p><p>因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标 准的内存寻址方法访问栈内的任意位置。例如， 假设栈顶元素是四字， 指令 mov q 8 (% rsp), %r d x 会将第二个四字从栈中复制到寄存 器%r d x 。</p><p>3. 5 算术和逻辑操作</p><p>图 3-10 列出了 x86-64 的一些整数 和逻辑操作。大多数操作都分成了指令类， 这些指令类有各种带不同大小操作数的变种（只有 l e a q 没有其他大小的变种）。例如， 指令类</p><p>ADD 由四条加法指令组成： a d db 、 a d d w、a d d l 和 a d d q , 分别是字节加法、字加法、双字加法和四字加法。事实上，给出的每个指令类都有对这四种不同大小数据的指令。这些</p><p>操作被分为四组：加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数， 而一元操 作有一个操作数 。这些 操作数的描 述方法与 3. 4 节中所讲的一样。</p><table><thead><tr><th>指令</th><th>效果</th><th>描述</th><th></th></tr></thead><tbody><tr><td>leaq</td><td>S,D</td><td>D 七 - &amp;S</td><td>加载有效地址</td></tr><tr><td>INC DEC NEG NOT</td><td>D D D D</td><td>D 七 - D+l D 仁 D - 1 D ..&ndash;D D&ndash;D</td><td>加 1 减 l 取负 取补</td></tr><tr><td>ADD SUB IMUL XOR OR AND</td><td>S,D S,D S,D S,D S,D S,D</td><td>D 七 D + S D 七 D - S D 七 - D * S v-v-s D 仁 D I S D&lt;-D&amp;S</td><td>加 减 乘 异或或 与</td></tr><tr><td>SAL SHL SAR SHR</td><td>k,D k,D k, D k,D</td><td>D-D«k D 七 - D«k D 七 D »A k D-D»ik</td><td>左移 左移（等同于SAL ) 算术右移 逻辑右移</td></tr></tbody></table><p>图 3-10 整数算术操作。加 载有效地址 ( l eaq) 指令通常用来执行简单的算术操作。其余的指令 是更加标准的一元或二元操作。我们用> > A 和 > > L 来分别 表示算术右移 和逻辑 右 移。注意 ，这 里 的 操 作 顺 序 与 AT T 格式的汇编代码中的相反</p><p>3. 5. 1 加载有效地址</p><p>加栽有效地 址O oa d effective address ) 指令 l e a q 实际上是 mo v q 指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写人到目的操作数。在 图 3-10 中我们用 C 语言的地址操作符 &amp;S 说明这种计算 。这条指令可以 为后面的内存引用产生指针。另外，它还可以简洁地描述普通的算术操作。例如，如果寄存器%r d x 的值为 x , 那么指令 l e a q 7 ( %r d x , %rdx, 4), %r a x 将设 置寄 存器%r a x 的值为 5x +</p><p>7。编译器经常 发现 l e a q 的一些灵活用法 ， 根本就与有效地址计算无关 。目的操作数必须是一个寄存器。</p><p>为了说明 l e a q 在编译出的 代码中的使用 ， 看看下 面这个 C 程序 ：</p><p>long scale(long x, long y, long z) { long t = x + 4 * y + 12 * z; return t;</p><p>编译时 ， 该函数的算术 运算以 三条 l e a q 指令实现， 就像右边 注释说明 的那样：</p><p>long scale(long x, long y, long z)</p><p>X 立 加 di , y in¼rsi , z in¼rdx scale:</p><table><thead><tr><th>leaq</th><th>(o/.rdi,o/.rsi,4),</th><th>o/.rax</th><th>X + 4*y</th></tr></thead><tbody><tr><td>leaq</td><td>(o/.rdx,o/.rdx,2),</td><td>o/.rdx</td><td>Z + 2*z = 3*Z</td></tr><tr><td>leaq</td><td>(o/.rax,o/.rdx,4),</td><td>o/.rax</td><td>(x +4*y) + 4* (3*z) = x + 4*y + 12*z</td></tr><tr><td>ret</td><td></td><td></td><td></td></tr></tbody></table><p>l e a q 指令能执行加法和有限形式的乘法， 在编译如上简单的算术表达式时 ， 是很有用处的。</p><p>芦 练习题 3. 6 假设寄 存器 %r a x 的 值 为 x , %r c x 的 值 为 y 。 填 写 下表， 指明 下 面每条 汇编代 码指令 存储在寄 存器 %r d x 中的值 ：</p><table><thead><tr><th>表达式</th><th>结果</th></tr></thead><tbody><tr><td>leaq 6 ( %ax ) , r% dx</td><td></td></tr><tr><td>leaq (r% ax, r% cx ) , r% dx</td><td></td></tr><tr><td>leaq (r% a x, r沦 cx, 4) , r毛 dx</td><td></td></tr><tr><td>leaq 7 (%r a x, % r ax, 8) , % r dx</td><td></td></tr><tr><td>leaq OxA(,%rcx,4), r令 dx</td><td></td></tr><tr><td>leaq 9 ( 毛r ax, r% cx , 2), r毛 dx</td><td></td></tr></tbody></table><p>沁 义 练习题 3. 7 考虑下面的代码，我们省略了被计算的表达式：</p><p>long scale2(long x, long y, long z) { long t = return t;</p><p>｝</p><p>用 GCC 编译 实际的 函 数得到 如下的 汇编代码 ：</p><p>long scale2(long x, long y, long z)</p><p>x in r7. di , y in 7.rsi , z in scale2:</p><p>r7. dx</p><p>leaq leaq leaq ret</p><p>(%rdi,%rdi,4), %rax (%rax,%rsi,2), %rax (%rax,%rdx,8), %rax</p><p>填写 出 C 代码 中缺 失的 表达 式。</p><p>3. 5. 2 一元和二元操作</p><p>第二组中的操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以是一个寄存 器， 也可以是一个内 存位置。比如说， 指令 i n c q ( %r s p ) 会使栈顶的 8 字节元 素加 1。这种语法让人想起 C 语言中的 加 1 运算符 &lt;+ + ) 和减 1 运算符（一—)。</p><p>第三组是 二元操作， 其中， 第二个操作数既是源又是目的 。这种语法让人想起 C 语言中的赋值运算符， 例如 x - =y 。不过， 要注意 ， 源操 作数是第一个，目 的操作数是第二个， 对千不可交换操作来说 ， 这看上去 很奇特。例 如， 指令 s u b q %r a x , %r d x 使寄存器%r d x 的值减去 %r a x 中的值。（将指令解读成“从%r d x 中 减去%r a x " 会有所帮助。）第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意， 当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回 内存。</p><p>; 练习题 3. 8 假设下面的值存放在指定的内存地址和寄存器中：</p><p>寄存器 值</p><p>r号 a x OxlOO</p><p>毛r c x Oxl</p><p>告rd x Ox3</p><p>填写下表，给出下面指令的效果，说明将被更新的寄存器或内存位置，以及得到</p><p>的值：</p><table><thead><tr><th>指令</th><th>目的</th><th>值</th></tr></thead><tbody><tr><td>addq %rcx, 伐rax )</td><td></td><td></td></tr><tr><td>subq %rdx, 8 (r% ax )</td><td></td><td></td></tr><tr><td>耳 nul q $16, 伐r ax, 毛r dx, 8)</td><td></td><td></td></tr><tr><td>incq 16 (r% ax )</td><td></td><td></td></tr><tr><td>decq r% cx</td><td></td><td></td></tr><tr><td>subq 号r dx, r% ax</td><td></td><td></td></tr></tbody></table><p>3. 5. 3 移位操作</p><p>最后一组是 移位操作 ，先 给出移位量， 然后第二项给出的 是要移位的 数。可以 进行 算术和逻辑右移。移位量可以 是一个立即数， 或者放在单字节寄存器% c l 中。（这些指令很特别 ， 因为只允 许以这个特定的寄存器作 为操作 数。）原则上来说， 1 个字节的移位量使得</p><p>移位量的 编码范围 可以达到 28 — 1 = 255 。x86- 64 中， 移位操作对 w 位长的 数据值进行 操</p><p>作， 移位量是由 %c l 寄存器的低 m 位决定的， 这里 2&rsquo;"= w。高位会被忽略。所以， 例如当寄存器 %c l 的十六进制值 为 Ox FF 时， 指令 s a l b 会移 7 位， s a l w 会移 15 位， s a l l 会移</p><p>31 位， 而 s a l q 会移 63 位。</p><p>如图 3-10 所示 ，左 移指令有两个 名字： S AL 和 S HL。两者的效果是一样的， 都是将右边填上 0。右移指 令不同 ， S AR 执行算术移位（填上符号位）， 而 SHR 执行逻辑 移位（填上0) 。移位操作的目 的操作数可以 是一个寄存器或是一个内存位置。图 3-10 中用>>A (算</p><p>术）和＞＞凶逻辑）来表示这两种不同的右移运算。</p><p>练习题 3. 9 假设 我们 想生成以 下 C 函 数的 汇编代 码 ：</p><p>long shift_left4_rightn(long x, long n)</p><p>X &lt;&lt;= 4;</p><p>X >>= n;</p><p>return x;</p><p>｝</p><p>下 面这 段 汇编代 码执 行 实 际 的 移位 ， 并 将最 后 的 结果放在寄 存器%r a x 中。 此处</p><p>省略 了两 条关键 的指令。 参数 x 和 n 分别 存放在寄 存器 %r d i 和%r s i 中。</p><p>long shi f t _l ef t 4工 i ght n (l ong x, long n)</p><p>X l D r加 di , n in Y.rsi shift_left4_rightn:</p><p>movq %rdi, %rax Get x</p><p>X &lt;&lt;= 4</p><p>movl %esi, %ecx Get n (4 byt es )</p><p>X >>= n</p><p>根据右边的注释，填出缺失的指令。请使用算术右移操作。</p><p>3. 5. 4 讨 论</p><p>我们看到图 3-10 所示的大多数指令 ， 既可以 用千无 符号 运算 ， 也可以 用千补码 运算。</p><p>只有右移操作要求区分有符号和无符号数。这个特性使得补码运算成为实现有符号整数运算的一种比较好的方法的原因之一。</p><p>图 3-11 给出 了一个执行算术操作的函数示例，以 及 它 的 汇编代码。参数 x 、y 和 z 初始时分别存放在内存%r d i 、%r s i 和 %r d x 中 。 汇编代码指令和 C 源代码行对应很紧密。第 2行计算 x " y 的值。指令 3 和 4 用 l e a q 和移位指令的组合来实现表达式 z * 48 。第 5 行 计算 七1 和 Ox OF OF OF OF 的 AND 值 。第 6 行 计算 最 后 的 减法。由于减法的目的寄存器是％</p><p>rax, 函数会返回这个值。</p><p>long arith(long x, long y, long z)</p><p>｛</p><p>long ti= x y; long t2 = z * 48;</p><p>long t3 = ti & OxOFOFOFOF; long t4 = t2 - t3;</p><p>return t4;</p><ol><li>C语言代码</li></ol><table><thead><tr><th>3</th><th>leaq</th><th>(%rdx,%rdx,2), %rax</th><th>3*Z</th><th></th></tr></thead><tbody><tr><td>4</td><td>salq</td><td>$4, %rax</td><td>t2 = 16</td><td>* (3*z) = 48*Z</td></tr><tr><td>5</td><td>andl</td><td>$252645135, %edi</td><td>t3 = t1</td><td>& OxOFOFOFOF</td></tr><tr><td>6</td><td>subq</td><td>%rdi, %rax</td><td>Return</td><td>t2 - t3</td></tr><tr><td>7</td><td>ret</td><td></td><td></td><td></td></tr></tbody></table><p>b ) 汇编代码</p><p>图 3-11 算术运算 函数的 C 语言和汇编代 码</p><p>在图 3-11 的汇编代码中，寄 存 器 %r a x 中 的 值 先 后 对 应于程序值 3 * z 、 z * 48 和 t 4( 作为返回值）。通常，编译器产生的代码中，会用一个寄存器存放多个程序值，还会在寄存 器之间传送程序值。</p><p>沁氐 练习题 3. 10 下 面的 函 数是 图 3- ll a 中 函 数 一个 变种 ， 其 中有些表达式用 空 格替 代 ：</p><p>long arith2(long x, long y, long z)</p><p>｛</p><p>long t1 = long t2 = _ long t3 = long t4 = return t4;</p><p>｝</p><p>实现这些表达式的汇编代码如下：</p><p>long arith2(long x, long y, long z) x i n ¼r d工， y 工n r¼s 工， z 工丑 肚 dx</p><p>arith2:</p><p>orq %rsi, %rdi</p><p>sarq $3, %rdi</p><p>notq %rdi</p><p>movq ir儿</p><p>dx , %rax</p><p>subq %rdi, %rax ret</p><p>基于这 些 汇编代码 ， 填写 C 语言代码 中缺 失的部分。</p><p>练习题 3. 11 常常可以看见以下形式的汇编代码行：</p><p>xorq %rdx,%rdx</p><p>但是在产 生这 段 汇编代 码的 C 代码 中，并 没 有出现 E XC L U S I V E-O R 操作。</p><ol><li>解释这条 特殊的 E XC L U S I V E- O R 指令 的效果 ， 它实现 了什 么有用 的操作。</li><li>更直接地表达这个操作的汇编代码是什么？</li><li>比较同样一个操作的两种不同实现的编码字节长度。</li></ol><p>3. 5. 5 特殊的算术操作</p><p>正如我们在 2. 3 节中看到的 ， 两个 6 4 位有符号 或无符号 整数相乘得到的 乘积需 要 1 28</p><p>位来表示 。x8 6-64 指令集对 1 28 位(1 6 字节）数的操作提供 有限的支持。延续字 ( 2 字节）、双字( 4 字节）和四字( 8 字节）的命名惯例 ， Intel 把 16 字节的 数称为八 宇 ( oct word ) 。图 3-1 2 描述的是 支持产 生两个 64 位数字的 全 1 28 位乘积以 及整数除 法的指令。</p><table><thead><tr><th>指令</th><th>效果</th><th>描述</th></tr></thead><tbody><tr><td>irnulq s mulq s</td><td>R[ %r dx] : R[ % r ax] - S XR [ r% ax] R[ %r dx] , R[ % r ax] +-S X R[ r% ax]</td><td>有符号全乘法无符号全乘法</td></tr><tr><td>clto</td><td>R[ r% dx] : R[r% ax] - 符号扩 展&lt;R[ r% ax] )</td><td>转换为八字</td></tr><tr><td>idivq s</td><td>R[ 毛r dx] - R[ 毛r dx] : R[ r沧 ax] mod S R[ r% dx]- R[ 毛r dx] : R[ r% ax] -c- S</td><td>有符号除法</td></tr><tr><td>divq s</td><td>R[ %rdx]-R[r% dx] : R[r% ax] mod S R[ %r dx] - R[ %r dx] , R[%rax]7S</td><td>无符号除法</td></tr></tbody></table><p>图 3-12 特殊的算术操作 。这些操作提供了有符号 和无符号数的全 128 位乘法和除法。</p><p>一对寄存器 r%</p><p>dx 和 r%</p><p>a x 组成一个 128 位的八 字</p><p>i mu l q 指令有两种不同 的形式。其中一种， 如图 3-1 0 所示， 是 IM U L 指令类中的一种。这种形式的 i mu l q 指令是一个“双操作 数＂ 乘法指 令。它从两个 64 位操作数产生一个 64 位乘积 ， 实现了 2. 3. 4 和 2. 3. 5 节中描述的操作 * 4 和 * 4 。（回想一下， 当将乘积 截取到 64 位时， 无符号乘 和补码 乘的位级行为是一样的 。）</p><p>此外 ， x8 6- 64 指令集还提供 了两条不 同的“单操作数” 乘法指令，以 计算两个 64 位 值的全 1 28 位乘积 一个是无符号数乘法( mu l q ) , 而另一个是补码乘法( i mu l q ) 。这 两条指令都要求一个参数必须 在寄存器%r a x 中， 而另一个作为指令的源操作数给出。然后乘积存放在寄存 器%r d x ( 高 64 位）和%r a x ( 低 64 位）中。虽然 i mu l q 这个名字可以 用 于两个不同的乘法操作，但是汇编器能够通过计算操作数的数目，分辨出想用哪条指令。</p><p>下面这段 C 代码是一 个示例， 说明了如何从 两个无符号 64 位数字 x 和 y 生成 1 28 位的乘积：</p><p>#include &lt;inttypes.h></p><p>typedef unsigned int128 uint128_t;</p><p>void store_uprod(uint128_t *dest, uint64_t x, uint64_t y) {</p><p>*dest = x * (uint128_t) y;</p><p>｝</p><p>在这个程序中 ， 我们显式 地把 x 和 y 声明为 64 位的数字， 使用文件 i n t t yp e s . h 中声明的定义， 这是对标 准 C 扩展的一部分。不幸的是， 这个标 准没有提供 128 位的 值。所以我们只好 依赖 GCC 提供的 1 28 位整数支持 ， 用名字_ _ i n tl 28 来声明。代码用 t yp e de f 声明定义了一 个数据类型 u i n t l 28 _ t , 沿用 的 i n t t yp e s . h 中其他数据类型的 命名规律。这段代码指明 得到的 乘积应该 存放在指 针 d e s t 指向的 16 字节处 。</p><p>GCC 生成的 汇编代码 如下 ：</p><p>void store_uprod(uint128_t *des t , uint64_t x, uint64_t y) des t 工 n r% di , x 耳 1 %rsi , y in %rdx</p><p>store_uprod:</p><table><thead><tr><th>movq</th><th>7.rsi,</th><th>%rax</th><th>Copy x to multiplicand</th></tr></thead><tbody><tr><td>mulq movq</td><td>7.rdx 7.rax,</td><td>(%rdi)</td><td>Mult i p l y by y Store lower 8 bytes at dest</td></tr><tr><td>movq</td><td>7.rdx,</td><td>8(7.rdi)</td><td>Store upper 8 bytes at dest+8</td></tr><tr><td>ret</td><td></td><td></td><td></td></tr></tbody></table><p>可以 观察到， 存储乘积需要两个 mo v q 指令： 一个存储低 8 个字节（第4 行）， 一个存储高 8 个字节（第5 行）。由于生成这段 代码针对的 是小端法机器， 所以高位字节存储 在大地址 ， 正如地址 8 ( %r d i ) 表明的那样。</p><p>前面的算术 运算 表（图3-10 ) 没有列 出除法或取模 操作。这些操作是由单操作数除法指令来提供的 ， 类似于单操作数乘法指令 。有符号除法指令 J.中 v l 将寄存器%r d x ( 高 64 位）和%r a x ( 低 64 位）中的128 位数作 为被 除数， 而除 数作为指 令的操作数给出。 指令将商存储在寄存器 %r a x 中， 将余数存储 在寄存 器%r d x 中。</p><p>对千大多数 64 位除法应用来说 ， 除数也常常是一 个 64 位的值。这个值应该存放在％</p><p>r a x 中 ，%r d x 的 位应该设 置为 全 0 ( 无符号运算）或者%r a x 的符号位（有符号运算）。后面这个操作可以用指令 c q 七0 8 来完成。这条指令不需 要操作数一一 它隐含读出 %r a x 的符号位 ， 并 将它复 制到 %r d x 的所有位 。</p><p>我们 用下面这个 C 函数来 说明 x86-6 4 如何实现除 法， 它计算了两个 64 位有符号数的商和余数： -;-</p><p>void remdiv(long x, long y,</p><p>long *qp, long *rp) { long q = x/y;</p><p>longr = x%y;</p><p>*qp = q;</p><p>*rp = r;</p><p>｝</p><p>该函数编译得到如下汇编代码：</p><p>e 在 Intel 的 文档中 ， 这条指 令叫做 cqo, 这是指 令的 ATT 格式 名字和 Intel 名字无 关的少数情况之一．</p><p>voi d remdiv(long x, long y, long•qp, long•rp) x in 7.rdi , y in 7.rsi , qp in 7.rdx, rp in 7.rcx remdiv:</p><p>movq movq cqto idivq movq movq ret</p><p>%rdx, %r8</p><p>%rdi, %rax</p><p>%rsi</p><p>%rax, (%r8)</p><p>%rdx, (%rcx)</p><p>Copy qp</p><p>Move x to lower 8 bytes of dividend</p><p>Sign-extend to upper 8 bytes of dividend Di vi de by y</p><p>Store quotient at qp Store remainder at rp</p><p>在上述代码中 ，必须 首先把参数 qp 保存到另一个寄存器中（第2 行）， 因为除 法操作要使用参数寄存器 %r d x 。 接下来 ， 第 3~ 4 行准备被除 数， 复制并 符号扩展 x 。除法之后，寄存器 %r a x 中的商被保存 在 qp ( 第 6 行）， 而寄存 器%r d x 中的余数被保存 在r p ( 第 7 行）。</p><p>无符号除 法使用 d i v q 指令。通常 ， 寄存器%r d x 会事先设 置为 0。</p><p>练习题 3. 12 考虑如下 函数， 它计 算 两个 无符 号 64 位数的 商和 余数 ：</p><p>void urerndiv(unsigned long x, unsigned long y, unsigned long *qp, unsigned long *rp) {</p><p>unsigned long q = x/y;</p><p>unsigned longr = x%y;</p><p>*qp = q;</p><p>*rp = r;</p><p>3. 6</p><p>｝</p><p>修 改有符号除 法的 汇编代 码来 实现这个 函数。</p><h6 id=控制>控制
<a class=anchor href=#%e6%8e%a7%e5%88%b6>#</a></h6><p>到目前为止 ， 我们只 考虑了 直线代 码的行为， 也就是指令一条接着一条顺序地执行。</p><p>C 语言中的某些结构 ， 比如条件语句、循 环语句和分支语句， 要求有条件的执行 ， 根据数据测试的结果来 决定操作执行的顺序。机器代码提供两种基本的 低级机制来实现有条件的行为： 测试数 据值， 然后根据测试的结果来改 变控制流或者数 据流。</p><p>与数据相关的控制流是实现有条件行为的更一般和更常见的方法，所以我们先来介绍 它。通常 ， C 语言中的语句和机器代码中的指令 都是按照它们在程序中 出现的次序， 顺序执行的。 用 jum p 指令可以改 变一组 机器代码指 令的执行顺序， jum p 指令指定控制应该被传递到程序的某个 其他部分， 可能是 依赖于某个测试的结果 。编译器必须产生构 建在这种低级机制基础之上的指令 序列， 来实 现 C 语言的控制结构。</p><p>本文会先涉及实 现条件操作的 两种方式 ， 然后描 述表达循 环和 s wi t c h 语句的方法。</p><ol><li><p>6. 1 条件码</p><p>除了整数寄存 器， CPU 还维护着一组单个位的条件码( co nd it io n cod e ) 寄存器， 它们描述了最 近的算术 或逻辑操作的 属性。可以检测这些寄存器来 执行条件分支指令。最常用的条件码有：</p><p>CF: 进位标志 。最近的操作使最高位产生了进位 。可用来 检查无符号操作的溢出 。</p><p>ZF: 零标志。最近的操作得出的结果为 0 。</p><p>SF: 符号标志。最近的操作得到的结果为负数。</p><p>OF : 溢出标志。最近的操作导致一个补码溢出 正溢出或负溢 出。</p></li></ol><p>比如说， 假设我们 用一条 ADD 指令完成 等价 千 C 表达式 t =a + b 的功能 ， 这里变簸</p><p>a 、b 和 t 都是整型的 。然后 ， 根据下 面的 C 表达式来设 置条 件码：</p><p>CF (unsigned) t &lt; (unsigned) a</p><p>ZF （ 七 = 0 )</p><p>SF （ 七&lt;0 )</p><p>无符号溢出零</p><p>负数</p><p>OF (a&lt;O==b&lt;O) && ( 七&lt;0 ! =a&lt;O) 有符号溢出</p><p>l e aq 指令不改变任何 条件码， 因为它是 用来进行 地址 计算的。除此之外， 图 3-10 中列出的所有指令 都会设置条 件码。对千逻 辑操作， 例如 XOR , 进位标志和溢出标志会设置成 0。对千移 位操作 ， 进位标 志将设置为最后一个被移出的位， 而溢出标志设置为 0。I NC 和 DEC 指令会设置溢出 和零标志， 但是不会改变进位标志， 至千原 因， 我们就不在这里深入探讨了。</p><p>除了 图 3-10 中的指令会设置 条 件</p><p>码， 还有两类指令（有8、16 、32 和 64 位形式），它们只设置条件码而不改变任何其他寄存器； 如图 3-13 所示。CMP 指令根据两个操作数之差 来设置 条件码。除了只设置条件码而不更新目的寄存器 之外， CMP 指令与 SUB 指令的行 为是一样的。在 AT T 格式中， 列出操作 数的顺序是相反的，这使代码有点难读。如 果两个 操作数相等， 这些指令会将零标志设置为 1 , 而其他的标志可以用来确定两个操作数之间的大小 关系。T EST 指</p><p>令的行为与 AND 指令一样 ，除 了 它们只设置条件码而不改变目的寄存器的值。</p><p>图 3-13 比较和测试指令。这些指令不修改任何</p><p>寄存器的值，只设置条件码</p><p>典型的用法是， 两个操作数是一样的（例如， t e s t q % r a x, %r a x 用来检查%r a x 是负数、零，还是正数），或其中的一个操作数是一个掩码，用来指示哪些位应该被测试。</p><ol><li><p>6. 2 访问条件码</p><p>条件码通常不会直接读取，常用的使用方法有三种： 1 ) 可以 根据条件码的某种组合， 将一个字节设 置为 0 或者 1 , 2) 可以 条件跳 转到程序的 某个其他的部分， 3 ) 可以 有条 件地传送数据。对于第一种情 况，图 3-1 4 中描述的指令根据条件码的某种组合， 将一个字节设置为 0 或者 1。我们将 这一整类指令 称为 SET 指令； 它们之间的区别就在于它们考虑的条件码的组合是什么 ， 这些指令 名字的不同后缀指明了它们 所考虑的条件码的组合。这些指令的后缀表示不同的条件而不是操 作数大小 ，了 解这一点很重要。例如， 指令 s e t l 和s e t b 表示“小于时设 置( set less ) " 和“低 千时设置( set below)", 而不是“设置长字 ( set long word ) " 和“设置字节 ( set byte) " 。</p><p>一条 SET 指令的目的操作数是 低位单字节寄 存器元素（图3-2 ) 之一， 或是一个字节的内存位置， 指令会将这个 字节设 置成 0 或者 1。为了得到一个 32 位或 64 位结果， 我们必须对高位 清零。一个计算 C 语言表达式 a &lt; b 的典型指令序列如下 所示 ， 这里 a 和 b 都是l o ng 类型 ：</p></li></ol><table><thead><tr><th>指令</th><th>同义名</th><th>效果</th><th>设置条件</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>sete setne</td><td>D D</td><td>setz setnz</td><td>D D</td><td>七七</td><td>ZF - ZF</td><td>相等／零不等／非零</td></tr><tr><td>sets setns</td><td>D D</td><td></td><td>D D</td><td>七七</td><td>SF - SF</td><td>负 数 非负数</td></tr><tr><td>setg setge setl setle</td><td>D D D D</td><td>setnle setnl setnge setng</td><td>D D D D</td><td>七七七 仁</td><td>~(SF - OF) & -ZF - (SF - OF) SF - OF (SF - OF) I ZF</td><td>大千（有符号＞） 大于等于（有符号＞＝） 小于（有符号＜） 小千等于（有符号＜＝）</td></tr><tr><td>seta setae setb setbe</td><td>D D D D</td><td>setnbe setnb setnae setna</td><td>D D D D</td><td>七七七 七</td><td>- CF &-ZF ~CF CF CF I ZF</td><td>超过（无符号＞） 超过或相等（无符号＞＝） 低于（无符号＜） 低于或相等（无符号＜＝）</td></tr></tbody></table><p>图 3- 1 4 SET 指 令 。 每条指令 根据条件码的某种组合， 将 一 个 字 节 设 置 为 0 或 者 1 。有些指令有“同义名“，也就是同一条机器指令有别的名字</p><ol><li><p>nt comp(data_t a, data_t b) a in 7.rdi , b in 7.rsi</p><p>comp:</p></li></ol><p>cmpq setl movzbl ret</p><p>%rsi, %rdi</p><p>%al</p><p>%al, %eax</p><p>Compare a: b</p><p>Set low-order byte of 7.eax to O or 1 Clear rest of 7.eax (and rest of 7.rax)</p><p>注意 c mpq 指令的比较顺 序（第2 行）。虽然参 数列出的顺 序先是%r s i ( b ) 再是%r d i ( a ) , 实际上比较 的是 a 和 b 。还要记得 ， 正如在 3. 4. 2 节中讨 论过的那样 ， mo v z b l 指令不仅会把%e a x 的高 3 个字节清零 ， 还会把 整个寄 存器%r a x 的高 4 个字节都 清零。</p><ul><li><p>某些底层 的机器指令可能有多个名字， 我们称之为“同 义名 ( s y no n ym ) " 。比如说， s e t g ( 表示“设置大千")和 s e t n l e ( 表示“设 置不 小千等千")指 的就是同一条机器指令。编译器和反汇编器会随意决定使用哪个名字。</p><p>虽然所有的算术和逻辑操作都会设 置条件码， 但是各个 SET 命令的描述都适用的情况 是： 执行比较指令， 根据计算 t =a - b 设置条件码。更具体地说， 假设 a 、b 和 t 分别是 变量 a 、 b 和 t 的补码形式表示的整数， 因此 t = a - 口,b, 这里 w 取决 千 a 和 b 的大小。</p><p>来看 s e t e 的 情况 ， 即“当相等时设置( set when equal) " 指令。当 a = b 时， 会得到t = O,</p><p>因此零标志置位就表示相等。类 似地 ， 考虑用 s e t l , 即“当小千时设 詈( set when less) " 指令， 测试一个有符号比较。当没有发生溢出时( OF 设置为0 就表明无溢出）， 我们有当 a —:Vb &lt; O时 a &lt; b, 将 SF 设置为 1 即指明这一点， 而当 a —:Vb O 时 a 多b, 由 SF 设置为 0 指明。另一 方面， 当发生溢出时 ， 我们有当 a — .b> O( 负溢出）时a &lt; b , 而当 a —汹&lt; O( 正溢出）时a > b。</p><p>当 a = b 时， 不会有溢出。因此 ， 当 OF 被设置为 1 时， 当且仅当 SF 被设置为 o, 有 a &lt; b。将</p><p>这些情况组合起来 ， 溢出和符号位的 EXCLUSIVE-OR 提供了 a &lt; b 是否为真的测试。其他的有符号比较测试基千 SF A OF 和 ZF 的其他组合。</p><p>对于无符号 比较的测试 ， 现在设 a 和b 是变量 a 和 b 的无符号形式表示的 整数。在执行计算 t =a - b 中， 当 a - b&lt; O 时， CMP 指令会设置进位标 志， 因而尤 符号比较使用的是</p></li></ul><p>进位标志和零标志的组合。</p><p>注意到机器代码 如何区分有符号和无符号值是很重要的 。同 C 语言不同， 机器代码不会将每个程序值都和一个数据类型联系起来。相反，大多数情况下，机器代码对千有符号和无符号两种情况都使用一样的指令，这是因为许多算术运算对无符号和补码算术都有一样的位级行为。有些情况需要用不同的指令来处理有符号和无符号操作，例如，使用不同版本的右移、除法和乘法指令，以及不同的条件码组合。</p><p>芦 练习题 3. 13 考虑下 列的 C 语言代 码 ：</p><p>int comp(data_t a, data_t b) { return a COMP b;</p><p>它给 出 了 参 数 a 和 b 之 间 比 较 的 一 般 形 式 ， 这 里 ， 参 数 的 数 据 类 型 d a t a _ t ( 通 过t yp e d e f ) 被声明 为表 3-1 中列 出的 某种整数 类型 ， 可以是 有符 号的也 可以是 无符号的 c omp 通过 # d e f i ne 来定 义。</p><p>假设 a 在 %r 土 中某个部 分， b 在 %r s i 中 某个 部 分。 对于下 面每 个 指令 序 列， 确定哪 种数 据类型 d a t a _ t 和比 较 COMP 会导致编译 器 产 生这 样的代码。（可能 有 多个 正确答案，请列出所有的正确答案。）</p><ol><li>cmpl %esi, %edi setl %al<ol><li>cmpw %si, %di setge %al<ol><li>cmpb %sil, %dil setbe %al<ol><li><p>cmpq %rsi, %rdi setne %a</p><p>比氐 练习题 3. 14 考虑下 面的 C 语言代 码 ：</p><p>int test(data_t a) { return a TEST O;</p><p>｝</p></li></ol></li></ol></li></ol></li></ol><p>它给出了参数 a 和 0 之间比较的 一般形 式，这里，我们 可以 用 t yp e de f 来声明 da t a _t , 从而设置参数的数据类型，用# de f i ne 来声明 TEST, 从而设置比较的类型。对于下面每个指令 序列， 确定 哪种 数据 类 型 d a t a _ t 和比 较 TEST 会导 致 编译器 产 生 这样的代码。（可能有多个正确答案，请列出所有的正确答案。）</p><ol><li><p>testq %rdi, %rdi</p><p>setge %al</p></li><li><p>testw %di, %di sete %al</p></li><li><p>testb %dil, %dil seta %al</p></li><li><p>testl %edi, %edi setne %al</p></li></ol><p>3. 6. 3 跳转指令</p><p>正常执行的情况 下， 指令按照它们 出现的顺 序一条一条地执行 。跳转( j um p ) 指令会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号</p><p>(labe l) 指明。考 虑下面的汇编代码 序列（完全是人为编造的）：</p><p>movq $0,%rax jmp .L1</p><p>movq (%rax),%rdx</p><p>.L1:</p><p>popq %rdx</p><p>Set 7.rax to 0 Goto .L1</p><p>Null pointer dereference (s 虹 pped)</p><p>Jump target</p><p>指令 j mp . Ll 会导致程序跳过 mo v q 指令， 而从 p o p q 指令开始继续 执行。在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令的地址）编码 为跳转指令的一部分。</p><p>图 3-15 列举了不同的 跳转指令。j mp 指令是无条件跳转 。它可以是直接跳转 ， 即跳转目标是作为指令的一部分编码的；也可以是间接跳转，即跳转目标是从寄存器或内存位置 中读出的。汇编语言中，直接跳转是给出一个标号作为跳转目标的，例如上面所示代码中 的标号".Ll " 。间接跳转的写 法是 &lsquo;* &lsquo;后面跟一个 操作数指 示符 ， 使用图 3-3 中描述的内存操作数格式中的一种。举个例子，指令</p><p>jmp *%rax</p><p>用寄存器 %r a x 中的值作为跳转目标 ， 而指令</p><p>jmp *(%rax)</p><p>以%r a x 中的值作为读地址， 从内存中读出跳转目标 。</p><table><thead><tr><th>指令</th><th>同义名</th><th>跳转条件</th><th>描述</th><th></th></tr></thead><tbody><tr><td>jmp jmp</td><td>Label *Operand</td><td></td><td>1 1</td><td>直接跳转间接跳转</td></tr><tr><td>je jne</td><td>Label Label</td><td>jz jnz</td><td>ZF -ZF</td><td>相等／零 不相等／非零</td></tr><tr><td>js jns</td><td>Label Label</td><td></td><td>SF -SF</td><td>负 数 非负数</td></tr><tr><td>jg jge jl jle</td><td>Label Label Label Label</td><td>jnle jnl jnge jng</td><td>-(SF - OF) &: -ZF -(SF- OF) SF- OF (SF - OF) I ZF</td><td>大千（有符号＞） 大于或等于（有符号＞＝） 小于（有符号＜） 小于或等于（有符号＜＝）</td></tr><tr><td>ja jae jb jbe</td><td>Label Label Label Label</td><td>jnbe jnb jnae jna</td><td>-CF &-ZF -CF CF CF I ZF</td><td>超过（无符号＞） 超过或相等（无符号 ＞＝） 低于（无符号＜） 低于或相等（无符号＜＝）</td></tr></tbody></table><p>图 3-15 ju mp 指令。当跳转条 件满足时 ，这 些 指 令 会 跳 转 到 一 条 带 标 号 的 目 的 地 。有些指令有“同义名“，也就是同一条机器指令的别名</p><p>表中所示的其他跳转指令都是有条件的－它们根据条件码的某种组合，或者跳转， 或者继续 执行代码序列 中下一条指令。这些指令的名字和跳 转条件与 SET 指令的名字和 设置条件是 相匹配的（参见图3-14) 。同 SET 指令一样 ， 一些底层的 机器指令有多个名字。条件跳转只能是直接跳转。</p><ol><li><p>6. 4 跳转指令的编码</p><p>虽然我们不关 心机器代码格式的细节 ， 但是理 解跳转指令的目标如何编码， 这对第 7</p></li></ol><p>章研究链接非常重要。此外，它也能帮助理解反汇编器的输出。在汇编代码中，跳转目标 用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有 几种不同的编码 ， 但是最 常用都是 P C 相对的 ( P C- relat ive ) 。也 就是 ， 它们会将目标指令 的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编 码为 1 、2 或 4 个字节。第二 种编码方 法是给出“绝对“地址，用 4 个字节直接指定 目标。汇编器和链接器会选择适当的跳转目的编码。</p><p>下面是一 个 P C 相对寻址的 例子， 这个函数的汇编代码由 编译文件 bra nch. c 产生。它包含两个 跳转： 第 2 行的 j mp 指令前向 跳转 到更高的地址， 而第 7 行的 j g 指令后向跳转到较低的地址。</p><p>movq jmp</p><p>.13:</p><p>sarq</p><p>.12:</p><p>%rdi, %rax</p><p>.L2</p><p>%rax</p><p>testq %rax, %rax jg .13</p><p>rep; ret</p><p>汇编器产生的 " . o" 格式的 反汇编版本 如下 ：</p><table><thead><tr><th>0:</th><th>48</th><th>89</th><th>f8</th><th>mov</th><th>%rdi,%rax</th></tr></thead><tbody><tr><td>3:</td><td>eb</td><td>03</td><td></td><td>jmp</td><td>8 &lt;loop+Ox8></td></tr><tr><td>5:</td><td>48</td><td>d1</td><td>f8</td><td>sar</td><td>%rax</td></tr><tr><td>8:</td><td>48</td><td>85</td><td>co</td><td>test</td><td>%rax, %rax</td></tr><tr><td>b:</td><td>7f</td><td>f8</td><td></td><td>jg</td><td>5 &lt;loop+Ox5></td></tr><tr><td>d:</td><td>f3</td><td>c3</td><td></td><td>repz</td><td>retq</td></tr></tbody></table><p>右边反汇编器产生的 注释中 ， 第 2 行中跳转指令的跳转目标指明为 Ox B, 第 5 行中跳转指令的跳转目标是 Ox S( 反汇编器以 十六 进制格式给出 所有的数字）。不过， 观察指令的字节编码 ， 会看到第一 条跳转 指令的目标 编码（在第二个字节中）为Ox 03 。把它加上 Ox S, 也就是下一条指令的 地址 ， 就得到跳转目 标地址 Ox 8 , 也就是第 4 行指令的地址。</p><p>类似， 第二个跳转指令的目标用单字节 、补码表示 编码为 Ox f B( 十进制 -8 ) 。将这个数加上 Oxd ( 十进制 13 ) , 即第 6 行指令的地址 ， 我们得到 Ox S, 即第 3 行指令的地址。</p><p>这些例子说明 ， 当执行 P C 相对寻址时 ， 程序计 数器的值是跳转指令后面的 那条指令的地址，而不是跳转指令本身的地址。这种惯例可以追溯到早期的实现，当时的处理器会将更新程序计数器作为执行一条指令的第一步。</p><p>下面是链接后的程序反汇编版本：</p><table><thead><tr><th>4004d0:</th><th>48 89 f8</th><th>mov</th><th>%rdi,%rax</th></tr></thead><tbody><tr><td>4004d3:</td><td>eb 03</td><td>jmp</td><td>4004d8 &lt;loop+Ox8></td></tr><tr><td>4004d5:</td><td>48 d1 f8</td><td>sar</td><td>%rax</td></tr><tr><td>4004d8:</td><td>48 85 co</td><td>test</td><td>%rax,%rax</td></tr><tr><td>4004db:</td><td>7f f8</td><td>jg</td><td>4004d5 &lt;loop+Ox5></td></tr><tr><td>4004dd:</td><td>f3 c3</td><td>repz</td><td>retq</td></tr></tbody></table><p>这些指令被重定 位到不同的 地址， 但是 第 2 行和第 5 行中跳转 目标的编码并 没有变。通过使用 与 P C 相对的跳转目标 编码， 指令编码很简洁（只需要 2 个字节）， 而且目标代码 可以不做改变就移到内存中不同的位置。</p><p>m 指令r e p 和r e p z 有什么用</p><p>本节开始的 汇编代码的 笫 8 行 包含指令组合r e p ; r e t 。它们在 反汇编 代码中（笫 6 行）对应于r e p zr e 七q 。 可以推 测 出r e p z 是r e p 的 同 义名， 而r e t q 是r e t 的同 义名。查阅 Intel 和 AMD 有关r e p 的 文档，我 们发现它通 常 用 来 实现重复的 字符 串操作[ 3 ,</p><p>51] 。在这 里用它似乎很 不合 适。 这个问 题的答案 可以 在 AMD 给编译器编 写 者的 指导意见书 [ l ] 中找到 。他们建议用r e p 后 面跟r e t 的组合来避免 使r e t 指令成为条件跳 转指令的目标 。如果没有r e p 指令 ， 当 分 支不跳 转时， j g 指令（汇编代码的 第 7 行）会继续到 r e t 指令。根据 AM D 的说法， 当r e t 指令通过跳 转指令到 达时 ， 处理 器不能 正确预测 r e t 指令的 目的 。这里的r e p 指令就是作为 一种空操 作， 因此 作为 跳转目 的插入它， 除了能使代码在 AMD 上运行得 更快之 外， 不会 改 变代码的 其他 行为。 在本书后 面其他代 码中再遇到 r e p 或r e p z 时，我 们可以很 放心地无视 它们。</p><p>区§练习题 3. 15 在下 面这 些反 汇编 二进 制 代 码 节选 中 ， 有 些 信息 被 X 代替 了。 回答下列关于这些指令的问题。</p><ol><li><p>下 面 j e 指令的 目标是 什 么？（在此， 你不需 要知道任何 有关 c a l l q 指令的 信息。）</p><p>4003fa: 74 02 je xxxxxx</p><p>4003f c : ff dO callq *%rax</p><ol><li><p>下面尸：指令的目标是什么？</p><p>40042f: 74 f4 je xxxxxx</p><p>400431: 5d pop %rbp</p></li><li><p>j a 和 p o p 指令的 地址是 多少？</p><p>XXXXXX: 77 02 ja 400547</p><p>XXXXXX: 5d pop %rbp</p></li><li><p>在下 面的代 码 中，跳 转目标的编 码是 PC 相对的 ， 且是 一个 4 字节补码数。 字节桉</p><p>． 照从最低位到 最高位 的顺序列 出，反 映 出 x86-6 4 的 小端 法 字节 顺 序。 跳 转 目标 的地址是什么？</p></li></ol></li></ol><p>4005e8: e9 73 ff ff ff 4005ed: 90</p><p>jmpq XXXXXXX nop</p><p>跳转指令提供了一种实现条件执行（江）和儿种不同循环结构的方式。</p><ol><li><p>6. 5 用条件控制来实现条件分支</p><p>将条件表达式 和语句从 C 语言翻译 成机器代码 ， 最常用的方式是结 合有条件 和无条件跳转。（另一种方式在 3. 6. 6 节中会看到， 有些条件可以 用数据的条件转移实现， 而不是用控制的条 件转移来 实现。）例如， 图 3-1 6a 给出了一个计 算两数之差绝对值 的函数的 C 代码气 这个函数有一 个副作用 ， 会增加两个计数 器， 编码为全局 变最 l t _ c n t 和 g e _ c n t 之一。G CC 产生的汇编代码 如图 3-1 6c 所示。把这个 机器代码再转换成 C 语言， 我们称之为函数 g o t o d i f f _s e ( 图 3-1 6b ) 。它 使用了 C 语言中的 go t o 语句， 这个语句类似于汇编代码中的无条件跳转 。使用 go t o 语句通常认 为是一种不好的编程风格， 因为它会使代码非</p></li></ol><p>e 实际上， 如果一个减法 溢出， 这个函数就会返回一 个负数值。 这里我们主要 是为了 展示机器代码， 而不 是实现代码的健壮性。</p><p>常难以阅 读和调试。本文中使用 goto 语句， 是为了 构造描述汇编代码程序控制流的 C 程序。我们称这样的编程风格 为 " g o t o 代码”。</p><p>在 g o t o 代码中（图3-166 ) , 第 5 行中的 go t o x_g e _y 语句会导致跳转到第 9 行中的标号 x_ge _ y 处（当x 娑y 时会进行跳转）。从这一点继续执行， 完成函数 a b s d i f f _ s e 的e l s e 部分并返回。另一方面， 如果测试 x >=y 失败， 程序会计算 a b s d i f f _ s e 的 江 部分指定的步骤并返回。</p><p>汇编代码的 实现（图3- l 6c ) 首先比较了两个 操作数（第2 行）， 设置条件码。如果 比较的结果表明 x 大千或者等 于 y , 那么它就会跳转到第 8 行， 增加全局变量 g e _ c n t , 计算 x</p><p>- y 作为返回 值并返回。由此我们可以 看到 a b s d i f f _s e 对应汇编代码的 控制流非 常类似于</p><p>g o t o d i f f —s e 的 g o t o 代码。</p><p>｝</p><p>return result;</p><p>｝</p><p>a ) 原始的C语言代码 b ) 与之等价的got o版本</p><p>long absdiff_se(long x, long y)</p><p>X 江 肚 di , y 立 肚s i</p><ol><li><p>absdiff_se:</p></li><li><p>cmpq %rsi, %rdi Compare x : y</p></li><li><p>jge .L2 If>= goto x_ge _y</p><p>4 addq $1, lt_cnt(%rip) lt_cnt++</p></li></ol><p>5 movq 。r儿</p><p>s i , %rax</p><p>6 subq %rdi, %rax result = y - x</p><p>7 ret Return</p><p>8 .L2: x_ge_y :</p><p>9 addq $1, ge_cnt Or 儿</p><ol><li><p>movq %rdi, %rax</p><p>i p) ge_cnt++</p></li><li><p>subq %rsi, %rax result= x - y</p></li><li><p>ret Return</p><p>c ) 产生的汇编代码</p><p>图 3-16 条 件 语 句 的 编 译 。 a)C 过程 abs di f f s e 包含一个 迂- e l se 语句 ； b)C 过程 got odif f _se</p><p>模拟了汇编代码的控制； c ) 给出了产生的汇编代码</p></li></ol><p>C 语言中的 江- e l s e 语旬的通用形式模板如下：</p><p>if (test-expr)</p><p>then-statement</p><p>else</p><p>else-statement</p><p>这里 test-e工 p r 是一个整数表达式 ，它 的 取 值 为 0 ( 解释为“假" )或者为非 0 ( 解释为“真" )。两个分 支语句 中 ( then-sta tement 或 else-sta tement ) 只会执行一个。</p><p>对于这种通用形式， 汇编实现通常会使用下面这种形式， 这里， 我们用 C 语法来描述控制流：</p><p>t = test-expr; if (!t)</p><p>goto false; then-statement goto done;</p><p>false:</p><p>else-statement done:</p><p>也就是 ， 汇编器为 the n-sta tement 和 else-sta tement 产生各自的代码块。它会插入条件和无条件分支，以保证能执行正确的代码块。</p><p>m 用 C 代码描述机器代码</p><p>图 3-1 6 给出 了 一个示例 ， 用 来展 示把 C 语言控 制 结构翻译成机 器代码。图 中 包括示例 的 C 函数 a 和由 GCC 生成 的汇编代码的 注释 版本 c , 还有一个与汇编代码结构高度一致的 C 语言版本 b。机 器代 码的 C 语言表 示有 助 于你理解其中的 关键 点 ， 能引导你理解实际的汇编代码。</p><p>江 练习题 3 . 16 已 知下列 C 代 码 ：</p><p>void cond(long a, long *p)</p><p>｛</p><p>if (p && a> *p)</p><p>*P = a;</p><p>｝</p><p>GCC 会产 生下 面的 汇编 代码 ： void cond(long a, long *p) a in %rdi, p in %rsi</p><p>cond:</p><p>testq %rsi, %rsi</p><p>je .Ll</p><p>cmpq %rdi, (%rsi)</p><p>jge .Ll</p><p>movq %rdi, (%rsi)</p><p>.Ll:</p><p>rep; ret</p><ol><li>按照 图 3-1 66 中所 示的 风格， 用 C 语言 写 一个 go to 版本， 执行 同 样的 计 算 ， 并模拟汇编代码的控制流。像示例中那样给汇编代码加上注解可能会有所帮助。</li><li>请说 明为什 么 C 语 言代码 中只有 一个 if 语 句 ， 而 汇编 代码包 含 两个 条件分支。</li></ol><p>让 练习题 3. 17 将 i f 语句 翻译成 go to 代码 的另 一种 可行 的 规则 如下：</p><p>t = test-expr;</p><p>if Ct)</p><p>goto true; else-statement goto done;</p><p>tr ue :</p><p>then-statement done :</p><ol><li>基于这种规则 ， 重 写 a b s d i f f _s e 的 go to 版本。<ol><li><p>你能想出选用一种规则而不选用另一种规则的理由吗？</p><p>已 练习题 3. 18 从如下形 式 的 C 语 言代码 开 始 ：</p><p>long test(long x, long y, long z) { long val = ;</p><p>if () {</p><p>if () val=</p><p>else</p><p>val=</p><p>} else if ()</p><p>val= return val;</p><p>｝</p><p>GCC产 生 如 下的 汇编代码 ：</p><p>long test (long x, long y, long z)</p><p>x in %rdi, y i n r¼ si , z i n %rdx test:</p><p>leaq (%rdi,%rsi), %rax addq %rdx, %rax</p><p>cmpq $-3, o/.rdi</p><p>jge .L2</p><p>cmpq %rdx, %rsi</p><p>jge .L3</p><p>movq %rdi, %rax imulq %rsi, %rax ret</p><p>.L3:</p><p>movq %rsi, %rax imulq %rdx, %rax ret</p><p>.L2:</p><p>cmpq $2, %rdi</p><p>jle .14</p><p>movq %rdi, %rax imulq %rdx, %rax</p><p>.14:</p><p>rep; ret</p></li></ol></li></ol><p>填写 C 代码 中缺 失的表 达 式 。</p><ol><li><p>6. 6 用条件传送来实现条件分支</p><p>实现条件操 作的传统方法是通过使用 控制的条件转移 。当条件满足时， 程序沿 着一条执行路 径执行， 而当条 件不满足时 ， 就走另 一条路径。这种 机制简单而通用 ， 但是 在现代处理器上 ， 它可能 会非常低效。</p><p>一种替 代的 策略是使用 数据的条 件转移 。这种方法计算 一个条件操作的两种结果 ， 然后再根据条件是否满足从中选取一个。只有在一些受限制的情况中，这种策略才可行，但 是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理 器的性能特性 。我们 将介绍 这一策略 ， 以及它在 x8 6-64 上的实现。</p><p>图 3- l 7a 给出了一 个可以用条件传送编译的 示例代码。这个函数计算参数 x 和 y 差的绝对值 ， 和前面的例子一样（图3-1 6 ) 。不过前面的例子中， 分支里有副作用， 会修改 lt</p><p>cnt 或 g e _ c n t 的值， 而这个 版本只是简单地计算 函数要返 回的值。</p><p>GCC 为该 函数产生 的 汇 编代 码 如图 3- l 7c 所 示， 它与图 3-1 76 中所 示 的 C 函数cmovdif f 有相似的形式。研究 这个 C 版本 ， 我们可以 看到它既计算了 y- x , 也计算了 x - y , 分别命名为 r va l 和 e va l 。然后 它再测试 x 是否大于等千 y , 如果 是， 就在函数返回r va l 前，将 e va l 复制到r v a l 中。图 3-l 7c 中的汇编代码有相同的逻辑 。关键就在千汇编代码的那条cmovge 指令（第7 行）实现了cmovd i ff 的条件赋值（第8 行）。只有当第6 行的 cmpq 指令表明一 个值大于等于另一 个值（正如后缀ge 表明的那样）时， 才会把数据源寄存器传送到目的 。</p></li></ol><p>long absdiff(long x, long y)</p><p>｛</p><p>long result; if (x &lt; y)</p><p>result= y - x;</p><p>else</p><p>result= x - y; return result;</p><p>｝</p><p>long cmovdiff(long x, long y)</p><p>2 {</p><p>3 long rval = y-x;</p><p>4 long eval = x-y;</p><p>5 long ntest = x >= y;</p><p>6 I* Line below requires</p><p>7 single instruction: *I</p><p>8 if (ntest) rval = eval;</p><p>9 return rval;</p><p>10 }</p><p>a ) 原始的C语言代码 b ) 使用条件赋值的实现</p><table><thead><tr><th>1</th><th>abs di ff :</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>2</td><td>movq</td><td>%rsi,</td><td>%rax</td><td></td></tr><tr><td>3</td><td>subq</td><td>%rdi,</td><td>1r儿 ax rval = y-x</td><td></td></tr><tr><td>4</td><td>movq</td><td>%rdi,</td><td>%rdx</td><td></td></tr><tr><td>5</td><td>subq</td><td>%rsi,</td><td>ir儿 dx</td><td>eval = x- y</td></tr><tr><td>6</td><td>cmpq</td><td>%rsi,</td><td>%rdi</td><td>Compare xy.</td></tr><tr><td>7</td><td>crnovge</td><td>%rdx,</td><td>%rax</td><td>If >=, rval = eval</td></tr><tr><td>8</td><td>ret</td><td></td><td></td><td>Return tval</td></tr></tbody></table><p>C ) 产生的汇编代码</p><p>图 3-17 使用 条件赋值的条件语句的 编译。a)C 函数 absd if f 包 含一个条件表达式 ；</p><p>b)C 函数 cmo vdi f f 模 拟 汇编代码操作； c) 给出产生的 汇编代码</p><p>为了理解为什么基于条件 数据传送的 代码会比基千条 件控制转移的代码（如图 3-16 中那样）性能要好 ， 我们必须 了解一些关于现代处理器如何运行的知识。正如我们将在第 4 章 和第 5 章中看到的 ， 处理器通过使用 流水线 ( pipelining ) 来获得高性能 ， 在流水线中 ， 一条指令的 处理要经过一 系列的阶段， 每个阶段执行所需操作的一小部分（例如， 从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数 器）。这种方法通过重叠连续指令的步骤来获得高性能，例如，在取一条指令的同时，执 行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行的指令序列，这 样才能保持流水线中充满了待执行的指令。当机器遇到条件跳转（也称为“分支")时，只 有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的分支预测逻 辑来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠（现代微处理器设计试图达 到 90 % 以上的成功 率）， 指令流水线中就会充满着指令。另一方面， 错误预测一个跳转， 要求处理器丢掉它为该跳转指令后所有指令己做的工作，然后再开始用从正确位置处起始 的指令去填充流水线。正如我们会看到的，这样一个错误预测会招致很严重的惩罚，浪费 大约 15 ~ 30 个时钟周期 ， 导致程序性能 严重下降 。</p><p>作为一 个示例 ， 我们在 In tel H aswe ll 处理器上运行 a bs d if f 函数， 用两种方 法来实现条件操作。在一个典型的应用 中， x &lt; y 的结果非常地不可预测 ， 因此即使是最 精密 的分支预测硬件也 只能有大约 50 % 的概率 猜对。此外 ， 两个代码 序列中的 计算执行都只需 要一个时钟周期。因此，分支预测错误处罚主导着这个函数的性能。对千包含条件跳转的 x86-64 代码， 我们 发现当分 支行为模式 很容易预测时 ， 每次调用函数需要大约 8 个时钟周期； 而分支行为模式 是随机的时 候， 每次调用需 要大约 1 7. 50 个时钟周期。由此我们可以推断出分 支预测错误 的处罚是大约 19 个时钟周期。这就意味着函数需要的时间范围大约在 8 到 27 个周期 之间， 这依赖于分支预测是 否正确。</p><p>田 如何 确定分支预测错误的 处罚</p><p>假设预测错误 的概率是 p , 如果没有 预测错 误， 执行代码的 时间是 T oK , 而预测错误的处罚是 T MP 。 那 么， 作为 p 的一个函数 ， 执行代码的平 均 时间 是 T ,v. C p ) = (l - p ) ToK + P (T oK + T MP) = T oK +PT MP 。 如果已知 T oK 和 T ,."( 当 p = O. 5 时的 平 均 时间）， 要确定 T MP 。 将参数代入等式， 我们有 T can = Tavg (0. 5) = ToK + 0. 5T MP , 所以 有 T MP = 2 (Tran - T OK) 。 因此 ， 对于 T oK= 8 和 T can= l 7. 5, 我们有 T MP= l 9。</p><p>另一方面，无论测试的数据是什么，编译出来使用条件传送的代码所需的时间都是大 约 8 个时钟周期 。控制流不 依赖于数据， 这使得处理器更容易 保持流水线是 满的 。</p><p>; 练习题 3. 19 在 一个比较旧的处 理器模 型上运 行， 当 分 支行 为模 式非常 可预测 时，我们的代码需要大约 1 6 个时钟周期 ， 而当模 式是随机 的时候 ， 需要大约 31 个时钟周期。</p><ol><li>预测错误处罚大约是多少？<ol><li><p>当分支预测错误时，这个函数需要多少个时钟周期？</p><p>图 3-18 列举了 x86- 64 上一些 可用的 条件传送指令。每条指 令都有两个操作数： 源寄存器或者内存地址 S , 和目的 寄存器 R。与不同的 SET (3. 6. 2 节）和跳转指令( 3. 6. 3 节） 一样，这些指令的结果取决千条件码的值。源值可以从内存或者源寄存器中读取，但是只 有在指定 的条件满 足时 ， 才会被复 制到目的 寄存 器中。</p><p>源和目的的值可以是 16 位、32 位或 64 位长。不支持单字节的条件传送。无条件指令的操作数的长度显式地编码在指令名中（例如movw 和 mov U , 汇编器可以从目标寄存器的名字推断</p></li></ol></li></ol><p>出条件传送指令的操作数长度，所以对所有的操作数长度，都可以使用同一个的指令名字。</p><table><thead><tr><th>指令</th><th>同义名</th><th>传送条件</th><th>描述</th><th></th></tr></thead><tbody><tr><td>cmove cmovne</td><td>S,R S,R</td><td>cmovz cmovnz</td><td>ZF -ZF</td><td>相等／零 不相等／非零</td></tr><tr><td>cmovs cmovns</td><td>S,R S,R</td><td></td><td>SF -SF</td><td>负 数 非负数</td></tr><tr><td>cmovg cmovge cmovl cmovle</td><td>S,R S,R S,R S,R</td><td>cmovnle cmovnl cmovnge cmovng</td><td>-(SF~ OF) & -ZF -(SF- OF) SF~ OF (SF~ OF) I ZF</td><td>大于（有符号＞） 大于或等于（有符号＞＝） 小千（有符号＜） 小于或等千（有符号＜＝）</td></tr><tr><td>cmova cmovae cmovb cmovbe</td><td>S,R S,R S , R S,R</td><td>crnovnbe crnovnb cmovnae cmovna</td><td>~CF & ~ZF ~CF CF CF I ZF</td><td>超过（无符号＞） 超过或相等（ 无符号＞＝） 低于（无符号＜） 低于或相等（无符号＜＝）</td></tr></tbody></table><p>图 3-18 条件传送指令。当传送条件满足时 ，指 令 把 源值 S 复制到目的 R 。有些指令是“同义名＂，即同一条机器指令的不同名字</p><p>同条件跳转不同，处理器无需预测测试的结果就可以执行条件传送。处理器只是读源值（可能是从内存 中）， 检查条 件码， 然后要 么更新目的寄存器， 要么保持不变。我们会在第 4 章中探讨条件传送的 实现。</p><p>为了理解如何通过条件数据传输来实现条件操作，考虑下面的条件表达式和赋值的通 用形式：</p><p>v = test-expr ? then-expr : else-expr;</p><p>用条件控制转移的标准方法来编译这个表达式会得到如下形式：</p><p>if (! test-expr)</p><p>goto false; v = then-expr; goto done;</p><p>false:</p><p>v = else-expr; done:</p><p>这段代码包含两个代码 序列 ： 一个对 then-ex p r 求值， 另一个对 els e-ex p r 求值。条件跳转和无条件跳转结合起来使用是为了保证只有一个序列执行。</p><p>基于条 件传送的代码 ， 会对 the n-ex p r 和 else-ex p r 都求值， 最终值的选择 基于对 test­</p><p>ex pr 的求值。可以用下面的抽象代码描述：</p><p>v = then-expr; ve = else-expr; t = test-expr; if (!t) v = ve;</p><p>这个序列中的最后一条语旬是用条件传送实现的 只有当测试条件 t 满足时， v t 的值才会被复制到 v 中。</p><p>不是所有的条件表达式都可以用条件传送来编译。最重要的是，无论测试结果如何，</p><p>我们 给出的 抽象代码会对 th en-ex p r 和 else-ex p r 都求值。如果这两个表达式 中的任意一个可能 产生错误条件或者副作用 ， 就会导 致非法的行 为。前 面的一 个例子（图3-16 ) 就是这种情况。实际 上， 我们在该 例中引 入副作用就是 为了强 制 GCC 用条件转移来实 现这个函数。</p><p>作为说明 ， 考虑下面这个 C 函数：</p><p>long cread(long *xp) { return (xp? *xp : O);</p><p>乍一 看， 这段代码似乎很适 合被编译成使 用条件传送 ， 当指针为空时 将结果设置为 o,</p><p>如下面的汇编代码所示：</p><p>long cread(long•xp)</p><p>Invalid implementation of function cread</p><p>xp 工n register %r d工cread:</p><table><thead><tr><th>movq</th><th>(%rdi), %rax</th><th>V = *Xp</th></tr></thead><tbody><tr><td>testq</td><td>%rdi, %rdi</td><td>Test x</td></tr><tr><td>movl</td><td>$0, %edx</td><td>Set ve = 0</td></tr><tr><td>cmove ret</td><td>%rdx, %rax</td><td>If x ==O, v = ve Return v</td></tr></tbody></table><p>不过， 这个 实现是非 法的 ， 因为即使 当测试 为假时 ， mo v q 指令（第2 行）对x p 的间接引用还是发生了 ， 导致一个间接引 用空指针的错误。所以， 必须用分支代码来 编译这段代码。</p><p>使用条件传送也不 总是会提高 代码的效 率。例如， 如果 th en-ex p r 或者 else-ex p r 的求值需要大量的计算， 那么当相对应的 条件不满 足时 ， 这些工 作就白费了。编译器必须 考虑浪费的 计算和由于分支预测错 误所造成的性能处罚 之间的相对性能。说实话 ， 编译器并不具有足够的信息来做出 可靠的决定； 例如， 它们不知道分支会多好地遵循可预测 的模式。我们对 GCC 的实验表明 ， 只有当两个表达式 都很容易 计算时， 例如表达式 分别都只是一条加法指令，它才会使用条件传送。根据我们的经验，即使许多分支预测错误的开销会超 过更复杂的计算， GCC 还是 会使用条件控制转移 。</p><p>所以，总的来说，条件数据传送提供了一种用条件控制转移来实现条件操作的替代策略。它们只能用于非常受限制的清况，但是这些情况还是相当常见的，而且与现代处理器的运行方式更契合。</p><p>亡 练习题 3. 20 在下 面的 C 函数 中 ， 我们对 OP 操作的定 义是 不 完整的 ：</p><p>#define OP _ I* Unknown operator *I</p><p>long arith(long x) { return x OP 8;</p><p>｝</p><p>当编译时， GCC 会产 生如下 汇编代 码 ：</p><p>long arith(long x) x in %r d 工</p><p>arith:</p><p>leaq testq cmovns sarq ret</p><p>7(%rdi), %rax</p><p>%rdi, %rdi</p><p>%rdi, %rax</p><p>$3, %rax</p><ol><li><p>OP 进行 的是 什 么操作？</p></li><li><p>给代码 添加注释 ， 解释 它是 如何工作的。讫§ 练习题 3. 21 C 代码 开始的形 式如下 ：</p><p>long test(long x, long y) { long val = ;</p><p>if () {</p><p>if ()</p><p>val=</p><p>else</p><p>val= _—;</p><p>} else if ()</p><p>val= return val;</p><p>｝</p><p>GCC 会产 生如下 汇编代码 ：</p><p>long test(long x, long y) x in %rdi , y in %rsi</p><p>test:</p><p>leaq O(,%rdi,8), %rax testq %rsi, %rsi</p><p>jle .L2</p><p>movq %rsi, %rax</p><p>subq %rdi, %rax</p><p>movq %rdi, %rdx</p><p>andq %rsi, %rdx</p><p>cmpq %rsi, %rdi cmovge %rdx, %rax ret</p><p>,L2:</p><p>addq %rsi, %rdi</p><p>cmpq $-2, %rsi cmovle %rdi, %rax ret</p><p>填补 C 代码 中缺 失的 表达 式。</p></li><li><p>7 循环</p><p>C 语言提供了多种循环结构， 即 d o - wh i l e 、 wh i l e 和 f o r 。汇编中没有相应的指令存在， 可以用条件测试 和跳转组 合起来实现循环的效果。GCC 和其他汇编器产生的循环代码主要 基于两种基本的 循环模式 。我们会循 序渐进地研究循环的 翻译 ，从 d o - wh i l e 开始，然后再研究具有更复杂实现的循环，并覆盖这两种模式。</p><ol><li><p>d o - wh i l e 循环</p><p>do - wh i l e 语句的通用形式 如下 ：</p><p>do</p><p>body-statement while (test-expr);</p><p>这个循环 的效果就是重复执行 body sta tement , 对 test-ex pr 求值， 如果求值的结果为非</p></li></ol></li></ol><p>零， 就继续循环。可以 看到 ， bod y-sta tement 至少会 执行一次。这种通用形式可以被翻译 成如下所示的条 件和 g o t o 语句： loop:</p><p>body-statement</p><p>t = test-expr;</p><p>if (t)</p><p>goto loop;</p><p>也就是说，每次循环，程序会执行循环体里的语句，然后执行测试表达式。如果测试为 真， 就回去再执行一次循环。</p><p>看一个示例 ， 图 3-19a 给出了一 个函数的实现， 用 d o - wh i l e 循环来计算函数参 数的阶乘， 写作 n ! 。这个函数只计算 n > 0 时 n 的阶乘的值。</p><p>亡 练习题 3. 22</p><ol><li>用 一个 32 位 i n t 表 示 n !&rsquo; 最 大的 n 的值 是 多少？<ol><li><p>如果 用 一个 64 位 l o ng 表 示，最大的 n 的值 是 多少？</p><p>图 3-196 所示的 goto 代码展示了如何把循环变成低级的测试和条件跳转的组合。 r e s ul t 初始化之后 ， 程序开始循环。首先执行循环体 ， 包括更新变量r e s u止 和 n。然后测试 1&rsquo;!> 1 , 如果是真 ， 跳转到循环开始处。图 3-19c 所示的汇编代码就是 goto 代码的原型。条件跳转指令 j g ( 第 7 行）是实现循环的关键指令， 它决定了是需要继续重复还是退出循环。</p></li></ol></li></ol><p>long fact_do(long n)</p><p>｛</p><p>long result = 1; do {</p><p>result*= n; n = n-1;</p><p>} while (n > 1); return result;</p><p>｝</p><p>long fact_do_goto(long n)</p><p>｛</p><p>long result = 1; loop:</p><p>result*= n; n = n-1;</p><p>if (n > 1)</p><p>goto loop; return result;</p><p>｝</p><ol><li>C代码 b ) 等价的go七o版本</li></ol><table><thead><tr><th>1</th><th>long fact_do(long n) n in %rdi fact_do:</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>2</td><td>movl $1, %eax</td><td>Set result 1</td><td></td><td></td></tr><tr><td>3</td><td>.12:</td><td>l oop:</td><td></td><td></td></tr><tr><td>4</td><td>imulq</td><td></td><td>%rdi, %rax</td><td>Compute result *= n</td></tr><tr><td>5</td><td>subq</td><td></td><td>$1, %rdi</td><td>Decrement n</td></tr><tr><td>6</td><td>cmpq</td><td></td><td>$1, %rdi</td><td>Compare n: 1</td></tr><tr><td>7</td><td>jg</td><td></td><td>.L2</td><td>If>, goto l oop</td></tr><tr><td>8</td><td>rep;</td><td>ret</td><td></td><td>Return</td></tr></tbody></table><p>C ) 对应的汇编代码</p><p>佟I 3- 1 9 阶 乘 程序的 do- whi l e 版本的代码。条件跳转会使得程序循环</p><p>逆向工程像图 3-19c 中那样的汇编代码 ，需 要确定 哪个寄存器对应的是 哪个程序值 。本例中， 这个对应 关系很容易确定 ： 我们知道 n 在寄存 器%r d i 中传递给函数。可以 看到寄存器%r ax 初始化为 1 ( 第 2 行）。（注意， 虽然指令的目 的寄存 器是 %e a x , 它实际上还会 把%r a x 的高 4 字节设 置为 0。)还可以看到这个寄存器还会在第 4 行被乘法改变值。此外，%r a x 用来返回函数值 ， 所以通常会用来存放需要返回的程 序值。因此我们断定%r ax 对应程序值r e s ul t 。</p><p>练习题 3. 23 已 知 C 代 码 如下 ：</p><p>long dw_loop(long x) { long y = x*x;</p><p>long *P = &amp;x; long n = 2*x; do {</p><p>X += y;</p><p>(*p)++;</p><p>n&ndash;;</p><p>} while (n > 0); return x;</p><p>｝</p><p>GCC 产 生的 汇编代码 如下：</p><p>long d w_l oop(l ong x) x initially in %rdi dw_loop:</p><table><thead><tr><th>2</th><th>movq</th><th>%rdi, %rax</th></tr></thead><tbody><tr><td>3</td><td>movq</td><td>%rdi, %rcx</td></tr><tr><td>4</td><td>imulq</td><td>%rdi, %rcx</td></tr><tr><td>5</td><td>leaq</td><td>(%rdi,%rdi), %rdx</td></tr><tr><td>6</td><td>. L2:</td><td></td></tr><tr><td>7</td><td>leaq</td><td>1(%rcx,%rax), %rax</td></tr><tr><td>8</td><td>subq</td><td>$1, %rdx</td></tr><tr><td>9</td><td>testq</td><td>%rdx, 1r儿 dx</td></tr><tr><td>10</td><td>jg</td><td>.L2</td></tr><tr><td>11</td><td>rep; ret</td><td></td></tr></tbody></table><ol><li><p>哪 些寄 存器用来存 放程序值 x、 y 和 n?</p></li><li><p>编译器 如何 消 除对指 针 变 量 p 和表达 式 ( *p ) ++ 隐含的指针 间 接引用的 需求？</p></li><li><p>对 汇编 代码 添加 一些注释 ， 描述 程序的 操作 ， 类似于 图 3-1 9c 中所 示的 那样。</p><p>m 逆向 工程循环</p><p>理解产生的汇编代码与原始沌代码之间的关系，关键是找到程序值和寄存器之间的 映射 关 系。 对于图 3-1 9 的循 环 来说 ， 这个任 务非 常 简 单， 但是对于更 复杂的 程序来说 ， 就可能是 更具挑战性 的任务。C 语言编译 器常常 会重组 计算， 因此 有些 C 代码中的 变量在机器代码中没有对应的值；而有时，机器代码中又会引入源代码中不存在的新值。此 外，编译器还常常试图将多个程序值映射到一个寄存器上，来最小化寄存器的使用率。</p><p>我们描 述 f a c t _d o 的过程对于逆 向工程循 环 来说 ， 是一 个通 用的 策略 。 看 看在循环之前如何初始化寄存器，在循环中如何更新和测试寄存器，以及在循环之后又如何使 用寄存器。这些步骤中的每一步都提供了一个线索，组合起来就可以解开谜团。做好准</p></li></ol><p>备，你会看到令人惊奇的变换，其中有些情况很明显是编译器能够优化代码，而有些情 况很 难解释编译 器 为 什 么要 选用 那些奇怪的 策略。根 据我们的 经验 ， G CC 常 常做 的一些变换，非但不能带来性能好处，反而甚至可能降低代码性能。</p><ol><li><p>while 循环</p><p>wh i l e 语 句 的 通用 形 式如下：</p><p>while (test-expr) body-statement</p><p>与 d o- wh i l e 的 不 同 之 处 在 于， 在 第 一 次 执 行 bod y-s ta tem ent 之 前， 它 会 对 tes t- expr 求值 ， 循 环 有 可 能就中 止 了。 有很 多 种 方 法 将 wh i l e 循 环 翻 译成 机器代 码 ， G CC 在代 码生成 中使 用 其 中 的 两种 方 法。 这 两种 方 法使 用 同 样的 循 环结构， 与 d o - wh i l e 一 样， 不 过 它们实现初始测试的方法不同。</p><p>第 一种 翻译方 法 ， 我 们 称之 为 跳 转 到 中 间 ( jum p to middle), 它执行一个无条件跳转跳到 循 环结尾处 的 测试， 以 此来 执行初始的 测 试。 可 以用 以下模板来 表 达这种 方 法 ， 这个模板把 通用 的 wh i l e 循 环格 式 翻译 到 g o t o 代码 ：</p><p>goto test; loop:</p><p>body-statement test:</p><p>t = test-expr;</p><p>if (t)</p><p>goto loop;</p></li></ol><p>作为 一个 示 例 ， 图 3- 20a 给 出 了使用 wh i l e 循 环的 阶 乘 函 数 的 实 现。这个 函 数 能 够 正确地 计算 0 ! = l 。 它 旁 边的 函 数 f a c t _ wh i l e _ j m_g o t o ( 图 3-20 b ) 是 GCC 带优 化命令行选项-Og 时产 生的 汇编 代码 的 C 语言翻译。 比 较 f a c 七_wh il e ( 图 3-20 b) 和 f a c 七_ d o ( 图 3- l 9b) 的代码 ， 可 以 看到 它们 非 常 相 似 ， 区 别 仅在 于 循 环 前 的 g o t o t e s t 语 句 使得 程 序 在 修 改 r e s u l t 或 n 的值之前， 先执行对 n 的 测 试。 图 的 最下 面（图 3- 20c) 给出 的是 实际产 生 的 汇编代码。</p><p>立 练习题 3. 24 对于如下 C 代 码 ：</p><p>long loop_while(long a, long b)</p><p>｛</p><p>long result = ; while () {</p><p>result= ，</p><p>a = ，</p><p>｝</p><p>return result;</p><p>｝</p><p>以命令行选项 - Og 运行 GCC 产 生 如下代码 ：</p><p>long l oop _ w 加 l e (l ong a, long b) a in %rdi, b i n %rsi loop_while:</p><table><thead><tr><th>2</th><th>movl</th><th>$1, %eax</th></tr></thead><tbody><tr><td>3</td><td>jmp</td><td>.L2</td></tr></tbody></table><p>4 .L3:</p><ol><li><p>leaq (%rdi,%rsi), %rdx</p></li><li><p>imulq %rdx, %rax</p></li><li><p>addq $1, %rdi</p><p>8 . L2 :</p></li><li><p>cmpq %rsi, %rdi</p></li><li><p>jl .L3</p><p>11 rep; ret</p></li></ol><p>可以 看到 编译器使用 了 跳 转 到 中 间 的 翻 译 方 法 ， 在 第 3 行用 jm p 跳 转 到 以 标 号</p><ol><li>2 开始的 测试。填写 C 代码 中缺失的部分。</li></ol><p>long fact_while(long n)</p><p>｛</p><p>long result= 1; while (n > 1) {</p><p>result*= n; n = n-1;</p><p>｝</p><p>return result;</p><p>｝</p><p>long fact_while_jm_goto(long n)</p><p>｛</p><p>long result = 1; goto test;</p><p>loop:</p><p>result*= n; n = n-1;</p><p>test:</p><p>if (n > 1)</p><p>goto loop; return result;</p><p>｝</p><ol><li>C代码 b ) 等价的goto版本</li></ol><p>long f act _ w 加 l e ( l ong n)</p><p>n 工 n %rdi fact_while:</p><p>movl $1, %eax</p><p>jmp .L5</p><p>.L6:</p><p>Set result 1 Goto test</p><p>l oop:</p><p>imulq %rdi, %rax Compute result *= n subq $1, %rdi Decrement n</p><p>.15: t es t :</p><p>cmpq $1 , %rdi Compare n: 1</p><p>jg .16 If >, goto loop</p><p>rep; ret Return</p><p>C ) 对应的汇编代码</p><p>图 3-20 使用跳转到中间 翻译方法的 阶乘算 法的 whi l e 版本的 C 代码和汇编代 码。</p><p>C 函数 f ac t _whi l e_ j m_g ot o 说明了汇编代码 版本的操作</p><p>第二种翻译 方法 ， 我们称之为 g ua r d ed-d o , 首先用条件分支，如果初始条件不成立就跳过循 环， 把代码变换为 d o - wh i l e 循 环 。 当使用较高优化等级编译时，例 如 使 用 命 令 行选项 - 0 1 , GCC 会采用这种策略。可以用如下模板来表达这种方法， 把通用的 wh i l e 循 环</p><p>格式翻译 成 d o - wh i l e 循 环 ：</p><p>t = test-expr;</p><p>if (!t)</p><p>goto done;</p><p>do</p><p>body-statement while (test-expr) ;</p><p>done:</p><p>相应地， 还可以把它翻译 成 go to 代码如下：</p><p>t = test-expr;</p><p>if (! t)</p><p>goto done; loop:</p><p>body-statement</p><p>t = test-expr;</p><p>if (t)</p><p>goto loop;</p><p>done:</p><p>利用这种实现策略 ， 编译器常常可以 优化初始的测试，例 如 认 为测试条件总是满足。</p><p>再来看 个 例 子，图 3 - 21 给出了图 3- 20 所示阶乘函数同样的 C 代码， 不 过给出的是</p><p>GCC 使用命令行选项- 01 时的编译。图 3-2 l c 给出实际生成的汇编代码，图 3 - 21 b 是这个汇编代码更易读的 C 语言表示。根据 goto 代码， 可以看到如果对千 n 的初始值有 n l, 那 么将跳过该循环。该循环本身的基本结构与该函数 d o - wh 工l e 版 本 产 生的结构（图3-19 ) 一样。不过，一 个 有趣的特性是，循 环测试（汇编代码的第 9 行）从 原 始 C 代码的 n > l 变成 了 n =I= 1 。 编译器知道只有当 n> l 时才会进入循环， 所以将 n 减 1 意味着 n > l 或者 n =</p><p>1 。因此 ，测 试 n =I= l 就 等价于测试 n l 。</p><p>long fact_while(long n)</p><p>｛</p><p>long result = 1; while (n > 1) {</p><p>result*= n; n = n-1;</p><p>｝</p><p>return result;</p><p>｝</p><p>long f act _wh辽 e _gd_got o ( l ong n)</p><p>｛</p><p>long result = 1;</p><p>if (n &lt;= 1)</p><p>goto done;</p><p>loop:</p><p>result*= n; n = n-1;</p><p>if (n != 1)</p><p>goto loop;</p><p>done:</p><p>return result;</p><p>｝</p><ol><li>C代码 b ) 等价的goto版本</li></ol><p>图 3-21 使用 guarded -do 翻译方法的 阶乘算法的 whil e 版本的 C 代码和汇编代 码。函数 f act _whi l e_gd_got o 说明 了汇编代 码版本的 操作</p><p>long f act _whi l e (l ong n) n in %rdi</p><p>fact_while:</p><p>cmpq $1 , %rdi</p><p>jle .17</p><p>movl $1, %eax</p><p>.16:</p><p>Compare n:1 If&lt;=, goto done Set result= 1</p><p>loop:</p><p>imulq subq cmpq jne rep;</p><p>.17:</p><p>movl ret</p><p>ret</p><p>%rdi, ;儿r ax</p><p>$1, %rdi</p><p>$1, %rdi</p><p>.L6</p><p>$1, %eax</p><p>Compute result *= n Decrement n</p><p>Compare n:1 If!=, goto loop Return</p><p>done:</p><p>Compute result = 1 Return</p><p>练习题 3. 25 对 于如下 C 代码 ：</p><p>C ) 对应的汇编代码</p><p>图 3-21 （续）</p><p>long loop_while2(long a, long b)</p><p>｛</p><p>long result = ; while () {</p><p>result=</p><p>b =</p><p>｝</p><p>return result;</p><p>｝</p><p>以命 令行选项 - 0 1 运行 GCC , 产生如下代码：</p><p>a in %rdi , b in %rsi loop_while2:</p><p>testq %rsi, %rsi jle .L8</p><p>movq %rsi, %rax</p><p>.L7:</p><p>imulq %rdi,</p><p>subq %rdi,</p><p>testq %rsi,</p><p>jg .L7</p><p>rep; ret</p><p>.L8:</p><p>%rax</p><p>%rsi</p><p>%rsi</p><p>movq ret</p><p>%rsi, %rax</p><p>可以看到编译 器使用 了 guard e d- do 的翻译 方法 ， 在第 3 行使用了 j l e 指令使得当初 始测试不成 立时 ， 忽略循环代 码。 填写缺 失的 C 代码。 注意 汇编 语言中的 控制结构 不 一定 与根据翻译规则 直接 翻译 C 代码得 到的 完全 一致。 特别 地， 它有 两个 不同的r e t 指令（第10 行和第 13 行）。不过 ， 你可以根 据等价的 汇编代码 行为填写 C 代码中缺 失的部分。</p><p>让 练习题 3. 26 函数 f un_a 有如下 整体 结构 ：</p><p>long fun_a(unsigned long x) { long val= O;</p><p>while (&mldr;) {</p><p>｝</p><p>return &mldr; ;</p><p>｝</p><p>GCC C 编译器 产 生如 下 汇编 代码 ：</p><p>long f un _a ( unsi gned long x) x in¼rdi</p><p>fun_a:</p><table><thead><tr><th>2</th><th>movl</th><th>$0, %eax</th><th></th></tr></thead><tbody><tr><td>3</td><td>jmp</td><td>.LS</td><td></td></tr><tr><td>4</td><td>.L6:</td><td></td><td></td></tr><tr><td>5</td><td>xorq</td><td>%rdi, %rax</td><td></td></tr><tr><td>6</td><td>shrq</td><td>%rdi</td><td>Shift right by 1</td></tr><tr><td>7</td><td>.LS:</td><td></td><td></td></tr><tr><td>8</td><td>testq</td><td>%rdi, %rdi</td><td></td></tr><tr><td>9</td><td>jne</td><td>.L6</td><td></td></tr><tr><td>10</td><td>andl</td><td>$1, %eax</td><td></td></tr><tr><td>11</td><td>ret</td><td></td><td></td></tr></tbody></table><p>逆向工程这段代码的操作，然后宪成下面作业：</p><ol><li>确定这段代码使用的循环翻译方法。</li><li>根据 汇编 代码版本填 写 C 代码 中缺 失的部分。</li><li>用 自 然语 言描述这 个函 数是 计算 什 么的 。<ol><li><p>for 循环</p><p>for 循环的通用形式如下 ：</p><p>for (init-expr; test-expr; update-expr) body-statement</p><p>C 语言标准说明（有一个例外， 练习题 3. 29 中有特别说明）， 这样一个循环的行为与下面这段使 用 wh il e 循环的 代码的 行为一样：</p><p>init-expr;</p><p>while (test-expr) { body-statement update-exp,;</p><p>｝</p><p>程序 首先对初始表达式 init-ex pr 求值， 然后 进入循环 ； 在循环 中它先对测试 条件 test 飞 x pr 求值， 如果测试结果为“ 假” 就会退出， 否则执行循环体 bod :r sta tement ; 最后对更新表达式 up d a te-ex pr 求值。</p><p>GCC 为 f o r 循环产生 的代码是 wh i l e 循环的两种翻译 之一， 这取决于优化的等级。也就是， 跳转到 中间策略 会得到如下 go to 代码：</p><p>init-expr; goto test;</p></li></ol></li></ol><p>loop:</p><p>body-statement update-expr;</p><p>test:</p><p>t = test-expr; if (t)</p><p>goto loop;</p><p>而 gua rded-do 策略得到 ：</p><p>init-expr;</p><p>t = test-expr; if (! t)</p><p>goto done;</p><p>l oop :</p><p>body-statement update-expr;</p><p>t = test-expr;</p><p>if (t)</p><p>goto loop;</p><p>done:</p><p>作为一个 示例 ， 考虑用 f or 循环写的 阶乘函数：</p><p>long fact_for(long n)</p><p>long i;</p><p>long result = 1;</p><p>for (i = 2; i &lt;= n; i++) result*= i;</p><p>return result;</p><p>如上述代码所示 ， 用 f o r 循环编写阶乘函数最自然的 方式就是将从 2 一直到 n 的因子乘起来 ， 因此， 这个 函数与我们使用 wh il e 或者 d o - wh il e 循环的代码很不一 样。</p><p>这段代码中的 f or 循环的不同 组成部分 如下 ：</p><p>init-expr i = 2</p><p>test-expr i &lt;= n</p><p>update-expr i ++</p><p>body-statement result *= i;</p><p>用这些部分替换前面给出的 模板中相应 的位置， 就把 f or 循环转换成了 wh i l e 循环， 得到下面的代码：</p><p>long fact_for_while(long n)</p><p>｛</p><p>long i = 2;</p><p>long result = 1; while (i &lt;= n) { result*= i;</p><p>i++;</p><p>｝</p><p>return result;</p><p>｝</p><p>对 wh i l e 循环进行跳转到中间 变换 ， 得到如下 g o to 代码 ：</p><p>long fact_for_jrn_goto(long n)</p><p>｛</p><p>long i = 2;</p><p>long result= 1; goto test;</p><p>loop:</p><p>result*= i;</p><p>i++;</p><p>test:</p><p>if (i &lt;= n)</p><p>goto loop; return result;</p><p>确实， 仔细查看使用命令行选项&ndash;Og 的 GCC 产生的汇编代码， 会发现它非常接近于以下模板：</p><p>long fact_for(long n) n in¼rdi</p><p>fact_for:</p><p>movl movl jmp</p><p>.19:</p><p>imulq addq</p><p>.18:</p><p>cmpq jle rep;</p><p>ret</p><p>$1, %eax</p><p>$2, %edx</p><p>.L8</p><p>%rdx, %rax</p><p>$1, %rdx</p><p>%rdi, %rdx</p><p>.L9</p><p>Set result= 1</p><p>Seti= 2</p><p>Goto test loop:</p><p>Computer es ul t *= 工</p><p>Increment i test:</p><p>Compare i : n If&lt;=, goto loop Return</p><p>; 练习题 3. 27 先 把 f a c t —f or 转 换 成 wh i l e 循 环 ， 再 进 行 g ua rd ed- do 变 换， 写出</p><p>f a c t _ f o r 的 g o t o 代码。</p><p>综上所述 ， C 语言中三种形式的 所有的 循环 d o - wh i l e 、 wh i l e 和 f o r 都可以用一种简单的策略来翻译，产生包含一个或多个条件分支的代码。控制的条件转移提供了 将循环翻译成机器代码的基本机制。</p><p>江 义 练习题 3. 28 函 数 f u n—b 有如下整体结 构：</p><p>long fun_b(unsigned long x) { long val= O;</p><p>long i;</p><p>for (. . . ; . . . ; . . .) {</p><p>｝</p><p>return val;</p><p>GCC C 编译器产 生如下 汇编 代码 ：</p><p>l ong 丘m _ b ( 皿s i gned long x) x in %rdi</p><p>fun_b:</p><p>movl movl</p><p>.110:</p><p>movq</p><p>$64, %edx</p><p>$0, %eax</p><p>%rdi, %rcx</p><table><thead><tr><th>6</th><th>andl</th><th></th><th>$1, %e</th><th>c x</th><th></th></tr></thead><tbody><tr><td>7</td><td>ad dq</td><td></td><td>%rax,</td><td>%rax</td><td></td></tr><tr><td>8</td><td>or q</td><td></td><td>%rcx,</td><td>%rax</td><td></td></tr><tr><td>9</td><td>s hr q</td><td></td><td>r% di</td><td></td><td>Shift right by 1</td></tr><tr><td>10</td><td>s ubq</td><td></td><td>$1, %r</td><td>dx</td><td></td></tr><tr><td>11</td><td>jne</td><td></td><td>.110</td><td></td><td></td></tr><tr><td>12</td><td>rep;</td><td>ret</td><td></td><td></td><td></td></tr></tbody></table><p>逆向工程这段代码的操作，然后完成下面的工作：</p><ol><li><p>根据 汇编代 码版本填 写 C 代码 中缺 失的部分。</p></li><li><p>解释循环前为什么没有初始测试也没有初始跳转到循环内部的测试部分。</p></li><li><p>用自然语言描述这个函数是计算什么的。</p><p>讫； 练习题 3. 29 在 C 语 言 中执行 c o n t i n ue 语 句会导 致 程 序 跳 到 当 前 循环 迭代 的 结 尾。当处理 c o n t i n ue 语句 时 ， 将 f or 循环 翻译 成 wh i l e 循 环 的 描述 规则 需 要 一 些 改进。例如，考虑下面的代码：</p><p>I* Example of for l oop cont a i ni ng a continue statement *I I* Sum even numbers between O and 9 *I</p><p>long sum= O; long i;</p><p>for (i = O; i &lt; 10; i++) {</p><p>if (i & 1)</p><p>continue; sum += i ;</p></li><li><p>如果 我们 简 单地 直 接 应 用 将 f o r 循 环 翻译 到 wh i l e 循 环 的 规则 ， 会得 到 什 么呢？ 产生的代码会有什么错误呢？</p></li><li><p>如何用 g o t o 语 句来 替代 c o n t i n ue 语句 ， 保证 wh i l e 循环的行 为同 f or 循环的行为完全一样？</p></li><li><p>6. 8 s w itc h 语句</p><p>s wi t c h ( 开关）语句可以根据一个整数 索引值进行多重分支( m ult iw ay bra nching ) 。 在处理具有多种可能结果 的测试时 ， 这种 语句特别有用。它们不仅提高了 C 代码的可读性，而且通 过使用跳 转表 ( jum p ta ble ) 这种数据结构使得实现更加高效。跳转表是一个数组，表项 t 是一个代码段的 地址 ， 这个代码 段实现当开关 索引值等千 1 时程序应该 采取的 动作。程序代码用开关索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。和使用一组很 长 的 江- e l s e 语句相比， 使用跳转表的优点 是执行开关 语句的时间与开关情况的 数 扯无关。GCC 根据开关 情况的数 量和开关情况值的稀疏程度来 翻译 开关语句。当开关情况数量比较多（例如4 个以上）， 并且值的 范图跨度比较小 时， 就会使用跳转 表。</p><p>图 3- 22a 是一个 C 语言 SW止 c h 语句的示例。这个 例子有些 非常有意思的特征， 包括情况标号 ( case la be!) 跨过一个不 连续 的区域（对于情况 101 和 105 没有标 号）， 有些情况有多个标号（情况 104 和 106 ) , 而有些情况则 会落入其他情况之 中（情况 10 2 ) , 因为对应该情况的代码段没有 以 br e a k 语句结尾。</p><p>图 3-23 是编译 s wi t c h_e g 时产生的汇编代码。这段 代码的行为用 C 语言来描述就是图 3-226 中的过程 s wi t c h_e g _ i mp l 。 这段代码使用了 GCC 提供的 对跳转表的支持， 这是</p></li></ol><p>对 C 语言的扩展。数组 j t 包含 7 个表项 ， 每个都是一个代码块的地址 。这些位置由 代码中的标号定义，在］七的表项中由代码指针指明，由标号加上飞矿前缀组成。（回想运算符</p><p>＆ 创建一个指向数 据值的指针。在做这个扩展时， GCC 的作者们创造了一个新的运算 符</p><p>＆＆， 这个运算 符创建一个指向代码位 置的指 针。）建议你研究一下 C 语言过程 s wi t c h_e g —</p><p>impl, 以及它与汇编代码版本之间的关系。</p><p>void switch_eg_impl(long x, long n,</p><p>2 long *dest)</p><p>3 ｛</p><ol><li><p>I* Table of code pointers *I</p></li><li><p>static void *jt [7] = {</p><p>void switch_eg(long x, long n, 6 &&amp;loc_A, &&amp;loc_def, &&amp;loc_B, long *dest) 7 &&amp;loc_C, &&amp;loc_D, &&amp;loc_def,</p><p>｛ 8 &&amp;loc_D</p><p>long val= x; 9 };</p><p>10 unsigned long index= n - 100;</p><p>switch (n) { I ,, long val;</p></li></ol><table><thead><tr><th></th><th>12</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>case 100: val*= 13;</td><td></td><td>13 14</td><td>if</td><td>(index> 6) goto loc_def;</td><td></td></tr><tr><td>break;</td><td></td><td>15</td><td>I*</td><td>Multiway branch</td><td>*I</td></tr><tr><td></td><td></td><td>16</td><td>goto *jt[index];</td><td></td><td></td></tr><tr><td></td><td>case 102: val+= 10;</td><td></td><td></td><td>17 18</td><td>loc_A: I* Case 100 *I</td></tr><tr><td></td><td>I* Fall through</td><td>*I</td><td></td><td>19</td><td>val= x * 13;</td></tr><tr><td></td><td></td><td></td><td></td><td>20</td><td>goto done;</td></tr><tr><td></td><td>case 103:</td><td></td><td></td><td>21</td><td>loc_B: I* Case 102 *I</td></tr><tr><td></td><td>val += 11;</td><td></td><td></td><td>22</td><td>X = X + 10;</td></tr><tr><td></td><td>break;</td><td></td><td></td><td>23</td><td>/• Fall through•/</td></tr><tr><td></td><td></td><td></td><td></td><td>24</td><td>loc_C: I* Case 103 *I</td></tr><tr><td></td><td>case 104:</td><td></td><td></td><td>25</td><td>val = x + 11;</td></tr><tr><td></td><td>case 106:</td><td></td><td></td><td>26</td><td>goto done;</td></tr><tr><td></td><td>val*= val;</td><td></td><td></td><td>27</td><td>loc_D: I* Cases 104, 106 *I</td></tr><tr><td></td><td>break;</td><td></td><td></td><td>28</td><td>val= x * x;</td></tr><tr><td></td><td></td><td></td><td></td><td>29</td><td>goto done;</td></tr><tr><td></td><td>default:</td><td></td><td></td><td>30</td><td>loc_def: I* Default case *I</td></tr><tr><td></td><td>val= O;</td><td></td><td></td><td>31</td><td>val= O;</td></tr><tr><td></td><td>｝</td><td></td><td></td><td>32</td><td>done:</td></tr><tr><td></td><td>*dest = val;</td><td></td><td></td><td>33</td><td>*dest = val;</td></tr><tr><td>｝</td><td></td><td></td><td></td><td>34</td><td>｝</td></tr></tbody></table><p>a ) s wi t c h语句 b ) 翻译到扩展的 C语言</p><p>图 3-22 s wi t c h 语句示例以及翻译到扩展的 C 语言。该翻译 给出了 跳转表 j t 的结构， 以 及如何访问它。作为对 C 语言的扩展 ， GCC 支持 这样 的表</p><p>原始的 C 代码有针对值 100 、102-104 和 10 6 的清况 ， 但是开关变量 n 可以是任意整数。编译器首先将 n 减去 100 , 把取值范围移到 0 和 6 之间， 创建一个新的程序变量 ， 在我们的 C 版本中称为 i nde x。补码表示的负数会映射成无符号表示的大正数 ， 利用这一事实 ， 将 i nde x 看作无符号值， 从而进一步简化了分支的可能性。因此可以 通过测试 i nde x 是否大于 6 来判定i nde x 是否在 0 ~ 6 的范围之外。在 C 和汇编代码中 ， 根据 i nde x 的值， 有五个不同的跳转位</p><p>置： loc A( 在汇编代码中标识为 . 1 3) , loc B(.LS), loc C(.16), loc D( . 1 7 ) 和 l o c def</p><p>(.18), 最后一个是默认的目的地址。每个标号都标识一个实 现某个情 况分支的代码块。在 C</p><p>和汇编代码 中， 程序都是将 i nde x 和 6 做比较， 如果大千 6 就跳转到默认的代码处。</p><p>void switch_eg(long x, long n, long *des t )</p><p>x in %rdi, n in %sr switch_eg:</p><p>i , dest in %rdx</p><p>subq $100, %rsi</p><p>cmpq $6, %rsi</p><p>ja .18</p><p>jmp *. 14(,%rsi, 8)</p><p>.13:</p><p>leaq (%rdi,%rdi,2), %rax leaq (%rdi,%rax,4), %rdi jmp .12</p><p>.15:</p><p>addq $10, %rdi</p><p>.16:</p><p>addq $11, %rdi</p><p>jmp .12</p><p>.17:</p><p>imulq %rdi, %rdi jmp .12</p><p>.18:</p><p>movl $0, %edi</p><p>.12:</p><p>movq %rdi, (%rdx) ret</p><p>Comp ut e index = n-1 00</p><p>Compar e i nde x: 6 If>, goto l oc_def Goto *jt [index]</p><p>l oc _A : 3•x</p><p>val = 13•x</p><p>Goto done l oc _B :</p><p>X = X + 10</p><p>l oc_ C :</p><p>val = x + 11 Goto done</p><p>l oc _D:</p><p>val = x * x Goto done</p><p>l oc _de f : val = 0</p><p>done :</p><p>•dest = val Return</p><p>图 3-23 图 3-22 中 s wi t c h 语句示例的汇编代码</p><p>执行 s wi t c h 语句的关键步骤是通过跳转 表来访问代码位 置。 在 C 代码中是 第 1 6 行， 一条 g o t o 语句引用了跳转表 j t 。GCC 支持计算 g o t o ( co m p u ted goto), 是对 C 语言的扩展。在我们的 汇编代码 版本中， 类似的操作是在第 5 行， j mp 指令的操作数有前缀｀＊＇，表明这 是一个间 接跳转 ， 操作数指定一个内存位置， 索引由寄存器%r s i 给出 ， 这个寄存 器保存着 i n d e x 的值。（我们会在 3. 8 节中看到如何 将数组引 用翻译 成机器代码 。）</p><p>C 代码将跳转 表声明 为一个 有 7 个元素的 数组 ， 每个元素都是 一个指向代码位置的指针。这些元素跨越 i n d e x 的值 0 ~ 6 , 对应于 n 的值 100 ~ 10 6。可以 观察到， 跳转表对重复情况 的处理就是 简单地对表项 4 和 6 用同样的 代码标号( l o c _ D) , 而对千缺失的情况的处理就是对表 项 1 和 5 使用默认情 况的标 号( l o c _ d e f ) 。</p><p>在汇编代码中，跳转表用以下声明表示，我们添加了一些注释：</p><table><thead><tr><th>2</th><th>.section .align 8</th><th></th><th>.rodata Align address to multiple of 8</th></tr></thead><tbody><tr><td>3</td><td>.L4:</td><td></td><td></td></tr><tr><td>4</td><td>.quad</td><td>.L3</td><td>Case 100: loc_A</td></tr><tr><td>5</td><td>.quad</td><td>.LS</td><td>Case 101: loc_def</td></tr><tr><td>6</td><td>.quad</td><td>.15</td><td>Case 102: loc_B</td></tr><tr><td>7</td><td>.quad</td><td>.L6</td><td>Case 103: loc_C</td></tr><tr><td>8</td><td>.quad</td><td>.L7</td><td>Case 104: loc_D</td></tr><tr><td>9</td><td>.quad</td><td>.L8</td><td>Case 105: loc_def</td></tr><tr><td>10</td><td>.quad</td><td>.17</td><td>Case 106: loc_D</td></tr></tbody></table><p>这些声明 表明 ， 在叫做 " . r o d a t a " ( 只读数据， R e ad- O nly Dat a ) 的目标代码文件的 段中 ， 应该有一组 7 个“四” 字( 8 个字节）， 每个字的值都是与指定 的汇编代码标号（例如 . L3) 相关联的指令地址。标号 . L4 标记出这个分配地址 的起始。与这个标号相对应的 地 址会作为间 接跳转（第5 行）的基地址。</p><p>不同的代码块CC 标号 l oc _A 到 l oc _ D 和 l oc—de f ) 实现了 s wi t ch 语句的不同分支。它</p><p>们中的大多数只是简单地计算了 va l 的值， 然后跳转到函数的结 尾。类似地 ， 汇编代码块计 算了寄存器 %r 中 的值， 并且跳转到函数结 尾处由标号. L2 指示的位置。只有情况标号 102 的 代码不是这种模式的 ， 正好说明在原始 C 代码中情况 102 会落到 情况 103 中。具体处理如下： 以标号. LS 起始的汇编代码块中， 在块结尾处没有 j rnp 指令， 这样代码就会继续执行下一个块。类似地， C 版本 s wi t c h_e g _i rnp l 中以标号 l oc_B 起始的块的结尾处也没有 got o 语句。</p><p>检查所有这些代码需要很仔 细的研究， 但是关键是领会使 用跳转表是一种非常有效 的实现多 重分 支的方法。在我 们的例子中， 程序可以 只用一次跳转表引用就分支到 5 个不同的位置。甚 至当 s wi t c h 语句有上百 种情况的时候 ， 也可以只 用一次跳转表访问 去处理。 亡 练习题 3. 30 下 面的 C 函数省略 了 S W 江 c h 语句的 主体 。在 C 代码 中 ， 情况标 号是不</p><p>连续的，而有些情况有多个标号。</p><p>void switch2(long x, long *dest) { long val= O;</p><p>switch (x) {</p><p>Body of switc h statement omitted</p><p>*dest = val;</p><p>在编译该函数时， GCC 为程序的初 始部分生成了以 下汇编代码，变 量 x 在寄存器r%</p><p>V O 工 d swi tch2(long x, long *dest)</p><p>x in %rdi swi t ch2 :</p><p>di 中：</p><p>addq cmpq ja jmp</p><p>$1, %rdi</p><p>$8, 1r儿 di</p><p>.12</p><p>*. 14(,%rdi, 8)</p><p>为跳转表生成以下代码：</p><p>.L4:</p><p>.quad</p><p>.quad</p><p>. quad</p><p>. quad</p><p>.quad</p><p>.quad</p><p>.quad</p><p>.quad</p><p>.quad</p><p>. L9</p><p>.LS</p><p>.L6</p><p>. L7</p><p>. L2</p><p>.L7</p><p>.L8</p><p>.L2</p><p>.LS</p><p>根据 上述 信息 回答下 列问题 ：</p><ol><li>s wi t c h 语 句内 情况标 号的值 分别是 多少？</li><li>C 代码 中哪 些情况 有 多个标 号？</li></ol><p>诈 练 习题 3. 31 对于 一 个 通用 结构的 C 函 数 s wi t c h er :</p><p>void switcher(long a, long b, long c, long *dest)</p><p>｛</p><p>long val; switch(a) {</p><p>casa : I* Case A *I</p><p>C =</p><p>I* Fall through *I</p><p>case I* Case B *I</p><p>val= break;</p><p>case I* Case C *I</p><p>case I* Case D *I</p><p>val= break;</p><p>case I* Case E *I</p><p>val= break;</p><p>default:</p><p>val=</p><p>｝</p><p>*dest = val;</p><p>｝</p><p>GCC 产 生如 图 3- 24 所 示 的 汇 编代码 和跳 转 表。</p><p>VO 工 d switcher(long a, long b, l ong c, long *dest) a in %rdi, b 工 n %rsi, c in %rdx, dest in %rcx switcher:</p><p>cmpq ja jmp</p><p>.section</p><p>.L7:</p><p>$7, %rdi</p><p>.12</p><p>*. 14(,%rdi ,8)</p><p>r. odat a</p><p>xorq $15, %rsi</p><p>movq %rsi, %rdx</p><p>.L3:</p><p>leaq 112(%rdx), %rdi jmp .L6</p><p>.LS:</p><p>leaq salq jmp</p><p>.L2:</p><p>(%r dx , %r s i ) , %rdi</p><p>$2, %rdi</p><p>.L6</p><p>movq %rsi, %rdi</p><p>.L6:</p><p>movq %rdi, (%rcx) ret</p><p>a ) 代码</p><p>图 3-2 4 练习题 3. 31 的汇编代 码和跳转表</p><p>b ) 跳转表</p><p>填写 C 代码 中 缺 失的 部 分。除 了 情 况标 号 C 和 D 的 顺 序 之 外， 将 不 同 情 况 填入这个模板的方式是唯一的。</p><p>3. 7 过程</p><p>过程是软件中一种很重要的抽象。它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。设计良好的软件用过程 作为抽象机制，隐藏某个行为的具体实现，同时又提供清晰简洁的接口定义，说明要计算的是哪些值， 过程会对程序状态产生什么样的影响。不同编程语言中， 过程的形式多样： 函数( function) 、方法( method) 、子例程( sub ro utine) 、处理函数( handler ) 等等， 但是它们有一些共有的特性。</p><p>要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程</p><p>p 调用过程 Q , Q 执行后返回到 P。这些动作包括下 面一个 或多个 机制 ：</p><p>传递控 制。在进入过 程 Q 的时候， 程序计数 器必须被设置为 Q 的代码的起始地址 ， 然后在返回时， 要把程序计 数器设置为 P 中调用 Q 后面那条指令的 地址。</p><p>传递数 据。P 必须能够向 Q 提供一个或多个参数， Q 必须 能够向 P 返回一个值 。</p><p>分配和释放 内存。在开始 时， Q 可能需 要为局 部变量分 配空间， 而在返回前， 又必 须释放这些存储空间。</p><p>x86-64 的过程实现 包括一组特殊的指令 和一些 对机器资源（例如寄存器和程序内存）使用的约定规则。人们花了大量的力气来尽量减少过程调用的开销。所以，它遵循了被认为 是最低要求策略的方法，只实现上述机制中每个过程所必需的那些。接下来，我们一步步 地构建起不同的机制，先描述控制，再描述数据传递，最后是内存管理。</p><p>3. 7. 1 运行时栈</p><p>C 语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。在过 程 P 调用过程 Q 的例子中， 可以看到当 Q 在执行 时， p 以及所有在向上追溯到 P 的调用链中的过程， 都是暂时被挂起的。当Q 运行时， 它只需要为局部 变量分 配新的存储空间，或者设置到另一个过程的调用。 另一方面， 当 Q 返回时， 任何它所分配的局部存储空间都可以被释放。因此，程序可以用栈来管 理它的过程所需要的存储空间，栈和程序寄存器 存放着传递控制和数据、分配内存所需要的信息。当 P 调用 Q 时， 控制和数据信息添加到栈尾。当 P 返回时，这些信息会释放掉。</p><p>如 3. 4. 4 节中讲过的， x86-64 的栈向低地址方向增长， 而栈指 针%r s p 指向栈顶元 素。 可以用 p us hq 和 p o p q 指令将数据存入栈中或是从栈中取出。将栈指针减小一个适当的量可以 为没有指定初始值的数据在栈上分配空间。类 似地，可以通过增加栈指针来释放空间。</p><p>地址增大</p><p>栈指针</p><p>%rsp</p><p>栈底</p><p>栈“顶”</p><p>较早的帧</p><p>调用函数</p><p>P的帧</p><p>正在执行的</p><p>函数Q的帧</p><p>当 x86-64 过程需要的存储空间 超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分 称为过程的栈帧 ( s t ack fr am ) 。图 3- 25</p><p>图 3-25 通用的栈帧结构（栈用来传递参数、存储返回信息、保存寄存器，以及局部 存储。省略了不必要的部分）</p><p>给出了运行时栈的通用结构，包括把它划分为栈帧。当前正在执行的过程的帧总是在栈 顶。当过程 P 调用过程 Q 时， 会把返回地址压入栈中， 指明当 Q 返回时， 要从 P 程序的哪个位置继续 执行。我们把这个 返回地址 当做 P 的栈帧的一部分， 因为它存 放的是与 P 相关的状态 。Q 的代码会 扩展当前 栈的边界 ， 分配它的栈帧所需的空间。在这个空间中， 它可以保存寄存器的 值， 分配局部 变量空间， 为它调用的 过程设 置参数。大多数过程的 栈帧都是定长的 ， 在过程的 开始就分 配好了。但是有些过程需 要变长的帧 ， 这个问题会在 3. 10. 5 节中讨论。通过寄存 器， 过程 P 可以 传递最多 6 个整数 值（也就是指针和整数）， 但是如果</p><p>Q 需要更多的参数 ， P 可以在调用 Q 之前在自己 的栈帧里存储好这些参数。</p><p>为了提高空间 和时间效 率， x 8 6 - 64 过程只分 配自己所需 要的栈帧部分。例如， 许多过程有 6 个或者更 少的参数， 那么所有的参数都可以 通过寄存器传递。因此， 图 3- 25 中画出的某些栈 帧部分可以省略。实际上， 许多函数甚至根本不 需要栈帧。当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数（有时称之为叶子过程，此时 把过程调用看做树结构）时，就可以这样处理。例如，到目前为止我们仔细审视过的所有 函数都不 需要栈帧。</p><ol><li><p>7. 2 转移控制</p><p>将控制从函数 P 转移到函数 Q 只需 要简单地把程序计数器 ( PC)设置为 Q 的代码的起始位置。不过 ， 当稍后从 Q 返回的时候 ， 处理器必须记录好它需要继续 P 的执行的代码位置。在x86-64 机器中， 这个信息是用指令 c a ll Q 调用过程 Q 来记录的。该指 令会把地址 A 压入栈中， 并将 PC 设置为 Q 的起始地址。压入的地址 A 被称为返回地址 ， 是紧跟 在 c a l l 指令后面的那 条指令的地址。对应的指令r e t 会从栈中弹出地址 A , 并把 PC 设置为 A 。</p><p>下表给出的是 c a l l 和r e t 指令的一般形式 ：</p></li></ol><table><thead><tr><th>指令</th><th></th><th>描述</th></tr></thead><tbody><tr><td>call</td><td>Label</td><td>过程调用</td></tr><tr><td>call</td><td>Operand</td><td>过程调用</td></tr><tr><td>ret</td><td></td><td>从过程调用中返回</td></tr></tbody></table><p>（这些指令在程序 OBJDUMP 产生的反汇编输出中 被称为 c a ll q 和r e t q 。添加的后缀&rsquo; q &rsquo; 只是为了强 调这些是 x8 6- 64 版本的调用和返 回， 而不是 I A 3 2 的。在 x8 6- 64 汇编代码中， 这两种版本可以互换。）</p><p>c a l l 指令有一个 目标， 即指明 被调用过程起始的指令地址。同 跳转一样， 调用可以是直接的，也可以是间接的。在汇编代码中，直接调用的目标是一个标号，而间接调用的 目标是 ＊ 后面跟一个操作数指示符 ， 使用的是图 3-3 中描述的格式之一。</p><p>图 3- 26 说明了 3. 2. 2 节中介绍的 mu l t s t or e 和 ma i n 函数的 c a l l 和r e t 指令的执行情况。下面是这两个 函数的反汇编代码的 节选 ：</p><p>Beginning of function multstore</p><p>1 0000000000400540 &lt;multstore>:</p><p>2 400540: 53</p><p>3 400541: 48 89 d3</p><p>push %rbx</p><p>mov %rdx,%rbx</p><p>Return from f unc t i on mul tstore</p><p>40054d: c3 retq</p><p>Call to multstore from ma 工 n 400563: e8 d8 ff ff ff 400568: 48 8b 54 24 08</p><p>callq 400540 &lt;multstore> mov Ox8(%rsp),%rdx</p><p>在这段 代码中 我们 可以 看到 ， 在 ma i n 函数中 ， 地址 为 Ox 400 5 63 的 c a l l 指令调用 函 数 mu l t s t or e 。此 时的状态如图 3- 26a 所示， 指明了栈指针%r s p 和程序计数 器％豆 p 的值。 c a ll 的效果是 将返回地址 Ox 40 05 68 压入栈中，并跳到函数 mu l t s t or e 的第一条指令，地址为 Ox 0 40 05 40 ( 图 3- 266 ) 。函数 mu l t s t or e 继续执行， 直到 遇 到地址 Ox 40 05 4d 处的</p><p>r e t 指令。这条指 令从 栈中弹出值 Ox 40 05 68 , 然后跳转到这个地址， 就在 c a l l 指令之后， 继续 ma i n 函数的 执行。</p><p><img src=img/847c31850d9893a5dd167eb7b2db063e.jpeg alt><img src=img/469a80d839b8e6d22cc8b19671199219.jpeg alt>霍。x7f f f驾言罚</p><p>Ox400568</p><p>a ) 执行ca l l b) ca ll 执行之后</p><p>c) r e t 执行之后</p><p>图 3-26 ca ll 和 r e t 函数的说明。ca l l 指令将控制 转移到一 个函数的起 始， 而 r e t 指令 返回 到这 次调 用后面的 那条指 令</p><p>再来看一个更详细说明在过程间传递控制的 例子， 图 3- 27a 给出了两个函数 t op 和 l e a f 的反汇编代码， 以及 ma i n 函数中调用 t op 处的代码。每条指令都以标号标出： Ll ~ L 2 O e a f 中）， T l ~ T 4 ( ma i n 中）和M l ~ M 2 ( ma i n 中）。该图的 b 部分给出了 这段代码执</p><p>Disassembly of leaf(long y) y in¼rdi</p><p>1 0000000000400540 &lt;l e af > :</p><p>2 400540: 48 8d 47 02</p><p>3 400544: c3</p><p>4 0000000000400545 &lt;top>:</p><p>历 s as s embl y of top(long x) x in¼rdi</p><p>lea Ox2 (%rdi) , %rax L1: y+2 retq L2: Return</p><table><thead><tr><th></th><th>Call to</th><th>top from function main</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>9</td><td>40055b:</td><td>e8 e5 ff ff ff</td><td>callq</td><td>400545 &lt;top></td><td>Ml: Call top(100)</td></tr><tr><td>1O</td><td>400560:</td><td>48 89 c2</td><td>rnov</td><td>%rax, %rdx</td><td>M2: Resume</td></tr></tbody></table><p>a ) 说明过程调用和返回的反汇编代码</p><p>图 3-27 包含过 程调 用和返回的 程序的 执行细节 。使用栈来存储返回地址使得能够返回到过程中正确的位置</p><table><thead><tr><th>指令</th><th>状态值（指令执行前）</th><th>描述</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>标号</td><td>PC</td><td>指令</td><td>兮r di</td><td>%rax</td><td>%rsp</td><td>飞 r s p</td><td></td></tr><tr><td>Ml</td><td>Ox40055b</td><td>callq</td><td>JOO</td><td></td><td>Ox7fffffffe820</td><td></td><td>调用t op(100)</td></tr><tr><td>Tl</td><td>Ox400555</td><td>sub</td><td>100</td><td></td><td>Ox7fffffffeS18</td><td>Ox400560</td><td>进入t op</td></tr><tr><td>T2</td><td>Ox400559</td><td>callq</td><td>95</td><td></td><td>Ox7fffffffe818</td><td>Ox400560</td><td>调用l e a f (95)</td></tr><tr><td>LI</td><td>Ox400540</td><td>lea</td><td>95</td><td></td><td>Ox7 fffffffe810</td><td>Ox40054e</td><td>进人l e a f</td></tr><tr><td>L2</td><td>Ox400544</td><td>retq</td><td></td><td>97</td><td>Ox7 f ff f ff f e 81 0</td><td>Ox40054e</td><td>从l e a f 返回97</td></tr><tr><td>T3</td><td>Ox40054e</td><td>add</td><td></td><td>97</td><td>Ox7f f f f f f f e 818</td><td>Ox400560</td><td>继续t op</td></tr><tr><td>T4</td><td>Ox400551</td><td>retq</td><td></td><td>194</td><td>Ox7f f f ff ff e 818</td><td>Ox400560</td><td>从t op返回194</td></tr><tr><td>M2</td><td>Ox400560</td><td>rnov</td><td></td><td>194</td><td>Ox7 ff f ff ff e 820</td><td></td><td>继续ma i n</td></tr></tbody></table><p>b ) 示例代码的执行过程图 3-27 (续）</p><p>行的详细 过程， ma i n 调 用 t o p ( l OO) , 然后 t o p 调用 l e a f ( 9 5 ) 。 函数 l e a f 向 t o p 返回</p><p>97, 然后 t o p 向 ma i n 返回 1 9 4 。前面三列描述了被执行的指令， 包括指令标号、地址和指令类 型。后面四列给出了在该指令执行前程序的状态， 包括寄存器%r d i 、%r a x 和 %r s p 的内容，以及位于栈顶的值。仔细研究这张表的内容，它们说明了运行时栈在管理支持过 程调用和返回所需的存储空间中的重要作用。</p><p>l e a f 的指令 L l 将%r a x 设 置为 9 7 , 也就是要返回的值。然后指令 L2 返回，它 从 栈中弹出 Ox 40 0 0 5 4e 。通过将 PC 设置为这个弹出的值，控 制转移回 七o p 的 T3 指令。程序成功 完成对 l e a f 的 调 用 ，返 回 到 t o p 。</p><p>指令 T3 将%r a x 设 置为 1 9 4 , 也就是要从 t o p 返回的值。然后指令 T 4 返回，它 从 栈中弹出 Ox 4 0 0 0 5 60 , 因此将 PC 设置为 ma i n 的 M2 指令。程序成功完成对 t o p 的调用， 返回到 m釭n。可以 看到，此 时 栈 指针也恢复成了 Ox 7 f f f f f f f e 8 2 0 , 即 调 用 t o p 之 前 的 值 。</p><p>可以看到，这种把返回地址压入栈的简单的机制能够让函数在稍后返回到程序中正确 的点。C 语言（以及大多数程序语言）标准的调用／返回机制刚好与栈提供的后进先出的内存管理方法吻合。</p><p>讫 ］练习题 3 . 32 下面 列 出 的是 两个 函 数 f ir s t 和 l a 江 的 反 汇编 代 码 ， 以 及 ma i n 函 数调用 f ir s t 的代码 ：</p><table><thead><tr><th></th><th>D 工 sas s e mbl y of last (long u, U 立 1 r% di , v in %rsi</th><th>long v)</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>1</td><td>0000000000400540 &lt;last>:</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td>40054 0 : 48 89 f8</td><td></td><td>rnov</td><td>%rdi,%rax</td><td>L1 :</td><td>u</td></tr><tr><td></td><td>400543: 48 Of af c6</td><td></td><td>irnul</td><td>%rsi,%rax</td><td>L2 :</td><td>u• v</td></tr><tr><td>4</td><td>400547: c3</td><td></td><td>retq</td><td></td><td>L3 :</td><td>Return</td></tr></tbody></table><p>釭 s ass embl y of first(long x) x in %rdi</p><table><thead><tr><th>5</th><th>0000000000400548 &lt;first>:</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>6</td><td>400548: 48 8d 77 01</td><td>lea</td><td>Ox1(%rdi) , %rsi</td><td>Fl : x+1</td></tr><tr><td>7</td><td>40054c: 48 83 ef 01</td><td>sub</td><td>$0x1,%rdi</td><td>F2: x-1</td></tr><tr><td>8</td><td>4 00550 : e8 eb ff ff ff</td><td>callq</td><td>400540 &lt;last></td><td>F3: Call last (x-1,x+1)</td></tr></tbody></table><p>9 400555: f3 c3 repz retq F4: Return</p><p>1o 400560: e8 e3 ff ff ff 11 400565: 48 89 c2</p><p>callq 400548 &lt;first> M1 : Call f r工s t (10) mov %rax, %rdx M2 : Resume</p><p>每条指令都 有 一个标 号 ， 类似 于图 3- 2 7 a 。 从 ma i n 调用 丘r s 七 (1 0 ) 开始 ，到 程序返回 ma i n 时为止 ， 填写 下表 记 录指令 执行 的过 程。</p><table><thead><tr><th>指令</th><th>状态值（指令执行前）</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>标号</td><td>PC</td><td>指令</td><td>r% di</td><td>r%s i</td><td>% r ax</td><td>r% s p</td><td>* r% s p</td><td>描述</td></tr><tr><td>Ml</td><td>Ox400560</td><td>ca ll q</td><td>10</td><td></td><td></td><td>Ox7fffffffe820</td><td></td><td>调用 f1rstO O)</td></tr><tr><td>Fl</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>F2</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>F3</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>L1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>L2</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>L3</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>F4</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>MZ</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ol><li><p>7. 3 数据传送</p><p>当调用一个过程时，除了要把控制传递给它并在过程返回时再传递回来之外，过程调 用还可能包括把数 据作为参数 传递， 而从 过程返回还有可能 包括返回一个值。x8 6- 64 中， 大部分 过程间 的数据传送 是通过寄 存器实现的 。例如 ， 我们 已经看到无数的函数 示例 ， 参数在寄存器 %r d i 、%r s i 和其他寄存 器中传递 。当过程 P 调用过程 Q 时， P 的代码必须首先把参数复制到适 当的寄存器中。类似地 ， 当 Q 返回到 P 时， P 的代码 可以 访问寄存器%r a x 中的返回值。在本节中，我们更详细地探讨这些规则。</p><p>x 8 6- 6 4 中， 可以 通过寄存特最多 传递 6 个整型（例如整数 和指针）参数。寄存器的使用是有特殊顺 序的 ， 寄存器使用的名字取决千要传递的数据类型的大小， 如图 3- 28 所示。会根据参数在参数列表中的顺 序为它们分配寄 存器。可以 通过 6 4 位寄存器适 当的部分访问小于 6 4 位的参数 。例如 ， 如果第一个参数是 3 2 位的 ， 那么可以用%e d i 来访间它。</p></li></ol><table><thead><tr><th>操作数大小（位）</th><th>参数数扭</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr><tr><td>64</td><td>% r di</td><td>% r s i</td><td>% r dx</td><td>毛r c x</td><td>r号 8</td><td>% r 9</td></tr><tr><td>32</td><td>%edi</td><td>%es i</td><td>%ed x</td><td>%ec x</td><td>%r8d</td><td>r号 9d</td></tr><tr><td>16</td><td>%di</td><td>%s i</td><td>%dx</td><td>%e x</td><td>%r8w</td><td>%r9w</td></tr><tr><td>8</td><td>令dil</td><td>% s i l</td><td>%dl</td><td>%cl</td><td>%r8b</td><td>r皂 9b</td></tr></tbody></table><p>图 3-28 传递函数参数的寄存器。寄存器是按照特殊顺序来使用的 ， 而使用的 名字是 根据参数的大小来 确定的</p><p>如果一 个函数有 大于 6 个整型参 数， 超出 6 个的部分就要通过栈来传递。假设过程 P</p><p>调用过程 Q, 有 n 个整型 参数 ， 且 n > 6 。那么 P 的代码分配的栈帧必须要能容纳 7 到 n</p><p>号参数的存储空间 ， 如图 3- 25 所示。要 把参数 1 ~ 6 复制到 对应的寄存 器， 把参数 7 ~ n 放</p><p>到栈上 ， 而参数 7 位于栈顶 。通过栈 传递参数时 ， 所有的数 据大小都向 8 的倍数对齐。参数到位 以后， 程序就可以 执行 c a l l 指令将控 制转 移到过 程 Q 了。过程 Q 可以 通过寄存器访问参数， 有必要的 话也可以 通过栈 访问。相应地 ， 如果 Q 也调用了 某个 有超过 6 个参数的函数 ， 它也需要在自己的 栈帧中为超出 6 个部分的参数分配空 间， 如图 3- 25 中标号为“参数构造区”的区域所示。</p><p>作为参数 传递的示例 ， 考虑图 3- 2 9 a 所示的 C 函数 p r o c 。这个 函数有 8 个参数 ， 包括字节数 不同的整数 ( 8 、4 、2 和 1) 和不同类 型的指针， 每个都是 8 字节的 。</p><p>void proc(long a1, long *alp,</p><p>int a2, int *a2p, short a3, short *a3p, char a4, char *a4p)</p><p>｛</p><p>*a1p += a1;</p><p>*a2p += a2;</p><p>*a3p += a3;</p><p>*a4p += a4;</p><p>｝</p><ol><li>C代码</li></ol><p>void proc(a1, a1p, a2, a2p, a3, a3p, a4, a4p) Arguments passed as follows:</p><p>a1 in %rdi (64 bi ts)</p><p>alp in %rsi (64 bi ts)</p><p>a2 in %edx (32 bi ts)</p><p>a2p in %rcx (64 bi ts)</p><p>a3 in %r 8 日 (16 bits)</p><p>a3pin %r9 (64 bi ts)</p><p>a4 at %rsp+8 (8 bi ts)</p><p>a4p at %rsp+16 (64 bits) proc:</p><p>movq addq addl addw movl addb ret</p><p>16(%rsp), %rax</p><p>%rdi, (%rsi)</p><p>%edx, (%rcx)</p><p>%r8w, (%r9) 8(%rsp), %edx</p><p>%dl, (%rax)</p><p>Fetch a4p</p><p>•a1p += a1</p><p>•a2p += a2</p><p>•a3p += a3 Fetch a4</p><p>•a4p += a4 Return</p><p>(64 bits)</p><p>(64 bits)</p><p>(32 bits)</p><p>(16 bits)</p><p>(8 bits)</p><p>(8 bits)</p><p>图 3-29</p><p>b ) 生成的汇编代码</p><p>有多个不同 类型参数的函数示例。参数 1 ~ 6 通过寄 存器传递 ， 而参 数 7~ 8 通过 栈传递</p><p>图 3- 2 9 6 中给出 pr o c 生成的 汇编代码。前面 6 个参数通过寄存器传递， 后面 2 个通过栈 传递 ， 就像图 3-30 中画出来 的那样。可以看到， 作为过程调用的一部分， 返回地址被压 入栈中。因 而这两 个参数位千相对千栈指针距离为 8 和 16 的位置。 在这段代码中， 我们可 以看到根 据操作数的大小， 使用了 ADD 指令的不同版本： a l ( l o n g ) 使用 a d d q , a 2釭n 七）使用 a d d l , a 3 ( s h o r 七） 使用 a d d w, 而 a 4 ( c h ar ) 使用 a d d b 。请注意第 6 行的mov l 指令从内存 读入 4 字节， 而后面的 a d db 指令只使用其中的 低位一字节。</p><p>a4p</p><p>返回地址</p><p>16</p><p>a4 8</p><p>。（ 栈指针r% s p</p><p>图 3-30 函数 proc 的栈帧结构。参数 a 4 和 a 4p 通过栈传递</p><p>芦 练习题 3. 33 C 函 数 pr o c pr o b 有 4 个参数 u、a 、v 和 b , 每个参 数 要 么 是 一个 有 符号数，要么是一个指向有符号数的指针，这里的数大小不同。该函数的函数体如下：</p><p>*U += a;</p><p>*V += b;</p><p>return sizeof(a) + sizeof(b);</p><p>编译得到 如下 x86-64 代 码 ：</p><p>procprob:</p><p>movslq %edi, %rdi addq %rdi, (%rdx)</p><p>addb %s il, (%rcx)</p><p>movl $6, %eax ret</p><p>确定 4 个参数的合 法 顺 序 和 类 型。 有 两种 正 确 答案。</p><ol><li><p>7. 4 栈上的局部存储</p><p>到目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域。不 过有些时候，局部数据必须存放在内存中，常见的情况包括：</p><ul><li><p>寄存器不足够存放所有的本地数据。</p></li><li><p>对一个局部变最使用地址运算符＇＆＇，因此必须能够为它产生一个地址。</p></li><li><p>某些局部变量是数组或结构，因 此 必 须 能 够 通过数组或结构引用被访问到。在描述数组和结构分配时 ， 我们会讨论这个问题。</p><p>一般来说， 过程通过减小栈指针在栈上分配空间。分配的结果作为栈帧的一部分， 标号为 ＂局部变量” ，如 图 3- 25 所示。</p><p>来看一个处理地址运算符的例子，图 3-3 l a 中给出的两个函数。函数 s wa p _ a d d 交换指 针 xp 和 yp 指向的两个值，并 返回这两个值的和。函数 c a l l er 创建到局部变量 a r g l 和 ar g 2 的指针，把 它 们传递给 s wa p_a d d 。 图 3-31 6 展 示了 c a l l er 是如何用栈帧来实现这些局 部 变最的。c a l l er 的代码开始的时候把栈指针减掉了 1 6 ; 实际上这就是在栈上分配了 16 个 字节。S 表示栈指针的值， 可以 看到这段代码计算 &amp;ar g 2 为 S + 8 &lt; 第 5 行）， 而 &amp;ar g l 为 S 。因此可以推断局部变量 ar g l 和 ar g 2 存放在栈帧中相对于栈指针偏移量为 0 和 8 的 地 方 。 当 对 s wa p _ a d d 的 调 用 完成后， c a l l er 的 代码会从栈上取出这两个值（第8 ~ 9 行），计 算它们的差，再 乘以 s wa p_ a d d 在寄存器 %r a x 中 返回的值（第10 行）。最后， 该 函数把栈指针加 16 , 释放栈帧（第11 行）。通过这个例子可以看到， 运行时栈提供了一种简单的 、在需要时分配、函数完成时释放局部存储的机制。</p><p>如图 3-32 所示 ， 函数 c a l l _pr o c 是一个更复杂的例子，说 明 x8 6-64 栈行为的一些特性。尽管这个例子有点儿长，但还是值得仔细研究。它给出了一个必须在栈上分配局部变 量存储空间的函数，同 时 还要向有 8 个参数的函数 pr o c 传递值（图3-29 ) 。该 函数创建一个栈帧 ， 如图 3-33 所示。</p></li></ul></li></ol><p>long swap_add(long *XP, long *yp)</p><p>｛</p><p>long x = *xp; long y = *yp;</p><p>*XP = y;</p><p>*YP = x; return x + y;</p><p>long caller()</p><p>｛</p><p>long argl = 534; long arg2 = 1057;</p><p>long sum= swap_add(&amp;argl, &amp;arg2); long diff = argl - arg2;</p><p>return sum* diff;</p><p>｝</p><p>a) swap_add和调用函数的代码</p><p>long caller() caller:</p><p>b ) 调用函数生成的汇编代码</p><p>图 3-31 过程定义和调用的示例。由于会使用地址运算符，所以调用代码必须分配一个栈帧</p><p>long call_proc ()</p><p>｛</p><p>long xl = 1; int x2 = 2; short x3 = 3; char x4 = 4;</p><p>proc(xl, &amp;xl, x2, &amp;x2, x3, &amp;x3, x4, &amp;x4); return (x1+x2)*(x3-x4);</p><p>｝</p><p>a) swap_add 和调用函数的代码</p><p>图 3-32 调 用 在图 3-29 中定义的函数 pr oc 的代码示 例。该代码创建了一个栈帧</p><p>long call_proc() call_proc:</p><p>Set up arguments to proc</p><table><thead><tr><th>2</th><th>subq</th><th>$32, %rsp</th><th>Allocate 32-byte stack frame</th></tr></thead><tbody><tr><td>3</td><td>movq</td><td>$1, 24(%rsp)</td><td>Store 1 in &amp;xl</td></tr><tr><td>4</td><td>movl</td><td>$2, 20(%rsp)</td><td>Store 2 in &amp;x2</td></tr><tr><td>5</td><td>movw</td><td>$3, 18 (%rsp)</td><td>Store 3 in &amp;x3</td></tr><tr><td>6</td><td>movb</td><td>$4, 17(%rsp)</td><td>Store 4 in &amp;x4</td></tr><tr><td>7</td><td>leaq</td><td>17(%rsp), %rax</td><td>Create &amp;x4</td></tr><tr><td>8</td><td>movq</td><td>%rax, 8(%rsp)</td><td>Store &amp;x4 as argument 8</td></tr><tr><td>9</td><td>movl</td><td>$4, (%rsp)</td><td>Store 4 as argument 7</td></tr><tr><td>10</td><td>leaq</td><td>18(%rsp), %r9</td><td>Pass &amp;x3 as argument 6</td></tr><tr><td>11</td><td>movl</td><td>$3, %r8d</td><td>Pass 3 as argument 5</td></tr><tr><td>12</td><td>leaq</td><td>20(%rsp), %rcx</td><td>Pass &amp;x2 as argument 4</td></tr><tr><td>13</td><td>movl</td><td>$2, 1儿 e dx</td><td>Pass 2 as argument 3</td></tr><tr><td>14</td><td>leaq</td><td>24()儿r s p ) , )儿r s i</td><td>Pass &amp;xl as argument 2</td></tr><tr><td>15</td><td>movl</td><td>$1, %edi</td><td>Pass 1 as argument 1</td></tr><tr><td></td><td>Call proc</td><td></td><td></td></tr><tr><td>16</td><td>call</td><td>proc</td><td></td></tr><tr><td></td><td>Retrieve</td><td>changes to memory</td><td></td></tr><tr><td>17</td><td>movslq</td><td>20(%rsp), %rdx</td><td>Get x2 and convert to long</td></tr><tr><td>18</td><td>addq</td><td>24(%rsp), %rdx</td><td>Compute x1+x2</td></tr><tr><td>19</td><td>movswl</td><td>18(%rsp), %eax</td><td>Get x3 and convert to int</td></tr><tr><td>20</td><td>movsbl</td><td>17(%rsp), %ecx</td><td>Get x4 and convert to int</td></tr><tr><td>21</td><td>subl</td><td>%ecx, %eax</td><td>Compute x3-x4</td></tr><tr><td>22</td><td>cltq</td><td></td><td>Convert to long</td></tr><tr><td>23</td><td>imulq</td><td>%rdx, %rax</td><td>Compute (x1+x2) * (x3-x4)</td></tr><tr><td>24</td><td>addq</td><td>$32, %rsp</td><td>Deallocate stack frame</td></tr><tr><td>25</td><td>ret</td><td></td><td>Return</td></tr></tbody></table><p>b ) 调用函数生成的汇编代码图 3 32 (续）</p><p>看看 c a l l _pr o c 的汇编代码（图3- 3 2 b ) , 可以看到 代码中一 大部分（第2 ~ 1 5 行）是为调用 pr o c 做准备。其中包括为局部 变最 和函数参数建立栈 帧， 将函数参数 加载至寄 存器。如 图 3- 33 所示， 在栈上分 配局部变量 x l ~ x 4 , 它们具有不同的大小： 24~3l(xl), 20~23 (x2), 18~ 19(x3)和 1 7 ( s 3 ) 。用 l e a q 指令生成 到这些 位置的指针（第7 、10 、1 2 和 1 4 行）。参数 7 ( 值为 4 ) 和 8 ( 指向 x 4 的位置的指针）存放在栈中相对于栈指针偏移量为 0 和 8 的地方。</p><p>当调用过 程 pr o c 时， 程序会 开始执行 图 3- 2 9 b 中的代码 。如图 3- 30 所示， 参数 7 和</p><p>8 现在位 千相 对千栈 指针偏移量为 8 和 16 的地方 ， 因为返回地址这时已 经被压入栈中了。当程序返 回 c a ll —pr o c 时， 代码会取出</p><p>返回地址</p><p>32</p><p><img src=img/2b372df284bccf1a7a924caa5da097d8.jpeg alt>xl</p><p>4 个局部变量（第1 7 ~ 20 行）， 并执行最终的计算。在 程序结束前， 把栈指针加 3 2 , 释放这个栈帧。</p><ol><li><p>7. 5 寄存器中的局部存储空间</p><p>x2</p></li></ol><p>参数8 = &amp;x4</p><p>参数7</p><p>ol &mdash;一 栈指针釭 s p</p><p>寄存器组是唯一被所有过程共享的资源。</p><p>图 3-33 函数 ca ll _yr oc 的栈帧。该栈帧包含局部</p><p>变量 和两个要传递 给函数 proc 的参数</p><p>虽然在给定时刻只有一个过程是活动的，我们仍然必须确保当一个过程（调用者）调用另一 个过程（被调用者）时， 被调用 者不会覆盖调用 者稍后 会使用的寄 存器值。 为此， x86-64 采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。</p><p>根据惯例 ， 寄存器%r b x 、%r b p 和 %r 1 2~ %r 1 5 被划分为 被调 用者保 存寄存器。当过程 P 调用过程 Q 时， Q 必须保存这些寄存器的值， 保证它们的值在 Q 返回到 P 时与 Q 被调用时是一样 的。过程 Q 保存一个寄存器的值不变， 要么就是根本不去改 变它， 要么就是把原 始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。压入寄存器的值会在栈帧 中创建标 号为“保 存的寄存器” 的一部分 ， 如图 3- 25 中所示。有了 这条惯 例， P 的代码就能安全地 把值存 在被调用 者保存寄存器中（当然， 要先把之前的值保存到栈上）， 调用 Q, 然后继续使用寄存器中的值，不用担心值被破坏。</p><p>所有其他的 寄存器 ， 除了栈指针%r s p , 都分类为调用者保存寄存器。这就意味着任何函数都 能修改它 们。可以这样来理解“调用 者保存” 这个名 字： 过程 P 在某个此类寄存器中有局部数 据， 然后 调用过程 Q。因为 Q 可以 随意修改 这个 寄存器， 所以在调 用之前首先保存好这 个数据是 p ( 调用者）的责任。</p><p>来看一个例子 ， 图 3-34a 中的函数 P。它两次调用 Q。在第一次调用中 ，必 须保存 x 的值以备后面 使用。类似地， 在第二次调用中 ， 也必须保存 Q (y ) 的值。图 3-346 中， 可以 看到 GCC 生成的代码使用了 两个被调用 者保存 寄存器：%r b p 保存 x 和%r b x 保存计算出来的</p><p>long P(long x, long y)</p><p>｛</p><p>long u = Q(y); long v = Q(x); return u + v;</p><p>｝</p><p>a ) 调用函数</p><p>long P(long x, long y)</p><table><thead><tr><th></th><th>x in %rdi ,</th><th>y in %rsi</th><th></th></tr></thead><tbody><tr><td>1</td><td>P:</td><td></td><td></td></tr><tr><td>2</td><td>pushq</td><td>%rbp</td><td>Save ¼r bp</td></tr><tr><td>3</td><td>pushq</td><td>%rbx</td><td>Sa ve r¼ bx</td></tr><tr><td>4</td><td>subq</td><td>$8, %rsp</td><td>Align stack frame</td></tr><tr><td>5</td><td>movq</td><td>%rdi, %rbp</td><td>Save x</td></tr><tr><td>6</td><td>rnovq</td><td>%rsi, %rdi</td><td>Move y to first argument</td></tr><tr><td>7</td><td>call</td><td>Q</td><td>Call Q(y)</td></tr><tr><td>8</td><td>rnovq</td><td>%rax, %rbx</td><td>Save result</td></tr><tr><td>9</td><td>movq</td><td>%rbp, %rdi</td><td>Move x to first argument</td></tr><tr><td>10</td><td>call</td><td>Q</td><td>Call Q(x)</td></tr><tr><td>11</td><td>addq</td><td>%rbx, %rax</td><td>Add saved Q(y) to Q( x) ·</td></tr><tr><td>12</td><td>addq</td><td>$8, %rsp</td><td>Deallocate last part of stack</td></tr><tr><td>13</td><td>popq</td><td>%rbx</td><td>Restore %rbx</td></tr><tr><td>14</td><td>popq</td><td>%rbp</td><td>Res t or e r 妇 bp</td></tr><tr><td>15</td><td>ret</td><td></td><td></td></tr></tbody></table><p>b ) 调用函数生成的汇编代码</p><p>图 3-34 展示被调用者保存寄存器使用的代码。在第 一次调用中 ， 必须保存 x 的值 ， 第二次调用中 ， 必须保存 Q( y ) 的值</p><p>Q (y ) 的值。在函数的开头 ， 把这两个寄存 器的值保存到栈中（第2~ 3 行）。在第一 次调用 Q</p><p>之前， 把参数 x 复制到 %r bp ( 第 5 行）。在第二次调用Q 之前， 把这次调用的结果复制到 %r bx</p><p>（第8 行）。在函数的结尾 ，（第1 3 ~ 1 4 行）， 把它们从栈中弹出 ， 恢复这两个被调用者保存寄存器的值。注意它们的弹出顺序与压入顺序相反，说明了栈的后进先出规则。</p><p>亡 练习题 3. 34 一个 函数 P 生成名 为 a 0~ a 7 的 局部 变 量 ， 然后调 用 函 数 Q, 没 有参数。</p><p>GCC 为 P 的 第一部分 产 生如下代码 ：</p><p>long P(long x) x in %rdi</p><p>P:</p><table><thead><tr><th>2</th><th>pushq</th><th>．r儿 15</th></tr></thead><tbody><tr><td>3</td><td>pushq</td><td>%r14</td></tr><tr><td>4</td><td>pushq</td><td>%r13</td></tr><tr><td>5</td><td>pushq</td><td>%r12</td></tr><tr><td>6</td><td>pushq</td><td>%rbp</td></tr><tr><td>7</td><td>pushq</td><td>%rbx</td></tr><tr><td>8</td><td>subq</td><td>$24, %rsp</td></tr><tr><td>9</td><td>movq</td><td>。r 儿 di , %rbx</td></tr><tr><td>10</td><td>leaq</td><td>1(%rdi), ;r儿 15</td></tr><tr><td>1 1</td><td>leaq</td><td>2(%rdi), %r14</td></tr><tr><td>12</td><td>leaq</td><td>3(%rdi), %r13</td></tr><tr><td>13</td><td>leaq</td><td>4(%rdi), %r12</td></tr><tr><td>14</td><td>leaq</td><td>5(%rdi), %rbp</td></tr><tr><td>15</td><td>leaq</td><td>6(%rdi), %rax</td></tr><tr><td>16</td><td>movq</td><td>%rax, (%rsp)</td></tr><tr><td>1 7</td><td>leaq</td><td>7(%rdi), %rdx</td></tr><tr><td>18</td><td>movq</td><td>%rdx, 8(%rsp)</td></tr><tr><td>19</td><td>movl</td><td>$0, %eax</td></tr><tr><td>20</td><td>call</td><td>Q</td></tr></tbody></table><ol><li><p>确定哪些局部值存储在被调用者保存寄存器中。</p><ol><li><p>确定 哪 些局部 变量存储在栈 上。</p><p>c. 解释 为 什 么不能把所有的局部值都 存储在被调用老保 存寄 存器 中。</p></li></ol></li><li><p>7. 6 递归过程</p><p>前面已 经描述的寄 存器和栈 的惯例使得 x8 6- 64 过程能够递归地调用它们自身。每个过程调用 在栈中都有它自己 的私有空间 ， 因此多个未完成 调用的局部变量 不会相互影响 。此外，栈的原则很自然地就提供了适当的策略，当过程被调用时分配局部存储，当返回时 释放存储 。</p><p>图 3- 35 给出了 递归的阶乘函数的 C 代码 和生 成的汇编代码。可以 看到汇编代码使用寄存器%r b x 来保存参数 n , 先把巳有的值保存在栈上（第2 行），随 后在返回前恢复该值</p><p>（第 11 行）。根据栈的使用特性 和寄存器保 存规则 ， 可以 保证当递归调用r f a c t (n - 1 ) 返回时（第9 行）， (1 ) 该 次调用的结果会保存在寄存器%r a x 中， ( 2 ) 参数 n 的值仍然 在寄存器% r b x 中。把这两个值相乘就能 得到期望的 结果。</p><p>从这个例子我们可以 看到 ， 递归调用一个函数本身 与调用其他函数是一样的。栈规则提供了一种机制， 每次 函数调用 都有它自己 私有的状态信息（保存的返回位置和被调 用者保存寄存器的值）存储空间。如果需 要， 它还可以 提供 局部变量的存储。栈分配和释放的</p></li></ol><p>规则很自然 地就与函数 调用－返回的顺序匹配。这种实现函数调用和返回的方法甚至对更复杂的 情况也适用 ， 包括相 互递归调用（例如， 过程 P 词用 Q , Q 再调用 p ) 。</p><p>longr fa ct (l ong n)</p><p>｛</p><p>long result;</p><p>辽 (n &lt;= 1)</p><p>result= 1;</p><p>else</p><p>result= n *r fact(n-1);</p><p>return result;</p><p>｝</p><ol><li>C代码</li></ol><p>long rfact(long n) n in %rdi</p><p>rfact:</p><p>pushq movq movl cmpq jle leaq call imulq</p><p>.135:</p><p>popq ret</p><p>%r b x</p><p>%rdi, %rbx</p><p>$1, %ea x</p><p>$1, %rdi</p><p>. L35</p><p>-1(%rdi), %rdi rfact</p><p>%rbx, %rax</p><p>%rbx</p><p>Save %rbx</p><p>Store n in callee-saved register Set return value = 1</p><p>Compare n: 1</p><p>If &lt;=, goto done Compute n-1</p><p>Callr f act (n-1)</p><p>加 l t i pl y result by n done :</p><p>Restore %rbx Return</p><p>b ) 生成的汇编代码</p><p>图 3-35</p><p>a 练习题 3. 35</p><p>递归的阶乘程序的代码。标准过程处理机制足够用来实现递归函数</p><p>一个具有通用 结构的 C 函 数如下：</p><p>long rfun(unsigned long x) { if ( - - &mdash;- - )</p><p>return - '</p><p>unsigned long nx = ; longr v = rfun(nx);</p><p>return &ndash; '</p><p>｝</p><p>GCC 产 生 如下 汇 编代 码 ：</p><p>long rfun (uns i gned long x) x in %rdi</p><p>rfun:</p><p>pushq movq movl testq</p><p>%rbx</p><p>%rdi, %rbx</p><p>$0, %eax</p><p>%rdi, %rdi</p><table><thead><tr><th>6</th><th>je</th><th>.12</th></tr></thead><tbody><tr><td>7</td><td>shrq</td><td>$2, %rdi</td></tr><tr><td>8</td><td>call</td><td>rfun</td></tr><tr><td>9</td><td>addq</td><td>%rbx, %rax</td></tr><tr><td>10</td><td>.12:</td><td></td></tr><tr><td>11</td><td>popq</td><td>%rbx</td></tr><tr><td>12</td><td>ret</td><td></td></tr></tbody></table><ol><li>r f u n 存储在被调用 者保 存寄 存器%r b x 中的值 是什 么？</li><li>填写上述 C 代码 中缺 失的 表达 式。</li></ol><p>3. 8 数组分配和访问</p><p>C 语言中的数组是一种将标量数据聚集成更大数据类型的方式。 C 语言实现数组 的方式非常简单 ， 因此很容易 翻译成机器代码。 C 语言的一个不同寻常的 特点是可以产生指向数组中元素的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算。</p><p>优化编译器非 常善于简化数组索引 所使用的 地址计算 。不过这使 得 C 代码和它到机器代码的翻译之间的对应关系有些难以理解。</p><p>3. 8. 1 基本原则</p><p>对于数据类型 T 和整型常数 N , 声明如下：</p><p>T A[N];</p><p>起始位 置表示 为 环。这个声明有两个效果。首先 ， 它在内存中分配一个 L • N 字节的连续</p><p>区域， 这里 L 是数据类型 T 的大小（单位为字节）。其次 ， 它引入了标识符 A , 可以用 A 来作为指向 数组开头的 指针， 这个指针的值就是 X A 。 可以 用 O~ N -1 的整数索引来访问该数</p><p>组元素。数组元 素 z 会被存放 在地址 为 X A +L. i 的地方。作为示例，让我们来看看下面这样的声明：</p><p>char A[12];</p><p>char *B[8];</p><p>int C [6]; double *D[5];</p><p>这些声明会产生带下列参数的数组：</p><table><thead><tr><th>数组</th><th>元素大小</th><th>总的大小</th><th>起始地址</th><th>元素 t</th></tr></thead><tbody><tr><td>A B C D</td><td>1 8 4 8</td><td>12 64 24 40</td><td>x. Xa Xe 工·o</td><td>乓卢- l xs +, 8 xc+4, X 。+ B,</td></tr></tbody></table><p>数组 A 由 1 2 个单字节 ( c h ar ) 元素组成 。数组 C 由 6 个整数组成 ， 每个需 要 8 个字节。</p><p>B 和 D 都是指针数组 ， 因此每个数组元 素都是 8 个字节。</p><p>x8 6- 64 的内存引用指令可以用来简化数组访问。例如， 假设 E 是一个 i n t 型的数组， 而我们 想计算 E [i], 在此， E 的地址存放在寄存器%r d x 中， 而 l 存放在寄存器%r c x 中。然后，指令</p><p>movl (%rdx, %rcx, 4) , i儿e ax</p><p>会执行地址计算 XE+ 4 i , 读这个内 存位置的值， 并将结果存放到寄 存器%e a x 中。允许的</p><p>伸缩因子 1 、2 、4 和 8 覆盖了所有基本简单 数据类型的 大小。</p><p>江 练习题 3. 36 考虑下面的声明：</p><p>short 8[7];</p><p>short *T [3] ; short **U [6] ; int V[8]; double *W[4];</p><p>填写下表 ， 描述每个 数 组的 元 素大小 、整个 数 组的 大小 以及 元 素 t 的地 址：</p><table><thead><tr><th>数组</th><th>元素大小</th><th>整个数组的大小</th><th>起始地址</th><th>元素 t</th></tr></thead><tbody><tr><td>s</td><td></td><td></td><td>工s</td><td></td></tr><tr><td>T</td><td></td><td></td><td>.rr</td><td></td></tr><tr><td>u</td><td></td><td></td><td>Xu</td><td></td></tr><tr><td>V</td><td></td><td></td><td>.rv</td><td></td></tr><tr><td>付</td><td></td><td></td><td>.:rw</td><td></td></tr></tbody></table><p>3. 8. 2 指针运算</p><p>C 语言允许对指针进行 运算 ， 而计算出来的 值会根据该 指针引 用的数据类型的 大小 进行伸缩。也 就是说 ， 如果 p 是一个指向类型 为 T 的数据的指针， p 的值为 芬， 那么表达式p+ i 的值为 丐+ L • i, 这里 L 是数据类型 T 的大小。</p><p>单操作数操作符｀矿和&rsquo;*&lsquo;可以产生指针和间接引用指针。也就是，对千一个表示某 个对象的 表达式 Ex pr , &amp;Ex pr 是给出该对象地址的一个指针。对于一 个表示地址的表达式 AExpr , *AEx pr 给出该 地址处的 值。因此 ， 表达式 Exp r 与* &amp;Ex pr 是等价的。可以 对数组和指针应用数组下 标操作。数组引 用 A [ i ) 等同千表 达式 * (A+ i ) 。 它计算第 z 个数组元素的地址，然后访问这个内存位置。</p><p>扩展一下前面的例子， 假设整型数组 E 的起始地址和整数索引 z 分别存放在寄存器</p><p>%r dx 和%r c x 中。下 面是一些 与 E 有关的表达式 。我们还给出 了每个 表达式 的汇编代码实现， 结果存放在寄 存器 %e a x ( 如果是 数据）或寄存器 %r a x ( 如果是指针）中。</p><table><thead><tr><th>表达式</th><th>类型</th><th>值</th><th>汇编代码</th></tr></thead><tbody><tr><td>E</td><td>int*</td><td>工E</td><td>movq % r dx , % r a x</td></tr><tr><td>E[O]</td><td>int</td><td>M[ .r r.]</td><td>mo v l ( % r dx ) , 另r a x</td></tr><tr><td>E [i )</td><td>int</td><td>M 妇 + 4,]</td><td>movl ( % r dx, 毛 r c x , 4 ) , %e a x</td></tr><tr><td>&amp;E[2]</td><td>int*</td><td>工 E+ 8</td><td>leaq 8( % r dx ) , 毛 r a x</td></tr><tr><td>E+i-1</td><td>int*</td><td>工E 十如一4</td><td>l e aq - 4 ( 毛r d x, 毛r c x, 4 ) , %r a x</td></tr><tr><td>* (E+i-3)</td><td>int</td><td>M伍 + , 4 - 1 2]</td><td>mo v l - 1 2 ( %r d x, %r c x , 4 ) , %e a x</td></tr><tr><td>&amp;E[i}-E</td><td>long</td><td>l</td><td>movq %r c x , % r a x</td></tr></tbody></table><p>在这些 例子中 ， 可以 看到返 回数组值的操作类型为 i n t , 因此涉及 4 字节操作（例如</p><p>mov l ) 和寄存器（例如%e a x ) 。 那些返回指针的操作类型为 i n t * , 因此涉及 8 字节操作</p><p>（例如 l e a q ) 和寄存 器（例如%r a x ) 。最后一个例子表明 可以 计算同一个数据结构中的两个指针之差 ， 结果的数据类型为 l o ng , 值等于两个地址之差除以该数据类型的大小。</p><p>江 练习题 3. 37 假设短 整 型 数 组 s 的 地 址 X s 和 整 数 索引 1 分 别 存 放 在 寄 存 器%r d x 和</p><p>% r c x 中。 对下 面每个表 达 式， 给出 它的 类型 、值的表达 式和 汇编代码 实现。 如果 结果</p><p>是指针 的话 ， 要保 存 在 寄 存 器%r a x 中 ， 如果数 据 类 型 为 s h or t , 就保存在寄存器元素 %a x 中。</p><table><thead><tr><th>表达式</th><th>类型</th><th>值</th><th>汇编代码</th></tr></thead><tbody><tr><td>S+ 1</td><td></td><td></td><td></td></tr><tr><td>S [ 3]</td><td></td><td></td><td></td></tr><tr><td>&amp;S [ i j</td><td></td><td></td><td></td></tr><tr><td>S [4 *i + l]</td><td></td><td></td><td></td></tr><tr><td>S+ i-5</td><td></td><td></td><td></td></tr></tbody></table><p>3. 8. 3 嵌套的数组</p><p>当我们创建 数组的数组时 ， 数组分 配和引 用的 一般原则也是 成立的。例如 ， 声明</p><p>int A [ 5 ] [ 3 ] ;</p><p>等价于下 面的声明</p><p>typedef int r ow3 _t [ 3) ; row3_t A[5 ] ;</p><p>数据类型r o w3 —t 被定义为一个 3 个整数的 数组。数组 A 包含 5 个这样的元素， 每个 元素需要 1 2 个字节来 存储 3 个整数 。整个数 组的大小就是 4 X 5 X 3 = 6 0 字节。</p><p>数组 A 还可以 被看成一个 5 行 3 列的二维数组， 用 A [ O ] [ 0 ] 到 A [ 4 ) [ 2 ] 来引用。数组元素在内存中按照“行优先” 的顺序排列 ， 意味着第 0 行的所有元素， 可以 写作 A [OJ, 后面跟着第 1 行的所有元 素 ( A [l]), 以此类推， 如图 3- 3 6 所示。</p><p>这种 排列顺 序是嵌 套声明的结果。将 A 看作一个有 5 个元素的数组 ， 每个元素都 是 3 个 i n t 的数组， 首先是 A [OJ, 然后 是 A [ l ] , 以此类推。</p><p>要访问多维数组的 元素 ， 编译 器会以数组 起始为基地址，</p><p>（可能需要经过伸缩的）偏移量为索引 ， 产生计算期望的元素的偏移量， 然后使用某种 MO Y 指令。通常来说， 对 千一个声明如下的数组 ：</p><p>T D[R ] [CJ;</p><p>它的数组元素 D [ i l [ j J 的内存地址 为</p><p>& D [ i ] [ j ] = 工 。 十 L &lt;C • i + j ) (3.1)</p><p>这里 ， L 是数据类型 T 以字节为单 位的大小。作为一个示例，</p><p>图 3-36 按照行优先顺序</p><p>存储的数组元素</p><p>考虑前 面定 义的 5 X 3 的整型数组 A。假设 石、1 和）分别 在寄存器%r d i 、%r s i 和% r d x 中。然后 ， 可以用下面的 代码将数组元 素 A [i] [ j l 复制到 寄存器%e a x 中：</p><p>A in % 过 i&rsquo; 工 i n %rsi, and j i n %rdx</p><p>l e a q ( %r s i , %r s i , 2 ) , %r ax</p><p>l e a q ( %r d i , %r a x , 4 ) , %rax mov l (%rax,%rdx,4), %eax</p><p>Compute 31 Compute xA + 12,</p><p>Read from M[xA + 12i + 4 八</p><p>正如可以 看到的那样 ， 这段代码计算 元素的地址为 XA + 1 2 i + 4j = x A + 4C 3 i 十 j )&rsquo; 使用了</p><p>x8 6 - 6 4 地址运算的 伸缩和加法特性 。</p><p>诠 练 习 题 3. 38</p><p>long P [M] [NJ ;</p><p>long Q [NJ [M] ;</p><p>考 虑下 面的 源 代码 ， 其 中 M 和 N 是 用 # d e f i ne 声明 的 常数 ：</p><p>long sum_element(long i, long j) { return P [i] [j] + Q [j] [i] ;</p><p>｝</p><p>在编译这个程 序 中 ， GCC 产 生 如下 汇编 代 码 ：</p><p>long sum_element(long i , l ong j) i in %rdi , j in %rsi sum_element:</p><p>leaq O (, %rdi, 8), %rdx subq %rdi, %rdx</p><p>addq %rsi, %rdx</p><p>leaq (%rsi,%rsi,4), %rax addq %rax, %rdi</p><p>movq Q (, %rdi,8), %rax addq P(, %rdx,8), %rax ret</p><p>运用 逆 向 工程 技 能 ， 根据这 段 汇编 代 码 ， 确定 M 和 N 的值。</p><p>3. 8. 4 定长数组</p><p>C 语 言 编译器能够优化定长多维数组上的操作代码。这里我们展示优化等级设置为－</p><p>01 时 GCC 采用的一些优化。假设我们用如下方式将数据类型 f i x _ ma tr i x 声 明 为 16 X 16</p><p>的整型数组：</p><p>#define N 16</p><p>_ t ypedef int fix_matrix [NJ [NJ ;</p><p>（这个例子说明了一个很好的编码习惯。当程序要用一个常数作为数组的维度或者缓 冲区的大小时，最好通过# d e f i ne 声明将这个常数与一个名字联 系起来， 然后 在后面一直使用这个名字代替常数的数值。这样一来，如果需要修改这个值，只用简单地修改这个＃ def i ne 声明就可以 了。）图3-3 7a 中的代码计算矩阵 A 和 B 乘积的元素 i , k, 即 A 的 行 t 和</p><p>B 的列 k 的 内 积 。 G CC 产生的代码（我们再反 汇编成 C )&rsquo; 如图 3-3 7 b 中函数 f i x—pr o d _</p><p>e i e _o p t 所示。这段代码包含很多聪明的优化。它去掉了整数索引 j , 并把所有的数组弓I 用都转换 成了指针间接引用，其 中 包 括(1 ) 生成一个指针，命 名为 Ap t r , 指向 A 的 行 1 中连续的元素； ( 2 ) 生成一个指针，命 名为 Bp tr , 指向 B 的 列 k 中连续的元素； ( 3 ) 生成一个指 针，命 名为 Be nd , 当需要终止该循环时， 它 会等于 Bp tr 的 值。Ap tr 的 初始值是 A的行 1 的 第一个元素的地址， 由 C 表达式 &amp;A [ i ) [ O J 给出。Bp tr 的 初始值是 B 的列 k 的 第一个元素的地址， 由 C 表达式 &amp;B [ O J [ k l 给出。Be n d 的 值是 假想中 B 的列）的第 C n + l) 个元素的 地址， 由 C 表达式 &amp;B [NJ [ k ) 给出。</p><p>下面给出 的是 GCC 为函数 f i x _ pr o d _ e l e 生成的这个循环的实际汇编代码。我们看到 4 个寄存器的使用如下： %e a x 保 存 r e s u l 七，%r 土 保存 Ap t r , % r c x 保存 Bp tr , 而%r s i 保 存 Be nd 。</p><p>I* Compute i,k of fixed matrix product *I</p><p>int fix_prod_ele (fix_matrix A, fix_matrix B, long i, long k) { long j;</p><p>int result= O;</p><p>for (j = 0; j &lt; N; j++)</p><p>result += A [i] [j] * B [j] [k] ; return result;</p><p>a ) 原始的C代码</p><p>I* Compute i,k of fixed matrix product *I</p><ol><li><p>int fix_prod_ele_opt(fix_matrix A, fix_matrix B, long i, long k) {</p></li><li><p>int *Aptr = &amp;A[i] [OJ; I* Points to elements in row i of A *I</p></li><li><p>int *Bptr = &amp;B[O] [k]; I* Points to elements in column k of B *I</p><p>5 int *Bend= &amp;B[N] [k]; I* Marks stopping point for Bptr *I int result= O;</p></li></ol><p>do {</p><p>result+= *Aptr * *Bptr; Aptr ++;</p><p>Bptr += N;</p><p>I* No need for initial test *I I* Add next product to sum *I I* Move Aptr to next column *I I* Move Bptr to next row *I</p><p>} while (Bptr != Bend);</p><p>12 return result;</p><p>13 }</p><p>I* Test for stopping point *I</p><ol><li><p>优化过的C代码</p><p>图 3-37 原 始的和优化过的 代码 ，该 代码计算定 长数组的 矩阵乘 积的元素 i , k。</p><p>编译器会自动完成这些优化</p><p>int fix_prod_ele_opt (fix_matrix A , fix_matrix B, long i, long k)</p><p>A in %rdi, Bin %rsi, i in %r dx , kin %rcx fix_prod_ele:</p><p>2 salq $6, %rdx Compute 64 * 1.</p><p>3 addq %rdx, %rdi Compute Aptr = xA + 64i = &amp;A [i] [OJ</p><p>4 leaq (%rsi, %rcx, 4) , %rcx Compute Bptr = x8 + 4k = &amp;B[OJ [k]</p><p>5 leaq 1024(%rcx), %rsi Compute Bend = x8 + 4k +1024 = &amp;B[N] [k]</p><p>6 movl $0, %eax Set result = 0</p><p>7 .17: l oop :</p></li></ol><p>movl (%rdi), %edx imull (%rcx), %edx addl %edx, %eax</p><p>addq $4, %rdi</p><p>addq $64, %rcx</p><p>cmpq %rsi, %rcx</p><p>jne .17</p><p>rep; ret</p><p>Read *Aptr</p><p>Mul t i pl y by *Bptr Add to result Increment Aptr ++ Increment Bptr += N</p><p>Compare Bptr : Bend If!=, got o loop Return</p><p>; 练习题 3. 39 利用 等式 3. 1 来解释图 3-376 的 C 代码中 Ap tr 、 Bptr 和 Be nd 的初始值计算（第3~ 5 行）是如何正确反映 f i x_p ro d—e l e 的 汇编代码中它们的计算 （第 3~ 5 行）的。</p><p>诠 练习题 3. 40 下 面的 C 代码将定 长数 组的对 角 线上的元 素设 置 为 v a l :</p><p>I* Set all diagonal elements to val *I</p><p>void fix_set_diag(fix_matrix A, int val) { long i;</p><p>for (i = 0; i &lt; N; i ++)</p><p>A[i] [i] = val;</p><p>｝</p><p>当以优 化等级 - 0 1 编译 时 ， GC C 产 生如下 汇编代 码 ：</p><p>fix_set_diag:</p><p>voi d fix_set_diag(fix_matrix A, int val)</p><p>A 立 1 %rdi , val in¼rsi movl $0, %eax</p><p>.113:</p><p>movl %esi, (%rdi, %rax) addq $68, %rax</p><p>cmpq $1088, %rax</p><p>jne .113</p><p>rep; ret</p><p>创建 一个 C 代码 程序 f i x _ s 包 _ d i a g _ o p t , 它使用类似于这段汇编代码中所使用</p><p>的优化 ， 风格 与图 3-37 b 中 的 代 码 一致。 使用 含有 参 数 N 的 表 达 式 ， 而不 是整 数 常量，使得 如果 重新定 义 了 N , 你的代码仍能够正确地工作。</p><p>3. 8. 5 变长数组</p><p>历史上 ， C 语言只支持大小 在编译时就能确定的多维数组（对第一维可能有些例外）。程序员需要变长数组时 不得不用 m a ll o c 或 call o c 这样的函数为这些 数组分配存储 空间 ， 而 且不得 不显式地 编码，用 行优先索引将多维数组映射到一维数组 ， 如公式( 3. 1) 所示。ISO</p><p>C吁引入了一种功能 ，允 许数组的维度是表达式 ， 在数组被分配的时候才计算出来。在变长数组的 C 版本中 ， 我们可以将一个数组声明如下 ：</p><p>int A [exprl] [expr2]</p><p>它可以作为 一个局部变量 ， 也可以作为一个 函数的参数 ， 然后在遇到 这个声明的时候， 通过对 表达式 ex p r l 和 ex pr 2 求值来确定数组的维度。因此， 例如要访问 n X n 数组的元素i,, j&rsquo; 我们可以 写一个如下的函数：</p><p>int var_ele(long n, int A[n] [n], long i, long j) { return A [i] [j] ;</p><p>参数 n 必须在参数A[n ] [n ] 之前， 这样函数就可以在遇到这个数组的时候计算出数组的维度。</p><p>GCC 为这个引 用函数产生的代码如下所示 ：</p><p>mt vra _el e (long n, int A [n] [n], long i, long j )</p><p>n in¼rdi, A in¼rsi, i in¼rdx, j in¼rcx var_ele:</p><p>imulq</p><p>%rdx, %rdi</p><p>Compute n · 1</p><p>leaq</p><p>Cir儿</p><p>s i , %r d i , 4 ) , %rax</p><p>Compute xA + 4(n · i)</p><p>movl ret</p><p>(%rax,%rcx,4), %eax</p><p>Read from M[ 入A + 4(11 · ,) + 4 八</p><p>正如注释所示， 这段代码计算元素 i&rsquo; j 的 地址为 工A + 4 ( n · i ) + 4j = xA + 4 ( n · i + 户。这个地址的计算类似千定 长数组的地址计算（参见 3. 8. 3 节）， 不同点在千 1) 由于增加了参数</p><p>n, 寄存器的使用变化了； 2 ) 用了乘法指令来计算 n · i( 第 2 行）， 而不是用 l e a q 指令来计</p><p>算 3i。因此引用变长数组只需要对定长数组做一点儿概括。动态的版本必须用乘法指令对</p><p>t 伸缩 n 倍 ， 而不能用一系列的移位和加法。在一些处理器中，乘 法会招致严重的性能处罚 ， 但是在这种情况中无可避免。</p><p>在一个循环中引用变长数组时，编译器常常可以利用访问模式的规律性来优化索引的 计算。例如， 图 3-38a 给出 的 C 代码， 它 计 算 两个 n X n 矩阵 A 和 B 乘积的元素 i , k 。</p><p>GCC 产生的汇编代码， 我们再重新变为 C 代码（图3-38b) 。这个代码与固定大小数组的优化代码（图3-37 ) 风格不同， 不过这更多的是编译器选择的结果 ， 而不是两个函数有什么根本的不同造成的。图 3-38 b 的 代码保留了循环变量 j&rsquo; 用 以 判定循环是否结束和作为到 A 的行 1 的元 素组成的数组的索引。</p><p>I* Compute i,k of variable matrix product *I</p><table><thead><tr><th>2</th><th>int</th><th>var_prod_ele(long n, int A[n] [n], int B[n] [n], long i, long k) {</th></tr></thead><tbody><tr><td>3</td><td></td><td>long j;</td></tr><tr><td>4</td><td></td><td>int result= O;</td></tr><tr><td>5</td><td></td><td></td></tr><tr><td>6</td><td></td><td>for (j = 0; j &lt; n; j++)</td></tr><tr><td>7</td><td></td><td>result += A[i] [j] * B[j] [k];</td></tr><tr><td>8</td><td></td><td></td></tr><tr><td>9</td><td></td><td>return result;</td></tr><tr><td>10</td><td>}</td><td></td></tr><tr><td></td><td></td><td>a ) 原始的C代码</td></tr></tbody></table><p>I* Compute i,k of variable matrix product *I</p><p>int var_prod_ele_opt(long n, int A[n] [n], int B[n] [n], long i, long k) { int *Arow = A[i];</p><p>int *Bptr = &amp;B[O] [k]; int result= O;</p><p>long j;</p><p>for (j = O; j &lt; n; j++) { result+= Arow[j] * *Bptr; Bptr += n;</p><p>｝</p><p>return result;</p><p>｝</p><p>b) 优化后的C代码</p><p>图 3&lt;l8 计算变长数组的矩 阵乘积的 元素 i , k 的原始代码 和优化后的 代码。编译 器自动执行 这些优化</p><p>下 面是 v ar —pr o d —e l e 的 循 环的汇编代码：</p><p>Regs工</p><p>t re</p><p>s : n i n r¼ di , Arow in¼rsi, Bptr in¼rcx 4n in %r9, result in¼eax, j in¼edx</p><p>.L24: l oop :</p><p>movl Cr 儿 s i , %r dx , 4 ) , %r8d imull (%rcx), %r8d</p><p>Read Arow[j]</p><p>Mul t i p l y by•Bptr</p><table><thead><tr><th>addl</th><th>%r8d, %eax</th><th>Add t o result</th></tr></thead><tbody><tr><td>addq</td><td>$1, %rdx</td><td>j++</td></tr><tr><td>addq</td><td>%r9, %rcx</td><td>Bptr += n</td></tr><tr><td>cmpq</td><td>%rdi, %rdx</td><td>Compare j:n</td></tr><tr><td>jne</td><td>.L24</td><td>If!=, goto loop</td></tr></tbody></table><p>我们看到 程序既使 用了伸缩过的值 4 n ( 寄存器%r 9) 来增加 Bp tr , 也使用了 n 的值（寄存器 %r 主 ）来检查循环的边界。C 代码中并没有体现出需要这两个 值， 但是由于指针运算的伸缩，才使用了这两个值。</p><p>可以看到 ， 如果允许使用优化， GCC 能够识别出程序访问多维数组的元素的步长。然后生 成的代码会避免 直接应 用等式 ( 3. 1) 会导致的乘法。不论生成基于指针的 代码（图3- 37b)还是基于数组的代码（图 3-38b) , 这些优化都能显著提高程序的性能。</p><ol><li><p>9 异质的数据结构</p><p>C 语言提供了 两种将不同类型的对象组合到一起创建数据类型的机制： 结 构 ( s t ru c­ ture) , 用关键字 s 七r u 吐 来声明， 将多个对象 集合到一个单位中； 联合 ( u nio n ) , 用关键字 un i o n 来声明，允 许用几种不同的 类型来引 用一个对象。</p></li></ol><p>3. 9. 1 结构</p><p><img src=img/79854afb15357bc8f3e7350eb69d4e1d.jpeg alt>C 语言的 s tr u c t 声明创建一个数据类型 ， 将可能不同 类型的 对象聚合到一 个对象 中。用名字来引用结构的各个组成部分。类似于数组的实现，结构的所有组成部分都存放在内 存中一段连续 的区域内， 而指向结 构的指针就是结 构第一个字节的 地址。编译器维护关于每个结构类型的信息 ， 指示每个字段（如 Id ) 的字节偏移。它以 这些偏移作为内 存引用指令中的位移 ， 从而产生 对结构元素的引用。</p><p>， 3 将一个对 象表 示为s 七r u e 七</p><p>·c语言提供的 s tr uc t 数据类型的构造函数(cons tru ctor) 与 C++ 和 Java 的对象最为接近。</p><p>它允许程序员在一个数据结构中保存关于某个实体的信息，并用名字来引用这些信息。 例如，一个图形程序可能要用结构来表示一个长方形：</p><p>struct rect {</p><p>long llx; I*X coordinate of lower-left corner *I</p><p>long lly; I*Y coordinate of lower-left corner *I</p><p>unsigned long wi dt h ; I* Width (in pixels) ＊／</p><p>unsigned long height; I* Height (in pixels) ＊／</p><p>unsigned color; I* Coding of color ＊／</p><p>};</p><p>可以声明 一个 s tr u c t r e c t 类型的 变量r , 并将它的字段值设置如下：</p><p>struct rect r; r.llx = r.lly = O; r.color = OxFFOOFF; r.width = 10;</p><p>r.height = 20;</p><p>这里表达式 r . l l x 就会选择结构r 的 l l x 字段。</p><p>另外，我们可以在一条语句中既声明变量又初始化它的宇段：</p><p>struct rectr = { 0, 0, 10, 20 , OxFFOOFF } ;</p><p>将指向结构的指针从一个地方传递到另一个地方，而不是复制它们，这是很常见的。例如，下面的函数计算长方形的面积，这里，传递给函数的就是一个指向长方形s tr uc 七的指针：</p><p>long area(struct rect *rp) {</p><p>return (*rp).width * (*rp).height;</p><p>｝</p><p>表达式 (*r p ) . wi d t h 间接 引 用 了 这个指针， 并且 选取 所得 结构的 wi d t h 字段 。 这里必须要 用括 号， 因 为 编译器会 将 表 达式 *r p . wi d t h 解释 为 * (rp.width), 而这是非法的 。间接 引 用和字段 选取结合起 来使 用非 常常见，以 至 于 C 语言提供了一种替代的表示法－＞ 。 即 r p - > wi d t h 等价于表 达式 (*r p ) . wi d t h 。 例如 ， 我们可以 写一个函数， 它将 一个长方形顺时针旋转 90 度 ：</p><p>void rotate_left(struct rect *rp) { I* Exchange width and height *I long t = rp->height;</p><p>rp->height = rp->width; rp->width = t;</p><p>I* Shift to new lower-left corner *I rp->llx -= t;</p><p>｝</p><p>C++ 和 J ava 的对象比 C 语言中的 结构要复杂精 细得 多 ， 因 为 它们将一组可以 被调用 来执行计算的方 法与一个对象联 系起 来。在 C 语言中， 我们可以 简 单地把这些 方 法写成普通函数 ， 就像上面所示的 函数 ar e a 和r o七a t e —l e f t 。</p><p>让 我们来看看这样一个例子，考 虑 下 面这样的结构声明 ：</p><p>struct rec { inti; int j; inta[2]; int *p;</p><p>};</p><p>这个结构包括4 个 字段： 两个 4 字节 i n t 、一个由两个类型为 i n t 的元素组成的数组和一个 8 字节整型指针，总 共 是 24 个字节：</p><p>偏移 0</p><p>内容 ［＿二</p><p>a [OJ a[l]</p><p>16 24</p><p>可以观察到，数 组 a 是嵌入到这个结构中的。上图中顶部的数字给出的是各个字段相对于结构开始处的字节偏移。</p><p>为了访问结构的字段，编译器产生的代码要将结构的地址加上适当的偏移。例如，假 设 s tr uc t r e c * 类型的变最r 放在寄存器%r 生 中 。 那 么 下 面的代码将元素r - >i 复制到元 素r - > j :</p><p>Regsi</p><p>t esr</p><p>:r in r% d 工</p><p>movl (%rdi), %eax movl %eax, 4(%rdi)</p><p>Getr - >1. Store in r->j</p><p>因为字段 1 的偏移盘为 o , 所以这个字段的地址就是r 的值。为了存储到字段 j , 代码要</p><p>将 r 的地址加上偏移量 4 。</p><p>要产生一个指向结构内部对象的指针，我们只需将结构的地址加上该字段的偏移量。 例如，只用 加上偏移量 8 + 4 X l = l 2 , 就可以 得 到指针 & (r - >a [ l ] ) 。 对于在寄存器%r d i 中的指针 r 和在寄存器%r s i 中 的 长整数变量 i , 我们可以用一条指令产生指针& (r->a [i ]) 的值：</p><p>Registers:r in %rdi, i %sr 工</p><p>leaq 8(%rdi,%rsi,4), %rax Set %rax to &amp;r->a [i)</p><p>最后举一个例子，下面的代码实现的是语句：</p><p>r->p = &amp;r->a[r->i + r->j];</p><p>开始 时 r 在寄存器%r 土 中 ：</p><p>Registers:r in %rd1.</p><table><thead><tr><th>movl addl cltq</th><th>4(%rdi), %eax (%rdi), %eax</th><th></th><th>Get r->J Add r->i Extend to 8 bytes</th></tr></thead><tbody><tr><td>leaq movq</td><td>8(%rdi,%rax,4), %rax, 16(%rdi)</td><td>%rax</td><td>Compute &amp;r->a[r->i + r->j] Store in r->p</td></tr></tbody></table><p>综上所述，结构的各个字段的选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息。</p><p>讫 练习题 3. 41 考虑下面的结构声明：</p><p>struct prob { int *p; struct {</p><p>int x; int y;</p><p>} s;</p><p>struct prob *next;</p><p>};</p><p>这个声明说明一个结构可以嵌套在另一个结构中，就像数组可以嵌套在结构中、数组可以嵌套在数组中一样。</p><p>下面的过程（省略了某些表达式）对这个结构进行操作：</p><p>void sp_init(struct prob *sp) { sp->s.x = ，</p><p>sp->p = ，</p><p>sp->next = ，</p><p>｝</p><ol><li><p>下列字段的偏移量是多少（以字节为单位）？</p><p>p: s.x:</p><p>s.y:</p><p>next:</p><ol><li>这个结构总共需要多少字节？</li><li>编译器为 s p _ i 汇 t 的 主体产 生 的 汇编 代码 如下 ：</li></ol></li></ol><p>void sp_init(struct prob *sp) sp in %rdi</p><p>s p_i ni t :</p><p>movl movl leaq movq movq ret</p><p>12(%rdi), %eax</p><p>%eax, 8 (%r d沁 8(%rdi), %rax</p><p>%rax, (%rdi)</p><p>%rdi, 16(%rdi)</p><p>根据这 些 信息 ， 填写 s p _ i 工 t 代码 中缺 失的表达 式 。</p><p>练习题 3. 42 下 面 的代 码 给 出 了 类 型 ELE 的结构声 明 以及 函 数 f u n 的原 型：</p><p>struct ELE {</p><p>long v; struct ELE *p;</p><p>};</p><p>long fun(struct ELE *ptr);</p><p>当 编译 f u n 的代码 时 ， GCC 会 产 生 如下 汇 编代码 ：</p><p>long f un (s rt ptr in %rdi fun:</p><p>movl jmp</p><p>.L3:</p><p>addq movq</p><p>.L2:</p><p>testq jne</p><p>uct ELE•ptr)</p><p>$0, %eax</p><p>.L2</p><p>(%rdi), %rax 8(%rdi), %rdi</p><p>%rdi, %rdi</p><p>.L3</p><p>rep; ret</p><ol><li>利 用 逆 向 工 程 技 巧 写 出 f u n 的 C 代码 。<ol><li>描述这个结 构 实 现的 数 据结 构 以 及 f u n 执行的操 作。</li></ol></li></ol><p>3. 9. 2 联合</p><p>联合提供了一种方式，能 够 规避 C 语言的类型系统 ， 允 许 以 多 种 类型来引用一个对象 。 联合声明的语法与结构的语法一样，只 不过语义相差比较大。它们是用不同的字段来引 用 相同的内存块。</p><p>考虑下面的声明：</p><p>struct S3{</p><p>char c; int i[2]; double v;</p><p>};</p><p>union U3 {</p><p>char c; int i [2]; double v;</p><p>};</p><p>在一台 x86- 64 Linux 机器上编译时 ， 字段的偏移最、数据类型 S3 和 U3 的完整大小如下：</p><p>类型 C V 大小</p><h4 id=heading>。
<a class=anchor href=#heading>#</a></h4><p>（稍后会解 释 S3 中 l 的偏移最为什么是 4 而不是 1&rsquo; 以 及为什么 v 的偏移量是 16 而不是 9 或 12 。)对千类型 un i o n U3 * 的 指 针 p , p-> C 、p - > i [ O ] 和 p - > V 引 用 的 都是数据结构的起始位 置。还可以 观察到， 一 个 联合的总的大小等于它最大字段的大小。</p><p>在一些 下上文中 ， 联合十分 有用。但是，它 也 能 引 起一些讨厌的错误， 因 为它们绕过了 C 语言类型系统提供的安全措施。一种应用情况是， 我们事先知道对一个数据结构中的两个不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一 部分 ， 会减小 分配空间的总量。</p><p>例如， 假设我们想实现一个二叉树的数据结构， 每个叶子节点都有两个 doub l e 类型的数据值 ， 而每个内部节点都有指向两个孩子节点的指针， 但是没有数据。如果声明如下：</p><p>struct node_s {</p><p>struct node_s *left; struct node_s *right; double data[2];</p><p>};</p><p>那么每个 节点需要 32 个字节 ， 每种类型的节点都要浪费一半的字节。相反， 如 果 我们如下声明一个节点 ：</p><p>union node_u { struct {</p><p>union node_u *left; union node_u *right;</p><p>} internal; double data[2];</p><p>} ;</p><p>那么 ， 每个 节点就只需要 1 6 个字节。如果 n 是一个指针， 指向 u n i o n no d e _ u *类型的节点， 我们 用 n - > d a 七a [ 0 ] 和 n - > d a t a [ l ] 来引用叶子节点的数据， 而用 n - > internal.</p><p><img src=img/f47a3f359bcca4d94f9c6cc3d885c62f.jpeg alt>typedef enurn { N_LEAF, N_INTERNAL} nodetype_t; struct node_t {</p><p>nodetype_t type; union {</p><p>struct {</p><p>struct node_t *left; struct node_t *right;</p><p>} internal; double data[2];</p><p>} info;</p><p>};</p><p>这个结构总共需 要 24 个字节： t ype 是 4 个字节 ， i n fo . i n t er na l . l e f t 和 i nfo . i 阰 e r na l . 豆 g h t 各要 8 个字节， 或者是 i n f o . d a t a 要 1 6 个字节。我们后面很 快会谈到， 在字段七yp e 和联合的元 素之间需 要 4 个字节的 填充， 所以 整个 结构大小 为 4 + 4 + 1 6 = 24 。在这种情况中，相对于给代码造成的麻烦，使用联合带来的节省是很小的。对于有较多字段的 数据结构，这样的节省会更加吸引人。</p><p>联合还可以用来访问不同数据类型的位模式。例如，假设我们使用简单的强制类型转换将一个 d o ub l e 类型的值 d 转换为 u ns i g ne d l o ng 类型的值 U :</p><p>unsigned long u = (unsigned long) d;</p><p>值 u 会是 d 的整数表示。除 了 d 的值为 0 . 0 的情况以外， u 的位表示会与 d 的很不一样。再看下面这段 代码 ， 从一个 d o ub l e 产生一个 u ns i g ne d l o ng 类型的值：</p><p>unsigned long double2bits(double d) { union {</p><p>doubled; unsigned long u;</p><p>} temp; temp.d = d;</p><p>return temp.u;</p><p>};</p><p>在这段代码中，我们以一种数据类型来存储联合中的参数，又以另一种数据类型来访 问它。结果会是 u 具有和 d 一样的 位表示， 包括符号位字段 、指数和尾数 ， 如 3. 11 节中描述的那样。 u 的数值与 d 的数值没有任何关 系， 除了 d 等于 0. 0 的 情况。</p><p>当用联合来将各种不同大小的数据类型结合到一起时，字节顺序问题就变得很重要 了。例如， 假设我们写了一 个过程， 它以两个 4 字节 的 u ns i g ne d 的位模 式， 创建一个 8 字节的 d o ub l e :</p><p>double uu2double(unsigned i.ordO, unsigned i.ord1)</p><p>｛</p><p>union {</p><p>doubled; unsigned u[2];</p><p>} temp;</p><p>temp.u[O] = wor dO ; temp.u[1] = word1; return temp.d;</p><p>｝</p><p>在 x86-64 这样的小端法 机器上 ， 参数 wor d O 是 d 的低位 4 个字节， 而 wo r d l 是高位</p><p>4 个字节 。在大端法机器上 ， 这两个参数的 角色刚好相反 。</p><p>; 练习题 3. 43 假设 给你个任 务， 检查 一下 C 编译 器 为 结 构 和联 合 的 访 问 产 生正 确的代码。你写了下面的结构声明：</p><p>typedef union { struct {</p><p>long u;</p><p>short v;</p><p>char w;</p><p>} t1;</p><p>struct {</p><p>int a[2]; char *p;</p><p>} t2;</p><p>} u_type;</p><p>你写 了一 组具 有下 面这种形 式的 函数 ：</p><p>void get (u_type *up, type *dest) {</p><p>*dest = expr;</p><p>｝</p><p>这组函数有不 一样的 访问 表达 式 ex p r , 而且 根据 ex p r 的 类 型 来设 置目 的 数 据 类 型 t y p e 。然后再检查编译这些函数时产生的代码，看看它们是否与你预期的一样。</p><p>假设在这 些函数 中 ， u p 和 d e s t 分别被 加 载 到寄 存器 %r d i 和 %r s i 中。 填 写 下表 中的数据类 型 ty p e , 并用 1 ~ 3 条指令 序列来计 算表达 式 ， 并将结果 存储到 d e s 七 中。</p><table><thead><tr><th>expr</th><th>type</th><th>代码</th></tr></thead><tbody><tr><td>up - >t l . u</td><td>long</td><td>movq ( %r d 切 ，r% a x movq r% a x, ( % r s i )</td></tr><tr><td>up - >t l . v</td><td></td><td></td></tr><tr><td>&amp;up->tl. w</td><td></td><td></td></tr><tr><td>up->t2.a</td><td></td><td></td></tr><tr><td>up->t2.a[up->tl.u)</td><td></td><td></td></tr><tr><td>*up->t2.p</td><td></td><td></td></tr></tbody></table><ol><li><p>. 3 数据对齐</p><p>许多计算 机系统对基本数 据类型的合法地 址做出了一些限制， 要求某种 类型对象的地址必须是某个值 K ( 通常是 2、 4 或 8) 的倍数。这种对齐限 制简化了形成处 理器和内存 系统之间接口 的硬件设 计。例如， 假设一个处理器总是从内存中取 8 个字节， 则地址必须为 8 的倍数 。如果我们能保证 将所有的 d o u b l e 类型数据的地址对齐成 8 的倍数， 那么就可以用一个内存操作来读 或者写值 了。否则， 我们 可能需 要执行 两次内存访问， 因为对象可能被分放在 两个 8 字节内存 块中。</p><p>无论数 据是否对齐， x8 6- 64 硬件都能正确工作。不过， I n t e l 还是建议要对齐数据以提高内存系统的性能 。对齐原则是 任何 K 字节的基本对象的地址必须是 K 的倍数。可以看到这条原则会得到如下对齐：</p></li></ol><p>确保 每种数 据类型都是 按照指定 方式来组织 和分配， 即每种 类型的对象都满足它的 对齐限制， 就可保证实施对 齐。编译 器在汇编代码中放入命令， 指明全局数据所需 的对齐。例如， 3. 6. 8 节开始的跳转 表的 汇编代码声明 在第 2 行包含下 面这样 的命令：</p><p>.align 8</p><p>这就保证 了它后面的数 据（在此， 是跳转表的开始）的起始地址是 8 的倍数。因为每个表项长 8 个字节 ， 后面的元素都 会遵守 8 字节 对齐的限 制。</p><p>对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都 满足它的 对齐要求 。而结构本身 对它的起始地址也 有一些对齐要求。</p><p>比如说 ， 考虑下面的 结构声明 ：</p><p>struct S1{</p><p>int i; char c; int j;</p><p>};</p><p>假设 编译器用最 小的 9 字节分 配， 画出图 来是 这样的 ：</p><p>偏移 0 4 5</p><p>内容I i I C I</p><p>它是不可能 满足字段 认偏移 为 0 ) 和 ］（偏移为5 ) 的 4 字节对齐要求的 。取而代 之地， 编译器在 字段 c 和 ］之间插入一 个 3 字节的 间隙（在此用蓝色阴影 表示）：</p><p>偏移 0 4 5 12</p><p>内容 I i IC I</p><p>结果， J 的偏 移晕 为 8&rsquo; 而 整 个结构的 大小 为 12 字 节。 此外， 编译 器必须保 证 任 何struct Sl * 类型的 指针 p 都满足 4 字节对 齐。用 我们前面的 符号， 设指针 p 的值为 Xp, 那么， X p必须是 4 的倍数。这就保证了 p - > i ( 地址 X p) 和 p - > j ( 地址 x p + S ) 都满足它们的 4 字节对齐要求 。</p><p>另外 ， 编译 器结构的末尾可能 需要一些填充， 这样结 构数组中的每个元 素都 会满 足它的对齐要求 。例如 ， 考虑下 面这个结 构声明 ：</p><p>struct S2{</p><p>int i ;</p><p>int j; char c;</p><p>};</p><p>如果 我们将这个结 构打包成 9 个字节，只 要保证结构的起始地址满足 4 字节对齐要求， 我们仍然能够保证满 足字段 l 和 J 的对齐要求。不过 ， 考虑下面的声明：</p><p>struct S2 d[4];</p><p>分配 9 个字节， 不可能满足 d 的每个元素的对齐要求 ， 因 为这些元索的地址分别为 互、xd+ 9、xct+ 1 8 和 孔+ 27。相反， 编译器会为结构 S2 分配 12 个字节 ，最后 3 个 字节是浪费的空间：</p><p>偏移 0 4 8 9 12</p><p>内容 I i I j I 叶</p><p>这样一来， d 的 元素的地址分别为 工心 Xct+ 1 2 、工ct + 24 和 工d + 36。 只 要 Xd 是 4 的 倍 数 ， 所有的 对齐限制就都可以满足了。</p><p>讫§ 练习题 3. 44 对下 面 每 个 结 构 声 明 ， 确 定每 个 字 段 的 偏 移 量 、 结 构 总 的 大 小 ， 以 及</p><p>在 x86-64 下 它的 对齐 要 求 ：</p><ol><li><p>struct P1 {inti; char c; int j ; char d; } ;</p><ol><li>struct P2 { int i; char c; char d; long j ; } ;<ol><li><p>struct P3 { short w [3] ; char c [3] };</p></li><li><p>struct P4 { short w [5] ; char *c [3] } ;</p></li><li><p>struct PS { struct P3 a [2] ; struct P2 t } ;</p><p>讫§ 练习题 3. 45 对于下列结构声明回答后续问题：</p><p>struct {</p><p>char *a;</p><p>short b，·</p><p>double c·，</p><p>char d.，</p><p>float e，·</p><p>char f ，·</p><p>long g;</p><p>int h ;</p><p>}r ec ;</p></li></ol></li></ol></li><li><p>这个结构中所有的字段的字节偏移量是多少？</p></li><li><p>这个结构 总 的 大小是 多少？</p></li><li><p>重新排列这个结构中的字段，以最小化浪费的空间，然后再给出重排过的结构的 字节偏移量和总的大小。</p><p>m 强制对齐的 情 况</p><p>对于大多数 x86- 64 指令 来说 ， 保 持 数 据对 齐能 够提 高 效率， 但是 它 不 会 影响程序的行 为。 另 一 方 面 ， 如 果数据没有对 齐， 某些型号的 Intel 和 AMD 处理 器 对于有些 实现多媒 体操作的 SS E 指令， 就无 法正确执行。这些 指令 对 16 字 节 数 据块进行操作 ， 在</p><p>SSE 单元和内存之间传送数据的指令要 求 内存地址必须是 16 的倍数。任何试图以 不 满足对 齐要 求的 地址未访问内存都会导致异常（参见 8. 1 节），默 认 的行为是 程序终止。</p><p>因此 ，任 何针对 x86-64 处理器的 编译 器和运行 时系统都必须保证分配用来保存 可能会被</p><p>SSE 寄存器读或 写的数据结构的 内存， 都必须满足 16 字节对 齐。这个要求有两个后 果：</p></li></ol><ul><li><p>任何内存分配函数 ( a l l o c a 、rna l l o c 、 c a l l o c 或r e a l l o c ) 生成的块的起 始地址都必须是 1 6 的倍数。</p></li><li><p>大 多数 函数的栈 帧的边界 都必须是 16 字节的倍数。（这个要 求有一些例 外。）</p><p><img src=img/69a7778ed7c340fbcbbc79a3db6b3cb3.jpeg alt>较近版本的 x86- 64 处理 器 实现了 A V X 多媒 体指令。除了 提 供 SSE 指令的超 集 ， 支</p><p>持 AVX 的指令并没有强 制性的对齐要 求。</p></li></ul><p>3. 10 在机器级程序中将控制与数据结合起来</p><p>到目前为止，我们已经分别讨论机器级代码如何实现程序的控制部分和如何实现不同 的数据结构。在本节中 ， 我们会看看数 据和控制如何交互 。首先， 深入审视一下指针， 它是 C 编程语 言中最重要的 概念之一 ， 但是许多 程序员 对它的 理解都非 常浅显 。我们复习符号调试器 GDB 的使用，用 它仔细检 查机器级程序的详细运行 。接下来， 看看理解机器级程序如何帮助我们研究缓冲区溢出，这是现实世界许多系统中一种很重要的安全漏洞。最 后，查看机器级程序如何实现函数要求的栈空间大小在每次执行时都可能不同的情况。</p><ol><li><p>10. 1 理解指针</p><p>指针是 C 语言的一个核心特色。它们以 一种统一方式， 对不同数据结构中的元素产生引用。对于编程新手来说，指针总是会带来很多的困惑，但是基本概念其实非常简单。在此，我们重点介绍一些指针和它们映射到机器代码的关键原则。</p><ul><li><p>每个指针都对应一个类型。这个类型表明该指针指向的是哪一类对象。以下面的指针声明为例：</p><p>int *ip; char **cpp;</p><p>变最 i p 是一个指向 i n t 类型对象的 指针 ，而 c p p 指针指向的 对象自身 就是一个指向c h a r 类型对象的 指针。通常 ， 如果 对象类型为 T , 那么指针的类型为 T * 。特殊的v o i d * 类型代表通用指 针。比 如说 ， ma 荨 o c 函数返回一个通用 指针， 然后 通过显式强制类型转换或者赋值操作那样的隐式强制类型转换，将它转换成一个有类型的 指针。指针类型不是 机器代码中的 一部分 ； 它们是 C 语言提供的一种抽象 ， 帮助程序员避免寻址错误。</p></li><li><p>每个指针 都有一个值。这个值是 某个 指定类型的 对象的地址。特殊的 NULL ( O) 值表示该指针没有指向 任何 地方 。</p></li><li><p>指针 用 ＇矿运 算 符 创 建。 这个运 算符可以应用 到任何 l v a l ue 类的 C 表 达式上， l v a l ue 意指可以 出现在赋值语句左边的表达式。这样的例子包括变量以及结 构、联合 和数组的 元素。我 们已经看到， 因为 l e a q 指令是设 计用来计算内存引用的地址的，＆运算符的机器代码实现常常用这条指令来计算表达式的值。</p></li><li><p>*操作符用于间接引用指针。其结果是一个值，它的类型与该指针的类型一致。间接引用是用内存引用来实现的，要么是存储到一个指定的地址，要么是从指定的地址读取。</p></li><li><p>数组与指针 紧密 联系。 一个数 组的名字可以 像一个指针变最一样引用（但是不能修改）。数组引用（例如a [ 3 ] ) 与指 针运算和间 接引 用（例如 * (a+ 3 ) ) 有一样的效果。数组引用和指针运算都需 要用对象大小对偏移量进行 伸缩。当我们写 表达式 p + i, 这里指 针 p 的值为 p , 得到的 地址计算 为 p + L · i , 这里 L 是与 p 相关联的 数据类型的大小。</p></li><li><p>将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。强 制类型转换的 一个效果是改 变指针运 算的伸缩。例如， 如果 p 是一个 c har * 类型的指针， 它的值为 p , 那么表达式 (i n t * ) p + 7 计算为 p + 28 , 而 (i n t *) (p+ 7) 计算为 p + 7。（回想一下， 强制类型转换的 优先级高千加法。）</p></li></ul></li></ol><ul><li><p>指针也可以指向函数。这提供了一个很强大的存储和向代码传递引用的功能，这些引用 可以被程序的某个其他部分调用 。例如， 如果我们有一个函数，用 下面这个原型定义：</p><p>int fun(int x, int *p);</p></li></ul><p>然后 ， 我们 可以声 明一个指针 f p , 将它赋值为这个函数，代码如下：</p><p>int (*fp)(int, int*); fp = fun;</p><p>然后用这个 指针来调 用这个函数：</p><p>int y = 1;</p><p>int result= fp(3, &amp;y);</p><p>函数指针的值是该函数机器代码表示中第一条指令的地址。</p><p>四亘正l王詈ll 函数指 针</p><p>函数指针声明的语法对程序员新手来说特别难以理解。对于以下声明：</p><p>int (*f)(int*);</p><p>要从里（从 " f " 开始）往外读。 因此 ， 我们看到像 " (* f ) " 表明的 那样 ， f 是一个指 针； 而 " (*f ) (i n t * ) " 表明 f 是一个指 向函数 的指针， 这个函数以一 个 辽比＊ 作为 参数。最后 ， 我们 看到 ， 它是 指向以 i n 七 ＊ 为参数并返回 i n t 的函数的 指针 。</p><p>*f 两边的 括号是 必需的 ， 否则声明 变成</p><p>int *fCint*);</p><p>它会被解读成</p><p>(int•) f(int•);</p><p>也就是说 ， 它会 被解释 成一 个函数原 型 ， 声明 了一 个函数 f , 它以 一个 l 让 ＊ 作为 参数并返 回一个 i n t * 。</p><p>K ern ig h a n 和 民tch ie [61, 5. 12 节］提供了一 个有 关阅读 C 声明的很 有帮助的教 程。</p><ol><li><p>10. 2 应用： 使 用 GDB 调试 器</p><p>GNU 的调试器 GDB 提供了许多有用的特性 ， 支持机器级 程序的 运行时评估和分析。对千本书中的示 例和练习， 我们试图通过阅读代码， 来推断出程序的行为。有了 GDB , 可以 观察正在运行的程序， 同时又对 程序的执行有相当的 控制， 这使得研究程序 的行为变 为可能 。</p><p>图 3-39 给出了 一些 GDB 命令的例子， 帮助研究机器级 x86-64 程序。 先 运行 OBJ­</p><p>DUMP 来获得程序的 反汇编版本， 是很有好处的。我们的示例都基于对文件 pr o g 运行</p><p>GDB, 程序的描述 和反汇编见 3. 2. 3 节。我们用 下面的命令行来启 动 GDB :</p><p>linux> gdb prog</p></li></ol><p>通常的方法是在程序中感兴趣的地方附近设置断点。断点可以设置在函数入口后面， 或是一个程序的 地址处。程序在执行过程中遇到一个 断点时， 程序 会停下来， 并将控制返回给用户。在断点处，我们能够以各种方式查看各个寄存器和内存位置。我们也可以单步 跟踪程序 ， 一次只执行几 条指令， 或是前进到下一个 断点。</p><table><thead><tr><th>A.PP女A</th><th>效果</th></tr></thead><tbody><tr><td>开始和停止 quit run kill</td><td>退出 GOB 运行程序（在此给出命令行参数） 停止程序</td></tr><tr><td>断点 break mu l 七S 七or e break * Ox400540 delete 1 delete</td><td>在函数 mu l t s t or e 入口处设 置断点在地址 Ox 400540 处设 置断点 删除断点 1 删除所有断点</td></tr><tr><td>执行</td><td></td></tr><tr><td>stepi</td><td>执行 1 条指令</td></tr><tr><td>stepi 4</td><td>执行 4 条指令</td></tr><tr><td>nexti</td><td>类似于 s t e p i , 但以函数调用为单位</td></tr><tr><td>continue</td><td>继续执行</td></tr><tr><td>finish</td><td>运行到当前函数返回</td></tr><tr><td>检查代码</td><td></td></tr><tr><td>disas</td><td>反汇编当前函数</td></tr><tr><td>disas mu l t s t or e</td><td>反汇 编函数 mul t s t or e</td></tr><tr><td>disas Ox400544</td><td>反汇编位于地址 Ox 400544 附近的 函数</td></tr><tr><td>disas Ox400540, Ox40054d</td><td>反汇编指定地址范围内的代码</td></tr><tr><td>print /x $rip</td><td>以十六进制输出程序计数器的值</td></tr><tr><td>检查数据</td><td></td></tr><tr><td>print $rax</td><td>以十进制输出 %r a x 的内容</td></tr><tr><td>print /x $rax</td><td>以十六进制输出 %r a x 的内容</td></tr><tr><td>print /t $rax</td><td>以二进制输出 %r a x 的内 容</td></tr><tr><td>print OxlOO</td><td>输出 Ox l OO 的十进制 表示</td></tr><tr><td>print /x 555</td><td>输出 555 的十六 进制表示</td></tr><tr><td>print /x ($rsp+ 8)</td><td>以十六 进制输出 %r s p 的内容加上 8</td></tr><tr><td>print *(long *) Ox7fffffffe818</td><td>输出位 于地址 Ox 7ff f f f f f e 81 8 的 长整数</td></tr><tr><td>print *(long *) ($rsp+ 8)</td><td>输出位 于地址 %r s p + 8 处的长整数</td></tr><tr><td>x/2g Ox7fffffffe818</td><td>检查从 地址 Ox 7f f f f ff f e 81 8 开始的双 ( 8 字节）字</td></tr><tr><td>x/20brnultstore</td><td>检查函数 mu l t s t or e 的 前 20 个字节</td></tr><tr><td>有用的信息</td><td></td></tr><tr><td>info frame</td><td>有关当前栈帧的信息</td></tr><tr><td>info registers help</td><td>所有寄存器的值 获取有关 GOB 的信息</td></tr></tbody></table><p>图 3-39 GDB 命令示例。说明 了一些 GDB 支持 机器级 程序悯试的方式</p><p>正如我们的示 例表明的那样 ， GDB 的命令语法有点 晦涩， 但是在线 帮助信息（用 GDB 的 he l p 命令调用）能克服这些 毛病。相对于使用命令行接口来访问 GDB, 许多程序员更愿意使用 DDD , 它是 GDB 的一个扩展 ， 提供了图 形用户界 面。</p><ol><li><p>10 . 3 内存越界引用和缓冲区溢出</p><p>我们已 经看到 ， C 对千数组引 用不进行 任何边界检查， 而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中。这两种情况结合到一起就能导致严重的程 序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破</p></li></ol><p>坏的状态， 试图重新加载寄存 器或执行 r e t 指令时 ， 就会出现很 严重的错误 。</p><p>一种特别常 见的状态破坏称 为缓 冲 区 溢 出 ( b uff e r o ve r fl o w ) 。通常， 在栈 中分配某个字符数组来保 存一个字符串 ， 但是字符串的 长度超出了 为数组 分配的 空间。下面这 个程序示例就说明了这个问题：</p><p>I* Implementation of library function gets() *I char *gets(char *s)</p><p>｛</p><p>int c;</p><p>char *dest = s ;</p><p>while ((c = getchar()) !=&rsquo;\n&rsquo;&& c != EDF)</p><p>*dest++ = c;</p><p>if (c == EDF && dest == s)</p><p>I* No characters read *I return NULL;</p><p>*dest++ =&rsquo;\0&rsquo;; I*Terminate string *I returns;</p><p>｝</p><p>I* Read input line and write it back *I void echo()</p><p>｛</p><p>char buf[8]; gets(buf); puts(buf);</p><p>I* Way too small! *I</p><p>前面的代码 给出了 库函数 g e t s 的一个实现，用来说明这个 函数的严 重问题。它从标准输入读入 一行 ，在遇到一个回 车换行字符或某个 错误情况时 停止。它将这个字符串复制到参数. s 指明 的位置，并在字符串结尾加上 n u l l 字符。在函数 e c h o 中，我们使用了 g e t s , 这个函 数只是简单 地从标准输入中读入 一行， 再把它回送 到标 准输出 。</p><p>ge t s 的问题是它没有 办法确定是否为保存 整个 字符串分 配了足够的 空间。在 e c h o 示例中 ， 我们故意 将缓 冲区设 得非常小一 只有 8 个字节 长。任何长度超 过 7 个字符的字符串都会导致写越界。</p><p>检查 GCC 为 e c h o 产生的 汇编代码 ， 看看栈 是如何组织的 ：</p><p>void echo() echo :</p><table><thead><tr><th>subq</th><th>$24,</th><th>%rsp</th><th>Allocate 24 bytes on stack</th></tr></thead><tbody><tr><td>movq</td><td>%rsp,</td><td>%rdi</td><td>Compute buf as %rsp</td></tr><tr><td>call movq</td><td>gets %rsp,</td><td>%rdi</td><td>Call gets Compute buf as %rsp</td></tr><tr><td>call addq</td><td>puts $24,</td><td>%rsp</td><td>Call puts Deallocate stack space</td></tr><tr><td>ret</td><td></td><td></td><td>Return</td></tr></tbody></table><p>图 3- 40 画出了 e c h o 执行时 栈的组织 。该程序把栈 指针减去了 24 ( 第 2 行）， 在栈上分配了 24 个字节 。字符数组 b u f 位于栈顶， 可以 看到，%r s p 被复制到%r d i 作为调用 g e t s 和 p u t s 的参数。这个调用的参 数和存储的 返回指针之间的 1 6 字节是未 被使用的。只要用户输入 不超过 7 个字符 ， g e t s 返回的字符串（包括结尾的 n u ll ) 就能够放进为 b u f 分配的</p><p>空间里。不 过， 长一些 的字符串 就会导致 g e t s 覆盖栈上存储的某些信息。随着字符串变长，下面的信息会被破坏：</p><table><thead><tr><th>输入的字符数量</th><th>附加的被破坏的状态</th></tr></thead><tbody><tr><td>0-7</td><td>无</td></tr><tr><td>9-23</td><td>未被使用的栈空间</td></tr><tr><td>24-31</td><td>返回地址</td></tr><tr><td>32+</td><td>cal l er 中保存的状态</td></tr></tbody></table><p>字符串 到 23 个字符之前都没有严重的后果，但是超过以后，返回指针的值以及更多可能的保存状态会被破坏。如果存储的返回地址的值被破坏了 ， 那么r e t 指令（第8 行）会导致程序跳转 到一个完全意</p><p>调用者的栈帧</p><p>echo</p><p>返回地址 &lt; —</p><p>r% sp + 24</p><p>想不到的位置。如果只 看 C 代码 ， 根本 就</p><p>不可能看出会有上面这些行为。只有通过研究机器代码级别的程序才能理解像</p><p>ge 七s 这 样 的 函数 进 行 的内 存 越 界 写的影响。</p><p>的栈帧</p><p>[7Jl[ 6Ji(5J!(4 J!(3J!(2J!(l J!(Dl l-+ buf = %rsp</p><p>图 3-40 ech o 函数的栈组织。字符数组 buf 就在保存的 状 态 下 面。对 buf 的 越界写会破坏程序的状态</p><p>我们的 e c h o 代码很 简单 ， 但是有点 太随意了。更好一点的版本是使用 f ge 七s 函数， 它包括一个参数 ， 限制待读入 的最大字节数。家庭作业 3. 71 要求你写出一个能处理任意长度输入字符串 的 e c h o 函数。通常， 使用 ge t s 或其他任何能导致存储溢出的函数， 都是不好的编程习 惯。 不幸的是， 很多常用的库函数， 包括 s tr c p y、 s tr c a t 和 s pr i n t f , 都有一个属性 不需要告诉 它们目 标缓 冲区的 大小， 就产生一个字节 序列 [ 97] 。这样的情况就会导致缓冲区溢出漏洞。</p><p>" 、练习题 3 . 46 图 3- 41 是 一个 函数的（不大好的 ）实现 ， 这个函数从标 准 输入 读入 一行 ， 将字符串复制到新分配的存储中，并返回一个指向结果的指针。</p><p>考虑下 面这 样 的 场 景。 调 用 过 程 g e t _ l i ne , 返 回地 址 等 于 Ox 40007 6 , 寄存器</p><p>%r b x 等于 Ox 012345678 9ABCDEF。输入 的 字符 串 为 " 012345678901 2345678901 234" 。程</p><p>序会因为段错误 ( segmentation fault ) 而中止。运 行 GDB, 确定 错误是在 执行 g 武 _ l i ne</p><p>的r e t 指令 时发 生的。</p><ol><li><p>填写下 图 ， 尽可能 多地 说 明 在 执行 完反 汇编 代 码 中 第 3 行指 令 后 栈 的 相 关 信息。在右边标注出存储在栈中的数字含意（例如“返回地址")&lsquo;在方框中写出它们的十 六进 制值（如果知道 的 话）。每 个 方 框 都 代 表 8 个 字节。 指 出 %r s p 的位 置。 记住 ， 字符 0 ~ 9 的 ASCII 代码是 Ox 3~ 0x 3 9。</p><p>00 00 00 00 00 40 00 76 1 返回地址</p></li><li><p>修改你的 图 ， 展现调 用 g e t s 的 影响（第 5 行）。</p><ol><li>程序应该试图返回到什么地址？</li></ol></li><li><p>当 ge t —巨 n e 返回 时， 哪个（些）寄存器 的值被破坏 了？</p><ol><li><p>除了可能 会缓冲 区溢 出以 外， g e t —l i ne 的代 码还有哪 两个错误？</p><p>I* This is very low-quality code.</p><p>It is intended to illustrate badprogramming practices.</p><p>See Practice Problem 3.46. *I char *get_line ()</p><p>｛</p><p>char buf [4] ; char *result; gets(buf);</p><p>result= malloc(strlen(buf)); strcpy(result, buf);</p><p>return result;</p><p>｝</p><ol><li>C代码</li></ol></li></ol></li></ol><p>char *get _l i ne () 0000000000400720 &lt;get_line>:</p><p>2 400720: 53</p><p>3 400721: 48 83 ec 10</p><p>Di agr 却 st ack at this point</p><p>4 400725: 48 89 e7</p><p>400728: e8 73 ff ff ff</p><p>push %rbx</p><p>sub $0x10,%rsp</p><p>mov %rsp,%rdi callq 4006a0 &lt;gets></p><p>Modify diagram to show stack contents at this point</p><p>b ) 对gets调用的反汇编</p><p>图 3-41 练习题 3. 46 的 C 和反汇编代码</p><p>．缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一 种最常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字 符串包含一些 可执行 代码的 字节编码 ， 称为攻击代码 ( e xploit code), 另外，还有一些字节会用一个指向攻 击代码的 指针覆盖返 回地址。那么， 执行r e t 指令的效果 就是跳转到攻击代码。</p><p>在一种攻 击形式 中， 攻击代码会 使用系统 调用启动一个 shell 程序， 给攻 击者提供一组操作系统函数。在另一种攻击形式中，攻击代码会执行一些未授权的任务，修复对栈的 破坏， 然后第二次执行r e t 指令，（表面上）正常返回到调用者。</p><p>让我们来看一个例子 ， 在 1 988 年 11 月， 著名的 In ternet 蠕虫病毒通过 Int ernet 以四种不同 的方法获取 对许多计算机的访问。一种是对 fi nger 守护进程 f i ng er d 的缓冲区 溢出攻击 ， f i ng er d 服务 F I NG E R 命令请求。通过以一个适当的字符串调用 F I NG E R , 蠕虫可以使远程的守护进程缓冲区溢出并执行一段代码，让蠕虫访问远程系统。一旦蠕虫获得了对系统的访问，它就能自我复制，几乎完全地消耗掉机器上所有的计算资源。结果， 在安全专家制定出如何消除这种蠕虫的方法之前，成百上千的机器实际上都瘫痪了。这种蠕虫的始作桶者最后被抓住并被起诉。时至今日，人们还是不断地发现遭受缓冲区溢出攻击的系统安全漏洞，这更加突显了仔细编写程序的必要性。任何到外部环境的接口都应该是“防弹的＂，这样，外部代理的行为才不会导致系统出现错误。</p><p>日 日 蠕虫和病 毒</p><p>蠕虫 和病毒都 试图 在计 算机中 传播它们 自 己的 代码段。正如 S pa fford [ 105 J 所 述， 蠕 虫 ( w o rm ) 可以 自己 运行 ， 并且 能 够将 自 己的 等效副 本传播 到 其他 机 器。 病毒( vi ru s ) 能将自己添加到包括操作系统在内的其他程序中，但它不能独立运行。在一些大众媒体 中，“ 病毒“ 用来指 各种在 系统间 传播 攻击代 码的 策略 ， 所以 你 可能 会听到人们把 本 来应该叫做＂蠕虫”的东西称为“病毒”。</p><p>3. 10 . 4 对抗缓冲区溢出攻击</p><p>缓冲区溢 出攻击的普遍发 生给计算 机系统 造成了许多 的麻烦。现代的 编译器和操作 系统实现了很多 机制 ， 以避免遭受这 样的攻 击， 限制入侵者 通过缓 冲区 溢出攻击获得 系统控制的方式。在本节中 ， 我们 会介绍一些 L in u x 上最新 G CC 版本所 提供的机制。</p><p>1 栈随机化</p><p>为了 在系统 中插入攻 击代码 ， 攻击者既要插入代 码， 也要插入指向这段代码的指针， 这个指针也是 攻击字符串的 一部分。产生这个指 针需 要知道这个 字符串放置的 栈地址 。在过去 ， 程序的 栈地址非常容易 预测。对于所 有运行 同样程序和操 作系统 版本的 系统 来说， 在不同的 机器之间 ， 栈的位置是相 当固定的 。因此， 如果 攻击者可以确定 一个常见的 We b 服务器所使用的 栈空间 ， 就可以设 计一个在许多 机器上都能 实施的攻击。以 传染病来打个</p><p>比方， 许多系统都容易 受到同一种病毒的攻击， 这 种现象常被称作安全 单 一 化 ( sec u rit y monoculture) [ 96] 。</p><p>栈随机化的思 想使得栈的 位置在程序每 次运行时都 有变化。 因此， 即使许多机器都 运行同样的 代码 ， 它们的 栈地址 都是不同 的。实现的方式是 ： 程序 开始时， 在栈上分配一段 O~ n 字节之间的随 机大小 的空间， 例如， 使用分配函 数 a l l o c a 在栈上 分配指定 字节数 量 的空间 。程序不使 用这段空间， 但是 它会导致程序 每次执行时后续的栈位置发 生了变化。分配的范围 n 必须足够大 ， 才能 获得 足够多的 栈地址 变化 ， 但是 又要 足够小 ， 不至千浪费 程序太多 的空间 。</p><p>下面的代码是一种确定 ”典型的＂ 栈地址的 方法：</p><p>int main() { long local;</p><p>printf (&ldquo;local at %p\n&rdquo;, &amp;local); return O;</p><p>这段 代码只 是简单 地打印出 ma i n 函数中局部 变量的 地址。在 32 位 L in u x 上运行这段 代码</p><p>10 000 次， 这个地址的 变化范围为 Ox f f7 f c 5 9c 到 Ox f f f f d 09c , 范围大小 大约是 2气 在更新 一点 儿的 机 器上 运 行 64 位 L i n ux , 这 个地址的 变 化范围 为 Ox 7 f f f 000 l b 698 到Ox 7 f f f f f f a a 4a 8 , 范围大小大约是 2 32 0</p><p>在 L i n u x 系统 中， 栈随机化已经变成了标准行 为。它是更大的一类技术中的一种， 这类技术 称为地址空间布局 随机化 ( A dd r ess -S pace La yo ut Ra nd omiza tio n ) , 或者简 称 AS LR [ 99] 。采用 AS LR , 每次运行时 程序的 不同部分， 包括程序 代码 、库 代码、栈 、全局 变撮和堆数 据， 都会被 加载到内 存的不同区域 。这就意 味着在 一台机器上运行一个程序 ， 与在其他机器上 运行同样的程 序， 它们的地址映射大相径庭。 这样才能够对抗一些形式的攻击。</p><p>然而，一个执著的攻击者总是能够用蛮力克服随机化，他可以反复地用不同的地址进 行攻击 。一种常见的把戏就是在实际的攻击代码前插入很长一段的 no p ( 读作 " no op", no ope ratio in 的缩写）指令。执行这种指令除了对程序计数器加一，使 之指向下一条指令之外，没有任何的效果。只要攻击者能够猜中这段序列中的某个地址，程序就会经过这个序 列， 到达攻 击代码。这个序列常用的术语是“ 空操 作雪橇 ( no p sled)" [97], 意思是程序会“滑过“ 这个序列。如果我们建立一个 256 个字节的 no p sled, 那么枚举 215 = 32 768 个 起始地 址， 就能破解 n 2 23 的 随 机化， 这对于一个顽固的攻击者来说 ， 是完全可行的。对千 64 位的 情况， 要尝试枚举 沪 —1 6 777 216 就有点儿令人畏惧了。我们可以看到栈随机化和其 他一些 AS LR 技术能够增加成功攻击一个系统的难度， 因而大大降低了病毒或者蠕虫的传播速度，但是也不能提供完全的安全保障。</p><p>练习题 3. 47 在运行 L in u x 版本 2. 6. 1 6 的机器上运行栈检查代 码 10 000 次， 我 们 获得地 址的 范 围从 最小的 Ox ff f f b 75 4 到 最 大 的 Ox f f f f d 75 4。</p><ol><li><p>地址的大概范围是多大？</p></li><li><p>如果 我 们 尝试 一个 有 1 28 字节 no p s led 的 缓冲 区 溢 出 ， 要 想 穷尽 所 有 的 起始地址， 需要尝试多少次？</p><p>2 栈破坏检测</p><p>计算机的第二道防线是能 够检测到何时栈已经被破坏。我们在 e c ho 函数示例（图3-</p></li><li><p>中看到 ， 破坏通常发生在当超越局部缓 冲区的边界时。在 C 语言 中 ， 没有可靠的方法来防止对数组的越界写。但是，我们能够在发生了越界写的时候，在造成任何有害结果之 前，尝试检测到它。</p><p>最近的 GCC 版本在产生的代码中加</p><p>入了一种栈保护者 ( s t ack pro t ecto r ) 机制，</p></li></ol><p>来检测缓冲区越界。其思想是在栈帧中任 何局部缓冲区与栈状态之间存储一个特殊 的全·丝 雀 ( cana ry ) 值s , 如 图 3-42 所 示</p><p>调用者</p><p>的栈帧</p><p>echo</p><p>返回地址</p><p>&lt; — r%</p><p>s p + 24</p><p>[26, 97] 。这个金丝雀值，也 称为哨兵值 的栈帧</p><p>(guard value), 是在程序每次运行时随机</p><p>金丝雀</p><p>[7 Jl[ 6 Ji [ S Jl[ 4 Ji[ 3Jl [ 2 Jl[l li[ O]</p><p>&lt; — buf = %rsp</p><p>产生的，因此，攻击者没有简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的</p><p>图 3-42 ech o 函数具有栈保护者的栈组织（在数组</p><p>buf 和保存的状态之间放了 一个特殊的“金丝雀＂ 值。代码检查这个金丝雀值 ， 确定栈状态是否被破坏）</p><p>某个函数的某个操作改变了。如果是的，那么程序异常中止。</p><p>最近的 GCC 版本会试着确定一个函数是否容易遭受栈溢出攻击，并 且自动 插入这种溢出检测。实际上，对 于前面的栈溢出展示， 我们不得不用命令行选项 " - f no - s t a c k- pr ot e c t or " 来阻止 GCC 产生这种代码。当不用这个选项来编译 e c ho 函数时，也 就是允许使用栈保护者，得到下面的汇编代码：</p><p>void echo()</p><ol><li>echo:<ol><li>subq $24, %rsp Allocate 24 bytes on stack</li></ol></li></ol><p>e 术语“金丝雀＂源于历史上用这种鸟在煤矿中察觉有毒的气体。</p><p>议</p><ol><li><p>movq %fs:40, %rax Retrieve canary</p><p>4 movq %rax, 8(%rsp) Store on stack</p><p>5 xorl %eax, %eax Zero out register</p><p>6 movq %rsp, %rdi Compute buf as¼rsp</p><p>7 call gets Call gets</p><p>8 movq ．r 儿 s p , %rdi Compute but as %rsp</p><p>9 call puts Call puts</p><p>10 movq 8(%rsp), %rax Retrieve canary</p><p>11 xorq %fs:40, %rax Compare to stored value</p><p>12 je .19 If=, goto ok</p><p>13 call stack_chk_fail Stack corrupted!</p><p>14 .L9: ck:</p><p>15 addq $24, %rsp Deallocate stack space</p><p>16 ret</p><p>这个版本的函数从内存中读出一个值（第3 行），再 把它存放在栈中相对千%r s p 偏移量 为 8 的地方 。指令参数%f s : 40 指明金丝雀值是用段寻址 ( s eg m e n ted ad d ress ing ) 从 内 存中读入的， 段寻址机制可以 追溯到 80286 的 寻 址， 而在现代系统上运行的程序中已经很少见到了。将金丝雀值存放在一个特殊的段中，标志为“只读“，这样攻击者就不能覆盖存 储的金丝雀值。在恢复寄存器状态和返回前，函数将存储在栈位置处的值与金丝雀值做比 较（通过第 11 行的 x or q 指令）。如果两个数相同， x or q 指令就会得到 0 , 函数会按照正常的方式完成。非零的值表明栈上的金丝雀值被修改过，那么代码就会调用一个错误处理 例程。</p><p>栈保护很好地防止了缓冲区溢出攻击破坏存储在程序栈上的状态。它只会带来很小的性能损失， 特别是因为 GCC 只在函数中有局部 c h ar 类型缓 冲区的 时 候 才插入这样的代码。当然，也有其他一些方法会破坏一个正在执行的程序的状态，但是降低栈的易受攻击性能够对抗许多常见的攻击策略。</p><p>让 练习题 3. 48 函 数 i n t l e n 、l e n 和 i p t o a 提供 了 一 种很 纠结 的 方 式 ， 来计算 表 示 一个整数所 需 要 的 十 进 制 数 字 的 个 数。 我 们 利 用 它 来 研 究 GCC 栈保 护 者 措 施 的 一 些情况。</p><p>int len(char *s) { return strlen(s);</p><p>｝</p></li></ol><p>void iptoa(char *s, long *p) { long val= *p;</p><p>sprintf (s, &ldquo;%ld&rdquo;, val) ;</p><p>｝</p><p>int intlen(long x) { long v;</p><p>char buf[12];</p><p>V = x;</p><p>iptoa(buf, &amp;v); return len(buf);</p><p>｝</p><p>下 面是 i n t l e n 的 部分代码 ， 分别 由 带和 不 带栈 保护者 编译：</p><table><thead><tr><th></th><th></th><th></th><th>int intl en (1 ong x)</th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td>x in %rdi</td><td></td></tr><tr><td></td><td></td><td></td><td>1</td><td>intlen:</td></tr><tr><td></td><td>i nt 工 nt l en(l ong x)</td><td></td><td>2</td><td>subq $56, %rsp</td></tr><tr><td></td><td>x in %rdi</td><td></td><td>3</td><td>movq %fs:40, %rax</td></tr><tr><td></td><td>intlen:</td><td></td><td>4</td><td>movq %rax, 40(%rsp)</td></tr><tr><td>2</td><td>subq $40, %rsp</td><td></td><td>5</td><td>xorl %eax, 1儿eax</td></tr><tr><td>3</td><td>movq %rdi, 24(%rsp)</td><td></td><td>6</td><td>movq %rdi, 8(%rsp)</td></tr><tr><td>4</td><td>leaq 24(%rsp), %rsi</td><td></td><td>7</td><td>leaq 8(%rsp), %rsi</td></tr><tr><td>5</td><td>movq %rsp, %rdi</td><td></td><td>8</td><td>leaq 16(%rsp), %rdi</td></tr><tr><td>6</td><td>call iptoa</td><td></td><td>9</td><td>call iptoa</td></tr></tbody></table><p>a ) 不带保护者 b ) 带保护者</p><ol><li><p>对于两个版本： b u f 、v 和金 丝雀值（如果 有的 话）分别 在栈 帧 中的 什 么 位置？</p></li><li><p>在有保护的代码中，对局部变量重新排列如何提供更好的安全性来对抗缓冲区越界攻击？</p><p>3 限制可 执行代码区域</p><p>最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。正如第 9 章中会看到的 ， 虚拟内存空间 在逻辑上被分成了页( page) , 典型的每页是2048 或者 4096 个字节。硬件支持多种形式的内存保护， 能够指明用户程序和 操作系统内核所允许的访问形式。许多系统允许控制三种访问形式： 读（从内存读数据）、写（存储数据到内存）和执行（将内存的内容看作机器级代码）。， 以x8 前6 体系结构将读和执行访问控制合并成一个1 位的标志， 这样任何被标记为可读的 页也都是可执行的。栈必须是既可读又可写的，因而栈上的字节也都是可执行的。已经实现的很多机制，能够限制一些页是可读但是不可执行的，然而这些机制通常会带来严重的性能损失。</p><p>最近， AMD 为它的 64 位处理器的内 存保护引 入了 " N X" (No-Execute, 不执行）位， 将读和执行 访问模式分开， In t el 也跟进了 。有 了这个特性 ， 栈可以 被标记为可读和可写， 但是不可执行，而检查页是否可执行由硬件来完成，效率上没有损失。</p><p>有些类型的 程序要求 动态产生 和执 行代码的能力。例如， ”即时( jus t-in- t ime ) " 编译技术为解 释语言（例如J a va ) 编写的 程序动态地产生 代码 ， 以提高执行 性能。是否能够将可执行代码限制在由编译器在创建原始程序时产生的那个部分中，取决千语言和操作系统。</p><p>我们讲到的这些技术 随机化、栈保护和限制哪部分内存可以存储可执行代码</p><p>是用千最小化程序缓冲区溢出攻击漏洞三种最常见的机制。它们都具有这样的属性，即不需要程序员做任何特殊的努力，带来的性能代价都非常小，甚至没有。单独每一种机制都降低了漏洞的等级，而组合起来，它们变得更加有效。不幸的是，仍然有方法能够攻击计算机 [ 85 , 97], 因而蠕虫和病毒继续危害着许多机器的完整性。</p></li><li><p>10. 5 支持变长栈帧</p><p>到目前为止，我们已经检查了各种函数的机器级代码，但它们有一个共同点，即编译 器能够预先确定需要为栈帧分配多少空间。但是有些函数，需要的局部存储是变长的。例 如， 当函数调用 a l l o c a 时就会发生这种情况。 a l l o c a 是一个标准库函数， 可以在栈上分配任意字节数量的存储。当代码声明一个局部变长数组时，也会发生这种情况。</p><p>虽然本节介绍 的内容实际上是如何实现过程的一部分， 但我们还是 把它推迟 到现在才</p></li></ol><p>讲， 因为它需 要理解数组和对齐。</p><p>图 3-43a 的代码 给出了一 个包含变长数组的 例子。该函数声明了 n 个指针的局部数组</p><p>p, 这里 n 由第一个参数 给出 。这要求 在栈上分 配 8 n 个字节， 这里 n 的值每次调 用该函数时都会不同 。因此编译 器无 法确定 要给该 函数的 栈帧分配多少空间。此外 ，该 程序 还产生一个对局部 变鼠 1 的地址引 用， 因此该 变星必须存储在栈 中。在执 行工程中 ， 程序必须能够访问 局部变最 1 和数组 p 中的元素。返回时， 该函数必须 释放这个栈 帧， 并将栈指针设置为存储 返回地址的 位置。</p><p>long vframe(long n, long idx, long *q) { long i;</p><p>long *p[n]; p[O] = &amp;i;</p><p>for (i = 1; i &lt; n; i++) p[i] = q;</p><p>return *p[idx];</p><p>｝</p><ol><li><p>C代码</p><p>long vframe(long n, l ong 工 dx , long *q)</p><p>n 江I %r 中 ， 过 x in %r s 工， q 耳1 %rdx Only portions of code shown vframe:</p></li></ol><table><thead><tr><th>2</th><th>pushq</th><th>%rbp</th><th></th><th>Save old %rbp</th><th></th></tr></thead><tbody><tr><td>3</td><td>rnovq</td><td>%rsp, %rbp</td><td></td><td>Set fr 动 e pointer</td><td></td></tr><tr><td>4</td><td>subq</td><td>$16, %rsp</td><td></td><td>Allocate space for</td><td>i (%rsp = s1)</td></tr><tr><td>5</td><td>leaq</td><td>22(,%rdi,8),</td><td>%rax</td><td></td><td></td></tr><tr><td>6</td><td>andq</td><td>＄一1 6 , %rax</td><td></td><td></td><td></td></tr><tr><td>7</td><td>subq</td><td>%rax, %rsp</td><td></td><td>Allocate space for</td><td>array p (%rsp = s2)</td></tr><tr><td>8</td><td>leaq</td><td>7(%rsp), %rax</td><td></td><td></td><td></td></tr><tr><td>9</td><td>shrq</td><td>$3, %rax</td><td></td><td></td><td></td></tr><tr><td>10</td><td>leaq</td><td>0(,%rax,8), %r8</td><td>Set %r8 to !tp[O]</td><td></td><td></td></tr><tr><td>11</td><td>rnovq</td><td>%r8, %rcx</td><td>Set %rcx to !tp[O] (%rcx = p)</td><td></td><td></td></tr></tbody></table><p>Code for initialization loop</p><p>i in¼rax and on stack, n in¼rdi, pin¼rcx, q in¼rdx</p><table><thead><tr><th>12</th><th>.13:</th><th></th><th>loop:</th></tr></thead><tbody><tr><td>13</td><td>movq</td><td>%rdx, (%rcx,%rax,8)</td><td>Set p[i] to q</td></tr><tr><td>14</td><td>addq</td><td>$1, %rax</td><td>Increment i</td></tr><tr><td>15</td><td>movq</td><td>%rax, - 8 C儿r bp )</td><td>Store on stack</td></tr><tr><td>16</td><td>. 1 2 :</td><td></td><td></td></tr><tr><td>17</td><td>movq</td><td>-8(%rbp), %rax</td><td>Retrieve i from stack</td></tr><tr><td>18</td><td>cmpq</td><td>%rdi, %rax</td><td>Compare i : n</td></tr><tr><td>19</td><td>jl</td><td>.L3</td><td>If &lt;, goto loop</td></tr></tbody></table><p>Code for function exit</p><ol><li>leave</li><li>ret</li></ol><p>Restore¾rbp and 7.rsp Return</p><p>b ) 生成的部分汇编代码</p><p>图 3-43 需 要使用帧 指针的 函数。变长数组 意味着在编译 时无法确定栈帧的 大小</p><p>为了管理 变长栈帧 ， x8 6-64 代码使用 寄存器%r b p 作为帧 指针( fr am e pointer) (有时称为基指 针 ( base pointer) , 这也是%r bp 中 b p</p><p>两个字母的由来）。当使用帧指针时，栈帧的</p><p>组织结 构与图 3-44 中函数 v fr a me 的情况一 帧指针r% 样。可 以看到代码必须把%r b p 之前的值保存</p><p>到栈中，因为它是一个被调用者保存寄存器。然后在函 数的整个执行过程中， 都使得%r b p 指向那个时刻栈的位置，然后用固定长度的 局部变量（例 如 i ) 相对于%r b p 的偏移趾来引</p><p>bp -­</p><p>&lt; s,</p><p>｝e,</p><p>用它们。 8n字节</p><p>图 3-43 b 是 GCC 为 函数 v fr a me 生成的部分代码。在函数的开始，代码建立栈帧， 并为数组 p 分配空间。首先把%r b p 的当前 值</p><p>压入栈 中， 将%r b p 设置为指向当前的栈位詈 栈指针%r sp — — ></p><p>)&mldr;. p</p><p>(s,</p><p>（第 2~ 3 行）。然后， 在栈上分配 1 6 个字节， 图 3-44 函数 vf ra me 的栈帧结构（该函数使用寄其中前 8 个字节 用于存储局部变最 i , 而后 8 存器 %r bp 作为帧指针。图右边的注释供个字节是未 被使用的。接着， 为数组 p 分配 练习题 3. 49 所 用 ）</p><p>空间（第 5 ~ 11 行）。练习题3. 49 探讨了分配多 少空间以 及将 p 放在这段 空间 的什么位置。当程序到第 11 行的时候， 已经 (1 ) 在栈上分 配了 8 n 字节 ， 并( 2 ) 在已分配的 区域内 放置好数组 p , 至少有 811 字节可 供其使用 。</p><p>初始化循环的 代码展示 了如何引 用局部变蜇 1 和 p 的例子。第 13 行表明 数组元素 p 肛］被设 置为 q 。该指令用 寄存器%r c x 中的值作 为 p 的起始地址 。我们可以 看到修 改局部变量 i( 第 1 5 行）和读局部变最（第1 7 行）的例子。1 的地址是引用- 8 (%rbp), 也就是相对千帧指 针偏移扯 为- 8 的地方。</p><p>在函数的结 尾， l e a v e 指令将帧指针恢 复到它之前的值（第20 行）。这条指令不需要参数，等价千执行下面两条指令：</p><p>movq %rbp, %rsp Set stack pointer to beginning of frame popq %rbp Restores aved %rbp and set stack ptr</p><p>to end of cal l ers&rsquo; frame</p><p>也就是 ， 首先把栈指针设置为保 存%r b p 值的 位置， 然后把该 值从 栈中弹出到%r b p 。 这个指令组合具有释放整个栈帧的效果。</p><p>在较早版本的 x86 代码中 ， 每个函数调用都使用 了帧指针。 而现 在，只 在栈帧长可变的情况下才使用 ， 就像函数 v fr a me 的情况一样。历 史上， 大多数编译 器在生成 I A32 代码时会使用帧 指针。最 近的 G CC 版本放弃了这个惯 例。可以 看到把 使用帧指针的代码和不使用帧指针的 代码混 在一起 是可以 的，只 要所有的函数都把%r b p 当做被调用者保存寄存器来处理即可。</p><p>让 练习题 3. 49 在这 遗题 中，我们 要探 究图 3- 43 b 第 5 ~ 11 行代 码 背后的逻 辑， 它 分 配了变长大 小的数组 p 。 正如代码 的注释表明的 ， S 1 表 示执行 第 4 行的 s ub q 指令 之后 栈指针的地 址。这 条指令 为局部 变量 1 分 配 空间。 S2 表 示执 行 第 7 行的 s ub q 指令之 后栈指针的值。 这条指令 为局部 数 组 p 分 配存 储。 最 后 ， p 表 示 第 1 0 ~ 11 行的 指令 赋给寄 存器 %r 8 和%r c x 的值。 这 两个寄存器都用来 引用数组 p 。</p><p>图 3-44 的 右边 画 出 了 s, 、Sz 和 p 指 示的 位置。 图 中 还 画 出 了 S2 和 p 的值之 间 可能有 一个 偏 移 量 为 e 2 字 节 的位置 ， 该 空 间是未被使用 的。 数 组 p 的 结 尾和 s , 指 示的 位置之间 还可 能 有 一个 偏 移 量 为 e , 字节的地方。</p><ol><li>用 数 学 语 言解释第 5 ~ 7 行 中 计 算 Sz 的逻辑。提 示 ： 想想—16 的位级表 示以 及它在第 6 行 a ndq 指令 中 的作用 。</li><li>用 数 学语 言解释第 8 ~ 10 行 中 计 算 p 的 逻 辑。 提 示 ： 可 以 参 考 2. 3. 7 节 中 有 关 除以 2 的幕的 讨论。</li><li>对 于 下 面 n 和 s , 的值 ， 跟 踪 代码 的执行， 确定 Sz 、p、e, 和 e2 的结果值。</li></ol><p>sI 们 e,</p><ol start=4><li>这段代码 为 S2 和 p 的 值提供 了什 么 样的 对 齐 属 性？</li></ol><h6 id=11-浮点代码>11 浮点代码
<a class=anchor href=#11-%e6%b5%ae%e7%82%b9%e4%bb%a3%e7%a0%81>#</a></h6><p>处理器的浮点体 系结构包括多个方面，会 影响对浮点 数据操作的程序如何被映射到机器上，包括：</p><ul><li>如何存储和访问浮点数值。通常是通过某种寄存器方式来完成。<ul><li><p>对浮点数据操作的指令。</p></li><li><p>向函数传递浮点 数参数和从函数返回浮点数结果的规则。</p></li><li><p>函数调用过程中保存寄存器的规则 例如， 一 些 寄 存 器被指定为调用者保存， 而其他的被指定为被调用者保存。</p><p>简要回顾历史会对理解 x86- 64 的 浮点体系结构有所帮助。1997 年出现了 Pent i um / MMX, Int el 和 AMD 都引 入了持续数代的媒体( med ia) 指令， 支持图形和图像处理。这些 指令本意是允许多个操作以并行模式执行， 称 为 单指令 多 数 据或 S IMD ( 读作 sim-de e )。在这种模式中，对 多 个不同的数据并行执行同一个操作。近年来， 这些扩展有了长足的发展。名字经过 了 一 系列 大的 修 改， 从 MMX 到 SSE ( Str eaming SIMD Extens ion , 流式</p><p>SIMD 扩展），以 及最新的 AVX (Advanced Vector Extension , 高级向量扩展）。每一代中，都 有一些不同的版本。每个扩展都是管理寄存器组中的数据， 这些寄存器组在 MMX 中 称为 " MM" 寄 存 器 ， SS E 中称为 " XMM" 寄 存 器 ， 而在 AVX 中 称 为 " YMM" 寄存器；</p><p>MM 寄存 器是 64 位的， XMM 是 128 位的 ， 而 YMM 是 256 位的。所以， 每个 YMM 寄存器可以存放 8 个 32 位值， 或 4 个 64 位值， 这些值可以 是整数，也 可以 是浮点数。</p><p>2000 年 Pent i um 4 中 引 入了 SSE2 , 媒体指令开始包括那些对标量浮点数据进行操作的指令，使 用 XMM 或 YMM 寄存 器的低 32 位或 64 位 中 的 单 个 值 。 这个标量模式提供了一组寄存器和指令，它 们 更类似于其他处理器支待浮点 数的 方式。所有能够执行 x86-6 4 代码的处理器都支待 SSE2 或更高的版本，因 此 x86-6 4 浮点数是基于 SSE 或 AVX 的 ， 包括传递过程参数和返回值的规则[ 77] 。</p><p>我们的讲述基于 AVX2 , 即 AVX 的 第 二 个 版本， 它 是 在 201 3 年 Core i7 Has well 处理器中引入的。当给定命令行参数- ma v x2 时 ， GCC 会生成 AVX2 代 码 。 基于不同版本的</p><p>SSE 以及第一个版本的 AVX 的 代码从概念上来说是类似的，不 过 指 令 名和格式有所不同。我们只介绍用 GCC 编译浮点程序时会出现的那些指令。其中大部分是标量 AVX 指令， 我</p></li></ul></li></ul><p>们也会 说明对整个数 据向量进行 操作的 指令出现的情况。后文中的网络旁 注 O PT , SIMD 更全面地 说明了如何利用 SSE 和 AVX 的 SIMD 功能读者可能 希望参考 AM D 和 Intel 对每条指令 的说明 文档[ 4 , 51] 。和整数操 作一样， 注意 我们表述中使用的 AT T 格式不同 千这些文档中 使用的 Intel 格式。特别地， 这两种版本 中列出指令操作数的顺 序是不同 的。</p><p>如图 3-45 所示 ， AVX 浮点 体系结 构允许数据存储在 16 个 YM M 寄存器中， 它们的 名字为 %ymrn0~ %ymrn1 5 。 每个 YM M 寄存器都 是 256 位( 32 字节）。当对标最数据操作时， 这些寄 存骈只保 存浮点数， 而且只使用低 32 位（对千 fl o a t ) 或 64 位（对于 d o u b l e ) 。汇编代码 用寄存器的 SS E XM M 寄存器名字%xmrn0~ %xmrn1 5 来引用 它们， 每个 XM M 寄存器</p><p>都是对应 的 YM M 寄存器的 低 1 28 位(1 6 字节）。</p><p>255</p><h3 id=尸>尸
<a class=anchor href=#%e5%b0%b8>#</a></h3><p>E三</p><p>尸三三三三E E</p><h2 id=三三三三>三三三三
<a class=anchor href=#%e4%b8%89%e4%b8%89%e4%b8%89%e4%b8%89>#</a></h2><p>三三</p><p>127 。</p><p>%xrnm0 II 1st FP arg 返回值</p><p>%xmml II 2nd FP参数</p><p>%xmm2 II 3rd FP参数</p><p>令xmm3 II 4th FP参数</p><p>%xrnm4 II 5th FP参数</p><p>%xmm5 』6th FP参数</p><p>1 %xmm6 17th FP参数</p><p>I%xmm7 18th FP 参数</p><p>J %xrnm8 ii 调用者保存</p><p>l %xrnm9 II 调用 者保存</p><p>j%xmm1 0 II 调用者保存</p><p>l %xrnmll II调用者保存</p><p>%xrnm1 2 11 调 用者保存</p><p>%xmml 3 II调用者保存</p><p>%xmm14 II调用者保存</p><p>J %xmml 5 II调用者保存</p><p>图 3-45 媒 体 寄 存 器 。 这些寄存器用于存放浮点 数 据。每个 YMM 寄存器保 存 32 个 字 节 。 低 16 字 节 可以 作为 XMM 寄存器来访问</p><p>3. 11. 1 浮点传送和转换操作</p><p>图 3-46 给出了一组在内存和 XM M 寄存器之间以及从一个 XM M 寄存器到另一个不</p><p>做任何转换的 传送浮点 数的指 令。引用内 存的指令是标量指 令， 意味着它们只对单个而不 是一组封装好的数 据值进行 操作。数据要么保存在内 存中（由表中的 M 32 和 M 64 指明）， 要 么保存在 XM M 寄存器中（在表中 用 X 表示 ）。无论数据对齐与否， 这些指令都能正确执行， 不过代码优化规则建议 32 位内 存数据满足 4 字节对齐， 64 位数据满足 8 字节 对齐。内存引 用的指定方式与整数 MOV 指令的一样， 包括偏移量、基址寄存器、变址 寄存器和伸缩因子的 所有可能的组合。</p><table><thead><tr><th>指令</th><th>源</th><th>目的</th><th>描述</th></tr></thead><tbody><tr><td>vrnovss</td><td>M32</td><td>X</td><td>传送单精度数</td></tr><tr><td>vmovss</td><td>X</td><td>Ms,</td><td>传送单精度数</td></tr><tr><td>vmovsd</td><td>M"</td><td>X</td><td>传送 双精 度数</td></tr><tr><td>vmovsd</td><td>X</td><td>M"</td><td>传送双精度数</td></tr><tr><td>vmovaps</td><td>X</td><td>X</td><td>传送对 齐的 封装好的 单精度数</td></tr><tr><td>vmovapd</td><td>X</td><td>X</td><td>传送对齐的封装好的 双精度数</td></tr></tbody></table><p>图 3-46 浮点 传送指 令。这些操作在内存和寄存器之间以 及一对寄存器之间传 送值 &lt;X, XMM</p><p>寄存器（例如%x mm3 ) ; M32 : 3 2 位内 存范围； M6, : 64 位内 存范围）</p><p>GCC 只用标量传送操作从内存传送数据到 XM M 寄存器或从 XM M 寄存器传送 数据到内 存。对 于 在 两 个 XM M 寄 存 器 之间 传 送 数 据， GCC 会使用两 种 指令之一， 即用v mo v a p s 传送单精度数 ， 用 v mo v a p d 传送双精度数。对于这些情况， 程序复制整个寄存器还是只复制低位值既 不会影响程序功能 ， 也不会影响 执行 速度 ， 所以使用这些指令还是</p><p>针对标 量数据的指令没有实质上的 差别。指令名字中的字母 ＇矿表示 " a li g n ed ( 对齐的 ）＂。当用于读写 内存时 ， 如果 地址不满足 16 字节 对齐， 它们会导 致异常。在两个寄存器之间传送数据， 绝不 会出现错 误对齐的状况。</p><p>下面是一 个不同 浮点 传送操作的 例子， 考虑以 下 C 函数</p><p>float float_mov(float v1, float *Src, float *dst) { float v2 = *src;</p><p>*dst = v1;</p><p>return v2;</p><p>｝</p><p>与它相关 联的 x86- 64 汇编代码 为</p><p>float float_mov(float v1, float *src, float *dst) v1 in %xmm0, src in %rdi, dst in %rsi</p><p>float_mov:</p><p>vmovaps %xmm0, %xmm1 vmovss (%rdi), %xmm0 vmovss %xmm1, (%rsi) ret</p><p>Copy v1</p><p>Read v2 from src Write v1 to dst Return v2 in¼xmmO</p><p>这个例子中可以 看到它 使用了 v mo v a p s 指令把数据从一个寄存器复制到另一个， 使用了</p><p>v mo v s s 指令把数 据从内 存复制到 XM M 寄存器以及从 XM M 寄存器复制到内 存。</p><p>图 3-47 和图 3-48 给出了 在浮点数和整 数数据类型之间以及不同浮点 格式之间进行转换的指令集 合。这些 都是对单 个数据值进行操作的标量指令。图 3-47 中的指令把一个从XM M 寄存器或内存中读出的 浮点值进 行转换， 并 将结果写入一个通用寄存 器（例如</p><p>%r a x 、%e b x 等）。把浮点 值转换 成整数时 ， 指令会执 行截断 ( t ru n ca t io n ) , 把值向 0 进行舍</p><p>入， 这是 C 和大多数其他编程语言的要求。</p><table><thead><tr><th>指令</th><th>源</th><th>目的</th><th>描述</th></tr></thead><tbody><tr><td>vcv t t s s 2s i</td><td>X/ M32</td><td>R,,</td><td>用 截断的 方法把单精 度数转换 成整数</td></tr><tr><td>vcvt t sd 2s i</td><td>X/ M"</td><td>R,,</td><td>用 截断的方 法把 双精 度数转换 成整数</td></tr><tr><td>vcvttss2siq</td><td>X/ M32</td><td>R,,</td><td>用 截断的方法把单精 度数转换 成四字 整数</td></tr><tr><td>vcvttsd2s iq</td><td>X/ M"</td><td>R, 4</td><td>用 截断的方法 把双精 度数转换 成四字整数</td></tr></tbody></table><p>图 3-47 双操作数浮点转换指 令。这些 操作将浮点 数转换成整数 ( X , XMM 寄存器（例如% x mm3 ) ; R32 :</p><p>32 位通用 寄存器（例如%e a x) ; R" : 64 位通用寄存器（例如%r a x ) ; M32 : 32 位内存范围； M " :</p><p>64 位内存范围）</p><table><thead><tr><th>指令</th><th>源 1</th><th>源 2</th><th>目的</th><th>描述</th></tr></thead><tbody><tr><td>vcvtsi2ss</td><td>M32 / R32</td><td>X</td><td>X</td><td>把整数转换成单精度数</td></tr><tr><td>vcvt s i 2s d</td><td>M32/ R32</td><td>X</td><td>X</td><td>把整数转换成双精度数</td></tr><tr><td>vcvtsi2s sq</td><td>M,d R,,</td><td>X</td><td>X</td><td>把四字整数转换成单精度数</td></tr><tr><td>vcvtsi2sdq</td><td>M64/ R64</td><td>X</td><td>X</td><td>把四字整数转换成双精度数</td></tr></tbody></table><p>图 3- 48 三操作数 浮点转换 指令 。这些操作将第一个 源的 数据类型转换 成目的的数据类 塑。第二个源值对结果的低位 字节没 有影响CX : XMM 寄存器（例如% x rnm3 ) ; M, 2 : 3 2 位内存范围 ； M , , : 64 位内存范围）</p><p>图 3-48 中的指令把整数转换成浮点数。它们使用的是不太常见的三操作数格式， 有两个源和一个目的。第一个操作数读自于内存或一个通用目的寄存器。这里可以忽略第二 个操作数 ，因 为它的值只会影响结果的高位字节。而我们的目标必须是 X M M 寄存器。在最常见的 使用场景中 ，第 二 个 源和目的操作数都是一样的， 就像下面这 条指令：</p><p>vcvtsi2sdq %rax, %xmm1, %xmm1</p><p>这条指 令从寄存器%r a x 读 出 一 个 长 整数，把 它 转 换成数据类型 d o u b l e , 并把结果存放进</p><p>XM M 寄存器%x mrnl 的 低 字节中。</p><p>最后 ， 要在两种不同的浮点格式之间转换， G CC 的当前版本生成的代码需要单独说明。假设 %x mrn0 的低位 4 字 节保 存 着一个单精度值，很 容易 就想到用下面这条指令</p><p>vcvtss2sd %XIIlIIl0, %XIIlIIl0, %XIIlIIl0</p><p>把它转 换成一个双精度值，并 将 结 果 存 储 在寄存器%x mrn0 的 低 8 字节。不过我们发现 GCC</p><p>生成的代码如下</p><p>Conversion from single to double precision</p><p>vunpcklps %xmm0, %xmm0, %xmm0 Replicate first vector element</p><p>2 vcvtps2pd %xmm0, %xmm0 Convert two vector elements to double</p><p>vunp c kl p s 指令通常用来交叉放置来自两个 X M M 寄存器的值， 把它们存储到第三个寄存器中 。也 就是说，如 果 一 个 源寄存器的内容为字[ s3 , s2 , s 1 , s。J , 另 一 个 源寄存器为字[ d 3 , dz, d 1 , d 。J , 那 么 目 的 寄 存 器 的 值 会 是 [ s1 , d1, s。, d 。] 。 在上面的代码中， 我们看到三个 操作数使用同一个寄存器 ， 所以如果原始寄存器的值为[ x 3 , Xz , X1 , X。J , 那</p><p>么该指令 会将寄存器的值更新为值[ x 1 , X1 , Xo , Xo] 。 v c v t p s 2 p d 指令把源 X M M 寄存器中的两个 低位单精度值扩展成目的 X M M 寄存器中的两个双精度值。对前 面 v u n p c k l p s</p><p>指令的结果应用这条指令会得到值[ d x,o d x o] , 这 里 d x o 是 将 x 转换成双精度后的结果。</p><p>即， 这两条指令的最终效果是 将原 始的%x mrn0 低位 4 字节中的单精度值转换成双精 度值 ， 再将其 两个副本保存 到%x mrn0 中。我们不太清楚 GCC 为什么会生成这样的代码， 这样做既没有好处 ， 也没有必要 在 XMM 寄存器中 把这个值复 制一遍。</p><p>对于把双精度转换 为单精度 ， GCC 会产生类 似的代码 ：</p><p>Convers 工 on from double to single prec1s1on</p><table><thead><tr><th>vmovddup</th><th>%xrnm0, %xrnm0</th><th>Replicate first vector element</th></tr></thead><tbody><tr><td>vcvtpd2psx</td><td>%xrnm0, %xrnm0</td><td>Convert two vector elements to single</td></tr></tbody></table><p>假设这些指 令开始执行前 寄存器%x mm0 保存着两个双精度值［工门 工。］。 然后 vrno v d d u p 指</p><p>令把它设 置为［ 工o&rsquo; X。]。 v c v t p d 2p s x 指令把这两个 值转换成单精度， 再存放到该 寄存器的低位一半 中， 并将高位一半设 置为 o , 得到结果[0. 0, 0. 0, Xo , 工。］（回想一下， 浮点值</p><p>o. 0 是由位模式 全 0 表示的）。同样，用 这种方式 把一种精度转换成 另一种精度 ， 而不用下面的单条指令，没有明显直接的意义：</p><p>vcvtsd2ss %xmm0, %xmm0, %xmm0</p><p>下面是一 个不同 浮点 转换 操作的例子 ， 考虑以下 C 函数</p><p>double fcvt(int i, float•fp, double•dp, long•lp)</p><p>｛</p><p>float f = *fp;</p><p>*lp = (long)</p><p>*fp = (float)</p><p>*dp= (double) return (double)</p><p>｝</p><p>doubled=•dp; long 1 =•lp; d;</p><p>i;</p><p>l;</p><p>f;</p><p>以及它对应的 x8 6- 64 汇编代码</p><p>double fcvt (int i, float *fp, double *dp, long *lp) i in¼edi, fp in¼rsi, dp in¼rdx, lp in¼rcx fcvt:</p><p>vmovss (%rsi), %xmm0 Get f = *fp</p><p>movq (%rcx) , %rax Get 1 = *lp</p><p>vcvttsd2siq (%rdx), %r8 Get d = *dp and convert to long</p><p>movq %r8, (%rcx) Store at lp vcvtsi2ss %edi, %xmm1, %xmm1 Convert i to float vmovss %xmm1, (%rsi) Store at fp vcvtsi2sdq %rax, %xmm1, %xmm1 Convert 1 to double vmovsd %xmm1, (%rdx) Store at dp</p><p>The f ol l owi ng two instructions convert f to double</p><ol><li><p>vunpcklps %xmm0, %xmm0, %xmm0</p></li><li><p>vcvtps2pd %xmm0, %xmm0</p></li><li><p>ret Return f</p><p>f c v t 的所有参数都是 通过通 用寄存器传递的， 因为它们既不是整数也不是指针。结果通过寄存器 %x mm0 返回。如图 3- 45 中描述的 ， 这是 fl o a t 或 d o u b l e 值指定的返回寄存器。在这段 代码 中， 可以看到图 3- 46 ~ 图 3-48 中的许多传送 和转换指令， 还 可以看到GCC 将单精度转换 为双精度的方法 。</p><p>; 练习题 3. 50 对于下面的 C 代码 ， 表达式 va ll ~ v a l 4 分别对应程序值 L、 f 、 d 和 1 : double fcvt2(int *ip, float *fp, double *dp, long 1)</p></li></ol><p>｛</p><p>inti= *ip; float f = *fp; doubled= *dp;</p><p>*ip = (int) val!;</p><p>*fp = (float) val2;</p><p>*dp = (double) val3; return (double) val4;</p><p>｝</p><p>根据该 函 数 如下的 x8 6-64 代 码 ， 确定这个映射 关 系 ：</p><p>double fcvt2(int *ip, float *fp, double *dp, long 1)</p><p>ip in 7.rdi, fp i n 肚 s i , dp i n 7.rdx, 1 in 7.rcx Result returned in 7.xmmO</p><p>fcvt2:</p><ol><li><p>rnovl (%rdi), %eax</p></li><li><p>vrnovss (%rsi), %xrnrn0</p><p>4 vcvttsd2s i (%rdx), %r8d</p></li><li><p>movl %r8d, (%rdi)</p></li><li><p>vcvtsi2ss %eax, %xmm1, %xmm1</p></li><li><p>vmovss %xmm1, (%rsi)</p></li><li><p>vcvtsi2sdq %rcx, %xmm1, %xmm1</p><p>9 vmovsd %xmm1, (%rdx)</p></li><li><p>vunpcklps %xmm0, %xmm0, %xmm0</p></li><li><p>vcvtps2pd %xmm0, %xmm0</p></li><li><p>ret</p></li></ol><p>练习题 3. 51 下 面的 C 函 数 将 类 型 为 s r c _ t 的 参 数 转 换 为 类 型 为 d s 七—t 的 返 回 值 ， 这里 两 种 数据类 型都 用 t y p e d e f 定义 ：</p><p>dest_t cvt(src_t x)</p><p>｛</p><p>dest_t y = (dest_t) x; return y;</p><p>｝</p><p>在 x8 6- 64 上执行这 段代 码 ， 假设 参 数 x 在 %x rnm0 中 ， 或 者在 寄 存 器%r d i 的 某 个适当的命名部分中（即％立江或% e d i ) 。用 一条或 两条 指令来 完 成 类 型 转换 ， 并 把 结 果值 复制 到 寄存器%r a x 的 某 个 适 当 命 名 部 分 中（整 数 结 果）， 或 %x rnm0 中（浮 点 结果）。给出这条或这些指令，包括源和目的寄存器。</p><table><thead><tr><th>T,</th><th>Ty</th><th>指令</th></tr></thead><tbody><tr><td>long</td><td>double</td><td>vcvtsi2sdq %r di , %xmm0</td></tr><tr><td>double</td><td>int</td><td></td></tr><tr><td>double</td><td>float</td><td></td></tr><tr><td>long</td><td>float</td><td></td></tr><tr><td>float</td><td>long</td><td></td></tr></tbody></table><ol><li><p>11. 2 过程中的 浮点 代 码</p><p>在 x8 6-64 中， XM M 寄存器用来向函数传递浮点 参数，以 及从函数返回浮点 值。如图</p><ol><li>所示， 可以看到如下规则：<ul><li>XM M 寄存器%x mm0 ~ %x mm7 最 多 可以 传递 8 个浮点 参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点 参数。</li></ul></li></ol></li></ol><ul><li><p>函数使用 寄存器 %x mm0 来返回 浮点值。</p></li><li><p>所有的 XM M 寄存器都是 调用者保存的。被调用者可以 不用保存就覆盖这些 寄存器中任意一个。</p><p>当函数包含指针、整数和浮点 数混合的参数时 ， 指针和整数通过通用寄存器传递， 而</p><p>浮点值通过 XM M 寄存器传递。也就是说 ， 参数到寄 存器的映射取 决千它们 的类型和排列的顺序。下面是一些例子：</p><p>double fi(int x, double y, long z);</p></li></ul><p>这个函数会把 x 存放在 % e d i 中， y 放在 %x mm0 中 ， 而 z 放在 %r s i 中。</p><p>double f2(double y, int x, long z);</p><p>这个函数的寄存 器分 配与函数 fl 相同。</p><p>double fl(float x, double *Y, long *z);</p><p>这个函数会将 x 放在 %x mm0 中， y 放在 %r 生 中， 而 z 放在%r s i 中。</p><p>; 练习题 3. 52 对于下 面每个 函数声明 ， 确定 参数的寄 存器 分配：</p><ol><li>double g1(double a, long b, float c, int d);</li><li>double g2(int a, double *b, float *c, long d);</li><li>double g3(double *a, double b, int c, float d);</li><li>double g4(float a, int *b, float c, double d) ;</li></ol><p>3. 11. 3 浮点运算操作</p><p>图 3- 49 描述了一组执行算术 运算的标量 AV X2 浮点 指令。每条指 令有一个( S 1 ) 或两个&lt;S 1 , S 2) 源操作 数， 和一个目的 操作数 D。第一个源操作 数 S 1 可以是一个 XMM 寄存器或一个内存位置。第二 个源操作数 和目的 操作数都必 须是 XMM 寄存器。每个操 作都有一条针对单 精度的指 令和一条针对 双精度的 指令。结果存放 在目的寄存 器中。</p><table><thead><tr><th></th><th>单精度</th><th>双精度</th><th>效果</th><th>描述</th><th></th></tr></thead><tbody><tr><td></td><td>vaddss vsubss vmulss vdivss vrnaxss vminss</td><td>vaddsd vsubsd vmulsd vdi vsd vmaxsd vminsd</td><td>0-s,+s1 o - s , - s , D- S, XS 1 D- Sz/S1 D 千 max(S 2 , S1) D- min(S 2 , S,)</td><td>浮点数加浮点数减浮点数乘浮点数除 浮点数最大值 浮点数最小值</td><td></td></tr><tr><td></td><td>sqrtss</td><td>sqrtsd</td><td>D- 尽</td><td>浮点数平方根</td><td></td></tr></tbody></table><p>图 3-49 标扭浮点算术运算。这些指令有一个或两个源操作数和一个目的操作数</p><p>来看一个例子 ， 考虑下 面的 浮点 函数：</p><p>double funct(double a, float x, double b, inti)</p><p>｛</p><p>return a*x - b/i;</p><p>｝</p><p>x86-64代码如下 ：</p><p>double funct(double a, float x, double b, 工 nt i) a in %xmm0, x 工n %xmm1, bin %xmm2, i in %edi funct:</p><p>The following two instructions convert x to double vunpcklps %xmm1, %xmm1, %xmm1</p><p>vcvtps2pd %xmm1, %xmm1</p><p>vmulsd %xmm0, %xmm1, %xmm0 vcvtsi2sd %edi, %xmm1, %xmm1 vdivsd %xmm1, %xmm2, %xmm2</p><p>vsubsd %xmm2, %xmm0, %xmm0 ret</p><p>Mul t i pl y a by x Convert i to double Compute b/i</p><p>Subtract from a*x Return</p><p>三个浮点 参数 a 、x 和 b 通过 XM M 寄存器%x mm0~ %x mm2 传递， 而整数参数 通过寄 存器%e 中 传递。标准的 双指令序列用以将参数 x 转换为双精度类 型（第2 ~ 3 行）。另一条转换指令 用来将参数 l 转换为双精度类型（第5 行）。该函数的 值通过寄存 器%x mm0 返回。</p><p>练习题 3. 53 对 于下 面的 C 函 数 ， 4 个参数的 类型由 t y p e d e f 定义 ：</p><p>double funct1(arg1_t p, arg2_t q, arg3_t r,</p><p>｛</p><p>arg4_t s)</p><p>return p/(q+r) - s;</p><p>｝</p><p>编译时， GCC 产 生 如下代码 ：</p><p>double funct1(arg1_t p, arg2_t q, arg3_t r, arg4_t s) funct1:</p><p>vcvtsi2ssq %rsi, %xmm2, %xmm2 vaddss %xmm0, %xmm2, %xmm0</p><p>vcvtsi2ss %edi, %xmm2, %xmm2 vdi vss %xmm0, %xmm2, i 儿 x mmO vunpcklps %xmm0, %xmm0, %xmm0</p><p>vcvtps2pd %xmm0, i儿x mmO vsubsd %xmm1, %xmm0, %xmm0 ret</p><p>确定 4 个参 数类 型可 能 的 组合（答案 可 能 不 止 一种）。让 练习题 3. 54 函 数 f u n c 七2 具有如下原 型：</p><p>double funct2(double w, int x, floaty, long z);</p><p>GCC 为该 函 数产 生 如下代码 ：</p><p>double funct2(double w, int x, float y, long z) w in %xmm0, x in %edi , y in %xmm1 , z in %rsi funct2:</p><p>vcvtsi2ss %edi, %xmm2, %xmrn2 vmulss %xmrn1, %xmm2, %xmrn1 vunpcklps %xmm1, %xmrn1, %xmm1</p><p>vcvtps2pd %x 皿 1 , %xmm2</p><p>vcvtsi2sdq %rsi, %xmm1, %xmm1 vdivsd %xmrn1, %xmrn0, %xmm0</p><p>vsubsd %xmrn0, %xmrn2, %xmm0 ret</p><p>写 出 f u n c t 2 的 C 语言版 本。</p><p>3. 1 1 . 4 定义和使用浮点常数</p><p>和整数 运算 操作不同 ， AV X 浮点 操作不能以 立即数值作为操作数。相反， 编译 器必须为所有 的常量值分配和初 始化存储 空间。然后代码在把这些 值从内存读入。下面从 摄氏度到华氏 度转换 的函数就说明 了这个问题：</p><p>double cel2fahr(double temp)</p><p>｛</p><p>return 1.8 * temp + 32 . 0 ;</p><p>｝</p><p>相应的 x8 6- 64 汇编代码部分如下 ：</p><p>double cel 2f ahr (doubl e temp) temp in¼xmmO</p><p>cel2fahr:</p><table><thead><tr><th>2</th><th>vmulsd</th><th>. LC2 (%rip),</th><th>%xmm0,</th><th>%xmm0</th><th>Multiply by 1 . 8</th></tr></thead><tbody><tr><td>3</td><td>vaddsd</td><td>. LC3 (%rip) ,</td><td>%xmm0,</td><td>%xmm0</td><td>Add 32. O</td></tr><tr><td>4</td><td>ret</td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>. LC2 :</td><td></td><td></td><td></td><td></td></tr><tr><td>6</td><td>.long</td><td>3435973837</td><td></td><td></td><td>Low-order 4 bytes of 1.8</td></tr><tr><td>7</td><td>long</td><td>1073532108</td><td></td><td></td><td>High-order 4 bytes of 1.8</td></tr><tr><td>8</td><td>.LC3:</td><td></td><td></td><td></td><td></td></tr><tr><td>9</td><td>.long</td><td>0</td><td></td><td></td><td>Low-order 4 bytes of 32 . 0</td></tr><tr><td>0 1</td><td>.long</td><td>1077936128</td><td></td><td></td><td>High-order 4 bytes of 32 . 0</td></tr></tbody></table><p>可以 看到函数从标号为 . LC2 的内存位置读出值 1. 8&rsquo; 从标号为 . LC3 的位置读入值 32 . 0。观察这些 标号对应的 值， 可以看出每一个 都是通过一 对 . l o n g 声明和十进 制表示 的值指定的。该怎样把这些 数解释为浮点 值呢？看看标号为 . LC2 的声明， 有两个值： 3435973837</p><p>( Ox c c c c c c c d ) 和 1 0 73532 108 ( 0x 3 f f c c c c c ) 。因为机器采用的 是小端法字节顺 序， 第一个值给出的 是低位 4 字节 ， 第二个给出的是 高位 4 字节。从 高位字节， 可以 抽取指数字段为Ox 3 f f (l 0 23 ) , 减去偏 移 10 23 得到指数 0。将两个值的小数位连接起来， 得到小数字段</p><p>Oxccccccccccccd, 二进制小数表示 为 0. 8 , 加上隐含的 1 得到 1. 8 。</p><p>五 练习题 3. 55 解释标 号 为 . LC3 处声明 的数 字是 如何 对数 字 3 2. 0 编码的。</p><p>3. 1 1. 5 在浮点代码中使用位级操作</p><p>有时， 我们会发现 GCC 生成的 代码会在 XM M 寄存器上执行位级操作， 得到有用的浮点结果。图 3-50 展示了一些相关的指令， 类似千它们在通用寄存器上对应的操作。这些操作都作用千封装好的 数据， 即它们更新 整个目的 XM M 寄存器， 对两个 源寄存 器的所有位都实 施指定 的位级操 作。 和前面一样， 我们只对标量数据感兴趣， 只 想了解这些指令对目的寄存器的低 4 或 8 字节的 影响 。从下面的例子中可以 看出， 运用 这些操作 通常 可以简单方便地操作 浮点数。</p><p>单精度 双精度 效果 描述</p><p>vxorps vandps</p><p>vorpd andpd</p><h6 id=o--s-s->o- s,-s ,
<a class=anchor href=#o--s-s->#</a></h6><p>o- s, &amp;s ,</p><p>位级异或 ( EXCLUS IVE - OR)</p><p>位级 与C AN DJ</p><p>图 3-50 对封装数 据的位级操 作（这些指令 对一个 XM M 寄存器中的 所有 128 位进行 布尔操作）</p><p>霆 练习题 3. 56 考 虑下 面的 C 函数 ， 其 中 EXPR 是用 # d e f i ne 定义的 宏：</p><p>double simplefun(double x) { return EXPR(x);</p><p>｝</p><p>下面，我们给出 了为不 同 的 EXPR 定义 生成 的 AV X Z 代 码， 其 中， x 的 值保 存在%xmrn0 中。这些代码都对应于某些对浮点数值有用的操作。确定这些操作都是什么。要理解 从内存中取出的常数字的位模式才能找出答案。</p><p>。</p><p>。</p><p>3. 11 . 6 浮点比较操作</p><p>AVX2 提供了两条用 千比较 浮点数值的指令 ：</p><p>指令</p><p>UCOffilSS S1, s,</p><p>ucornisd S1 , S,</p><p>基于</p><p>S, - S1</p><p>s , —S1</p><p>描述</p><p>比较单精度值比较双精度值</p><p>这些指令类 似千 CMP 指令（参见3. 6 节）， 它们都比较操作数 S 1 和 S 2 (但是顺序可能与预计的相反）， 并且设置条件码 指示它们的相对值。与 cmpq 一样， 它们遵循以相反顺序列出操 作数的 A T T 格式惯 例。参数 S 2 必 须在 XM M 寄存器中， 而 S 1 可以 在 XM M 寄存器中，也可以在内存中。</p><p>浮点比较指令会设置三个条件码： 零标志位 ZF 、 进位标志位 CF 和奇偶标志位 PF。</p><ol><li><p>6. 1 节中我们没有讲奇偶 标志位， 因为它 在 GCC 产生的 x86 代码中不 太常见 。对于整数操作 ， 当最近的 一次算术或逻辑 运算产生的值的最低位字节是偶校验的（即这个字节中有偶数个 1) &rsquo; 那么就会设置这个标志位。不过对于浮点比较， 当两个操作数中任一个是Na N 时， 会设置该位。根 据惯例， C 语言中如果有个参数为 N a N , 就认为比较失败了， 这个标 志位就被用来发 现这样的 条件。例如 ， 当 x 为 N a N 时， 比较 x == x 都会得到 0。</p><p>条件码的设置条件如下：</p><p>顺序 s, ,s, CF ZF PF</p><p>无序的 1 1</p><p>S2 &lt; S1 1</p><p>S 2= 5 1</p><p>S2>S1</p></li></ol><p>当任一操作数为 N a N 时， 就会出 现无序 的情况。可以 通过奇偶 标志位发 现这种情 况。通常 JP 勺um p on parity ) 指令是条件跳转 ， 条件就是 浮点比较得到一个无序的结果。除了这种情况以外， 进位和零标志位的值都 和对应的无符号比较一样 ： 当两个操作数相等时 ， 设置 ZF; 当 S2&lt; S1 时， 设置 CF。像 j a 和 j b 这样的指令可以根据标志位的各种组合进行条件跳转。</p><p>来看一个浮点比较的例子 ， 图 3-5 l a 中的 C 函数会根据参数 x 与 o. 0 的相对关 系进行分</p><p>类， 返回一个枚举类型作为结果 。C 中的枚举类型是编码为整数的 ， 所以 函数可能 的值为：</p><p>O ( NEG) , lCZERO), 2 ( POS ) 和 3 ( 0 THER) 。当 x 的值为 N a N 时， 会出现最后一种结果 。</p><p>typedef enum {NEG, ZERO, POS, OTHER} range_t; range_t find_range(float x)</p><p>｛</p><p>int result;</p><p>if (x &lt; 0)</p><p>result= NEG; else if (x == 0)</p><p>result= ZERO; else if (x > 0)</p><p>result= POS;</p><p>else</p><p>result= OTHER;</p><p>return result;</p><p>｝</p><ol><li>C代码</li></ol><table><thead><tr><th></th><th>range_t find_range(float x)</th><th></th><th></th></tr></thead><tbody><tr><td></td><td>x in %xmm0</td><td></td><td></td></tr><tr><td>1</td><td>find_range:</td><td></td><td></td></tr><tr><td>2</td><td>vxorps %xmml , %xmml , %xmm1</td><td></td><td>Set %xmm1 = 0</td></tr><tr><td>3</td><td>vucomiss %xmm0, %xmm1</td><td></td><td>Compare O:x</td></tr><tr><td>4</td><td>ja .15</td><td></td><td>If >, goto neg</td></tr><tr><td>5</td><td>vucom1ss %xmm1, %xmm0</td><td></td><td>Compare x : O</td></tr><tr><td>6</td><td>jp .L8</td><td></td><td>If NaN, goto posornan</td></tr><tr><td>7</td><td>movl $1, %eax</td><td></td><td>result= ZERO</td></tr><tr><td>8</td><td>je .L3</td><td></td><td>It=, goto done</td></tr><tr><td>9</td><td>.L8:</td><td></td><td>posornan:</td></tr><tr><td>10</td><td>vucomiss .LCO(%rip),</td><td>%xmm0</td><td>Compare x:O</td></tr><tr><td>11</td><td>setbe %al</td><td></td><td>Set result= NaN? 1 : 0</td></tr><tr><td>12</td><td>movzbl %al, %eax</td><td></td><td>Zero-extend</td></tr><tr><td>13</td><td>addl $2, %eax</td><td></td><td>result += 2 (P OS for > 0, OTHER for NaN)</td></tr><tr><td>14</td><td>ret</td><td></td><td>Return</td></tr><tr><td>15</td><td>.L5:</td><td></td><td>neg:</td></tr><tr><td>16</td><td>movl $0, %eax</td><td></td><td>r se ul t = NEG</td></tr><tr><td>17</td><td>.L3:</td><td></td><td>done :</td></tr><tr><td>18</td><td>rep; ret</td><td></td><td>Return</td></tr></tbody></table><p>b ) 产生的汇编代码</p><p>图 3-51 浮点代码中的条件分支说明</p><p>GCC 为 丘nd _ r a ng e 生成图 3-51 6 中的代码。这段 代码的效率不是很高： 它比较了 x</p><p>和 0. 0 三次 ， 即使一次比较就能获得所需的信息。它还生成了浮点 常数两次： 一次使用</p><p>vxorps, 另一次从内存读出这个值。让我们追踪这个函数，看看四种可能的比较结果：</p><p>X &lt; 0. 0 第 4 行的 j a 分支指令会选择跳转 ， 跳转到结尾 ， 返回值为 0。</p><p>x=O. 0 j a ( 第 4 行）和j p ( 第 6 行）两个分支语句都 会选择不 跳转 ， 但是 j e 分支（第8</p><p>行）会选择跳转，以% e a x 等于 1 返回 。</p><p>X > 0. 0 这三个分支都不会选 择跳 转。s e t b e ( 第 11 行）会得到 o ,</p><p>行）会把它增加 ， 得到返 回值 2。</p><p>a d d l 指令（第1 3</p><p>x=NaN jp 分支（第6 行）会选择跳转。第三个 v uc omi s s 指令（第10 行）会设置进位和零 标志位， 因此 s e t b e 指令（第11 行）和后面的指令会把% e a x 设置为 1 。a d d l 指令</p><p>（第 13 行）会把它增加， 得到返 回值 3。</p><p>家庭作业 3. 73 和 3. 74 中， 你需要试着 手动生成 f i nd _r a ng e 更高效 的实现。</p><p>讫 练习题 3. 57 函数 f unc t 3 有 如下 原 型：</p><p>double funct3(int *ap, double b, long c, float *dp);</p><p>对于此函数， GCC 产 生如下 代码 ：</p><p>double funct3(int•ap, double b, long c, fl oat •dp) ap in r% di , b in %xmm0, c in %rsi, dp in %rdx funct3:</p><p>vmovss (%rdx), %xmm1</p><p>vcvtsi2sd (%rdi), %xmm2, %xmm2</p><p>vucomisd %xmm2, %xmm0 jbe .18</p><p>vcvtsi2ssq %rsi, %xmm0, %xmm0 vmulss %xmm1, %xmm0, %xmm1 vunpcklps %xmm1, o/.xmm1, %xmm1</p><p>vcvtps2pd %xmm1, %xmm0</p><p>ret</p><p>.18:</p><p><img src=img/2afc64644be360bdcecb571cc47e07ea.jpeg alt>vaddss %xmm1, %xmm1, %xmm1 vcvtsi2ssq %rsi, %xmm0, %xmm0 vaddss %xmm1, %xmm0, %xmm0 vunpcklps %xmm0, %xmm0, %xmm0</p><p>vcvtps2pd %xmm0, %xmm0 ret</p><p>写出 f unc t 3 的 C 版本。</p><ol><li><p>11 . 7 对浮点代码的观察结论</p><p>我们可以 看到 ，用 AVX 2 为浮点 数上的 操作产生的机器代码 风格类 似千为 整数上的 操作产生 的代码风格 。它们都 使用一组寄存器来保存和操作数 据值 ， 也都使用这些寄存器来传递函数参数。</p><p>当然，处理不同的数据类型以及对包含混合数据类型的表达式求值的规则有许多复杂 之处 ， 同时， AVX2 代码包括许 多比只执行整数 运算的 函数更加不同的 指令和格式 。</p><p>AVX2 还有能力 在封装好的 数据上执行并行 操作， 使计算执行 得更快。编译器开发 者正致力于自动化从标量代码到并行代码的转换，但是目前通过并行化获得更高性能的最可</p></li></ol><p>靠的方法是使 用 GCC 支持的、操纵向量数 据的 C 语言扩展。参见原书 546 页的网络旁 注</p><p>OPT: SIMD, 看看可以怎么做到这样。</p><p>3. 12 小结</p><p>在本章 中， 我们窥 视了 C 语言提供的 抽象层下面的 东西，以 了 解机器级编程。 通过 让编译 器产生机器级程序的 汇编代码 表示 ， 我们 了解了编译器和它的优化能力， 以及机器、数 据类型和指 令集。 在第 5 章，我们会看到，当编写能有效映射到机器上的程序时，了解编译器的特性会有所帮助。我们还更完整 地了 解了 程序如何 将数 据存储在不同的内 存区域中 。在第 12 章 会看 到许多 这样的 例子， 应用 程序员需 要知道一 个程序变 量是 在运行时 栈中， 是在某个 动态分 配的 数据结构中， 还是全局程序数 据的一部分。理解程序如何映射到机器上，会让理解这些存储类型之间的区别容易一些。</p><p>机器级 程序和它们的 汇编代 码表示 ， 与 C 程序的差别很大。各 种数据类型之间的差别很小。程 序是以指令序列来表示的，每条指令都完成一个单独的操作。部分程序状态，如寄存器和运行时栈，对程序 员来说是直接可见的。本书仅提供了低级操作来支持数据处理和程序控制。编译器必须使用多条指令来 产生和操作各 种数据结构， 以及实现像 条件 、循环和过 程这样的控制结 构。我 们讲述了 C 语言和如 何编译它的许多不同方面。我 们看到 C 语言中缺乏边界检查， 使得许多程序容易 出现缓 冲区 溢出。虽 然最近的运行时系统提供了安全保护，而且编译器帮助使得程序更安全，但是这巳经使许多系统容易受到恶意 入侵者的攻击。</p><p>我们只分析了 C 到 x86-64 的映射， 但是 大多 数内容对其他语言和机器组合来说也是类似的 。例如， 编译 C++ 与编译 C 就非常相似。实际 上 ， C++ 的早期 实现 就只是 简单地执行了从 C++ 到 C 的源到源的 转换 ， 并对结果 运行 C 编译器， 产生目标 代码。C++ 的对象 用结构来表示 ， 类似千 C 的 s t r uc t 。C++ 的方法是 用指向实现方法的 代码的 指针来 表示的。相比而言 ， J ava 的实现方式完全不同。Java 的目标代码是一种特殊的 二进制表示 ， 称为 Java 宇节代码。这 种代码 可以 看成是虚拟机的机器级 程序。正 如它的名字暗示的那样，这种机器并不是直接用硬件实现的，而是用软件解释器处理字节代码，模拟虚拟机的 行为。另外 ， 有一种称 为及 时编译 ( jus 臼 n-t ime compila tion) 的方法， 动态地将字节代码序列 翻译 成机器指令。当代码要执行多次时（例如在循环中），这种方法执行起来更快。用字节代码作为程序的低级表示， 优点是相同的代码可以 在许多 不同的 机器上执行 ， 而在本章 谈到的机器代码只能 在 x86-64 机器上运行。</p><p>参考文献说明</p><p>Intel 和 AMD 提供 了关于他们处理器的 大量文档。包括从汇编语言程序员 角度来看硬件的概貌[ 2,</p><p>50], 还包 括每条指 令的详 细参考 [ 3 , 51] 。读指令 描述很 复杂 ， 因为 1) 所有的 文档都 基于 Inte l 汇编代码格式 ， 2 ) 由于不同的寻址和执行模 式， 每条指 令都 有多个变种， 3 ) 没有说明性示例。不 过这些文档仍然是关于每条指令行为的权威参考。</p><p>组织 x86-64. org 负责定义运行 在 Linux 系统 上的 x86-64 代码的应用二进制接口( A pp licatioin Binary Interface, ABI) [ 77] 。这个 接口描述 了一些细节 ， 包括过程 链接、二 进制代码文件和大最的为了让机器代码程序正确运行所需要的其他特性。</p><p>正如我 们讨论过的那 样， GCC 使用的 AT T 格式与 Intel 文档中使用的 Intel 格式和其他编译 器（包括</p><p>Microsoft 编译器）使用的格式 都很不相同。</p><p>Muchn ick 的关于编译器设 计的书[ 80] 被认 为是 关千代 码优化技术最 全面的 参考书。 它涵盖了许多我们在此讨论过的技术，例如寄存器使用规则。</p><p>已经有很多 文章 是关于使用缓 冲区溢出通过因特网来 攻击系统 的。Spafford 出版了关于 1988 年因特网蠕虫的详细分析[ 105] , 而帮助阻 止它传播的 MIT 团队的成员也出版了一些论著[ 35] 。从那以后，大噩的论文和项目提出了各 种创建和阻 止缓 冲区溢出攻 击的方 法。Seacord 的书[ 97] 提供 了关于缓 冲区 溢出和其他一些 对 C 编译器产生的 代码 进行攻 击的 丰富信息 。</p><p>家庭作业</p><ul><li>3. 58 一个函数的原型为</li></ul><p>long decode2(long x, long y, long z);</p><p>GCC 产生如下 汇编代 码：</p><p>1 decode2 :</p><p>subq imulq movq salq sarq xorq</p><p>8 ret</p><p>%rdx, %rsi</p><p>%rsi, %rdi</p><p>%rsi, %rax</p><p>$63, %rax</p><p>$63, %rax</p><p>%rdi, %rax</p><p>•• 3. 59</p><p>参数 x 、 y 和 z 通过寄 存器%r d i 冷r s i 和% r d x 传递。代码 将返回值 存放在 寄存器 % r a x 中 。写出等价 于上述 汇编代 码的 de c ode 2 的 C 代码 。</p><p>下面的代码计算 两个 64 位有 符号 值 工 和 y 的 128 位乘积， 并将结果存储在内存中：</p><p>typedef int128 int128_t;</p><p>void store_prod(int128_t *dest, int64_t x, int64_t y) {</p><p>*dest = x * (int128_t) y;</p><p>｝</p><p>GCC 产出下面的 汇编代 码来实现计算 ：</p><p>s t or e _pr od :</p><p>movq %rdx, %rax cqto</p><p>movq sarq imulq imulq addq mulq addq movq movq ret</p><p>%rsi, %rcx</p><p>$63, %rcx</p><p>%rax, %rcx</p><p>%rsi, %rdx</p><p>%rdx, %rcx</p><p>%rsi</p><p>%rcx, %rdx</p><p>%r ax , (%rdi)</p><p>%rdx, 8(%rdi)</p><p>•• 3. 60</p><p>为了 满足 在 64 位机器上实现 128 位运 算所需的多精度计算， 这段代 码用了三个乘法。描 述用来计算乘积的 算法， 对汇编代 码加注释， 说明它是如何 实现你的 算法的。提示： 在把参数 x 和 y</p><p>扩展到 1 28 位时 ， 它们可以 重写为 x = 264 • x, +x, 和 y = zs• • y, + y ,&rsquo; 这里 x, &rsquo; x ,&rsquo; y, 和 y , 都是</p><p>64 位值。类似地 ， 1 28 位的乘 积可以写成 p = 26 1·. p , + p, , 这里 p , 和 p , 是 64 位值。 请解 释这 段代码是 如何 用 x, &rsquo; x ,&rsquo; y, 和 y , 来计算 p , 和 p , 的。</p><p>考虑下面的 汇编代码 ：</p><p>long loop(long x, int n) x in¾rdi, n i n ¾es1</p><p>l oop :</p><p>movl movl movl jmp</p><p>. L3 :</p><p>movq andq orq salq</p><p>.L2 :</p><p>%esi, %ecx</p><p>$1, %edx</p><p>$0 , %eax</p><p>. L2</p><p>o/.rdi, 壮 8 o/.rdx, o/.r8 o/.r8, o/.rax</p><p>%cl, o/.rdx</p><p>testq %rdx, %rdx jne . L3</p><p>rep; ret</p><p>以上代 码是编译以 下整体形式的 C 代码产生的 ：</p><p>long loop(long x, int n)</p><p>｛</p><p>long result= long mask;</p><p>for (mask = ; mask result I=·- &ndash; - '</p><p>; mask =) {</p><p>｝</p><p>return result;</p><p>｝</p><p>•• 3. 61</p><p>•• 3. 62</p><p>你的任务是 填写这个 C 代码中缺失的部分， 得到一个程序 等价 千产生的 汇编代码 。回想一下， 这个 函数的结 果是在寄存 器%r a x 中返回的 。你会发现以下 工作很有帮助： 检查循环之前 、之中和之后的 汇编 代码 ， 形成一个寄存器 和程序变最 之间一致的映射 。</p><ol><li><p>哪个寄存器保存 着程序值 x、n 、r e s u l t 和 ma s k?</p></li><li><p>r e s u l t 和 ma s k 的初始值是 什么？</p></li><li><p>ma s k 的测试条件是什么？</p></li><li><p>ma s k 是如何被修改的？</p></li><li><p>r e s ul t 是如何被修改的</p></li><li><p>填写这段 C 代码中所有 缺失的部分。</p><p>在 3. 6. 6 节， 我们 查看了下面的 代码， 作为使用 条件数据传送的一 种选择 ：</p><p>long cread(long•xp) { return (xp? *xp: 0);</p></li></ol><p>我们给出了使用 条件传送指令的一个尝试实现， 但是 认为它是不合法的， 因为它 试图从一个空地址读数据。</p><p>写一个 C 函数 c r e a d_a l 七， 它与 c r e a d 有一样的 行为，除 了 它可以 被编译成使用条件数 据传送。当编译时，产生的代码应该使用条件传送指令而不是某种跳转指令。</p><p>下面的代码给出了一个 开关语 句中根 据枚 举类型值进行分支选择的 例子。回忆 一下 ， C 语言中枚举类型只是一种引人一组与整数值 相对应的 名字的方法。默认情况下，值 是从 0 向上依次赋给名字的。在我们 的代码中 ， 省略了与各种情况标 号相对应的动作 。</p><p>/• Enumerated type creates set of constants numbered O and upward•/ typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE 王 } mode_t;</p><p>long switch3(long *p1, long *p2, mode_t action)</p><p>｛</p><p>long result= O; switch(action) { case MODE_A:</p><p>case MODE_B: case MODE_C: case MODE_D: case MODE_E: default:</p><p>｝</p><p>return result;</p><p>产生的 实现各个动 作的汇编代 码部分如图 3-52 所示。注释指明 了参数位置， 寄存器值， 以及各个跳转目的的情况标号。</p><p>pl i n 肛 di , p2 i n r幻 si , action in¾edx</p><p>. L 8 : MODE_E</p><p>movl $27, %eax ret</p><p>. L3 :</p><p>movq movq movq ret</p><p>.L5:</p><p>movq</p><p>addq movq ret</p><p>.L6:</p><p>movq movq ret</p><p>.L7:</p><p>movq movq movl ret</p><p>.L9:</p><p>movl ret</p><p>(%rsi), %rax (%rdi), %rdx 沿·dx , (壮 s i )</p><p>(¾rdi), ¾rax (¾r s 立 ， ¾r ax</p><p>¾rax, (¾rdi)</p><p>$59, (¾rdi) (¾rsi), ¾rax</p><p>(&lsquo;Y.rsi),&lsquo;Y.rax</p><p>&lsquo;Y.rax, ( 壮 di )</p><p>$27,&lsquo;Y.eax</p><p>$12, %eax</p><p>MODE_A</p><p>MODE_B</p><p>MODE_C</p><p>MDDE_D</p><p>default</p><p>图 3- 52 家庭作业 3. 62 的汇编代码。这 段代码 实现了 s wi t c h 语句的各个分 支</p><p>&ldquo;3. 63</p><p>填写 C 代码中缺失的部分。代码包括落人 其他情况的 情况， 试着重建 这个情况。</p><p>这个程 序给你一个 机会， 从反汇编机 器代 码逆向 工程一个 s wi t c h 语句。在下面这 个过程中 ， 去掉了 s wi t c h 语句的主体 ：</p><p>long switch_prob(long x, long n) { long result= x;</p><p>switch(n) {</p><p>/• Fill in code here•/</p><p>｝</p><p>return result;</p><p>图 3-53 给出了这 个过程的 反汇编机 器代 码。</p><p>跳转表驻 留在内 存的不同区域中。可以从 第 5 行的间接跳 转看出来， 跳转表的 起始地址 为 Ox 4006f 8。用调试器 G DB , 我们可以 用命 令 x / 6g x Ox 4006f 8 来检查组 成跳转表的 6 个 8 字节字的内存。G DB 打印出下 面的内 容：</p><p>(gdb) x/6gx Ox4006f8</p><p>Ox4006f 8 : Ox00000000004005a1 Ox400708: Ox00000000004005a1 Ox400718: Ox00000000004005b2</p><p>Ox00000000004005c3 Ox00000000004005aa Ox00000000004005bf</p><p>用 C 代码填写开关语句的 主体 ， 使它的行 为与机器代 码一致。</p><p>long s wit c h _pr ob(l ong x , long n) x in r7. di , n i n 肛 si</p><p>0000000000400590 &lt;switch_prob>:</p><p>400590: 48 83 ee 3c</p><p>400594: 48 83 fe 05</p><p>400598: 77 29</p><p>40059a: ff 24 f5 f8 06 40 00</p><p>4005a1: 48 8d 04 fd 00 00 00</p><p>4005a8: 00</p><p>4005a9: c3</p><p>4005aa: 48 89 f8</p><p>4005ad: 48 c1 f8 03</p><p>4005b1: c3</p><p>4005b2: 48 89 f8</p><p>4005b5: 48 c1 eO 04</p><p>4005b9: 48 29 f8</p><p>4005bc: 48 89 c7</p><p>4005bf : 48 Of af ff</p><p>4005c3: 48 8d 47 4b</p><p>4005c7: c3</p><p>sub cmp ja jmpq lea</p><p>retq mov sar retq mov shl sub mov imul lea retq</p><p>$0x3c,%rsi</p><p>$0x5,%rsi</p><p>4005c3 &lt;switch_prob+Ox33></p><p>*Ox4006f8(,%rsi,8) Ox0(,%rdi,8),%rax</p><p>%r d i , %r a x</p><p>$0x3,%rax</p><p>%rdi,%rax</p><p>$0x4,%rax</p><p>%rdi,%rax</p><p>%rax,%rdi</p><p>%rdi,%rdi Ox4b(%rdi),%rax</p><p>•＊• 3. 64</p><p>图 3-53 家庭作业 3. 63 的反汇编代 码</p><p>考虑下面的 源代 码， 这里 R 、 S 和 T 都是用 #d e f i ne 声明的常数 ：</p><p>long A [R] [SJ [Tl ;</p><p>long store_ele(long i, l ong j, long k, long *dest)</p><p>｛</p><p>*&lt;lest = A [i] [j] [k];</p><p>return sizeof(A);</p><p>｝</p><ul><li><p>3 65</p><p>在编译这个 程序中 ， G CC 产生下面的 汇编代 码：</p><p>longs t or e _el e ( l ong i , long j, long k, long *des t ) i in¾rdi, j in r 无 si , k i n 肛 dx, dest in¾rcx store_ele:</p><p>leaq (%rsi,%rsi,2), %rax leaq (%rsi,%rax,4), %rax movq %rdi, %rsi</p><p>salq $6, %rsi</p><p>addq %rsi, %rd1</p><p>addq %rax, %rdi</p><p>addq %rdi, %rdx</p><p>movq A(,%rdx,8), %rax movq %rax, (%r cx )</p><p>movl $3640, i 儿 eax</p><p>ret</p></li></ul><ol><li><p>将等式 ( 3. 1 )从二维扩展 到三维 ， 提供数组 元素 A [ i ] [ j ] [ k l 的位置的公 式。</p></li><li><p>运用 你的逆向 工程技术 ， 根据汇编代码 ， 确定 R 、S 和 T 的值。</p><p>下面的代 码转置一个 M X M 矩阵的元素 ， 这里 M 是一个用 #d e f i ne 定义的常数 ：</p><p>void transpose(long A[M] [M]) { long i, j;</p><p>for (i = 0; i &lt; M; i ++)</p><p>for (j = 0; j &lt; i ; j ++ ) { long t = A[i][j]; A[i][j] = A[j][i];</p><p>A [j] [i] = t;</p></li></ol><p>｝</p><p>｝</p><p>当用优化等级 - 0 1 编译时， GCC 为这 个函数的内 循环产生下 面的 代码 ：</p><p>. L6 :</p><p>movq movq movq movq addq addq cmpq jne</p><p>(%rdx), %rcx (%rax), %rsi</p><p>%rsi, (%rdx)</p><p>%rcx, (%rax)</p><p>$8, %rdx</p><p>$120, %rax</p><p>%rdi, %rax</p><p>. L6</p><ul><li><p>3. 66</p><p>我们可以 看到 GCC 把数组索 引转换 成了指 针代 码。</p></li></ul><ol><li><p>哪个寄存器保 存着指向 数组元素 A [ i ] [ j ]的指针？</p></li><li><p>哪个寄 存器保 存着指向 数组元素 A [ j J [ i ] 的指针？</p></li><li><p>M 的值是多少？</p><p>考虑下 面的 源代 码， 这里 NR 和 NC 是用 #d e f i ne 声明的宏表达式 ， 计算用参数 n 表示 的矩阵 A 的维度。这段代码计算矩阵的第）列的元素之和。</p></li></ol><p>long sum_col(long n, long A[NR(n)] [NC(n)], long j) { long i;</p><p>long result= O;</p><p>for (i = O; i &lt; NR(n); i++) result += A [i] [j] ;</p><p>return result;</p><p>｝</p><p>编译这个程 序， GCC 产生下 面的 汇编代码 ： long sum_col(long n , long A[NR( n)] [ NC(n)] , l ong j) n i n 肛 di , A 江 Zrs i , j in Zrdx</p><p>sum_col:</p><p>leaq leaq movq testq jle salq leaq movl movl</p><p>.L3:</p><p>1 (, o/.rdi, 4) , o/.r8</p><p>(o/.rdi,o/.rdi,2), o/.rax o/.rax, o/.rdi</p><p>o/.rax, o/.rax</p><p>.L4</p><p>$3, o/.r8 (o/.rsi,o/.rdx,8), o/.rcx</p><p>$0, o/.eax</p><p>$0, o/.edx</p><p>addq (%rcx), %rax</p><p>addq $1, %rdx</p><p>addq 缸8 , %rcx</p><p>cmpq %rdi, %rdx</p><p>jne .L3</p><p>rep; ret</p><p>.L4:</p><p>movl ret</p><p>$0, %eax</p><p>" 3. 67</p><p>运用 你的逆向 工程技术 ， 确定 NR 和 NC 的定义。</p><p>这个作业要查看 GCC 为参数和返回 值中有结 构的 函数产生的 代码 ， 由此可以 看到这 些语言特性通常是如何实现的。</p><p>下面的 C 代码中有 一个函数 pr o c e s s , 它用结 构作为参数 和返 回值， 还有 一个函数 e v a l , 它调用 p r o c e s s :</p><p>typedef struct { long a[2];</p><p>long•p;</p><p>} strA;</p><p>typedef struct { long u[2]; long q;</p><p>} strB;</p><p>strB process(strA s) { strB r;</p><p>r.u[O) = s . a [1) ;</p><p>r.u[1) = s . a [O) ;</p><p>r.q =•s.p; return r;</p><p>｝</p><p>long eval (long x, long y, long z) { strA s;</p><p>s.a[O] = x;</p><p>s.a[l] = y;</p><p>s.p = &amp;z;</p><p>strBr = process(s);</p><p>return r.u[O] + r.u[l] + r.q;</p><p>｝</p><p>GCC 为这 两个函数产生下 面的 代码 ：</p><p>strB process (strA s) process:</p><p>movq</p><p>movq movq movq movq movq movq movq ret</p><p>¾rdi, ¾rax 24(¾rsp), ¾rdx (¾rdx), ¾rdx 16(¾rsp), ¾rcx</p><p>¾rcx, (¾rdi) 8(¾rsp), ¾rcx</p><p>¾rcx, 8(¾rdi)</p><p>¾rdx, 16(¾rdi)</p><p>long eval(long x, long y , long z)</p><table><thead><tr><th>1</th><th>x in r% d,i eval:</th><th>y in %rsi, z in %rdx</th></tr></thead><tbody><tr><td>2 3</td><td>subq movq</td><td>$104, 7,rsp 7.rdx, 24(7,rsp)</td></tr><tr><td>4</td><td>leaq</td><td>24(7.rsp), 7.rax</td></tr><tr><td>5</td><td>movq</td><td>7.rdi, (7.rsp)</td></tr><tr><td>6</td><td>movq</td><td>7.rsi, 8(7.rsp)</td></tr><tr><td>7</td><td>movq</td><td>7.rax, 16(7.rsp)</td></tr><tr><td>8</td><td>leaq</td><td>64(7.rsp), 7.rdi</td></tr><tr><td>9</td><td>call</td><td>process</td></tr><tr><td>10</td><td>movq</td><td>72(7.rsp), 7,rax</td></tr><tr><td>11</td><td>addq</td><td>64(7.rsp), 7.rax</td></tr><tr><td>12</td><td>addq</td><td>80(7.rsp), 7.rax</td></tr><tr><td>13</td><td>addq</td><td>$104, 7.rsp</td></tr><tr><td>14</td><td>ret</td><td></td></tr></tbody></table><ol><li>从 e va l 函数的第 2 行我们 可以 看到， 它在栈上分 配了 104 个字节 。画出 e va l 的栈帧 ，给出它在调用 pr oc e s s 前存储在栈上的值。<ol><li>e va l 调 用 pr oc e s s 时传递了什么值？</li><li>p r o c e s s 的代码是 如何访间结 构参数 s 的元素的？</li><li>pr oc e s s 的代码是如何设 置结 果结构r 的字段的？</li></ol></li></ol><p>·: 3. 68</p><ol><li>完成 e va l 的栈帧图 ，给出 在从 pr oc e s s 返回后 e va l 是如何访问 结构 r 的元素的 。<ol><li><p>就如何传递作为函数参数的结构以及如何返回作为函数结果的结构值，你可以看出什么通用的 原则？</p><p>在下 面的代码中 ， A 和 B 是用ii de f i ne 定义的常数 ：</p><p>typedef struct {</p><p>int x[A] [BJ; /• Unknown constants A and B•/ long y ;</p><p>} strl;</p></li></ol></li></ol><p>typedef struct { char array[B]; int t;</p><p>short s [A]; long u;</p><p>} str2;</p><p>void setVal(strl *P, str2 *q) { long vl = q->t;</p><p>long v2 = q->u; p->y = vl+v2;</p><p>｝</p><p>GCC 为 s e t Va l 产生下 面的代 码：</p><p>void set Val ( srt 1 *P, s tr 2 • q)</p><p>p i n 肛 di , q 江</p><p>set Val :</p><p>r¼ si</p><p>movslq addq</p><p>movq ret</p><p>8(%rsi), %rax 32(%rsi), %rax</p><p>¼rax, 184(%r d立</p><p>·: 3. 69</p><p>A 和 B 的值是多少？（答案是唯一的。）</p><p>你负责维 护一个大型的 C 程序， 遇到下面的代 码：</p><p>typedef struct {</p><p>2 int first;</p><p>3 a_struct a[CNT];</p><p>4 int last;</p><p>5 } b_struct;</p><p>6</p><p>void test(long i, b_struct *bp)</p><p>8 ｛</p><p>9 int n = bp->first + bp->last;</p><p>10 a_struct *ap = &amp;bp->a[i];</p><p>11 ap->x[ap->idx] = n; 12</p><p>编译时常数 CN T 和结构 a _ s tr uc t 的声明是在一 个你没有访问权限的文件中。幸好， 你有代</p><p>码的 .o&rsquo; 版本 ， 可以 用 OBJDUMP 程序来 反汇编这些 文件 ， 得到下面的 反汇编代码 ：</p><p>void test (long i, bs_ tr uct • bp) i in 7.rdi, bp in 7.rsi</p><p>0000000000000000 &lt;test>:</p><p>0: Sb Se 20 01 00 00</p><p>6: 03 Oe</p><p>S : 4S Sd 04 bf</p><p>c: 4S Sd 04 c6</p><p>10: 4S Sb 50 OS</p><p>14: 4S 63 c9</p><p>mov Ox120(¾rsi),¾ecx add (¾rsi),¾ecx</p><p>lea (¾rdi,¾rdi,4),¾rax lea (¾rsi,¾rax,8),¾rax mov Ox8(¾rax),¾rdx movslq¾ecx,¾rcx</p><p>17:</p><p>le:</p><p>48 89 4c dO 10</p><p>c3</p><p>mov retq</p><p>%rcx,Ox10(%rax,%rdx,8)</p><p>*＊* 3. 70</p><p>运用你的逆向工程技术，推断出下列内容：</p><ol><li><p>CNT 的值。</p></li><li><p>结构 a s tr uc t 的完整声 明。假设 这个结构中只有字段 i d x 和 x , 并且这两个字段保存的都是有符号值。</p><p>考虑下面的联合声明：</p><p>union ele {</p><p>struct {</p><p>long *p; long y;</p><p>} el; struct {</p><p>long x;</p><p>union ele *next;</p><p>} e2;</p></li></ol><p>};</p><p>这个声明说明联合中可以 嵌套结 构。</p><p>下面的 函数（省略了一些表达式）对一个链表进行 操作 ， 链表是以 上述联 合作 为元素的 ：</p><p>void proc (union ele *up) {</p><p>up- > - = * C-</p><p>｝</p><p>— ) －；</p><ol><li><p>下列字段的偏移址是多少（以字节为单位）：</p><p>e1.p e1.y e2.x e2.next</p><ol><li><p>这个结构总共需要多少个字节？</p></li><li><p>编译器为 pr oc 产生下 面的 汇编代 码：</p><p>void proc (union el e • up ) up in¾rdi</p><p>proc:</p></li></ol></li></ol><p>movq movq movq subq movq ret</p><p>8(%rdi), %rax (%rax), %rdx (%rdx), %rdx 8(%rax), %rdx</p><p>%rdx, (%r d 立</p><ul><li>3. 71</li></ul><p>•• 3. 72</p><p>在这些 信息的基础上 ， 填写 p r oc 代码中 缺失的 表达式。提示： 有些联合引用的解 释可以 有歧义 。当你 清楚引用指引到哪里的 时候， 就能够澄清 这些歧义。只有一个答案， 不需 要进行强制类型转换， 且不违反 任何类 型限 制。</p><p>写一个函数 g ood _e c ho , 它从标准输人读取一行，再把它写到标准输出。你的实现应该对任意长度的 输入行都能工作。可以 使用库 函数 f ge ts , 但是你必须确保即使当输入行要求比你已经为缓冲区分配的更多的空间时，你的函数也能正确地工作。你的代码还应该检查错误条件，要在遇到 错误条件时返 回。参 考标 准 I/ 0 函数的定 义文 档[ 45 , 61] 。</p><p>图 3-54a 给出了一 个函数的代 码， 该函数类 似于函 数 v f u nc t ( 图 3- 43a ) 。我们用 v f unc t 来说明过帧指针在管 理变长栈帧中的 使用情况 。这里的新 函数 a fr a me 调用库函数 a l l oc a 为局 部数组 p 分配空间 。a l l o c a 类似于更常用的 函数 ma l l oc , 区别在于它在运行 时栈上分 配空间。当正在执行的过程返回时 ，该 空间 会自动释放 。</p><p>图 3-54 b 给出了部 分的汇编代码， 建立帧指针， 为局部变量 1 和 p 分 配空间。非常类似于</p><p>第 3 章 程序的机器级表示 225</p><p>v fr a me 对应的 代码。在此使用与练习题 3. 49 中同样的表示 法： 栈指针在第 4 行设置为值 S1 , 在 第 7 行设置为值 切。 数组 p 的起始地址 在第 9 行被设置为值 p。Sz 和 p 之间可能 有额外的 空间 e,&rsquo;</p><p>数组 p 结尾和 S1之间可能 有额外的空间 e, .</p><ol><li><p>用数学语言解 释计算 S2 的逻辑 。</p></li><li><p>用数学语言 解释计算 p 的逻辑 。</p></li><li><p>确定使 e1 的值最小 和最大的 n 和 s , 的值。</p></li><li><p>这段代 码为 Sz 和 p 的值保证了怎 样的对齐属性？</p><p>#include &lt;alloca.h></p></li></ol><p>long aframe(long n, long idx, long *q) long i;</p><p>long **P = alloca(n * sizeof(long *)); p[O] = &amp;i;</p><p>for (i = 1 ; i &lt; n; i ++)</p><p>p[i] = q; return *p[idx];</p><ol><li>C代码</li></ol><p>l ong 红 r ame (l ong n, long i dx, l ong • q)</p><p>n 江 肛 di , i dx in i.rsi , q 耳 1 ri. dx aframe:</p><p>图 3 - 54</p><p>b ) 部分生成的汇编代码</p><p>家庭作业 3. 72 的代码。该函数类似于图 3- 43 中的函数</p><ul><li>3. 73</li></ul><p>•• 3. 74</p><ul><li>3. 75</li></ul><p>用汇编代码 写出匹配图 3-51 中函数 f i nd_r a nge 行为的 函数。你的代码必须只包含一个浮点 比较指令，并用条件分支指令来生成正确的结果。在产种可能的参数值上测试你的代码。网络旁注 ASM : EASM 描述了如何在 C 程序中嵌 入汇编代 码。</p><p>用汇编代码写出匹配图 3-51 中函数 f i nd_r a nge 行为的 函数。你的代码必须只包含一个浮点 比较指令 ， 并用条件传 送指令 来生成 正确的结果。你可能 会想要 使用指令 c movp ( 如果设置了 偶校验位传送）。在沪 种可能的 参数值上测试你的代 码。网 络旁 注 ASM : EASM 描述了如何在 C 程序中嵌入汇编代码。</p><p>ISO C99 包括了支持 复数的 扩展 。任何 浮点 类型都可以 用关键字 c o mp l e x 修饰。这里有一些使用复数数据的示例函数，调用了一些关联的库函数：</p><p>#include &lt;complex.h></p><p>double c_imag(double complex x) { return cimag(x);</p><p>｝</p><p>double c_real(double complex x) { return creal(x);</p><table><thead><tr><th>9</th><th>}</th><th></th></tr></thead><tbody><tr><td>10</td><td></td><td></td></tr><tr><td>11</td><td>double complex c_sub(double complex x, double complex y)</td><td>{</td></tr><tr><td>12</td><td>return x - y;</td><td></td></tr><tr><td>13</td><td>}</td><td></td></tr></tbody></table><p>编译时， G CC 为这些 函数产生如下 代码：</p><p>double c_imag(double compl e x x)</p><ol><li>c_imag:</li><li>movapd %xmm1, %xmm0 ret</li></ol><p>double c_real (doubl e complex x)</p><ol><li>c_real:</li><li>rep; ret</li></ol><p>double complex c_sub(double complex x, double complex y)</p><ol start=3><li><p>c_sub:</p><p>subsd %xmm2, %xmm0</p></li><li><p>subsd %xmm3, %xmml</p></li><li><p>ret</p></li></ol><p>根据这些例子，回答下列问题：</p><ol><li>如何向函数传递 复数 参数？</li><li>如何从函数返回复数值？</li></ol><p>练习题答案</p><ol start=3><li>1 这个练习使你熟悉各种操作数格式。</li></ol><table><thead><tr><th>操作数</th><th></th><th>值</th><th>注释</th><th></th></tr></thead><tbody><tr><td>%r a x</td><td></td><td>Ox l OO</td><td>寄存器</td><td></td></tr><tr><td>Oxl 04</td><td></td><td>OXAB</td><td>绝对地址</td><td></td></tr><tr><td>$0x l 08</td><td></td><td>Ox l 08</td><td>立即数</td><td></td></tr><tr><td>(%r a x )</td><td></td><td>OXFF</td><td>地址 Ox l</td><td>OO</td></tr><tr><td>4 ( %r a x )</td><td></td><td>OXAB</td><td>地址 Ox l</td><td>04</td></tr><tr><td>9 ( %r a x, % r dx )</td><td></td><td>Ox ll</td><td>地址 Ox l</td><td>OC</td></tr><tr><td>260 ($r c x, % r d x</td><td>)</td><td>Oxl3</td><td>地址 Ox l</td><td>08</td></tr><tr><td>OXFC (, %r c x , 4)</td><td></td><td>OxFF</td><td>地址 Ox l</td><td>OO</td></tr><tr><td>( %r a x , %r dx, 4)</td><td></td><td>Oxll</td><td>地址 Oxl</td><td>OC</td></tr></tbody></table><p>3 2 正如我们已 经看到的 ， G CC 产生的 汇编代码指令上有后缀， 而反 汇编代码没有。能 够在这两种形式之间转换是 一种很 重要的 需要学习的技能。一个重要的特性就是， x 8 6 - 6 4 中的内存引 用总是用四字长寄存器给出 ， 例如釭a x , 哪怕操作数只是 一个字节 、一个字或是 一个双字。</p><p>这里是带后缀的代码：</p><p>movl %eax, (%rsp) mov11 (%rax), %dx movb $0xFF, %bl</p><p>movb (%rsp,%rdx,4), %dl movq (%rdx), %rax</p><p>mo 四 %dx , (%rax)</p><p>3. 3 由于我们会依 赖 GCC 来产生大多 数汇编代码 ， 所以能够写正确的汇编 代码并不是一项很关键的技能。但是， 这个练习会帮助你熟 悉不同的 指令和操作 数类型。</p><p>下面给出了有错误解释的代码：</p><p>movb $0xF, (%ebx) Cannot use Y.ebx as address register</p><p>movl %rax, (%rsp) Mismatch be 切 een ins tr uct io n s 立 f i x 却 d register ID</p><p>movw (%rax),4(%rsp) Cannot have both source and destination be memory references movb %al, %s1 No register named Y.sl</p><p>movq %rax, $0x123 Cannot have 1·mmed1·ate as destination</p><p>movl %eax,%rdx Destination ope 丘 u,d incorrect size</p><p>movb %s i, 8 (%rbp) Mismatch between instruction s吐丘x 迎 dr egis t er ID</p><p>3.4 这个练习 给你更多 经验，关 于不同的数据传送指令， 以及它们与 C 语言的数据类 型和转换规则的关系。</p><table><thead><tr><th>src t</th><th>dest t</th><th>指令</th><th>注释</th></tr></thead><tbody><tr><td>long</td><td>long</td><td>movq ( %r d 习，%r a x rnovq % r a x, ( % r s i )</td><td>读 8 个字节 存 8 个字节</td></tr><tr><td>char</td><td>int</td><td>novsbl(%rdi),%eax movl %e a x, ( % r s i )</td><td>将 c ha r 转换成 i nt 存 4 个字节</td></tr><tr><td>char</td><td>unsigned</td><td>rnovs bl ( %r d习，%e a x movl %e a x , 伐 r s i )</td><td>将 c ha r 转换成 i nt 存 4 个字节</td></tr><tr><td>unsigned char</td><td>long</td><td>movzbl(%rdi),%eax movq %r a x , (%rsi)</td><td>读一个字节并零扩展 存 8 个字节</td></tr><tr><td>int</td><td>char</td><td>movl (%rdi) , %e a x movb %a l , (%rsi)</td><td>读 4 个字节 存低位字节</td></tr><tr><td>unsigned</td><td>unsigned char</td><td>rnov l ( %r d 习，%e a x movb %a l , ( %r s 习</td><td>读 4 个字节 存低位字节</td></tr><tr><td>char</td><td>short</td><td>movs bw ( %r d i ) , %a x movw %a x , (%rsi)</td><td>读一个字节并符号扩展 存 2 个字节</td></tr></tbody></table><ol><li><p>5 逆向工程是一 种理解 系统的好方法。在此， 我们想要逆转 C 编译器的效果， 来确定什么样的 C 代码会得到这样的 汇编代码 。最好的方法是 进行 “模拟＂， 从值 x 、y 和 z 开始， 它们分别在指 针 x p 、</p><p>yp 和 z p 指定的位置。于是 ， 我们可以 得到下面这样的效 果：</p><p>voi d decode1 (l ong •xp , long *YP, l ong 五 p) xp in 7.rdi, yp in 7.rsi, zp in 7.rdx</p><p>decodel:</p></li></ol><table><thead><tr><th>movq movq</th><th>(o/.rdi), o/.r8 (%rsi), %rcx</th><th>Get x =•xp Get y = • yp</th></tr></thead><tbody><tr><td>movq</td><td>(&lsquo;Y.rdx),&lsquo;Y.rax</td><td>Getz=•zp</td></tr><tr><td>movq</td><td>%r8, (%rsi)</td><td>Store x at yp</td></tr><tr><td>movq</td><td>%rcx, (%rdx)</td><td>Store y at zp</td></tr><tr><td>movq ret</td><td>%rax, (%rdi)</td><td>Store z at xp</td></tr></tbody></table><p>由此可以产生下 面这样 的 C 代码：</p><p>void decode1(long *xp, long *YP, long *zp)</p><p>｛</p><p>long x = *xp; long y = *yp; long z = *zp;</p><p>*YP = x;</p><p>•zp = y;</p><p>•xp = z;</p><p>3 6 这个练习说明 了 l e a q 指令的 多样性，同 时也让你更多地练习解读各种操作数形式。虽然在图 3-3</p><p>中有的操作数格式被划分为“内存”类型，但是并没有访存发生。</p><table><thead><tr><th>指令</th><th>结果</th></tr></thead><tbody><tr><td>leaq 6 ( 毛r a x ) , %r dx</td><td>6+.r</td></tr><tr><td>l eaq ( 令 r a x , %r c x ) , %r dx</td><td>工 + y</td></tr><tr><td>leaq(%rax,%rcx,4),%rdx</td><td>工+ 4y</td></tr><tr><td>leaq 7 (%rax, % r a x , 8), %rdx</td><td>7+ 9 工</td></tr><tr><td>leaq OxA (, % r c x , 4), % r dx</td><td>10+4y</td></tr><tr><td>l eaq 9(%rax, %r c x , 2 ) , %rdx</td><td>9+.r+Zy</td></tr></tbody></table><p>3 7 逆向 工程再 次被证明是学 习 C 代码和生成的 汇编代 码之间 关系的 有用 方式。</p><p>解决此类型问题的最好方式是为汇编代码行加注释，说明正在执行的操作信息。下面是一个 例子：</p><p>long scale2(long x, long y, long z) x in i.rdi, y in½rsi, z in i.rdx</p><p>scale2:</p><table><thead><tr><th>leaq</th><th>(%rdi, %rdi, 4) , %rax</th><th>5•</th><th>x</th></tr></thead><tbody><tr><td>leaq</td><td>(%rax,%rsi,2), %rax</td><td>5•</td><td>x + 2• y</td></tr><tr><td>leaq</td><td>(%rax,%rdx,8), %rax</td><td>5•</td><td>x + 2• y + 8• z</td></tr><tr><td>ret</td><td></td><td></td><td></td></tr></tbody></table><p>由此很容易得到缺失的表达式：</p><p>long t = 5 * x + 2 * y + 8 * z;</p><p>3. 8 这个练习使你有机会检验对操作数和算术指令的理解。指令序列被设计成每条指令的结果都不会影响后续指令的行为。</p><table><thead><tr><th>指令</th><th>目的</th><th>值</th></tr></thead><tbody><tr><td>addq %rcx, (毛r a x )</td><td>OxlOO</td><td>OxlOO</td></tr><tr><td>subq %rdx, 8 ( % r a x )</td><td>Oxl08</td><td>OxAB</td></tr><tr><td>耳 nul q $16, ( % r a x, % r dx, 8)</td><td>OxllB</td><td>OxllO</td></tr><tr><td>incq 16( 令r a x )</td><td>OxllO</td><td>Oxl4</td></tr><tr><td>decq %rcx</td><td>%rcx</td><td>OxO</td></tr><tr><td>subq %rdx, % r a x</td><td>%rax</td><td>OXFD</td></tr></tbody></table><p>3. 9 这个练习使你有机 会生成一点汇编代码。 答案的代码由 GCC 生成。将参数 n 加载到寄存器%e c x</p><p>中， 它可以 用字节 寄存 器%c l 来指定 s ar l 指令的移位量。使用 mo v l 指令看上去有点 儿奇怪， 因为</p><p>n 的长度是 8 字节， 但是要 记住只有最低位的 那个字节 才指 示着移 位量。</p><p>long shitt_left4_rightn(long x, long n)</p><p>X 立 7.r di , n in 7.rsi shift_left4_rightn:</p><table><thead><tr><th>movq</th><th>%rdi, %rax</th><th>Get x</th></tr></thead><tbody><tr><td>salq</td><td>$4, %rax</td><td>x«= 4</td></tr><tr><td>movl</td><td>%esi, %ecx</td><td>Get n (4 bytes)</td></tr><tr><td>sarq</td><td>%cl, %rax</td><td>x»= n</td></tr></tbody></table><p>3. 10 这个练习 比较简单 ， 因为汇编代 码基本上 沿用 了 C 代码的结构。</p><p>long tl = x I y; long t2 = tl»3; long t3 = -t2; long t4 = z-t3;</p><p>3. 11</p><p>3. 12</p><p>3 13</p><p>3. 14</p><p>3 15</p><ol><li><p>这个指令用来将寄存器 %r dx 设置为 o, 运用了对任意 x , 工＾工=O 这一属性。它对应于 C 语句 x= O。</p></li><li><p>将寄存 器%r dx 设 置为 0 的更直接的 方法是用 指令 mov q $0, %r dx 。</p></li><li><p>不过， 汇编 和反 汇编这段 代码 ， 我们 发现使用 xor q 的版本 只需要 3 个字节， 而使用 movq 的版本需要 7 个字节。其 他将 %r d x 设 置为 0 的方法都依 赖于这样一个 属性 ， 即任何 更新低位 4 字节的指令都 会把 高位字 节设 置为 0 。因此， 我 们 可以使用 xo r l % edx, % edx ( 2 字节）或 mov l</p><p>$0,% e d x( 5 字节）。</p><p>我们可以 简单地把 c q t o 指令替换为将寄 存器 %r d x 设置为 0 的指令 ， 并且用 d i vq 而不是 迈i v q 作为我们的除法指令，得到下面的代码：</p><p>void ru em 中 v( uns i gned long x, unsigned long y, unsigned long *qp, unsigned long•rp)</p><p>x rn i.rdi , y in i.rsi , qp i n 肛 dx , rp in i.rcx uremdiv:</p></li></ol><p>汇编代码不会记录程序值的类型，理解这点这很重要。相反地，不同的指令确定操作数的大小以 及是有符号的 还是无 符号的。当从指令序列映 射回 C 代码时 ， 我们必 须做一点儿侦查 工作， 推断程序值的数据类型。</p><ol><li><p>后缀 &rsquo; l &rsquo; 和寄 存器指示符 表明 是 32 位操 作数 ， 而比 较是对补码的＜ 。 我们可以 推断 da t a _ t -</p><p>定是 i n t 。</p></li><li><p>后缀｀矿和寄存 器指示符 表明是 16 位操 作数， 而比较是对补码的 ＞＝ 。 我们可以 推断 da t a _ 七一定是 s ho r t 。</p></li><li><p>后缀＇矿和寄存器指示符表明是 8 位操作数 ， 而比较是对无 符号数的 ＜＝ 。 我们可以 推断 da t a _ t</p><p>一定是 uns i g ne d c har 。</p><p>_o. 后缀＇矿和寄存器指示符 表明是 64 位操作数， 而比较是！＝ ， 有符 号、无符号和指 针参数都是一样的。我们可以推断 da t a _ t 可以 是 l o ng 、uns i g ne d l ong 或者某 种形式的 指针。</p><p>这道题 与练习题 3. 13 类似， 不同的是它使用了 T EST 指令而不是 CMP 指令。</p></li><li><p>后缀＇矿和寄存器指 示符 表明是 64 位操 作数， 而比较是＞＝ ， 一定是有符号数。我们可以 推断</p><p>da t a _ 七一定是 l o ng 。</p></li><li><p>后缀＇矿和寄存器指 示符 表明 是 16 位操作数， 而比较是＝＝， 这个对有符号和无 符号都是一样的。我们可以 推断 da t a _ 七一定是 s ho r t 或者 u ns i g ne d s hor t 。</p></li><li><p>后缀｀矿和寄存器指示符表明是 8 位操作数 ， 而比较是 针对无 符号数的＞。 我们 可以 推断 da t a _ t</p><p>一定是 uns i g ne d c har 。</p></li><li><p>后缀&rsquo; l &rsquo; 和寄存器指示符 表明是 32 位操作数 ， 而比较是＜＝ 。 我们可以 推断 da t a_t 一定是 m七。这个练习要求你仔细检查反汇编代码，并推理跳转目标的编码。同时练习十六进制运算。</p></li><li><p>j e 指令的目标为 Ox 4003f c + Ox 02。如原始的反汇编代码所示 ， 这就是 Ox 4003f e 。</p></li></ol><p>4003fa: 74 02</p><p>4003fc: ff dO</p><p>Je callq</p><p>4003fe</p><p>*%rax</p><ol start=2><li>j b 指令的目标是 Ox 400431 - 1 2 ( 由于 Ox f 4 是— 1 2 的一个字节的 补码表示）。正如原 始的 反 汇编代码所示 ， 这就是 Ox 400425:</li></ol><p>40042f: 74 f4</p><p>400431: 5d</p><p>je pop</p><p>400425</p><p>%rbp</p><ol start=3><li>根据反 汇编器 产生的注释， 跳转目标是绝对地址 Ox 400547 。根据字节编码， 一定在距离 po p</li></ol><p>指令 Ox 2 的地址处 。减去这个值就得到地址 Ox 400545 。 注意， j a 指令的编码需要 2 个字节， 它一定 位于地址 Ox 4005 43 处。检查原始的反汇编代码 也证实了这一点 ：</p><p>400543: 77 02</p><p>400545: 5d</p><p>ja 400547</p><p>pop %rbp</p><ol start=4><li><p>以相反的顺 序来 读这些 字 节， 我 们看 到 目 标 偏 移 量 是 Ox f f f f f f7 3 , 或者 十 进 制数 一 141 。</p><p>Ox 4005e d ( no p 指令的 地址）加上这个 值得到地址 Ox 4 00560 :</p></li></ol><p>4005e8 : e9 73 ff ff ff</p><p>4005ed : 90</p><p>jmpq 400560 nop</p><p>3 16 对汇编 代码写 注释， 并且模仿 它的控 制流来 编写 C 代码， 是理解汇编语 言程序很好的第一步。本题是一个具有简单 控制流的示 例， 给你一个 检查 逻辑操作实 现的机会。</p><ol><li><p>这里是 C 代码：</p><p>void goto_cond(long a, long•p) {</p><p>if (p == 0)</p><p>goto done;</p><p>if (*p >= a)</p><p>goto done;</p><p>*P = a;</p><p>done : return;</p></li><li><p>第一个条件分支是 ＆＆ 表达式 实现的一部分。如果 对 p 为非 空的测试失败， 代码会跳 过对 a >*p</p><p>的测试。</p></li><li><p>17 这个练习帮助你思考一个通用的翻译规则的思想以及如何应用它。</p><ol><li><p>转换成这种替代的形式，只需要调换一下几行代码：</p><p>long gotodiff_se_alt(long x, long y) { long result;</p><p>if (x &lt; y)</p><p>goto x_l t _y ; ge_cnt++; result= x - y ; return result;</p><p>x_lt_y:</p><p>lt_cnt++; result= y - x; return result;</p></li></ol></li><li><p>在大多 数情况下 ， 可以 在这 两种方式中 任意选择。但是原来的方法对常见的没有 e l s e 语句的情况更好 一些。对于这种情况， 我们只用 简单地将 翻译规则修改 如下 ：</p><p>t = test-expr;</p><p>if (!t)</p><p>goto done; then-statement</p><p>done :</p></li></ol><p>基于这种替代规则的翻译更麻烦一些。</p><p>3. 18 这个题目要求你完成一个嵌 套的分 支结构， 在此 你会看到 如何使用翻译 if 语句的规则。大部 分情况下 ， 机器代码就是 C 代码的 直接翻译 。</p><p>long test (long x, long y, long z) { long val= x+y+z;</p><p>if (x &lt; -3) {</p><p>if (y &lt; z)</p><p>val= x•y;</p><p>else</p><p>val= y•z;</p><p>} else if (x > 2) val= x•z;</p><p>return val;</p><p>｝</p><ol><li>19 这道题巩固加强了我们计算预测错误处罚的方法。<ol><li>可以 直接应用公 式得到 T),le =2 X (31-16) = 30。<ol><li>当预测错误时 ， 函数会需 要大 概 1 6 + 30 = 46 个周期 。</li></ol></li></ol></li><li>20 这道题提供了研究条件传送使用的机会。<ol><li><p>运算 符是＇／＇。可以 看到这 是一个通过右移 实现除以 2 的 3 次幕的例子（见2. 3. 7 节）。在移位</p><p>k = 3之前 ， 如果被除数 是负数的话 ，必 须加上偏移 扯 2&rsquo; - 1 = 7。</p></li><li><p>下面是该汇编代码加上注释的一个版本：</p><p>long arith(long x) x in 7.rdi</p><p>arith:</p></li></ol></li></ol><table><thead><tr><th>leaq</th><th>7(%rdi) , %rax</th><th>temp = x+7</th></tr></thead><tbody><tr><td>testq</td><td>%rdi, %rdi</td><td>Test x</td></tr><tr><td>cmovns</td><td>%rdi, %rax</td><td>If x>= O, temp = x</td></tr><tr><td>sarq</td><td>$3, %rax</td><td>result = temp»3 (= x/ 8)</td></tr><tr><td>ret</td><td></td><td></td></tr></tbody></table><p>这个 程序创建一 个临 时值等于 工 + 7 , 预期 工 为负，需 要加偏 移量时使用。c mov ns 指令在当</p><p>:r o 条件成 立时 把这个 值修改 为 :r ， 然后再移动 3 位， 得到 可 8。</p><p>3. 21 这个题目类 似于练 习题 3. 18 , 除了有些条件语句是用条件数据传送实现的。虽然将这段代码装进到原始的 C 代码中看起来 有些 令人惧怕， 但是你会 发现它 相当严格地 遵守了翻译 规则。</p><p>long test(long x, long y) { long val= 8•x;</p><p>if (y > 0) {</p><p>if (x &lt; y)</p><p>val= y-x;</p><p>else</p><p>val= x&amp;y;</p><p>} else if (y &lt;= -2) val= x+y;</p><p>return val;</p><p>｝</p><ol><li>22 A. 如果构建一张使用 数据类型 i nt 来计算的 阶乘表， 得到下 面这 样的 表：</li></ol><p>n n! OK?</p><table><thead><tr><th></th><th>1</th><th>I</th><th>Y</th><th></th></tr></thead><tbody><tr><td></td><td>2</td><td>2</td><td>Y</td><td></td></tr><tr><td></td><td>3</td><td>6</td><td>Y</td><td></td></tr><tr><td></td><td>4</td><td>24</td><td>Y</td><td></td></tr><tr><td></td><td>5</td><td>120</td><td>Y</td><td></td></tr><tr><td></td><td>6</td><td>720</td><td>Y</td><td></td></tr><tr><td></td><td>7</td><td>5 040</td><td>Y</td><td></td></tr><tr><td></td><td>8</td><td>40 320</td><td>Y</td><td></td></tr><tr><td></td><td>9</td><td>362 880</td><td>Y</td><td></td></tr><tr><td></td><td>10</td><td>3 628 800</td><td>Y</td><td></td></tr><tr><td></td><td>11</td><td>39916800</td><td>Y</td><td></td></tr><tr><td></td><td>12</td><td>479 001 600</td><td>Y</td><td></td></tr><tr><td></td><td>13</td><td>1 932 053 504</td><td>N</td><td></td></tr></tbody></table><p>我们可以 看到 ， 计算 13 ! 溢出了。正 如在练习题 2. 35 中学到的那样， 还 可以 通过计算</p><p>.:r/n, 看它 是否 等于 ( n - 1) ! 来测试 n ! 的计算是 否溢出了（假设我们已经能够保证( n— 1 ) ! 的计算没有溢 出）。在此处 ， 我们得到 1 932 053 504 / 13 = 161 004 458. 667 。另外有个测试方法，</p><p>可以 看到 10 ! 以上的 阶乘数都 必须是 100 的倍数， 因此最 后两位数字必 然是 0。13 ! 的正确值应该是 6 227 020 800 。</p><p>B. 用数据类 型 l o ng 来计算 ， 直到 20 ! 才溢出， 得到 2 432 902 008 176 640 000 。</p><p>3 23 编译循环产生的代码可能会很难分析，因为编译器对循环代码可以执行许多不同的优化，也因为可能 很难把程序变 量和寄存器 匹配起 来。 这个 特殊的例子展 示了几个汇编代码不仅仅是 C 代码直接翻译的地方。</p><ol><li><p>虽然参 数 x 通过寄存 器%r d i 传递给函 数， 可以 看到一旦进入循环就再也没有引 用过该寄存器了。 相反， 我们看 到第 2 ~ 5 行上寄 存器 %r a x 、%r c x 和%r d x 分别被初始化为 x、x*x 和 x+x 。因此可以推断，这些寄存器包含着程序变量。</p></li><li><p>编译器认 为指 针 p 总是指向 X , 因此表达式 (*p ) ++就能够实现 x 加一。代码通过第 7 行的 l e aq</p><p>指令 ， 把这个 加一 和加 y 组合起 来。</p></li><li><p>添加了注释的代码如下：</p><p>long d巳 l oop(l ong x) x initially in¼rdi</p><p>1 dw_loop:</p><p>movq %rdi, %rax Copy x to i.rax movq %rdi, %rcx</p><p>4 imulq %rdi, %rcx Compute y = x*x</p><p>5 leaq (%rdi, %rdi) , %rdx Compute n = 2*x</p><p>6 •12: loop</p></li></ol><table><thead><tr><th>7</th><th>leaq</th><th>1(%rcx,%rax),</th><th>%rax</th><th>Compute x += y + 1</th></tr></thead><tbody><tr><td>8</td><td>subq</td><td>$1, %rdx</td><td></td><td>Decrement n</td></tr><tr><td>9</td><td>testq</td><td>%rdx, %rdx</td><td></td><td>Test n</td></tr><tr><td>10</td><td>jg</td><td>.L2</td><td></td><td>If> 0, goto l oop</td></tr><tr><td>11</td><td>rep; ret</td><td></td><td></td><td>Return</td></tr></tbody></table><p>3. 24 这个汇编代码 是用跳转到中间 方法对循 环的 相当直接的 翻译。完整的 C 代码 如下 ：</p><p>long loop_while(long a, long b)</p><p>long result= 1; while (a&lt; b) {</p><p>result = result * (a+b); a = a+l;</p><p>return result;</p><p>3. 25 这个汇编代 码没有完 全遵 循 g ua rded-do 翻译的模式 ， 可以 看到它 等价于下 面的 C 代码 ：</p><p>long loop_while2(long a, long b)</p><p>long result= b; while (b > 0) {</p><p>result= result* a; b = b-a;</p><p>return result;</p><p>我们 会经常看 到这 样的情 况， 特别是用 较高优化 等级 编译 时， 此时 GCC 会自作 主张地 修改生成代码的格式，同时又保留所要求的功能。</p><p>3. 26 能够从汇编代码 工作回 C 代码， 是逆向 工程的 一个主要例子。</p><ol><li>可以 看到这 段代码使用的 是跳转到中间 翻译方法， 在第 3 行使用了 j mp 指令。<ol><li><p>下面是原 始的 C 代码：</p><p>long fun_a(unsigned long x) { long val; O;</p><p>while (x) {</p><p>val ; x;</p><p>X >>1; ;</p></li></ol></li></ol><p>return val&: Ox1;</p><ol><li><p>这个代码计算 参数 x 的奇偶 性。也就是， 如果 x 中有奇 数个 1&rsquo; 就返回 1, 如果有偶 数个 1, 就返回 0。</p><p>3. 27 这道练习题 意在加强 你对如何 实现循环的理 解。</p><p>long fact_for_gd_goto(long n)</p></li></ol><p>long i; 2; long result ; 1; if (n &lt;; 1)</p><p>goto done;</p><p>l oop :</p><p>result*; i;</p><p>i++;</p><p>辽 ( i &lt;; n)</p><p>goto loop;</p><p>done :</p><p>return result;</p><ol><li>28 这个间 题比练习题 3. 26 要难一些， 因为循 环中的代 码更复杂 ， 而整个 操作也不那么熟悉。<ol><li><p>以下是原始的 C 代码：</p><p>long fun_b(unsigned long x) { long val; O;</p><p>long i;</p><p>for (i; 64; i !; O; i 一 ）｛</p><p>val ; (val«1) I (x&: Ox1);</p><p>X»; 1;</p></li></ol></li></ol><p>return val;</p><ol><li><p>这段代码是 用 g uarded-do 变换生成的， 但是编译器发现因为 l. 初始 化成了 64 , 所以一定会满足测试 i# O, 因此初始的测试是没必要的。</p><p>c. 这段代 码把 x 中的位反 过来， 创造一个镜像 。实现的 方法是 ： 将 x 的位从 左往右移， 然后再填</p><p>入这些 位， 就像是把 va l 从右往左 移。</p></li><li><p>29 我们把 f or 循环翻译 成 wh il e 循环的规则有些过于简单 这是唯 一需要特殊考虑的 方面。</p><ol><li><p>使用我们的翻译规则会得到下面的代码：</p><p>I* Naive translation of for loop into while loop *I I* WARNING: This is buggy code *I</p><p>long sum= O;</p><p>long i = O; while (i &lt; 10) {</p><p>辽 ( i & 1)</p><p>I* Thi s 甘 i ll cause an infinite loop *I continue;</p><p>sum += i; i++;</p><p>｝</p></li></ol></li></ol><p>因为 c o n t i nue 语句会阻止索引变量 l. 被修改 ，所 以 这段代码是无限循环。</p><ol><li><p>通用的解决方法是用 g o t o 语句替 代 c o n t i nue 语句 ，它 会 跳 过循环体中余下的部分，直 接跳到</p><p>up d a t e 部 分 ：</p><p>I* Correct translation of for loop into while loop *I long sum= O;</p><p>long i = O;</p><p>while (i &lt; 10) {</p><p>辽 ( i & 1)</p><p>goto update; sum += i;</p><p>upda t e :</p><p>i++;</p><p>｝</p></li><li><p>30 这个练习给你一个机会， 推算出 s wi t c h 语 句 的 控制流。要求你将汇编代码中的多处信息综合起来回答这些问题：</p><ul><li>汇编代码的第 2 行将 x 加上 1, 将情况( cases ) 的下界设置成 0。这就意味着最小的 清况标 号 为一1 。</li><li>当调整过的情况值大于 8 时 ，第 3 行 和第 4 行 会导致 程序跳转到默认情况。这就意味着最大情况 标 号 为—1 + 8 = 7。</li><li>在 跳 转表中， 我们看到第 6 行 的 表项（情况值 3) 与第 9 行 的 表项（情况值 6) 都以 第 4 行 的 跳 转指令 作 为 同 样的目标( .L2) , 表明这是默认的情况行为。因此 ，在 s wi t c h 语 句 体 中 缺失了情况标号 3 和 一6。</li><li>在跳转表中， 我们看到第 3 行和第 10 行上的表项有相同的目的。这对应于情况标号 0 和 7 。</li><li>在跳转表中， 我们看到第 5 行 和第 7 行 上 的 表项有相同的目的。这对应于情况标号 2 和 4。从上述推理，我们得出如下结论：</li></ul></li><li><p>s w itch 语句体中的情况标号值为— 1 、0 、1 、2 、4 、5 和 7 。</p></li><li><p>目标为.L5 的 清况 标号为 0 和 7。</p></li><li><p>目标为.L7 的 情况 标号为 2 和 4。</p><p>3 . 31 逆 向 工 程编译出 s wi t c h 语 句 ，关 键 是 将 来 自汇 编 代码 和跳转表的信息结 合起来 ， 理 清 不 同 的情况 。 从 j a 指 令（第 3 行 ）可知，默 认 情 况 的 代码的标号是 . L2。我们可以 看到，跳 转表中只有另一个 标 号 重 复出现，就 是 . LS, 因 此 它 一 定 是 情 况 C 和 D 的 代 码 。 代 码 在 第 8 行 落 人 下 面的 情况， 因 而 标 号 . L7 符合情况 A , 标号 . L 3 符合情况 B。只剩下标号 . L6 , 符合情况 E 。</p><p>原始的 C 代 码 如下 ：</p><p>void switcher(long a, long b, long c, long *dest)</p><p>｛</p><p>long val;</p><p>S廿i t ch(a) { case 5:</p><p>c = b - 15;</p><p>I* Fall through *I case 0:</p><p>val = c + 112; break;</p><p>case 2:</p><p>case 7:</p><p>val = (c + b)«2; break;</p><p>case 4:</p><p>val = a; break;</p><p>default:</p><p>val= b;</p><p>｝</p><p>*dest = val;</p><p>｝</p></li></ol><p>3 32</p><p>3 33</p><p>追踪此等级上的程序的执行有助于理解过程调用和返回的很多方面。可以明确看到调用时控制是 怎么传 给过 程的以 及返回时 调用函数如何继续执行的。还可以看到参数通过寄存器%r d i 和％工s i传递 ，结 果通过寄 存器% r a x 返回。</p><table><thead><tr><th>指令</th><th>状态值（指令开始执行前）</th><th>描述</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>标号</td><td>PC</td><td>指令</td><td>%rdi</td><td>号r s i</td><td>%r a x</td><td>%rsp</td><td>飞 r s p</td><td></td></tr><tr><td>Ml</td><td>Ox400560</td><td>callq</td><td>10</td><td></td><td></td><td>Ox7fffffffe820</td><td></td><td>调用 f ir s t (10)</td></tr><tr><td>Fl</td><td>Ox400548</td><td>lea</td><td>10</td><td></td><td></td><td>Ox7f f f ff f f e 818</td><td>Ox400565</td><td>丘r s t 的入口</td></tr><tr><td>F2</td><td>Ox40054c</td><td>sub</td><td>10</td><td>11</td><td></td><td>Ox7fffffffe818</td><td>Ox 40 0565</td><td></td></tr><tr><td>F3</td><td>Ox400550</td><td>callq</td><td>9</td><td>11</td><td></td><td>Ox7fffffffe818</td><td>Ox400565</td><td>调 用 l a s t (9, 11)</td></tr><tr><td>LI</td><td>Ox400540</td><td>rnov</td><td>9</td><td>11</td><td></td><td>Ox7fffffffe810</td><td>Ox400555</td><td>l a s t 的入口</td></tr><tr><td>L2</td><td>Ox400543</td><td>imul</td><td>9</td><td>11</td><td>9</td><td>Ox7fffffffe810</td><td>Ox400555</td><td></td></tr><tr><td>L3</td><td>Ox400547</td><td>retq</td><td>9</td><td>11</td><td>99</td><td>Ox7fffffffe810</td><td>Ox400555</td><td>从 l a s t 返回 99</td></tr><tr><td>F4</td><td>Ox400555</td><td>repz repq</td><td>9</td><td>11</td><td>99</td><td>Ox7fffffffe818</td><td>Ox400565</td><td>从 f ir s t 返回 99</td></tr><tr><td>M2</td><td>Ox400565</td><td>mov</td><td>9</td><td>11</td><td>99</td><td>Ox7fffffffe820</td><td></td><td>继续执行 ma i n</td></tr></tbody></table><p>由千是多种数据大小混合在一起，这道题有点儿难。</p><p>让我们先 描述第一种答案， 再解 释第二种可能性。如果 假设第一个加（第3 行）实现* u += a, 第二个加（第4 行）实现 v+= b , 然后 我们 可以 看到 a 通过 % e中 作为第 一个参 数传 递， 把它从 4 个字节转换 成 8 个字节， 再加到 %r d x 指向的 8 个字节上。这就意味着 a 必定 是 i n t 类型， u 一定是 l o ng * 类型。还可以看 到参数 b 的低位字节被加到了%r c x 指向的字节。 这就意味着 v 一定是char* , 但是 b 的类型是不 确定的- 它的大小 可以 是 1 、2、4 或 8 字节。 注意 到返回值为 6 就能解决 这种不 确定性， 这个返回 值是 a 和 b 大小的和。因为我们知道 a 的大小 是 4 字节， 所以可以推断出 b 一定是 2 字节的。</p><p>该函数的一 个加了注释的版本解释了这些 细节 ：</p><p>int procprobl (int a, short b, 1ong•u, char•v) a in 7.edi, b in ¾s i , u in¾rdx, v in¾rcx procprob:</p><p>movslq %edi, %rdi addq %rdi, (%rdx) addb %s il, (%rcx)</p><p>movl $6, %eax ret</p><p>Convert a to 1 ong</p><p>Add to•u (long)</p><p>Add low-order byte of b to•v Return 4+2</p><p>3 34</p><p>3. 35</p><p>此外 ， 我们可以 看到 如果以它们在 C 代码中出 现相反的 顺序在汇编代 码中计算这两个和， 这段汇编代码同 样合法。这 会导致交 换参数 a 和 b , 参数 u 和 V , 得到如下原型：</p><p>int procprob(int b, short a, long•v, char•u);</p><p>这个例子展示了被调用者保存寄存器的使用，以及保存局部数据的栈的使用。</p><ol><li><p>可以 看到第 9 ~ 14 行将局部值 a O~ a S 分别保 存 进 被调用者保存 寄存器%r b x 、%r l S 、%r 1 4、</p><p>沧r 13 、%r 1 2 和%r b p 。</p></li><li><p>局部值 a 6 和 a 7 存放在栈中 相对于栈指 针偏移量 为 0 和 8 的地方（第1 6 和 18 行）。</p></li><li><p>在存 储完 6 个局部变量之后 ， 这个程序用完了 所有的 被调用者保存 寄存器， 所以 剩下的两个值保存在栈上。</p><p>这道题给了一个检查递归函数代码的机会。要学的一个很重要的内容就是，递归代码与我们看到的其他函数的结构一模一样。栈和寄存器保存规则足以让递归函数正确执行。</p></li><li><p>寄存器 %r b x 保存参数 x 的值， 所以 它可以 被用来计算结果 表达式 。</p></li><li><p>汇编代码是由下 面的 C 代码产生而来的 ：</p></li></ol><p>long rfun(unsigned long x) { if (x == 0)</p><p>return O;</p><p>unsigned long nx = x>>2; long rv = rfun(nx); return x + rv;</p><p>3. 36</p><p>3 37</p><p>3 38</p><p>这个练习测试你 对数据大小 和数 组索引的理解。注意， 任何类型的指针都是 8 个字节长。 s hor t</p><p>数据类型需要 2 个字节 ， 而 i n t 需要 4 个。</p><table><thead><tr><th>数组</th><th>元素大小</th><th>总大小</th><th>起始地址</th><th>元素1</th></tr></thead><tbody><tr><td>s T u V w</td><td>2 8 8 4 8</td><td>14 24 48 32 32</td><td>Xs Xr Xu Xv x.</td><td>x,+2i XT + 8i Xv + 8i Xv +4i Xw+Bi</td></tr></tbody></table><p>这个练习是 关于整数 数组 E 的练习的一个变形。理 解指针与指 针指向的对象之间的区别是很重要的。因为数 据类型 s ho r t 需要 2 个字节， 所以所有的数组索引都将乘以因子 2。前面我 们用的是</p><p>movl, 现在用的则 是 mov w。</p><table><thead><tr><th>表达式</th><th>类型</th><th>值</th><th>汇编语句</th></tr></thead><tbody><tr><td>S+l S [3] &amp;S [i] S[4*i+l] S+i-5</td><td>short* short s ho r t * shor t short*</td><td>X5 + 2 M[x5 +6] x , +2i M[x5 + 8i + 2] X5 + 2i - 10</td><td>l e a l 2 ( %r d x ) , %r a x movw6(%rdx),%ax leal(%rdx,%rcx,2),%rax rnovw2(%rdx,%rcx,8),%ax l e a l - 1 0 ( %r d x , %r c x , 2 ) , %r a x</td></tr></tbody></table><p>这个练习要求 你完成 缩放操作 ， 来确定地址的 计算，并 且应用行 优先索引的公式( 3. 1 ) 。第一步是注释汇编 代码， 来确定 如何计算地址引 用：</p><p>long sum_element(long i, long J)</p><p>工 in 7.rdi, j in 7.rsi s um_el e ment :</p><p>leaq O (, %r di , 8) , %rdx</p><p>subq %rdi, %rdx</p><p>addq %rsi, %rdx</p><p>leaq (%rsi,%rsi,4), %rax addq %rax, %rdi</p><p>movq Q (, %rdi, 8) , %rax</p><p>addq P(,%rdx,8), %rax ret</p><p>Compute 81</p><p>Compute 7i Compute 7i + J Compute 51 Compute i + SJ</p><p>Retrieve M[xQ + 8 (5 」 + i)]</p><p>Add M (xp + 8 (7i + })]</p><p>3. 39</p><p>3. 40</p><p>我们可以看 出， 对矩阵 P 的引用是在字节偏移 8 X ( 九十））的地方， 而对矩阵 Q 的引用是在字节偏移 8 X ( 5 j + i ) 的地方。由此我们可以 确定 P 有 7 列， 而 Q 有 5 列， 得到 M = 5 和 N = 7。</p><p>这些计算 是公式( 3. 1) 的直接应用 ：</p><ul><li><p>对千 L = 4 , C = 1 6 和 ）= O, 指针 Ap tr 等千 x , +4X (1 6i + O) =x, + 64, 。</p></li><li><p>对千 L = 4 , C=l6, i= O 和 j = k , 指针 Bp tr 等千 x 8 + 4 X0 6 X O+ k ) = x a + 4 k 。</p></li><li><p>对于 L = 4 , C=l6, i= l6 和）= k , Be nd 等于 x 8 +4 X 06 X 16+k) =x8 + 1024 + 4k 。</p><p>这个练习要求你能够研究编译产生的汇编代码，了解执行了哪些优化。在这个情况中，编译器做 一些聪明的优化。</p><p>让我们先来研究 一下 C 代码， 然后看看如何从为原 始函数产生的汇编代码推导出这个 C</p><p>代码。</p></li></ul><p>I* Set all diagonal elements to val *I</p><p>void fix_set_diag_opt(fix_matrix A, int val) { int *Abase = &amp;A [OJ [OJ ;</p><p>long i = O;</p><p>long iend = N*(N+1); do {</p><p>Abase[iJ = val; i += (N+1);</p><p>} while (i != iend);</p><p>这个函 数引 入了一 个变量 Aba s e , int * 类型的， 指向数组 A 的起始位置。 这个指针指向一个 4 字节整数序列 ， 这个序列由按 照行优先顺 序存放的 A 的元素组 成。我们引 入一个 整数 变量 i n­</p><p>dex, 它一步一步经过 A 的对角线 ， 它有一个属性 ， 那就是对角线 元素 l 和 i + l 在序 列中 相隔 N +</p><p>1 个元素， 而且一旦 我们 到达对角线 元素 N ( 索引为 N ( N + l ) ) , 我们就超出了边界。</p><p>实际的汇编代 码遵循这样的通 用 格式， 但是现在指针的增加必须乘以因子 4。我们将寄存器釭a x 标记为存放 值 i nd e x 4 , 等于 C 版本中的 i n d e x , 但是使用因子 4 进行伸缩。对于 N = l 6 , 我们可以 看到对于 i n d e x 4 的停止点会是 4 · 160 6 + 1 ) = 1088 。</p><p>fix_set_diag:</p><p>void fix_set_diag(fix_matrix A, int val) A i n 肚 di , val in 7.rsi</p><p>movl $0, %eax</p><p>.L13:</p><p>movl %esi, (%rdi, %rax) addq $68, %rax</p><p>cmpq $1088, i,rax</p><p>jne .L13</p><p>rep; ret</p><p>Set index4 = 0 l oop:</p><p>Set Abase [in dex4/ 4] to val Increment index4 += 4(N+1)</p><p>Compare index4: 4N(N+1) If!=, goto l oop</p><p>Return</p><p>3. 41</p><p>这个练习让 你思考结构的布局 ， 以及用来访问 结构字段的代码。该结构声明是书中 所示例子的 一个变形。它表明嵌套的结构的分配是将内层结构嵌人到外层结构之中。</p><ol><li>该结构的布局图如下：</li></ol><p>偏 移 0</p><p>内容[</p><p>s.x 产 s . y</p><p>24</p><p>next</p><ol start=2><li><p>它使用 了 24 个字节。</p><p>c. 同平时一样， 我们从 给汇编代 码加注释开始：</p><p>void sp_init(struct prob•sp) s p in 7.rdi</p><p>sp_init:</p></li></ol><p>movl movl leaq movq movq ret</p><p>12 c 儿r di ) , %eax</p><p>．儿e ax , 8(%rdi) 8(%rdi), %rax</p><p>%rax, (%rdi)</p><p>%rdi, 16(%rdi)</p><p>Get sp->s.y Save in sp->s.x</p><p>Compute &(sp->s .x) Store in sp->p</p><p>Store spin sp->next</p><p>由此可以 产生如下 C 代码：</p><p>void sp_init(struct prob•sp)</p><p>｛</p><p>sp->s.x sp->p</p><p>sp->next</p><p>= sp->s.y;</p><p>= &(sp->s.x);</p><p>= sp;</p><p>3. 42</p><p>这道题说明 了一个非常普 通的 数据结构和对它的 操作时 如何在机器代 码中实现。要解答 这些问 题， 还是先对汇编代码加 注释， 确认出该结构的两个字段分 别在偏移 量 0 ( 字段 v ) 和 8 ( 字段 p ) 处。</p><p>loDg f 皿 (s tr uct ELE •ptr )</p><p>ptr ill</p><p>1 fun:</p><p>rY. d1</p><p>movl $0, %eax</p><p>JIDP .12</p><p>4 .L3:</p><p>result = 0 Goto middle</p><p>loop:</p><p>5 addq</p><p>6 movq</p><p>7 .L2:</p><p>(o/.rdi) , o/.rax</p><p>8(o/.rdi), o/.rd1</p><p>result+= ptr->v ptr = ptr->p</p><p>middle:</p><p>testq&rsquo;Y.rdi,&lsquo;Y.rdi jne .L3</p><p>10 rep; ret</p><p>Test ptr</p><p>If ! = NULL, goto loop</p><ol><li><p>根据加了注释的 代码， 可以 得到 C 语言：</p><p>long fun(struct ELE *ptr) { long val= O;</p><p>while (ptr) {</p><p>val+= ptr->v; ptr = ptr->p;</p></li></ol><p>return val;</p><ol start=2><li><p>可以 看到每个结 构都是一个单链 表中的 元素， 字段 v 是元素的 值， 字段 p 是指向下 一个元 素的指针。函数 f u n 计算列表中元素值的 和。</p><p>3. 43 结构和联合涉及的概念很简单，但是需要练习来习惯不同的引用模式和它们的实现。</p></li></ol><table><thead><tr><th>表达式</th><th>类型</th><th>代码</th></tr></thead><tbody><tr><td>up->tl. u</td><td>long</td><td>movq ( % r d 习 ，%r a x movq 毛r a x, ( %r s 习</td></tr><tr><td>up->tl.v</td><td>short</td><td>movw 8 ( %r di ) , 毛a x mo vw 皂 a x, 伐 r s i )</td></tr><tr><td>&amp;up->tl. w</td><td>char*</td><td>addq $, %r d i movq % r d i , ( %r s i )</td></tr><tr><td>up->t2.a</td><td>int*</td><td>mo v q 乌r d i , %r s i</td></tr><tr><td>up- >t 2 . a [up- > tl.u)</td><td>int</td><td>mo v q ( %r d i ) , %r a x movl ( %r d i , %rax, 4), %e a x movl %e a x , (%r s 习</td></tr><tr><td>*up->t2.p</td><td>char</td><td>movq 8 ( %r d习 ，%r a x movb ( %r a x ) , %a l movb %a l , ( 沧r s 习</td></tr></tbody></table><ol><li>44 想理解各种数据结构需要多少存储，以及编译器为访问这些结构产生的代码，理解结构的布局和对齐是非常重 要的 。这个练习让你看清楚 一些示例结构的细节 。<ol><li>struct Pl {inti; char c; int j; chard;);</li></ol></li></ol><p>总共 对齐</p><p>1 6</p><ol><li>s tr u c 七 P2 {inti; char c; chard; long j; };</li></ol><h1 id=勹>勹
<a class=anchor href=#%e5%8b%b9>#</a></h1><ol><li>struct P3{ short w [3]; char c [3] } ;</li></ol><p>w C 总10共 对齐</p><p>6 2</p><ol><li>struct P4 { short w [5]; char *c[3] } ;</li></ol><p>w C 总4共0 对齐</p><p>。 16 8</p><ol><li>struct PS (struct P3a[2]; struct P2 t };</li></ol><p>a t 总40共 对齐</p><p>24 8</p><ol><li>45 这是一个理 解结构的布局 和对齐的 练习。<ol><li>这里是对象大小和字节偏移量：</li></ol></li></ol><p>字段大 小 偏移攸</p><ol><li>这个结构一共是 56 个字节长 。结构的结尾必须 填充 4 个字节来 满足 8 字节对 齐的 要求 。<ol><li><p>当所有的 数据元素的 长度都 是 2 的幕时 ， 一种行 之有效的策略 是按照 大小的降序排 列结构的元素。导致声明如下：</p><p>struct {</p><p>char •a;</p><p>double c;</p><p>long g;</p><p>float e;</p><p>int h;</p><p>short b，·</p><p>char d;</p><p>char f;</p><p>} rec;</p></li></ol></li></ol><table><thead><tr><th>得到的偏移扭如下：</th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>字段 a</td><td>C</td><td>g</td><td>e</td><td>h</td><td>b</td><td>d</td><td>f</td></tr><tr><td>大小 8</td><td>8</td><td>8</td><td>4</td><td>4</td><td>2</td><td></td><td></td></tr><tr><td>偏移量 I o</td><td>8</td><td>16</td><td>24</td><td>28</td><td>32</td><td>34</td><td>35</td></tr></tbody></table><p>这个结构要填充 4 个字节以满足 8 字节对齐的 要求 ， 所以总共是 40 个字节。</p><ol><li>46 这个问 题覆盖的话题比较广泛，例 如栈帧、字符 串表示 、ASCII 码和字节顺 序。 它说明了越界的内存引用的危险性，以及缓冲区溢出背后的基本思想。<ol><li>执行了第 3 行后的栈：</li></ol></li></ol><p>00 00 00 00 00 40 00 7 61 返回值</p><p>01 23 45 67 89 AB CD EF 保存的釭b x</p><p>&lt; — b u f = 毛 r s p</p><ol><li>执行了 第 5 行后的栈：</li></ol><table><thead><tr><th>00</th><th>00</th><th>00 00</th><th>00</th><th>40</th><th>00</th><th>3 41 返回值</th></tr></thead><tbody><tr><td>33</td><td>32</td><td>31 30</td><td>39</td><td>38</td><td>37</td><td>36 保存的%r b x</td></tr><tr><td>35</td><td>34</td><td>33 32</td><td>31</td><td>30</td><td>39</td><td>38</td></tr></tbody></table><p>37 36 35 34 33 32 31 30 I &ndash; buf = %rsp</p><ol><li><p>这个程序试图 返回 到地址 Ox 0 40034 。低 位 2 字节被字符＇矿和结尾的 空( null) 字符覆盖了。</p><ol><li><p>寄存器 %r b x 的保存 值被 设置为 Ox 333231 3039383 736 。在 ge t _ l i ne 返回前， 这个值会被 加载回这个寄存器中。</p></li><li><p>对 ma l l oc 的 调用应该以 s tr l e n (bu f ) + 1 作为它的 参数， 而且代码还应 该检查返回 值是否为</p><p>NULL 。</p><p>3. 47 A. 这对应于大约沪个地址的范围。</p><p>B. 每次尝试， 一个 1 28 字节的空 操作 s l e d 会覆盖 扩个地址 ， 因此我们只需 要 26 = 64 次尝试。这个 例子明确地 表明了这个版 本的 L inux 中的随机化程度只能 很小地阻 挡溢出攻击。</p></li></ol></li><li><p>48 这道题让 你看看 x86-64 代码如何管 理栈 ， 也让你更 好地理解如何防 卫缓 冲区 溢出攻 击。</p><ol><li>对于没有保护的代码 ， 第 4 行和第 5 行计算 v 和 b u f 的地址为相对千%r s p 偏移噩为 24 和 0。在有保护的代码中 ， 金丝雀被存放 在偏 移雇为 40 的地方（第4 行）， 而 v 和 bu f 在偏移 量为 8 和 16 的地方（第7 行和第 8 行）。</li><li>在有保 护的代码中 ， 局部变量 v 比 bu f 更靠 近栈 顶 ， 因此 b u f 溢出就不会 破坏 v 的值。</li></ol></li><li><p>49 这段代码中包含许 多我们已 经见到过的 执行位级 运算的 技巧。要仔细研究 才能 看得懂 。</p><ol><li><p>第 5 行的 l e a q 指令计算值 8 n + 22 , 然后 第 6 行的 a ndq 指令 把它向下舍入 到最接近的 16 的倍数。当 n 是奇数时，结 果值会是 8 n + 8 , 当 n 是偶数时 ，结 果值会是 8 n + l 6 , 这个 值减去 s, 就得到 s, O</p></li><li><p>该 序列中的三条指令 将 S2 舍入 到最 近的 8 的倍数。它们利用了 2. 3. 7 节中实现除以 2 的幕用到的偏移 和移 位的组 合。</p></li><li><p>这两个 例子可以 看做最小 化和最大化 e1 和 e, 的情况。</p><p>n s, s, p e, e, 5 2065 2017 2024 I 7</p><p>6 2064 2000 2000 16</p></li></ol></li><li><p>可以 看到 s, 的计算方式 会保 留 S1 的偏移 量为 最接近的 1 6 的倍数。还可以 看到 p 会以 8 的倍数对齐， 正是对 8 字节元 素数组建 议使用的 。 ｀</p><p>3 50 这道题要求你仔细检查代码，小心留意使用的转换和数据传送指令。可以看到取出的值和转换的 情况如下 ：</p></li></ol><ul><li><p>取出位 千 dp 的值， 转换成 i nt ( 第 4 行）， 再存储到 i p 。因 此可以 推断出 va 荨 是 d。</p></li><li><p>取出位 千 i p 的值， 转换 成 fl oa t ( 第 6 行）， 再存储到 f p。因此可以 推断出 va l 2 是 l 。</p></li><li><p>1 的值被转换 成 doub l e ( 第 8 行）， 并存储在 dp 。因此 可以 推断出 va l 3 是 1 。</p></li><li><p>第 3 行上取出位 千 f p 的值。第 10 和 11 行的两条指 令把它转换为双精度， 值通过寄存 器%xmm0</p><p>返回。因此可以 推断 出 va l 4 是 f 。</p><p>3. 51 可以通过从图 3-47 和图 3- 48 中选择适当的条目或者使用在浮点 格式间转换的代码序列 来处 理这些情况。</p></li></ul><table><thead><tr><th></th><th>T,</th><th>Ty</th><th>指令</th><th></th></tr></thead><tbody><tr><td></td><td>long double double</td><td>double int float</td><td>vcvtsi2sdq %r d i , %x mm0 , %x mm0 vcvttsd2si %x mm0 , %e a x vunpcklpd %x mm0 , %x mm0 , %x mm0</td><td></td></tr><tr><td></td><td></td><td></td><td>vcvtpd2ps %xmm0, 毛 x mmO</td><td></td></tr><tr><td></td><td>long float</td><td>float long</td><td>vctsi2ssq % r d i , %x mm0 , %x mm0 vcvt t s 2s i q % x mm0 , %r a x</td><td></td></tr></tbody></table><ol><li>映射参数到寄存器的基本规则非常简单（虽然随着有更多类型的参数出现，这些规则也变得越来越 复杂[ 77] ) 。<ol><li><p>double gl (double a, long b, float c, int d);</p><p>寄存器： a 在%x mm0 中， b 在%r d i 中， e 在%x mml 中 ， d 在 % e s i 中</p><ol><li><p>double g2(int a, double *b, float *c, long d) ;</p><p>寄存器： a 在 ¾ e小 中， b 在% rsi 中， c 在 % rd x 中， d 在 % rcx 中</p></li><li><p>double g3(double *a, double b, int c, float d);</p><p>寄存器： a 在%r 中 中 ， b 在%x mm0 中， e 在% e s i 中 ， d 在%x mml 中</p></li><li><p>double g4(float a, int *b, float c, double d);</p><p>寄存器： a 在%x mm0 中 ， b 在%r d i 中， e 在%x mml 中 ， d 在%x mm2 中</p></li></ol></li><li><p>从这段 汇编代码 可以 看出有 两个整数 参数， 通过寄存器%r 生 和%r s i 传递， 将其命名为 过 和 辽。类似地 ， 有两个浮点 参数， 通过 寄存器%x mm0 和%x mml 传递， 将其命 名为 fl 和 f 2。</p><p>然后给汇编代码加注释：</p><p>Refer to arguments as 工 1 (r¼ di ) , 立 (¼esi )</p><p>t 1 (¼xmmO) , and t2 (¼xmm1)</p></li></ol></li></ol><p>double tunct1(arg1_t p, arg2_t q, arg3_t r, arg生t s) functl:</p><p>vcvtsi2ssq %rsi, %xmm2, %xmm2 vaddss %xmm0, %xmm2, %xmm0 vcvtsi2ss %edi, %xmm2, %xmm2 vdivss %xmm0, %xmm2, %xmm0 vunpcklps %xmm0, %xmm0, %xmm0</p><p>vcvtps2pd %xmm0, %xmm0 vsubsd %xmm1, %xmm0, %xmm0 ret</p><p>Get i2 and convert from long to float Add ft (type float)</p><p>Get it and convert from int to float Comp ut e 辽 I (i2 + tt)</p><p>Convert to double</p><p>Compute i1 I (i2 + fl) - f2 (double)</p><p>3. 54</p><p>由此可以 看出这段代码计算 值 i l / (i2+fl) - f2。还 可以 看到， i l 的类型 为 i nt , i 2 的类 型 为long, f l 的类型为 f l oa t , 而 f 2 的类型为 do ub l e 。将参数 匹配到命名的 值只有一个不确定的地方，来自于加法的交换性 得到两种可能的结果：</p><p>·double functla(int p, float q, long r, double s); double functlb(int p, long q, float r, doubles);</p><p>一步步梳理 汇编 代码 ， 确定 每一 步计算什么， 就很容易 找到这 道题的答 案， 如下 面的 注释所示 ：</p><p>double funct2(double w, int x, float y, long z) w in i.xmmO, x in i.edi, y in i.xmm1 , z i n 肚 si funct2:</p><p>vcvtsi2ss %edi, %xmm2, %xmm2 vmulss %xmm1, %xmm2, %xmm1 vunpcklps %xmm1, %xmm1, %xmm1</p><p>vcvtps2pd %xmm1, %xmm2 vcvtsi2sdq %rsi, %xmm1, %xmm1 vdivsd %xmm1, %xmm0, %xmm0</p><p>vsubsd %xmm0, %xmm2, %xmm0 ret</p><p>Convert x to float Multiply by y</p><p>Convert x•y to double Convert z to double Compute w/z</p><p>Subtract from x•y Return</p><p>3. 55</p><p>3. 56</p><p>可以从 分析得出结论，该 函数计算 y*x- w/ z 。</p><p>这道题使用的 推理 与推断 标号 . LC2 处声明的数字是 1. 8 的编码一 样， 不过例子更简单 。</p><p>我们 看到 两个值分别 是 0 和 1077 936128 ( Ox 40400000 ) 。从高 位字 节 可 以抽取出 指 数字段</p><p>Ox404Cl028), 减去偏移 量 1023 得到指数为 5 。连 接两个 值的小数位， 得到小数字段为 o, 加上隐含的 开头的 1, 得到 1. 0 。因此这个常数是 1. OX25 =32. 0。</p><ol><li>在此可以 看到从 地址 . LCl 开始的 1 6 个字节是一个掩码 ， 它的低 8 个字节是全 1 , 除了最高位， 这是 双精度值的 符号位。计算 这个掩码和%x mm0 的 A ND 值时 ， 会清除 x 的符号位， 得到绝对</li></ol><p>值。实际上， 定义 EXPR (x ) 为 f a b s (x ) 就 能得到这段 代码， f a b s 是在&lt; ma t h . h > 中定义的。</p><ol start=2><li><p>可以 看到 v x or p d 指令将 整个寄存器设 置为 0 , 所以这是 一种产生浮点 常数 o. 0 的方法。</p></li><li><p>可以 看到从 地址 . LC2 开始的 16 个字节是 一个掩码， 它只有一个 1 位， 位于 XMM 寄存器中低位数值 的符号位。计算这个 掩码与% x mrn0 的 EXCLUSIVE - OR 值时， 会改变 x 符号的值， 计算出 表达式 - x。</p><p>3 57 同样地，为代码加注释，包括处理条件分支：</p><p>double funct3(int *ap, double b, long c, float *dp) ap in¼rdi, b in¼xmmO, c in¼rsi, dpin¼rdx</p></li><li><p>funct3:</p></li><li><p>vmovss (o/.rdx) , o/.xmml Get d = *dp</p><p>vcvtsi2sd (o/.rdi), o/.xmm2, o/.xmm2 Get a = *ap and convert to double</p><p>4 vucom1sd o/.xmm2, o/.xmmO Compare b:a</p></li><li><p>jbe . LS</p></li><li><p>vcvtsi2ssq %rsi, %xmm0, %xmm0</p></li><li><p>vmulss %xmm1, %xmm0, %xmm1</p></li><li><p>vunpcklps %xmm1, %xmm1, %xmm1</p><p>If&lt;=, goto lesseq Conver t c to float 加 l tiply by d</p></li></ol><p>9 vcvtps2pd %xmm1, %xmm0</p><p>10 ret</p><p>11 .LB:</p><p>Convre Return</p><p>l esseq ·</p><p>t to double</p><p>72 vaddss %xmm1, %xmm1, %xmm1</p><ol><li><p>vcvtsi2ssq %rsi, %xrom0, %xmm0</p></li><li><p>vaddss %xmm1, %xmm0, %xmm0</p></li><li><p>vunpcklps ¾xmmO, ¾xmmO, ¾xmmO</p></li><li><p>vcvtps2pd %xmm0 , %xmm0</p></li><li><p>ret</p><p>Compute d+d = 2 . 0 * d Convert c to float Compute c + 2•d</p></li></ol><p>Conver t to double Return</p><p>由此， 可以 写出 f u n c t 3 的代码如下 ：</p><p>double fu 卫 ct 3(i nt • ap, double b, long c, float•dp) { int a; •ap;</p><p>float d; •dp; if (a &lt; b)</p><p>return c•d;</p><p>else</p><p>｝</p><p>return c+2•d;</p><p>第 4 章</p><p>CH APTER 4</p><h5 id=处理器体系结构>处理器体系结构
<a class=anchor href=#%e5%a4%84%e7%90%86%e5%99%a8%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84>#</a></h5><p>现代微处理器可以称得上是人类创造出的最复杂的系统之一。一块手指甲大小的硅片 上，可以容纳一个完整的高性能处理器、大的高速缓存，以及用来连接到外部设备的逻辑电路。从性能上来说 ， 今天在一 块芯片上实现的处理器巳经使 20 年前价值 1000 万美元、房间那么大的超级计算机相形见细了。即使是在像手机、导航系统和可编程恒温器这样的日常设备中的嵌入式处理器，也比早期计算机开发者所能想到的强大得多。</p><p>到目前为止，我们看到的计算机系统只限于机器语言程序级。我们知道处理器必须执 行一系列指令，每条指令执行某个简单操作，例如两个数相加。指令被编码为由一个或多 个字节序列组成的二进制格式。一个处理器支持的指令和指令的字节级编码称为它的指令 集体系 结构 (I nst ruct ion-Set Architecture, ISA) 。不同的处 理器“家族” ， 例如 In tel IA32 和 x86-64 、IBM/ Freescale Power 和 ARM 处理器家族， 都有不同的 ISA 。一 个程序编译成在一种机器上运行，就不能在另一种机器上运行。另外，同一个家族里也有很多不同型 号的处理 器。虽然每个 厂商制造的处 理器性能 和复杂性不断提高 ， 但是不同的型号在 ISA 级别上都 保持着兼容 。一些常见的处理器家族（例如x86-64) 中的处理器分别由多个厂商提供。因此， ISA 在编译器编写者 和处理器设计人员之间提供了一个概念抽象 层， 编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出执行 这些指令的处理器。</p><p>本章将简要介绍处 理器硬件的设 计。我们将研究一个硬件系统执行某种 ISA 指令的 方式。这会使你能更好地理解计算机是如何工作的，以及计算机制造商们面临的技术挑战。一个很重要 的概念是 ， 现代处 理器的实际工作方式可能 跟 ISA 隐含的计算模型大相径庭。</p><p>ISA 模型看上去应该是 顺序指 令执行 ， 也就是先取出一条指令， 等到它执行完毕 ， 再开始下一条。然而，与一个时刻只执行一条指令相比，通过同时处理多条指令的不同部分，处 理器可以获得更高的性能。为了保证处理器能得到同顺序执行相同的结果，人们采用了一 些特殊的机制。在计算机科学中，用巧妙的方法在提高性能的同时又保持一个更简单、更 抽象模型的 功能， 这种思想是众所周知的。在 Web 浏览器或平衡二叉树和哈希表这样的信息检索数据结构中使用缓存，就是这样的例子。</p><p>你很可能永 远都不会 自己设 计处理器。这是专家们的任务， 他们工作在全球不到 100</p><p>家的公司里。那么为什么你还应该了解处理器设计呢？</p><ul><li>从智力方面来说，处理器设计是非常有趣而且很重要的。学习事物是怎样工作的有其内在价值。了解作为计算机科学家和工程师日常生活一部分的一个系统的内部工作原理（特别是对很多人来说这还是个谜），是件格外有趣的事情。处理器设计包括许多好的工程实践原理。它需要完成复杂的任务，而结构又要尽可能简单和规则。</li><li>理解处理 器如何工作 能帮助 理解整 个计 算机 系统如何 工作。在第 6 章 ， 我们将讲述存储器系统，以及用来创建很大的内存映像同时又有快速访问时间的技术。看看处 理器端的处理器 内存接口，会使那些讲述更加完整。</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><ul><li></li><li><a href=#尸>尸</a></li></ul></li><li><a href=#三三三三>三三三三</a><ul><li></li></ul></li></ul></li><li><a href=#勹>勹</a><ul><li><ul><li></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>