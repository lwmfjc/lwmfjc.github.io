<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="aqs详解"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0308lyaqs-details/"><meta property="og:site_name" content="随记"><meta property="og:title" content="aqs详解"><meta property="og:description" content="aqs详解"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2022-11-30T14:48:01+00:00"><meta property="article:modified_time" content="2022-11-30T14:48:01+00:00"><meta property="article:tag" content="复习"><meta property="article:tag" content="复习-JavaGuide"><meta property="article:tag" content="复习-JavaGuide-并发"><title>aqs详解 | 随记</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0308lyaqs-details/><link rel=stylesheet href=/book.min.139f5e11df71f5bba2b1247bd4b1313c3248d3a29ad3aabb5259e40af9e483a5.css integrity="sha256-E59eEd9x9buisSR71LExPDJI06Ka06q7UlnkCvnkg6U=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.c917c498d627067a21e447536919120085d1051836f750e4c0cde9a0c9ef4390.js integrity="sha256-yRfEmNYnBnoh5EdTaRkSAIXRBRg291DkwM3poMnvQ5A=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>随记</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><a href=/zh/docs/technology/>技术</a><ul><li><input type=checkbox id=section-1dd4601389ea65ef400f95373226aee0 class=toggle>
<label for=section-1dd4601389ea65ef400f95373226aee0 class="flex justify-between"><a role=button>Linux</a></label><ul><li><input type=checkbox id=section-f8d8a779959a764d65613f11020c9a13 class=toggle>
<label for=section-f8d8a779959a764d65613f11020c9a13 class="flex justify-between"><a role=button>Terminal Commands</a></label><ul><li><a href=/zh/docs/technology/Linux/Terminal-Commands/0000-0029/>0000-0029</a></li></ul></li><li><input type=checkbox id=section-eb3a110e9a221e46d625b63087e91152 class=toggle>
<label for=section-eb3a110e9a221e46d625b63087e91152 class="flex justify-between"><a role=button>SHELL编程(learnLinuxTV)</a></label><ul><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/16-18/>16-18</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/12-15/>12-15</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/11DataStreams/>11DataStreams</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/07-10/>07-10</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/06ExitCode/>06ExitCode</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/05If/>05If</a></li><li><a href=/zh/docs/technology/Linux/SHELLlearnLinuxTV_/01-04/>01-04</a></li></ul></li><li><input type=checkbox id=section-bfc45dc929fcc1310a60f77e491b60d2 class=toggle>
<label for=section-bfc45dc929fcc1310a60f77e491b60d2 class="flex justify-between"><a role=button>韩顺平老师_</a></label><ul><li><a href=/zh/docs/technology/Linux/hanshunping/52-x/>52-X</a></li><li><a href=/zh/docs/technology/Linux/hanshunping/40-51/>linux_韩老师_40-51</a></li><li><a href=/zh/docs/technology/Linux/hanshunping/28-39/>linux_韩老师_28-39</a></li><li><a href=/zh/docs/technology/Linux/hanshunping/21-27/>linux_韩老师_21-33</a></li><li><a href=/zh/docs/technology/Linux/hanshunping/12-20/>linux_韩老师_12-20</a></li><li><a href=/zh/docs/technology/Linux/hanshunping/07-11/>linux_韩老师_07-11</a></li><li><a href=/zh/docs/technology/Linux/hanshunping/01-06/>linux_韩老师_01-06</a></li></ul></li><li><a href=/zh/docs/technology/Linux/basic/>基本操作</a></li><li><a href=/zh/docs/technology/Linux/create_clone/>vmware上linux主机的安装和克隆</a></li></ul></li><li><input type=checkbox id=section-9f56b27db6873dfaab68a13a9088b050 class=toggle>
<label for=section-9f56b27db6873dfaab68a13a9088b050 class="flex justify-between"><a role=button>Reg Exp</a></label><ul><li><input type=checkbox id=section-6da126b4a17fb67539c8fc56ed6827d9 class=toggle>
<label for=section-6da126b4a17fb67539c8fc56ed6827d9 class="flex justify-between"><a role=button>基础(CoreySchafer)</a></label><ul><li><a href=/zh/docs/technology/RegExp/baseCoreySchafer/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class=toggle>
<label for=section-f04eb05ff8f0dfbe9287eeb97b54a2b3 class="flex justify-between"><a role=button>Hugo</a></label><ul><li><input type=checkbox id=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class=toggle>
<label for=section-c4f3bbcb281997edd8d8b0c9fd9cdb76 class="flex justify-between"><a role=button>主题</a></label><ul><li><a href=/zh/docs/technology/Hugo/themes/PaperMod/01/>使用PaperMode</a></li></ul></li><li><input type=checkbox id=section-c73b582566a4e49b5b07f613bac566cf class=toggle>
<label for=section-c73b582566a4e49b5b07f613bac566cf class="flex justify-between"><a role=button>基础(Giraffe学院)_</a></label><ul><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy/advanced20-23/>hugo进阶学习20-23</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy/advanced17-19/>hugo进阶学习17-19</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy/advanced11-16/>hugo进阶学习11-15</a></li><li><a href=/zh/docs/technology/Hugo/GiraffeAcademy/advanced01-10/>hugo进阶学习01-10</a></li></ul></li></ul></li><li><input type=checkbox id=section-43be5f3c9fb2465efc746ae00240e4b3 class=toggle>
<label for=section-43be5f3c9fb2465efc746ae00240e4b3 class="flex justify-between"><a role=button>Obsidian</a></label><ul><li><a href=/zh/docs/technology/Obsidian/border-theme/>border-theme背景图片问题</a></li><li><a href=/zh/docs/technology/Obsidian/obsidian-theme/>obsidian-theme</a></li><li><a href=/zh/docs/technology/Obsidian/plugin/>plugin</a></li></ul></li><li><input type=checkbox id=section-7123c56777444b2f7157631dd88ad8f6 class=toggle>
<label for=section-7123c56777444b2f7157631dd88ad8f6 class="flex justify-between"><a role=button>Redis</a></label><ul><li><input type=checkbox id=section-653c4bfd6de0200aef700672dc46b623 class=toggle>
<label for=section-653c4bfd6de0200aef700672dc46b623 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/19-A/>redis_尚硅谷_19-A</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/18/>redis_尚硅谷_18</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/12-17/>redis_尚硅谷_12-17</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/06-11/>redis_尚硅谷_06-11</a></li><li><a href=/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/01-05/>redis_尚硅谷_01-05</a></li></ul></li><li><a href=/zh/docs/technology/Redis/rsync-use/>rsync使用</a></li><li><a href=/zh/docs/technology/Redis/redis-cluster/>redis集群搭建</a></li></ul></li><li><input type=checkbox id=section-a94b8d7740a71c28fc6e0f89885b2468 class=toggle>
<label for=section-a94b8d7740a71c28fc6e0f89885b2468 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><input type=checkbox id=section-dacf512d642735207e9a681d5fb91053 class=toggle>
<label for=section-dacf512d642735207e9a681d5fb91053 class="flex justify-between"><a role=button>_深入理解Java虚拟机_</a></label><ul><li><a href=/zh/docs/technology/JVM/understanding_the_jvm/03/>03垃圾收集器与内存分配策略</a></li></ul></li></ul></li><li><input type=checkbox id=section-d2e5dc71fe2274ddaa089e125f33ae58 class=toggle>
<label for=section-d2e5dc71fe2274ddaa089e125f33ae58 class="flex justify-between"><a role=button>My SQL</a></label><ul><li><input type=checkbox id=section-55f24404ff04ecc51ca2539f0513db8f class=toggle>
<label for=section-55f24404ff04ecc51ca2539f0513db8f class="flex justify-between"><a role=button>_MySQL是怎样运行的_</a></label><ul><li><a href=/zh/docs/technology/MySQL/how_mysql_run/07/>07B+数索引的使用</a></li><li><a href=/zh/docs/technology/MySQL/how_mysql_run/06/>06B+树索引</a></li><li><a href=/zh/docs/technology/MySQL/how_mysql_run/05/>05InnoDB数据页结构</a></li><li><a href=/zh/docs/technology/MySQL/how_mysql_run/04/>04InnoDB记录存储结构</a></li><li><a href=/zh/docs/technology/MySQL/how_mysql_run/03/>03字符集和比较规则</a></li><li><a href=/zh/docs/technology/MySQL/how_mysql_run/02/>02启动选项和系统变量</a></li><li><a href=/zh/docs/technology/MySQL/how_mysql_run/01/>01初识MySQL</a></li></ul></li><li><input type=checkbox id=section-71c340add51164b94f4c1b5254385b46 class=toggle>
<label for=section-71c340add51164b94f4c1b5254385b46 class="flex justify-between"><a role=button>进阶(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MySQL/bl_sgg/96-00/>mysql高阶_sgg 96-00</a></li></ul></li></ul></li><li><input type=checkbox id=section-e8f515fe7fc71d283363385aa363c2dd class=toggle>
<label for=section-e8f515fe7fc71d283363385aa363c2dd class="flex justify-between"><a role=button>其他</a></label><ul><li><a href=/zh/docs/technology/Other/kaoshi/>科目</a></li><li><a href=/zh/docs/technology/Other/pc_base/>电脑基础操作</a></li></ul></li><li><input type=checkbox id=section-f54112ca99b135fbc484938888b1f1a2 class=toggle checked>
<label for=section-f54112ca99b135fbc484938888b1f1a2 class="flex justify-between"><a href=/zh/docs/technology/Review/>面试</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/>JavaGuide</a><ul><li><input type=checkbox id=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class=toggle>
<label for=section-aa443fde93c5c7ab0082fb8bc7a93cb7 class="flex justify-between"><a role=button>数据库</a></label><ul><li><input type=checkbox id=section-e7660273cef85dff1f39af04a42bd062 class=toggle>
<label for=section-e7660273cef85dff1f39af04a42bd062 class="flex justify-between"><a role=button>MySQL</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0606lymysql-query-execution-plan/>mysql执行计划</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0611lymysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0610lymysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0609lyindex-invalidation-caused-by-implicit-conversion/>MySQL中的隐式转换造成的索引失效</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0608lysome-thoughts-on-database-storage-time/>MySQL数据库时间类型数据存储建议</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0605lyhow-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0604lyinnodb-implementation-of-mvcc/>innodb引擎对MVCC的实现</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0603lytransaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0602lymysql-logs/>日志</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/MySQL/ly0601lymysql-index/>索引</a></li></ul></li><li><input type=checkbox id=section-680d077436e58b0cad0a63ed8edb5f53 class=toggle>
<label for=section-680d077436e58b0cad0a63ed8edb5f53 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/diagram/>redis问题图解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0703ly3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0704lyredis-memory-fragmentation/>redis内存碎片</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0702lyredis-spec-data-structure/>redis特殊数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0701lyredis-base-data-structures/>redis基本数据结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0706lyredis-questions-02/>redis面试题02</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/Redis/ly0705lyredis-questions-01/>redis面试题01</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0503lysql-question-01/>sql常见面试题总结01</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0504lysql-syntax-summary/>sql语法基础知识总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0502lycharactor-set/>字符集详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/database/ly0501lybasis/>数据库基础</a></li></ul></li><li><input type=checkbox id=section-a1b717b4079938cc0efe574541b240b8 class=toggle>
<label for=section-a1b717b4079938cc0efe574541b240b8 class="flex justify-between"><a role=button>系统设计</a></label><ul><li><input type=checkbox id=section-9eaf95f03abf595bfdf838c4b4cdb2ef class=toggle>
<label for=section-9eaf95f03abf595bfdf838c4b4cdb2ef class="flex justify-between"><a role=button>安全</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly06ly_sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly05ly_design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly04ly_sso-intro/>sso单点登录</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly03ly_jwt-advantages-disadvantages/>jwt身份认证优缺点</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly02ly_jwt-intro/>jwt-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly01ly_basis-of-authority-certification/>认证授权基础概念详解</a></li></ul></li><li><input type=checkbox id=section-79417049c90714c6ddbf18a3c3958148 class=toggle>
<label for=section-79417049c90714c6ddbf18a3c3958148 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/unit-test/>单元测试</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/software-engineering/>软件工程简明教程</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/basis/restful/>restFul</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/web-real-time-message-push/>web-real-time-message-push</a></li><li><a href=/zh/docs/technology/Review/java_guide/lycly_system-design/schedule-task/>Java定时任务详解</a></li></ul></li><li><input type=checkbox id=section-0a9533f3005d615c696f74456e46d269 class=toggle>
<label for=section-0a9533f3005d615c696f74456e46d269 class="flex justify-between"><a role=button>高可用</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly05ly_performance-test/>性能测试入门</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly04ly_timout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly03ly_limit-request/>服务限流详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly02ly_redundancy/>冗余设计</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly01ly_high-availability-system-design/>高可用系统设计指南</a></li></ul></li><li><input type=checkbox id=section-e36f94f48e5027e7cbd39b7f7bbc249c class=toggle>
<label for=section-e36f94f48e5027e7cbd39b7f7bbc249c class="flex justify-between"><a role=button>高性能</a></label><ul><li><input type=checkbox id=section-581624dd7aa25a150f706312689ba446 class=toggle>
<label for=section-581624dd7aa25a150f706312689ba446 class="flex justify-between"><a role=button>RocketMQ</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-questions/>rocketmq常见面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-intro/>rocketmq介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/base/>message-queue</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly02ly_cdn/>cdn</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyely_high-performance/ly01ly_read-and-write-separation-and-library-subtable/>数据库读写分离&分库分表详解</a></li></ul></li><li><input type=checkbox id=section-a6916634f1b5324076467df4cc9ac3b5 class=toggle>
<label for=section-a6916634f1b5324076467df4cc9ac3b5 class="flex justify-between"><a role=button>分布式系统</a></label><ul><li><input type=checkbox id=section-0c8e62b6137b614e01882e2a88ea5daf class=toggle>
<label for=section-0c8e62b6137b614e01882e2a88ea5daf class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/raft-algorithm/>raft算法</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/paxos-algorithm/>paxos算法</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/cap_base-theorem/>CAP&amp;BASE 理论</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly08ly_zookeeper-in-action/>zookeeper实战</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly07ly_zookeeper-plus/>zookeeper进阶</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly06ly_zookeeper-intro/>zookeeper介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly04ly_rpc-http/>rpc_http</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly05ly_rpc-intro/>rpc基础及面试题</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly03ly_distributed-lock/>分布式锁</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly02ly_distributed-id/>分布式id</a></li><li><a href=/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly01ly_api-gateway/>api网关</a></li></ul></li><li><input type=checkbox id=section-ce3cbb53c62f67624e4ab24a5a14298a class=toggle>
<label for=section-ce3cbb53c62f67624e4ab24a5a14298a class="flex justify-between"><a role=button>框架</a></label><ul><li><input type=checkbox id=section-dbe480810d1877286936b38cdb5e9229 class=toggle>
<label for=section-dbe480810d1877286936b38cdb5e9229 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><input type=checkbox id=section-30b916f2071579e2468767a2562433d9 class=toggle>
<label for=section-30b916f2071579e2468767a2562433d9 class="flex justify-between"><a role=button>原理</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle3/>Mybatis原理系列(3)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle2/>Mybatis原理系列(2)</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle1/>Mybatis原理系列(1)</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/MyBatis-interview/>Mybatis面试</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/conditional_on_class/>ConditionalOnClass实践</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly05ly_springboot-auto-assembly/>SpringBoot自动装配原理</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly04ly_spring-design-patterns/>spring 设计模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly03ly_spring-transaction/>Spring事务详情</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly02ly_spring-annotations/>Spring/SpringBoot常用注解</a></li><li><a href=/zh/docs/technology/Review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/>spring 常见面试题总结</a></li></ul></li><li><input type=checkbox id=section-1f6733a85e33dcc22aabbf820e3ef963 class=toggle>
<label for=section-1f6733a85e33dcc22aabbf820e3ef963 class="flex justify-between"><a role=button>开发工具</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/git/>git</a></li><li><a href=/zh/docs/technology/Review/java_guide/lyaly_dev_tools/maven/>maven</a></li></ul></li><li><input type=checkbox id=section-c01151f806b917cd0ecc4cffa72c3402 class=toggle checked>
<label for=section-c01151f806b917cd0ecc4cffa72c3402 class="flex justify-between"><a role=button>Java基础</a></label><ul><li><input type=checkbox id=section-26625a0c4c0bffef02640966ca545537 class=toggle checked>
<label for=section-26625a0c4c0bffef02640966ca545537 class="flex justify-between"><a role=button>并发</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly030301lyatomicpre/>Atomic预备知识</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0311lycompletablefuture-intro/>completablefuture-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0310lythreadlocal/>ThreadLocal详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0309lyatomic-classes/>Atomic原子类介绍</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0308lyaqs-details/ class=active>aqs详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0307lyconcurrent-collections/>java常见并发容器</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0306lythread-pool-best/>线程池最佳实践</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0305lyjava-thread-pool/>java线程池详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0304lyjmm/>java内存模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0303lyconcurrent-03/>并发03</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03122lylock_escalation/>锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated2/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly03121lyobject-concurrent/>对象内存布局和对象头</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0302lyconcurrent-02/>并发02</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Concurrent/ly0301lyconcurrent-01/>并发01</a></li></ul></li><li><input type=checkbox id=section-8f747d8f024fbfe2b392a25696e01266 class=toggle>
<label for=section-8f747d8f024fbfe2b392a25696e01266 class="flex justify-between"><a role=button>IO</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0203lyio-model/>io模型</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0202lyio-design-patterns/>io设计模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/IO/ly0201lyio/>io基础</a></li></ul></li><li><input type=checkbox id=section-7d26c3d37b0e4678a1ec776265992903 class=toggle>
<label for=section-7d26c3d37b0e4678a1ec776265992903 class="flex justify-between"><a role=button>集合</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0105lysource-code-concurrenthashmap/>ConcurrentHashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0106lysource-code-hashmap/>HashMap源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0104lysource-code-ArrayList/>ArrayList源码</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0103lycollections-precautions-for-use/>集合使用注意事项</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0102lycollection_2/>集合_2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Collection/ly0101lycollection_1/>集合_1</a></li></ul></li><li><input type=checkbox id=section-7027a9bc1d603892e7826da81b333f38 class=toggle>
<label for=section-7027a9bc1d603892e7826da81b333f38 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0011lysyntactic_sugar/>语法糖</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0010lyjava_spi/>java_spi</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0009lyunsafe_class/>unsafe类</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0008lybig_decimal/>big_decimal</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0007lyproxy_pattern/>Java代理模式</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0006lyreflex/>java-reflex</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0005lyserialize/>Java序列化详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0004lypassbyvalue/>为什么Java中只有值传递</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0003lyjava_guide_basic_3/>javaGuide基础3</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0002lyjava_guide_basic_2/>javaGuide基础2</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/Basic/ly0001lyjava_guide_basic_1/>javaGuide基础1</a></li></ul></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0408lyjdk-monitoring-and-troubleshooting-tools/>jvm监控和故障处理工具 总结</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0406lyjvm-params/>jvm参数</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0403lyclass-structure/>类文件结构</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0405lyclassloader-detail/>类加载器详解</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0404lyclassloader-process/>类加载过程</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0402lygarbage-collection/>java垃圾回收</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0407lyjvm-intro/>jvm-intro</a></li><li><a href=/zh/docs/technology/Review/java_guide/java/JVM/ly0401lymemory-area/>memory-area</a></li></ul></li><li><input type=checkbox id=section-04d967d6579d47b35ececb3d233024f1 class=toggle>
<label for=section-04d967d6579d47b35ececb3d233024f1 class="flex justify-between"><a role=button>计算机基础</a></label><ul><li><input type=checkbox id=section-316b43351a75a19ac6dec86ad1a48c45 class=toggle>
<label for=section-316b43351a75a19ac6dec86ad1a48c45 class="flex justify-between"><a role=button>数据结构</a></label><ul><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/heap/>堆</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/technology/Review/java_guide/cs_basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li></ul></li></ul></li><li><input type=checkbox id=section-09d19e9c6f50e4706fe8b6d358c441ce class=toggle>
<label for=section-09d19e9c6f50e4706fe8b6d358c441ce class="flex justify-between"><a role=button>Ssm</a></label><ul><li><a href=/zh/docs/technology/Review/ssm/scope_transaction/>作用域及事务</a></li></ul></li><li><input type=checkbox id=section-11f3d4afcbd3591ad3ee5d79993e29d7 class=toggle>
<label for=section-11f3d4afcbd3591ad3ee5d79993e29d7 class="flex justify-between"><a role=button>Java基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/Review/basics/member_variables_and_local_variables/>成员变量与局部变量</a></li><li><a href=/zh/docs/technology/Review/basics/recursion_and_iteration/>递归与迭代</a></li><li><a href=/zh/docs/technology/Review/basics/method_parameter_passing_mechanism/>方法的参数传递机制</a></li><li><a href=/zh/docs/technology/Review/basics/class_and_instance_initialization/>类、实例初始化</a></li><li><a href=/zh/docs/technology/Review/basics/singleton_design_pattern/>单例设计模式</a></li><li><a href=/zh/docs/technology/Review/basics/self_incrementing_variable/>自增变量</a></li></ul></li></ul></li><li><input type=checkbox id=section-2fa8d2f95840b0143e19fcee5ee1ad97 class=toggle>
<label for=section-2fa8d2f95840b0143e19fcee5ee1ad97 class="flex justify-between"><a role=button>SpringCloud</a></label><ul><li><input type=checkbox id=section-c8a8a7f47884d9b6be47c71f7ac9c83e class=toggle>
<label for=section-c8a8a7f47884d9b6be47c71f7ac9c83e class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/springCloud/bl_zhouyang/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-5057ba12f456498454476dc11b58648b class=toggle>
<label for=section-5057ba12f456498454476dc11b58648b class="flex justify-between"><a role=button>Git</a></label><ul><li><input type=checkbox id=section-950cdebc38a9ca098189c3fa0102c810 class=toggle>
<label for=section-950cdebc38a9ca098189c3fa0102c810 class="flex justify-between"><a role=button>基础(尚硅谷视频)_</a></label><ul><li><a href=/zh/docs/technology/Git/git_sgg/19-26/>19-26_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg/09-18/>09-18_git_尚硅谷</a></li><li><a href=/zh/docs/technology/Git/git_sgg/01-08/>01-08_git_尚硅谷</a></li></ul></li></ul></li><li><input type=checkbox id=section-d8f59257917ebff8da82fd22583ae10c class=toggle>
<label for=section-d8f59257917ebff8da82fd22583ae10c class="flex justify-between"><a role=button>Maven</a></label><ul><li><input type=checkbox id=section-3557a7ceacd3cc2944407bceae9cdb4d class=toggle>
<label for=section-3557a7ceacd3cc2944407bceae9cdb4d class="flex justify-between"><a role=button>进阶(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/advance_dljd/01-21/>01-21 maven多模块管理_动力节点</a></li></ul></li><li><input type=checkbox id=section-1ebe9fbd5f37ad16b6c30982516d03c1 class=toggle>
<label for=section-1ebe9fbd5f37ad16b6c30982516d03c1 class="flex justify-between"><a role=button>基础(动力节点)_</a></label><ul><li><a href=/zh/docs/technology/Maven/base_dljd/31-43/>31-43 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd/17-30/>17-30 maven基础_动力节点</a></li><li><a href=/zh/docs/technology/Maven/base_dljd/01-16/>01-16 maven基础_动力节点</a></li></ul></li></ul></li><li><input type=checkbox id=section-d2ff9acb1ec90bec89f165361ced2010 class=toggle>
<label for=section-d2ff9acb1ec90bec89f165361ced2010 class="flex justify-between"><a role=button>算法</a></label><ul><li><input type=checkbox id=section-30bb60688a753351f347686aa0c1d0ca class=toggle>
<label for=section-30bb60688a753351f347686aa0c1d0ca class="flex justify-between"><a role=button>_算法(第四版)_</a></label><ul><li><a href=/zh/docs/technology/Algorithm/algorithhms_4th/3.2.1/>算法红皮书 3.2.1</a></li><li><a href=/zh/docs/technology/Algorithm/algorithhms_4th/3.1.1-3.1.7/>算法红皮书 3.1.1-3.1.7</a></li><li><a href=/zh/docs/technology/Algorithm/algorithhms_4th/2.5/>算法红皮书 2.5</a></li><li><a href=/zh/docs/technology/Algorithm/algorithhms_4th/2.4/>算法红皮书 2.4</a></li><li><a href=/zh/docs/technology/Algorithm/algorithhms_4th/2.1.2-2.1.3/>算法红皮书 2.1.2-2.1.3</a></li><li><a href=/zh/docs/technology/Algorithm/algorithhms_4th/2.1.1/>算法红皮书 2.1.1</a></li><li><a href=/zh/docs/technology/Algorithm/algorithhms_4th/1.5.1-1.5.3/>算法红皮书 1.5.1-1.5.3</a></li><li><a href=/zh/docs/technology/Algorithm/algorithhms_4th/1.4.1-1.4.10/>算法红皮书 1.4.1-1.4.10</a></li><li><a href=/zh/docs/technology/Algorithm/algorithhms_4th/1.3.3.1-1.3.4/>算法红皮书1.3.3.1-1.3.4</a></li><li><a href=/zh/docs/technology/Algorithm/algorithhms_4th/1.3.1.1-1.3.2.5/>算法红皮书 1.3.1.1-1.3.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/algorithhms_4th/1.2.1-1.2.5/>算法红皮书 1.2.1-1.2.5</a></li><li><a href=/zh/docs/technology/Algorithm/algorithhms_4th/1.1.6-1.1.11/>算法红皮书 1.1.6-1.1.11</a></li><li><a href=/zh/docs/technology/Algorithm/algorithhms_4th/1.1.1-1.1.5/>算法红皮书 1.1.1-1.1.5</a></li></ul></li></ul></li><li><input type=checkbox id=section-b414f13e51dbc5e90231aa49f06e7237 class=toggle>
<label for=section-b414f13e51dbc5e90231aa49f06e7237 class="flex justify-between"><a role=button>My Batis Plus</a></label><ul><li><input type=checkbox id=section-4e717bc1448c52e86ed955c4be3f428c class=toggle>
<label for=section-4e717bc1448c52e86ed955c4be3f428c class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg/40-57/>mybatis-plus-sgg-40-57</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg/19-39/>mybatis-plus-sgg-19-39</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg/12-18/>mybatis-plus-sgg-12-18</a></li><li><a href=/zh/docs/technology/MyBatis-Plus/bl_sgg/01-11/>mybatis-plus-sgg-01-11</a></li></ul></li><li><a href=/zh/docs/technology/MyBatis-Plus/official/hello/>官方的hello-world</a></li></ul></li><li><input type=checkbox id=section-1e5a67821c47d147a096480c75e0d7c4 class=toggle>
<label for=section-1e5a67821c47d147a096480c75e0d7c4 class="flex justify-between"><a role=button>Flowable</a></label><ul><li><input type=checkbox id=section-e53ff6c199f2d0902ca5c483279f25b8 class=toggle>
<label for=section-e53ff6c199f2d0902ca5c483279f25b8 class="flex justify-between"><a role=button>基础(波哥)_</a></label><ul><li><a href=/zh/docs/technology/Flowable/boge_blbl/03-others/>boge-03-其他</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl/02-advance_6/>boge-02-flowable进阶_6</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl/02-advance_5/>boge-02-flowable进阶_5</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl/02-advance_4/>boge-02-flowable进阶_4</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl/02-advance_3/>boge-02-flowable进阶_3</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl/02-advance_2/>boge-02-flowable进阶_2</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl/02-advance_1/>boge-02-flowable进阶_1</a></li><li><a href=/zh/docs/technology/Flowable/boge_blbl/01-base/>boge-01-flowable基础</a></li></ul></li><li><input type=checkbox id=section-6019d9043956834af14f96c2f7dcd5ca class=toggle>
<label for=section-6019d9043956834af14f96c2f7dcd5ca class="flex justify-between"><a role=button>官方文档</a></label><ul><li><a href=/zh/docs/technology/Flowable/offical/05/>Flowable-05-spring-boot</a></li><li><a href=/zh/docs/technology/Flowable/offical/04/>Flowable-04-spring</a></li><li><a href=/zh/docs/technology/Flowable/offical/03/>Flowable-03-api</a></li><li><a href=/zh/docs/technology/Flowable/offical/02/>Flowable-02-Configuration</a></li><li><a href=/zh/docs/technology/Flowable/offical/01/>Flowable-01-GettingStarted</a></li></ul></li><li><a href=/zh/docs/technology/Flowable/zsx_design/01/>zsx_flowable_design01</a></li></ul></li><li><input type=checkbox id=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class=toggle>
<label for=section-bcdb1ad0996261fc1aba63e3b9c9a8e8 class="flex justify-between"><a role=button>Rocket Mq</a></label><ul><li><input type=checkbox id=section-43a4f8091b9954bf8a9e95f6b71d2c49 class=toggle>
<label for=section-43a4f8091b9954bf8a9e95f6b71d2c49 class="flex justify-between"><a role=button>基础(黑马)_</a></label><ul><li><a href=/zh/docs/technology/RocketMQ/heima/05advance/>05高级功能</a></li><li><a href=/zh/docs/technology/RocketMQ/heima/04case/>04案例</a></li><li><a href=/zh/docs/technology/RocketMQ/heima/03messagetype/>03收发消息</a></li><li><a href=/zh/docs/technology/RocketMQ/heima/02buildcluster/>02双主双从集群搭建</a></li><li><a href=/zh/docs/technology/RocketMQ/heima/01base/>01rocketmq学习</a></li></ul></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/problem/>问题解决</a><ul><li><input type=checkbox id=section-ab4f1dd893a7409a00858148e98c245c class=toggle>
<label for=section-ab4f1dd893a7409a00858148e98c245c class="flex justify-between"><a role=button>Other</a></label><ul><li><a href=/zh/docs/problem/Other/01/>如何搜索</a></li></ul></li><li><input type=checkbox id=section-ef3324c710f7241c89fc009a5f576fbc class=toggle>
<label for=section-ef3324c710f7241c89fc009a5f576fbc class="flex justify-between"><a role=button>Linux</a></label><ul><li><a href=/zh/docs/problem/Linux/20230919/>Linux操作符问题</a></li><li><a href=/zh/docs/problem/Linux/20230819/>Debian问题处理3</a></li><li><a href=/zh/docs/problem/Linux/20230817/>Debian问题处理2</a></li><li><a href=/zh/docs/problem/Linux/20230815/>Debian问题处理1</a></li><li><a href=/zh/docs/problem/Linux/20230803/>安卓手机及平板安装linuxDeploy的问题简记</a></li><li><a href=/zh/docs/problem/Linux/20230523/>zsh卸载后root无法登录及vm扩容centos7报错处理</a></li><li><a href=/zh/docs/problem/Linux/20221101/>post</a></li></ul></li><li><input type=checkbox id=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class=toggle>
<label for=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/problem/JVM/20230526/>JDK代理和CGLIB代理</a></li><li><a href=/zh/docs/problem/JVM/2023052302/>linux中调试open jdk</a></li></ul></li><li><input type=checkbox id=section-a028a45b205904a783d0c60e8a184391 class=toggle>
<label for=section-a028a45b205904a783d0c60e8a184391 class="flex justify-between"><a role=button>Hexo</a></label><ul><li><a href=/zh/docs/problem/Hexo/01/>hexo在线查看pdf</a></li></ul></li><li><input type=checkbox id=section-1c55bf7a5578a7de17cc1ee45681106b class=toggle>
<label for=section-1c55bf7a5578a7de17cc1ee45681106b class="flex justify-between"><a role=button>Idea</a></label><ul><li><a href=/zh/docs/problem/Idea/01/>问题01</a></li></ul></li><li><input type=checkbox id=section-66dd985e53d8e0b78efdab983762411c class=toggle>
<label for=section-66dd985e53d8e0b78efdab983762411c class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/problem/Git/01/>git使用ssh连不上</a></li></ul></li><li><input type=checkbox id=section-9440d21f7eb9f8cf7f45b16969ab18dc class=toggle>
<label for=section-9440d21f7eb9f8cf7f45b16969ab18dc class="flex justify-between"><a role=button>Hugo</a></label><ul><li><a href=/zh/docs/problem/Hugo/p1/>hugo踩坑</a></li><li><a href=/zh/docs/problem/Hugo/01a/>图片测试(hugo踩坑)</a></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/life/>生活</a><ul><li><input type=checkbox id=section-c7f767205668758142bb8053263cc14f class=toggle>
<label for=section-c7f767205668758142bb8053263cc14f class="flex justify-between"><a role=button>往日归档</a></label><ul><li><a href=/zh/docs/life/archive/20231026/>成就</a></li><li><a href=/zh/docs/life/archive/20231013/>沉没</a></li><li><a href=/zh/docs/life/archive/20230913/>鲇鱼后思</a></li><li><a href=/zh/docs/life/archive/20230912/>病愈 有感</a></li><li><a href=/zh/docs/life/archive/20220724/>人为什么要结婚(找对象)</a></li><li><a href=/zh/docs/life/archive/20220416/>《作酒》有感</a></li><li><a href=/zh/docs/life/archive/20121226/>2021年最后一个周日</a></li><li><a href=/zh/docs/life/archive/20231021/>沉沦</a></li></ul></li><li><a href=/zh/docs/life/dailyExcerpt/>每日摘抄</a></li><li><a href=/zh/docs/life/20240626/>知命不惧 日日自新</a></li><li><a href=/zh/docs/life/20231227/>起床临感</a></li><li><a href=/zh/docs/life/20231101/>20231101</a></li></ul></li><li class=book-section-flat><span>文化</span><ul><li><input type=checkbox id=section-2caf93f41e261fb08fbc8abd7e4170d5 class=toggle>
<label for=section-2caf93f41e261fb08fbc8abd7e4170d5 class="flex justify-between"><a role=button>论语</a></label><ul><li><a href=/zh/docs/culture/%E8%AE%BA%E8%AF%AD/01%E5%AD%A6%E5%A4%A9%E7%AC%AC%E4%B8%80/>01学天第一</a></li></ul></li><li><input type=checkbox id=section-77e618b9fdc931e63e2343a70dbe6630 class=toggle>
<label for=section-77e618b9fdc931e63e2343a70dbe6630 class="flex justify-between"><a role=button>资治通鉴</a></label><ul><li><input type=checkbox id=section-196ebc38f91a63032ca3483e389aa4c5 class=toggle>
<label for=section-196ebc38f91a63032ca3483e389aa4c5 class="flex justify-between"><a role=button>周纪</a></label><ul><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/>基本知识</a></li><li><a href=/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/001%E5%91%A8%E7%BA%AA%E4%B8%80/>001周纪一</a></li></ul></li></ul></li><li><input type=checkbox id=section-5aa85019131e2605fa7465dc987f590d class=toggle>
<label for=section-5aa85019131e2605fa7465dc987f590d class="flex justify-between"><a role=button>增广贤文</a></label><ul></ul></li><li><input type=checkbox id=section-36af101672fdef38bd3af078cbe1e845 class=toggle>
<label for=section-36af101672fdef38bd3af078cbe1e845 class="flex justify-between"><a role=button>天纪</a></label><ul></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/test/>测试</a><ul><li><a href=/zh/docs/test/hello2/>pdfTest</a></li></ul></li></ul><ul><li><a href=/zh/posts/>博客</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>aqs详解</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#aqs简单介绍>AQS简单介绍</a></li><li><a href=#aqs原理>AQS原理</a><ul><li><a href=#aqs核心思想>AQS核心思想</a></li><li><a href=#aqs资源共享方式>AQS资源共享方式</a></li><li><a href=#自定义同步器>自定义同步器</a></li></ul></li><li><a href=#常见同步类>常见同步类</a><ul><li><a href=#semaphore>Semaphore</a></li><li><a href=#countdownlatch倒计时>CountDownLatch(倒计时)</a><ul><li><a href=#countdownlatch的两种典型用法>CountDownLatch的两种典型用法</a></li><li><a href=#countdownlatch-的不足>CountDownLatch 的不足</a></li><li><a href=#countdownlatch-相常见面试题改版后没了>CountDownLatch 相常见面试题（改版后没了）</a></li></ul></li><li><a href=#cyclicbarrier>CyclicBarrier</a><ul><li><a href=#原理>原理</a></li><li><a href=#cyclicbarrier源码分析>CyclicBarrier源码分析</a></li></ul></li><li><a href=#cyclicbarrier和countdownlatch区别>CyclicBarrier和CountDownLatch区别</a></li><li><a href=#reentrantlock和reentrantreadwritelock>ReentrantLock和ReentrantReadWriteLock</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><blockquote><p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!</p></blockquote><p><code>Semaphore [ˈseməfɔː(r)]</code></p><blockquote><ul><li>何为 AQS？AQS 原理了解吗？</li><li><code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 了解吗？两者的区别是什么？</li><li>用过 <code>Semaphore</code> 吗？应用场景了解吗？</li><li>&mldr;&mldr;</li></ul></blockquote><h1 id=aqs简单介绍>AQS简单介绍
<a class=anchor href=#aqs%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d>#</a></h1><p>AQS,AbstractQueueSyschronizer，即抽象队列同步器，这个类在java.util.concurrent.locks包下面</p><p><img src=img/ly-20241212141944167.png alt=ly-20241212141944167></p><p>AQS是一个抽象类，主要用来构建<strong>锁</strong>和<strong>同步器</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AbstractQueuedSynchronizer</span> <span style=color:#66d9ef>extends</span> AbstractOwnableSynchronizer <span style=color:#66d9ef>implements</span> java.<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Serializable</span> {
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>AQS <strong>为构建锁和同步器提供了一些通用功能</strong>的实现，因此，使用 AQS 能简单且高效地<strong>构造出应用广泛的大量的同步器</strong>，比如我们提到的 <strong><code>ReentrantLock</code></strong>，<strong><code>Semaphore</code></strong>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code>(jdk1.7) 等等皆是基于 AQS 的。</p><h1 id=aqs原理>AQS原理
<a class=anchor href=#aqs%e5%8e%9f%e7%90%86>#</a></h1><h2 id=aqs核心思想>AQS核心思想
<a class=anchor href=#aqs%e6%a0%b8%e5%bf%83%e6%80%9d%e6%83%b3>#</a></h2><p><strong>面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来</strong></p><p>AQS 核心思想是，如果被请求的<strong>共享资源（AQS内部）<strong>空闲，则将</strong>当前请求资源的线程</strong>设置为<strong>有效</strong>的工作线程，并且将<strong>共享资源</strong>设置为<strong>锁定</strong>状态。如果被请求的共享资源<strong>被占用</strong>，那么就需要一套<strong>线程阻塞等待</strong>以及<strong>被唤醒时锁分配</strong>的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong>实现的，即<strong>将暂时获取不到锁的线程加入到队列</strong>中。</p><blockquote><p>CLH(Craig,Landin and Hagersten)队列是一个<strong>虚拟的双向队列</strong>（虚拟的双向队列即<strong>不存在队列实例</strong>，仅存在结点之间的关联关系）。AQS 是<strong>将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点</strong>（Node）来实现锁的分配。<br>[ 搜索了一下，CLH好像是人名 ]
在 CLH 同步队列中，一个节点表示一个线程，它保存着<strong>线程的引用</strong>（thread）、 当前节点在<strong>队列中的状态</strong>（waitStatus）、<strong>前驱节点</strong>（prev）、<strong>后继节点</strong>（next）。<br>CLH队列结构<br><img src=img/ly-20241212141944445.png alt=ly-20241212141944445></p></blockquote><ul><li><p>AQS（AbstractQueuedSynchronized）原理图<br><img src=img/ly-20241212141944597.png alt=ly-20241212141944597></p><p>AQS使用一个<strong>int成员变量来表示同步状态</strong>，通过内置的<strong>线程等待队列</strong>来获取资源线程的排队工作。<br><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示<strong>当前临界资源的获锁</strong>情况。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>int</span> state;<span style=color:#75715e>//共享变量，使用volatile修饰保证线程可见性</span>
</span></span></code></pre></div><p>状态信息的操作</p><blockquote><p>通过 <code>protected</code> 类型的<code>getState()</code>、<code>setState()</code>和<code>compareAndSetState()</code> 进行操作。并且，这几个方法都是 <code>final</code> 修饰的，在子类中无法被重写。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>//返回同步状态的当前值</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getState</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> state;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//设置同步状态的值</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setState</span>(<span style=color:#66d9ef>int</span> newState) {
</span></span><span style=display:flex><span>    state <span style=color:#f92672>=</span> newState;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>compareAndSetState</span>(<span style=color:#66d9ef>int</span> expect, <span style=color:#66d9ef>int</span> update) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> unsafe.<span style=color:#a6e22e>compareAndSwapInt</span>(<span style=color:#66d9ef>this</span>, stateOffset, expect, update);
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>以 <code>ReentrantLock</code> 为例，<strong><code>state</code></strong> 初始值为 <strong>0</strong>，表示<strong>未锁定</strong>状态。A 线程 <strong><code>lock()</code></strong> 时，会调用 <strong><code>tryAcquire()</code></strong> 独占该锁并将 <strong><code>state+1</code></strong> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <strong><code>unlock()</code> 到 <code>state=</code>0</strong>（即释放锁）为止，<strong>其它线程</strong>才有机会获取该锁。当然，<strong>释放锁之前</strong>，A 线程<strong>自己是可以重复获取</strong>此锁的（<code>state</code> 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p><p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，<code>state</code> 也<strong>初始化为 N</strong>（注意 N 要与线程个数一致）。这 <strong>N 个子线程是并行执行</strong>的，每个子线程执行完后<code>countDown()</code> 一次，<strong>state 会 CAS(Compare and Swap) 减 1</strong>。等到<strong>所有子线程都执行完后(即 <code>state=0</code> )</strong>，会 <strong><code>unpark()</code> 主调用线程</strong>，然后<strong>主调用线程</strong>就会<strong>从 <code>await()</code> 函数</strong>返回，继续后余动作。</p></li></ul><p>​</p><h2 id=aqs资源共享方式>AQS资源共享方式
<a class=anchor href=#aqs%e8%b5%84%e6%ba%90%e5%85%b1%e4%ba%ab%e6%96%b9%e5%bc%8f>#</a></h2><ul><li><p>包括Exclusive（独占，<strong>只有一个线程</strong>能执行，如ReentrantLock）和Share（共享，<strong>多个线程</strong>可同时执行，如<code>Semaphore</code>/<code>CountDownLatch</code>）</p><blockquote><p>从另一个角度讲，就是<strong>只有一个</strong>线程能操作<strong>state</strong>变量以及<strong>有n个线程</strong>能操作<strong>state变量</strong>的区别</p><p>一般来说，自定义同步器的共享方式<strong>要么是独占</strong>，<strong>要么是共享</strong>，他们也只需实现**<code>tryAcquire-tryRelease</code><strong>、</strong><code>tryAcquireShared-tryReleaseShared</code><strong>中的一种即可。但 AQS 也支持自定义同步器</strong>同时实现独占<strong>和</strong>共享<strong>两种方式，如</strong><code>ReentrantReadWriteLock</code>**。</p></blockquote></li></ul><h2 id=自定义同步器>自定义同步器
<a class=anchor href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e5%90%8c%e6%ad%a5%e5%99%a8>#</a></h2><p>同步器的设计是基于<strong>模板方法模式</strong>的，如果需要<strong>自定义同步器</strong>一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承 <strong><code>AbstractQueuedSynchronizer</code></strong> 并<strong>重写</strong>指定的方法。【<strong>使用者</strong>】</li><li>将 <strong>AQS 组合</strong>在<strong>自定义同步组件的实现</strong>中，并<strong>调用其模板方法</strong>，而这些模板方法会<strong>调用使用者重写</strong>的方法。【<strong>AQS内部</strong>】</li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>tryAcquire</span>(<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>tryRelease</span>(<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>tryAcquireShared</span>(<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>tryReleaseShared</span>(<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>//该线程是否正在独占资源。只有用到condition才需要去实现它。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isHeldExclusively</span>() 
</span></span></code></pre></div><p><strong>什么是钩子方法呢？</strong> 钩子方法是一种<strong>被声明在抽象类中的方法</strong>，一般使用 <code>protected</code> 关键字修饰，它<strong>可以是空方法（由子类实现）</strong>，<strong>也可以是默认</strong>实现的方法。模板设计模式<strong>通过钩子方法控制固定步骤</strong>的实现。</p><blockquote><p>篇幅问题，这里就不详细介绍模板方法模式了，不太了解的小伙伴可以看看这篇文章：<a href=https://mp.weixin.qq.com/s/zpScSCktFpnSWHWIQem2jg>用 Java8 改造后的模板方法模式真的是 yyds!open in new window</a>。</p><p>除了上面提到的钩子方法之外，<strong>AQS 类中的其他方法都是 <code>final</code></strong> ，所以<strong>无法被其他类重写</strong>。</p></blockquote><h1 id=常见同步类>常见同步类
<a class=anchor href=#%e5%b8%b8%e8%a7%81%e5%90%8c%e6%ad%a5%e7%b1%bb>#</a></h1><h2 id=semaphore>Semaphore
<a class=anchor href=#semaphore>#</a></h2><p>Semaphore（信号量）可以指定多个线程同时访问某个资源</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @author Snailclimb
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @date 2018年9月30日
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @Description: 需要一次性拿一个许可的情况
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SemaphoreExample1</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 请求的数量</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> threadCount <span style=color:#f92672>=</span> 550;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span>
</span></span><span style=display:flex><span>    ExecutorService threadPool <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(300);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 一次只能允许执行的线程数量。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> Semaphore semaphore <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Semaphore(20);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> threadCount; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> threadnum <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>      threadPool.<span style=color:#a6e22e>execute</span>(() <span style=color:#f92672>-&gt;</span> {<span style=color:#75715e>// Lambda 表达式的运用</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>          <span style=color:#75715e>//通行证发了20个之后，就不能再发放了</span>
</span></span><span style=display:flex><span>          semaphore.<span style=color:#a6e22e>acquire</span>();<span style=color:#75715e>// 获取一个许可，所以可运行线程数量为20/1=20</span>
</span></span><span style=display:flex><span>          test(threadnum);
</span></span><span style=display:flex><span>          semaphore.<span style=color:#a6e22e>release</span>();<span style=color:#75715e>// 释放一个许可</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// TODO Auto-generated catch block</span>
</span></span><span style=display:flex><span>          e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    threadPool.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;finish&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//拿了通行证之后，处理2s钟后才释放</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test</span>(<span style=color:#66d9ef>int</span> threadnum) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>    Thread.<span style=color:#a6e22e>sleep</span>(1000);<span style=color:#75715e>// 模拟请求的耗时操作</span>
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;threadnum:&#34;</span> <span style=color:#f92672>+</span> threadnum);
</span></span><span style=display:flex><span>    Thread.<span style=color:#a6e22e>sleep</span>(1000);<span style=color:#75715e>// 模拟请求的耗时操作</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>//另一个例子</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException{
</span></span><span style=display:flex><span>        AtomicInteger atomicInteger<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> AtomicInteger();
</span></span><span style=display:flex><span>        ExecutorService executorService <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newCachedThreadPool</span>();
</span></span><span style=display:flex><span>        Semaphore semaphore<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> Semaphore(3);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>0;i<span style=color:#f92672>&lt;</span>8;i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> finalI <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            executorService.<span style=color:#a6e22e>submit</span>(()<span style=color:#f92672>-&gt;</span>{
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    semaphore.<span style=color:#a6e22e>acquire</span>();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> i1 <span style=color:#f92672>=</span> atomicInteger.<span style=color:#a6e22e>incrementAndGet</span>();
</span></span><span style=display:flex><span>                    log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;获取一个通行证&#34;</span><span style=color:#f92672>+</span> finalI); 
</span></span><span style=display:flex><span>                    TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(finalI<span style=color:#f92672>+</span>1);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                    e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>                }<span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;通行证&#34;</span><span style=color:#f92672>+</span> finalI <span style=color:#f92672>+</span><span style=color:#e6db74>&#34;释放完毕&#34;</span>);
</span></span><span style=display:flex><span>                    semaphore.<span style=color:#a6e22e>release</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;全部获取完毕&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//这个方法不会导致线程立即结束</span>
</span></span><span style=display:flex><span>        executorService.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;线程池shutdown&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#75715e>/* 结果
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:31 下午 [Thread: pool-1-thread-3] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:获取一个通行证2
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:31 下午 [Thread: main] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:全部获取完毕
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:31 下午 [Thread: main] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:线程池shutdown
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:31 下午 [Thread: pool-1-thread-2] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:获取一个通行证1
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:31 下午 [Thread: pool-1-thread-1] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:获取一个通行证0
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:32 下午 [Thread: pool-1-thread-1] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:通行证0释放完毕
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:32 下午 [Thread: pool-1-thread-4] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:获取一个通行证3
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:33 下午 [Thread: pool-1-thread-2] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:通行证1释放完毕
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:33 下午 [Thread: pool-1-thread-5] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:获取一个通行证4
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:34 下午 [Thread: pool-1-thread-3] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:通行证2释放完毕
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:34 下午 [Thread: pool-1-thread-6] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:获取一个通行证5
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:36 下午 [Thread: pool-1-thread-4] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:通行证3释放完毕
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:36 下午 [Thread: pool-1-thread-7] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:获取一个通行证6
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:38 下午 [Thread: pool-1-thread-5] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:通行证4释放完毕
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:38 下午 [Thread: pool-1-thread-8] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:获取一个通行证7
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:40 下午 [Thread: pool-1-thread-6] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:通行证5释放完毕
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:43 下午 [Thread: pool-1-thread-7] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:通行证6释放完毕
</span></span></span><span style=display:flex><span><span style=color:#75715e>2022-12-01 14:21:46 下午 [Thread: pool-1-thread-8] 
</span></span></span><span style=display:flex><span><span style=color:#75715e>INFO:通行证7释放完毕
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>Process finished with exit code 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>如上所示，先是获取了210，之后释放一个获取一个(最多获取3个)，
</span></span></span><span style=display:flex><span><span style=color:#75715e>3+n*2 =10 ，之后陆续释放0获取3，释放1获取4，释放2获取5
</span></span></span><span style=display:flex><span><span style=color:#75715e>之后 释放3获取6，释放4获取7；
</span></span></span><span style=display:flex><span><span style=color:#75715e>这是还有5,7,6拿着通行证
</span></span></span><span style=display:flex><span><span style=color:#75715e>之后随机将5，7，6释放掉即可。 
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><p>//如上，shutdown不会立即停止，而是：</p><ol><li><p>线程池shutdown之后不再接收新任务</p></li><li><p>sutdown只是<strong>将线程池的状态设置为SHUTWDOWN</strong>状态，<strong>正在执行的任务会继续执行下去</strong>，<strong>没有被执行的则中断</strong>。而shutdownNow则是将线程池的状态设置为STOP，<strong>正在执行的任务则被停止，没被执行任务的则返回</strong>。如果是shutdownNow,则会报这个问题</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>java.<span style=color:#a6e22e>lang</span>.<span style=color:#a6e22e>InterruptedException</span>: sleep interrupted
</span></span><span style=display:flex><span>  	at java.<span style=color:#a6e22e>lang</span>.<span style=color:#a6e22e>Thread</span>.<span style=color:#a6e22e>sleep</span>(Native Method)
</span></span><span style=display:flex><span>  	at java.<span style=color:#a6e22e>lang</span>.<span style=color:#a6e22e>Thread</span>.<span style=color:#a6e22e>sleep</span>(Thread.<span style=color:#a6e22e>java</span>:340)
</span></span><span style=display:flex><span>  	at java.<span style=color:#a6e22e>util</span>.<span style=color:#a6e22e>concurrent</span>.<span style=color:#a6e22e>TimeUnit</span>.<span style=color:#a6e22e>sleep</span>(TimeUnit.<span style=color:#a6e22e>java</span>:386)
</span></span><span style=display:flex><span>  	at com.<span style=color:#a6e22e>ly</span>.<span style=color:#a6e22e>SemaphoreExample2</span>.<span style=color:#a6e22e>lambda$main$0</span>(SemaphoreExample2.<span style=color:#a6e22e>java</span>:45)
</span></span><span style=display:flex><span>  	at java.<span style=color:#a6e22e>util</span>.<span style=color:#a6e22e>concurrent</span>.<span style=color:#a6e22e>Executors$RunnableAdapter</span>.<span style=color:#a6e22e>call</span>(Executors.<span style=color:#a6e22e>java</span>:511)
</span></span><span style=display:flex><span>  	at java.<span style=color:#a6e22e>util</span>.<span style=color:#a6e22e>concurrent</span>.<span style=color:#a6e22e>FutureTask</span>.<span style=color:#a6e22e>run</span>(FutureTask.<span style=color:#a6e22e>java</span>:266)
</span></span><span style=display:flex><span>  	at java.<span style=color:#a6e22e>util</span>.<span style=color:#a6e22e>concurrent</span>.<span style=color:#a6e22e>ThreadPoolExecutor</span>.<span style=color:#a6e22e>runWorker</span>(ThreadPoolExecutor.<span style=color:#a6e22e>java</span>:1149)
</span></span><span style=display:flex><span>  	at java.<span style=color:#a6e22e>util</span>.<span style=color:#a6e22e>concurrent</span>.<span style=color:#a6e22e>ThreadPoolExecutor$Worker</span>.<span style=color:#a6e22e>run</span>(ThreadPoolExecutor.<span style=color:#a6e22e>java</span>:624)
</span></span><span style=display:flex><span>  	at java.<span style=color:#a6e22e>lang</span>.<span style=color:#a6e22e>Thread</span>.<span style=color:#a6e22e>run</span>(Thread.<span style=color:#a6e22e>java</span>:748)
</span></span></code></pre></div><p>解释最上面的例子：</p><ol><li>执行acquire()方法会导致阻塞，直到有一个许可证可以获得然后拿走一个许可证</li><li>每个<strong>release()<strong>方法</strong>增加</strong>一个许可证，这**可能会释放一个阻塞的acquire()**方法</li><li>Semaphore只是维持了一个可以获得许可证的数量，<strong>没有实际的许可证这个对象</strong></li><li>Semaphore经常用于<strong>限制获取某种资源的线程数量</strong></li></ol><blockquote><p>可以一次性获取或释放多个许可，不过没必要</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>semaphore.<span style=color:#a6e22e>acquire</span>(5);<span style=color:#75715e>// 获取5个许可，所以可运行线程数量为20/5=4</span>
</span></span><span style=display:flex><span>test(threadnum);
</span></span><span style=display:flex><span>semaphore.<span style=color:#a6e22e>release</span>(5);<span style=color:#75715e>// 释放5个许可</span>
</span></span></code></pre></div></blockquote><p>除了 <code>acquire()</code> 方法之外，另一个比较常用的与之对应的方法是 <strong><code>tryAcquire()</code></strong> 方法，该方法如果获取不到许可就立即返回 false</p></li></ol><ul><li><p><strong>介绍</strong></p><p><strong><code>synchronized</code></strong> 和 <strong><code>ReentrantLock</code></strong> 都是<strong>一次只允许一个线程访问某个资源</strong>，而<code>Semaphore</code>(信号量)可以用来<strong>控制同时访问特定资源的线程数量</strong>。<br>Semaphore 的使用简单，我们这里<strong>假设有 N(N>5) 个线程来获取 <code>Semaphore</code> 中的共享资源</strong>，下面的代码表示<strong>同一时刻 N 个线程中只有 5 个线程能获取到共享资源</strong>，其他线程都会<strong>阻塞</strong>，只有<strong>获取到共享资源的线程才能执行</strong>。等到有线程<strong>释放</strong>了共享资源，其他阻塞的线程才能获取到。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 初始共享资源数量</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> Semaphore semaphore <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Semaphore(5);
</span></span><span style=display:flex><span><span style=color:#75715e>// 获取1个许可</span>
</span></span><span style=display:flex><span>semaphore.<span style=color:#a6e22e>acquire</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// 释放1个许可</span>
</span></span><span style=display:flex><span>semaphore.<span style=color:#a6e22e>release</span>(); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>当初始的资源个数为 1 的时候，Semaphore 退化为排他锁。
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div></li><li><p>Semaphore有两种模式，<strong>公平模式</strong>和<strong>非公平模式</strong></p><ul><li>公平模式：调用acquire()方法的顺序，就是获取许可证的顺序，遵循FIFO</li><li>非公平模式：抢占式的</li></ul><p>两个构造函数，<strong>必须提供许可数量</strong>，第二个构造方法可以指定是公平模式还是非公平模式，<strong>默认非公平模式</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Semaphore</span>(<span style=color:#66d9ef>int</span> permits) {
</span></span><span style=display:flex><span>        sync <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> NonfairSync(permits);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Semaphore</span>(<span style=color:#66d9ef>int</span> permits, <span style=color:#66d9ef>boolean</span> fair) {
</span></span><span style=display:flex><span>        sync <span style=color:#f92672>=</span> fair <span style=color:#f92672>?</span> <span style=color:#66d9ef>new</span> FairSync(permits) : <span style=color:#66d9ef>new</span> NonfairSync(permits);
</span></span><span style=display:flex><span>    } 
</span></span></code></pre></div><blockquote><p><code>Semaphore</code> 通常用于那些<strong>资源有明确访问数量限制</strong>的场景比如限流（<strong>仅限于单机模式</strong>，实际项目中推荐使用 <strong>Redis +Lua</strong> 来做限流）</p></blockquote></li><li><p>原理<br><code>Semaphore</code> 是共享锁的一种实现，它<strong>默认构造 AQS 的 <code>state</code> 值为 <code>permits</code></strong>，你可以将 <code>permits</code> 的值理解为<strong>许可证的数量</strong>，只有拿到许可证的线程才能执行。</p><ol><li><p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，<strong>如果 <code>state >= 0</code></strong> 的话，则表示可以获取成功。如果获取成功的话，使用 <strong>CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code></strong>。如果 <strong><code>state&lt;0</code></strong> 的话，则表示许可证数量不足。此时会<strong>创建一个 Node 节点加入阻塞队列</strong>，挂起当前线程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> *  获取1个许可证
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>acquire</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>   sync.<span style=color:#a6e22e>acquireSharedInterruptibly</span>(1);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * 共享模式下获取许可证，获取成功则返回，失败则加入阻塞队列，挂起线程
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>acquireSharedInterruptibly</span>(<span style=color:#66d9ef>int</span> arg)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (Thread.<span style=color:#a6e22e>interrupted</span>())
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> InterruptedException();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 尝试获取许可证，arg为获取许可证个数，当可用许可证数减当前获取的许可证数结果小于0,则创建一个节点加入阻塞队列，挂起当前线程。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (tryAcquireShared(arg) <span style=color:#f92672>&lt;</span> 0)
</span></span><span style=display:flex><span>      doAcquireSharedInterruptibly(arg);
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div></li><li><p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会<strong>唤醒同步队列中的一个线程</strong>。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state>=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 释放一个许可证</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>release</span>() {
</span></span><span style=display:flex><span>  	sync.<span style=color:#a6e22e>releaseShared</span>(1);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 释放共享锁，同时会唤醒同步队列中的一个线程。</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>releaseShared</span>(<span style=color:#66d9ef>int</span> arg) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//释放共享锁</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (tryReleaseShared(arg)) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>//唤醒同步队列中的一个线程</span>
</span></span><span style=display:flex><span>      doReleaseShared();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div></li></ol></li><li><p>补充</p><blockquote><p><code>Semaphore</code> 与 <code>CountDownLatch</code> 一样，也是共享锁的一种实现。它默认构造 AQS 的 <code>state</code> 为 <code>permits</code>。当<strong>执行任务的线程数量超出 <code>permits</code></strong>，那么<strong>多余的线程将会被放入阻塞队列 <code>Park</code></strong>,并自旋判断 <code>state</code> 是否大于 0。只有<strong>当 <code>state</code> 大于 0 的时候，阻塞的线程才能继续执行</strong>,此时先前执行任务的线程继续执行 <strong><code>release()</code> 方法，<code>release()</code> 方法使得 state 的变量会加 1</strong>，那么自旋的线程便会判断成功。 如此，<strong>每次只有最多不超过 <code>permits</code> 数量的线程能自旋成功</strong>，<strong>便限制了</strong>执行任务线程的数量。</p></blockquote></li></ul><h2 id=countdownlatch倒计时>CountDownLatch(倒计时)
<a class=anchor href=#countdownlatch%e5%80%92%e8%ae%a1%e6%97%b6>#</a></h2><ul><li><code>CountDown 倒计时器；Latch 门闩</code><ul><li>允许count个线程阻塞在一个地方，直至所有线程的任务都执行完毕</li><li><code>CountDownLatch</code> 是<strong>一次性</strong>的，计数器的值<strong>只能</strong>在构造方法中<strong>初始化一次</strong>，之后<strong>没有任何机制再次对其设置值</strong>，当 <code>CountDownLatch</code> 使用完毕后，它不能再次被使用。</li></ul></li><li>原理<ul><li>CountDownLatch是共享锁的一种实现（<strong>我的理解是 本质上是说AQS内部的state变量可以被多个线程同时修改，所以是"共享"</strong>），默认构造AQS的state值为count。当线程使用countDown()方法时，其实是使用了tryReleaseShared方法以CAS操作来减少state，直至state为0</li><li>当<strong>调用await()<strong>方法时，<strong>如果state不为0</strong>，那就证明任务还没有执行完毕,await()方法会</strong>一直阻塞</strong>，即await()方法之后的语句不会被执行。<strong>之后</strong>CountDownLatch会自旋CAS判断state==0，如果<strong>state == 0就会释放所有等待线程</strong>，await()方法之后的语句得到执行</li></ul></li></ul><h3 id=countdownlatch的两种典型用法>CountDownLatch的两种典型用法
<a class=anchor href=#countdownlatch%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%85%b8%e5%9e%8b%e7%94%a8%e6%b3%95>#</a></h3><p><strong>其实就是n个线程等待其他m个线程执行完毕后唤醒，只有n为1时是第一种情况，只有m为1时是第二种情况</strong></p><ol><li><p><strong>某线程在开始运行前等待n个线程执行完毕</strong></p><blockquote><p>将 <code>CountDownLatch</code> 的计数器初始化为 n （<strong><code>new CountDownLatch(n)</code></strong>），每<strong>当一个任务线程执行完毕</strong>，就将计数器减 1 （<strong><code>countdownlatch.countDown()</code></strong>），当计数器的值<strong>变为 0</strong> 时，在 <strong><code>CountDownLatch 上 await()</code> 的线程就会被唤醒</strong>。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p></blockquote></li><li><p>实现多个线程开始执行任务的<strong>最大并行性</strong></p></li></ol><blockquote><p>注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。<br>做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 （<code>new CountDownLatch(1)</code>），<strong>多个线程在开始执行任务前首先 <code>coundownlatch.await()</code></strong>，当主线程调用 <code>countDown()</code> 时，计数器变为 0，<strong>多个线程同时被唤醒</strong>。</p></blockquote><p>CountDownLatch使用示例</p><p>300个线程(说的是线程池有300个<strong>核心线程</strong>，而<strong>不是CountDown300次</strong>)，550个请求（及count = 550）。启动线程后，主线程阻塞。当所有请求都countDown，主线程恢复运行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @author SnailClimb
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @date 2018年10月1日
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @Description: CountDownLatch 使用方法示例
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CountDownLatchExample1</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 请求的数量</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> threadCount <span style=color:#f92672>=</span> 550;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span>
</span></span><span style=display:flex><span>    ExecutorService threadPool <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(300);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> CountDownLatch countDownLatch <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CountDownLatch(threadCount);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> threadCount; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> threadnum <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>      threadPool.<span style=color:#a6e22e>execute</span>(() <span style=color:#f92672>-&gt;</span> {<span style=color:#75715e>// Lambda 表达式的运用</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>          test(threadnum);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// TODO Auto-generated catch block</span>
</span></span><span style=display:flex><span>          e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>          countDownLatch.<span style=color:#a6e22e>countDown</span>();<span style=color:#75715e>// 表示一个请求已经被完成</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    countDownLatch.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>    threadPool.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;finish&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test</span>(<span style=color:#66d9ef>int</span> threadnum) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>    Thread.<span style=color:#a6e22e>sleep</span>(1000);<span style=color:#75715e>// 模拟请求的耗时操作</span>
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;threadnum:&#34;</span> <span style=color:#f92672>+</span> threadnum);
</span></span><span style=display:flex><span>    Thread.<span style=color:#a6e22e>sleep</span>(1000);<span style=color:#75715e>// 模拟请求的耗时操作</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><ul><li><p>与CountDownLatch的第一次交互是主线程等待其他线程</p></li><li><p>主线程必须在启动其他线程后立即调用CountDownLatch.await()方法，这样主线程的操作就会在这个方法阻塞，直到其他线程完成各自任务</p></li><li><p>其他 N 个线程<strong>必须引用闭锁对象（说的是CountDownLoatch对象）</strong>，因为他们需要通知 <code>CountDownLatch</code> 对象，他们已经完成了各自的任务。这种通知机制是通过 <code>CountDownLatch.countDown()</code>方法来完成的；<strong>每调用</strong>一次这个方法，在构造函数中初始化的 <strong>count 值就减 1</strong>。所以<strong>当 N 个线程都调 用</strong>了这个方法，count 的值等于 0，然后<strong>主线程就能通过 <code>await()</code>方法</strong>，<strong>恢复</strong>执行自己的任务。</p></li><li><p><code>CountDownLatch</code> 的 <code>await()</code> 方法使用不当很容易产生死锁，比如我们上面代码中的 for 循环改为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> threadCount<span style=color:#f92672>-</span>1; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>.......
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//这样就导致 count 的值没办法等于 0（最终为1），然后就会导致一直等待。</span>
</span></span></code></pre></div></li></ul><h3 id=countdownlatch-的不足>CountDownLatch 的不足
<a class=anchor href=#countdownlatch-%e7%9a%84%e4%b8%8d%e8%b6%b3>#</a></h3><p><strong><code>CountDownLatch</code> 是一次性的</strong>，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 <code>CountDownLatch</code> <strong>使用完毕后，它不能再次被使用</strong>。</p><h3 id=countdownlatch-相常见面试题改版后没了>CountDownLatch 相常见面试题（改版后没了）
<a class=anchor href=#countdownlatch-%e7%9b%b8%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98%e6%94%b9%e7%89%88%e5%90%8e%e6%b2%a1%e4%ba%86>#</a></h3><ul><li><code>CountDownLatch</code> 怎么用？应用场景是什么？</li><li><code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 的不同之处？</li><li><code>CountDownLatch</code> 类中主要的方法？</li></ul><h2 id=cyclicbarrier>CyclicBarrier
<a class=anchor href=#cyclicbarrier>#</a></h2><ul><li><p>CyclicBarrier和CountDownLatch类似，可以实现线程间的技术等待，主要应用场景和CountDownLatch类似，但更复杂强大 主要应用场景和 <code>CountDownLatch</code> 类似。</p><blockquote><p>CountDownLatch基于<strong>AQS</strong>，而CycliBarrier基于<strong>ReentrantLock</strong>（ReentrantLock属于AQS同步器）和<strong>Condition</strong></p></blockquote></li><li><p><code>CyclicBarrier</code> 的字面意思是<strong>可循环</strong>使用（Cyclic）的屏障（Barrier）。它要做的事情是：让<strong>一组线程(中的一个)到达一个屏障（也可以叫同步点）时</strong>被阻塞，直到<strong>最后一个线程到达屏障</strong>时，<strong>屏障才会开门</strong>，所有被屏障拦截的线程才会继续干活。</p></li></ul><h3 id=原理>原理
<a class=anchor href=#%e5%8e%9f%e7%90%86>#</a></h3><p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就<strong>尝试执行我们构造方法中输入的任务（之后再释放所有阻塞的线程）</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>//每次拦截的线程数</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> parties;
</span></span><span style=display:flex><span><span style=color:#75715e>//计数器</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> count;
</span></span></code></pre></div><p><code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法<strong>告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>CyclicBarrier</span>(<span style=color:#66d9ef>int</span> parties) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>(parties, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>CyclicBarrier</span>(<span style=color:#66d9ef>int</span> parties, Runnable barrierAction) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (parties <span style=color:#f92672>&lt;=</span> 0) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>parties</span> <span style=color:#f92672>=</span> parties;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>count</span> <span style=color:#f92672>=</span> parties;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>barrierCommand</span> <span style=color:#f92672>=</span> barrierAction;
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>先看一个例子</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @author Snailclimb
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @date 2018年10月1日
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @Description: 测试 CyclicBarrier 类中带参数的 await() 方法
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CyclicBarrierExample2</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 请求的数量</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> threadCount <span style=color:#f92672>=</span> 550;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 需要同步的线程数量</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> CyclicBarrier cyclicBarrier <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CyclicBarrier(5, () <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;------当线程数达到之后，优先执行------&#34;</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 创建线程池</span>
</span></span><span style=display:flex><span>    ExecutorService threadPool <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(10);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> threadCount; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> threadNum <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>      Thread.<span style=color:#a6e22e>sleep</span>(1000); <span style=color:#75715e>///注意这行</span>
</span></span><span style=display:flex><span>      threadPool.<span style=color:#a6e22e>execute</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>          test(threadNum);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// TODO Auto-generated catch block</span>
</span></span><span style=display:flex><span>          e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (BrokenBarrierException e) {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// TODO Auto-generated catch block</span>
</span></span><span style=display:flex><span>          e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    threadPool.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test</span>(<span style=color:#66d9ef>int</span> threadnum) <span style=color:#66d9ef>throws</span> InterruptedException, BrokenBarrierException {
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;threadnum:&#34;</span> <span style=color:#f92672>+</span> threadnum <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;is ready&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>/**等待60秒，保证子线程完全执行结束*/</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>//如果等待的时间，超过了60秒，那么就会抛出异常，而且还会进行重置(变为0个线程再等待)</span>
</span></span><span style=display:flex><span>      cyclicBarrier.<span style=color:#a6e22e>await</span>(60, TimeUnit.<span style=color:#a6e22e>SECONDS</span>);
</span></span><span style=display:flex><span>      <span style=color:#75715e>//最后一个(第5个到达后，count会重置为0)</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>      System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;-----CyclicBarrierException------&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;threadnum:&#34;</span> <span style=color:#f92672>+</span> threadnum <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;is finish&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* 结果
</span></span></span><span style=display:flex><span><span style=color:#75715e> threadnum:0is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:1is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:2is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:3is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:4is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:4is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:0is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:1is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:2is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:3is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:5is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:6is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:7is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:8is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:9is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:9is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:5is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:8is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:7is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:6is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>...... 
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> 1.可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， await() 方法之后的方法才被执行。
</span></span></span><span style=display:flex><span><span style=color:#75715e> 2.另外，CyclicBarrier 还提供一个更高级的构造函数 CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行 barrierAction，方便处理更复杂的业务场景。 
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//注意这里，如果把Thread.sleep(1000)去掉，顺序(情况之一)为：</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//也就是说，上面的代码，导致的现象：所有的ready都挤在一起了(而且不分先后，随时执行，而某5个的finish，会等待那5个的ready执行完才会执行，且finish没有顺序的)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//★如上，ready也是没有顺序的</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*threadnum:0is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:5is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:9is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:7is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:3is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:8is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:4is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:2is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:1is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:6is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>------当线程数达到之后，优先执行------    当ready数量为5的倍数时（栅栏是5个，就会执行这个）
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:3is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:10is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>------当线程数达到之后，优先执行------
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:10is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:11is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:0is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:5is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:4is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:1is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:8is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:12is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:9is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:7is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:16is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:15is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>------当线程数达到之后，优先执行------
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:14is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:6is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:13is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:2is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:19is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:16is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:12is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:18is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:11is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:23is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>------当线程数达到之后，优先执行------
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:17is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:19is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:15is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:25is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:24is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:18is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:26is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:13is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:14is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:23is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:22is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:21is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:20is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>------当线程数达到之后，优先执行------
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:29is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:28is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:27is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:22is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:24is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:25is finish
</span></span></span><span style=display:flex><span><span style=color:#75715e>threadnum:32is ready
</span></span></span><span style=display:flex><span><span style=color:#75715e>.....
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><p>在看一个例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BarrierTest1</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> InterruptedException, TimeoutException, BrokenBarrierException {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        CyclicBarrier cyclicBarrier <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CyclicBarrier(3);
</span></span><span style=display:flex><span>        ExecutorService executorService <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(10);
</span></span><span style=display:flex><span>        executorService.<span style=color:#a6e22e>submit</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(1);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                cyclicBarrier.<span style=color:#a6e22e>await</span>( );
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;数量11====&#34;</span><span style=color:#f92672>+</span>cyclicBarrier.<span style=color:#a6e22e>getNumberWaiting</span>());
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;111&#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;数量异常1111===&#34;</span><span style=color:#f92672>+</span>cyclicBarrier.<span style=color:#a6e22e>getNumberWaiting</span>());
</span></span><span style=display:flex><span>                <span style=color:#75715e>// e.printStackTrace();</span>
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;报错1&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        executorService.<span style=color:#a6e22e>submit</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(3);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;数量2222====&#34;</span><span style=color:#f92672>+</span>cyclicBarrier.<span style=color:#a6e22e>getNumberWaiting</span>());
</span></span><span style=display:flex><span>                cyclicBarrier.<span style=color:#a6e22e>await</span>(111,TimeUnit.<span style=color:#a6e22e>SECONDS</span>);
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;222&#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;数量异常2222====&#34;</span><span style=color:#f92672>+</span>cyclicBarrier.<span style=color:#a6e22e>getNumberWaiting</span>());
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;报错2&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        executorService.<span style=color:#a6e22e>submit</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;数量33 await前====&#34;</span><span style=color:#f92672>+</span>cyclicBarrier.<span style=color:#a6e22e>getNumberWaiting</span>());
</span></span><span style=display:flex><span>                cyclicBarrier.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;数量33 await后====&#34;</span><span style=color:#f92672>+</span>cyclicBarrier.<span style=color:#a6e22e>getNumberWaiting</span>());
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;333&#34;</span>);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;数量异常333====&#34;</span><span style=color:#f92672>+</span>cyclicBarrier.<span style=color:#a6e22e>getNumberWaiting</span>());
</span></span><span style=display:flex><span>                System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;报错3&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> 数量2222====1
</span></span></span><span style=display:flex><span><span style=color:#75715e>数量33 await前====2 (第1、2个处于wait状态)
</span></span></span><span style=display:flex><span><span style=color:#75715e>数量33 await后====0 （得到栅栏数量3，wait线程数重置为0）
</span></span></span><span style=display:flex><span><span style=color:#75715e>333
</span></span></span><span style=display:flex><span><span style=color:#75715e>数量11====0 （此时第1、2个线程都会释放，且数量重置为0）
</span></span></span><span style=display:flex><span><span style=color:#75715e>111
</span></span></span><span style=display:flex><span><span style=color:#75715e>222
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><h3 id=cyclicbarrier源码分析>CyclicBarrier源码分析
<a class=anchor href=#cyclicbarrier%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90>#</a></h3><ul><li><p>当调用CyclicBarrier对象调用await() 方法时，实际上调用的是dowait(false,0L )方法【主要用到false】</p><blockquote><p><code>await()</code> 方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到 <code>parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>await</span>() <span style=color:#66d9ef>throws</span> InterruptedException, BrokenBarrierException {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>return</span> dowait(<span style=color:#66d9ef>false</span>, 0L);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (TimeoutException toe) {
</span></span><span style=display:flex><span>   	 <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(toe); <span style=color:#75715e>// cannot happen</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div></li><li><p>dowait(false,0L)方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>   <span style=color:#75715e>// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> count;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Main barrier code, covering the various policies.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dowait</span>(<span style=color:#66d9ef>boolean</span> timed, <span style=color:#66d9ef>long</span> nanos)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> InterruptedException, BrokenBarrierException,
</span></span><span style=display:flex><span>               TimeoutException {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> ReentrantLock lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>lock</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 锁住</span>
</span></span><span style=display:flex><span>        lock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>final</span> Generation g <span style=color:#f92672>=</span> generation;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (g.<span style=color:#a6e22e>broken</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> BrokenBarrierException();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果线程中断了，抛出异常</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (Thread.<span style=color:#a6e22e>interrupted</span>()) {
</span></span><span style=display:flex><span>                breakBarrier();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> InterruptedException();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// cout减1  //★前面锁住了，所以不需要CAS</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> index <span style=color:#f92672>=</span> <span style=color:#f92672>--</span>count;
</span></span><span style=display:flex><span>            <span style=color:#75715e>//★★ 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (index <span style=color:#f92672>==</span> 0) {  <span style=color:#75715e>// tripped</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>boolean</span> ranAction <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>final</span> Runnable command <span style=color:#f92672>=</span> barrierCommand;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (command <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                        command.<span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>                    ranAction <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 将 count 重置为 parties 属性的初始化值</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 唤醒之前等待的线程</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 下一波执行开始</span>
</span></span><span style=display:flex><span>                    nextGeneration();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> 0;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ranAction)
</span></span><span style=display:flex><span>                        breakBarrier();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// loop until tripped, broken, interrupted, or timed out</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>timed)
</span></span><span style=display:flex><span>                        trip.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (nanos <span style=color:#f92672>&gt;</span> 0L)
</span></span><span style=display:flex><span>                        nanos <span style=color:#f92672>=</span> trip.<span style=color:#a6e22e>awaitNanos</span>(nanos);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException ie) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (g <span style=color:#f92672>==</span> generation <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span> g.<span style=color:#a6e22e>broken</span>) {
</span></span><span style=display:flex><span>                        breakBarrier();
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>throw</span> ie;
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// We&#39;re about to finish waiting even if we had not</span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// been interrupted, so this interrupt is deemed to</span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// &#34;belong&#34; to subsequent execution.</span>
</span></span><span style=display:flex><span>                        Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (g.<span style=color:#a6e22e>broken</span>)
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> BrokenBarrierException();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (g <span style=color:#f92672>!=</span> generation)
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> index;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (timed <span style=color:#f92672>&amp;&amp;</span> nanos <span style=color:#f92672>&lt;=</span> 0L) {
</span></span><span style=display:flex><span>                    breakBarrier();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> TimeoutException();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            lock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } 
</span></span></code></pre></div><blockquote><p>总结：<code>CyclicBarrier</code> 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务</p></blockquote></li></ul><h2 id=cyclicbarrier和countdownlatch区别>CyclicBarrier和CountDownLatch区别
<a class=anchor href=#cyclicbarrier%e5%92%8ccountdownlatch%e5%8c%ba%e5%88%ab>#</a></h2><ol><li><p><code>CountDownLatch</code> 是计数器，只能使用一次，而 <code>CyclicBarrier</code> 的计数器提供 <code>reset</code> 功能，可以多次使用。</p></li><li><p>从jdk作者设计的目的来看，javadoc是这么描述他们的</p><blockquote><p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p><p><strong>需要结合上面的代码示例，CyclicBarrier示例是这个意思</strong></p></blockquote></li><li><p>对于 <code>CountDownLatch</code> 来说，重点是“<strong>一个线程（多个线程）等待</strong>”，而其他的 N 个线程在完成“某件事情”之后，可以终止，也可以等待。【强调的是<strong>某个(组)等另一组线程完成</strong>】<br>而对于 <code>CyclicBarrier</code>，重点是多个线程，在<strong>任意一个线程没有完成</strong>，<strong>所有的线程都必须等待</strong>。【强调的是互相】</p></li><li><p><code>CountDownLatch</code> 是<strong>计数器</strong>，线程完成一个记录一个，只不过计数不是递增而是递减，而 <code>CyclicBarrier</code> 更像是一个<strong>阀门</strong>，需要所有线程都到达，阀门才能打开，然后继续执行。</p></li></ol><h2 id=reentrantlock和reentrantreadwritelock>ReentrantLock和ReentrantReadWriteLock
<a class=anchor href=#reentrantlock%e5%92%8creentrantreadwritelock>#</a></h2><p>读写锁 <code>ReentrantReadWriteLock</code> 可以保证<strong>多个线程可以同时读</strong>，所以在<strong>读操作远大于写操作的时候</strong>，读写锁就非常有用了。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#aqs简单介绍>AQS简单介绍</a></li><li><a href=#aqs原理>AQS原理</a><ul><li><a href=#aqs核心思想>AQS核心思想</a></li><li><a href=#aqs资源共享方式>AQS资源共享方式</a></li><li><a href=#自定义同步器>自定义同步器</a></li></ul></li><li><a href=#常见同步类>常见同步类</a><ul><li><a href=#semaphore>Semaphore</a></li><li><a href=#countdownlatch倒计时>CountDownLatch(倒计时)</a><ul><li><a href=#countdownlatch的两种典型用法>CountDownLatch的两种典型用法</a></li><li><a href=#countdownlatch-的不足>CountDownLatch 的不足</a></li><li><a href=#countdownlatch-相常见面试题改版后没了>CountDownLatch 相常见面试题（改版后没了）</a></li></ul></li><li><a href=#cyclicbarrier>CyclicBarrier</a><ul><li><a href=#原理>原理</a></li><li><a href=#cyclicbarrier源码分析>CyclicBarrier源码分析</a></li></ul></li><li><a href=#cyclicbarrier和countdownlatch区别>CyclicBarrier和CountDownLatch区别</a></li><li><a href=#reentrantlock和reentrantreadwritelock>ReentrantLock和ReentrantReadWriteLock</a></li></ul></li></ul></nav></div></aside></main></body></html>