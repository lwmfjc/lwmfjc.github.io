<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>随记</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/</link><description>Recent content on 随记</description><generator>Hugo</generator><language>zh</language><atom:link href="https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>常见数据结构经典LeetCode题目推荐</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/common-data-structures-leetcode-recommendations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/common-data-structures-leetcode-recommendations/</guid><description>&lt;h2 id="数组">
 数组
 &lt;a class="anchor" href="#%e6%95%b0%e7%bb%84">#&lt;/a>
&lt;/h2>
&lt;p>704.二分查找：
&lt;a target="_blank" href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/&lt;/a>&lt;/p>
&lt;p>80.删除有序数组中的重复项 II：
&lt;a target="_blank" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii">https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii&lt;/a>&lt;/p>
&lt;p>977.有序数组的平方：
&lt;a target="_blank" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/&lt;/a>&lt;/p>
&lt;h2 id="链表">
 链表
 &lt;a class="anchor" href="#%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h2>
&lt;p>707.设计链表：
&lt;a target="_blank" href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/&lt;/a>&lt;/p>
&lt;p>206.反转链表：
&lt;a target="_blank" href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/&lt;/a>&lt;/p>
&lt;p>92.反转链表 II：
&lt;a target="_blank" href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/&lt;/a>&lt;/p>
&lt;p>61.旋转链表：
&lt;a target="_blank" href="https://leetcode.cn/problems/rotate-list/">https://leetcode.cn/problems/rotate-list/&lt;/a>&lt;/p>
&lt;h2 id="栈与队列">
 栈与队列
 &lt;a class="anchor" href="#%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97">#&lt;/a>
&lt;/h2>
&lt;p>232.用栈实现队列：
&lt;a target="_blank" href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/&lt;/a>&lt;/p>
&lt;p>225.用队列实现栈：
&lt;a target="_blank" href="https://leetcode.cn/problems/implement-stack-using-queues/">https://leetcode.cn/problems/implement-stack-using-queues/&lt;/a>&lt;/p>
&lt;p>347.前 K 个高频元素：
&lt;a target="_blank" href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/&lt;/a>&lt;/p>
&lt;p>239.滑动窗口最大值：
&lt;a target="_blank" href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/&lt;/a>&lt;/p>
&lt;h2 id="二叉树">
 二叉树
 &lt;a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91">#&lt;/a>
&lt;/h2>
&lt;p>105.从前序与中序遍历构造二叉树：
&lt;a target="_blank" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&lt;/a>&lt;/p>
&lt;p>117.填充每个节点的下一个右侧节点指针 II：
&lt;a target="_blank" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii&lt;/a>&lt;/p>
&lt;p>236.二叉树的最近公共祖先：
&lt;a target="_blank" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/&lt;/a>&lt;/p>
&lt;p>129.求根节点到叶节点数字之和：
&lt;a target="_blank" href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">https://leetcode.cn/problems/sum-root-to-leaf-numbers/&lt;/a>&lt;/p>
&lt;p>102.二叉树的层序遍历：
&lt;a target="_blank" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/&lt;/a>&lt;/p>
&lt;p>530.二叉搜索树的最小绝对差：
&lt;a target="_blank" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">https://leetcode.cn/problems/minimum-absolute-difference-in-bst/&lt;/a>&lt;/p>
&lt;h2 id="图">
 图
 &lt;a class="anchor" href="#%e5%9b%be">#&lt;/a>
&lt;/h2>
&lt;p>200.岛屿数量：
&lt;a target="_blank" href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/&lt;/a>&lt;/p>
&lt;p>207.课程表：
&lt;a target="_blank" href="https://leetcode.cn/problems/course-schedule/">https://leetcode.cn/problems/course-schedule/&lt;/a>&lt;/p>
&lt;p>210.课程表 II：
&lt;a target="_blank" href="https://leetcode.cn/problems/course-schedule-ii/">https://leetcode.cn/problems/course-schedule-ii/&lt;/a>&lt;/p>
&lt;h2 id="堆">
 堆
 &lt;a class="anchor" href="#%e5%a0%86">#&lt;/a>
&lt;/h2>
&lt;p>215.数组中的第 K 个最大元素:
&lt;a target="_blank" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/&lt;/a>&lt;/p>
&lt;p>216.数据流的中位数:
&lt;a target="_blank" href="https://leetcode.cn/problems/find-median-from-data-stream/">https://leetcode.cn/problems/find-median-from-data-stream/&lt;/a>&lt;/p>
&lt;p>217.前 K 个高频元素：
&lt;a target="_blank" href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/&lt;/a>&lt;/p></description></item><item><title>几道常见的链表算法题</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/linkedlist-algorithm-problems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/linkedlist-algorithm-problems/</guid><description>&lt;h2 id="1-两数相加">
 1. 两数相加
 &lt;a class="anchor" href="#1-%e4%b8%a4%e6%95%b0%e7%9b%b8%e5%8a%a0">#&lt;/a>
&lt;/h2>
&lt;h3 id="题目描述">
 题目描述
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0">#&lt;/a>
&lt;/h3>
&lt;blockquote>
&lt;p>Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。&lt;/p>
&lt;p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。&lt;/p>
&lt;/blockquote>
&lt;p>示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>输出：7 -&amp;gt; 0 -&amp;gt; 8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>原因：342 + 465 = 807
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="问题分析">
 问题分析
 &lt;a class="anchor" href="#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h3>
&lt;p>Leetcode 官方详细解答地址：&lt;/p>
&lt;p>
&lt;a target="_blank" href="https://leetcode-cn.com/problems/add-two-numbers/solution/">https://leetcode-cn.com/problems/add-two-numbers/solution/&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>要对头结点进行操作时，考虑创建哑节点 dummy，使用 dummy-&amp;gt;next 表示真正的头节点。这样可以避免处理头节点为空的边界问题。&lt;/p>
&lt;/blockquote>
&lt;p>我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐
位相加的过程。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/34910956.jpg" alt="图1，对两数相加方法的可视化: 342 &amp;#43; 465 = 807， 每个结点都包含一个数字，并且数字按位逆序存储。" />&lt;/p>
&lt;h3 id="solution">
 Solution
 &lt;a class="anchor" href="#solution">#&lt;/a>
&lt;/h3>
&lt;p>&lt;mark>我们首先从最低有效位也就是列表 l1 和 l2 的表头开始相加。注意需要考虑到进位的情况！&lt;/mark>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Definition for singly-linked list.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * public class ListNode {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * int val;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * ListNode next;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * ListNode(int x) { val = x; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//https://leetcode-cn.com/problems/add-two-numbers/description/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> ListNode &lt;span style="color:#a6e22e">addTwoNumbers&lt;/span>(ListNode l1, ListNode l2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode dummyHead &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ListNode(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode p &lt;span style="color:#f92672">=&lt;/span> l1, q &lt;span style="color:#f92672">=&lt;/span> l2, curr &lt;span style="color:#f92672">=&lt;/span> dummyHead;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//carry 表示进位数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> carry &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (p &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">||&lt;/span> q &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> (p &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> p.&lt;span style="color:#a6e22e">val&lt;/span> : 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> (q &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> q.&lt;span style="color:#a6e22e">val&lt;/span> : 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> carry &lt;span style="color:#f92672">+&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//进位数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> carry &lt;span style="color:#f92672">=&lt;/span> sum &lt;span style="color:#f92672">/&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//新节点的数值为sum % 10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ListNode(sum &lt;span style="color:#f92672">%&lt;/span> 10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">=&lt;/span> curr.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (p &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) p &lt;span style="color:#f92672">=&lt;/span> p.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (q &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) q &lt;span style="color:#f92672">=&lt;/span> q.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (carry &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ListNode(carry);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> dummyHead.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2-翻转链表">
 2. 翻转链表
 &lt;a class="anchor" href="#2-%e7%bf%bb%e8%bd%ac%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h2>
&lt;h3 id="题目描述-1">
 题目描述
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0-1">#&lt;/a>
&lt;/h3>
&lt;blockquote>
&lt;p>剑指 offer:输入一个链表，反转链表后，输出链表的所有元素。&lt;/p></description></item><item><title>几道常见的字符串算法题</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/string-algorithm-problems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/string-algorithm-problems/</guid><description>&lt;blockquote>
&lt;p>作者：wwwxmu&lt;/p>
&lt;p>原文地址:
&lt;a target="_blank" href="https://www.weiweiblog.cn/13string/">https://www.weiweiblog.cn/13string/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-kmp-算法">
 1. KMP 算法
 &lt;a class="anchor" href="#1-kmp-%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;p>谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有 O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而 KMP 算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。&lt;/p>
&lt;p>具体算法细节请参考：&lt;/p>
&lt;ul>
&lt;li>
&lt;a target="_blank" href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解 KMP:&lt;/a>&lt;/li>
&lt;li>
&lt;a target="_blank" href="https://www.zhihu.com/question/21923021">如何更好的理解和掌握 KMP 算法?&lt;/a>&lt;/li>
&lt;li>
&lt;a target="_blank" href="https://blog.sengxian.com/algorithms/kmp">KMP 算法详细解析&lt;/a>&lt;/li>
&lt;li>
&lt;a target="_blank" href="http://blog.jobbole.com/76611/">图解 KMP 算法&lt;/a>&lt;/li>
&lt;li>
&lt;a target="_blank" href="https://www.bilibili.com/video/av3246487/?from=search&amp;amp;seid=17173603269940723925">汪都能听懂的 KMP 字符串匹配算法【双语字幕】&lt;/a>&lt;/li>
&lt;li>
&lt;a target="_blank" href="https://www.bilibili.com/video/av11866460?from=search&amp;amp;seid=12730654434238709250">KMP 字符串匹配算法 1&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;mark>除此之外，再来了解一下 BM 算法！&lt;/mark>&lt;/p>
&lt;blockquote>
&lt;p>BM 算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则 和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。
《字符串匹配的 KMP 算法》:
&lt;a target="_blank" href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="2-替换空格">
 2. 替换空格
 &lt;a class="anchor" href="#2-%e6%9b%bf%e6%8d%a2%e7%a9%ba%e6%a0%bc">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>剑指 offer：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。&lt;/p>
&lt;/blockquote>
&lt;p>这里我提供了两种方法：① 常规方法；② 利用 API 解决。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//https://www.weiweiblog.cn/replacespace/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 第一种方法：常规方法。利用String.charAt(i)以及String.valueOf(char).equals(&amp;#34; &amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * )遍历字符串并判断元素是否为空格。是则替换为&amp;#34;%20&amp;#34;,否则不替换
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">replaceSpace&lt;/span>(StringBuffer str) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> str.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// System.out.println(&amp;#34;length=&amp;#34; + length);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringBuffer result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuffer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> length; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> str.&lt;span style="color:#a6e22e">charAt&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (String.&lt;span style="color:#a6e22e">valueOf&lt;/span>(b).&lt;span style="color:#a6e22e">equals&lt;/span>(&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%20&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">append&lt;/span>(b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 第二种方法：利用API替换掉所用空格，一行代码解决问题
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">replaceSpace2&lt;/span>(StringBuffer str) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> str.&lt;span style="color:#a6e22e">toString&lt;/span>().&lt;span style="color:#a6e22e">replaceAll&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;\\s&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;%20&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于替换固定字符（比如空格）的情况，第二种方法其实可以使用 &lt;code>replace&lt;/code> 方法替换，性能更好!&lt;/p></description></item><item><title>剑指offer部分编程题</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/the-sword-refers-to-offer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/the-sword-refers-to-offer/</guid><description>&lt;h2 id="斐波那契数列">
 斐波那契数列
 &lt;a class="anchor" href="#%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0%e5%88%97">#&lt;/a>
&lt;/h2>
&lt;p>&lt;mark>题目描述：&lt;/mark>&lt;/p>
&lt;p>大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。
n&amp;lt;=39&lt;/p>
&lt;p>&lt;mark>问题分析：&lt;/mark>&lt;/p>
&lt;p>可以肯定的是这一题通过递归的方式是肯定能做出来，但是这样会有一个很大的问题，那就是递归大量的重复计算会导致内存溢出。另外可以使用迭代法，用 fn1 和 fn2 保存计算过程中的结果，并复用起来。下面我会把两个方法示例代码都给出来并给出两个方法的运行时间对比。&lt;/p>
&lt;p>&lt;mark>示例代码：&lt;/mark>&lt;/p>
&lt;p>采用迭代法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">Fibonacci&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> number) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (number &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (number &lt;span style="color:#f92672">==&lt;/span> 1 &lt;span style="color:#f92672">||&lt;/span> number &lt;span style="color:#f92672">==&lt;/span> 2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> first &lt;span style="color:#f92672">=&lt;/span> 1, second &lt;span style="color:#f92672">=&lt;/span> 1, third &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 3; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> number; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> third &lt;span style="color:#f92672">=&lt;/span> first &lt;span style="color:#f92672">+&lt;/span> second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> first &lt;span style="color:#f92672">=&lt;/span> second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> second &lt;span style="color:#f92672">=&lt;/span> third;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> third;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>采用递归：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">Fibonacci&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">==&lt;/span> 1&lt;span style="color:#f92672">||&lt;/span>n&lt;span style="color:#f92672">==&lt;/span>2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Fibonacci(n &lt;span style="color:#f92672">-&lt;/span> 2) &lt;span style="color:#f92672">+&lt;/span> Fibonacci(n &lt;span style="color:#f92672">-&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="跳台阶问题">
 跳台阶问题
 &lt;a class="anchor" href="#%e8%b7%b3%e5%8f%b0%e9%98%b6%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;p>&lt;mark>题目描述：&lt;/mark>&lt;/p></description></item><item><title>经典算法思想总结（含LeetCode题目推荐）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/classical-algorithm-problems-recommendations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/classical-algorithm-problems-recommendations/</guid><description>&lt;h2 id="贪心算法">
 贪心算法
 &lt;a class="anchor" href="#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;h3 id="算法思想">
 算法思想
 &lt;a class="anchor" href="#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3">#&lt;/a>
&lt;/h3>
&lt;p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。&lt;/p>
&lt;h3 id="一般解题步骤">
 一般解题步骤
 &lt;a class="anchor" href="#%e4%b8%80%e8%88%ac%e8%a7%a3%e9%a2%98%e6%ad%a5%e9%aa%a4">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>将问题分解为若干个子问题&lt;/li>
&lt;li>找出适合的贪心策略&lt;/li>
&lt;li>求解每一个子问题的最优解&lt;/li>
&lt;li>将局部最优解堆叠成全局最优解&lt;/li>
&lt;/ul>
&lt;h3 id="leetcode">
 LeetCode
 &lt;a class="anchor" href="#leetcode">#&lt;/a>
&lt;/h3>
&lt;p>455.分发饼干：
&lt;a target="_blank" href="https://leetcode.cn/problems/assign-cookies/">https://leetcode.cn/problems/assign-cookies/&lt;/a>&lt;/p>
&lt;p>121.买卖股票的最佳时机：
&lt;a target="_blank" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/&lt;/a>&lt;/p>
&lt;p>122.买卖股票的最佳时机 II：
&lt;a target="_blank" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/&lt;/a>&lt;/p>
&lt;p>55.跳跃游戏：
&lt;a target="_blank" href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/&lt;/a>&lt;/p>
&lt;p>45.跳跃游戏 II：
&lt;a target="_blank" href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/&lt;/a>&lt;/p>
&lt;h2 id="动态规划">
 动态规划
 &lt;a class="anchor" href="#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#&lt;/a>
&lt;/h2>
&lt;h3 id="算法思想-1">
 算法思想
 &lt;a class="anchor" href="#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-1">#&lt;/a>
&lt;/h3>
&lt;p>动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。&lt;/p>
&lt;p>经典题目：01 背包、完全背包&lt;/p>
&lt;h3 id="一般解题步骤-1">
 一般解题步骤
 &lt;a class="anchor" href="#%e4%b8%80%e8%88%ac%e8%a7%a3%e9%a2%98%e6%ad%a5%e9%aa%a4-1">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>确定 dp 数组（dp table）以及下标的含义&lt;/li>
&lt;li>确定递推公式&lt;/li>
&lt;li>dp 数组如何初始化&lt;/li>
&lt;li>确定遍历顺序&lt;/li>
&lt;li>举例推导 dp 数组&lt;/li>
&lt;/ul>
&lt;h3 id="leetcode-1">
 LeetCode
 &lt;a class="anchor" href="#leetcode-1">#&lt;/a>
&lt;/h3>
&lt;p>509.斐波那契数：
&lt;a target="_blank" href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/&lt;/a>&lt;/p>
&lt;p>746.使用最小花费爬楼梯：
&lt;a target="_blank" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/&lt;/a>&lt;/p>
&lt;p>416.分割等和子集：
&lt;a target="_blank" href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/&lt;/a>&lt;/p>
&lt;p>518.零钱兑换：
&lt;a target="_blank" href="https://leetcode.cn/problems/coin-change-ii/">https://leetcode.cn/problems/coin-change-ii/&lt;/a>&lt;/p>
&lt;p>647.回文子串：
&lt;a target="_blank" href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/&lt;/a>&lt;/p>
&lt;p>516.最长回文子序列：
&lt;a target="_blank" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/&lt;/a>&lt;/p>
&lt;h2 id="回溯算法">
 回溯算法
 &lt;a class="anchor" href="#%e5%9b%9e%e6%ba%af%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;h3 id="算法思想-2">
 算法思想
 &lt;a class="anchor" href="#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-2">#&lt;/a>
&lt;/h3>
&lt;p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条&lt;/p>
&lt;p>件时，就“回溯”返回，尝试别的路径。其本质就是穷举。&lt;/p>
&lt;p>经典题目：8 皇后&lt;/p>
&lt;h3 id="一般解题步骤-2">
 一般解题步骤
 &lt;a class="anchor" href="#%e4%b8%80%e8%88%ac%e8%a7%a3%e9%a2%98%e6%ad%a5%e9%aa%a4-2">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。&lt;/li>
&lt;li>确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。&lt;/li>
&lt;li>以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。&lt;/li>
&lt;/ul>
&lt;h3 id="leetcode-2">
 leetcode
 &lt;a class="anchor" href="#leetcode-2">#&lt;/a>
&lt;/h3>
&lt;p>77.组合：
&lt;a target="_blank" href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/&lt;/a>&lt;/p></description></item><item><title>十大经典排序算法总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/10-classical-sorting-algorithms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/10-classical-sorting-algorithms/</guid><description>&lt;blockquote>
&lt;p>本文转自：
&lt;a target="_blank" href="http://www.guoyaohua.com/sorting.html">http://www.guoyaohua.com/sorting.html&lt;/a>，JavaGuide 对其做了补充完善。&lt;/p>
&lt;/blockquote>
&lt;h2 id="引言">
 引言
 &lt;a class="anchor" href="#%e5%bc%95%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。&lt;/p>
&lt;h2 id="简介">
 简介
 &lt;a class="anchor" href="#%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="排序算法总结">
 排序算法总结
 &lt;a class="anchor" href="#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h3>
&lt;p>常见的内部排序算法有：&lt;mark>插入排序&lt;/mark>、&lt;mark>希尔排序&lt;/mark>、&lt;mark>选择排序&lt;/mark>、&lt;mark>冒泡排序&lt;/mark>、&lt;mark>归并排序&lt;/mark>、&lt;mark>快速排序&lt;/mark>、&lt;mark>堆排序&lt;/mark>、&lt;mark>基数排序&lt;/mark>等，本文只讲解内部排序算法。用一张表格概括：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>排序算法&lt;/th>
 &lt;th>时间复杂度（平均）&lt;/th>
 &lt;th>时间复杂度（最差）&lt;/th>
 &lt;th>时间复杂度（最好）&lt;/th>
 &lt;th>空间复杂度&lt;/th>
 &lt;th>排序方式&lt;/th>
 &lt;th>稳定性&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>冒泡排序&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n)&lt;/td>
 &lt;td>O(1)&lt;/td>
 &lt;td>内部排序&lt;/td>
 &lt;td>稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>选择排序&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(1)&lt;/td>
 &lt;td>内部排序&lt;/td>
 &lt;td>不稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>插入排序&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n)&lt;/td>
 &lt;td>O(1)&lt;/td>
 &lt;td>内部排序&lt;/td>
 &lt;td>稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>希尔排序&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(1)&lt;/td>
 &lt;td>内部排序&lt;/td>
 &lt;td>不稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>归并排序&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(n)&lt;/td>
 &lt;td>外部排序&lt;/td>
 &lt;td>稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>快速排序&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(logn)&lt;/td>
 &lt;td>内部排序&lt;/td>
 &lt;td>不稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>堆排序&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(1)&lt;/td>
 &lt;td>内部排序&lt;/td>
 &lt;td>不稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>计数排序&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>O(k)&lt;/td>
 &lt;td>外部排序&lt;/td>
 &lt;td>稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>桶排序&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>外部排序&lt;/td>
 &lt;td>稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>基数排序&lt;/td>
 &lt;td>O(n×k)&lt;/td>
 &lt;td>O(n×k)&lt;/td>
 &lt;td>O(n×k)&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>外部排序&lt;/td>
 &lt;td>稳定&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;mark>术语解释&lt;/mark>：&lt;/p></description></item></channel></rss>