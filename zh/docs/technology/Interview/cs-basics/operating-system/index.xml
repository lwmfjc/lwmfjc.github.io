<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>随记</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/</link><description>Recent content on 随记</description><generator>Hugo</generator><language>zh</language><atom:link href="https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 基础知识总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/linux-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/linux-intro/</guid><description>&lt;p>简单介绍一下 Java 程序员必知的 Linux 的一些概念以及常见命令。&lt;/p>
&lt;h2 id="初探-linux">
 初探 Linux
 &lt;a class="anchor" href="#%e5%88%9d%e6%8e%a2-linux">#&lt;/a>
&lt;/h2>
&lt;h3 id="linux-简介">
 Linux 简介
 &lt;a class="anchor" href="#linux-%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h3>
&lt;p>通过以下三点可以概括 Linux 到底是什么：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>类 Unix 系统&lt;/strong>：Linux 是一种自由、开放源码的类似 Unix 的操作系统&lt;/li>
&lt;li>&lt;strong>Linux 本质是指 Linux 内核&lt;/strong>：严格来讲，Linux 这个词本身只表示 Linux 内核，单独的 Linux 内核并不能成为一个可以正常工作的操作系统。所以，就有了各种 Linux 发行版。&lt;/li>
&lt;li>&lt;strong>Linux 之父(林纳斯·本纳第克特·托瓦兹 Linus Benedict Torvalds)&lt;/strong>：一个编程领域的传奇式人物，真大佬！我辈崇拜敬仰之楷模。他是 &lt;strong>Linux 内核&lt;/strong> 的最早作者，随后发起了这个开源项目，担任 Linux 内核的首要架构师。他还发起了 Git 这个开源项目，并为主要的开发者。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/linux/linux-father.png" alt="Linux 之父" />&lt;/p>
&lt;h3 id="linux-诞生">
 Linux 诞生
 &lt;a class="anchor" href="#linux-%e8%af%9e%e7%94%9f">#&lt;/a>
&lt;/h3>
&lt;p>1989 年，Linus Torvalds 进入芬兰陆军新地区旅，服 11 个月的国家义务兵役，军衔为少尉，主要服务于计算机部门，任务是弹道计算。服役期间，购买了安德鲁·斯图尔特·塔能鲍姆所著的教科书及 minix 源代码，开始研究操作系统。1990 年，他退伍后回到大学，开始接触 Unix。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Minix&lt;/strong> 是一个迷你版本的类 Unix 操作系统，由塔能鲍姆教授为了教学之用而创作，采用微核心设计。它启发了 Linux 内核的创作。&lt;/p>
&lt;/blockquote>
&lt;p>1991 年，Linus Torvalds 开源了 Linux 内核。Linux 以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。&lt;/p></description></item><item><title>Shell 编程基础知识总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/shell-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/shell-intro/</guid><description>&lt;p>Shell 编程在我们的日常开发工作中非常实用，目前 Linux 系统下最流行的运维自动化语言就是 Shell 和 Python 了。&lt;/p>
&lt;p>这篇文章我会简单总结一下 Shell 编程基础知识，带你入门 Shell 编程！&lt;/p>
&lt;h2 id="走进-shell-编程的大门">
 走进 Shell 编程的大门
 &lt;a class="anchor" href="#%e8%b5%b0%e8%bf%9b-shell-%e7%bc%96%e7%a8%8b%e7%9a%84%e5%a4%a7%e9%97%a8">#&lt;/a>
&lt;/h2>
&lt;h3 id="为什么要学-shell">
 为什么要学 Shell？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ad%a6-shell">#&lt;/a>
&lt;/h3>
&lt;p>学一个东西，我们大部分情况都是往实用性方向着想。从工作角度来讲，学习 Shell 是为了提高我们自己工作效率，提高产出，让我们在更少的时间完成更多的事情。&lt;/p>
&lt;p>很多人会说 Shell 编程属于运维方面的知识了，应该是运维人员来做，我们做后端开发的没必要学。我觉得这种说法大错特错，相比于专门做 Linux 运维的人员来说，我们对 Shell 编程掌握程度的要求要比他们低，但是 Shell 编程也是我们必须要掌握的！&lt;/p>
&lt;p>目前 Linux 系统下最流行的运维自动化语言就是 Shell 和 Python 了。&lt;/p>
&lt;p>两者之间，Shell 几乎是 IT 企业必须使用的运维自动化编程语言，特别是在运维工作中的服务监控、业务快速部署、服务启动停止、数据备份及处理、日志分析等环节里，shell 是不可缺的。Python 更适合处理复杂的业务逻辑，以及开发复杂的运维软件工具，实现通过 web 访问等。Shell 是一个命令解释器，解释执行用户所输入的命令和程序。一输入命令，就立即回应的交互的对话方式。&lt;/p>
&lt;p>另外，了解 shell 编程也是大部分互联网公司招聘后端开发人员的要求。下图是我截取的一些知名互联网公司对于 Shell 编程的要求。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/shell/60190220.jpg" alt="大型互联网公司对于shell编程技能的要求" />&lt;/p>
&lt;h3 id="什么是-shell">
 什么是 Shell？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-shell">#&lt;/a>
&lt;/h3>
&lt;p>简单来说“Shell 编程就是对一堆 Linux 命令的逻辑化处理”。&lt;/p>
&lt;p>W3Cschool 上的一篇文章是这样介绍 Shell 的，如下图所示。
&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/shell/19456505.jpg" alt="什么是 Shell？" />&lt;/p></description></item><item><title>操作系统常见面试题总结(上)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-01/</guid><description>&lt;p>很多读者抱怨计算操作系统的知识点比较繁杂，自己也没有多少耐心去看，但是面试的时候又经常会遇到。所以，我带着我整理好的操作系统的常见问题来啦！这篇文章总结了一些我觉得比较重要的操作系统相关的问题比如 &lt;strong>用户态和内核态、系统调用、进程和线程、死锁、内存管理、虚拟内存、文件系统&lt;/strong>等等。&lt;/p>
&lt;p>这篇文章只是对一些操作系统比较重要概念的一个概览，深入学习的话，建议大家还是老老实实地去看书。另外， 这篇文章的很多内容参考了《现代操作系统》第三版这本书，非常感谢。&lt;/p>
&lt;p>开始本文的内容之前，我们先聊聊为什么要学习操作系统。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>从对个人能力方面提升来说&lt;/strong>：操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。比如说我们开发的系统使用的缓存（比如 Redis）和操作系统的高速缓存就很像。CPU 中的高速缓存有很多种，不过大部分都是为了解决 CPU 处理速度和内存处理速度不对等的问题。我们还可以把内存看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。同样地，我们使用的 Redis 缓存就是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。高速缓存一般会按照局部性原理（2-8 原则）根据相应的淘汰算法保证缓存中的数据是经常会被访问的。我们平常使用的 Redis 缓存很多时候也会按照 2-8 原则去做，很多淘汰算法都和操作系统中的类似。既说了 2-8 原则，那就不得不提命中率了，这是所有缓存概念都通用的。简单来说也就是你要访问的数据有多少能直接在缓存中直接找到。命中率高的话，一般表明你的缓存设计比较合理，系统处理速度也相对较快。&lt;/li>
&lt;li>&lt;strong>从面试角度来说&lt;/strong>：尤其是校招，对于操作系统方面知识的考察是非常非常多的。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>简单来说，学习操作系统能够提高自己思考的深度以及对技术的理解力，并且，操作系统方面的知识也是面试必备。&lt;/strong>&lt;/p>
&lt;h2 id="操作系统基础">
 操作系统基础
 &lt;a class="anchor" href="#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="https://oss.javaguide.cn/2020-8/image-20200807161118901.png" alt="" />&lt;/p>
&lt;h3 id="什么是操作系统">
 什么是操作系统？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f">#&lt;/a>
&lt;/h3>
&lt;p>通过以下四点可以概括操作系统到底是什么：&lt;/p>
&lt;ol>
&lt;li>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。&lt;/li>
&lt;li>操作系统本质上是一个运行在计算机上的软件程序 ，主要用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。&lt;/li>
&lt;li>操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。&lt;/li>
&lt;li>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。&lt;/li>
&lt;/ol>
&lt;p>很多人容易把操作系统的内核（Kernel）和中央处理器（CPU，Central Processing Unit）弄混。你可以简单从下面两点来区别：&lt;/p>
&lt;ol>
&lt;li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。&lt;/li>
&lt;li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。&lt;/li>
&lt;/ol>
&lt;p>下图清晰说明了应用程序、内核、CPU 这三者的关系。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/2020-8/Kernel_Layout.png" alt="Kernel_Layout" />&lt;/p>
&lt;h3 id="操作系统主要有哪些功能">
 操作系统主要有哪些功能？
 &lt;a class="anchor" href="#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e4%b8%bb%e8%a6%81%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8a%9f%e8%83%bd">#&lt;/a>
&lt;/h3>
&lt;p>从资源管理的角度来看，操作系统有 6 大功能：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>进程和线程的管理&lt;/strong>：进程的创建、撤销、阻塞、唤醒，进程间的通信等。&lt;/li>
&lt;li>&lt;strong>存储管理&lt;/strong>：内存的分配和管理、外存（磁盘等）的分配和管理等。&lt;/li>
&lt;li>&lt;strong>文件管理&lt;/strong>：文件的读、写、创建及删除等。&lt;/li>
&lt;li>&lt;strong>设备管理&lt;/strong>：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。&lt;/li>
&lt;li>&lt;strong>网络管理&lt;/strong>：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。&lt;/li>
&lt;li>&lt;strong>安全管理&lt;/strong>：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。&lt;/li>
&lt;/ol>
&lt;h3 id="常见的操作系统有哪些">
 常见的操作系统有哪些？
 &lt;a class="anchor" href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%9c%89%e5%93%aa%e4%ba%9b">#&lt;/a>
&lt;/h3>
&lt;h4 id="windows">
 Windows
 &lt;a class="anchor" href="#windows">#&lt;/a>
&lt;/h4>
&lt;p>目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。界面简单易操作，软件生态非常好。&lt;/p></description></item><item><title>操作系统常见面试题总结(下)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-02/</guid><description>&lt;h2 id="内存管理">
 内存管理
 &lt;a class="anchor" href="#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;h3 id="内存管理主要做了什么">
 内存管理主要做了什么？
 &lt;a class="anchor" href="#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e4%b8%bb%e8%a6%81%e5%81%9a%e4%ba%86%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/memory-management-roles.png" alt="内存管理主要做的事情" />&lt;/p>
&lt;p>操作系统的内存管理非常重要，主要负责下面这些事情：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>内存的分配与回收&lt;/strong>：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。&lt;/li>
&lt;li>&lt;strong>地址转换&lt;/strong>：将程序中的虚拟地址转换成内存中的物理地址。&lt;/li>
&lt;li>&lt;strong>内存扩充&lt;/strong>：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。&lt;/li>
&lt;li>&lt;strong>内存映射&lt;/strong>：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。&lt;/li>
&lt;li>&lt;strong>内存优化&lt;/strong>：通过调整内存分配策略和回收算法来优化内存使用效率。&lt;/li>
&lt;li>&lt;strong>内存安全&lt;/strong>：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;h3 id="什么是内存碎片">
 什么是内存碎片？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87">#&lt;/a>
&lt;/h3>
&lt;p>内存碎片是由内存的申请和释放产生的，通常分为下面两种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)&lt;/strong>：已经分配给进程使用但未被使用的内存。导致内部内存碎片的主要原因是，当采用固定比例比如 2 的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。举个例子，一个进程只需要 65 字节的内存，但为其分配了 128（2^7） 大小的内存，那 63 字节的内存就成为了内部内存碎片。&lt;/li>
&lt;li>&lt;strong>外部内存碎片(External Memory Fragmentation，简称为外部碎片)&lt;/strong>：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片。也就是说，外部内存碎片指的是那些并未分配给进程但又不能使用的内存。我们后面介绍的分段机制就会导致外部内存碎片。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/internal-and-external-fragmentation.png" alt="内存碎片" />&lt;/p>
&lt;p>内存碎片会导致内存利用率下降，如何减少内存碎片是内存管理要非常重视的一件事情。&lt;/p>
&lt;h3 id="常见的内存管理方式有哪些">
 常见的内存管理方式有哪些？
 &lt;a class="anchor" href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b">#&lt;/a>
&lt;/h3>
&lt;p>内存管理方式可以简单分为下面两种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>连续内存管理&lt;/strong>：为一个用户程序分配一个连续的内存空间，内存利用率一般不高。&lt;/li>
&lt;li>&lt;strong>非连续内存管理&lt;/strong>：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对更加灵活一些。&lt;/li>
&lt;/ul>
&lt;h4 id="连续内存管理">
 连续内存管理
 &lt;a class="anchor" href="#%e8%bf%9e%e7%bb%ad%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86">#&lt;/a>
&lt;/h4>
&lt;p>&lt;strong>块式管理&lt;/strong> 是早期计算机操作系统的一种连续内存管理方式，存在严重的内存碎片问题。块式管理会将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为内部内存碎片。除了内部内存碎片之外，由于两个内存块之间可能还会有外部内存碎片，这些不连续的外部内存碎片由于太小了无法再进行分配。&lt;/p>
&lt;p>在 Linux 系统中，连续内存管理采用了 &lt;strong>伙伴系统（Buddy System）算法&lt;/strong> 来实现，这是一种经典的连续内存分配算法，可以有效解决外部内存碎片的问题。伙伴系统的主要思想是将内存按 2 的幂次划分（每一块内存大小都是 2 的幂次比如 2^6=64 KB），并将相邻的内存块组合成一对伙伴（注意：&lt;strong>必须是相邻的才是伙伴&lt;/strong>）。&lt;/p>
&lt;p>当进行内存分配时，伙伴系统会尝试找到大小最合适的内存块。如果找到的内存块过大，就将其一分为二，分成两个大小相等的伙伴块。如果还是大的话，就继续切分，直到到达合适的大小为止。&lt;/p>
&lt;p>假设两块相邻的内存块都被释放，系统会将这两个内存块合并，进而形成一个更大的内存块，以便后续的内存分配。这样就可以减少内存碎片的问题，提高内存利用率。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/linux-buddy-system.png" alt="伙伴系统（Buddy System）内存管理" />&lt;/p>
&lt;p>虽然解决了外部内存碎片的问题，但伙伴系统仍然存在内存利用率不高的问题（内部内存碎片）。这主要是因为伙伴系统只能分配大小为 2&lt;sup>n 的内存块，因此当需要分配的内存大小不是 2&lt;/sup>n 的整数倍时，会浪费一定的内存空间。举个例子：如果要分配 65 大小的内存快，依然需要分配 2^7=128 大小的内存块。&lt;/p></description></item></channel></rss>