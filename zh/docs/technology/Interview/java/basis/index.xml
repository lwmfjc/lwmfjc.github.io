<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>随记</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/</link><description>Recent content on 随记</description><generator>Hugo</generator><language>zh</language><atom:link href="https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-keyword-summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-keyword-summary/</guid><description>&lt;h1 id="finalstaticthissuper-关键字总结">final,static,this,super 关键字总结&lt;a class="anchor" href="#finalstaticthissuper-%e5%85%b3%e9%94%ae%e5%ad%97%e6%80%bb%e7%bb%93">#&lt;/a>&lt;/h1>
&lt;h2 id="final-关键字">final 关键字&lt;a class="anchor" href="#final-%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>&lt;/h2>
&lt;p>&lt;mark>final 关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：&lt;/mark>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>final 修饰的方法不能被重写；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>说明：使用 final 方法的原因有两个：&lt;/p>
&lt;ol>
&lt;li>把方法锁定，以防任何继承类修改它的含义；&lt;/li>
&lt;li>效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。&lt;/li>
&lt;/ol>
&lt;h2 id="static-关键字">static 关键字&lt;a class="anchor" href="#static-%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>&lt;/h2>
&lt;p>&lt;mark>static 关键字主要有以下四种使用场景：&lt;/mark>&lt;/p>
&lt;ol>
&lt;li>&lt;mark>修饰成员变量和成员方法:&lt;/mark> 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：&lt;code>类名.静态变量名&lt;/code> &lt;code>类名.静态方法名()&lt;/code>&lt;/li>
&lt;li>&lt;mark>静态代码块:&lt;/mark> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&amp;gt;非静态代码块—&amp;gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.&lt;/li>
&lt;li>&lt;mark>静态内部类（static 修饰类的话只能修饰内部类）：&lt;/mark> 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。&lt;/li>
&lt;li>&lt;mark>静态导包(用来导入类中的静态资源，1.5 之后的新特性):&lt;/mark> 格式为：&lt;code>import static&lt;/code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。&lt;/li>
&lt;/ol>
&lt;h2 id="this-关键字">this 关键字&lt;a class="anchor" href="#this-%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>&lt;/h2>
&lt;p>this 关键字用于引用类的当前实例。 例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Manager&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Employees&lt;span style="color:#f92672">[]&lt;/span> employees;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">manageEmployees&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> totalEmp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">employees&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Total employees: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> totalEmp);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">report&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">report&lt;/span>() { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面的示例中，this 关键字用于两个地方：&lt;/p></description></item><item><title>BigDecimal 详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/bigdecimal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/bigdecimal/</guid><description>&lt;p>《阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 &lt;code>BigDecimal&lt;/code> 来进行浮点数的运算”。&lt;/p>
&lt;p>浮点数的运算竟然还会有精度丢失的风险吗？确实会！&lt;/p>
&lt;p>示例代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> 2.&lt;span style="color:#a6e22e">0f&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1.&lt;span style="color:#a6e22e">9f&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> 1.&lt;span style="color:#a6e22e">8f&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1.&lt;span style="color:#a6e22e">7f&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a);&lt;span style="color:#75715e">// 0.100000024&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(b);&lt;span style="color:#75715e">// 0.099999905&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a &lt;span style="color:#f92672">==&lt;/span> b);&lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;mark>为什么浮点数 &lt;code>float&lt;/code> 或 &lt;code>double&lt;/code> 运算的时候会有精度丢失的风险呢？&lt;/mark>&lt;/p>
&lt;p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。&lt;/p>
&lt;p>就比如说十进制下的 0.2 就没办法精确转换成二进制小数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0.&lt;span style="color:#a6e22e">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> 2 &lt;span style="color:#f92672">=&lt;/span> 0.&lt;span style="color:#a6e22e">4&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0.&lt;span style="color:#a6e22e">4&lt;/span> &lt;span style="color:#f92672">*&lt;/span> 2 &lt;span style="color:#f92672">=&lt;/span> 0.&lt;span style="color:#a6e22e">8&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0.&lt;span style="color:#a6e22e">8&lt;/span> &lt;span style="color:#f92672">*&lt;/span> 2 &lt;span style="color:#f92672">=&lt;/span> 1.&lt;span style="color:#a6e22e">6&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0.&lt;span style="color:#a6e22e">6&lt;/span> &lt;span style="color:#f92672">*&lt;/span> 2 &lt;span style="color:#f92672">=&lt;/span> 1.&lt;span style="color:#a6e22e">2&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0.&lt;span style="color:#a6e22e">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> 2 &lt;span style="color:#f92672">=&lt;/span> 0.&lt;span style="color:#a6e22e">4&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 0&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>发生循环&lt;span style="color:#960050;background-color:#1e0010">）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于浮点数的更多内容，建议看一下
&lt;a target="_blank" href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">计算机系统基础（四）浮点数&lt;/a>这篇文章。&lt;/p>
&lt;h2 id="bigdecimal-介绍">BigDecimal 介绍&lt;a class="anchor" href="#bigdecimal-%e4%bb%8b%e7%bb%8d">#&lt;/a>&lt;/h2>
&lt;p>&lt;code>BigDecimal&lt;/code> 可以实现对浮点数的运算，不会造成精度丢失。&lt;/p>
&lt;p>通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 &lt;code>BigDecimal&lt;/code> 来做的。&lt;/p>
&lt;p>《阿里巴巴 Java 开发手册》中提到：&lt;mark>浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断。&lt;/mark>&lt;/p></description></item><item><title>Java SPI 机制详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/spi/</guid><description>&lt;blockquote class='book-hint '>
&lt;p>本文来自 
&lt;a target="_blank" href="https://github.com/jjx0708">Kingshion&lt;/a> 投稿。欢迎更多朋友参与到 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：
&lt;a target="_blank" href="https://javaguide.cn/javaguide/contribution-guideline.html">JavaGuide 贡献指南&lt;/a> 。&lt;/p>&lt;/blockquote>&lt;p>面向对象设计鼓励模块间基于接口而非具体实现编程，以降低模块间的耦合，遵循依赖倒置原则，并支持开闭原则（对扩展开放，对修改封闭）。然而，直接依赖具体实现会导致在替换实现时需要修改代码，违背了开闭原则。为了解决这个问题，SPI 应运而生，它提供了一种服务发现机制，允许在程序外部动态指定具体实现。这与控制反转（IoC）的思想相似，将组件装配的控制权移交给了程序之外。&lt;/p>
&lt;p>SPI 机制也解决了 Java 类加载体系中双亲委派模型带来的限制。
&lt;a target="_blank" href="https://javaguide.cn/java/jvm/classloader.html">双亲委派模型&lt;/a>虽然保证了核心库的安全性和一致性，但也限制了核心库或扩展库加载应用程序类路径上的类（通常由第三方实现）。SPI 允许核心或扩展库定义服务接口，第三方开发者提供并部署实现，SPI 服务加载机制则在运行时动态发现并加载这些实现。例如，JDBC 4.0 及之后版本利用 SPI 自动发现和加载数据库驱动，开发者只需将驱动 JAR 包放置在类路径下即可，无需使用&lt;code>Class.forName()&lt;/code>显式加载驱动类。&lt;/p>
&lt;h2 id="spi-介绍">SPI 介绍&lt;a class="anchor" href="#spi-%e4%bb%8b%e7%bb%8d">#&lt;/a>&lt;/h2>
&lt;h3 id="何谓-spi">何谓 SPI?&lt;a class="anchor" href="#%e4%bd%95%e8%b0%93-spi">#&lt;/a>&lt;/h3>
&lt;p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。&lt;/p>
&lt;p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。&lt;/p>
&lt;p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。
&lt;img src="img/378984f387cc7b09f726009ee176ed41_MD5.jpg" alt="SPI VS API" />&lt;/p>
&lt;h3 id="spi-和-api-有什么区别">SPI 和 API 有什么区别？&lt;a class="anchor" href="#spi-%e5%92%8c-api-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">#&lt;/a>&lt;/h3>
&lt;p>&lt;mark>那 SPI 和 API 有啥区别？&lt;/mark>&lt;/p>
&lt;p>说到 SPI 就不得不说一下 API（Application Programming Interface） 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下：&lt;/p>
&lt;p>&lt;img src="img/9fac41fbdcff49f370756d37be24c770_MD5.jpg" alt="SPI VS API" />&lt;/p>
&lt;p>一般模块之间都是通过接口进行通讯，因此我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。&lt;/p>
&lt;ul>
&lt;li>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 &lt;mark>API&lt;/mark>。这种情况下，接口和实现都是放在实现方的包中。调用方通过接口调用实现方的功能，而不需要关心具体的实现细节。&lt;/li>
&lt;li>当接口存在于调用方这边时，这就是 &lt;mark>SPI&lt;/mark> 。由接口调用方确定接口规则，然后由不同的厂商根据这个规则对这个接口进行实现，从而提供服务。&lt;/li>
&lt;/ul>
&lt;p>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。&lt;/p></description></item><item><title>Java 代理模式详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/proxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/proxy/</guid><description>&lt;h2 id="1-代理模式">1. 代理模式&lt;a class="anchor" href="#1-%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f">#&lt;/a>&lt;/h2>
&lt;p>代理模式是一种比较好理解的设计模式。简单来说就是 &lt;mark>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。&lt;/mark>&lt;/p>
&lt;p>&lt;mark>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。&lt;/mark>&lt;/p>
&lt;p>举个例子：新娘找来了自己的姨妈来代替自己处理新郎的提问，新娘收到的提问都是经过姨妈处理过滤之后的。姨妈在这里就可以看作是代理你的代理对象，代理的行为（方法）是接收和回复新郎的提问。&lt;/p>
&lt;p>&lt;img src="img/204386cbc258c9ee874f86cd6cfda31d_MD5.jpg" alt="Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium" />&lt;/p>
&lt;p style="text-align:right;font-size:13px;color:gray">https://medium.com/@mithunsasidharan/understanding-the-proxy-design-pattern-5e63fe38052a&lt;/p> 
&lt;p>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。&lt;/p>
&lt;h2 id="2-静态代理">2. 静态代理&lt;a class="anchor" href="#2-%e9%9d%99%e6%80%81%e4%bb%a3%e7%90%86">#&lt;/a>&lt;/h2>
&lt;p>&lt;mark>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（&lt;em>后面会具体演示代码&lt;/em>），非常不灵活（&lt;em>比如接口一旦新增加方法，目标对象和代理对象都要进行修改&lt;/em>）且麻烦(&lt;em>需要对每个目标类都单独写一个代理类&lt;/em>）。&lt;/mark> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。&lt;/p>
&lt;p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， &lt;mark>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。&lt;/mark>&lt;/p>
&lt;p>静态代理实现步骤:&lt;/p>
&lt;ol>
&lt;li>定义一个接口及其实现类；&lt;/li>
&lt;li>创建一个代理类同样实现这个接口&lt;/li>
&lt;li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。&lt;/li>
&lt;/ol>
&lt;p>下面通过代码展示！&lt;/p>
&lt;p>&lt;mark>1.定义发送短信的接口&lt;/mark>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">SmsService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#a6e22e">send&lt;/span>(String message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;mark>2.实现发送短信的接口&lt;/mark>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SmsServiceImpl&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> SmsService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">send&lt;/span>(String message) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;send message:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> message;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;mark>3.创建代理类并同样实现发送短信的接口&lt;/mark>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SmsProxy&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> SmsService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> SmsService smsService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">SmsProxy&lt;/span>(SmsService smsService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">smsService&lt;/span> &lt;span style="color:#f92672">=&lt;/span> smsService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">send&lt;/span>(String message) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//调用方法之前，我们可以添加自己的操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;before method send()&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> smsService.&lt;span style="color:#a6e22e">send&lt;/span>(message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//调用方法之后，我们同样可以添加自己的操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;after method send()&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;mark>4.实际使用&lt;/mark>&lt;/p></description></item><item><title>Java 反射机制详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/reflection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/reflection/</guid><description>&lt;h2 id="何为反射">何为反射？&lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba%e5%8f%8d%e5%b0%84">#&lt;/a>&lt;/h2>
&lt;p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。&lt;/p>
&lt;p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。&lt;/p>
&lt;p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。&lt;/p>
&lt;h2 id="反射的应用场景了解么">反射的应用场景了解么？&lt;a class="anchor" href="#%e5%8f%8d%e5%b0%84%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e4%ba%86%e8%a7%a3%e4%b9%88">#&lt;/a>&lt;/h2>
&lt;p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。&lt;/p>
&lt;p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。&lt;/p>
&lt;p>&lt;mark>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。&lt;/mark>&lt;/p>
&lt;p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 &lt;code>Method&lt;/code> 来调用指定的方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DebugInvocationHandler&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> InvocationHandler {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 代理类中的真实对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Object target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">DebugInvocationHandler&lt;/span>(Object target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span> &lt;span style="color:#f92672">=&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">invoke&lt;/span>(Object proxy, Method method, Object&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> InvocationTargetException, IllegalAccessException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;before method &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> method.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object result &lt;span style="color:#f92672">=&lt;/span> method.&lt;span style="color:#a6e22e">invoke&lt;/span>(target, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;after method &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> method.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外，像 Java 中的一大利器 &lt;mark>注解&lt;/mark> 的实现也用到了反射。&lt;/p></description></item><item><title>Java 魔法类 Unsafe 详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/unsafe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/unsafe/</guid><description>&lt;blockquote class='book-hint '>
&lt;p>本文整理完善自下面这两篇优秀的文章：&lt;/p>
&lt;ul>
&lt;li>
&lt;a target="_blank" href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java 魔法类：Unsafe 应用解析 - 美团技术团队 -2019&lt;/a>&lt;/li>
&lt;li>
&lt;a target="_blank" href="https://xie.infoq.cn/article/8b6ed4195e475bfb32dacc5cb">Java 双刃剑之 Unsafe 类详解 - 码农参上 - 2021&lt;/a>&lt;/li>
&lt;/ul>&lt;/blockquote>&lt;p>阅读过 JUC 源码的同学，一定会发现很多并发工具类都调用了一个叫做 &lt;code>Unsafe&lt;/code> 的类。&lt;/p>
&lt;p>那这个类主要是用来干什么的呢？有什么使用场景呢？这篇文章就带你搞清楚！&lt;/p>
&lt;h2 id="unsafe-介绍">Unsafe 介绍&lt;a class="anchor" href="#unsafe-%e4%bb%8b%e7%bb%8d">#&lt;/a>&lt;/h2>
&lt;p>&lt;code>Unsafe&lt;/code> 是位于 &lt;code>sun.misc&lt;/code> 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 &lt;code>Unsafe&lt;/code> 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 &lt;code>Unsafe&lt;/code> 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 &lt;code>Unsafe&lt;/code> 的使用一定要慎重。&lt;/p>
&lt;p>另外，&lt;code>Unsafe&lt;/code> 提供的这些功能的实现需要依赖本地方法（Native Method）。你可以将本地方法看作是 Java 中使用其他编程语言编写的方法。本地方法使用 &lt;mark>&lt;code>native&lt;/code>&lt;/mark> 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 &lt;mark>本地代码&lt;/mark>。&lt;/p>
&lt;p>&lt;img src="img/ce20fd456011882edae253e9d041d50e_MD5.jpg" alt="" />&lt;/p>
&lt;p>&lt;mark>为什么要使用本地方法呢？&lt;/mark>&lt;/p>
&lt;ol>
&lt;li>需要用到 Java 中不具备的依赖于操作系统的特性，Java 在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用。&lt;/li>
&lt;li>对于其他语言已经完成的一些现成功能，可以使用 Java 直接调用。&lt;/li>
&lt;li>程序对时间敏感或对性能要求非常高时，有必要使用更加底层的语言，例如 C/C++甚至是汇编。&lt;/li>
&lt;/ol>
&lt;p>在 JUC 包的很多并发工具类在实现并发机制时，都调用了本地方法，通过它们打破了 Java 运行时的界限，能够接触到操作系统底层的某些功能。对于同一本地方法，不同的操作系统可能会通过不同的方式来实现，但是对于使用者来说是透明的，最终都会得到相同的结果。&lt;/p>
&lt;h2 id="unsafe-创建">Unsafe 创建&lt;a class="anchor" href="#unsafe-%e5%88%9b%e5%bb%ba">#&lt;/a>&lt;/h2>
&lt;p>&lt;code>sun.misc.Unsafe&lt;/code> 部分源码如下：&lt;/p></description></item><item><title>Java 序列化详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/serialization/</guid><description>&lt;h2 id="什么是序列化和反序列化">什么是序列化和反序列化?&lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96">#&lt;/a>&lt;/h2>
&lt;p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。&lt;/p>
&lt;p>简单来说：&lt;/p>
&lt;ul>
&lt;li>&lt;mark>序列化&lt;/mark>：将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式&lt;/li>
&lt;li>&lt;mark>反序列化&lt;/mark>：将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程&lt;/li>
&lt;/ul>
&lt;p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。&lt;/p>
&lt;p>下面是序列化和反序列化常见应用场景：&lt;/p>
&lt;ul>
&lt;li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；&lt;/li>
&lt;li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；&lt;/li>
&lt;li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；&lt;/li>
&lt;li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。&lt;/li>
&lt;/ul>
&lt;p>维基百科是如是介绍序列化的：&lt;/p>
&lt;blockquote class='book-hint '>
&lt;p>&lt;mark>序列化&lt;/mark>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。&lt;/p>&lt;/blockquote>&lt;p>综上：&lt;mark>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。&lt;/mark>&lt;/p>
&lt;p>&lt;img src="img/0e01cb60c247264e0caf119279c0e152_MD5.jpg" alt="" />&lt;/p>
&lt;p style="text-align:right;font-size:13px;color:gray">https://www.corejavaguru.com/java/serialization/interview-questions-1&lt;/p>
&lt;p>&lt;mark>序列化协议对应于 TCP/IP 4 层模型的哪一层？&lt;/mark>&lt;/p>
&lt;p>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？&lt;/p>
&lt;ol>
&lt;li>应用层&lt;/li>
&lt;li>传输层&lt;/li>
&lt;li>网络层&lt;/li>
&lt;li>网络接口层&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="img/b2c2ed9e75219083ed2290f6d2c1e65f_MD5.jpg" alt="TCP/IP 四层模型" />&lt;/p>
&lt;p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？&lt;/p>
&lt;p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。&lt;/p>
&lt;h2 id="常见序列化协议有哪些">常见序列化协议有哪些？&lt;a class="anchor" href="#%e5%b8%b8%e8%a7%81%e5%ba%8f%e5%88%97%e5%8c%96%e5%8d%8f%e8%ae%ae%e6%9c%89%e5%93%aa%e4%ba%9b">#&lt;/a>&lt;/h2>
&lt;p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。&lt;/p>
&lt;p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。&lt;/p>
&lt;h3 id="jdk-自带的序列化方式">JDK 自带的序列化方式&lt;a class="anchor" href="#jdk-%e8%87%aa%e5%b8%a6%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%e6%96%b9%e5%bc%8f">#&lt;/a>&lt;/h3>
&lt;p>JDK 自带的序列化，只需实现 &lt;code>java.io.Serializable&lt;/code>接口即可。&lt;/p></description></item><item><title>Java 语法糖详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/syntactic-sugar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/syntactic-sugar/</guid><description>&lt;blockquote class='book-hint '>
&lt;p>作者：Hollis&lt;/p>
&lt;p>原文：
&lt;a target="_blank" href="https://mp.weixin.qq.com/s/o4XdEMq1DL-nBS-f8Za5Aw">https://mp.weixin.qq.com/s/o4XdEMq1DL-nBS-f8Za5Aw&lt;/a>&lt;/p>&lt;/blockquote>&lt;p>语法糖是大厂 Java 面试常问的一个知识点。&lt;/p>
&lt;p>本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java 语法糖的同时，了解这些语法糖背后的原理。&lt;/p>
&lt;h2 id="什么是语法糖">什么是语法糖？&lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%af%ad%e6%b3%95%e7%b3%96">#&lt;/a>&lt;/h2>
&lt;p>&lt;mark>语法糖（Syntactic Sugar）&lt;/mark> 也称糖衣语法，是英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。&lt;/p>
&lt;p>&lt;img src="img/b8f249785286ad17891cf533f1c88888_MD5.jpg" alt="" />&lt;/p>
&lt;blockquote class='book-hint '>
&lt;p>有意思的是，在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。&lt;/p>&lt;/blockquote>&lt;p>我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。很多人说 Java 是一个“低糖语言”，其实从 Java 7 开始 Java 语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在 Java 有人还是认为现在的 Java 是低糖，未来还会持续向着“高糖”的方向发展。&lt;/p>
&lt;h2 id="java-中有哪些常见的语法糖">Java 中有哪些常见的语法糖？&lt;a class="anchor" href="#java-%e4%b8%ad%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e8%af%ad%e6%b3%95%e7%b3%96">#&lt;/a>&lt;/h2>
&lt;p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实， &lt;mark>Java 虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。&lt;/mark>&lt;/p>
&lt;p>说到编译，大家肯定都知道，Java 语言中，&lt;code>javac&lt;/code>命令可以将后缀名为&lt;code>.java&lt;/code>的源文件编译为后缀名为&lt;code>.class&lt;/code>的可以运行于 Java 虚拟机的字节码。如果你去看&lt;code>com.sun.tools.javac.main.JavaCompiler&lt;/code>的源码，你会发现在&lt;code>compile()&lt;/code>中有一个步骤就是调用&lt;code>desugar()&lt;/code>，这个方法就是负责解语法糖的实现的。&lt;/p>
&lt;p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。&lt;/p>
&lt;p>我们这里会用到
&lt;a target="_blank" href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;amp;mid=2650120609&amp;amp;idx=1&amp;amp;sn=5659f96310963ad57d55b48cee63c788&amp;amp;chksm=f36bbc80c41c3596a1e4bf9501c6280481f1b9e06d07af354474e6f3ed366fef016df673a7ba&amp;amp;scene=21#wechat_redirect">反编译&lt;/a>，你可以通过 
&lt;a target="_blank" href="http://www.javadecompilers.com/">Decompilers online&lt;/a> 对 Class 文件进行在线反编译。&lt;/p>
&lt;h3 id="switch-支持-string-与枚举">switch 支持 String 与枚举&lt;a class="anchor" href="#switch-%e6%94%af%e6%8c%81-string-%e4%b8%8e%e6%9e%9a%e4%b8%be">#&lt;/a>&lt;/h3>
&lt;p>前面提到过，从 Java 7 开始，Java 语言中的语法糖在逐渐丰富，其中一个比较重要的就是 Java 7 中&lt;code>switch&lt;/code>开始支持&lt;code>String&lt;/code>。&lt;/p>
&lt;p>在开始之前先科普下，Java 中的&lt;code>switch&lt;/code>自身原本就支持基本类型。比如&lt;code>int&lt;/code>、&lt;code>char&lt;/code>等。对于&lt;code>int&lt;/code>类型，直接进行数值的比较。对于&lt;code>char&lt;/code>类型则是比较其 ascii 码。所以，对于编译器来说，&lt;code>switch&lt;/code>中其实只能使用整型，任何类型的比较都要转换成整型。比如&lt;code>byte&lt;/code>。&lt;code>short&lt;/code>，&lt;code>char&lt;/code>(ascii 码是整型)以及&lt;code>int&lt;/code>。&lt;/p></description></item><item><title>Java 值传递详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/why-there-only-value-passing-in-java/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/why-there-only-value-passing-in-java/</guid><description>&lt;p>开始之前，我们先来搞懂下面这两个概念：&lt;/p>
&lt;ul>
&lt;li>形参&amp;amp;实参&lt;/li>
&lt;li>值传递&amp;amp;引用传递&lt;/li>
&lt;/ul>
&lt;h2 id="形参实参">形参&amp;amp;实参&lt;a class="anchor" href="#%e5%bd%a2%e5%8f%82%e5%ae%9e%e5%8f%82">#&lt;/a>&lt;/h2>
&lt;p>方法的定义可能会用到 &lt;mark>参数&lt;/mark>（有参的方法），参数在程序语言中分为：&lt;/p>
&lt;ul>
&lt;li>&lt;mark>实参（实际参数，Arguments）&lt;/mark>：用于传递给函数/方法的参数，必须有确定的值。&lt;/li>
&lt;li>&lt;mark>形参（形式参数，Parameters）&lt;/mark>：用于定义函数/方法，接收实参，不需要有确定的值。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String hello &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello!&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// hello 为实参&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sayHello(hello);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// str 为形参&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sayHello&lt;/span>(String str) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(str);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="值传递引用传递">值传递&amp;amp;引用传递&lt;a class="anchor" href="#%e5%80%bc%e4%bc%a0%e9%80%92%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92">#&lt;/a>&lt;/h2>
&lt;p>程序设计语言将实参传递给方法（或函数）的方式分为两种：&lt;/p>
&lt;ul>
&lt;li>&lt;mark>值传递&lt;/mark>：方法接收的是实参值的拷贝，会创建副本。&lt;/li>
&lt;li>&lt;mark>引用传递&lt;/mark>：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。&lt;/li>
&lt;/ul>
&lt;p>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。&lt;/p>
&lt;h2 id="为什么-java-只有值传递">为什么 Java 只有值传递？&lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88-java-%e5%8f%aa%e6%9c%89%e5%80%bc%e4%bc%a0%e9%80%92">#&lt;/a>&lt;/h2>
&lt;p>&lt;mark>为什么说 Java 只有值传递呢？&lt;/mark> 不需要太多废话，我通过 3 个例子来给大家证明。&lt;/p>
&lt;h3 id="案例-1传递基本类型参数">案例 1：传递基本类型参数&lt;a class="anchor" href="#%e6%a1%88%e4%be%8b-1%e4%bc%a0%e9%80%92%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e5%8f%82%e6%95%b0">#&lt;/a>&lt;/h3>
&lt;p>代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num1 &lt;span style="color:#f92672">=&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num2 &lt;span style="color:#f92672">=&lt;/span> 20;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(num1, num2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;num1 = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> num1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;num2 = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> num2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">swap&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">=&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;b = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出：&lt;/p></description></item><item><title>Java基础常见面试题总结(上)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-basic-questions-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-basic-questions-01/</guid><description>&lt;h2 id="基础概念与常识">基础概念与常识&lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5%e4%b8%8e%e5%b8%b8%e8%af%86">#&lt;/a>&lt;/h2>
&lt;h3 id="java-语言有哪些特点">Java 语言有哪些特点?&lt;a class="anchor" href="#java-%e8%af%ad%e8%a8%80%e6%9c%89%e5%93%aa%e4%ba%9b%e7%89%b9%e7%82%b9">#&lt;/a>&lt;/h3>
&lt;ol>
&lt;li>简单易学（语法简单，上手容易）；&lt;/li>
&lt;li>面向对象（&lt;mark>封装，继承，多态&lt;/mark>）；&lt;/li>
&lt;li>&lt;mark>平台无关&lt;/mark>性（ Java 虚拟机实现平台无关性）；&lt;/li>
&lt;li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；&lt;/li>
&lt;li>可靠性（具备异常处理和自动内存管理机制）；&lt;/li>
&lt;li>安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）；&lt;/li>
&lt;li>高效性（通过 Just In Time 编译器等技术的优化，Java 语言的运行效率还是非常不错的）；&lt;/li>
&lt;li>支持网络编程并且很方便；&lt;/li>
&lt;li>编译与解释并存；&lt;/li>
&lt;li>……&lt;/li>
&lt;/ol>
&lt;blockquote class='book-hint '>
&lt;p>&lt;mark>🐛 修正（参见：
&lt;a target="_blank" href="https://github.com/Snailclimb/JavaGuide/issues/544">issue#544&lt;/a>）&lt;/mark>：C&lt;ins>11 开始（2011 年的时候）,C&lt;/ins>就引入了多线程库，在 windows、linux、macos 都可以使用&lt;code>std::thread&lt;/code>和&lt;code>std::async&lt;/code>来创建线程。参考链接：
&lt;a target="_blank" href="http://www.cplusplus.com/reference/thread/thread/?kw=thread">http://www.cplusplus.com/reference/thread/thread/?kw=thread&lt;/a>&lt;/p>&lt;/blockquote>&lt;p>🌈 拓展一下：&lt;/p>
&lt;p>“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天，依然有很多人觉得跨平台是 Java 语言最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你&lt;mark>通过 Docker 就很容易实现跨平台&lt;/mark>了。在我看来，&lt;mark>Java 强大的生态&lt;/mark>才是！&lt;/p>
&lt;h3 id="java-se-vs-java-ee">Java SE vs Java EE&lt;a class="anchor" href="#java-se-vs-java-ee">#&lt;/a>&lt;/h3>
&lt;ul>
&lt;li>Java &lt;mark>SE&lt;/mark>（Java Platform，Standard Edition）: &lt;mark>Java 平台标准版&lt;/mark>，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的&lt;mark>核心类库以及虚拟机&lt;/mark>等核心组件。Java SE 可以用于构建&lt;mark>桌面应用程序或简单的服务器&lt;/mark>应用程序。&lt;/li>
&lt;li>Java EE（Java Platform, Enterprise Edition ）：Java 平台企业版，建立在 Java SE 的基础上，包含了支持&lt;mark>企业级应用程序开发和部署的标准和规范&lt;/mark>（比如 &lt;mark>Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS&lt;/mark>）。 Java EE 可以用于构建&lt;mark>分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序&lt;/mark>。&lt;/li>
&lt;/ul>
&lt;p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发&lt;mark>桌面应用程序或简单的服务器&lt;/mark>应用程序，Java EE 更适合开发&lt;mark>复杂的企业级应用程序或 Web 应用程序&lt;/mark>。&lt;/p></description></item><item><title>Java基础常见面试题总结(下)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-basic-questions-03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-basic-questions-03/</guid><description>&lt;h2 id="异常">异常&lt;a class="anchor" href="#%e5%bc%82%e5%b8%b8">#&lt;/a>&lt;/h2>
&lt;p>&lt;mark>Java 异常类层次结构图概览&lt;/mark>：&lt;/p>
&lt;p>&lt;img src="img/942f855926e30aff652d2169b861401b_MD5.jpg" alt="Java 异常类层次结构图" />&lt;/p>
&lt;h3 id="exception-和-error-有什么区别">Exception 和 Error 有什么区别？&lt;a class="anchor" href="#exception-%e5%92%8c-error-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">#&lt;/a>&lt;/h3>
&lt;p>在 Java 中，所有的异常都有一个共同的祖先 &lt;code>java.lang&lt;/code> 包中的 &lt;code>Throwable&lt;/code> 类。&lt;code>Throwable&lt;/code> 类有两个重要的子类:&lt;/p>
&lt;ul>
&lt;li>&lt;mark>&lt;code>Exception&lt;/code>&lt;/mark> :程序本身可以处理的异常，可以通过 &lt;code>catch&lt;/code> 来进行捕获。&lt;code>Exception&lt;/code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。&lt;/li>
&lt;li>&lt;mark>&lt;code>Error&lt;/code>&lt;/mark>：&lt;code>Error&lt;/code> 属于程序无法处理的错误 ，&lt;del>我们没办法通过 &lt;code>catch&lt;/code> 来进行捕获&lt;/del>不建议通过&lt;code>catch&lt;/code>捕获 。例如 Java 虚拟机运行错误（&lt;code>Virtual MachineError&lt;/code>）、虚拟机内存不够错误(&lt;code>OutOfMemoryError&lt;/code>)、类定义错误（&lt;code>NoClassDefFoundError&lt;/code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。&lt;/li>
&lt;/ul>
&lt;h3 id="checked-exception-和-unchecked-exception-有什么区别">Checked Exception 和 Unchecked Exception 有什么区别？&lt;a class="anchor" href="#checked-exception-%e5%92%8c-unchecked-exception-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">#&lt;/a>&lt;/h3>
&lt;p>&lt;mark>Checked Exception&lt;/mark> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 &lt;code>catch&lt;/code>或者&lt;code>throws&lt;/code> 关键字处理的话，就没办法通过编译。&lt;/p>
&lt;p>比如下面这段 IO 操作的代码：&lt;/p>
&lt;p>&lt;img src="img/b543eb42c3c240a76795caf829942cb1_MD5.jpg" alt="" />&lt;/p>
&lt;p>除了&lt;code>RuntimeException&lt;/code>及其子类以外，其他的&lt;code>Exception&lt;/code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、&lt;code>ClassNotFoundException&lt;/code>、&lt;code>SQLException&lt;/code>&amp;hellip;。&lt;/p>
&lt;p>&lt;mark>Unchecked Exception&lt;/mark> 即 &lt;mark>不受检查异常&lt;/mark> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。&lt;/p></description></item><item><title>Java基础常见面试题总结(中)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-basic-questions-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-basic-questions-02/</guid><description>&lt;h2 id="面向对象基础">面向对象基础&lt;a class="anchor" href="#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e5%9f%ba%e7%a1%80">#&lt;/a>&lt;/h2>
&lt;h3 id="面向对象和面向过程的区别">面向对象和面向过程的区别&lt;a class="anchor" href="#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e5%92%8c%e9%9d%a2%e5%90%91%e8%bf%87%e7%a8%8b%e7%9a%84%e5%8c%ba%e5%88%ab">#&lt;/a>&lt;/h3>
&lt;p>面向过程编程（Procedural-Oriented Programming，POP）和面向对象编程（Object-Oriented Programming，OOP）是两种常见的编程范式，两者的主要区别在于解决问题的方式不同：&lt;/p>
&lt;ul>
&lt;li>&lt;mark>面向过程编程（POP）&lt;/mark>：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。&lt;/li>
&lt;li>&lt;mark>面向对象编程（OOP）&lt;/mark>：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。&lt;/li>
&lt;/ul>
&lt;p>相比较于 POP，OOP 开发的程序一般具有下面这些优点：&lt;/p>
&lt;ul>
&lt;li>&lt;mark>易维护&lt;/mark>：由于良好的结构和封装性，OOP 程序通常更容易维护。&lt;/li>
&lt;li>&lt;mark>易复用&lt;/mark>：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。&lt;/li>
&lt;li>&lt;mark>易扩展&lt;/mark>：模块化设计使得系统扩展变得更加容易和灵活。&lt;/li>
&lt;/ul>
&lt;p>POP 的编程方式通常更为简单和直接，适合处理一些较简单的任务。&lt;/p>
&lt;p>POP 和 OOP 的性能差异主要取决于它们的运行机制，而不仅仅是编程范式本身。因此，简单地比较两者的性能是一个常见的误区（相关 issue : 
&lt;a target="_blank" href="https://github.com/Snailclimb/JavaGuide/issues/431">面向过程：面向过程性能比面向对象高？？&lt;/a> ）。&lt;/p>
&lt;p>&lt;img src="img/2c0d720fe57dd4b32b7302a98a93e59c_MD5.jpg" alt="POP 和 OOP 性能比较不合适" />&lt;/p>
&lt;p>在选择编程范式时，性能并不是唯一的考虑因素。代码的可维护性、可扩展性和开发效率同样重要。&lt;/p>
&lt;p>现代编程语言基本都支持多种编程范式，既可以用来进行面向过程编程，也可以进行面向对象编程。&lt;/p>
&lt;p>下面是一个求圆的面积和周长的示例，简单分别展示了面向对象和面向过程两种不同的解决方案。&lt;/p>
&lt;p>&lt;mark>面向对象&lt;/mark>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Circle&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 定义圆的半径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> radius;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 构造函数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Circle&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> radius) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">radius&lt;/span> &lt;span style="color:#f92672">=&lt;/span> radius;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 计算圆的面积&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">getArea&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Math.&lt;span style="color:#a6e22e">PI&lt;/span> &lt;span style="color:#f92672">*&lt;/span> radius &lt;span style="color:#f92672">*&lt;/span> radius;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 计算圆的周长&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">getPerimeter&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> 2 &lt;span style="color:#f92672">*&lt;/span> Math.&lt;span style="color:#a6e22e">PI&lt;/span> &lt;span style="color:#f92672">*&lt;/span> radius;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建一个半径为3的圆&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Circle circle &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Circle(3.&lt;span style="color:#a6e22e">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 输出圆的面积和周长&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;圆的面积为：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> circle.&lt;span style="color:#a6e22e">getArea&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;圆的周长为：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> circle.&lt;span style="color:#a6e22e">getPerimeter&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们定义了一个 &lt;code>Circle&lt;/code> 类来表示圆，该类包含了圆的半径属性和计算面积、周长的方法。&lt;/p></description></item><item><title>泛型&amp;通配符详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/generics-and-wildcards/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/generics-and-wildcards/</guid><description>&lt;p>&lt;mark>泛型&amp;amp;通配符&lt;/mark> 相关的面试题为我的
&lt;a target="_blank" href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了
&lt;a target="_blank" href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》&lt;/a>（点击链接即可查看详细介绍以及获取方法）中。&lt;/p>
&lt;p>
&lt;a target="_blank" href="hhttps://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》&lt;/a> 的部分内容展示如下，你可以将其看作是 
&lt;a target="_blank" href="https://javaguide.cn/#/">JavaGuide&lt;/a> 的补充完善，两者可以配合使用。&lt;/p>
&lt;p>&lt;img src="img/61bbee0c0859c10b6e63fa05364c1602_MD5.jpg" alt="" />&lt;/p>
&lt;p>
&lt;a target="_blank" href="hhttps://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》&lt;/a>只是星球内部众多资料中的一个，星球还有很多其他优质资料比如
&lt;a target="_blank" href="https://javaguide.cn/zhuanlan/">专属专栏&lt;/a>、Java 编程视频、PDF 资料。&lt;/p>
&lt;p>&lt;img src="img/edd78920380346c0ee46c4e34d7e87ae_MD5.jpg" alt="" />&lt;/p></description></item></channel></rss>