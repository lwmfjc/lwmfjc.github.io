<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>随记</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/</link><description>Recent content on 随记</description><generator>Hugo</generator><language>zh</language><atom:link href="https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java8-tutorial-translate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java8-tutorial-translate/</guid><description>&lt;h1 id="java8-指南中文翻译">
 《Java8 指南》中文翻译
 &lt;a class="anchor" href="#java8-%e6%8c%87%e5%8d%97%e4%b8%ad%e6%96%87%e7%bf%bb%e8%af%91">#&lt;/a>
&lt;/h1>
&lt;p>随着 Java 8 的普及度越来越高，很多人都提到面试中关于 Java 8 也是非常常问的知识点。应各位要求和需要，我打算对这部分知识做一个总结。本来准备自己总结的，后面看到 GitHub 上有一个相关的仓库，地址：
&lt;a href="https://github.com/winterbe/java8-tutorial">https://github.com/winterbe/java8-tutorial&lt;/a>。这个仓库是英文的，我对其进行了翻译并添加和修改了部分内容，下面是正文。&lt;/p>
&lt;hr>
&lt;p>欢迎阅读我对 Java 8 的介绍。本教程将逐步指导您完成所有新语言功能。 在简短的代码示例的基础上，您将学习如何使用默认接口方法，lambda 表达式，方法引用和可重复注释。 在本文的最后，您将熟悉最新的 API 更改，如流，函数式接口(Functional Interfaces)，Map 类的扩展和新的 Date API。 没有大段枯燥的文字，只有一堆注释的代码片段。&lt;/p>
&lt;h2 id="接口的默认方法default-methods-for-interfaces">
 接口的默认方法(Default Methods for Interfaces)
 &lt;a class="anchor" href="#%e6%8e%a5%e5%8f%a3%e7%9a%84%e9%bb%98%e8%ae%a4%e6%96%b9%e6%b3%95default-methods-for-interfaces">#&lt;/a>
&lt;/h2>
&lt;p>Java 8 使我们能够通过使用 &lt;code>default&lt;/code> 关键字向接口添加非抽象方法实现。 此功能也称为&lt;a href="http://stackoverflow.com/a/24102730">虚拟扩展方法&lt;/a>。&lt;/p>
&lt;p>第一个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Formula&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">sqrt&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Math.&lt;span style="color:#a6e22e">sqrt&lt;/span>(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Formula 接口中除了抽象方法计算接口公式还定义了默认方法 &lt;code>sqrt&lt;/code>。 实现该接口的类只需要实现抽象方法 &lt;code>calculate&lt;/code>。 默认方法&lt;code>sqrt&lt;/code> 可以直接使用。当然你也可以直接通过接口创建对象，然后实现接口中的默认方法就可以了，我们通过代码演示一下这种方式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Main&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通过匿名内部类方式访问接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Formula formula &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Formula() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sqrt(a &lt;span style="color:#f92672">*&lt;/span> 100);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(formula.&lt;span style="color:#a6e22e">calculate&lt;/span>(100)); &lt;span style="color:#75715e">// 100.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(formula.&lt;span style="color:#a6e22e">sqrt&lt;/span>(16)); &lt;span style="color:#75715e">// 4.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>formula 是作为匿名对象实现的。该代码非常容易理解，6 行代码实现了计算 &lt;code>sqrt(a * 100)&lt;/code>。在下一节中，我们将会看到在 Java 8 中实现单个方法对象有一种更好更方便的方法。&lt;/p></description></item><item><title>Java 10 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java10/</guid><description>&lt;p>&lt;strong>Java 10&lt;/strong> 发布于 2018 年 3 月 20 日，最知名的特性应该是 &lt;code>var&lt;/code> 关键字（局部变量类型推断）的引入了，其他还有垃圾收集器改善、GC 改进、性能提升、线程管控等一批新特性。&lt;/p>
&lt;p>&lt;strong>概览（精选了一部分）&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/286">JEP 286：局部变量类型推断&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/304">JEP 304：垃圾回收器接口&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/307">JEP 307：G1 并行 Full GC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/310">JEP 310：应用程序类数据共享(扩展 CDS 功能)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/317">JEP 317：实验性的基于 Java 的 JIT 编译器&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="局部变量类型推断var">
 局部变量类型推断(var)
 &lt;a class="anchor" href="#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e7%b1%bb%e5%9e%8b%e6%8e%a8%e6%96%advar">#&lt;/a>
&lt;/h2>
&lt;p>由于太多 Java 开发者希望 Java 中引入局部变量推断，于是 Java 10 的时候它来了，也算是众望所归了！&lt;/p>
&lt;p>Java 10 提供了 &lt;code>var&lt;/code> 关键字声明局部变量。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> codefx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> URL(&lt;span style="color:#e6db74">&amp;#34;https://mp.weixin.qq.com/&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(1, 2, 3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> p &lt;span style="color:#f92672">=&lt;/span> Paths.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;src/test/java/Java9FeaturesTest.java&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> numbers &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> n : list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>(n&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>var 关键字只能用于带有构造器的局部变量和 for 循环中。&lt;/p></description></item><item><title>Java 11 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java11/</guid><description>&lt;p>&lt;strong>Java 11&lt;/strong> 于 2018 年 9 月 25 日正式发布，这是很重要的一个版本！Java 11 和 2017 年 9 月份发布的 Java 9 以及 2018 年 3 月份发布的 Java 10 相比，其最大的区别就是：在长期支持(Long-Term-Support)方面，&lt;strong>Oracle 表示会对 Java 11 提供大力支持，这一支持将会持续至 2026 年 9 月。这是据 Java 8 以后支持的首个长期版本。&lt;/strong>&lt;/p>
&lt;p>下面这张图是 Oracle 官方给出的 Oracle JDK 支持的时间线。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/new-features/4c1611fad59449edbbd6e233690e9fa7.png" alt="" />&lt;/p>
&lt;p>&lt;strong>概览（精选了一部分）&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/321">JEP 321：HTTP Client 标准化&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/333">JEP 333：ZGC(可伸缩低延迟垃圾收集器)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/323">JEP 323：Lambda 参数的局部变量语法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/330">JEP 330：启动单文件源代码程序&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="http-client-标准化">
 HTTP Client 标准化
 &lt;a class="anchor" href="#http-client-%e6%a0%87%e5%87%86%e5%8c%96">#&lt;/a>
&lt;/h2>
&lt;p>Java 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化，在前两个版本中进行孵化的同时，Http Client 几乎被完全重写，并且现在完全支持异步非阻塞。&lt;/p></description></item><item><title>Java 12 &amp; 13 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java12-13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java12-13/</guid><description>&lt;h2 id="java12">
 Java12
 &lt;a class="anchor" href="#java12">#&lt;/a>
&lt;/h2>
&lt;h3 id="string-增强">
 String 增强
 &lt;a class="anchor" href="#string-%e5%a2%9e%e5%bc%ba">#&lt;/a>
&lt;/h3>
&lt;p>Java 12 增加了两个的字符串处理方法，如以下所示。&lt;/p>
&lt;p>&lt;code>indent()&lt;/code> 方法可以实现字符串缩进。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String text &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Java&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 缩进 4 格&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>text &lt;span style="color:#f92672">=&lt;/span> text.&lt;span style="color:#a6e22e">indent&lt;/span>(4);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(text);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>text &lt;span style="color:#f92672">=&lt;/span> text.&lt;span style="color:#a6e22e">indent&lt;/span>(&lt;span style="color:#f92672">-&lt;/span>10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(text);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span> Java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Java
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>transform()&lt;/code> 方法可以用来转变指定字符串。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">transform&lt;/span>(input &lt;span style="color:#f92672">-&amp;gt;&lt;/span> input &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; bar&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(result); &lt;span style="color:#75715e">// foo bar&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="files-增强文件比较">
 Files 增强（文件比较）
 &lt;a class="anchor" href="#files-%e5%a2%9e%e5%bc%ba%e6%96%87%e4%bb%b6%e6%af%94%e8%be%83">#&lt;/a>
&lt;/h3>
&lt;p>Java 12 添加了以下方法来比较两个文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">mismatch&lt;/span>(Path path, Path path2) &lt;span style="color:#66d9ef">throws&lt;/span> IOException
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>mismatch()&lt;/code> 方法用于比较两个文件，并返回第一个不匹配字符的位置，如果文件相同则返回 -1L。&lt;/p>
&lt;p>代码示例（两个文件内容相同的情况）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Path filePath1 &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">createTempFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;file1&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;.txt&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Path filePath2 &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">createTempFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;file2&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;.txt&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">writeString&lt;/span>(filePath1, &lt;span style="color:#e6db74">&amp;#34;Java 12 Article&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">writeString&lt;/span>(filePath2, &lt;span style="color:#e6db74">&amp;#34;Java 12 Article&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> mismatch &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">mismatch&lt;/span>(filePath1, filePath2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>assertEquals(&lt;span style="color:#f92672">-&lt;/span>1, mismatch);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码示例（两个文件内容不相同的情况）：&lt;/p></description></item><item><title>Java 14 &amp; 15 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java14-15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java14-15/</guid><description>&lt;h2 id="java14">
 Java14
 &lt;a class="anchor" href="#java14">#&lt;/a>
&lt;/h2>
&lt;h3 id="空指针异常精准提示">
 空指针异常精准提示
 &lt;a class="anchor" href="#%e7%a9%ba%e6%8c%87%e9%92%88%e5%bc%82%e5%b8%b8%e7%b2%be%e5%87%86%e6%8f%90%e7%a4%ba">#&lt;/a>
&lt;/h3>
&lt;p>通过 JVM 参数中添加&lt;code>-XX:+ShowCodeDetailsInExceptionMessages&lt;/code>，可以在空指针异常中获取更为详细的调用信息，更快的定位和解决问题。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>a.&lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> 99; &lt;span style="color:#75715e">// 假设这段代码会发生空指针&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java 14 之前：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Exception in thread &lt;span style="color:#e6db74">&amp;#34;main&amp;#34;&lt;/span> java.&lt;span style="color:#a6e22e">lang&lt;/span>.&lt;span style="color:#a6e22e">NullPointerException&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at NullPointerExample.&lt;span style="color:#a6e22e">main&lt;/span>(NullPointerExample.&lt;span style="color:#a6e22e">java&lt;/span>:5)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java 14 之后：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 增加参数后提示的异常中很明确的告知了哪里为空导致&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Exception in thread &lt;span style="color:#e6db74">&amp;#34;main&amp;#34;&lt;/span> java.&lt;span style="color:#a6e22e">lang&lt;/span>.&lt;span style="color:#a6e22e">NullPointerException&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Cannot read field &lt;span style="color:#e6db74">&amp;#39;c&amp;#39;&lt;/span> because &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>a.&lt;span style="color:#a6e22e">b&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> is &lt;span style="color:#66d9ef">null&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at Prog.&lt;span style="color:#a6e22e">main&lt;/span>(Prog.&lt;span style="color:#a6e22e">java&lt;/span>:5)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="switch-的增强转正">
 switch 的增强(转正)
 &lt;a class="anchor" href="#switch-%e7%9a%84%e5%a2%9e%e5%bc%ba%e8%bd%ac%e6%ad%a3">#&lt;/a>
&lt;/h3>
&lt;p>Java12 引入的 switch（预览特性）在 Java14 变为正式版本，不需要增加参数来启用，直接在 JDK14 中就能使用。&lt;/p>
&lt;p>Java12 为 switch 表达式引入了类似 lambda 语法条件匹配成功后的执行块，不需要多写 break ，Java13 提供了 &lt;code>yield&lt;/code> 来在 block 中返回值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">switch&lt;/span> (day) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;M&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;W&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;F&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;MWF&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;T&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;TH&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;S&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;TTS&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(day.&lt;span style="color:#a6e22e">isEmpty&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">yield&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Please insert a valid day.&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">yield&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Looks like a Sunday.&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(result);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="预览新特性">
 预览新特性
 &lt;a class="anchor" href="#%e9%a2%84%e8%a7%88%e6%96%b0%e7%89%b9%e6%80%a7">#&lt;/a>
&lt;/h3>
&lt;h4 id="record-关键字">
 record 关键字
 &lt;a class="anchor" href="#record-%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>
&lt;/h4>
&lt;p>&lt;code>record&lt;/code> 关键字可以简化 &lt;strong>数据类&lt;/strong>（一个 Java 类一旦实例化就不能再修改）的定义方式，使用 &lt;code>record&lt;/code> 代替 &lt;code>class&lt;/code> 定义的类，只需要声明属性，就可以在获得属性的访问方法，以及 &lt;code>toString()&lt;/code>，&lt;code>hashCode()&lt;/code>, &lt;code>equals()&lt;/code>方法。&lt;/p></description></item><item><title>Java 16 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java16/</guid><description>&lt;p>Java 16 在 2021 年 3 月 16 日正式发布，非长期支持（LTS）版本。&lt;/p>
&lt;p>相关阅读：&lt;a href="https://openjdk.java.net/projects/jdk/16/">OpenJDK Java 16 文档&lt;/a> 。&lt;/p>
&lt;h2 id="jep-338向量-api第一次孵化">
 JEP 338:向量 API(第一次孵化)
 &lt;a class="anchor" href="#jep-338%e5%90%91%e9%87%8f-api%e7%ac%ac%e4%b8%80%e6%ac%a1%e5%ad%b5%e5%8c%96">#&lt;/a>
&lt;/h2>
&lt;p>向量（Vector） API 最初由 &lt;a href="https://openjdk.java.net/jeps/338">JEP 338&lt;/a> 提出，并作为&lt;a href="http://openjdk.java.net/jeps/11">孵化 API&lt;/a>集成到 Java 16 中。第二轮孵化由 &lt;a href="https://openjdk.java.net/jeps/414">JEP 414&lt;/a> 提出并集成到 Java 17 中，第三轮孵化由 &lt;a href="https://openjdk.java.net/jeps/417">JEP 417&lt;/a> 提出并集成到 Java 18 中，第四轮由 &lt;a href="https://openjdk.java.net/jeps/426">JEP 426&lt;/a> 提出并集成到了 Java 19 中。&lt;/p>
&lt;p>该孵化器 API 提供了一个 API 的初始迭代以表达一些向量计算，这些计算在运行时可靠地编译为支持的 CPU 架构上的最佳向量硬件指令，从而获得优于同等标量计算的性能，充分利用单指令多数据（SIMD）技术（大多数现代 CPU 上都可以使用的一种指令）。尽管 HotSpot 支持自动向量化，但是可转换的标量操作集有限且易受代码更改的影响。该 API 将使开发人员能够轻松地用 Java 编写可移植的高性能向量算法。&lt;/p>
&lt;p>在 &lt;a href="./java18.md">Java 18 新特性概览&lt;/a> 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。&lt;/p>
&lt;h2 id="jep-347启用-c-14-语言特性">
 JEP 347:启用 C++ 14 语言特性
 &lt;a class="anchor" href="#jep-347%e5%90%af%e7%94%a8-c-14-%e8%af%ad%e8%a8%80%e7%89%b9%e6%80%a7">#&lt;/a>
&lt;/h2>
&lt;p>Java 16 允许在 JDK 的 C++ 源代码中使用 C++14 语言特性，并提供在 HotSpot 代码中可以使用哪些特性的具体指导。&lt;/p></description></item><item><title>Java 17 新特性概览（重要）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java17/</guid><description>&lt;p>Java 17 在 2021 年 9 月 14 日正式发布，是一个长期支持（LTS）版本。&lt;/p>
&lt;p>下面这张图是 Oracle 官方给出的 Oracle JDK 支持的时间线。可以看得到，Java&lt;/p>
&lt;p>17 最多可以支持到 2029 年 9 月份。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/new-features/4c1611fad59449edbbd6e233690e9fa7.png" alt="" />&lt;/p>
&lt;p>Java 17 将是继 Java 8 以来最重要的长期支持（LTS）版本，是 Java 社区八年努力的成果。Spring 6.x 和 Spring Boot 3.x 最低支持的就是 Java 17。&lt;/p>
&lt;p>这次更新共带来 14 个新特性：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/306">JEP 306:Restore Always-Strict Floating-Point Semantics（恢复始终严格的浮点语义）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/356">JEP 356:Enhanced Pseudo-Random Number Generators（增强的伪随机数生成器）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/382">JEP 382:New macOS Rendering Pipeline（新的 macOS 渲染管道）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/391">JEP 391:macOS/AArch64 Port（支持 macOS AArch64）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/398">JEP 398:Deprecate the Applet API for Removal（删除已弃用的 Applet API）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/403">JEP 403:Strongly Encapsulate JDK Internals（更强大的封装 JDK 内部元素）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/406">JEP 406:Pattern Matching for switch (switch 的类型匹配)&lt;/a>（预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/407">JEP 407:Remove RMI Activation（删除远程方法调用激活机制）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/409">JEP 409:Sealed Classes（密封类）&lt;/a>（转正）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/410">JEP 410:Remove the Experimental AOT and JIT Compiler（删除实验性的 AOT 和 JIT 编译器）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/411">JEP 411:Deprecate the Security Manager for Removal（弃用安全管理器以进行删除）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/412">JEP 412:Foreign Function &amp;amp; Memory API (外部函数和内存 API)&lt;/a>（孵化）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/417">JEP 414:Vector（向量） API&lt;/a>（第二次孵化）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/415">JEP 415:Context-Specific Deserialization Filters&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这里只对 356、398、413、406、407、409、410、411、412、414 这几个我觉得比较重要的新特性进行详细介绍。&lt;/p></description></item><item><title>Java 18 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java18/</guid><description>&lt;p>Java 18 在 2022 年 3 月 22 日正式发布，非长期支持版本。&lt;/p>
&lt;p>Java 18 带来了 9 个新特性：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/400">JEP 400:UTF-8 by Default（默认字符集为 UTF-8）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/408">JEP 408:Simple Web Server（简易的 Web 服务器）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/413">JEP 413:Code Snippets in Java API Documentation（Java API 文档中的代码片段）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/416">JEP 416:Reimplement Core Reflection with Method Handles（使用方法句柄重新实现反射核心）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/417">JEP 417:Vector（向量） API&lt;/a>（第三次孵化）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/418">JEP 418:Internet-Address Resolution（互联网地址解析）SPI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/419">JEP 419:Foreign Function &amp;amp; Memory API（外部函数和内存 API）&lt;/a>（第二次孵化）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/420">JEP 420:Pattern Matching for switch（switch 模式匹配）&lt;/a>（第二次预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/421">JEP 421:Deprecate Finalization for Removal&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Java 17 中包含 14 个特性，Java 16 中包含 17 个特性，Java 15 中包含 14 个特性，Java 14 中包含 16 个特性。相比于前面发布的版本来说，Java 18 的新特性少了很多。&lt;/p></description></item><item><title>Java 19 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java19/</guid><description>&lt;p>JDK 19 定于 2022 年 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。&lt;/p>
&lt;p>JDK 19 只有 7 个新特性：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.org/jeps/405">JEP 405: Record Patterns（记录模式）&lt;/a>（预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/422">JEP 422: Linux/RISC-V Port&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/424">JEP 424: Foreign Function &amp;amp; Memory API（外部函数和内存 API）&lt;/a>（预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/425">JEP 425: Virtual Threads（虚拟线程）&lt;/a>（预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/426">JEP 426: Vector（向量）API&lt;/a>（第四次孵化）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/427">JEP 427: Pattern Matching for switch（switch 模式匹配）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/428">JEP 428: Structured Concurrency（结构化并发）&lt;/a>（孵化）&lt;/li>
&lt;/ul>
&lt;p>这里只对 424、425、426、428 这 4 个我觉得比较重要的新特性进行详细介绍。&lt;/p>
&lt;p>相关阅读：&lt;a href="https://openjdk.org/projects/jdk/19/">OpenJDK Java 19 文档&lt;/a>&lt;/p>
&lt;h2 id="jep-424-外部函数和内存-api预览">
 JEP 424: 外部函数和内存 API（预览）
 &lt;a class="anchor" href="#jep-424-%e5%a4%96%e9%83%a8%e5%87%bd%e6%95%b0%e5%92%8c%e5%86%85%e5%ad%98-api%e9%a2%84%e8%a7%88">#&lt;/a>
&lt;/h2>
&lt;p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。&lt;/p></description></item><item><title>Java 20 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java20/</guid><description>&lt;p>JDK 20 于 2023 年 3 月 21 日发布，非长期支持版本。&lt;/p>
&lt;p>根据开发计划，下一个 LTS 版本就是将于 2023 年 9 月发布的 JDK 21。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/new-features/640.png" alt="" />&lt;/p>
&lt;p>JDK 20 只有 7 个新特性：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.org/jeps/429">JEP 429：Scoped Values（作用域值）&lt;/a>（第一次孵化）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/432">JEP 432：Record Patterns（记录模式）&lt;/a>（第二次预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/433">JEP 433：switch 模式匹配&lt;/a>（第四次预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/434">JEP 434: Foreign Function &amp;amp; Memory API（外部函数和内存 API）&lt;/a>（第二次预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/436">JEP 436: Virtual Threads（虚拟线程）&lt;/a>（第二次预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/437">JEP 437:Structured Concurrency（结构化并发）&lt;/a>(第二次孵化)&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/438">JEP 432:向量 API（&lt;/a>第五次孵化）&lt;/li>
&lt;/ul>
&lt;h2 id="jep-429作用域值第一次孵化">
 JEP 429：作用域值（第一次孵化）
 &lt;a class="anchor" href="#jep-429%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%80%bc%e7%ac%ac%e4%b8%80%e6%ac%a1%e5%ad%b5%e5%8c%96">#&lt;/a>
&lt;/h2>
&lt;p>作用域值（Scoped Values）它可以在线程内和线程间共享不可变的数据，优于线程局部变量，尤其是在使用大量虚拟线程时。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ScopedValue&lt;span style="color:#f92672">&amp;lt;&lt;/span>...&lt;span style="color:#f92672">&amp;gt;&lt;/span> V &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ScopedValue&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// In some method&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ScopedValue.&lt;span style="color:#a6e22e">where&lt;/span>(V, &lt;span style="color:#f92672">&amp;lt;&lt;/span>value&lt;span style="color:#f92672">&amp;gt;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">run&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> { ... V.&lt;span style="color:#a6e22e">get&lt;/span>() ... call methods ... });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// In a method called directly or indirectly from the lambda expression&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>... V.&lt;span style="color:#a6e22e">get&lt;/span>() ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>作用域值允许在大型程序中的组件之间安全有效地共享数据，而无需求助于方法参数。&lt;/p></description></item><item><title>Java 21 新特性概览(重要)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java21/</guid><description>&lt;p>JDK 21 于 2023 年 9 月 19 日 发布，这是一个非常重要的版本，里程碑式。&lt;/p>
&lt;p>JDK21 是 LTS（长期支持版），至此为止，目前有 JDK8、JDK11、JDK17 和 JDK21 这四个长期支持版了。&lt;/p>
&lt;p>JDK 21 共有 15 个新特性，这篇文章会挑选其中较为重要的一些新特性进行详细介绍：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/430">JEP 430：String Templates（字符串模板）&lt;/a>（预览）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/431">JEP 431：Sequenced Collections（序列化集合）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/439">JEP 439：Generational ZGC（分代 ZGC）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/440">JEP 440：Record Patterns（记录模式）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/442">JEP 441：Pattern Matching for switch（switch 的模式匹配）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/442">JEP 442：Foreign Function &amp;amp; Memory API（外部函数和内存 API）&lt;/a>（第三次预览）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/443">JEP 443：Unnamed Patterns and Variables（未命名模式和变量&lt;/a>（预览）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/444">JEP 444：Virtual Threads（虚拟线程）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/445">JEP 445：Unnamed Classes and Instance Main Methods（未命名类和实例 main 方法 ）&lt;/a>（预览）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="jep-430字符串模板预览">
 JEP 430：字符串模板（预览）
 &lt;a class="anchor" href="#jep-430%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%a8%a1%e6%9d%bf%e9%a2%84%e8%a7%88">#&lt;/a>
&lt;/h2>
&lt;p>String Templates(字符串模板) 目前仍然是 JDK 21 中的一个预览功能。&lt;/p></description></item><item><title>Java 22 &amp; 23 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java22-23/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java22-23/</guid><description>&lt;p>JDK 23 和 JDK 22 一样，这也是一个非 LTS（长期支持）版本，Oracle 仅提供六个月的支持。下一个长期支持版是 JDK 25，预计明年 9 月份发布。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/new-features/jdk8~jdk24.png" alt="" />&lt;/p>
&lt;p>由于 JDK 22 和 JDK 23 重合的新特性较多，这里主要以 JDK 23 为主介绍，会补充 JDK 22 独有的一些特性。&lt;/p>
&lt;p>JDK 23 一共有 12 个新特性：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.org/jeps/455">JEP 455: 模式中的原始类型、instanceof 和 switch（预览）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/466">JEP 456: 类文件 API（第二次预览）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/467">JEP 467：Markdown 文档注释&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/469">JEP 469：向量 API（第八次孵化）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/473">JEP 473：流收集器（第二次预览）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/471">JEP 471：弃用 sun.misc.Unsafe 中的内存访问方法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/474">JEP 474：ZGC：默认的分代模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/476">JEP 476：模块导入声明 (预览)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/477">JEP 477：未命名类和实例 main 方法 （第三次预览）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/480">JEP 480：结构化并发 （第三次预览）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/481">JEP 481： 作用域值 （第三次预览）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/482">JEP 482：灵活的构造函数体（第二次预览）&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>JDK 22 的新特性如下：&lt;/p></description></item><item><title>Java 9 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java9/</guid><description>&lt;p>&lt;strong>Java 9&lt;/strong> 发布于 2017 年 9 月 21 日 。作为 Java 8 之后 3 年半才发布的新版本，Java 9 带来了很多重大的变化其中最重要的改动是 Java 平台模块系统的引入，其他还有诸如集合、&lt;code>Stream&lt;/code> 流……。&lt;/p>
&lt;p>你可以在 &lt;a href="http://jdk.java.net/archive/">Archived OpenJDK General-Availability Releases&lt;/a> 上下载自己需要的 JDK 版本！官方的新特性说明文档地址：&lt;a href="https://openjdk.java.net/projects/jdk/">https://openjdk.java.net/projects/jdk/&lt;/a> 。&lt;/p>
&lt;p>&lt;strong>概览（精选了一部分）&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/222">JEP 222: Java 命令行工具&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/261">JEP 261: 模块化系统&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/248">JEP 248：G1 成为默认垃圾回收器&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/193">JEP 193: 变量句柄&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/254">JEP 254：字符串存储结构优化&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="jshell">
 JShell
 &lt;a class="anchor" href="#jshell">#&lt;/a>
&lt;/h2>
&lt;p>JShell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。&lt;/p>
&lt;p>在 JShell 中可以直接输入表达式并查看其执行结果。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/java-guide-blog/image-20210816083417616.png" alt="" />&lt;/p>
&lt;p>&lt;strong>JShell 为我们带来了哪些好处呢？&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>降低了输出第一行 Java 版&amp;quot;Hello World！&amp;ldquo;的门槛，能够提高新手的学习热情。&lt;/li>
&lt;li>在处理简单的小逻辑，验证简单的小问题时，比 IDE 更有效率（并不是为了取代 IDE，对于复杂逻辑的验证，IDE 更合适，两者互补）。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>JShell 的代码和普通的可编译代码，有什么不一样？&lt;/strong>&lt;/p></description></item><item><title>Java8 新特性实战</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java8-common-new-features/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java8-common-new-features/</guid><description>&lt;blockquote>
&lt;p>本文来自&lt;a href="https://github.com/cowbi">cowbi&lt;/a>的投稿~&lt;/p>
&lt;/blockquote>
&lt;p>Oracle 于 2014 发布了 Java8（jdk1.8），诸多原因使它成为目前市场上使用最多的 jdk 版本。虽然发布距今已将近 7 年，但很多程序员对其新特性还是不够了解，尤其是用惯了 Java8 之前版本的老程序员，比如我。&lt;/p>
&lt;p>为了不脱离队伍太远，还是有必要对这些新特性做一些总结梳理。它较 jdk.7 有很多变化或者说是优化，比如 interface 里可以有静态方法，并且可以有方法体，这一点就颠覆了之前的认知；&lt;code>java.util.HashMap&lt;/code> 数据结构里增加了红黑树；还有众所周知的 Lambda 表达式等等。本文不能把所有的新特性都给大家一一分享，只列出比较常用的新特性给大家做详细讲解。更多相关内容请看&lt;a href="https://www.oracle.com/java/technologies/javase/8-whats-new.html">官网关于 Java8 的新特性的介绍&lt;/a>。&lt;/p>
&lt;h2 id="interface">
 Interface
 &lt;a class="anchor" href="#interface">#&lt;/a>
&lt;/h2>
&lt;p>interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。&lt;/p>
&lt;p>为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用&lt;code>default&lt;/code> 或 &lt;code>static&lt;/code>修饰，这样就可以有方法体，实现类也不必重写此方法。&lt;/p>
&lt;p>一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。&lt;/p>
&lt;ol>
&lt;li>&lt;code>default&lt;/code>修饰的方法，是普通实例方法，可以用&lt;code>this&lt;/code>调用，可以被子类继承、重写。&lt;/li>
&lt;li>&lt;code>static&lt;/code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用&lt;code>Interface&lt;/code>调用。&lt;/li>
&lt;/ol>
&lt;p>我们来看一个实际的例子。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">InterfaceNew&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sm&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;interface提供的方式实现&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sm2&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;interface提供的方式实现&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">def&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;interface default方法&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">def2&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;interface default2方法&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//须要实现类重写&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">InterfaceNew1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">def&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;InterfaceNew1 default方法&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果有一个类既实现了 &lt;code>InterfaceNew&lt;/code> 接口又实现了 &lt;code>InterfaceNew1&lt;/code>接口，它们都有&lt;code>def()&lt;/code>，并且 &lt;code>InterfaceNew&lt;/code> 接口和 &lt;code>InterfaceNew1&lt;/code>接口没有继承关系的话，这时就必须重写&lt;code>def()&lt;/code>。不然的话，编译的时候就会报错。&lt;/p></description></item></channel></rss>