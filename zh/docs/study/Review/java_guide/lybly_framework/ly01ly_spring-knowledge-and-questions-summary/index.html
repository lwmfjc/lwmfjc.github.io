<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="spring 常见面试题总结"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://lwmfjc.github.io/zh/docs/study/Review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/"><meta property="og:site_name" content="随记"><meta property="og:title" content="spring 常见面试题总结"><meta property="og:description" content="spring 常见面试题总结"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2023-02-07T16:48:03+00:00"><meta property="article:modified_time" content="2023-02-07T16:48:03+00:00"><meta property="article:tag" content="复习"><meta property="article:tag" content="复习-JavaGuide"><meta property="article:tag" content="复习-JavaGuide-Framwork"><title>spring 常见面试题总结 | 随记</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://lwmfjc.github.io/zh/docs/study/Review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/><link rel=stylesheet href=/book.min.df5258082308c980f7c1e2616d3bcfcbc30dcb904a4584f85497470ed94719ef.css integrity="sha256-31JYCCMIyYD3weJhbTvPy8MNy5BKRYT4VJdHDtlHGe8=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.d0391905ca3b0118a3b4ea6a32a593946d4e28addc75e4f4434e4c7e6faab024.js integrity="sha256-0DkZBco7ARijtOpqMqWTlG1OKK3cdeT0Q05Mfm+qsCQ=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>随记</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><a href=/zh/docs/study/>学习</a><ul><li><input type=checkbox id=section-fd75fda6ddedeca6270faa2a090fbd09 class=toggle>
<label for=section-fd75fda6ddedeca6270faa2a090fbd09 class="flex justify-between"><a role=button>Hugo</a></label><ul><li><input type=checkbox id=section-f176cb78c200d3e788c5fc25ba95cff0 class=toggle>
<label for=section-f176cb78c200d3e788c5fc25ba95cff0 class="flex justify-between"><a role=button>主题</a></label><ul><li><a href=/zh/docs/study/Hugo/themes/PaperMod/01/>使用PaperMode</a></li></ul></li><li><input type=checkbox id=section-cb73ca50a9c696c8c3f564058ac4ec6c class=toggle>
<label for=section-cb73ca50a9c696c8c3f564058ac4ec6c class="flex justify-between"><a role=button>基础(Giraffe学院)_</a></label><ul><li><a href=/zh/docs/study/Hugo/GiraffeAcademy/advanced20-23/>hugo进阶学习20-23</a></li><li><a href=/zh/docs/study/Hugo/GiraffeAcademy/advanced17-19/>hugo进阶学习17-19</a></li><li><a href=/zh/docs/study/Hugo/GiraffeAcademy/advanced11-16/>hugo进阶学习11-15</a></li><li><a href=/zh/docs/study/Hugo/GiraffeAcademy/advanced01-10/>hugo进阶学习01-10</a></li></ul></li></ul></li><li><input type=checkbox id=section-2b0e263d8cf05e7ab2c51ff467e920e3 class=toggle>
<label for=section-2b0e263d8cf05e7ab2c51ff467e920e3 class="flex justify-between"><a role=button>Obsidian</a></label><ul><li><a href=/zh/docs/study/Obsidian/border-theme/>border-theme背景图片问题</a></li><li><a href=/zh/docs/study/Obsidian/obsidian-theme/>obsidian-theme</a></li><li><a href=/zh/docs/study/Obsidian/plugin/>plugin</a></li></ul></li><li><input type=checkbox id=section-a714da7fce329f357b616b7d5f234850 class=toggle>
<label for=section-a714da7fce329f357b616b7d5f234850 class="flex justify-between"><a role=button>Redis</a></label><ul><li><input type=checkbox id=section-5b5b9277ea3f4251d87a520f0c84cbf4 class=toggle>
<label for=section-5b5b9277ea3f4251d87a520f0c84cbf4 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/study/Redis/shangguigu_BV1Rv41177Af/19-A/>redis_尚硅谷_19-A</a></li><li><a href=/zh/docs/study/Redis/shangguigu_BV1Rv41177Af/18/>redis_尚硅谷_18</a></li><li><a href=/zh/docs/study/Redis/shangguigu_BV1Rv41177Af/12-17/>redis_尚硅谷_12-17</a></li><li><a href=/zh/docs/study/Redis/shangguigu_BV1Rv41177Af/06-11/>redis_尚硅谷_06-11</a></li><li><a href=/zh/docs/study/Redis/shangguigu_BV1Rv41177Af/01-05/>redis_尚硅谷_01-05</a></li></ul></li><li><a href=/zh/docs/study/Redis/rsync-use/>rsync使用</a></li><li><a href=/zh/docs/study/Redis/redis-cluster/>redis集群搭建</a></li></ul></li><li><input type=checkbox id=section-c83d73a2400545be3875d0afb3f2fd91 class=toggle>
<label for=section-c83d73a2400545be3875d0afb3f2fd91 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><input type=checkbox id=section-57e35594e8b43cd733f28923af12d22e class=toggle>
<label for=section-57e35594e8b43cd733f28923af12d22e class="flex justify-between"><a role=button>_深入理解Java虚拟机_</a></label><ul><li><a href=/zh/docs/study/JVM/understanding_the_jvm/03/>03垃圾收集器与内存分配策略</a></li></ul></li></ul></li><li><input type=checkbox id=section-9eff9a58132221bb687f875fa61fe9a9 class=toggle>
<label for=section-9eff9a58132221bb687f875fa61fe9a9 class="flex justify-between"><a role=button>My SQL</a></label><ul><li><input type=checkbox id=section-e91776bd3cf21fcb096b9943bca44d6d class=toggle>
<label for=section-e91776bd3cf21fcb096b9943bca44d6d class="flex justify-between"><a role=button>_MySQL是怎样运行的_</a></label><ul><li><a href=/zh/docs/study/MySQL/how_mysql_run/07/>07B+数索引的使用</a></li><li><a href=/zh/docs/study/MySQL/how_mysql_run/06/>06B+树索引</a></li><li><a href=/zh/docs/study/MySQL/how_mysql_run/05/>05InnoDB数据页结构</a></li><li><a href=/zh/docs/study/MySQL/how_mysql_run/04/>04InnoDB记录存储结构</a></li><li><a href=/zh/docs/study/MySQL/how_mysql_run/03/>03字符集和比较规则</a></li><li><a href=/zh/docs/study/MySQL/how_mysql_run/02/>02启动选项和系统变量</a></li><li><a href=/zh/docs/study/MySQL/how_mysql_run/01/>01初识MySQL</a></li></ul></li><li><input type=checkbox id=section-c87a76b0bfcac21a80f3375f9173b3f0 class=toggle>
<label for=section-c87a76b0bfcac21a80f3375f9173b3f0 class="flex justify-between"><a role=button>进阶(尚硅谷)_</a></label><ul><li><a href=/zh/docs/study/MySQL/bl_sgg/96-00/>mysql高阶_sgg 96-00</a></li></ul></li></ul></li><li><input type=checkbox id=section-e918ce4e8e11c555633656bf3673abd5 class=toggle>
<label for=section-e918ce4e8e11c555633656bf3673abd5 class="flex justify-between"><a role=button>其他</a></label><ul><li><a href=/zh/docs/study/Other/kaoshi/>科目</a></li><li><a href=/zh/docs/study/Other/pc_base/>电脑基础操作</a></li></ul></li><li><input type=checkbox id=section-83aeee70aec240ca35bd686808937b1a class=toggle>
<label for=section-83aeee70aec240ca35bd686808937b1a class="flex justify-between"><a role=button>Linux</a></label><ul><li><input type=checkbox id=section-39ea8024e0c1ad98023f9d8487bbf7ec class=toggle>
<label for=section-39ea8024e0c1ad98023f9d8487bbf7ec class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/study/Linux/base/base/>一些基本操作</a></li><li><a href=/zh/docs/study/Linux/base/create_clone/>vmware上linux主机的安装和克隆</a></li></ul></li><li><input type=checkbox id=section-714e8f2f35635f446effd8519da2bfdd class=toggle>
<label for=section-714e8f2f35635f446effd8519da2bfdd class="flex justify-between"><a role=button>韩顺平老师_</a></label><ul><li><a href=/zh/docs/study/Linux/hanshunping/52-x/>52-X</a></li><li><a href=/zh/docs/study/Linux/hanshunping/40-51/>linux_韩老师_40-51</a></li><li><a href=/zh/docs/study/Linux/hanshunping/28-39/>linux_韩老师_28-39</a></li><li><a href=/zh/docs/study/Linux/hanshunping/21-27/>linux_韩老师_21-33</a></li><li><a href=/zh/docs/study/Linux/hanshunping/12-20/>linux_韩老师_12-20</a></li><li><a href=/zh/docs/study/Linux/hanshunping/07-11/>linux_韩老师_07-11</a></li><li><a href=/zh/docs/study/Linux/hanshunping/01-06/>linux_韩老师_01-06</a></li></ul></li></ul></li><li><input type=checkbox id=section-8c517b8c8e7ec17aabed4f7dc85c6426 class=toggle checked>
<label for=section-8c517b8c8e7ec17aabed4f7dc85c6426 class="flex justify-between"><a href=/zh/docs/study/Review/>面试</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/>JavaGuide</a><ul><li><input type=checkbox id=section-d6319e5eae5aa8099a3135817b5bf06d class=toggle>
<label for=section-d6319e5eae5aa8099a3135817b5bf06d class="flex justify-between"><a role=button>数据库</a></label><ul><li><input type=checkbox id=section-4c137a1896506676da89b70079d7249f class=toggle>
<label for=section-4c137a1896506676da89b70079d7249f class="flex justify-between"><a role=button>MySQL</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/database/MySQL/ly0606lymysql-query-execution-plan/>mysql执行计划</a></li><li><a href=/zh/docs/study/Review/java_guide/database/MySQL/ly0611lymysql-high-performance-optimization-specification-recommendations/>MySQL高性能优化规范建议总结</a></li><li><a href=/zh/docs/study/Review/java_guide/database/MySQL/ly0610lymysql-questions-01/>MySQL常见面试题总结</a></li><li><a href=/zh/docs/study/Review/java_guide/database/MySQL/ly0609lyindex-invalidation-caused-by-implicit-conversion/>MySQL中的隐式转换造成的索引失效</a></li><li><a href=/zh/docs/study/Review/java_guide/database/MySQL/ly0608lysome-thoughts-on-database-storage-time/>MySQL数据库时间类型数据存储建议</a></li><li><a href=/zh/docs/study/Review/java_guide/database/MySQL/ly0605lyhow-sql-executed-in-mysql/>SQL语句在MySQL中的执行过程</a></li><li><a href=/zh/docs/study/Review/java_guide/database/MySQL/ly0604lyinnodb-implementation-of-mvcc/>innodb引擎对MVCC的实现</a></li><li><a href=/zh/docs/study/Review/java_guide/database/MySQL/ly0603lytransaction-isolation-level/>MySQL事务隔离级别详解</a></li><li><a href=/zh/docs/study/Review/java_guide/database/MySQL/ly0602lymysql-logs/>日志</a></li><li><a href=/zh/docs/study/Review/java_guide/database/MySQL/ly0601lymysql-index/>索引</a></li></ul></li><li><input type=checkbox id=section-84326e7a14b99ea9ebc88f68f3733711 class=toggle>
<label for=section-84326e7a14b99ea9ebc88f68f3733711 class="flex justify-between"><a role=button>Redis</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/database/Redis/diagram/>redis问题图解</a></li><li><a href=/zh/docs/study/Review/java_guide/database/Redis/ly0703ly3-commonly-used-cache-read-and-write-strategies/>3种常用的缓存读写策略详解</a></li><li><a href=/zh/docs/study/Review/java_guide/database/Redis/ly0704lyredis-memory-fragmentation/>redis内存碎片</a></li><li><a href=/zh/docs/study/Review/java_guide/database/Redis/ly0702lyredis-spec-data-structure/>redis特殊数据结构</a></li><li><a href=/zh/docs/study/Review/java_guide/database/Redis/ly0701lyredis-base-data-structures/>redis基本数据结构</a></li><li><a href=/zh/docs/study/Review/java_guide/database/Redis/ly0706lyredis-questions-02/>redis面试题02</a></li><li><a href=/zh/docs/study/Review/java_guide/database/Redis/ly0705lyredis-questions-01/>redis面试题01</a></li></ul></li><li><a href=/zh/docs/study/Review/java_guide/database/ly0503lysql-question-01/>sql常见面试题总结01</a></li><li><a href=/zh/docs/study/Review/java_guide/database/ly0504lysql-syntax-summary/>sql语法基础知识总结</a></li><li><a href=/zh/docs/study/Review/java_guide/database/ly0502lycharactor-set/>字符集详解</a></li><li><a href=/zh/docs/study/Review/java_guide/database/ly0501lybasis/>数据库基础</a></li></ul></li><li><input type=checkbox id=section-3080fd07026c22a39ade6aacd29eaf2c class=toggle>
<label for=section-3080fd07026c22a39ade6aacd29eaf2c class="flex justify-between"><a role=button>系统设计</a></label><ul><li><input type=checkbox id=section-9e386a7bd99ff41a97acbbc6230d43ef class=toggle>
<label for=section-9e386a7bd99ff41a97acbbc6230d43ef class="flex justify-between"><a role=button>安全</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/lycly_system-design/security/ly06ly_sentive-words-filter/>敏感词过滤方案总结</a></li><li><a href=/zh/docs/study/Review/java_guide/lycly_system-design/security/ly05ly_design-of-authority-system/>权限系统设计详解</a></li><li><a href=/zh/docs/study/Review/java_guide/lycly_system-design/security/ly04ly_sso-intro/>sso单点登录</a></li><li><a href=/zh/docs/study/Review/java_guide/lycly_system-design/security/ly03ly_jwt-advantages-disadvantages/>jwt身份认证优缺点</a></li><li><a href=/zh/docs/study/Review/java_guide/lycly_system-design/security/ly02ly_jwt-intro/>jwt-intro</a></li><li><a href=/zh/docs/study/Review/java_guide/lycly_system-design/security/ly01ly_basis-of-authority-certification/>认证授权基础概念详解</a></li></ul></li><li><input type=checkbox id=section-556e555ecfa7acbb04e736a42f7f3001 class=toggle>
<label for=section-556e555ecfa7acbb04e736a42f7f3001 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/lycly_system-design/basis/unit-test/>单元测试</a></li><li><a href=/zh/docs/study/Review/java_guide/lycly_system-design/basis/refactoring/>代码重构指南</a></li><li><a href=/zh/docs/study/Review/java_guide/lycly_system-design/basis/naming/>代码命名指南</a></li><li><a href=/zh/docs/study/Review/java_guide/lycly_system-design/basis/software-engineering/>软件工程简明教程</a></li><li><a href=/zh/docs/study/Review/java_guide/lycly_system-design/basis/restful/>restFul</a></li></ul></li><li><a href=/zh/docs/study/Review/java_guide/lycly_system-design/web-real-time-message-push/>web-real-time-message-push</a></li><li><a href=/zh/docs/study/Review/java_guide/lycly_system-design/schedule-task/>Java定时任务详解</a></li></ul></li><li><input type=checkbox id=section-ae23cb29521989d02444c3d00e52a937 class=toggle>
<label for=section-ae23cb29521989d02444c3d00e52a937 class="flex justify-between"><a role=button>高可用</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/lyfly_high-availability/ly05ly_performance-test/>性能测试入门</a></li><li><a href=/zh/docs/study/Review/java_guide/lyfly_high-availability/ly04ly_timout-and-retry/>超时&重试详解</a></li><li><a href=/zh/docs/study/Review/java_guide/lyfly_high-availability/ly03ly_limit-request/>服务限流详解</a></li><li><a href=/zh/docs/study/Review/java_guide/lyfly_high-availability/ly02ly_redundancy/>冗余设计</a></li><li><a href=/zh/docs/study/Review/java_guide/lyfly_high-availability/ly01ly_high-availability-system-design/>高可用系统设计指南</a></li></ul></li><li><input type=checkbox id=section-f50893813e38e679c177ecae34f1a27e class=toggle>
<label for=section-f50893813e38e679c177ecae34f1a27e class="flex justify-between"><a role=button>高性能</a></label><ul><li><input type=checkbox id=section-a27e08cfa2f92d9ae27ba84a2dd38f17 class=toggle>
<label for=section-a27e08cfa2f92d9ae27ba84a2dd38f17 class="flex justify-between"><a role=button>RocketMQ</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/lyely_high-performance/message-mq/rocketmq-questions/>rocketmq常见面试题</a></li><li><a href=/zh/docs/study/Review/java_guide/lyely_high-performance/message-mq/rocketmq-intro/>rocketmq介绍</a></li><li><a href=/zh/docs/study/Review/java_guide/lyely_high-performance/message-mq/base/>message-queue</a></li></ul></li><li><a href=/zh/docs/study/Review/java_guide/lyely_high-performance/ly02ly_cdn/>cdn</a></li><li><a href=/zh/docs/study/Review/java_guide/lyely_high-performance/ly01ly_read-and-write-separation-and-library-subtable/>数据库读写分离&分库分表详解</a></li></ul></li><li><input type=checkbox id=section-4c03297f9a4ed8c7bc35f591aa8fc226 class=toggle>
<label for=section-4c03297f9a4ed8c7bc35f591aa8fc226 class="flex justify-between"><a role=button>分布式系统</a></label><ul><li><input type=checkbox id=section-83c4eb8f0b3ef0625a7f05bd8a8d28b3 class=toggle>
<label for=section-83c4eb8f0b3ef0625a7f05bd8a8d28b3 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/lydly_distributed_system/base/raft-algorithm/>raft算法</a></li><li><a href=/zh/docs/study/Review/java_guide/lydly_distributed_system/base/paxos-algorithm/>paxos算法</a></li><li><a href=/zh/docs/study/Review/java_guide/lydly_distributed_system/base/cap_base-theorem/>CAP&amp;BASE 理论</a></li></ul></li><li><a href=/zh/docs/study/Review/java_guide/lydly_distributed_system/ly08ly_zookeeper-in-action/>zookeeper实战</a></li><li><a href=/zh/docs/study/Review/java_guide/lydly_distributed_system/ly07ly_zookeeper-plus/>zookeeper进阶</a></li><li><a href=/zh/docs/study/Review/java_guide/lydly_distributed_system/ly06ly_zookeeper-intro/>zookeeper介绍</a></li><li><a href=/zh/docs/study/Review/java_guide/lydly_distributed_system/ly04ly_rpc-http/>rpc_http</a></li><li><a href=/zh/docs/study/Review/java_guide/lydly_distributed_system/ly05ly_rpc-intro/>rpc基础及面试题</a></li><li><a href=/zh/docs/study/Review/java_guide/lydly_distributed_system/ly03ly_distributed-lock/>分布式锁</a></li><li><a href=/zh/docs/study/Review/java_guide/lydly_distributed_system/ly02ly_distributed-id/>分布式id</a></li><li><a href=/zh/docs/study/Review/java_guide/lydly_distributed_system/ly01ly_api-gateway/>api网关</a></li></ul></li><li><input type=checkbox id=section-c3336974516ca80b5640a7af943ec384 class=toggle checked>
<label for=section-c3336974516ca80b5640a7af943ec384 class="flex justify-between"><a role=button>框架</a></label><ul><li><input type=checkbox id=section-9162143365abe5a5a696ff6590fcb0c9 class=toggle>
<label for=section-9162143365abe5a5a696ff6590fcb0c9 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><input type=checkbox id=section-93ec1f924030fc8b96f90f85c9564c9b class=toggle>
<label for=section-93ec1f924030fc8b96f90f85c9564c9b class="flex justify-between"><a role=button>原理</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle3/>Mybatis原理系列(3)</a></li><li><a href=/zh/docs/study/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle2/>Mybatis原理系列(2)</a></li><li><a href=/zh/docs/study/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle1/>Mybatis原理系列(1)</a></li></ul></li><li><a href=/zh/docs/study/Review/java_guide/lybly_framework/MyBatis/MyBatis-interview/>Mybatis面试</a></li></ul></li><li><a href=/zh/docs/study/Review/java_guide/lybly_framework/conditional_on_class/>ConditionalOnClass实践</a></li><li><a href=/zh/docs/study/Review/java_guide/lybly_framework/ly05ly_springboot-auto-assembly/>SpringBoot自动装配原理</a></li><li><a href=/zh/docs/study/Review/java_guide/lybly_framework/ly04ly_spring-design-patterns/>spring 设计模式</a></li><li><a href=/zh/docs/study/Review/java_guide/lybly_framework/ly03ly_spring-transaction/>Spring事务详情</a></li><li><a href=/zh/docs/study/Review/java_guide/lybly_framework/ly02ly_spring-annotations/>Spring/SpringBoot常用注解</a></li><li><a href=/zh/docs/study/Review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/ class=active>spring 常见面试题总结</a></li></ul></li><li><input type=checkbox id=section-fbef796229916e4df4698183d83c9953 class=toggle>
<label for=section-fbef796229916e4df4698183d83c9953 class="flex justify-between"><a role=button>开发工具</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/lyaly_dev_tools/git/>git</a></li><li><a href=/zh/docs/study/Review/java_guide/lyaly_dev_tools/maven/>maven</a></li></ul></li><li><input type=checkbox id=section-51f0bd0d4b9747a4320b657876e50a2a class=toggle>
<label for=section-51f0bd0d4b9747a4320b657876e50a2a class="flex justify-between"><a role=button>Java基础</a></label><ul><li><input type=checkbox id=section-8929c4e1656ba567b0ed32f879a924e1 class=toggle>
<label for=section-8929c4e1656ba567b0ed32f879a924e1 class="flex justify-between"><a role=button>并发</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly030301lyatomicpre/>Atomic预备知识</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly0311lycompletablefuture-intro/>completablefuture-intro</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly0310lythreadlocal/>ThreadLocal详解</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly0309lyatomic-classes/>Atomic原子类介绍</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly0308lyaqs-details/>aqs详解</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly0307lyconcurrent-collections/>java常见并发容器</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly0306lythread-pool-best/>线程池最佳实践</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly0305lyjava-thread-pool/>java线程池详解</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly0304lyjmm/>java内存模型</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly0303lyconcurrent-03/>并发03</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly03122lylock_escalation/>锁升级</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/lock_escalation_deprecated2/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/lock_escalation_deprecated/>(该文弃用)锁升级</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly03121lyobject-concurrent/>对象内存布局和对象头</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly0302lyconcurrent-02/>并发02</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Concurrent/ly0301lyconcurrent-01/>并发01</a></li></ul></li><li><input type=checkbox id=section-920b9658698076c9f159f562698bad91 class=toggle>
<label for=section-920b9658698076c9f159f562698bad91 class="flex justify-between"><a role=button>IO</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/java/IO/ly0203lyio-model/>io模型</a></li><li><a href=/zh/docs/study/Review/java_guide/java/IO/ly0202lyio-design-patterns/>io设计模式</a></li><li><a href=/zh/docs/study/Review/java_guide/java/IO/ly0201lyio/>io基础</a></li></ul></li><li><input type=checkbox id=section-6c7234e672853aca4bcf751fbf1cba97 class=toggle>
<label for=section-6c7234e672853aca4bcf751fbf1cba97 class="flex justify-between"><a role=button>集合</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/java/Collection/ly0105lysource-code-concurrenthashmap/>ConcurrentHashMap源码</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Collection/ly0106lysource-code-hashmap/>HashMap源码</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Collection/ly0104lysource-code-ArrayList/>ArrayList源码</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Collection/ly0103lycollections-precautions-for-use/>集合使用注意事项</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Collection/ly0102lycollection_2/>集合_2</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Collection/ly0101lycollection_1/>集合_1</a></li></ul></li><li><input type=checkbox id=section-ca1e9ad7baebd6d389d34de78d42a8e2 class=toggle>
<label for=section-ca1e9ad7baebd6d389d34de78d42a8e2 class="flex justify-between"><a role=button>基础</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/java/Basic/ly0011lysyntactic_sugar/>语法糖</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Basic/ly0010lyjava_spi/>java_spi</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Basic/ly0009lyunsafe_class/>unsafe类</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Basic/ly0008lybig_decimal/>big_decimal</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Basic/ly0007lyproxy_pattern/>Java代理模式</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Basic/ly0006lyreflex/>java-reflex</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Basic/ly0005lyserialize/>Java序列化详解</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Basic/ly0004lypassbyvalue/>为什么Java中只有值传递</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Basic/ly0003lyjava_guide_basic_3/>javaGuide基础3</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Basic/ly0002lyjava_guide_basic_2/>javaGuide基础2</a></li><li><a href=/zh/docs/study/Review/java_guide/java/Basic/ly0001lyjava_guide_basic_1/>javaGuide基础1</a></li></ul></li><li><a href=/zh/docs/study/Review/java_guide/java/JVM/ly0408lyjdk-monitoring-and-troubleshooting-tools/>jvm监控和故障处理工具 总结</a></li><li><a href=/zh/docs/study/Review/java_guide/java/JVM/ly0406lyjvm-params/>jvm参数</a></li><li><a href=/zh/docs/study/Review/java_guide/java/JVM/ly0403lyclass-structure/>类文件结构</a></li><li><a href=/zh/docs/study/Review/java_guide/java/JVM/ly0405lyclassloader-detail/>类加载器详解</a></li><li><a href=/zh/docs/study/Review/java_guide/java/JVM/ly0404lyclassloader-process/>类加载过程</a></li><li><a href=/zh/docs/study/Review/java_guide/java/JVM/ly0402lygarbage-collection/>java垃圾回收</a></li><li><a href=/zh/docs/study/Review/java_guide/java/JVM/ly0407lyjvm-intro/>jvm-intro</a></li><li><a href=/zh/docs/study/Review/java_guide/java/JVM/ly0401lymemory-area/>memory-area</a></li></ul></li><li><input type=checkbox id=section-54223f76779f3f77f73a99061edd2c6a class=toggle>
<label for=section-54223f76779f3f77f73a99061edd2c6a class="flex justify-between"><a role=button>计算机基础</a></label><ul><li><input type=checkbox id=section-fb9728ac5d825bd60e8ee7cdceda4589 class=toggle>
<label for=section-fb9728ac5d825bd60e8ee7cdceda4589 class="flex justify-between"><a role=button>数据结构</a></label><ul><li><a href=/zh/docs/study/Review/java_guide/cs_basics/data-structure/tree/>树</a></li><li><a href=/zh/docs/study/Review/java_guide/cs_basics/data-structure/heap/>堆</a></li><li><a href=/zh/docs/study/Review/java_guide/cs_basics/data-structure/graph/>图</a></li><li><a href=/zh/docs/study/Review/java_guide/cs_basics/data-structure/linear-data-structure/>线性数据结构</a></li></ul></li></ul></li></ul></li><li><input type=checkbox id=section-54e1681af4f04c855109fc198a492569 class=toggle>
<label for=section-54e1681af4f04c855109fc198a492569 class="flex justify-between"><a role=button>Ssm</a></label><ul><li><a href=/zh/docs/study/Review/ssm/scope_transaction/>作用域及事务</a></li></ul></li><li><input type=checkbox id=section-4622fe029440577cf4d9dc756a00f7fd class=toggle>
<label for=section-4622fe029440577cf4d9dc756a00f7fd class="flex justify-between"><a role=button>Java基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/study/Review/basics/member_variables_and_local_variables/>成员变量与局部变量</a></li><li><a href=/zh/docs/study/Review/basics/recursion_and_iteration/>递归与迭代</a></li><li><a href=/zh/docs/study/Review/basics/method_parameter_passing_mechanism/>方法的参数传递机制</a></li><li><a href=/zh/docs/study/Review/basics/class_and_instance_initialization/>类、实例初始化</a></li><li><a href=/zh/docs/study/Review/basics/singleton_design_pattern/>单例设计模式</a></li><li><a href=/zh/docs/study/Review/basics/self_incrementing_variable/>自增变量</a></li></ul></li></ul></li><li><input type=checkbox id=section-b787d79f211ff564578abf3da0f5725d class=toggle>
<label for=section-b787d79f211ff564578abf3da0f5725d class="flex justify-between"><a role=button>SpringCloud</a></label><ul><li><input type=checkbox id=section-38cb2803d20f765819348442d5afdcac class=toggle>
<label for=section-38cb2803d20f765819348442d5afdcac class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/study/springCloud/bl_zhouyang/base/>基础</a></li></ul></li></ul></li><li><input type=checkbox id=section-4e973aa0b3ae2b53d309580eec822705 class=toggle>
<label for=section-4e973aa0b3ae2b53d309580eec822705 class="flex justify-between"><a role=button>Git</a></label><ul><li><input type=checkbox id=section-fde7cd3305a51d970d67828fe5792947 class=toggle>
<label for=section-fde7cd3305a51d970d67828fe5792947 class="flex justify-between"><a role=button>基础(尚硅谷视频)_</a></label><ul><li><a href=/zh/docs/study/Git/git_sgg/19-26/>19-26_git_尚硅谷</a></li><li><a href=/zh/docs/study/Git/git_sgg/09-18/>09-18_git_尚硅谷</a></li><li><a href=/zh/docs/study/Git/git_sgg/01-08/>01-08_git_尚硅谷</a></li></ul></li></ul></li><li><input type=checkbox id=section-f70c9af640cbf446eff0cbe3f95fc774 class=toggle>
<label for=section-f70c9af640cbf446eff0cbe3f95fc774 class="flex justify-between"><a role=button>Maven</a></label><ul><li><input type=checkbox id=section-206b7385f3b00976ae05df420146f283 class=toggle>
<label for=section-206b7385f3b00976ae05df420146f283 class="flex justify-between"><a role=button>进阶(动力节点)_</a></label><ul><li><a href=/zh/docs/study/Maven/advance_dljd/01-21/>01-21 maven多模块管理_动力节点</a></li></ul></li><li><input type=checkbox id=section-138f029d3c6b092429e2d094f2351f0b class=toggle>
<label for=section-138f029d3c6b092429e2d094f2351f0b class="flex justify-between"><a role=button>基础(动力节点)_</a></label><ul><li><a href=/zh/docs/study/Maven/base_dljd/31-43/>31-43 maven基础_动力节点</a></li><li><a href=/zh/docs/study/Maven/base_dljd/17-30/>17-30 maven基础_动力节点</a></li><li><a href=/zh/docs/study/Maven/base_dljd/01-16/>01-16 maven基础_动力节点</a></li></ul></li></ul></li><li><input type=checkbox id=section-696ea79ca856b53017b595edd2cd287b class=toggle>
<label for=section-696ea79ca856b53017b595edd2cd287b class="flex justify-between"><a role=button>算法</a></label><ul><li><input type=checkbox id=section-8c80783279a4135d2c2ca780be49becf class=toggle>
<label for=section-8c80783279a4135d2c2ca780be49becf class="flex justify-between"><a role=button>_算法(第四版)_</a></label><ul><li><a href=/zh/docs/study/Algorithm/algorithhms_4th/3.2.1/>算法红皮书 3.2.1</a></li><li><a href=/zh/docs/study/Algorithm/algorithhms_4th/3.1.1-3.1.7/>算法红皮书 3.1.1-3.1.7</a></li><li><a href=/zh/docs/study/Algorithm/algorithhms_4th/2.5/>算法红皮书 2.5</a></li><li><a href=/zh/docs/study/Algorithm/algorithhms_4th/2.4/>算法红皮书 2.4</a></li><li><a href=/zh/docs/study/Algorithm/algorithhms_4th/2.1.2-2.1.3/>算法红皮书 2.1.2-2.1.3</a></li><li><a href=/zh/docs/study/Algorithm/algorithhms_4th/2.1.1/>算法红皮书 2.1.1</a></li><li><a href=/zh/docs/study/Algorithm/algorithhms_4th/1.5.1-1.5.3/>算法红皮书 1.5.1-1.5.3</a></li><li><a href=/zh/docs/study/Algorithm/algorithhms_4th/1.4.1-1.4.10/>算法红皮书 1.4.1-1.4.10</a></li><li><a href=/zh/docs/study/Algorithm/algorithhms_4th/1.3.3.1-1.3.4/>算法红皮书1.3.3.1-1.3.4</a></li><li><a href=/zh/docs/study/Algorithm/algorithhms_4th/1.3.1.1-1.3.2.5/>算法红皮书 1.3.1.1-1.3.2.5</a></li><li><a href=/zh/docs/study/Algorithm/algorithhms_4th/1.2.1-1.2.5/>算法红皮书 1.2.1-1.2.5</a></li><li><a href=/zh/docs/study/Algorithm/algorithhms_4th/1.1.6-1.1.11/>算法红皮书 1.1.6-1.1.11</a></li><li><a href=/zh/docs/study/Algorithm/algorithhms_4th/1.1.1-1.1.5/>算法红皮书 1.1.1-1.1.5</a></li></ul></li></ul></li><li><input type=checkbox id=section-881896b16e61c2cd2e001e4ffad6dffd class=toggle>
<label for=section-881896b16e61c2cd2e001e4ffad6dffd class="flex justify-between"><a role=button>My Batis Plus</a></label><ul><li><input type=checkbox id=section-dd43767cc26afb26a54456c3eb653ab2 class=toggle>
<label for=section-dd43767cc26afb26a54456c3eb653ab2 class="flex justify-between"><a role=button>基础(尚硅谷)_</a></label><ul><li><a href=/zh/docs/study/MyBatis-Plus/bl_sgg/40-57/>mybatis-plus-sgg-40-57</a></li><li><a href=/zh/docs/study/MyBatis-Plus/bl_sgg/19-39/>mybatis-plus-sgg-19-39</a></li><li><a href=/zh/docs/study/MyBatis-Plus/bl_sgg/12-18/>mybatis-plus-sgg-12-18</a></li><li><a href=/zh/docs/study/MyBatis-Plus/bl_sgg/01-11/>mybatis-plus-sgg-01-11</a></li></ul></li><li><a href=/zh/docs/study/MyBatis-Plus/official/hello/>官方的hello-world</a></li></ul></li><li><input type=checkbox id=section-5f534090dc6aa59b8296427329944b0f class=toggle>
<label for=section-5f534090dc6aa59b8296427329944b0f class="flex justify-between"><a role=button>Flowable</a></label><ul><li><input type=checkbox id=section-edc2c35abbd8e6231be16b658a95164a class=toggle>
<label for=section-edc2c35abbd8e6231be16b658a95164a class="flex justify-between"><a role=button>基础(波哥)_</a></label><ul><li><a href=/zh/docs/study/Flowable/boge_blbl/03-others/>boge-03-其他</a></li><li><a href=/zh/docs/study/Flowable/boge_blbl/02-advance_6/>boge-02-flowable进阶_6</a></li><li><a href=/zh/docs/study/Flowable/boge_blbl/02-advance_5/>boge-02-flowable进阶_5</a></li><li><a href=/zh/docs/study/Flowable/boge_blbl/02-advance_4/>boge-02-flowable进阶_4</a></li><li><a href=/zh/docs/study/Flowable/boge_blbl/02-advance_3/>boge-02-flowable进阶_3</a></li><li><a href=/zh/docs/study/Flowable/boge_blbl/02-advance_2/>boge-02-flowable进阶_2</a></li><li><a href=/zh/docs/study/Flowable/boge_blbl/02-advance_1/>boge-02-flowable进阶_1</a></li><li><a href=/zh/docs/study/Flowable/boge_blbl/01-base/>boge-01-flowable基础</a></li></ul></li><li><input type=checkbox id=section-f8a7d597951f0b775acb2320219596e8 class=toggle>
<label for=section-f8a7d597951f0b775acb2320219596e8 class="flex justify-between"><a role=button>官方文档</a></label><ul><li><a href=/zh/docs/study/Flowable/offical/05/>Flowable-05-spring-boot</a></li><li><a href=/zh/docs/study/Flowable/offical/04/>Flowable-04-spring</a></li><li><a href=/zh/docs/study/Flowable/offical/03/>Flowable-03-api</a></li><li><a href=/zh/docs/study/Flowable/offical/02/>Flowable-02-Configuration</a></li><li><a href=/zh/docs/study/Flowable/offical/01/>Flowable-01-GettingStarted</a></li></ul></li><li><a href=/zh/docs/study/Flowable/zsx_design/01/>zsx_flowable_design01</a></li></ul></li><li><input type=checkbox id=section-b1d073fe2cfcc69f40c5ace6d9885d60 class=toggle>
<label for=section-b1d073fe2cfcc69f40c5ace6d9885d60 class="flex justify-between"><a role=button>Rocket Mq</a></label><ul><li><input type=checkbox id=section-8b4b311df7829d9838096c1024c164b5 class=toggle>
<label for=section-8b4b311df7829d9838096c1024c164b5 class="flex justify-between"><a role=button>基础(黑马)_</a></label><ul><li><a href=/zh/docs/study/RocketMQ/heima/05advance/>05高级功能</a></li><li><a href=/zh/docs/study/RocketMQ/heima/04case/>04案例</a></li><li><a href=/zh/docs/study/RocketMQ/heima/03messagetype/>03收发消息</a></li><li><a href=/zh/docs/study/RocketMQ/heima/02buildcluster/>02双主双从集群搭建</a></li><li><a href=/zh/docs/study/RocketMQ/heima/01base/>01rocketmq学习</a></li></ul></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/problem/>问题解决</a><ul><li><input type=checkbox id=section-ab4f1dd893a7409a00858148e98c245c class=toggle>
<label for=section-ab4f1dd893a7409a00858148e98c245c class="flex justify-between"><a role=button>Other</a></label><ul><li><a href=/zh/docs/problem/Other/01/>如何搜索</a></li></ul></li><li><input type=checkbox id=section-ef3324c710f7241c89fc009a5f576fbc class=toggle>
<label for=section-ef3324c710f7241c89fc009a5f576fbc class="flex justify-between"><a role=button>Linux</a></label><ul><li><a href=/zh/docs/problem/Linux/20230919/>Linux操作符问题</a></li><li><a href=/zh/docs/problem/Linux/20230819/>Debian问题处理3</a></li><li><a href=/zh/docs/problem/Linux/20230817/>Debian问题处理2</a></li><li><a href=/zh/docs/problem/Linux/20230815/>Debian问题处理1</a></li><li><a href=/zh/docs/problem/Linux/20230803/>安卓手机及平板安装linuxDeploy的问题简记</a></li><li><a href=/zh/docs/problem/Linux/20230523/>zsh卸载后root无法登录及vm扩容centos7报错处理</a></li><li><a href=/zh/docs/problem/Linux/20221101/>post</a></li></ul></li><li><input type=checkbox id=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class=toggle>
<label for=section-9e8cd5fa8604e5d54ff445fe44d3ca85 class="flex justify-between"><a role=button>Jvm</a></label><ul><li><a href=/zh/docs/problem/JVM/20230526/>JDK代理和CGLIB代理</a></li><li><a href=/zh/docs/problem/JVM/2023052302/>linux中调试open jdk</a></li></ul></li><li><input type=checkbox id=section-a028a45b205904a783d0c60e8a184391 class=toggle>
<label for=section-a028a45b205904a783d0c60e8a184391 class="flex justify-between"><a role=button>Hexo</a></label><ul><li><a href=/zh/docs/problem/Hexo/01/>hexo在线查看pdf</a></li></ul></li><li><input type=checkbox id=section-1c55bf7a5578a7de17cc1ee45681106b class=toggle>
<label for=section-1c55bf7a5578a7de17cc1ee45681106b class="flex justify-between"><a role=button>Idea</a></label><ul><li><a href=/zh/docs/problem/Idea/01/>问题01</a></li></ul></li><li><input type=checkbox id=section-66dd985e53d8e0b78efdab983762411c class=toggle>
<label for=section-66dd985e53d8e0b78efdab983762411c class="flex justify-between"><a role=button>Git</a></label><ul><li><a href=/zh/docs/problem/Git/01/>git使用ssh连不上</a></li></ul></li><li><input type=checkbox id=section-9440d21f7eb9f8cf7f45b16969ab18dc class=toggle>
<label for=section-9440d21f7eb9f8cf7f45b16969ab18dc class="flex justify-between"><a role=button>Hugo</a></label><ul><li><a href=/zh/docs/problem/Hugo/p1/>hugo踩坑</a></li><li><a href=/zh/docs/problem/Hugo/01a/>图片测试(hugo踩坑)</a></li></ul></li></ul></li><li class=book-section-flat><a href=/zh/docs/life/>生活</a><ul><li><input type=checkbox id=section-c7f767205668758142bb8053263cc14f class=toggle>
<label for=section-c7f767205668758142bb8053263cc14f class="flex justify-between"><a role=button>往日归档</a></label><ul><li><a href=/zh/docs/life/archive/20231026/>成就</a></li><li><a href=/zh/docs/life/archive/20231013/>沉没</a></li><li><a href=/zh/docs/life/archive/20230913/>鲇鱼后思</a></li><li><a href=/zh/docs/life/archive/20230912/>病愈 有感</a></li><li><a href=/zh/docs/life/archive/20220724/>人为什么要结婚(找对象)</a></li><li><a href=/zh/docs/life/archive/20220416/>《作酒》有感</a></li><li><a href=/zh/docs/life/archive/20121226/>2021年最后一个周日</a></li><li><a href=/zh/docs/life/archive/20231021/>沉沦</a></li></ul></li><li><a href=/zh/docs/life/20240626/>知命不惧 日日自新</a></li><li><a href=/zh/docs/life/20231227/>起床临感</a></li><li><a href=/zh/docs/life/20231101/>20231101</a></li></ul></li><li class=book-section-flat><a href=/zh/docs/test/>测试</a><ul><li><a href=/zh/docs/test/hello2/>pdfTest</a></li></ul></li></ul><ul><li><a href=/zh/posts/>博客</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>spring 常见面试题总结</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#spring-基础>Spring 基础</a><ul><li><a href=#什么是-spring-框架>什么是 Spring 框架?</a></li><li><a href=#spring-包含的模块有哪些>Spring 包含的模块有哪些？</a></li><li><a href=#springspring-mvcspring-boot-之间什么关系>Spring,Spring MVC,Spring Boot 之间什么关系?</a></li></ul></li><li><a href=#spring-ioc>Spring IoC</a><ul><li><a href=#谈谈自己对于-spring-ioc-的了解>谈谈自己对于 Spring IoC 的了解</a></li><li><a href=#什么是-spring-bean>什么是 Spring Bean？</a></li><li><a href=#将一个类声明为-bean-的注解有哪些>将一个类声明为 Bean 的注解有哪些?</a></li><li><a href=#component-和-bean-的区别是什么>@Component 和 @Bean 的区别是什么？</a></li><li><a href=#注入-bean-的注解有哪些>注入 Bean 的注解有哪些？</a></li><li><a href=#autowired-和-resource-的区别是什么>@Autowired 和 @Resource 的区别是什么？</a></li><li><a href=#bean-的作用域有哪些>Bean 的作用域有哪些?</a></li><li><a href=#单例-bean-的线程安全问题了解吗>单例 Bean 的线程安全问题了解吗？</a></li><li><a href=#bean-的生命周期了解么>Bean 的生命周期了解么?</a></li></ul></li><li><a href=#spring-aop>Spring AoP</a><ul><li><a href=#谈谈自己对于-aop-的了解>谈谈自己对于 AOP 的了解</a></li><li><a href=#spring-aop-和-aspectj-aop-有什么区别>Spring AOP 和 AspectJ AOP 有什么区别？</a></li><li><a href=#aspectj-定义的通知类型有哪些>AspectJ 定义的通知类型有哪些？</a></li><li><a href=#多个切面的执行顺序如何控制>多个切面的执行顺序如何控制？</a></li></ul></li><li><a href=#spring-mvc>Spring MVC</a><ul><li><a href=#说说自己对于-spring-mvc-了解>说说自己对于 Spring MVC 了解?</a></li><li><a href=#spring-mvc-的核心组件有哪些>Spring MVC 的核心组件有哪些？</a></li><li><a href=#springmvc-工作原理了解吗>SpringMVC 工作原理了解吗?</a></li><li><a href=#统一异常处理怎么做>统一异常处理怎么做？</a></li></ul></li><li><a href=#spring-框架中用到了哪些设计模式>Spring 框架中用到了哪些设计模式？</a></li><li><a href=#spring-事务>Spring 事务</a><ul><li><a href=#spring-管理事务的方式有几种>Spring 管理事务的方式有几种？</a></li><li><a href=#spring事务失效的几种情况非javaguide>Spring事务失效的几种情况（非javaguide）</a></li><li><a href=#spring-事务中哪几种事务传播行为>Spring 事务中哪几种事务传播行为?</a></li><li><a href=#spring-事务中的隔离级别有哪几种>Spring 事务中的隔离级别有哪几种?</a></li><li><a href=#transactionalrollbackfor--exceptionclass注解了解吗>@Transactional(rollbackFor = Exception.class)注解了解吗？</a></li></ul></li><li><a href=#spring-data-jpa>Spring Data JPA</a><ul><li><a href=#如何使用-jpa-在数据库中非持久化一个字段>如何使用 JPA 在数据库中非持久化一个字段？</a></li><li><a href=#jpa-的审计功能是做什么的有什么用>JPA 的审计功能是做什么的？有什么用？</a></li><li><a href=#实体之间的关联关系注解有哪些>实体之间的关联关系注解有哪些？</a></li></ul></li><li><a href=#spring-security>Spring Security</a><ul><li><a href=#有哪些控制请求访问权限的方法>有哪些控制请求访问权限的方法？</a></li><li><a href=#hasrole-和-hasauthority-有区别吗>hasRole 和 hasAuthority 有区别吗？</a></li><li><a href=#如何对密码进行加密>如何对密码进行加密？</a></li><li><a href=#如何优雅更换系统使用的加密算法>如何优雅更换系统使用的加密算法？</a></li></ul></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><blockquote><p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p></blockquote><p>这篇文章主要是想通过一些问题，加深大家对于 Spring 的理解，所以不会涉及太多的代码！</p><p>下面的很多问题我自己在使用 Spring 的过程中也并没有注意，自己也是临时查阅了很多资料和书籍补上的。网上也有一些很多关于 Spring 常见问题/面试题整理的文章，我感觉大部分都是互相 copy，而且很多问题也不是很好，有些回答也存在问题。所以，自己花了一周的业余时间整理了一下，希望对大家有帮助。</p><h2 id=spring-基础>Spring 基础
<a class=anchor href=#spring-%e5%9f%ba%e7%a1%80>#</a></h2><h3 id=什么是-spring-框架>什么是 Spring 框架?
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af-spring-%e6%a1%86%e6%9e%b6>#</a></h3><p>Spring 是一款<strong>开源</strong>的<strong>轻量级 Java 开发框架</strong>，旨在提高开发人员的<strong>开发效率</strong>以及系统的<strong>可维护性</strong>。</p><p>我们一般说 Spring 框架指的都是 Spring Framework，它是很<strong>多模块的集合</strong>，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 <strong>IoC</strong>（<strong>Inversion of Control:控制反转</strong>） 和 <strong>AOP</strong>(<strong>Aspect-Oriented Programming:面向切面编程</strong>)、可以很方便地<strong>对数据库进行访问</strong>、可以很<strong>方便地集成第三方组件</strong>（<strong>电子邮件</strong>，<strong>任务</strong>，<strong>调度</strong>，缓存等等）、对<strong>单元测试</strong>支持比较好、支持 <strong>RESTful Java 应用程序</strong>的开发。</p><p>[<img src=img/ly-20241212142008049.jpg alt=img></p><p>Spring 最核心的思想就是不重新造轮子，<strong>开箱即用</strong>，提高开发效率。</p><p>Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！</p><p>🤐 多提一嘴 ： <strong>语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。</strong></p><p>Spring 提供的核心功能主要是 <strong>IoC</strong> 和 <strong>AOP</strong>。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！</p><ul><li>Spring 官网：https://spring.io/</li><li>Github 地址： <a href=https://github.com/spring-projects/spring-framework>https://github.com/spring-projects/spring-framework</a></li></ul><h3 id=spring-包含的模块有哪些>Spring 包含的模块有哪些？
<a class=anchor href=#spring-%e5%8c%85%e5%90%ab%e7%9a%84%e6%a8%a1%e5%9d%97%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h3><p><strong>Spring4.x 版本</strong> ：</p><p><img src=img/ly-20241212142008316.png alt=ly-20241212142008316></p><p><strong>Spring5.x 版本</strong> ：</p><p><a href=https://camo.githubusercontent.com/29c4744c19142975a5205c977bc6b322591549d3b80ca429655bc9cae073cc05/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f6672616d65776f726b2f737072696e672f32303230303833313137353730382e706e67><img src=img/ly-20241212142008454.jpg alt=Spring5.x主要模块></a></p><p>Spring5.x 版本中 Web 模块的 Sertlet (<strong>应该是Servlet 吧</strong>)组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p><p>Spring 各个模块的依赖关系如下： <img src=img/ly-20241212142008595.png alt=ly-20241212142008595></p><h4 id=core-container>Core Container
<a class=anchor href=#core-container>#</a></h4><p>Spring 框架的核心模块，也可以说是<strong>基础模块</strong>，主要提供 <strong>IoC 依赖注入</strong>功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。</p><ul><li><strong>spring-core</strong> ：Spring 框架<strong>基本的核心工具</strong>类。</li><li><strong>spring-beans</strong> ：提供对 <strong>bean 的创建</strong>、<strong>配置</strong>和<strong>管理</strong>等功能的支持。</li><li><strong>spring-context</strong> ：提供对<strong>国际化</strong>、事件传播、资源加载等功能的支持。</li><li><strong>spring-expression</strong> ：提供对<strong>表达式语言（Spring Expression Language） SpEL</strong> 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li></ul><h4 id=aop>AOP
<a class=anchor href=#aop>#</a></h4><ul><li><strong>spring-aspects</strong> ：该模块为<strong>与 AspectJ 的集成</strong>提供支持。</li><li><strong>spring-aop</strong> ：提供了<strong>面向切面</strong>的编程实现。</li><li><strong>spring-instrument</strong> ：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。</li></ul><h4 id=data-accessintegration>Data Access/Integration
<a class=anchor href=#data-accessintegration>#</a></h4><ul><li><strong>spring-jdbc</strong> ：提供了<strong>对数据库访问的抽象 JDBC</strong>。不同的数据库都有自己独立的 API 用于操作数据库，而 <strong>Java 程序只需要和 JDBC API 交互</strong>，这样就屏蔽了数据库的影响。</li><li><strong>spring-tx</strong> ：提供对<strong>事务</strong>的支持。</li><li><strong>spring-orm</strong> ： 提供对 <strong>Hibernate</strong>、<strong>JPA</strong> 、<strong>iBatis</strong> 等 ORM 框架的支持。</li><li><strong>spring-oxm</strong> ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li><li><strong>spring-jms</strong> : <strong>消息</strong>服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li></ul><h4 id=spring-web>Spring Web
<a class=anchor href=#spring-web>#</a></h4><ul><li><strong>spring-web</strong> ：对 Web 功能的实现提供一些最基础的支持。</li><li><strong>spring-webmvc</strong> ： 提供对 <strong>Spring MVC</strong> 的实现。</li><li><strong>spring-websocket</strong> ： 提供了对 <strong>WebSocket</strong> 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li><strong>spring-webflux</strong> ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</li></ul><h4 id=messaging>Messaging
<a class=anchor href=#messaging>#</a></h4><p><strong>spring-messaging</strong> 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些<strong>基础的报文传送</strong>应用。</p><h4 id=spring-test>Spring Test
<a class=anchor href=#spring-test>#</a></h4><p>Spring 团队提倡<strong>测试驱动开发</strong>（TDD）。有了控制反转 (IoC)的帮助，<strong>单元测试</strong>和<strong>集成测试</strong>变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等<strong>常用的测试框架</strong>支持的都比较好。</p><h3 id=springspring-mvcspring-boot-之间什么关系>Spring,Spring MVC,Spring Boot 之间什么关系?
<a class=anchor href=#springspring-mvcspring-boot-%e4%b9%8b%e9%97%b4%e4%bb%80%e4%b9%88%e5%85%b3%e7%b3%bb>#</a></h3><p>很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。</p><p>Spring 包含了多个功能模块（上面刚刚提到过），其中最重要的是 <strong>Spring-Core（主要提供 IoC 依赖注入功能的支持）</strong> 模块， Spring 中的其他模块（比如 <strong>Spring MVC</strong>）的功能实现基本都需要依赖于该模块。</p><p>下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p><p><img src=img/ly-20241212142008728.jpg alt=Spring主要模块></p><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 <strong>Spring 快速构建 MVC 架构的 Web 程序的能力</strong>。MVC 是<strong>模型(Model)</strong>、<strong>视图(View)</strong>、<strong>控制器(Controller)<strong>的简写，其核心思想是通过将</strong>业务逻辑</strong>、<strong>数据</strong>、<strong>显示</strong>分离来组织代码。</p><p>使用 Spring 进行开发各种<strong>配置过于麻烦</strong>比如开启某些 Spring 特性时，需要用 <strong>XML</strong> 或 <strong>Java</strong> 进行显式配置。于是，Spring Boot 诞生了！</p><p>Spring 旨在<strong>简化 J2EE 企业应用程序</strong>开发。Spring Boot 旨在<strong>简化 Spring 开发</strong>（<strong>减少配置文件</strong>，开箱即用！）。</p><p>Spring Boot 只是<strong>简化了配置</strong>，如果你需要构建 MVC 架构的 Web 程序，你<strong>还是需要使用 Spring MVC</strong> 作为 MVC 框架，只是说 Spring Boot 帮你<strong>简化了 Spring MVC 的很多配置</strong>，真正做到开箱即用！</p><h2 id=spring-ioc>Spring IoC
<a class=anchor href=#spring-ioc>#</a></h2><h3 id=谈谈自己对于-spring-ioc-的了解>谈谈自己对于 Spring IoC 的了解
<a class=anchor href=#%e8%b0%88%e8%b0%88%e8%87%aa%e5%b7%b1%e5%af%b9%e4%ba%8e-spring-ioc-%e7%9a%84%e4%ba%86%e8%a7%a3>#</a></h3><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种<strong>设计</strong>思想，而不是一个具体的技术实现。IoC 的思想就是将<strong>原本在程序中手动创建对象</strong>的控制权，<strong>交由 Spring 框架</strong>来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><p><strong>为什么叫控制反转？</strong></p><ul><li><strong>控制</strong> ：指的是<strong>对象创建（实例化、管理）的权力</strong></li><li><strong>反转</strong> ：<strong>控制权交给外部环境</strong>（<strong>Spring 框架</strong>、<strong>IoC 容器</strong>）</li></ul><p><img src=img/ly-20241212142008866.jpg alt=img></p><p>将<strong>对象之间的相互依赖关系交给 IoC 容器</strong>来管理，并<strong>由 IoC 容器完成对象的注入</strong>。这样可以很大程度上<strong>简化</strong>应用的开发，把应用<strong>从复杂的依赖关系中解放</strong>出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要<strong>配置好配置文件/注解</strong>即可，完全<strong>不用考虑</strong>对象是<strong>如何被创建</strong>出来的。</p><p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你<strong>只需要配置</strong>好，然后<strong>在需要的地方引用</strong>就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>在 Spring 中， <strong>IoC 容器</strong>是 <strong>Spring 用来实现 IoC 的载体</strong>， IoC 容器<strong>实际上就是个 Map（key，value）</strong>，Map 中<strong>存放的是各种对象</strong>。</p><p>Spring 时代我们<strong>一般通过 XML</strong> 文件来<strong>配置 Bean</strong>，后来开发人员觉得 XML 文件来配置不太好，于是 <strong>SpringBoot 注解配置</strong>就慢慢开始流行起来。</p><p>相关阅读：</p><ul><li><a href=https://javadoop.com/post/spring-ioc>IoC 源码阅读</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486938&amp;idx=1&amp;sn=c99ef0233f39a5ffc1b98c81e02dfcd4&amp;chksm=cea24211f9d5cb07fa901183ba4d96187820713a72387788408040822ffb2ed575d28e953ce7&amp;token=1736772241&amp;lang=zh_CN#rd">面试被问了几百遍的 IoC 和 AOP ，还在傻傻搞不清楚？</a></li></ul><h3 id=什么是-spring-bean>什么是 Spring Bean？
<a class=anchor href=#%e4%bb%80%e4%b9%88%e6%98%af-spring-bean>#</a></h3><p>简单来说，Bean 代指的就是<strong>那些被 IoC 容器所管理的对象</strong>。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是<strong>通过配置元数据</strong>来定义的。配置元数据可以是 <strong>XML 文件</strong>、<strong>注解</strong>或者 <strong>Java 配置类</strong>。</p><pre tabindex=0><code>&lt;!-- Constructor-arg with &#39;value&#39; attribute --&gt;
&lt;bean id=&#34;...&#34; class=&#34;...&#34;&gt;
   &lt;constructor-arg value=&#34;...&#34;/&gt;
&lt;/bean&gt;
</code></pre><p>下图简单地展示了 IoC 容器如何使用<strong>配置元数据</strong>来管理对象。</p><p><code>org.springframework.beans</code>和 <code>org.springframework.context</code> 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看</p><h3 id=将一个类声明为-bean-的注解有哪些>将一个类声明为 Bean 的注解有哪些?
<a class=anchor href=#%e5%b0%86%e4%b8%80%e4%b8%aa%e7%b1%bb%e5%a3%b0%e6%98%8e%e4%b8%ba-bean-%e7%9a%84%e6%b3%a8%e8%a7%a3%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h3><ul><li><code>@Component</code> ：<strong>通用</strong>的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于<strong>数据库</strong>相关操作。</li><li><code>@Service</code> : 对应服务层，主要<strong>涉及一些复杂的逻辑</strong>，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 <strong>Spring MVC 控制层</strong>，主要用户<strong>接受用户请求</strong>并<strong>调用 Service 层返回数据</strong>给前端页面。</li></ul><h3 id=component-和-bean-的区别是什么>@Component 和 @Bean 的区别是什么？
<a class=anchor href=#component-%e5%92%8c-bean-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88>#</a></h3><ul><li><code>@Component</code> 注解作用于<strong>类</strong>，而<code>@Bean</code>注解作用于<strong>方法</strong>。</li><li><code>@Component</code>通常是<strong>通过类路径扫描</strong>来<strong>自动侦测</strong>以及<strong>自动装配到 Spring 容器</strong>中（我们可以使用 <strong><code>@ComponentScan</code></strong> 注解<strong>定义要扫描的路径</strong>从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在<strong>标有该注解的方法中定义产生这个 bean</strong>,<code>@Bean</code><strong>告诉了 Spring 这是某个类的实例</strong>，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且<strong>很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean</strong>。比如当我们<strong>引用第三方库</strong>中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ul><p><code>@Bean</code>注解使用示例：</p><pre tabindex=0><code>@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

}
</code></pre><p>上面的代码相当于下面的 xml 配置</p><pre tabindex=0><code>&lt;beans&gt;
    &lt;bean id=&#34;transferService&#34; class=&#34;com.acme.TransferServiceImpl&#34;/&gt;
&lt;/beans&gt;
</code></pre><p>下面这个例子是通过 <strong><code>@Component</code> 无法实现</strong>的。（<strong>带有逻辑</strong>）</p><pre tabindex=0><code>@Bean
public OneService getService(status) {
    case (status)  {
        when 1:
                return new serviceImpl1();
        when 2:
                return new serviceImpl2();
        when 3:
                return new serviceImpl3();
    }
}
</code></pre><h3 id=注入-bean-的注解有哪些>注入 Bean 的注解有哪些？
<a class=anchor href=#%e6%b3%a8%e5%85%a5-bean-%e7%9a%84%e6%b3%a8%e8%a7%a3%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h3><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p><table><thead><tr><th>Annotaion</th><th>Package</th><th>Source</th></tr></thead><tbody><tr><td><code>@Autowired</code></td><td><code>org.springframework.bean.factory</code></td><td>Spring 2.5+</td></tr><tr><td><code>@Resource</code></td><td><code>javax.annotation</code></td><td>Java JSR-250</td></tr><tr><td><code>@Inject</code></td><td><code>javax.inject</code></td><td>Java JSR-330</td></tr></tbody></table><p><code>@Autowired</code> 和<code>@Resource</code>使用的比较多一些。</p><h3 id=autowired-和-resource-的区别是什么>@Autowired 和 @Resource 的区别是什么？
<a class=anchor href=#autowired-%e5%92%8c-resource-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88>#</a></h3><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p><p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p><p>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 <code>smsService</code> 就是我这里所说的名称，这样应该比较好理解了吧。</p><pre tabindex=0><code>// smsService 就是我们上面所说的名称
@Autowired
private SmsService smsService;
</code></pre><p>举个例子，<code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p><pre tabindex=0><code>// 报错，byName 和 byType 都无法匹配到 bean
@Autowired
private SmsService smsService;
// 正确注入 SmsServiceImpl1 对象对应的 bean
@Autowired
private SmsService smsServiceImpl1;
// 正确注入  SmsServiceImpl1 对象对应的 bean
// smsServiceImpl1 就是我们上面所说的名称
@Autowired
@Qualifier(value = &#34;smsServiceImpl1&#34;)
private SmsService smsService;
</code></pre><p>我们还是<strong>建议通过 <code>@Qualifier</code> 注解来显式指定名称</strong>而<strong>不是依赖变量的名称</strong>。</p><p><strong><code>@Resource</code>属于 JDK 提供的注解</strong>，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p><p><code>@Resource</code> 有两个比较重要且日常开发常用的属性：<code>name</code>（名称）、<code>type</code>（类型）。</p><pre tabindex=0><code>public @interface Resource {
    String name() default &#34;&#34;;
    Class&lt;?&gt; type() default Object.class;
}
</code></pre><p>如果仅指定 <code>name</code> 属性则注入方式为<code>byName</code>，如果仅指定<code>type</code>属性则注入方式为<code>byType</code>，如果同时指定<code>name</code> 和<code>type</code>属性（不建议这么做）则注入方式为<code>byType</code>+<code>byName</code>。</p><pre tabindex=0><code>// 报错，byName 和 byType 都无法匹配到 bean
@Resource
private SmsService smsService;
// 正确注入 SmsServiceImpl1 对象对应的 bean
@Resource
private SmsService smsServiceImpl1;
// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）
@Resource(name = &#34;smsServiceImpl1&#34;)
private SmsService smsService;
</code></pre><p>简单总结一下：</p><ul><li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li><li><code>Autowired</code> <strong>默认</strong>的注入方式为**<code>byType</code>（根据类型进行匹配）**，<code>@Resource</code><strong>默认</strong>注入方式为 <strong><code>byName</code>（根据名称进行匹配）</strong>。</li><li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都<strong>需要通过名称</strong>才能正确匹配到对应的 Bean。<strong><code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称</strong>，<strong><code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称</strong>。</li></ul><h3 id=bean-的作用域有哪些>Bean 的作用域有哪些?
<a class=anchor href=#bean-%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h3><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : IoC 容器中只有<strong>唯一</strong>的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : <strong>每次获取都会创建一个新的</strong> bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: <strong>每一次 HTTP 请求</strong>都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : <strong>每一次来自新 session 的 HTTP 请求</strong>都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application/global-session</strong> （仅 Web 应用可用）： <strong>每个 Web 应用在启动时</strong>创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：<strong>每一次 WebSocket 会话</strong>产生一个新的 bean。</li></ul><p><strong>如何配置 bean 的作用域呢？</strong></p><p>xml 方式：</p><pre tabindex=0><code>&lt;bean id=&#34;...&#34; class=&#34;...&#34; scope=&#34;singleton&#34;&gt;&lt;/bean&gt;
</code></pre><p>注解方式：</p><pre tabindex=0><code>@Bean
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public Person personPrototype() {
    return new Person();
}
</code></pre><h3 id=单例-bean-的线程安全问题了解吗>单例 Bean 的线程安全问题了解吗？
<a class=anchor href=#%e5%8d%95%e4%be%8b-bean-%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e9%97%ae%e9%a2%98%e4%ba%86%e8%a7%a3%e5%90%97>#</a></h3><p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当<strong>多个线程操作同一个对象</strong>的时候是存在资源竞争的。</p><p>常见的有两种解决办法：</p><ol><li>在 Bean 中<strong>尽量避免定义可变的成员变量</strong>。</li><li>在类中定义一个 <strong><code>ThreadLocal</code> 成员变量</strong>，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><p>不过，<strong>大部分 Bean 实际都是无状态</strong>（<strong>没有实例变量</strong>）的（比如 Dao、Service），这种情况下， Bean 是<strong>线程安全</strong>的。</p><h3 id=bean-的生命周期了解么>Bean 的生命周期了解么?
<a class=anchor href=#bean-%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e4%ba%86%e8%a7%a3%e4%b9%88>#</a></h3><blockquote><p>下面的内容整理自：https://yemengying.com/2016/07/14/spring-bean-life-cycle/ ，除了这篇文章，再推荐一篇很不错的文章 ：https://www.cnblogs.com/zrtqsk/p/3735273.html 。</p></blockquote><ul><li>Bean 容器<strong>找到配置文件</strong>中 Spring Bean 的<strong>定义</strong>。</li><li>Bean 容器<strong>利用 Java Reflection API</strong> 创建一个 Bean 的实例。【<strong>反射</strong>】<ul><li>如果涉及到一些属性值 <strong>利用 <code>set()</code>方法设置</strong>一些属性值。</li></ul></li></ul><blockquote><p>aware 英[əˈweə(r)] adj. 意识到的,发觉,发现`</p></blockquote><ul><li>如果 Bean 实现了 <strong><code>BeanNameAware</code></strong> 接口，调用 <code>setBeanName()</code>方法，传入 <strong>Bean 的名字</strong>。</li><li>如果 Bean 实现了 <strong><code>BeanClassLoaderAware</code></strong> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <strong><code>ClassLoader</code>对象的实例</strong>。</li><li>如果 Bean 实现了 <strong><code>BeanFactoryAware</code></strong> 接口，调用 <code>setBeanFactory()</code>方法，传入 <strong><code>BeanFactory</code>对象的实例</strong>。</li><li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <strong><code>BeanPostProcessor</code></strong> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果 Bean 实现了**<code>InitializingBean</code><strong>接口，执行</strong><code>afterPropertiesSet()</code>**方法。</li><li>如果 Bean 在配置文件中的定义包含 <strong>init-method</strong> 属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <strong><code>BeanPostProcessor</code></strong> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 <strong><code>DisposableBean</code></strong> 接口，执行 <strong><code>destroy()</code></strong> 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 <strong>destroy-method</strong> 属性，执行指定的方法。</li></ul><p>图示：</p><p><a href=https://camo.githubusercontent.com/70ba44111686c9f9a4fcac62d8ae01fd23e3e707d91fbce4af1205856dcd458f/68747470733a2f2f696d616765732e7869616f7a6875616e6c616e2e636f6d2f70686f746f2f323031392f32346263326261643363653238313434643630643965306132656466366337662e6a7067><img src=https://camo.githubusercontent.com/70ba44111686c9f9a4fcac62d8ae01fd23e3e707d91fbce4af1205856dcd458f/68747470733a2f2f696d616765732e7869616f7a6875616e6c616e2e636f6d2f70686f746f2f323031392f32346263326261643363653238313434643630643965306132656466366337662e6a7067 alt="Spring Bean 生命周期"></a></p><p>与之比较类似的中文版本:</p><p><a href=https://camo.githubusercontent.com/9efd4a1a6c11ebb15c61a022e93bb20934a85a72d95194cf59402421c09191a9/68747470733a2f2f696d616765732e7869616f7a6875616e6c616e2e636f6d2f70686f746f2f323031392f62356432363435363536353761353339356332373831303831613734383365312e6a7067><img src=img/ly-20241212142009004.jpg alt="Spring Bean 生命周期"></a>
<img src=img/ly-20241212142009137.png alt=image.png></p><h2 id=spring-aop>Spring AoP
<a class=anchor href=#spring-aop>#</a></h2><h3 id=谈谈自己对于-aop-的了解>谈谈自己对于 AOP 的了解
<a class=anchor href=#%e8%b0%88%e8%b0%88%e8%87%aa%e5%b7%b1%e5%af%b9%e4%ba%8e-aop-%e7%9a%84%e4%ba%86%e8%a7%a3>#</a></h3><blockquote><p><code>aspect 英[ˈæspekt] 方位 n.</code></p><p><code>oriented 英[ˈɔːrientɪd] 朝向 v.</code></p></blockquote><p>AOP(<strong>Aspect-Oriented Programming:面向切面编程</strong>)能够将那些与业务无关，却为业务模块所<strong>共同调用</strong>的逻辑或责任（例如<strong>事务处理</strong>、<strong>日志管理</strong>、<strong>权限控制</strong>等）封装起来，便于<strong>减少系统的重复代码</strong>，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是<strong>基于动态代理</strong>的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去<strong>创建代理对象</strong>，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个<strong>被代理对象的子类</strong>来作为代理，如下图所示：</p><p><img src=img/ly-20241212142009269.png alt=ly-20241212142009269></p><p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，<strong>AspectJ</strong> 应该算的上是 <strong>Java 生态系统中最完整的 AOP 框架</strong>了。</p><p>AOP 切面编程设计到的一些专业术语：</p><table><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody><tr><td>目标(<strong>Target</strong>)</td><td><strong>被通知的对象</strong></td></tr><tr><td>代理(<strong>Proxy</strong>)</td><td>向目标对象应用通知之后创建的<strong>代理对象</strong></td></tr><tr><td>连接点(JoinPoint)</td><td><strong>目标对象的所属类</strong>中，定义的<strong>所有方法</strong>均为连接点</td></tr><tr><td>切入点(Pointcut)</td><td>被切面拦截 / 增强的连接点（<strong>切入点一定是连接点，连接点不一定是切入点</strong>）</td></tr><tr><td>通知(Advice)</td><td>增强的<strong>逻辑</strong> / <strong>代码</strong>，也即拦截到目标对象的连接点之后要做的事情</td></tr><tr><td>切面(Aspect)</td><td><strong>切入点(Pointcut)+通知(Advice)</strong></td></tr><tr><td>Weaving(织入)</td><td>将<strong>通知应用</strong>到目标对象，进而生成代理对象的<strong>过程动作</strong></td></tr></tbody></table><h3 id=spring-aop-和-aspectj-aop-有什么区别>Spring AOP 和 AspectJ AOP 有什么区别？
<a class=anchor href=#spring-aop-%e5%92%8c-aspectj-aop-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab>#</a></h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于<strong>代理</strong>(Proxying)，而 AspectJ 基于<strong>字节码</strong>操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当<strong>切面太多</strong>的话，最好选择 <strong>AspectJ</strong> ，它比 Spring AOP 快很多。</p><h3 id=aspectj-定义的通知类型有哪些>AspectJ 定义的通知类型有哪些？
<a class=anchor href=#aspectj-%e5%ae%9a%e4%b9%89%e7%9a%84%e9%80%9a%e7%9f%a5%e7%b1%bb%e5%9e%8b%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h3><ul><li><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li><li><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li><li><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li><li><strong>AfterThrowing</strong>（异常通知） ：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li><li><strong>Around</strong> （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li></ul><h3 id=多个切面的执行顺序如何控制>多个切面的执行顺序如何控制？
<a class=anchor href=#%e5%a4%9a%e4%b8%aa%e5%88%87%e9%9d%a2%e7%9a%84%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f%e5%a6%82%e4%bd%95%e6%8e%a7%e5%88%b6>#</a></h3><p>1、通常使用**<code>@Order</code> 注解**直接定义切面顺序</p><pre tabindex=0><code>// 值越小优先级越高
@Order(3)
@Component
@Aspect
public class LoggingAspect implements Ordered {
</code></pre><p><strong>2、实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法。</strong></p><pre tabindex=0><code>@Component
@Aspect
public class LoggingAspect implements Ordered {

    // ....

    @Override
    public int getOrder() {
        // 返回值越小优先级越高
        return 1;
    }
}
</code></pre><h2 id=spring-mvc>Spring MVC
<a class=anchor href=#spring-mvc>#</a></h2><h3 id=说说自己对于-spring-mvc-了解>说说自己对于 Spring MVC 了解?
<a class=anchor href=#%e8%af%b4%e8%af%b4%e8%87%aa%e5%b7%b1%e5%af%b9%e4%ba%8e-spring-mvc-%e4%ba%86%e8%a7%a3>#</a></h3><p>MVC 是<strong>模型(Model)</strong>、<strong>视图(View)</strong>、<strong>控制器(Controller)<strong>的简写，其核心思想是通过将</strong>业务逻辑</strong>、<strong>数据</strong>、<strong>显示</strong>分离来组织代码。</p><p><img src=img/ly-20241212142009406.jpg alt=img></p><p>网上有很多人说 MVC 不是设计模式，只是软件设计规范，我个人更倾向于 <strong>MVC 同样是众多设计模式中的一种</strong>。<strong><a href=https://github.com/iluwatar/java-design-patterns>java-design-patterns</a></strong> 项目中就有关于 MVC 的相关介绍。</p><p><img src=img/ly-20241212142009544.jpg alt=img></p><p>想要真正理解 Spring MVC，我们先来看看 Model 1 和 Model 2 这两个没有 Spring MVC 的时代。</p><p><strong>Model 1 时代</strong></p><p>很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几<strong>乎全部用 JSP 页面</strong>组成，<strong>只用少量的 JavaBean</strong> 来<strong>处理数据库连接</strong>、<strong>访问</strong>等操作。</p><p>这个模式下 <strong>JSP</strong> 即是<strong>控制层（Controller）<strong>又是</strong>表现层（View）</strong>。显而易见，这种模式存在很多问题。比如<strong>控制逻辑</strong>和<strong>表现逻辑</strong>混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。</p><p><strong>Model 2 时代</strong></p><p>学过 Servlet 并做过相关 Demo 的朋友应该了解“<strong>Java Bean(Model)</strong>+ <strong>JSP（View）</strong>+<strong>Servlet（Controller）</strong> ”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。</p><ul><li>Model:系统涉及的数据，也就是 <strong>dao</strong> 和 <strong>bean</strong>。</li><li>View：<strong>展示模型中的数据</strong>，只是用来展示。</li><li>Controller：<strong>处理用户请求</strong>都发送给 <strong>Servlet</strong>，返回数据给 JSP 并展示给用户。</li></ul><p><a href=https://camo.githubusercontent.com/b36a90d56dae552146126cf76f8de218f5d545d9df9d65a7eb84283157f46475/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6a6176612d67756964652d626c6f672f6d76632d6d6f64656c322e706e67><img src=img/ly-20241212142009678.jpg alt=img></a></p><p>Model2 模式下还存在很多问题，<strong>Model2 的抽象</strong>和<strong>封装程度</strong>还远远不够，使用 Model2 进行开发时不可避免地会<strong>重复造轮子</strong>，这就大大降低了程序的<strong>可维护性</strong>和<strong>复用性</strong>。</p><p>于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如 <strong>Struts2</strong>，但是 Struts2 比较笨重。</p><p><strong>Spring MVC 时代</strong></p><p>随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p><p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 <strong>Service 层（处理业务）</strong>、<strong>Dao 层（数据库操作）</strong>、<strong>Entity 层（实体类）</strong>、<strong>Controller 层(控制层</strong>，返回数据给前台页面)。</p><h3 id=spring-mvc-的核心组件有哪些>Spring MVC 的核心组件有哪些？
<a class=anchor href=#spring-mvc-%e7%9a%84%e6%a0%b8%e5%bf%83%e7%bb%84%e4%bb%b6%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h3><p>记住了下面这些组件，也就记住了 SpringMVC 的工作原理。</p><ul><li><strong><code>DispatcherServlet</code></strong> ：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong><code>HandlerMapping</code></strong> ：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code></strong> ：<strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li><strong><code>Handler</code></strong> ：<strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code></strong> ：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><h3 id=springmvc-工作原理了解吗>SpringMVC 工作原理了解吗?
<a class=anchor href=#springmvc-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e4%ba%86%e8%a7%a3%e5%90%97>#</a></h3><p><strong>Spring MVC 原理如下图所示：</strong></p><blockquote><p>SpringMVC 工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。</p></blockquote><p><img src=img/ly-20241212142009812.jpg alt=img></p><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求， <strong><code>DispatcherServlet</code>拦截</strong>请求。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <strong><code>HandlerMapping</code></strong> 。<strong><code>HandlerMapping</code> 根据 uri 去匹配</strong>查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><code>DispatcherServlet</code> 调用 **<code>HandlerAdapter</code>**适配执行 <code>Handler</code> 。</li><li><code>Handler</code> 完成对用户请求的处理后，会<strong>返回一个 <code>ModelAndView</code></strong> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了<strong>数据模型</strong>以及<strong>相应的视图的信息</strong>。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会<strong>根据逻辑 <code>View</code> 查找实际的 <code>View</code></strong>。</li><li><code>DispaterServlet</code> 把<strong>返回的 <code>Model</code> 传给 <code>View</code>（视图渲染</strong>）。</li><li>把 <strong><code>View</code> 返回</strong>给请求者（浏览器）<br><img src=img/ly-20241212142009954.png alt=image.png></li></ol><h3 id=统一异常处理怎么做>统一异常处理怎么做？
<a class=anchor href=#%e7%bb%9f%e4%b8%80%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e6%80%8e%e4%b9%88%e5%81%9a>#</a></h3><p>推荐使用注解的方式统一异常处理，具体会使用到 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 这两个注解 。</p><pre tabindex=0><code>@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    @ExceptionHandler(BaseException.class)
    public ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) {
      //......
    }

    @ExceptionHandler(value = ResourceNotFoundException.class)
    public ResponseEntity&lt;ErrorReponse&gt; handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) {
      //......
    }
}
</code></pre><p>这种异常处理方式下，会给<strong>所有</strong>或者<strong>指定</strong>的 <code>Controller</code> <strong>织入异常处理的逻辑</strong>（AOP），当 <code>Controller</code> 中的方法抛出异常的时候，由被<code>@ExceptionHandler</code> 注解修饰的方法进行处理。</p><p><code>ExceptionHandlerMethodResolver</code> 中 <code>getMappedMethod</code> 方法<strong>决定了异常具体被哪个</strong>被 <code>@ExceptionHandler</code> 注解修饰的方法处理异常。【<strong>这个是框架里的源码，不是自己写的</strong>】</p><pre tabindex=0><code>@Nullable
	private Method getMappedMethod(Class&lt;? extends Throwable&gt; exceptionType) {
		List&lt;Class&lt;? extends Throwable&gt;&gt; matches = new ArrayList&lt;&gt;();
    //找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系
		for (Class&lt;? extends Throwable&gt; mappedException : this.mappedMethods.keySet()) {
			if (mappedException.isAssignableFrom(exceptionType)) {
				matches.add(mappedException);
			}
		}
    // 不为空说明有方法处理异常
		if (!matches.isEmpty()) {
      // 按照匹配程度从小到大排序
			matches.sort(new ExceptionDepthComparator(exceptionType));
      // 返回处理异常的方法
			return this.mappedMethods.get(matches.get(0));
		}
		else {
			return null;
		}
	}
</code></pre><p>从源代码看出： <strong><code>getMappedMethod()</code>会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。</strong></p><h2 id=spring-框架中用到了哪些设计模式>Spring 框架中用到了哪些设计模式？
<a class=anchor href=#spring-%e6%a1%86%e6%9e%b6%e4%b8%ad%e7%94%a8%e5%88%b0%e4%ba%86%e5%93%aa%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f>#</a></h2><blockquote><p>关于下面这些设计模式的详细介绍，可以看我写的 <a href=https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html>Spring 中的设计模式详解</a> 这篇文章。</p></blockquote><ul><li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <strong><code>BeanFactory</code></strong>、<strong><code>ApplicationContext</code></strong> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring <strong>AOP</strong> 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 <strong>Bean 默认都是单例</strong>的。</li><li><strong>模板方法模式</strong> : Spring 中 <strong><code>jdbcTemplate</code></strong>、<strong><code>hibernateTemplate</code></strong> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够<strong>动态切换不同的数据源</strong>。</li><li><strong>观察者模式:</strong> Spring <strong>事件驱动</strong>模型就是<strong>观察者模式</strong>很经典的一个应用。</li><li><strong>适配器模式</strong> : Spring AOP 的<strong>增强或通知(Advice)<strong>使用到了适配器模式、spring MVC 中也是用到了适配器模式</strong>适配<code>Controller</code></strong>。</li><li>&mldr;&mldr;</li></ul><h2 id=spring-事务>Spring 事务
<a class=anchor href=#spring-%e4%ba%8b%e5%8a%a1>#</a></h2><p>关于 Spring 事务的详细介绍，可以看我写的 <a href=https://javaguide.cn/system-design/framework/spring/spring-transaction.html>Spring 事务详解</a> 这篇文章。</p><h3 id=spring-管理事务的方式有几种>Spring 管理事务的方式有几种？
<a class=anchor href=#spring-%e7%ae%a1%e7%90%86%e4%ba%8b%e5%8a%a1%e7%9a%84%e6%96%b9%e5%bc%8f%e6%9c%89%e5%87%a0%e7%a7%8d>#</a></h3><ul><li><strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过 **<code>TransactionTemplate</code>**或者 <strong><code>TransactionManager</code></strong> <strong>手动管理</strong>事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li><li><strong>声明式事务</strong> ： 在 <strong>XML 配置文件中配置</strong>或者<strong>直接基于注解</strong>（推荐使用） : 实际是通过 AOP 实现（基于<code>@**Transactional</code>** 的全注解方式使用最多）</li></ul><h3 id=spring事务失效的几种情况非javaguide>Spring事务失效的几种情况（非javaguide）
<a class=anchor href=#spring%e4%ba%8b%e5%8a%a1%e5%a4%b1%e6%95%88%e7%9a%84%e5%87%a0%e7%a7%8d%e6%83%85%e5%86%b5%e9%9d%9ejavaguide>#</a></h3><h4 id=1spring事务实现方式及原理>1.spring事务实现方式及原理
<a class=anchor href=#1spring%e4%ba%8b%e5%8a%a1%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f%e5%8f%8a%e5%8e%9f%e7%90%86>#</a></h4><p>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring 是无法提供事务功能的。真正的数据库层的事务提交和回滚是在binlog提交之后进行提交的 通过 redo log 来重做， undo log来回滚。</p><p>一般我们在程序里面使用的都是在方法上面加<code>@Transactional </code>注解，这种属于<strong>声明式事务</strong>。</p><p><strong>声明式事务本质是通过 AOP 功能</strong>，<strong>对方法前后进行拦截</strong>，将事务处理的功能<strong>编织</strong>到拦截的<strong>方法中</strong>，也就是<strong>在目标方法开始之前加入一个事务</strong>，在<strong>执行完目标方法之后根据执行情况提交</strong>或者<strong>回滚</strong>事务。</p><h4 id=2数据库本身不支持事务>2.数据库本身不支持事务
<a class=anchor href=#2%e6%95%b0%e6%8d%ae%e5%ba%93%e6%9c%ac%e8%ba%ab%e4%b8%8d%e6%94%af%e6%8c%81%e4%ba%8b%e5%8a%a1>#</a></h4><p>这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB</p><h4 id=3当前类的调用>3.当前类的调用
<a class=anchor href=#3%e5%bd%93%e5%89%8d%e7%b1%bb%e7%9a%84%e8%b0%83%e7%94%a8>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserServiceImpl</span> <span style=color:#66d9ef>implements</span> UserService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(User user) {
</span></span><span style=display:flex><span>        updateUser(user);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(rollbackFor <span style=color:#f92672>=</span> Exception.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>updateUser</span>(User user) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// update user</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></div><p>上面的这种情况下是不会有事务管理操作的。</p><p>通过看声明式事务的原理可知，spring使用的是AOP切面的方式，本质上使用的是动态代理来达到事务管理的目的，当前类调用的方法上面加<code>@Transactional</code> 这个是没有任何作用的，因为调用这个方法的是<code>this</code>.</p><p>OK， 我们在看下面的一种例子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserServiceImpl</span> <span style=color:#66d9ef>implements</span> UserService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(rollbackFor <span style=color:#f92672>=</span> Exception.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(User user) {
</span></span><span style=display:flex><span>        updateUser(user);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(propagation <span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRES_NEW</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>updateUser</span>(User user) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// update user</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></div><p>这次在 update 方法上加了 <code>@Transactional</code>，updateUser 加了 <code>REQUIRES_NEW</code> 新开启一个事务，那么新开的事务管用么？</p><p>答案是：不管用！</p><p>因为它们<strong>发生了自身调用</strong>，就<strong>调该类自己的方法</strong>，而<strong>没有经过 Spring 的代理类</strong>，默认<strong>只有在外部调用事务才会生效</strong>，这也是老生常谈的经典问题了。</p><h4 id=4方法不是public的>4.方法不是public的
<a class=anchor href=#4%e6%96%b9%e6%b3%95%e4%b8%8d%e6%98%afpublic%e7%9a%84>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserServiceImpl</span> <span style=color:#66d9ef>implements</span> UserService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(rollbackFor <span style=color:#f92672>=</span> Exception.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>updateUser</span>(User user) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// update user</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></div><p><strong><code>private</code> 方法是不会被spring代理</strong>的，因此是不会有事务产生的，这种做法是无效的。</p><h4 id=5没有被spring管理>5.没有被spring管理
<a class=anchor href=#5%e6%b2%a1%e6%9c%89%e8%a2%abspring%e7%ae%a1%e7%90%86>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>//@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserServiceImpl</span> <span style=color:#66d9ef>implements</span> UserService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(rollbackFor <span style=color:#f92672>=</span> Exception.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>updateUser</span>(User user) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// update user</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></div><p>没有被spring管理的bean， spring连代理对象都无法生成，当然无效咯。</p><h4 id=6配置的事务传播性有问题>6.配置的事务传播性有问题
<a class=anchor href=#6%e9%85%8d%e7%bd%ae%e7%9a%84%e4%ba%8b%e5%8a%a1%e4%bc%a0%e6%92%ad%e6%80%a7%e6%9c%89%e9%97%ae%e9%a2%98>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserServiceImpl</span> <span style=color:#66d9ef>implements</span> UserService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(propagation <span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>NOT_SUPPORTED</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(User user) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// update user</span>
</span></span><span style=display:flex><span>    }    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></div><p>回顾一下spring的事务传播行为</p><p>Spring 事务的传播行为说的是，当多个事务同时存在的时候， Spring 如何处理这些事务的行为。</p><ol><li>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</li><li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行</li><li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</li><li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER： 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按 REQUIRED 属性执行</li></ol><p>当传播行为设置了PROPAGATION_NOT_SUPPORTED，PROPAGATION_NEVER，PROPAGATION_SUPPORTS这三种时，就有可能存在事务不生效</p><h4 id=7异常被你-抓住了>7.异常被你 &ldquo;抓住"了
<a class=anchor href=#7%e5%bc%82%e5%b8%b8%e8%a2%ab%e4%bd%a0-%e6%8a%93%e4%bd%8f%e4%ba%86>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserServiceImpl</span> <span style=color:#66d9ef>implements</span> UserService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(rollbackFor <span style=color:#f92672>=</span> Exception.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(User user) {
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>try</span>{
</span></span><span style=display:flex><span>        <span style=color:#75715e>// update user</span>
</span></span><span style=display:flex><span>      }<span style=color:#66d9ef>catch</span>(Execption e){
</span></span><span style=display:flex><span>         log.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#34;异常&#34;</span>,e)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></div><p>异常被抓了，这样子代理类就没办法知道你到底有没有错误，需不需要回滚，所以这种情况也是没办法回滚的哦。</p><h4 id=8接口层声明式事务使用cglib代理>8.接口层声明式事务使用cglib代理
<a class=anchor href=#8%e6%8e%a5%e5%8f%a3%e5%b1%82%e5%a3%b0%e6%98%8e%e5%bc%8f%e4%ba%8b%e5%8a%a1%e4%bd%bf%e7%94%a8cglib%e4%bb%a3%e7%90%86>#</a></h4><blockquote><p>注意，这是个前后关系，说的是：如果在接口层使用了<strong>声明式事务</strong>，结果用的是cglib代理，那么事务就不会生效</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>UserService</span>   {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(rollbackFor <span style=color:#f92672>=</span> Exception.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(User user)  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>复制代码
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserServiceImpl</span> <span style=color:#66d9ef>implements</span> UserService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(User user) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// update user</span>
</span></span><span style=display:flex><span>    }    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></div><p>通过元素的 &ldquo;proxy-target-class&rdquo; 属性值来控制是基于接口的还是基于类的代理被创建。如果 &ldquo;proxy-target-class&rdquo; 属值被设置为 &ldquo;true&rdquo;，那么<strong>基于类的代理</strong>将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果 &ldquo;proxy-target-class&rdquo; 属值被设置为 &ldquo;false&rdquo; 或者这个属性被省略，那么<strong>标准的JDK基于接口</strong>的代理将起作用</p><p>注解@Transactional cglib与java动态代理最大区别是<strong>代理目标对象不用实现接口</strong>,那么注解要是写到接口方法上，要是使用cglib代理，这时注解事务就失效了，为了保持兼容注解最好<strong>都写到实现类方法</strong>上。</p><h4 id=9rollbackfor异常指定错误>9.rollbackFor异常指定错误
<a class=anchor href=#9rollbackfor%e5%bc%82%e5%b8%b8%e6%8c%87%e5%ae%9a%e9%94%99%e8%af%af>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserServiceImpl</span> <span style=color:#66d9ef>implements</span> UserService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(User user) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// update user</span>
</span></span><span style=display:flex><span>    }    
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></div><p>上面这种没有指定回滚异常，这个时候默认的回滚异常是<code>RuntimeException</code> ，如果出现其他异常那么就不会回滚事务</p><h3 id=spring-事务中哪几种事务传播行为>Spring 事务中哪几种事务传播行为?
<a class=anchor href=#spring-%e4%ba%8b%e5%8a%a1%e4%b8%ad%e5%93%aa%e5%87%a0%e7%a7%8d%e4%ba%8b%e5%8a%a1%e4%bc%a0%e6%92%ad%e8%a1%8c%e4%b8%ba>#</a></h3><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p><p>当事务方法被另一个事务方法(也可能非事务)调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><blockquote><p>注意几点，下面这个值都是<strong>内方法</strong>上的注解的值，且两个方法必须属于不同类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClassServiceImpl</span> <span style=color:#66d9ef>extends</span> ServiceImpl<span style=color:#f92672>&lt;</span>MyClassMapper, MyClass<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> MyClassService {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> UserService userService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//外方法 </span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodOuter</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//新增一条记录</span>
</span></span><span style=display:flex><span>        MyClass myClass<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> MyClass();
</span></span><span style=display:flex><span>        myClass.<span style=color:#a6e22e>setName</span>(<span style=color:#e6db74>&#34;class_name&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>saveOrUpdate</span>(myClass);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//调用内方法</span>
</span></span><span style=display:flex><span>        userService.<span style=color:#a6e22e>methodInner</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>//抛出异常</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//throw new Exception(&#34;hello&#34;);</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserServiceImpl</span> <span style=color:#66d9ef>extends</span> ServiceImpl<span style=color:#f92672>&lt;</span>UserMapper, User<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>implements</span> UserService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//内方法</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(
</span></span><span style=display:flex><span>            rollbackFor <span style=color:#f92672>=</span> Exception.<span style=color:#a6e22e>class</span>
</span></span><span style=display:flex><span>            ,propagation <span style=color:#f92672>=</span> Propagation.<span style=color:#a6e22e>REQUIRED</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodInner</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//新增一条记录</span>
</span></span><span style=display:flex><span>        User user <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> User();
</span></span><span style=display:flex><span>        user.<span style=color:#a6e22e>setName</span>(<span style=color:#e6db74>&#34;outer_name&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>saveOrUpdate</span>(user);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//抛出异常</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//throw new Exception(&#34;hello&#34;);</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></blockquote><p>正确的事务传播行为可能的值如下:</p><blockquote><p>注：<strong>如果外方法不存在事务，则内外方法完全独立，自己(方法内)抛异常不影响另一方法</strong></p></blockquote><p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p><p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解<strong>默认</strong>使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p><blockquote><p>如果外方法存在事务，则不论 外方法或内方法抛出异常，都会导致外内所在事务（同一个）回滚</p></blockquote><p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p><blockquote><p>如果外方法存在事务，如果仅内方法抛异常，会导致外方法回滚；如果仅外方法抛异常，则不会回滚内方法</p></blockquote><p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p><p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p><blockquote><p>如果外方法存在事务，<strong>（效果和1一样）</strong>， 不论 外方法或内方法抛出异常，都会导致外内所在事务（<strong>和1唯一不同的是，他们是不同事务</strong>）回滚</p></blockquote><p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p><p>这个使用的很少。</p><blockquote><p>如果外方法存在事务，<strong>（效果和1一样）</strong>， 不论 外方法或内方法抛出异常，都会导致外内所在事务（<strong>和1唯一不同的是，如果外方法不存在事务，调用该方法前就直接抛异常</strong>）回滚</p></blockquote><p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p><ul><li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。
<img src=img/ly-20241212142010090.png alt=image.png></li></ul><h3 id=spring-事务中的隔离级别有哪几种>Spring 事务中的隔离级别有哪几种?
<a class=anchor href=#spring-%e4%ba%8b%e5%8a%a1%e4%b8%ad%e7%9a%84%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d>#</a></h3><p><strong>//这个注解应该是用来修改session级别的隔离级别</strong></p><p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p><pre tabindex=0><code>public enum Isolation {

    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),

    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),

    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),

    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),

    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);

    private final int value;

    Isolation(int value) {
        this.value = value;
    }

    public int value() {
        return this.value;
    }

}
</code></pre><p>下面我依次对每一种事务隔离级别进行介绍：</p><ul><li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li><li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><blockquote><p>注意，这个注解的使用方法，下面写了两个方法分别模拟两个不同的线程操作（供不同的controller使用）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(
</span></span><span style=display:flex><span>            isolation <span style=color:#f92672>=</span> Isolation.<span style=color:#a6e22e>READ_COMMITTED</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> User <span style=color:#a6e22e>isolation1</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//读取userid=1的值</span>
</span></span><span style=display:flex><span>        User byId <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>getById</span>(1L);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> byId;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> User <span style=color:#a6e22e>isolation2</span>() <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//10s后修改</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10);
</span></span><span style=display:flex><span>        User user<span style=color:#f92672>=</span><span style=color:#66d9ef>new</span> User();
</span></span><span style=display:flex><span>        user.<span style=color:#a6e22e>setId</span>(1L);
</span></span><span style=display:flex><span>        user.<span style=color:#a6e22e>setName</span>(<span style=color:#e6db74>&#34;1被修改了&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>saveOrUpdate</span>(user);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//10s后提交</span>
</span></span><span style=display:flex><span>        TimeUnit.<span style=color:#a6e22e>SECONDS</span>.<span style=color:#a6e22e>sleep</span>(10);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ol><li>当isolation1为读已提交时，只要isolation2方法没有执行完毕（没有提交），那么isolation1只会读取到未修改的值；</li><li>当isolation1为读为提交时，即使isolation2方法没有执行完毕（没有提交），那么isolation1也会立马读取到最新的值；</li></ol></blockquote><h3 id=transactionalrollbackfor--exceptionclass注解了解吗>@Transactional(rollbackFor = Exception.class)注解了解吗？
<a class=anchor href=#transactionalrollbackfor--exceptionclass%e6%b3%a8%e8%a7%a3%e4%ba%86%e8%a7%a3%e5%90%97>#</a></h3><p><code>Exception</code> 分为运行时异常 <strong><code>RuntimeException</code></strong> 和<strong>非运行时异常</strong>。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p><p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别<strong>使用该标注来覆盖类级别的定义</strong>。如果类或者方法加了这个注解，那么这个类里面的方法<strong>抛出异常</strong>，<strong>就会回滚</strong>，数据库里面的数据也会回滚。</p><p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到**<code>RuntimeException</code><strong>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到</strong>非运行时异常时**也回滚。</p><h2 id=spring-data-jpa>Spring Data JPA
<a class=anchor href=#spring-data-jpa>#</a></h2><p>JPA 重要的是实战，这里仅对小部分知识点进行总结。</p><h3 id=如何使用-jpa-在数据库中非持久化一个字段>如何使用 JPA 在数据库中非持久化一个字段？
<a class=anchor href=#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-jpa-%e5%9c%a8%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%ad%e9%9d%9e%e6%8c%81%e4%b9%85%e5%8c%96%e4%b8%80%e4%b8%aa%e5%ad%97%e6%ae%b5>#</a></h3><p>假如我们有下面一个类：</p><pre tabindex=0><code>@Entity(name=&#34;USER&#34;)
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = &#34;ID&#34;)
    private Long id;

    @Column(name=&#34;USER_NAME&#34;)
    private String userName;

    @Column(name=&#34;PASSWORD&#34;)
    private String password;

    private String secrect;

}
</code></pre><p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p><pre tabindex=0><code>static String transient1; // not persistent because of static
final String transient2 = &#34;Satish&#34;; // not persistent because of final
transient String transient3; // not persistent because of transient
@Transient
String transient4; // not persistent because of @Transient
</code></pre><p>一般使用后面两种方式比较多，我个人使用注解的方式比较多。</p><h3 id=jpa-的审计功能是做什么的有什么用>JPA 的审计功能是做什么的？有什么用？
<a class=anchor href=#jpa-%e7%9a%84%e5%ae%a1%e8%ae%a1%e5%8a%9f%e8%83%bd%e6%98%af%e5%81%9a%e4%bb%80%e4%b9%88%e7%9a%84%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8>#</a></h3><p>审计功能主要是帮助我们记录数据库操作的具体行为比如<strong>某条记录是谁创建的</strong>、<strong>什么时间创建的</strong>、<strong>最后修改人</strong>是谁、<strong>最后修改时间</strong>是什么时候。</p><pre tabindex=0><code>@Data
@AllArgsConstructor
@NoArgsConstructor
@MappedSuperclass
@EntityListeners(value = AuditingEntityListener.class)
public abstract class AbstractAuditBase {

    @CreatedDate
    @Column(updatable = false)
    @JsonIgnore
    private Instant createdAt;

    @LastModifiedDate
    @JsonIgnore
    private Instant updatedAt;

    @CreatedBy
    @Column(updatable = false)
    @JsonIgnore
    private String createdBy;

    @LastModifiedBy
    @JsonIgnore
    private String updatedBy;
}
</code></pre><ul><li><p><code>@CreatedDate</code>: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</p></li><li><p><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert 的时候，会设置值</p><p><code>@LastModifiedDate</code>、<code>@LastModifiedBy</code>同理。</p></li></ul><h3 id=实体之间的关联关系注解有哪些>实体之间的关联关系注解有哪些？
<a class=anchor href=#%e5%ae%9e%e4%bd%93%e4%b9%8b%e9%97%b4%e7%9a%84%e5%85%b3%e8%81%94%e5%85%b3%e7%b3%bb%e6%b3%a8%e8%a7%a3%e6%9c%89%e5%93%aa%e4%ba%9b>#</a></h3><ul><li><code>@OneToOne </code>: 一对一。</li><li><code>@ManyToMany</code> ：多对多。</li><li><code>@OneToMany</code> : 一对多。</li><li><code>@ManyToOne</code> ：多对一。</li></ul><p>利用 <code>@ManyToOne</code> 和 <code>@OneToMany</code> 也可以表达多对多的关联关系。</p><h2 id=spring-security>Spring Security
<a class=anchor href=#spring-security>#</a></h2><p>Spring Security 重要的是实战，这里仅对小部分知识点进行总结。</p><h3 id=有哪些控制请求访问权限的方法>有哪些控制请求访问权限的方法？
<a class=anchor href=#%e6%9c%89%e5%93%aa%e4%ba%9b%e6%8e%a7%e5%88%b6%e8%af%b7%e6%b1%82%e8%ae%bf%e9%97%ae%e6%9d%83%e9%99%90%e7%9a%84%e6%96%b9%e6%b3%95>#</a></h3><p><img src=img/ly-20241212142010222.png alt=ly-20241212142010222.png></p><ul><li><code>permitAll()</code> ：无条件允许任何形式访问，不管你登录还是没有登录。</li><li><code>anonymous()</code> ：允许匿名访问，也就是没有登录才可以访问。</li><li><code>denyAll()</code> ：无条件决绝任何形式的访问。</li><li><code>authenticated()</code>：只允许已认证的用户访问。</li><li><code>fullyAuthenticated()</code> ：只允许已经登录或者通过 remember-me 登录的用户访问。</li><li><code>hasRole(String)</code> : 只允许指定的角色访问。</li><li><code>hasAnyRole(String) </code>: 指定一个或者多个角色，满足其一的用户即可访问。</li><li><code>hasAuthority(String)</code> ：只允许具有指定权限的用户访问</li><li><code>hasAnyAuthority(String)</code> ：指定一个或者多个权限，满足其一的用户即可访问。</li><li><code>hasIpAddress(String)</code> : 只允许指定 ip 的用户访问。</li></ul><h3 id=hasrole-和-hasauthority-有区别吗>hasRole 和 hasAuthority 有区别吗？
<a class=anchor href=#hasrole-%e5%92%8c-hasauthority-%e6%9c%89%e5%8c%ba%e5%88%ab%e5%90%97>#</a></h3><p>可以看看松哥的这篇文章：<a href=https://mp.weixin.qq.com/s/GTNOa2k9_n_H0w24upClRw>Spring Security 中的 hasRole 和 hasAuthority 有区别吗？</a>，介绍的比较详细。</p><h3 id=如何对密码进行加密>如何对密码进行加密？
<a class=anchor href=#%e5%a6%82%e4%bd%95%e5%af%b9%e5%af%86%e7%a0%81%e8%bf%9b%e8%a1%8c%e5%8a%a0%e5%af%86>#</a></h3><p>如果我们需要保存密码这类敏感数据到数据库的话，需要<strong>先加密再保存</strong>。</p><p>Spring Security 提供了多种加密算法的实现，开箱即用，非常方便。这些加密算法实现类的父类是 <code>PasswordEncoder</code> ，如果你想要自己实现一个加密算法的话，也需要继承 <code>PasswordEncoder</code>。</p><p><code>PasswordEncoder</code> 接口一共也就 3 个必须实现的方法。</p><pre tabindex=0><code>public interface PasswordEncoder {
    // 加密也就是对原始密码进行编码
    String encode(CharSequence var1);
    // 比对原始密码和数据库中保存的密码
    boolean matches(CharSequence var1, String var2);
    // 判断加密密码是否需要再次进行加密，默认返回 false
    default boolean upgradeEncoding(String encodedPassword) {
        return false;
    }
}
</code></pre><p><img src=img/ly-20241212142010354.png alt=ly-20241212142010354.png></p><p>官方推荐使用基于 bcrypt 强哈希函数的加密算法实现类。</p><h3 id=如何优雅更换系统使用的加密算法>如何优雅更换系统使用的加密算法？
<a class=anchor href=#%e5%a6%82%e4%bd%95%e4%bc%98%e9%9b%85%e6%9b%b4%e6%8d%a2%e7%b3%bb%e7%bb%9f%e4%bd%bf%e7%94%a8%e7%9a%84%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95>#</a></h3><p>如果我们在开发过程中，突然发现现有的加密算法无法满足我们的需求，需要更换成另外一个加密算法，这个时候应该怎么办呢？</p><p>推荐的做法是<strong>通过 <code>DelegatingPasswordEncoder</code> 兼容多种不同的密码加密</strong>方案，以适应不同的业务需求。</p><p>从名字也能看出来，<code>DelegatingPasswordEncoder</code> 其实就是一个代理类，并非是一种全新的加密算法，它做的事情就是<strong>代理上面提到的加密算法实现类</strong>。在 Spring Security 5.0之后，默认就是基于 <code>DelegatingPasswordEncoder</code> 进行密码加密的。</p><h2 id=参考>参考
<a class=anchor href=#%e5%8f%82%e8%80%83>#</a></h2><ul><li>《Spring 技术内幕》</li><li>《从零开始深入学习 Spring》：https://juejin.cn/book/6857911863016390663</li><li><a href=http://www.cnblogs.com/wmyskxz/p/8820371.html>http://www.cnblogs.com/wmyskxz/p/8820371.html</a></li><li><a href=https://www.journaldev.com/2696/spring-interview-questions-and-answers>https://www.journaldev.com/2696/spring-interview-questions-and-answers</a></li><li><a href=https://www.edureka.co/blog/interview-questions/spring-interview-questions/>https://www.edureka.co/blog/interview-questions/spring-interview-questions/</a></li><li><a href=https://www.cnblogs.com/clwydjgs/p/9317849.html>https://www.cnblogs.com/clwydjgs/p/9317849.html</a></li><li><a href=https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/>https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/</a></li><li><a href=http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/>http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/</a></li><li><a href=https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired>https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#spring-基础>Spring 基础</a><ul><li><a href=#什么是-spring-框架>什么是 Spring 框架?</a></li><li><a href=#spring-包含的模块有哪些>Spring 包含的模块有哪些？</a></li><li><a href=#springspring-mvcspring-boot-之间什么关系>Spring,Spring MVC,Spring Boot 之间什么关系?</a></li></ul></li><li><a href=#spring-ioc>Spring IoC</a><ul><li><a href=#谈谈自己对于-spring-ioc-的了解>谈谈自己对于 Spring IoC 的了解</a></li><li><a href=#什么是-spring-bean>什么是 Spring Bean？</a></li><li><a href=#将一个类声明为-bean-的注解有哪些>将一个类声明为 Bean 的注解有哪些?</a></li><li><a href=#component-和-bean-的区别是什么>@Component 和 @Bean 的区别是什么？</a></li><li><a href=#注入-bean-的注解有哪些>注入 Bean 的注解有哪些？</a></li><li><a href=#autowired-和-resource-的区别是什么>@Autowired 和 @Resource 的区别是什么？</a></li><li><a href=#bean-的作用域有哪些>Bean 的作用域有哪些?</a></li><li><a href=#单例-bean-的线程安全问题了解吗>单例 Bean 的线程安全问题了解吗？</a></li><li><a href=#bean-的生命周期了解么>Bean 的生命周期了解么?</a></li></ul></li><li><a href=#spring-aop>Spring AoP</a><ul><li><a href=#谈谈自己对于-aop-的了解>谈谈自己对于 AOP 的了解</a></li><li><a href=#spring-aop-和-aspectj-aop-有什么区别>Spring AOP 和 AspectJ AOP 有什么区别？</a></li><li><a href=#aspectj-定义的通知类型有哪些>AspectJ 定义的通知类型有哪些？</a></li><li><a href=#多个切面的执行顺序如何控制>多个切面的执行顺序如何控制？</a></li></ul></li><li><a href=#spring-mvc>Spring MVC</a><ul><li><a href=#说说自己对于-spring-mvc-了解>说说自己对于 Spring MVC 了解?</a></li><li><a href=#spring-mvc-的核心组件有哪些>Spring MVC 的核心组件有哪些？</a></li><li><a href=#springmvc-工作原理了解吗>SpringMVC 工作原理了解吗?</a></li><li><a href=#统一异常处理怎么做>统一异常处理怎么做？</a></li></ul></li><li><a href=#spring-框架中用到了哪些设计模式>Spring 框架中用到了哪些设计模式？</a></li><li><a href=#spring-事务>Spring 事务</a><ul><li><a href=#spring-管理事务的方式有几种>Spring 管理事务的方式有几种？</a></li><li><a href=#spring事务失效的几种情况非javaguide>Spring事务失效的几种情况（非javaguide）</a></li><li><a href=#spring-事务中哪几种事务传播行为>Spring 事务中哪几种事务传播行为?</a></li><li><a href=#spring-事务中的隔离级别有哪几种>Spring 事务中的隔离级别有哪几种?</a></li><li><a href=#transactionalrollbackfor--exceptionclass注解了解吗>@Transactional(rollbackFor = Exception.class)注解了解吗？</a></li></ul></li><li><a href=#spring-data-jpa>Spring Data JPA</a><ul><li><a href=#如何使用-jpa-在数据库中非持久化一个字段>如何使用 JPA 在数据库中非持久化一个字段？</a></li><li><a href=#jpa-的审计功能是做什么的有什么用>JPA 的审计功能是做什么的？有什么用？</a></li><li><a href=#实体之间的关联关系注解有哪些>实体之间的关联关系注解有哪些？</a></li></ul></li><li><a href=#spring-security>Spring Security</a><ul><li><a href=#有哪些控制请求访问权限的方法>有哪些控制请求访问权限的方法？</a></li><li><a href=#hasrole-和-hasauthority-有区别吗>hasRole 和 hasAuthority 有区别吗？</a></li><li><a href=#如何对密码进行加密>如何对密码进行加密？</a></li><li><a href=#如何优雅更换系统使用的加密算法>如何优雅更换系统使用的加密算法？</a></li></ul></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></div></aside></main></body></html>