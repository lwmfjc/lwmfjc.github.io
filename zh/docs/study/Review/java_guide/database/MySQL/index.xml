<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MySQL on 随记</title><link>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/</link><description>Recent content in MySQL on 随记</description><generator>Hugo</generator><language>zh</language><lastBuildDate>Tue, 14 Mar 2023 22:34:52 +0000</lastBuildDate><atom:link href="https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/index.xml" rel="self" type="application/rss+xml"/><item><title>mysql执行计划</title><link>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0606lymysql-query-execution-plan/</link><pubDate>Tue, 14 Mar 2023 22:34:52 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0606lymysql-query-execution-plan/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>本文来自公号 MySQL 技术，JavaGuide 对其做了补充完善。原文地址：https://mp.weixin.qq.com/s/d5OowNLtXBGEAbT31sSH4g&lt;/p>
&lt;/blockquote>
&lt;p>优化 SQL 的第一步应该是读懂 SQL 的执行计划。本篇文章，我们一起来学习下 MySQL &lt;code>EXPLAIN&lt;/code> 执行计划相关知识。&lt;/p>
&lt;h2 id="什么是执行计划">
 什么是执行计划？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>执行计划&lt;/strong> 是指一条 SQL 语句在经过 &lt;strong>MySQL 查询优化器&lt;/strong> 的优化会后，具体的执行方式。&lt;/p>
&lt;p>执行计划通常用于 &lt;strong>SQL 性能分析&lt;/strong>、&lt;strong>优化&lt;/strong>等场景。通过 &lt;code>EXPLAIN&lt;/code> 的结果，可以了解到如&lt;strong>数据表的查询顺序&lt;/strong>、数据查询操作的&lt;strong>操作类型&lt;/strong>、&lt;strong>哪些索引&lt;/strong>可以被命中、哪些索引&lt;strong>实际&lt;/strong>会命中、每个数据表有多少&lt;strong>行记录被查询&lt;/strong>等信息。&lt;/p>
&lt;h2 id="如何获取执行计划">
 如何获取执行计划？
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e8%8e%b7%e5%8f%96%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 提交准备数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">SET&lt;/span> NAMES utf8mb4;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SET&lt;/span> FOREIGN_KEY_CHECKS &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- ----------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- Table structure for dept_emp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- ----------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>emp_no&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">varchar&lt;/span>(&lt;span style="color:#ae81ff">128&lt;/span>) &lt;span style="color:#66d9ef">CHARACTER&lt;/span> &lt;span style="color:#66d9ef">SET&lt;/span> utf8mb4 &lt;span style="color:#66d9ef">COLLATE&lt;/span> utf8mb4_0900_ai_ci &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>other1&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">varchar&lt;/span>(&lt;span style="color:#ae81ff">255&lt;/span>) &lt;span style="color:#66d9ef">CHARACTER&lt;/span> &lt;span style="color:#66d9ef">SET&lt;/span> utf8mb4 &lt;span style="color:#66d9ef">COLLATE&lt;/span> utf8mb4_0900_ai_ci &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>other2&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">varchar&lt;/span>(&lt;span style="color:#ae81ff">255&lt;/span>) &lt;span style="color:#66d9ef">CHARACTER&lt;/span> &lt;span style="color:#66d9ef">SET&lt;/span> utf8mb4 &lt;span style="color:#66d9ef">COLLATE&lt;/span> utf8mb4_0900_ai_ci &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>) &lt;span style="color:#66d9ef">USING&lt;/span> BTREE,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">INDEX&lt;/span> &lt;span style="color:#f92672">`&lt;/span>index_emp_no&lt;span style="color:#f92672">`&lt;/span>(&lt;span style="color:#f92672">`&lt;/span>emp_no&lt;span style="color:#f92672">`&lt;/span>) &lt;span style="color:#66d9ef">USING&lt;/span> BTREE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) &lt;span style="color:#66d9ef">ENGINE&lt;/span> &lt;span style="color:#f92672">=&lt;/span> InnoDB &lt;span style="color:#66d9ef">CHARACTER&lt;/span> &lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#f92672">=&lt;/span> utf8mb4 &lt;span style="color:#66d9ef">COLLATE&lt;/span> &lt;span style="color:#f92672">=&lt;/span> utf8mb4_0900_ai_ci ROW_FORMAT &lt;span style="color:#f92672">=&lt;/span> Dynamic;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- ----------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- Records of dept_emp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- ----------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">VALUES&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;a1&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o11&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;012&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">VALUES&lt;/span> (&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;a2&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o21&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o22&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">VALUES&lt;/span> (&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;a3&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o31&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o32&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">VALUES&lt;/span> (&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;a4&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o41&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o42&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">VALUES&lt;/span> (&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;a5&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o51&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o52&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SET&lt;/span> FOREIGN_KEY_CHECKS &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MySQL 为我们提供了 &lt;code>EXPLAIN&lt;/code> 命令，来获取执行计划的相关信息。&lt;/p></description></item><item><title>MySQL高性能优化规范建议总结</title><link>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0611lymysql-high-performance-optimization-specification-recommendations/</link><pubDate>Fri, 20 Jan 2023 11:36:34 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0611lymysql-high-performance-optimization-specification-recommendations/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>索引优化相关&lt;/p>
&lt;ol>
&lt;li>in 代替 or&lt;/li>
&lt;li>not exist 代替 not in&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h1 id="数据库命名规范">
 数据库命名规范
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%91%bd%e5%90%8d%e8%a7%84%e8%8c%83">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>所有&lt;strong>数据库对象&lt;/strong>名称必须使用&lt;strong>小写字母&lt;/strong>并用&lt;strong>下划线分割&lt;/strong>&lt;/li>
&lt;li>所有数据库对象名称&lt;strong>禁止使用 MySQL 保留关键字&lt;/strong>（如果表名中包含关键字查询时，需要将其用单引号括起来）&lt;/li>
&lt;li>数据库对象的命名要能做到&lt;strong>见名识意&lt;/strong>，并且最好&lt;strong>不要超过 32 个&lt;/strong>字符&lt;/li>
&lt;li>&lt;strong>临时库表&lt;/strong>必须&lt;strong>以 &lt;code>tmp_&lt;/code> 为前缀&lt;/strong>并以日期为后缀，&lt;strong>备份表&lt;/strong>必须&lt;strong>以 &lt;code>bak_&lt;/code> 为前缀&lt;/strong>并&lt;strong>以日期 (时间戳) 为后缀&lt;/strong>&lt;/li>
&lt;li>所有&lt;strong>存储相同数据的列名和列类型&lt;/strong>必须一致（&lt;strong>一般作为关联列&lt;/strong>，如果查询时关联列&lt;strong>类型不一致会自动进行数据类型隐式转换&lt;/strong>，会&lt;strong>造成列上的索引失效&lt;/strong>，导致查询效率降低）&lt;/li>
&lt;/ul>
&lt;h1 id="数据库基本设计规范">
 数据库基本设计规范
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%9f%ba%e6%9c%ac%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83">#&lt;/a>
&lt;/h1>
&lt;h2 id="所有表必须使用innodb存储引擎">
 所有表必须使用InnoDB存储引擎
 &lt;a class="anchor" href="#%e6%89%80%e6%9c%89%e8%a1%a8%e5%bf%85%e9%a1%bb%e4%bd%bf%e7%94%a8innodb%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。&lt;/li>
&lt;li>InnoDB 支持&lt;strong>事务&lt;/strong>，支持&lt;strong>行级锁&lt;/strong>，更好的&lt;strong>恢复性&lt;/strong>，&lt;strong>高并发&lt;/strong>下性能更好&lt;/li>
&lt;/ul>
&lt;h2 id="数据库和表的字符集统一使用utf-8">
 数据库和表的字符集统一使用UTF-8
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%92%8c%e8%a1%a8%e7%9a%84%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bb%9f%e4%b8%80%e4%bd%bf%e7%94%a8utf-8">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>兼容性&lt;/strong>更好，&lt;strong>统一字符集&lt;/strong>可以避免由于字符集转换产生的&lt;strong>乱码&lt;/strong>，不同的字符集进行比较前需要进行转换会造成&lt;strong>索引失效&lt;/strong>，如果数据库中有&lt;strong>存储 emoji 表情&lt;/strong>的需要，字符集需要采用 &lt;strong>utf8mb4&lt;/strong> 字符集。&lt;/p>
&lt;p>参考文章：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/horses/article/details/107243447">MySQL 字符集不一致导致索引失效的一个真实案例open in new window&lt;/a>&lt;/li>
&lt;li>[MySQL 字符集详解&lt;/li>
&lt;/ul>
&lt;h2 id="所有表和字段都需要添加注释">
 所有表和字段都需要添加注释
 &lt;a class="anchor" href="#%e6%89%80%e6%9c%89%e8%a1%a8%e5%92%8c%e5%ad%97%e6%ae%b5%e9%83%bd%e9%9c%80%e8%a6%81%e6%b7%bb%e5%8a%a0%e6%b3%a8%e9%87%8a">#&lt;/a>
&lt;/h2>
&lt;p>使用 &lt;strong>comment 从句添加表&lt;/strong>和&lt;strong>列的备注&lt;/strong>，从一开始就进行数据字典的维护&lt;/p>
&lt;h2 id="尽量控制单表数据量的大小建议控制在500万以内">
 尽量控制单表数据量的大小，建议控制在500万以内
 &lt;a class="anchor" href="#%e5%b0%bd%e9%87%8f%e6%8e%a7%e5%88%b6%e5%8d%95%e8%a1%a8%e6%95%b0%e6%8d%ae%e9%87%8f%e7%9a%84%e5%a4%a7%e5%b0%8f%e5%bb%ba%e8%ae%ae%e6%8e%a7%e5%88%b6%e5%9c%a8500%e4%b8%87%e4%bb%a5%e5%86%85">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>500 万并不是 MySQL 数据库的限制，&lt;strong>过大会造成修改表结构&lt;/strong>，&lt;strong>备份&lt;/strong>，&lt;strong>恢复&lt;/strong>都会有很大的问题。&lt;/p></description></item><item><title>MySQL常见面试题总结</title><link>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0610lymysql-questions-01/</link><pubDate>Fri, 20 Jan 2023 11:36:06 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0610lymysql-questions-01/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!====&lt;/p>
&lt;/blockquote>
&lt;h1 id="mysql基础">
 MySQL基础
 &lt;a class="anchor" href="#mysql%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h1>
&lt;h2 id="关系型数据库介绍">
 关系型数据库介绍
 &lt;a class="anchor" href="#%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>关系型数据库&lt;/strong>，建立在&lt;strong>关系模型&lt;/strong>的基础上的数据库。表明数据库中所&lt;strong>存储&lt;/strong>的数据之间的&lt;strong>联系&lt;/strong>（一对一、一对多、多对多）&lt;/li>
&lt;li>关系型数据库中，我们的数据都被&lt;strong>存放在各种表&lt;/strong>中（比如用户表），表中的&lt;strong>每一行&lt;/strong>存放着&lt;strong>一条数据（比如一个用户的信息）&lt;/strong>
&lt;img src="img/ly-20241212141910786.png" alt="关系型数据库表关系" />&lt;/li>
&lt;li>大部分关系型数据库都使用&lt;strong>SQL&lt;/strong>来操作数据库中的数据，并且大部分&lt;strong>关系型数据库&lt;/strong>都支持&lt;strong>事务&lt;/strong>的&lt;strong>四大特性（ACID）&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>常见的关系型数据库&lt;/strong>&lt;br>
&lt;strong>MySQL&lt;/strong>、&lt;strong>PostgreSQL&lt;/strong>、&lt;strong>Oracle&lt;/strong>、&lt;strong>SQL Server&lt;/strong>、&lt;strong>SQLite&lt;/strong>（&lt;strong>微信本地的聊天记录&lt;/strong>的存储就是用的 SQLite） &amp;hellip;&amp;hellip;&lt;/p>
&lt;h2 id="mysql介绍">
 MySQL介绍
 &lt;a class="anchor" href="#mysql%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212141911084.png" alt="img" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>MySQL是一种&lt;strong>关系型数据库&lt;/strong>，主要用于&lt;strong>持久化存储&lt;/strong>我们系统中的一些数据比如&lt;strong>用户信息&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于 MySQL 是&lt;strong>开源&lt;/strong>免费并且比较&lt;strong>成熟&lt;/strong>的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 &lt;strong>GPL(General Public License 通用性公开许可证)&lt;/strong> 的许可下下载并根据&lt;strong>个性化的需要&lt;/strong>对其进行&lt;strong>修改&lt;/strong>。MySQL 的默认端口号是&lt;strong>3306&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="mysql基础架构">
 MySQL基础架构
 &lt;a class="anchor" href="#mysql%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>MySQL的一个&lt;strong>简要机构图&lt;/strong>，客户端的一条&lt;strong>SQL语句&lt;/strong>在MySQL内部如何执行
&lt;img src="img/ly-20241212141911246.png" alt="ly-20241212141911246" />&lt;/li>
&lt;li>MySQL主要由几部分构成
&lt;ol>
&lt;li>&lt;strong>连接器&lt;/strong>：&lt;strong>身份认证&lt;/strong>和&lt;strong>权限相关&lt;/strong>（登录MySQL的时候）&lt;/li>
&lt;li>&lt;strong>查询缓存&lt;/strong>：执行&lt;strong>查询&lt;/strong>语句的时候，会先&lt;strong>查询缓存&lt;/strong>（MySQL8.0版本后&lt;strong>移除&lt;/strong>，因为这个功能不太实用）&lt;/li>
&lt;li>&lt;strong>分析器&lt;/strong>：&lt;strong>没有命中缓存&lt;/strong>的话，SQL语句就会经过分析器，分析器说白了就是要先看你的SQL语句&lt;strong>要干嘛&lt;/strong>，再检查你的&lt;strong>SQL语句语法&lt;/strong>是否正确&lt;/li>
&lt;li>&lt;strong>优化器&lt;/strong>：按照&lt;strong>MySQL认为最优的方案&lt;/strong>去执行&lt;/li>
&lt;li>&lt;strong>执行器&lt;/strong>：&lt;strong>执行&lt;/strong>语句，然后从&lt;strong>存储引擎返回&lt;/strong>数据。执行语句之前会&lt;strong>先判断是否有权限&lt;/strong>，如果没有权限，就会报错&lt;/li>
&lt;li>&lt;strong>插件式存储引擎&lt;/strong>：主要负责&lt;strong>数据&lt;/strong>的&lt;strong>存储&lt;/strong>和&lt;strong>读取&lt;/strong>，采用的是&lt;strong>插件式架构&lt;/strong>，支持&lt;strong>InnoDB&lt;/strong>、&lt;strong>MyISAM&lt;/strong>、&lt;strong>Memory&lt;/strong>等多种存储引擎&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h1 id="mysql存储引擎">
 MySQL存储引擎
 &lt;a class="anchor" href="#mysql%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e">#&lt;/a>
&lt;/h1>
&lt;p>MySQL&lt;strong>核心&lt;/strong>在于&lt;strong>存储引擎&lt;/strong>&lt;/p>
&lt;h2 id="mysql支持哪些存储引擎默认使用哪个">
 MySQL支持哪些存储引擎？默认使用哪个？
 &lt;a class="anchor" href="#mysql%e6%94%af%e6%8c%81%e5%93%aa%e4%ba%9b%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e9%bb%98%e8%ae%a4%e4%bd%bf%e7%94%a8%e5%93%aa%e4%b8%aa">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>MySQL支持&lt;strong>多种存储引擎&lt;/strong>，可以通过&lt;code>show engines&lt;/code>命令来&lt;strong>查看MySQL支持的所有存储引擎&lt;/strong>
&lt;img src="img/ly-20241212141911409.png" alt="查看 MySQL 提供的所有存储引擎" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>默认&lt;/strong>存储引擎为InnoDB，并且，所有存储引擎中&lt;strong>只有InnoDB是事务性存储引擎&lt;/strong>，也就是说&lt;strong>只有InnoDB支持事务&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>这里使用MySQL 8.x&lt;/strong>
MySQL 5.5.5之前，MyISAM是MySQL的默认存储引擎；5.5.5之后，InnoDB是MySQL的默认存储引擎，可以通过&lt;code>select version()&lt;/code>命令查看你的MySQL版本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>mysql&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#a6e22e">version&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+-----------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">version&lt;/span>() &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+-----------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>.&lt;span style="color:#ae81ff">0&lt;/span>.&lt;span style="color:#ae81ff">27&lt;/span> &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+-----------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> row &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">set&lt;/span> (&lt;span style="color:#ae81ff">0&lt;/span>.&lt;span style="color:#ae81ff">00&lt;/span> sec) 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用&lt;code>show variables like %storage_engine%&lt;/code>命令直接查看MySQL&lt;strong>当前默认的存储引擎&lt;/strong> &lt;br>
&lt;img src="img/ly-20241212141911580.png" alt="查看 MySQL 当前默认的存储引擎" />&lt;/p></description></item><item><title>MySQL中的隐式转换造成的索引失效</title><link>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0609lyindex-invalidation-caused-by-implicit-conversion/</link><pubDate>Thu, 19 Jan 2023 17:10:48 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0609lyindex-invalidation-caused-by-implicit-conversion/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;p>本篇文章基于MySQL 5.7.26，原文：https://www.guitu18.com/post/2019/11/24/61.html&lt;/p>
&lt;/blockquote>
&lt;h1 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>关于&lt;strong>数据库优化&lt;/strong>，最常见的莫过于&lt;strong>索引失效&lt;/strong>，数据量多的时候比较明显，处理不及时会造成&lt;strong>雪球效应&lt;/strong>，最终导致&lt;strong>数据库卡死甚至瘫痪&lt;/strong>。&lt;/li>
&lt;li>这里说的是&lt;strong>隐式转换造成的索引失效&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="数据准备">
 数据准备
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%87%86%e5%a4%87">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 创建测试数据表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span> test1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>test1&lt;span style="color:#f92672">`&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(&lt;span style="color:#ae81ff">11&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>num1&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(&lt;span style="color:#ae81ff">11&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>num2&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">varchar&lt;/span>(&lt;span style="color:#ae81ff">11&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>type1&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(&lt;span style="color:#ae81ff">4&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>type2&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(&lt;span style="color:#ae81ff">4&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>str1&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">varchar&lt;/span>(&lt;span style="color:#ae81ff">100&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>str2&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">varchar&lt;/span>(&lt;span style="color:#ae81ff">100&lt;/span>) &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>num1&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>num1&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>num2&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>num2&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>type1&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>type1&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>str1&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>str1&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>str2&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>str2&lt;span style="color:#f92672">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) &lt;span style="color:#66d9ef">ENGINE&lt;/span>&lt;span style="color:#f92672">=&lt;/span>InnoDB &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">CHARSET&lt;/span>&lt;span style="color:#f92672">=&lt;/span>utf8;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 创建存储过程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">PROCEDURE&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span> pre_test1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DELIMITER &lt;span style="color:#f92672">//&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">PROCEDURE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>pre_test1&lt;span style="color:#f92672">`&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BEGIN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">DECLARE&lt;/span> i &lt;span style="color:#66d9ef">INT&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> autocommit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">WHILE&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">10000000&lt;/span> DO
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#f92672">@&lt;/span>str1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">SUBSTRING&lt;/span>(&lt;span style="color:#a6e22e">MD5&lt;/span>(&lt;span style="color:#a6e22e">RAND&lt;/span>()),&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">20&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 每100条数据str2产生一个null值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">THEN&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#f92672">@&lt;/span>str2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">ELSE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#f92672">@&lt;/span>str2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">@&lt;/span>str1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> END &lt;span style="color:#66d9ef">IF&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#a6e22e">test1&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>num1&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>num2&lt;span style="color:#f92672">`&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>type1&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>type2&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>str1&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>str2&lt;span style="color:#f92672">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">VALUES&lt;/span> (&lt;span style="color:#a6e22e">CONCAT&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, i), &lt;span style="color:#a6e22e">CONCAT&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, i),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">CONCAT&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, i), i&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>, i&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#f92672">@&lt;/span>str1, &lt;span style="color:#f92672">@&lt;/span>str2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 事务优化，每一万条数据提交一次事务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">THEN&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> COMMIT;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> END &lt;span style="color:#66d9ef">IF&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> END &lt;span style="color:#66d9ef">WHILE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>END;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">//&lt;/span> DELIMITER ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 执行存储过程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CALL&lt;/span> &lt;span style="color:#a6e22e">pre_test1&lt;/span>(); 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，七个字段，首先使用存储过程生成 1000 万条测试数据， 测试表一共建立了 7 个字段（包括主键），&lt;strong>&lt;code>num1&lt;/code>&lt;strong>和&lt;/strong>&lt;code>num2&lt;/code>&lt;strong>保存的是和&lt;code>ID&lt;/code>一样的顺序数字，其中&lt;/strong>&lt;code>num2&lt;/code>是字符串类型&lt;/strong>。 &lt;strong>&lt;code>type1&lt;/code>&lt;strong>和&lt;/strong>&lt;code>type2&lt;/code>&lt;strong>保存的都是主键对 5 的取模，目的是模拟实际应用中常用&lt;/strong>类似 type 类型&lt;/strong>的数据，但是**&lt;code>type2&lt;/code>是没有建立索引&lt;strong>的。 &lt;code>str1&lt;/code>和&lt;code>str2&lt;/code>都是保存了一个 &lt;strong>20 位长度的随机字符串&lt;/strong>，&lt;/strong>&lt;code>str1&lt;/code>不能为&lt;code>NULL&lt;/code>，&lt;code>str2&lt;/code>允许为&lt;code>NULL&lt;/code>&lt;strong>，相应的生成测试数据的时候我也会&lt;/strong>在&lt;code>str2&lt;/code>字段生产少量&lt;code>NULL&lt;/code>值**（每 100 条数据产生一个&lt;code>NULL&lt;/code>值）。&lt;/p></description></item><item><title>MySQL数据库时间类型数据存储建议</title><link>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0608lysome-thoughts-on-database-storage-time/</link><pubDate>Thu, 19 Jan 2023 17:10:06 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0608lysome-thoughts-on-database-storage-time/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="不要用字符串存储日期">
 不要用字符串存储日期
 &lt;a class="anchor" href="#%e4%b8%8d%e8%a6%81%e7%94%a8%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ad%98%e5%82%a8%e6%97%a5%e6%9c%9f">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>优点：简单直白&lt;/li>
&lt;li>缺点
&lt;ol>
&lt;li>字符串&lt;strong>占有的空间更大&lt;/strong>&lt;/li>
&lt;li>字符串存储的日期&lt;strong>效率比较低&lt;/strong>（逐个字符进行比较），&lt;strong>无法用日期相关的API&lt;/strong>进行计算和比较&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h1 id="datetime和timestamp之间抉择">
 Datetime和Timestamp之间抉择
 &lt;a class="anchor" href="#datetime%e5%92%8ctimestamp%e4%b9%8b%e9%97%b4%e6%8a%89%e6%8b%a9">#&lt;/a>
&lt;/h1>
&lt;p>Datetime 和 Timestamp 是 MySQL 提供的两种&lt;strong>比较相似&lt;/strong>的保存时间的数据类型。他们两者究竟该如何选择呢？&lt;/p>
&lt;p>&lt;strong>通常我们都会首选 Timestamp&lt;/strong>&lt;/p>
&lt;h2 id="datetime类型没有时区信息">
 Datetime类型没有时区信息
 &lt;a class="anchor" href="#datetime%e7%b1%bb%e5%9e%8b%e6%b2%a1%e6%9c%89%e6%97%b6%e5%8c%ba%e4%bf%a1%e6%81%af">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>DateTime 类型是没有时区信息的（时区无关）&lt;/strong> ，DateTime 类型保存的时间都是&lt;strong>当前会话所设置的时区&lt;/strong>对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。不要小看这个问题，很多系统就是因为这个问题闹出了很多笑话。&lt;/li>
&lt;li>&lt;strong>Timestamp 和时区有关&lt;/strong>。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是&lt;strong>在不同时区&lt;/strong>，&lt;strong>查询到同一个条记录此字段的值会不一样&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>案例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 建表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>time_zone_test&lt;span style="color:#f92672">`&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">bigint&lt;/span>(&lt;span style="color:#ae81ff">20&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">AUTO_INCREMENT&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>date_time&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">datetime&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>time_stamp&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">timestamp&lt;/span> &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">CURRENT_TIMESTAMP&lt;/span> &lt;span style="color:#66d9ef">ON&lt;/span> &lt;span style="color:#66d9ef">UPDATE&lt;/span> &lt;span style="color:#66d9ef">CURRENT_TIMESTAMP&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) &lt;span style="color:#66d9ef">ENGINE&lt;/span>&lt;span style="color:#f92672">=&lt;/span>InnoDB &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">CHARSET&lt;/span>&lt;span style="color:#f92672">=&lt;/span>utf8; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 插入数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#a6e22e">time_zone_test&lt;/span>(date_time,time_stamp) &lt;span style="color:#66d9ef">VALUES&lt;/span>(&lt;span style="color:#a6e22e">NOW&lt;/span>(),&lt;span style="color:#a6e22e">NOW&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 查看数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">select&lt;/span> date_time,time_stamp &lt;span style="color:#66d9ef">from&lt;/span> time_zone_test;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 结果
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> +---------------------+---------------------+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">| date_time | time_stamp |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">+---------------------+---------------------+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">| 2020-01-11 09:53:32 | 2020-01-11 09:53:32 |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">+---------------------+---------------------+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">------ 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改时区并查看数据&lt;/p></description></item><item><title>SQL语句在MySQL中的执行过程</title><link>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0605lyhow-sql-executed-in-mysql/</link><pubDate>Thu, 19 Jan 2023 10:20:57 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0605lyhow-sql-executed-in-mysql/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;p>原文 &lt;a href="https://github.com/kinglaw1204">https://github.com/kinglaw1204&lt;/a> 感谢作者&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>本篇文章会分析&lt;strong>一个SQL语句&lt;/strong>在MySQL的&lt;strong>执行流程&lt;/strong>，包括&lt;strong>SQL的查询&lt;/strong>在MySQL内部会怎么&lt;strong>流转&lt;/strong>，&lt;strong>SQL语句的更新&lt;/strong>是怎么完成的&lt;/li>
&lt;li>分析之前先看看&lt;strong>MySQL的基础架构&lt;/strong>，知道了MySQL由&lt;strong>哪些组件&lt;/strong>组成以及&lt;strong>这些组件的作用&lt;/strong>是什么，可以帮助我们&lt;strong>理解&lt;/strong>和&lt;strong>解决&lt;/strong>这些问题&lt;/li>
&lt;/ul>
&lt;h1 id="mysql基础架构分析">
 MySQL基础架构分析
 &lt;a class="anchor" href="#mysql%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h1>
&lt;p>&lt;img src="img/ly-20241212141908611.png" alt="ly-20241212141908611" />&lt;/p>
&lt;h2 id="mysql基本架构概览">
 MySQL基本架构概览
 &lt;a class="anchor" href="#mysql%e5%9f%ba%e6%9c%ac%e6%9e%b6%e6%9e%84%e6%a6%82%e8%a7%88">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>下图是MySQL的简要架构图，从下图可以看到&lt;strong>用户的SQL语句&lt;/strong>在MySQL内部是&lt;strong>如何执行的&lt;/strong>&lt;/li>
&lt;li>先简单介绍一个下图涉及的一些组件的基本作用
&lt;img src="img/ly-20241212141908907.png" alt="ly-20241212141908907" />
&lt;ol>
&lt;li>&lt;strong>连接器&lt;/strong>： &lt;strong>身份认证&lt;/strong>和&lt;strong>权限相关&lt;/strong>（登录MySQL的时候）&lt;/li>
&lt;li>&lt;strong>查询缓存&lt;/strong>：执行查询语句的时候，会&lt;strong>先查询缓存&lt;/strong>（MySQL8.0版本后移除，因为这个功能不太实用）&lt;/li>
&lt;li>&lt;strong>分析器&lt;/strong>：&lt;strong>没有命中&lt;/strong>缓存的话，SQL语句就会经过分析器，分析器说白了就是要&lt;strong>先看&lt;/strong>你的SQL语句干嘛，再&lt;strong>检查&lt;/strong>你的SQL语句&lt;strong>语法&lt;/strong>是否正确&lt;/li>
&lt;li>&lt;strong>优化器&lt;/strong>：按照&lt;strong>MySQL认为最优的方案&lt;/strong>去执行&lt;/li>
&lt;li>&lt;strong>执行器&lt;/strong>：&lt;strong>执行语句&lt;/strong>，然后从&lt;strong>存储引擎&lt;/strong>返回数据&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>简单来说 MySQL 主要分为 Server 层和存储引擎层：
&lt;ul>
&lt;li>&lt;strong>Server 层&lt;/strong>：主要包括&lt;strong>连接器&lt;/strong>、&lt;strong>查询缓存&lt;/strong>、&lt;strong>分析器&lt;/strong>、&lt;strong>优化器&lt;/strong>、&lt;strong>执行器&lt;/strong>等，所有&lt;strong>跨存储引擎&lt;/strong>的功能都在这一层实现，比如&lt;strong>存储过程&lt;/strong>、&lt;strong>触发器&lt;/strong>、&lt;strong>视图&lt;/strong>，&lt;strong>函数&lt;/strong>等，还有一个&lt;strong>通用的日志模块 binlog 日志模块&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>存储引擎&lt;/strong>： 主要负责数据的&lt;strong>存储&lt;/strong>和&lt;strong>读取&lt;/strong>，采用&lt;strong>可以替换的插件式架构&lt;/strong>，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 &lt;strong>redolog 模块&lt;/strong>。&lt;strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="server层基本组件介绍">
 Server层基本组件介绍
 &lt;a class="anchor" href="#server%e5%b1%82%e5%9f%ba%e6%9c%ac%e7%bb%84%e4%bb%b6%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212141909073.png" alt="ly-20241212141909073" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>连接器&lt;/strong>
连接器主要和&lt;strong>身份认证&lt;/strong>和&lt;strong>权限相关&lt;/strong>的功能相关，就好比一个级别很高的门卫一样&lt;/p>
&lt;blockquote>
&lt;p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户&lt;strong>账户密码&lt;/strong>已通过，连接器会到&lt;strong>权限表&lt;/strong>中查询&lt;strong>该用户的所有权限&lt;/strong>，之后在这个连接里的权限逻辑判断都是会依赖&lt;strong>此时读取到的权限数据&lt;/strong>，也就是说，&lt;strong>后续只要这个连接不断开&lt;/strong>，&lt;strong>即使&lt;/strong>管理员&lt;strong>修改&lt;/strong>了该用户的权限，该用户也是不受影响的。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>查询缓存（MySQL8.0 版本后移除）&lt;/strong>&lt;br>
查询缓存&lt;strong>主要用来缓存&lt;/strong>我们所执行的 &lt;strong>SELECT 语句&lt;/strong>以及该&lt;strong>语句的结果集&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>
&lt;p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 &lt;strong>Key-Value&lt;/strong> 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如&lt;strong>你对一个表更新&lt;/strong>的话，&lt;strong>这个表上的所有的查询缓存都会被清空&lt;/strong>。对于&lt;strong>不经常更新的数据&lt;/strong>来说，&lt;strong>使用缓存还是可以&lt;/strong>的。所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>MySQL &lt;strong>8.0 版本后删除了缓存&lt;/strong>的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了&lt;/p></description></item><item><title>innodb引擎对MVCC的实现</title><link>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0604lyinnodb-implementation-of-mvcc/</link><pubDate>Mon, 16 Jan 2023 19:23:55 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0604lyinnodb-implementation-of-mvcc/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="一致性非锁定读和锁定读">
 一致性非锁定读和锁定读
 &lt;a class="anchor" href="#%e4%b8%80%e8%87%b4%e6%80%a7%e9%9d%9e%e9%94%81%e5%ae%9a%e8%af%bb%e5%92%8c%e9%94%81%e5%ae%9a%e8%af%bb">#&lt;/a>
&lt;/h1>
&lt;h2 id="一致性非锁定读">
 一致性非锁定读
 &lt;a class="anchor" href="#%e4%b8%80%e8%87%b4%e6%80%a7%e9%9d%9e%e9%94%81%e5%ae%9a%e8%af%bb">#&lt;/a>
&lt;/h2>
&lt;p>★★非锁定★★&lt;/p>
&lt;ul>
&lt;li>对于&lt;strong>一致性非锁定读（Consistent Nonlocking Reads）&lt;strong>的实现，通常做法是&lt;/strong>加一个版本号&lt;/strong>或者&lt;strong>时间戳&lt;/strong>字段，在更新数据的同时&lt;strong>版本号+1&lt;/strong>或者&lt;strong>更新时间戳&lt;/strong>。查询时，将&lt;strong>当前可见的版本号&lt;/strong>与&lt;strong>对应记录的版本号&lt;/strong>进行比对，如果&lt;strong>记录的版本&lt;/strong>小于&lt;strong>可见版本&lt;/strong>，则表示&lt;strong>该记录可见&lt;/strong>&lt;/li>
&lt;li>&lt;strong>InnoDB&lt;/strong>存储引擎中，&lt;strong>多版本控制（multi versioning）&lt;strong>即是非锁定读的实现。如果读取的行&lt;/strong>正在执行DELETE&lt;/strong>或&lt;strong>UPDATE&lt;/strong>操作，这时读取操作&lt;strong>不会去等待行上&lt;/strong> &lt;strong>锁的释放&lt;/strong>.相反地，Inn哦DB存储引擎会去读取&lt;strong>行的一个快照数据&lt;/strong>，对于这种&lt;strong>读取历史数据&lt;/strong>的方式，我们叫它&lt;strong>快照读（snapshot read）&lt;/strong>。&lt;/li>
&lt;li>在 &lt;strong>&lt;code>Repeatable Read&lt;/code>&lt;/strong> 和 &lt;strong>&lt;code>Read Committed&lt;/code>&lt;/strong> 两个隔离级别下，如果是执行普通的 &lt;code>select&lt;/code> 语句（&lt;strong>不包括 &lt;code>select ... lock in share mode&lt;/code> ,&lt;code>select ... for update&lt;/code>&lt;/strong>）则会使用 &lt;strong>&lt;code>一致性非锁定读（MVCC）&lt;/code>&lt;/strong>。并且在 &lt;strong>&lt;code>Repeatable Read&lt;/code> 下 &lt;code>MVCC&lt;/code> 实现了可重复读和防止部分幻读&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="锁定读">
 锁定读
 &lt;a class="anchor" href="#%e9%94%81%e5%ae%9a%e8%af%bb">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>如果执行的是下列语句，就是&lt;strong>锁定读（Locking Reads）&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;code>select ... lock in share&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>select ... for update&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>insert &lt;/code>、&lt;code>upate&lt;/code>、&lt;code>delete&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>锁定读下，读取的是数据的最新版本，这种读也被称为&lt;strong>当前读current read&lt;/strong>。&lt;strong>锁定读&lt;/strong>会对读取到的记录加锁&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>select ... lock in share mode &lt;/code>：对(读取到的)记录加&lt;strong>S锁&lt;/strong>，其他事务也可以加S锁，如果加X锁则会被阻塞&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>select ... for update&lt;/code>、&lt;code>insert&lt;/code>、&lt;code>update&lt;/code>、&lt;code>delete&lt;/code>：对记录加&lt;strong>X锁&lt;/strong>，且其他事务不能加任何锁&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>在一致性非锁定读下，即使读取的记录&lt;strong>已被其他事务加上X锁&lt;/strong>，这时记录也是可以被读取的，即读取的&lt;strong>快照数据&lt;/strong>。&lt;/p></description></item><item><title>MySQL事务隔离级别详解</title><link>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0603lytransaction-isolation-level/</link><pubDate>Mon, 16 Jan 2023 01:00:44 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0603lytransaction-isolation-level/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="事务隔离级别总结">
 事务隔离级别总结
 &lt;a class="anchor" href="#%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>SQL标准定义了&lt;strong>四个隔离级别&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>READ-UNCOMMITTED(读取未提交)&lt;/strong>：&lt;strong>最低&lt;/strong>的隔离级别，允许读取&lt;strong>尚未提交的数据&lt;/strong>变更，可能会导致&lt;strong>脏读、幻读或不可重复读&lt;/strong>&lt;/li>
&lt;li>&lt;strong>READ-COMMITED(读取已提交)&lt;/strong>：允许读取&lt;strong>并发事务&lt;/strong> &lt;strong>已经提交&lt;/strong>的数据，可以阻止&lt;strong>脏读&lt;/strong>，但是&lt;strong>幻读&lt;/strong>或&lt;strong>不可重复读&lt;/strong>仍有可能发生&lt;/li>
&lt;li>&lt;strong>REPEATABLE-READ(可重复读)&lt;/strong>：对&lt;strong>同一字段的多次读取&lt;/strong>结果都是一致的，除非数据是被&lt;strong>本身事务自己&lt;/strong>所修改，可以&lt;strong>阻止脏读&lt;/strong>和&lt;strong>不可重复读&lt;/strong>，但&lt;strong>幻读&lt;/strong>仍有可能发生&lt;/li>
&lt;li>&lt;strong>SERIALIZABLE(可串行化)&lt;/strong>：&lt;strong>最高&lt;/strong>的隔离级别，&lt;strong>完全服从ACID&lt;/strong>的隔离级别。所有的&lt;strong>事务依次逐个&lt;/strong>执行，这样事务之间就&lt;strong>完全不可能产生干扰&lt;/strong>，也就是说，该级别可以防止&lt;strong>脏读&lt;/strong>、&lt;strong>不可重复读&lt;/strong>以及&lt;strong>幻读&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: center">隔离级别&lt;/th>
 &lt;th style="text-align: center">脏读&lt;/th>
 &lt;th style="text-align: center">不可重复读&lt;/th>
 &lt;th style="text-align: center">幻读&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: center">READ-UNCOMMITTED&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">READ-COMMITTED&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">REPEATABLE-READ&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">SERIALIZABLE&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 &lt;strong>REPEATABLE-READ（可重读）&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>使用命令查看，通过&lt;code>SELECT @@tx_isolation;&lt;/code>。&lt;br>
MySQL 8.0 该命令改为&lt;code>SELECT @@transaction_isolation;&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>MySQL&amp;gt; SELECT @@tx_isolation;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-----------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| @@tx_isolation |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-----------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| REPEATABLE-READ |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-----------------+ 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>从上面对SQL标准定义了&lt;strong>四个隔离级别&lt;/strong>的介绍可以看出，标准的SQL隔离级别里，&lt;strong>REPEATABLE-READ(可重复读)&lt;strong>是不可以防止幻读的。但是，&lt;strong>InnoDB实现的REPEATABLE-READ&lt;/strong> 隔离级别其实是可以&lt;/strong>解决幻读&lt;/strong>问题发生的，分两种情况&lt;/p>
&lt;ol>
&lt;li>&lt;strong>快照读&lt;/strong>：由&lt;strong>MVCC&lt;/strong>机制来保证不出现幻读&lt;/li>
&lt;li>&lt;strong>当前读&lt;/strong>：使用&lt;strong>Next-Key Lock&lt;/strong>进行&lt;strong>加锁&lt;/strong>来保证不出现幻读，Next-Key Lock是&lt;strong>行锁（Record Lock ）和间隙锁（Gap Lock）的结合&lt;/strong>，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖&lt;strong>间隙锁&lt;/strong> (&lt;strong>只用间隙锁不行，因为间隙锁是 &amp;gt; 或 &amp;lt; ，不包括等于，所以再可重复读下原记录可能会被删掉&lt;/strong>)&lt;/li>
&lt;/ol>
&lt;p>因为&lt;strong>隔离级别越低，事务请求的锁越少&lt;/strong>，所以大部分数据库系统的隔离级别都是 &lt;strong>READ-COMMITTED&lt;/strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 &lt;strong>REPEATABLE-READ&lt;/strong> 并不会有任何性能损失。&lt;/p></description></item><item><title>日志</title><link>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0602lymysql-logs/</link><pubDate>Sat, 14 Jan 2023 17:31:53 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0602lymysql-logs/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>首先要了解一个东西 ：WAL，全称 Write-Ahead Logging&lt;code>，它的关键点就是&lt;/code>先写日志，再写磁盘&lt;/p>
&lt;blockquote>
&lt;p>在概念上，innodb通过***force log at commit***机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;ol>
&lt;li>
&lt;p>WAL 机制的原理也很简单：&lt;strong>修改并不直接写入到数据库文件中，而是写入到另外一个称为 WAL 的文件中；如果事务失败，WAL 中的记录会被忽略，撤销修改；如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 WAL 的数据库系统不会再每新增一条 WAL 日志就将其刷入数据库文件中，一般&lt;strong>积累一定的量然后批量写入，通常使用页为单位，这是磁盘的写入单位&lt;/strong>。 同步 &lt;strong>WAL 文件和数据库文件的行为被称为 checkpoint（检查点）&lt;/strong>，一般在 WAL 文件积累到一定页数修改的时候；当然，有些系统也可以手动执行 checkpoint。执行 checkpoint 之后，WAL 文件可以被清空，这样可以保证 WAL 文件不会因为太大而性能下降。&lt;/p>
&lt;p>有些数据库系统读取请求也可以使用 WAL，通过读取 WAL 最新日志就可以获取到数据的最新状态&lt;/p>
&lt;blockquote>
&lt;p>关于checkpoint：https://www.cnblogs.com/chenpingzhao/p/5107480.html&lt;strong>思考一下这个场景&lt;/strong>：如果重做日志可以无限地增大，同时缓冲池也足够大 ，那么是不需要将缓冲池中页的新版本刷新回磁盘。因为当发生宕机时，完全可以通过重做日志来恢复整个数据库系统中的数据到宕机发生的时刻。但是这需要两个前提条件：1、缓冲池可以缓存数据库中所有的数据；2、重做日志可以无限增大&lt;/p>
&lt;p>因此Checkpoint（检查点）技术就诞生了，目的是解决以下几个问题：1、&lt;strong>缩短数据库的恢复时间&lt;/strong>；2、&lt;strong>缓冲池不够用时，将脏页刷新到磁盘&lt;/strong>；3、&lt;strong>重做日志不可用时，刷新脏页&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>当数据库发生宕机时，数据库&lt;strong>不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘&lt;/strong>。数据库只需对Checkpoint后的重做日志进行恢复，这样就大大缩短了恢复的时间。&lt;/li>
&lt;li>当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。&lt;/li>
&lt;li>当重做日志出现不可用时，因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大的，重做日志可以被重用的部分是指这些重做日志已经不再需要，当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，因此这部分就可以被覆盖重用。如果重做日志还需要使用，那么必须强制Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>mysql 的 WAL，大家可能都比较熟悉。mysql 通过 redo、undo 日志实现 WAL。redo log 称为重做日志，每当有操作时，在&lt;strong>数据变更之前将操作写入 redo log&lt;/strong>，这样当发生掉电之类的情况时系统可以在重启后继续操作。undo log 称为撤销日志，当一些变更执行到一半无法完成时，可以根据撤销日志恢复到变更之间的状态。mysql 中用 redo log 来在系统 Crash 重启之类的情况时修复数据（事务的持久性），而 undo log 来保证事务的原子性。&lt;/p></description></item><item><title>索引</title><link>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0601lymysql-index/</link><pubDate>Tue, 10 Jan 2023 22:09:25 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/study/Review/java_guide/database/MySQL/ly0601lymysql-index/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="补充索引基础知识引自b站sgg视频">
 补充索引基础知识(引自b站sgg视频)
 &lt;a class="anchor" href="#%e8%a1%a5%e5%85%85%e7%b4%a2%e5%bc%95%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86%e5%bc%95%e8%87%aab%e7%ab%99sgg%e8%a7%86%e9%a2%91">#&lt;/a>
&lt;/h1>
&lt;ol>
&lt;li>存储引擎，数据的基本单位是&lt;strong>页&lt;/strong>，如果数据很少，只有一页，那就简单，是直接二分查找(不涉及磁盘IO)；如果数据很多，有好几个页，那么需要对页建立一种数据结构，能够最快定位到哪一页，然后减少磁盘IO&lt;/li>
&lt;/ol>
&lt;h1 id="索引介绍">
 索引介绍
 &lt;a class="anchor" href="#%e7%b4%a2%e5%bc%95%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>索引是一种用于&lt;strong>快速查询&lt;/strong>和&lt;strong>检索数据&lt;/strong>的数据结构，其本质可以看成是一种&lt;strong>排序好&lt;/strong>的数据结构&lt;/p>
&lt;blockquote>
&lt;p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>索引底层数据结构存在很多种类型，常见的索引结构有：&lt;strong>B树&lt;/strong>，&lt;strong>B+树&lt;/strong>和&lt;strong>Hash&lt;/strong>、&lt;strong>红黑树&lt;/strong>。在MySQL中，无论是Innodb还是MyIsam，都使用了B+树作为索引结构&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="索引的优缺点">
 索引的优缺点
 &lt;a class="anchor" href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9">#&lt;/a>
&lt;/h1>
&lt;p>&lt;strong>优点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>使用索引可以大大&lt;strong>加快&lt;/strong> 数据的检索速度（大大&lt;strong>减少检索的数据量&lt;/strong>）, 这也是创建索引的最主要的原因。&lt;/li>
&lt;li>通过创建&lt;strong>唯一性索引&lt;/strong>，可以保证数据库表中&lt;strong>每一行数据的唯一性&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>创建索引&lt;/strong>和&lt;strong>维护索引&lt;/strong>需要&lt;strong>耗费许多&lt;/strong>时间。当对表中的数据进行&lt;strong>增删改&lt;/strong>的时候，如果数据有索引，那么&lt;strong>索引也需要动态的修改&lt;/strong>，会&lt;strong>降低 SQL 执行效率&lt;/strong>。&lt;/li>
&lt;li>索引需要使用&lt;strong>物理文件存储&lt;/strong>，也会&lt;strong>耗费一定空间&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>索引一定会提高查询性能吗&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>多数情况下，&lt;strong>索引查询&lt;/strong>都是比&lt;strong>全表扫描&lt;/strong>要快的。但是如果数据库的&lt;strong>数据量不大&lt;/strong>，那么使用&lt;strong>索引也不一定能够带来很大提升&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="索引的底层数据结构">
 索引的底层数据结构
 &lt;a class="anchor" href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h1>
&lt;h2 id="hash表">
 Hash表
 &lt;a class="anchor" href="#hash%e8%a1%a8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>哈希表是键值对的集合，通过&lt;strong>键（key）&lt;strong>即可&lt;/strong>快速取出对应的值（value）&lt;/strong>，因此哈希表可以&lt;strong>快速检索数据（接近O(1))&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为何能够通过key快速取出value呢？原因在于&lt;strong>哈希算法（也叫散列算法）&lt;/strong>。通过哈希算法，我们可以&lt;strong>快速找到key对应的index&lt;/strong>，找到了index也就找到了对应的value&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>hash &lt;span style="color:#f92672">=&lt;/span> hashfunc(key)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>index &lt;span style="color:#f92672">=&lt;/span> hash &lt;span style="color:#f92672">%&lt;/span> array_size
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，图中keys[天蓝色]是&lt;strong>字符串&lt;/strong>，&lt;strong>不是什么莫名其妙的人&lt;/strong>
&lt;img src="img/ly-20241212141858665.png" alt="ly-20241212141858665" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>哈希算法有个 &lt;strong>Hash 冲突&lt;/strong> 问题，也就是说&lt;strong>多个不同的 key 最后得到的 index 相同&lt;/strong>。通常情况下，我们常用的解决办法是 &lt;strong>链地址法&lt;/strong>。链地址法就是&lt;strong>将哈希冲突数据存放在链表中&lt;/strong>。就比如 JDK1.8 之前 &lt;code>HashMap&lt;/code> 就是通过&lt;strong>链地址法来解决哈希冲突&lt;/strong>的。不过，JDK1.8 以后&lt;code>HashMap&lt;/code>&lt;strong>为了减少链表过长&lt;/strong>的时候搜索时间过长引入了&lt;strong>红黑树&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为了减&lt;strong>少 Hash 冲突&lt;/strong>的发生，一个&lt;strong>好的哈希函数&lt;/strong>应该**“均匀地”将数据分布**在整个可能的哈希值集合中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于&lt;strong>Hash索引&lt;/strong>不支持&lt;strong>顺序&lt;/strong>和&lt;strong>范围查询&lt;/strong>，假如要对表中的数据进行&lt;strong>排序&lt;/strong>或者&lt;strong>进行范围查询&lt;/strong>，那&lt;strong>Hash索引&lt;/strong>就不行了，并且，&lt;strong>每次IO&lt;/strong>只能取一个&lt;/p>
&lt;blockquote>
&lt;p>例如： &lt;code>SELECT * FROM tb1 WHERE id &amp;lt; 500 ; &lt;/code>&lt;/p></description></item></channel></rss>