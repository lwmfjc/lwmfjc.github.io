<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>介绍 on 随记</title><link>https://lwmfjc.github.io/zh/</link><description>Recent content in 介绍 on 随记</description><generator>Hugo</generator><language>zh</language><lastBuildDate>Fri, 03 Jan 2025 09:19:53 +0000</lastBuildDate><atom:link href="https://lwmfjc.github.io/zh/index.xml" rel="self" type="application/rss+xml"/><item><title>随想</title><link>https://lwmfjc.github.io/zh/docs/life/20250103/</link><pubDate>Fri, 03 Jan 2025 09:19:53 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/life/20250103/</guid><description>&lt;ul>
&lt;li>学习知识是我们理解世界的一种方式。当知识与现实不符时，你可以说是知识错了，也可以说是你理解错了，但这都不重要，重要的是要将思维，改成与现实世界相符的方向来理解，毕竟我们是生活在现实世界中，而不是理想中。&lt;code>穷则独善其身，达则兼济天下。&lt;/code>&lt;/li>
&lt;li>用科技解释现象是一种理解世界的方式，用阴阳五行命理也是一种。最重要的是要过的心安理得，有理可循。&lt;/li>
&lt;/ul></description></item><item><title> 下编-中国文化史</title><link>https://lwmfjc.github.io/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8B%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%96%87%E5%8C%96%E5%8F%B2/</link><pubDate>Thu, 02 Jan 2025 23:23:41 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8B%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%96%87%E5%8C%96%E5%8F%B2/</guid><description>&lt;h1 id="第三十七章婚姻">
 第三十七章　婚姻
 &lt;a class="anchor" href="#%e7%ac%ac%e4%b8%89%e5%8d%81%e4%b8%83%e7%ab%a0%e5%a9%9a%e5%a7%bb">#&lt;/a>
&lt;/h1>
&lt;p>《易经》的《序卦传》说：“有天地，然后有万物；有万物，然后有男女；有男女，然后有夫妇；有夫妇，然后有父子；有父子，然后有君臣。”这是古代哲学家所推想的社会起源。他们以为隆古的社会，亦像后世一般，以一夫一妇为基本，成立一个家庭，由此互相联结，成为更大的组织。此等推想，确乎和我们根据后世的制度，以推想古代的情形的脾胃相合。所以几千年来，会奉为不刊之典。然而事实是否如此，却大是一个疑问了。&lt;/p>
&lt;p>自有历史以来，不过几千年，社会的情形，却已大有改变了。设使我们把历史抹杀了，根据现在的情形，去臆测周、秦、汉、魏、唐、宋时的状况，那给研究过历史的人听了，一定是一场大笑话，何况邃古之事，去今业已几万年几十万年呢？不知古代的真相，而妄以己意推测，其结果，必将以为自古至今，不过如此，实系因缘起灭的现象，都将认为天经地义，不可变更。这就将发生许多无谓的争执，不必要的保守，而进化的前途被其阻碍了。所以近几十年来，史前史的发现，实在是学术上的一个大进步。而其在社会组织方面，影响尤大。&lt;/p>
&lt;p>据近代社会学家所研究：人类男女之间，本来是没有什么禁例的。其后社会渐有组织，依年龄的长幼，分别辈行。当此之时，同辈行之男女，可以为婚，异辈行则否。更进，乃于亲族之间，加以限制。最初是施诸同母的兄弟姊妹的。后来渐次扩充，至凡同母系的兄弟姊妹，都不准为婚，就成所谓氏族（Sib）了。此时异氏族之间，男女仍是成群的，此一群之男，人人可为彼一群之女之夫；彼一群之女，人人可为此一群之男之妻；绝无所谓个别的夫妇。其后禁例愈繁，不许相婚之人愈多。于是一个男子，有一个正妻；一个女子，有一个正夫。然除此之外，尚非不许与其他的男女发生关系，而夫妻亦不必同居，其关系尚极疏松。更进，则夫妻必须同居（一夫一妻，或一夫多妻），关系更为永久，遂渐成后世的家庭了。所以人类的婚姻，是以全无禁例始，逐渐发生加繁其禁例，即缩小其通婚的范围，而成为今日的形态的。以一夫一妻的家庭，为原始的男女关系，实属错误。&lt;/p>
&lt;p>主张一夫一妻的家庭，为男女原始关系的形态的，不过说：人类是从猿猴进化而来的，猿猴已有家庭，何况人类？然谓猿猴均有家庭，其观察本不正确（详见李安宅译《两性社会学》附录《近代人类学与阶级心理》第四节。商务印书馆本）。即舍此勿论，猿猴也是人类祖先的旁支，而非其正系。据生物学家之说，动物的聚居，有两种形式：一如猫虎等，雌雄同居，以传种之时为限；幼儿成长，即与父母分离，是为家庭动物。一如犬马等，其聚居除传种外，兼以互相保卫为目的；历时可以甚久，为数可以甚多，是为社群动物。人类无爪牙齿角以自卫，倘使其聚居亦以家庭为限，在隆古之世，断乎无以自存，而且语言也必不会发达。所以原始人类的状况，我们虽不得而知，其为社群而非家庭，则殆无疑义。猿类的进化不如人类，以生物界的趋势论，实渐走上衰亡之路，怕正以其群居本能，不如人类之故。而反说人类的邃初，必与猿猴一样，实未免武断偏见了。何况人类的性质，如妒忌及性的羞耻等，均非先天所固有（此观小孩便可知。动物两性聚居，只有一夫一妻，一夫多妻两种形式，人类独有一妻多夫，尤妒忌非先天性质之明证）；母爱亦非专施诸子女等，足以证明其非家庭动物的，还很多呢。&lt;/p>
&lt;p>现代的家庭，与其说是源于人的本性，倒不如说是源于生活情形（道德不道德的观念，根于习惯；习惯源于生活）。据社会学家所考究：在先史时期，游猎的阶级极为普遍。游猎之民，都是喜欢掠夺的，而其时可供掠夺之物极少，女子遂成为掠夺的目的。其后虑遭报复，往往掠夺之后，遗留物件，以为交换。此时的掠夺，实已渐成为贸易。女子亦为交换品之一。是为掠夺的变相，亦开卖买的渊源。掠夺来的女子，是和部族中固有的女子，地位不同的。她是掠夺她的人的奴隶，须负担一切劳役。此既足以鼓励男子，使之从事于掠夺，又婚姻之禁例渐多，本部族中的女子，可以匹合者渐少，亦益迫令男子从事于向外掠夺。所以家庭的起源，是由于女子的奴役；而其需要，则是立在两性分工的经济原因上的。与满足性欲，实无多大关系。原始人除专属于他的女子以外，满足性欲的机会，正多着呢。游猎之民，渐进而为畜牧，其人之好战斗，喜掠夺，亦与游猎之民同（凡畜牧之民，大抵兼事田猎），而其力且加强（因其食物充足，能合大群；营养佳良，体格强壮之故），牧群须人照管，其重劳力愈甚，而掠夺之风亦益烈。只有农业是源于搜集的，最初本是女子之事。低级的农业，亦率由女子任其责。其后逐渐发达，成为生活所必资。此时经济的主权，操于女子之手。土田室屋及农具等，率为女子所有。部族中人，固不愿女子出嫁；女子势亦无从出嫁；男子与女子结婚者，不得不入居女子族中，其地位遂成为附属品。此时女子有组织，男子则无（或虽有之而不关重要），所以社会上有许多公务，其权皆操于女子之手（如参与部族会议，选举酋长等。此时之女子，亦未尝不从事于后世家务一类的事务，然其性质，亦为公务，与后世之家务，迥乎不同），实为女子的黄金时代。所谓服务婚的制度，即出现于此时。因为结婚不能徒手，而此时的男子，甚为贫乏，除劳力之外，实无可以为聘礼之物之故。其后农业更形重要，男子从事于此者益多。导致以男子为之主，而女子为之辅。于是经济的主权，再入男子之手。生活程度既高，财产渐有赢余，职业日形分化。如工商等业，亦皆为男子之事。个人私产渐兴，有财富者即有权力，不乐再向女子的氏族中作苦，乃以财物偿其部族的损失，而娶女以归。于是服务婚渐变为卖买婚，女子的地位，又形低落了。&lt;/p>
&lt;p>以上所述，都是社会学家的成说。返观我国的古事，也无乎不同。《白虎通义·三皇篇》说，古代的人，“知其母而不知其父”，这正是古代的婚姻，无所谓夫妇的证据。人类对于男女性交，毫无限制的时代，去今已远，在书本上不易找到证据。至于辈行婚的制度，则是很明白无疑的。《礼记·大传》说宗子合族之礼道：“同姓从宗合族属，异姓主名治际会。名著而男女有别。其夫属乎父道者，妻皆母道也；其夫属乎子道者，妻皆妇道也。谓弟之妻为妇者，是嫂亦可谓之母乎？名者，人治之大者也，可无慎乎？”这正是古代婚姻，但论辈行一个绝好的遗迹。这所谓同姓，是指父系时代本氏族里的人。用现在的话来说，就是老太爷、老爷、少爷们。异姓，郑《注》说：“谓来嫁者”，就是老太太、太太、少太太们。从宗，是要依着血系的枝分派别的，如先分为老大房、老二房、老三房，再各统率其所属的房分之类，参看下章自明。主名，郑《注》说：“主于妇与母之名耳。”谓但分别其辈行，而不复分别其枝派。质而言之，就是但分为老太太、太太、少太太，而不再问其孰为某之妻，孰为某之母。“谓弟之妻为妇者，是嫂亦可谓之母乎。”翻做现在的话，就是：“把弟媳妇称为少太太，算做儿媳妇一辈，那嫂嫂难道可称为老太太，算做母亲一辈么？”如此分别，就可以称为男女有别，可见古代婚姻，确有一个专论辈行的时代，在周代的宗法中，其遗迹还未尽泯。夏威夷人对于父、伯叔父、舅父，都用同一的称呼。中国人对于舅，虽有分别，父与伯叔父，母与伯叔母、从母，也是没有分别的。伯父只是大爷，叔父、季父，只是三爷、四爷罢了。再推而广之，则上一辈的人，总称为父兄，亦称父老。老与考为转注（《说文》），最初只是一语，而考为已死之父之称。下一辈则总称子弟。《公羊》何《注》说：“宋鲁之间，名结婚姻为兄弟。”（僖公二十五年）可见父母兄弟等，其初皆非专称。资本主义的社会学家说：这不是野蛮人不知道父与伯叔父、舅父之别，乃是知道了而对于他们，仍用同一的称呼。殊不知野蛮人的言语，总括的名词，虽比我们少，各别的名词却比我们多。略知训诂的人皆知之（如古鸟称雌雄，兽称牝牡，今则总称雌雄，即其一例）。既知父与伯叔父、舅父之别，而仍用同一的称呼，这在我们，实在想不出这个理由来。难者将说：父可以不知道，母总是可以知道的，为什么母字亦是通称呢？殊不知大同之世，“人不独亲其亲，不独子其子”，生物学上的母，虽止一个，社会学上的母，在上一辈中，是很普遍的。父母之恩，不在生而在养，生物学上的母，实在是无甚关系的，又何必特立专名呢？然则邃初所谓夫妇之制和家庭者安在？《尔雅·释亲》：兄弟之妻，“长妇谓稚妇为娣妇，娣妇谓长妇为姒妇”，这就是现在的妯娌。而女子同嫁一夫的，亦称先生者为姒，后生者为娣。这也是辈行婚的一个遗迹。&lt;/p>
&lt;p>社会之所以有组织，乃是用以应付环境的。其初，年龄间的区别，实在大于两性间的区别（后来受文化的影响，此等区别，才渐渐转变。《商君书·兵守篇》说，军队的组织，以壮男为一军，壮女为一军，男女之老弱者为一军，其视年龄的区别，仍重于两性的区别）。所以组织之始，是按年龄分辈分的。而婚姻的禁例，亦起于此。到后来，便渐渐依血统区别了。其禁例，大抵起于血缘亲近之人之间。违犯此等禁例者，俗语谓之“乱伦”，古语则谓之“鸟兽行”，亦谓之“禽兽行”。惩罚大抵是很严重的。至于扩而充之，对母方或父方有血缘关系之人，概不许结婚，即成同姓不婚之制（中国古代的姓，相当于现在社会学上所谓氏族，参看下章）。同姓不婚的理由，昔人说是“男女同姓，其生不蕃”（《左传》僖公二十三年郑叔詹说）。“美先尽矣，则相生疾。”（同上，昭公七年郑子产说）又说是同姓同德，异姓异德（《国语·晋语》司空季子说），好像很知道遗传及健康上的关系的。然（一）血族结婚，有害遗传，本是俗说，科学上并无证据。（二）而氏族时代所谓同姓，亦和血缘远近不符。（三）至谓其有害于健康，则更无此说。然则此等都是后来附会之说，并不是什么真正的理由。以实际言，此项禁例，所以能维持久远的，大概还是由于《礼记·郊特牲》所说的“所以附远厚别”。因为文化渐进，人和人之间，妒忌之心，渐次发达，争风吃醋的事渐多，同族之中，必有因争色而致斗乱的，于是逐渐加繁其禁例，最后，遂至一切禁断。而在古代，和亲的交际，限于血缘上有关系的人。异姓间的婚姻，虽然始于掠夺，其后则渐变为卖买，再变为聘娶，彼此之间，无复敌意，而且可以互相联络了。试看春秋战国之世，以结婚姻为外交手段者之多，便可知《郊特牲》附远二字之确。这是同姓不婚之制，所以逐渐普遍，益臻固定的理由。及其既经普遍固定之后，则制度的本身，就具有很大的威权，更不必要什么理由了。&lt;/p>
&lt;p>妒忌的感情，是何从而来的呢？前文不是说，妒忌不是人的本性么？然两性间的妒忌，虽非人之本性，而古人大率贫穷，物质上的缺乏，逼着他不能不生出产业上的嫉妒来。掠夺得来的女子，既是掠夺者的财产，自然不能不努力监视着她。其监视，固然是为着经济上的原因，然他男子设或与我的奴隶，发生性的关系，就很容易把她带走，于是占有之欲，自物而扩及于人，而和此等女子发生性的关系，亦非得其主人许可，或给以某种利益，以为交换不可了（如租凭、借贷、交换等。《左传》襄公二十八年，庆封与卢蒲嫳易内；昭公二十八年，祁胜与邬臧通室；现在有等地方，还有租妻之俗，就是这种制度的遗迹）。再进，产业上的妒忌，渐变成两性间的妒忌，而争风吃醋之事遂多。内婚的禁忌，就不得不加严，不得不加密了。所以外婚的兴起，和内婚的禁止，也是互为因果的。&lt;/p>
&lt;p>掠夺婚起于游猎时代，在中国古书上，也是确有证据的。《礼记·月令》《疏》引《世本》说：太昊始制嫁娶以俪皮为礼。托诸太昊，虽未必可信，而俪皮是两鹿皮，见《公羊》庄公二十二年何《注》，这确是猎人之物。古婚礼必用雁，其理由，怕亦不过如此。又婚礼必行之昏时，亦当和掠夺有关系。&lt;/p>
&lt;p>中国农业起于女子，捕鱼在古代，亦为女子之事，说见第四十七章。农渔之民，都是食物饶足，且居有定地的，畋猎对于社会的贡献比较少，男子在经济上的权力不大，所以服务婚之制，亦发生于此时。赘婿即其遗迹。《战国·秦策》说：太公望是齐之逐夫，当即赘婿。古代此等婚姻，在东方，怕很为普遍的。《汉书·地理志》说：齐襄公淫乱，姑姊妹不嫁。“于是下令国中：民家长女不得嫁，名曰巫儿，为家主祠，嫁者不利其家。民至今以为俗。”把此等风俗的原因，归诸人君的一道命令，其不足信，显而易见。其实齐襄公的姑姊妹不嫁，怕反系受这种风俗的影响罢？《公羊》桓公二年，有楚王妻媦之语（何《注》：媦，妹也）。可见在东南的民族，内婚制维持较久。《礼记·大传》说：“四世而缌，服之穷也。五世袒免，杀同姓也。六世亲属竭矣，其庶姓别于上（庶姓见下章），而戚单于下（单同殚），婚姻可以通乎？系之以姓而弗别，缀之以族而弗殊，虽百世而婚姻不通者，周道然也。”然则男系同族，永不通婚，只是周道。自殷以上，六世之后，婚姻就可以通的。殷也是东方之国。《汉书·地理志》又说燕国的风俗道：“初太子丹宾养勇士，不爱后宫美女，民化以为俗，至今犹然。宾客相过，以妇侍宿。嫁娶之夕，男女无别，反以为荣。后稍颇止，然终未改。”不知燕丹的举动，系受风俗的影响，反以为风俗源于燕丹，亦与其论齐襄公同病。而燕国对于性的共有制，维持较久，则于此可见。燕亦是滨海之地。然则自东南亘于东北，土性肥沃，水利丰饶，农渔二业兴盛之地，内婚制及母系氏族，都是维持较久的。父系氏族，当起于猎牧之民。此可见一切社会制度，皆以经济状况为其根本原因。&lt;/p>
&lt;p>人类对于父母亲族，总只能注意其一方，这是无可如何的。所以在母系氏族内，父方的亲族，并不禁止结婚；在父系氏族内，母方的亲族亦然；且有两个氏族，世为婚姻的。中国古代，似亦如此。所以夫之父与母之兄弟同称（舅）。夫之母与父之姊妹同称（姑）。可见母之兄弟，所娶者即父之姊妹（并非亲姊妹，不过同氏族的姊妹行而已）。而我之所嫁，亦即父之氏族中之男子，正和我之母与我之父结婚同。古代氏族，又有在氏族之中，再分支派的。如甲乙两部族，各分为一二两组。甲一之女，必与乙二之男结婚，生子则属于甲二。甲二之女，必与乙一之男结婚，生子则属于甲一。乙组的女子亦然（此系最简单之例，实际还可以更繁复）。如此，则祖孙为同族人，父子则否。中国古代，似亦如此。所以祭祀之礼：“孙可以为王父尸，子不可以为父尸。”（《礼记·曲礼》）。殇与无后者，必从祖祔食，而不从父祔食（《礼记·曾子问》）。&lt;/p>
&lt;p>近亲结婚，在法律上本有禁令的，并不限于父系。如《清津》：“娶己之姑舅两姨姊妹者，杖八十，并离异。”即是。然因此等风俗，根深柢固，法律就成为具文了。&lt;/p>
&lt;p>古代所谓同姓，是自认为出于同一始祖的（在父系氏族，则为男子。在母系氏族，则为女子），虽未必确实，他们固自以为如此。同姓与否，和血缘的远近，可谓实无关系。然他们认为同姓则同德，不可结婚，异姓则异德，可以结婚，理由虽不确实，办法尚觉一致。至后世所谓同姓，则并非同出于一源；而同出于一源的，却又不必同姓。如王莽，以姚、妫、陈、田皆黄、虞后，与己同姓，令元城王氏，勿得与四姓相嫁娶（《汉书·莽传》），而王、孙咸，以得姓不同，其女转嫁为莽妻（《汉书·传》），此等关系，后世都置诸不论了。所谓同姓异姓，只是以父系的姓，字面上的同异为据，在理论上，可谓并无理由，实属进退失据。此因同姓不婚之制，已无灵魂，仅剩躯壳之故。总而言之，现在的所谓姓氏，从各方面而论，都已毫无用处，不过是社会组织上的老废物罢了。参看下章自明。&lt;/p>
&lt;p>婚礼中的聘礼，即系卖买婚的遗迹，古礼称为“纳征”。《礼记·内则》说：“聘则为妻，奔则为妾”；《曲礼》说：“买妾不知其姓则卜之”；则买妾是真给身价的，聘妻虽具礼物，不过仅存形式，其意已不在于利益了。&lt;/p>
&lt;p>古代婚礼，传于后世的，为《仪礼》中的《士昏礼》。其节目有六：即（一）纳采（男氏遣使到女氏去求婚），（二）问名（女氏许婚之后，再请问许婚的是哪一位姑娘？因为纳采时只申明向女氏的氏族求婚，并未指明哪一个人之故），（三）纳吉（女氏说明许婚的系哪一位姑娘之后，男氏归卜之于庙。卜而得吉，再使告女氏），（四）纳征（亦谓之纳币。所纳者系玄束帛及俪皮），（五）请期（定吉日。吉日系男氏所定，三请于女氏，女氏不肯定，然后告之），（六）亲迎（新郎亲到女氏。执雁而入，揖让升堂，再拜奠雁。女父带着新娘出来，交结他。新郎带着新娘出门。新娘升车，新郎亲为之御。车轮三转之后，新郎下车，由御者代御。新郎先归，在门首等待。新娘车至，新郎揖之而入。如不亲迎的，则新郎三月后往见舅姑。亲迎之礼，儒家赞成，墨家是反对的，见《礼记·哀公问》、《墨子·非儒篇》），是为六礼。亲迎之夕，共牢而食，合卺而酳（古人的宴会，猪牛羊等，都是每人一份的。夫妻则两个人合一份，是谓同牢。把一个瓢破而为两，各用其半，以为酒器，是为合卺。这表示“合体，同尊卑”的意思）。其明天，“赞妇见于舅姑”。又明天，“舅姑共飨妇”。礼成之后，“舅姑先降自西阶（宾阶），妇降自阼阶。”（东阶，主人所行。古人说地道尊右，故让客人走西阶。）表明把家事传给他，自己变做客人的意思。此礼是限于适妇的，谓之“著代”，亦谓之“授室”。若舅姑不在，则三月而后庙见。《礼记·曾子问》说：“女未庙见而死，归葬于女氏之党，示未成妇。”诸侯嫁女，亦有致女之礼，于三月之后，遣大夫操礼而往，见《公羊》成公九年。何《注》说：“必三月者，取一时，足以别贞信。”然则古代的婚礼，是要在结婚三个月之后，才算真正成立的。若在三月之内分离，照礼意，还只算婚姻未完全成立，算不得离婚。这也可见得婚姻制度初期的疏松。&lt;/p>
&lt;p>礼经所说的婚礼，是家族制度全盛时的风俗，所以其立意，全是为家族打算的。《礼记·内则》说：“子甚宜其妻，父母不说，出。子不宜其妻，父母曰：是善事我，子行夫妇之礼焉，没身不衰。”可见家长权力之大。《昏义》说：“成妇礼，明妇顺，又申之以著代，所以重责妇顺焉也。妇顺也者，顺于舅姑，和于室人，而后当于夫，以成丝麻布帛之事，以审守委积盖藏。是故妇顺备而后内和理，内和理而后家可长久也，故圣王重之。”尤可见娶妇全为家族打算的情形。《曾子问》说：“嫁女之家，三夜不息烛，思相离也”，这是我们容易了解的。又说：“取妇之家，三日不举乐，思嗣亲也。”此意我们就不易了解了。原来现代的人，把结婚看作个人的事情，认为是结婚者的幸福，所以多有欢乐的意思。古人则把结婚看做为家族而举行的事情。儿子到长大能娶妻，父母就近于凋谢了，所以反有感伤的意思。《曲礼》说：“昏礼不贺，人之序也”，也是这个道理。此亦可见当时家族主义的昌盛，个人价值，全被埋没的一斑。&lt;/p>
&lt;p>当这时代，女子遂成为家族的奴隶，奴隶是需要忠实的，所以贞操就渐渐的被看重。“贞妇”二字，昉见于《礼记·丧服四制》。春秋时，鲁君的女儿，有一个嫁给宋国的，称为宋伯姬。一天晚上，宋国失火，伯姬说：“妇人夜出，必待傅姆。”（傅姆是老年的男女侍从。必待傅姆，是不独身夜行，以避嫌疑的意思）傅姆不至，不肯下堂，遂被火烧而死。《春秋》特书之，以示奖励（《公羊》襄公三十年）。此外儒家奖励贞节之说，还有许多，看刘向的《列女传》可知。刘向是治鲁诗的，《列女传》中，有许多是儒家相传的诗说。秦始皇会稽刻石说：“饰省宣义，有子而嫁，倍死不贞。防隔内外，禁止淫佚，男女洁诚。夫为寄豭，杀之无罪，男秉义程。妻为逃嫁，子不得母，咸化廉清。”按《管子·八观篇》说：“闾干无阖，外内交通，则男女无别矣。”又说：“食谷水，巷凿井；场圃接，树木茂；宫墙毁坏，门户不闭，外内交通；则男女之别，无自正矣。”（《汉书·地理志》说：郑国土陋而险，山居谷汲，男女亟聚会，故其俗淫）。这即是秦始皇所谓防隔内外。乃是把士大夫之家，“深宫固门，阍寺守之，男不入，女不出”的制度（见《礼记·内则》），推广到民间去。再嫁未必能有什么禁令，不过宣布其是倍死不贞，以示耻辱，正和奖励贞节，用意相同。寄豭是因奸通而寄居于女子之家的，杀之无罪；妻为逃嫁，则子不得母，其制裁却可谓严厉极了。压迫阶级所组织的国家，其政令，自然总是为压迫阶级张目的。&lt;/p>
&lt;p>虽然如此，罗马非一日之罗马，古代疏松的婚姻制度，到底非短期间所能使其十分严紧的。所以表显于古书上的婚姻，要比后世自由得多。《左传》昭公元年，载郑国徐吾犯之妹美，子南业经聘定了她，子皙又要强行纳聘。子皙是个强宗，国法奈何不得他。徐吾犯乃请使女自择，以资决定。这虽别有用意，然亦可见古代的婚嫁，男女本可自择。不过“男不亲求，女不亲许”（见《公羊》僖公十四年），必须要有个媒妁居间；又必须要“为酒食以召乡党僚友”（《礼记·典礼》），以资证明罢了。婚约的解除，也颇容易。前述三月成妇之制，在结婚三个月之后，两造的意见，觉得不合，仍可随意解除，这在今日，无论哪一国，实都无此自由。至于尚未同居，则自然更为容易。《礼记·曾子问》说：“昏礼：既纳币，有吉日，女之父母死，则如之何？孔子曰：婿使人吊。如婿之父母死，则女之家亦使人吊。婿已葬，婿之伯父，致命女氏曰：某之子有父母之丧，不得嗣为兄弟，使某致命。女氏许诺，而弗敢嫁，礼也。婿免丧，女之父母使人请，婿弗取而后嫁之，礼也。女之父母死，婿亦如之。”一方等待三年，一方反可随意解约，实属不近情理。迂儒因生种种曲说。其实这只是《礼记》文字的疏忽。孔子此等说法，自为一方遭丧而一方无意解约者言之。若其意欲解约，自然毫无限制。此乃当然之理，在当日恐亦为常行之事，其事无待论列，故孔子不之及。记者贸然下了“而弗敢嫁，礼也”六字，一似非等待不可的，就引起后人的误会了。离婚的条件，有所谓七出，亦谓之七弃（一、无子，二、淫佚，三、不事舅姑，四、口舌，五、盗窃，六、嫉妒，七、恶疾）。又有所谓三不去（一、尝更三年丧不去，二、贱取贵不去，三、有所受无所归不去）。与五不娶并列（一、丧妇长女，二、世有恶疾，三、世有刑人，四、乱家女，五、逆家女），见于《大戴礼记·本命篇》，和《公羊》庄公二十七年何《注》，皆从男子方面立说。此乃儒家斟酌习俗，认为义所当然，未必与当时的法律习惯密合。女子求去，自然也有种种条件，为法律习惯所认许的，不过无传于后罢了。观汉世妇人求去者尚甚多（如朱买臣之妻等），则知古人之于离婚，初不重视。夫死再嫁，则尤为恒事。这是到宋以后，理学盛行，士大夫之家，更看重名节，上流社会的女子，才少有再嫁的，前代并不如此。《礼记·郊特牲》说：“一与之齐，终身不改，故夫死不嫁。”这是现在讲究旧礼教的迂儒所乐道的。然一与之齐，终身不改，乃是说不得以妻为妾，并非说夫死不嫁。《白虎通义·嫁娶篇》引《郊特牲》，并无“故夫死不嫁”五字，郑《注》亦不及此义，可见此五字为后人所增。郑《注》又说：“齐或为醮”，这字也是后人所改的。不过郑氏所据之本，尚作齐字，即其所见改为醮字之本，亦尚未窜入“故夫死不嫁”五字罢了。此可见古书逐渐窜改之迹。&lt;/p>
&lt;p>后世男子的权利，愈行伸张，则其压迫女子愈甚。此可于其重视为女时的贞操，及其贱视再醮妇见之。女子的守贞，实为对于其夫之一种义务。以契约论，固然只在婚姻成立后，持续时为有效，以事实论，亦只须如此。所以野蛮社会的风俗，无不是如此的，而所谓文明社会，却有超过这限度的要求。此无他，不过压迫阶级的要求，更进一步而已。女子的离婚，在后世本较古代为难，因为古代的财产，带家族共有的意思多，一家中人，当然都有享受之份。所以除所谓有所受无所归者外，离婚的女子，都不怕穷无所归。后世的财产，渐益视为个人所有，对于已嫁大归之女，大都不愿加以扶养；而世俗又贱视再醮之妇，肯娶者少，弃妇的境遇，就更觉凄惨可怜了。法律上对于女子，亦未尝加以保护。如《清律》：“凡妻无应出及义绝之状而出之者，杖八十。虽犯七出，有三不去而出之者，减二等，追还完聚。”似乎是为无所归的女子特设的保护条文。然追还完聚之后，当如何设法保障，使其不为夫及夫之家族中人所虐待，则绝无办法。又说：“若夫妻不相和谐而两愿离者不坐。”不相和谐，即可离异，似极自由。然夫之虐待其妻者，大都榨取其妻之劳力以自利，安能得其愿离？离婚而必以两愿为条件，直使被虐待者永无脱离苦海之日。而背夫私逃之罪，则系“杖一百，从夫嫁卖”。被虐待的女子，又何以自全呢？彻底言之：现在所谓夫妇制度，本无维持之价值。然进化非一蹴所可几，即制度非旦夕所能改。以现在的立法论，在原则上当定：一、离婚之诉，自妻提出者无不许。二、其生有子女者，抚养归其母，费用则由其父负担。三、夫之财产中，其一部分，应视为其妻所应得，离婚后当给与其妻。四、夫妻异财者勿论。其同财者，嫁资应视为妻之私财，离婚时给还其妻；其业经销用者应赔偿。这固不是根本解决的办法，然在今日，立法上亦只得如此了。而在今日，立法上亦正该如此。&lt;/p>
&lt;p>古书中所载的礼，大抵是父系家庭时代的习惯风俗。后世社会组织，迄未改变，所以奉其说为天经地义。而因此等说法，被视为天经地义之故，亦有助于此制度之维持。天下事原总是互为因果的。但古书中的事实，足以表示家族主义形成前的制度的亦不少，此亦不可不注意。《礼记·礼运》：“合男女，颁爵位，必当年德。”《管子·幼官篇》，亦有“合男女”之文。合男女，即《周官》媒氏及《管子·入国篇》的合独之政。《周官》媒氏：“凡男女自成名以上，皆书年月日名焉。令男三十而娶，女二十而嫁。中春之月，令会男女。于是时也，奔者不禁（谓不备聘娶之礼，说见下）。司男女之无夫家者而会之。”合独为九惠之政之一。其文云：“取鳏寡而和合之，与田宅而家室之，三年然后事之。”此实男女妃合，不由家族主持，而由部族主持之遗迹。其初盖普遍如此。到家族发达之后，部族于通常之结婚，才置诸不管，而只干涉其违法者，而救济其不能婚嫁者了。当男女婚配由部族主持之世，结婚的年龄，和每年中结婚的季节，都是有一定的。婚年：儒家的主张，是男三十而娶，女二十而嫁。《礼记·曲礼》、《内则》等篇，都是如此。《大戴礼记·本命篇》说，这是中古之礼。太古五十而室，三十而嫁。《墨子》（《节用》）、《韩非子》（《外储说右下》），则说男二十而娶，女十五而嫁。结婚的年龄，当然不能斠若画一。王肃说：男十六而精通，女十四而能化，自此以往，便可结婚；所谓三十、二十等，乃系为之极限，使不可过。又所谓男三十，女二十，不过大致如此，并非必以三十之男，配二十之女，其说自通（见《诗·摽有梅疏》）。《大戴礼》说：三十而室，二十而嫁，天子庶人同礼。《左传》说：天子十五而生子；三十而室，乃庶人之礼（《五经异义》）。贵族生计，较庶人为宽裕，结婚年龄，可以提早，说亦可通。至《墨子》、《韩非子》之说，则系求蕃育人民之意，古代此等政令甚多，亦不足怪。所可怪者，人类生理，今古相同，婚配的要求，少壮之时，最为急切，太古时何以能迟至五十、三十？按罗维（Robert H.Lowie）所著的《初民社会》（吕叔湘译，商务印书馆本），说巴西的波洛洛人（Bororo），男女性交和结婚，并非一事。当其少年时，男女之间，早已发生性的关系，然常是过着浪漫的生活，并不专于一人。倒是年事较长，性欲较淡，彼此皆欲安居时，才择定配偶，相与同居。按人类的性质，本是多婚的。男女同居，乃为两性间的分工互助，实与性欲无甚关系。巴洛洛人的制度，实在是较为合理的。社会制度，往往早期的较后期的为合理（这是因已往的文化，多有病态，时期愈晚，病态愈深之故）。中国太古之世，婚年较晚的理由，也可以借鉴而明了。人类性欲的开始，实在二七、二八之年。自此以往，更阅数年，遂臻极盛（此系中国古说，见《素问·上古天真论》。《大戴礼记》、《韩诗外传》、《孔子家语》等说皆同），根于生理的欲念，宜宣泄不宜抑压。抑压之，往往为精神病的根源。然后世将经济上的自立，责之于既结婚的夫妇，则非十余龄的男女所及；又教养子女之责，专由父母任之，亦非十余龄的男女所能，遂不得不将结婚的年龄展缓。在近代，并有因生计艰难，而抱独身主义的。性欲受抑压而横溢，个人及社会两方面，均易招致不幸的结果。这亦是社会制度与人性不能调和的一端。倘使将经济及儿童教养的问题，和两性问题分开，就不至有此患了。所以目前的办法在以节育及儿童公育，以救济迟婚及独身问题。结婚的季节，《春秋繁露》说：“霜降逆女，冰泮杀止。”（《循天之道篇》）《荀子》同（《大略篇》）。王肃说：自九月至正月（见《诗·绸缪疏》）。其说良是。古人冬则居邑，春则居野（参看第四十二、第五十章）。结婚的月份，实在是和其聚居的时期相应的。仲春则婚时已过，至此而犹不克婚，则其贫不能备礼可知，所以奔者不禁了。&lt;/p>
&lt;p>多妻之源，起于男子的淫侈。生物界的事实，两性的数目，常大略相等。婚姻而无禁例，或虽有禁例而不严密则已，若既限定对于法定的配偶以外，不许发生性的关系，而又有若干人欲多占异性为己有，则有多占的人，即有无偶的人。所以古今中外，有夫妇之制的社会，必皆以一夫一妻为原则。但亦总有若干例外。古代贵族，妻以外发生性的关系的人有两种：一种是妻家带来的，谓之媵。一种是自己家里所固有的，谓之妾（后世媵之实消灭，故其名称亦消灭，但以妾为配偶以外发生性的关系之人之总称）。媵之义为送，即妻家送女的人（并限于女子，如伊尹为有莘氏媵臣是），与婿家跟着新郎去迎接新娘的御相同。媵御的原始，实犹今日结婚时之男女傧相，本无可发生性的关系的理由。后来有特权的男子，不止娶于一家，正妻以外的旁妻，无以名之，亦名之曰媵，媵遂有正妻以外之配偶之义。古代的婚姻，最致谨于辈行，而此规则，亦为有特权者所破坏。娶一妻者，不但兼及其娣，而且兼及其姪，于是有诸侯一娶九女之制。取一国则二国往媵，各以侄娣从。一娶九女之制，据《白虎通义·嫁娶篇》说，天子与诸侯同。亦有以为天子娶十二女的，如《春秋繁露·爵国篇》是。此恐系以天子与诸侯同礼为不安而改之。其实在古代，天子诸侯，在实际上，未必有多大的区别。《礼记·昏义》末节说：天子有一后，三夫人，九嫔，二十七世妇，八十一御妻。按《昏义》为《仪礼·士昏礼》之传，传文皆以释经，独《昏义》此节，与经无涉，文亦不类传体，其说在他处又无所见，而适与王莽立后，备和、嫔、美、御，和人三，嫔人九，美人二十七，御人八十一之制相合（见《汉书·莽传》），其为后人窜入，自无可疑。《冠义》说：“无大夫冠礼而有其昏礼？古者五十而后爵，何大夫冠礼之有？”五十而后娶，其为再娶可知。诸侯以一娶九女之故，不得再娶（《公羊》庄公十九年）。大夫若亦有媵，安得再娶？管氏有三归，孔子讥其不俭（《论语·八佾》：包咸云：三归，娶三姓女），即系讥其僭人君之礼。所以除人君以外，是决无媵的。至于妾，则为家中的女子，得与家主相接之义。家族主义发达的时代，门以内的事情，国法本不甚干涉。家主在家庭中的地位，亦无人可以制裁他。家中苟有女奴，家主要破坏她的贞操，自无从加以制裁。所以有妾与否，是个事实问题，在法律上，或者并无制限。然古代依身份而立别的习惯，是非常之多的，或有制限，亦未可知。后世等级渐平，依身份而立区别的习惯，大半消除，娶妾遂成为男子普遍的权利了。虽然如此，法律上仍有依身份之贵贱，而定妾之有无多寡的。如《唐书·百官志》：亲王有孺人二人，媵十人；二品媵八人；国公及三品媵六人；四品媵四人；五品媵三人。《明律》：民年四十以上无子者，方听娶妾，违者笞四十。但此等法律，多成具文，而在事实上，则多妻之权利，为富者所享受。适庶之别，古代颇严。因为古代等级，本来严峻，妻和妾一出于贵族，一出于贱族，其在社会上的身份，本相悬殊之故。后世等级既平，妻妾之身份，本来的相差，不如前代之甚，所以事实上贵贱之相差亦较微。仅在法律上、风俗上，因要维持家庭间的秩序，不得不略存区别而已。&lt;/p>
&lt;p>《颜氏家训》说：“江左不讳庶孽，丧室之后，多以妾媵终家事。河北鄙于侧室，不预人流，是以必须重娶，至于三四。”这是江左犹沿古代有媵不再娶的旧风，河北就荡然了。但以妾媵终家事，必本有妾媵而后能然。如其无之，自不能不再娶。再娶自不能视之为妾。《唐书·儒学传》说：“郑余庆庙有二妣，疑于袝祭，请于有司。博士韦公肃议曰：古诸侯一娶九女，故庙无二适。自秦以来有再娶，前娶后继皆适也，两袝无嫌。”自秦以来有再娶，即因封建破坏，无复一娶九女及三归等制度之故。韦公肃之议，为前娶后继，皆为适室礼文上的明据。但从礼意上说，同时不能有二嫡的，所以世俗所谓兼祧双娶，为法律所不许（大理院解释，以后娶者为妾）。&lt;/p>
&lt;p>人类的性质，本来是多婚的（男女皆然），虽由社会的势力，加以压迫，终不能改变其本性。所以压迫之力一弛，本性随即呈露。在现社会制度之下，最普遍而易见的，是为通奸与卖淫。通奸，因其为秘密之事，无从统计其多少。然就现社会和历史记载上观察，实可信其极为普遍。卖淫亦然。社会学家说：“凡是法律和习惯限制男女性交之处，即有卖淫之事，随之出现。”史家推原卖淫之始，多以为起于宗教卖淫。王书奴著《中国倡伎会》（生活书店本），亦力主此说。然原始宗教界中淫乱的现象，实未可称为卖淫。因为男女的交际，其初本极自由。后来强横的男子，虽把一部分女子占为己有，然只限于平时。至于众人集会之时，则仍须回复其故态。所以各个民族，往往大集会之时，即为男女混杂之际。如郑国之俗，三月上巳之日，于溱、洧两水之上，招魂续魄，拂除不祥，士女往观而相谑（《韩诗》说，据陈乔枞《三家诗遗说考》）。《史记·滑稽列传》载淳于髡说：“州闾之会，男女杂坐。行酒稽留，六博投壶，相引为曹。握手无罚，目眙不禁。前有堕珥，后有遗簪。”“日暮酒阑，合尊促坐。男女同席，履舄交错，杯盘狼籍。堂上烛灭，主人留髡而送客。罗襦襟解，微闻芗泽。”又如前文所引的燕国“嫁娶之夕，男女无别”都是。宗教上的寺院等，也是大众集会之地；而且是圣地；其地的习惯，是不易破坏的。《汉书·礼乐志》说：汉武帝立乐府，“采诗夜诵”。颜师古《注》说：“其言辞或秘，不可宣露，故于夜中歌诵。”按《后汉书·高句骊传》说：其俗淫。暮夜辄男女群聚为倡乐。高句骊是好祠鬼神的，而乐府之立，亦和祭礼有关。然则采诗夜诵，怕不仅因其言辞或秘罢？男女混杂之事，后世所谓邪教中，亦恒有之，正和邪有何标准？不过古代之俗，渐与后世不合，则被目为邪而已。然则宗教中初期的淫乱，实不可谓之卖淫。不过限制男女交际的自由，往往与私有财产制度，伴随而起。既有私有财产，自有所谓卖买；既有所谓卖买，淫亦自可为卖买的标的。在此情形之下，本非卖买之事，变为卖买的多了，亦不仅淫之一端。&lt;/p>
&lt;p>卖淫的根源，旧说以为起于齐之女闾。其事见于《战国策》的《东周策》。《东周策》载一个辩士的话道：“国必有诽誉。忠臣令诽在己，誉在上。齐桓公宫中七市，女闾七百，国人非之，管仲故为三归之家，以掩桓公非，自伤于民也。”则市与女闾，确为淫乐之地。《商君书·垦令篇》说：“令军市无有女子”；又说：“轻惰之民，不游军市，则农民不淫”，亦市为淫乐之地之一证。女闾则他处无文。按《太平御览》引《吴越春秋》说：“勾践输有过寡妇于山上，使士之忧思者游之，以娱其意”（今本无），亦即女闾之类。女闾，盖后世所谓女户者所聚居。女户以女为户主，可见其家中是没有壮男的。《周官》内宰：“凡建国，佐后立市”；《左传》昭公二十年，晏婴说：“内宠之妾，肆夺于市”，则古代的市，本由女子管理。所以到后来，聚居市中的女子还很多。市和女闾，都不过因其为女子聚居之所，遂成为纵淫之地罢了。其初，也未必是卖淫的。&lt;/p>
&lt;p>卖淫的又一来源，是为女乐。女乐是贵族家里的婢妾，擅长歌舞等事的，令其“执技以事上”。婢妾的贞操，本来是没有保障的，自不因其为音乐队员而有异。封建制度破坏，贵族的特权，为平民所僭者甚多，自将流布于民间。《史记·货殖列传》说：赵国的女子，“鼓鸣瑟，跕屣（现在的拖鞋，在古时为舞屣），游媚贵富，入后宫，遍诸侯。”“郑、卫俗与赵相类。”又说：“今夫赵女郑姬，设形容，揳鸣琴，揄长袂，蹑利屣，目挑心招，出不远千里，不择老少者，奔富厚也。”即其事。倡伎本来是对有技艺的人的称谓，并非专指女子。所以女子有此等技艺的，还特称为女伎。然其实是性的诱惑的成分多，欣赏其技艺的成分少。于是倡伎转变为女子卖淫者的称谓，其字也改从女旁了（即娼妓。男子之有技艺者，不复称倡伎）。为倡伎之女子，本系婢妾之流，故自古即可卖买。《战国·韩策》说：“韩卖美人，秦买之三千金”其证。后世当娼妓的，也都是经济上落伍的人，自然始终是可以买卖的了。资本的势力愈盛，遂并有买得女子，使操淫业以谋利的。古代的女伎，系婢妾所为，后世政治上还沿袭其遗制，是为乐户。系以罪人家属没入者为之。唐时，其籍属于太常。其额设的乐员，属于教坊司。此系国家的女乐队员，但因其本为贱族，贞操亦无保障，官员等皆可使之执技荐寝以自娱，是为官妓。军营中有时亦有随营的女子，则谓之营妓。民间女子卖淫的，谓之私娼。在本地的称土娼，在异乡的称流娼。清世祖顺治十六年，停止教坊女乐，改用内监。世宗雍正七年，改教坊司为和声署。是时各地方的乐户，亦皆除籍为民。于是在法律上除去一种贱族，亦无所谓官妓。但私娼在当时则是无从禁止的。律例虽有“举贡生员，宿娼者斥革”的条文，亦不过为管束举、贡、生员起见而已，并非禁娼。&lt;/p>
&lt;p>古代掠夺婚姻的习惯，仍有存于后世的。赵翼《陔余丛考》说：“村俗有以婚姻议财不谐，而纠众劫女成婚者，谓之抢亲。《北史·高昂传》：昂兄乾，求博陵崔圣念女为婚，崔不许。昂与兄往劫之。置女村外，谓兄曰：何不行礼？于是野合而归。是劫婚之事，古亦有之。然今俗劫婚，皆已经许字者，昂所劫则未字，固不同也。”按《清律》：“凡豪势之人，强夺良家妻女，奸占为妻妾者绞。配与子孙、弟侄、家人者，罪亦如之。”此指无婚姻契约而强抢的。又说：“应为婚者，虽已纳聘财，期未至，而男家强娶者，笞五十。”（指主婚人）“女家悔盟，男家不告官司强抢者，照强娶律减二等。”此即赵氏所谓已经许字之女，照法律亦有罪，但为习俗所囿，法律多不能实行。又有男女两家，因不能负担结婚时的费用，私相协议，令男家以强抢的形式出之的。则其表面为武力的，内容实为经济的了。抢孀等事，亦自古即有。《潜夫论·断讼篇》云：“贞洁寡妇，遭直不仁世叔、无义兄弟，或利其聘币，或贪其财贿，或私其儿子，则迫胁遣送，有自缢房中，饮药车上，绝命丧躯，孤捐童孩者。”又有“后夫多设人客，威力胁载者”。这其中，亦含有武力的经济的两种成分。&lt;/p>
&lt;p>卖买婚姻，则无其名而有其实。《断讼篇》又说：“诸女一许数家，虽生十子，更百赦，勿令得蒙一，还私家，则此奸绝矣。不则髡其夫妻，徙千里外剧县，乃可以毒其心而绝其后。”《抱朴子·弭讼篇》，述其姑子刘士由之论说：“末世举不修义，许而弗与。讼阋秽缛，烦塞官曹。今可使诸争婚者，未及同牢，皆听义绝，而倍还酒礼，归其币帛。其尝已再离，一倍裨聘（裨即现在赔偿的赔字）。其三绝者，再倍裨聘。如此，离者不生讼心，贪者无利重受。”葛洪又申说自己的意见道：“责裨聘倍，贫者所惮，丰于财者，则适其愿矣。后所许者，或能富殖，助其裨聘，必所甘心。然则先家拱默，不得有言，原情论之，能无怨叹乎？”葛洪之意，要令“女氏受聘，礼无丰约（谓不论聘财多少），皆以即日报版。又使时人署姓名于别版，必十人以上，以备远行及死亡。又令女之父兄若伯叔，答婿家书，必手书一纸。若有变悔而证据明者，女氏父母兄弟，皆加刑罚罪”。可见汉晋之世卖买婚姻之盛。后世契约效力较强，此等事无人敢做，但嫁女计较聘礼，娶妻觊觎妆奁，其内容还是一样的，此非经济制度改变，无法可以改良了。&lt;/p>
&lt;p>后世的婚姻，多全由父母做主，本人概不与闻，甚至有指腹为婚等恶习（见《南史·韦放传》。按《清律》，指腹为婚有禁），这诚然是很坏的。然论者遂以夫妇之道苦，概归咎于婚姻的不自由，则亦未必其然。人之性，本是多婚的，男女皆然，所以爱情很难持之永久。即使结婚之时，纯出两情爱慕，绝无别种作用，搀杂其间，尚难保其永久，何况现在的婚姻，有别种作用搀杂的，且居多数呢？欲救夫妇道苦之弊，与其审慎于结婚之时，不如宽大于离婚之际，因为爱情本有变动，结婚时无论如何审慎，也控制不住后来的变化的。习俗所以重视离婚，法律也尽力禁阻，不过是要维持家庭。然家庭制度，实不是怎么值得维持的东西，参看下章可明。&lt;/p>
&lt;p>统观两性关系，自氏族时代以后，即已渐失其正常。其理由：因女子在产育上，所负的责任，较男子为多。因而其斗争的力量，较男子为弱。不论在人类凭恃武力相斗争，或凭恃财力相斗争的时代，女子均渐沦于被保护的地位，失其独立，而附属于男子。社会的组织，宜于宽平坦荡，个个人与总体直接。若多设等级，使这一部分人，隶属于那一部分人，那不公平的制度就要逐渐发生，积久而其弊愈深了。近代女权的渐渐伸张，实因工业革命以来，女子渐加入社会的机构，非如昔日蛰居家庭之中，专做辅助男子的事情之故。女子在产育上多尽了责任，男子就该在别一方面多尽些义务，这是公道。乘此机会压迫女子，多占权利，是很不正当的。而欲实行公道，则必自铲除等级始。所以有人说：社群制度是女子之友，家庭制度是女子之敌。然则“女子回到家庭去”这口号，当然只有开倒车的人，才会去高呼了。人家都说现在的女学生坏了，不如从前旧式的女子，因其对于家政生疏了，且不耐烦。殊不知这正是现代女子进步之征兆。因为对于家政生疏，对于参与社会的工作，却熟练了。这正是小的、自私的、自利的组织，将逐渐破坏；大的、公平的、博爱的制度，将逐渐形成的征兆。贤母良妻，只是贤奴良隶。此等教育，亦只好落伍的国家去提倡。我们该教一切男女以天下为公的志愿，广大无边的组织。&lt;/p>
&lt;h1 id="第三十八章族制">
 第三十八章　族制
 &lt;a class="anchor" href="#%e7%ac%ac%e4%b8%89%e5%8d%81%e5%85%ab%e7%ab%a0%e6%97%8f%e5%88%b6">#&lt;/a>
&lt;/h1>
&lt;p>人是非团结不能生存的。当用何法团结呢？过去的事情，已非我们所能尽知；将来的事情，又非我们所能预料。我们现在只能就我们所知道的，略加说述而已。&lt;/p>
&lt;p>在有史时期，血缘是人类团结的一个重要因素。人恒狃于其所见闻，遂以此为人类团结唯一的因素，在过去都是如此，在将来也非如此不可了。其实人类的团结，并非是专恃血缘的。极远之事且勿论，即上章所说的以年龄分阶层之世，亦大率是分为老、壮、幼三辈（间有分为四辈的，但以分做三辈为最普通。《礼记·礼运》说：“使老有所终，壮有所用，幼有所长”；《论语·雍也篇》说：“老者安之，朋友信之，少者怀之”，亦都是分为三辈），而不再问其人与人间的关系的。当此之时，哪有所谓夫妇、父子、兄弟之伦呢？《礼记·礼运》说：大同之世，“人不独亲其亲，不独子其子”，《左传》载富辰的话，也说“大上以德抚民，其次亲亲，以相及也”（僖公二十四年）。可见亲族关系，是后起的情形了。&lt;/p>
&lt;p>人类愈进步，则其分化愈甚，而其组织的方法亦愈多。于是有所谓血族团体。血族团体，其初必以女子为中心。因为夫妇之伦未立，父不可知；即使可知，而父子的关系，亦不如母子之密之故。如上章所述，人类实在是社群动物，而非家庭动物，所以其聚居，并不限于两代。母及同母之人以外，又有母的母，母的同母等。自己而下推，亦是如此。逐渐成为母系氏族。每一个母系氏族，都有一个名称，是即所谓姓。一姓总有一个始祖母的，如殷之简狄，周之姜嫄即是。简狄之子契，姜嫄之子稷，都是无父而生的。因为在传说中，此等始祖母，本来无夫之故。记载上又说她俩都是帝喾之妃，一定是后来附会的（契、稷皆无父而生，见《诗·玄鸟》、《生民》。《史记·殷周本纪》所载，即是《诗》说。据陈乔枞《三家诗遗说考》所考证，太史公是用鲁诗说的。姜嫄、简狄，皆帝喾之妃，见《大戴礼记·帝系篇》。《史记·五帝本纪》，亦用其说）。&lt;/p>
&lt;p>女系氏族的权力，亦有时在男子手中（参看下章），此即所谓舅权制。此等权力，大抵兄弟相传，而不父子相继。因为兄弟是同氏族人，父子则异氏族之故。我国商朝和春秋时的鲁国、吴国，都有兄弟相及的遗迹（鲁自庄公以前，都一代传子，一代传弟，见《史记·鲁世家》），这是由于东南一带，母系氏族消灭较晚之故，已见上章。&lt;/p>
&lt;p>由于生业的转变，财产和权力，都转入男子手中，婚姻非复男子入居女子的氏族，而为女子入居男子的氏族（见上章）。于是组织亦以男为主，而母系氏族，遂变为父系氏族。商周自契稷以后，即奉契、稷为始祖，便是这种转变的一件史实。&lt;/p>
&lt;p>族之组织，是根据于血缘的。血缘之制既兴，人类自将据亲等的远近，以别亲疏。一姓的人口渐繁，又行外婚之制，则同姓的人，血缘不必亲，异姓的人，血缘或转相接近。所谓族与姓，遂不得不分化为两种组织。族制，我们所知道的，是周代的九族：一、父姓五服以内。二、姑母和他的儿子。三、姊妹和他的儿子。四、女儿和他的儿子。是为父族四；五、母的父姓，即现在所谓外家。六、母的母姓，即母亲的外家。七、母的姊妹和她们的儿子。是为母族三；八、妻之父姓。九、妻之母姓。是为妻族二。这是汉代今文家之说，见于《五经异义》（《诗·葛藟疏》引），《白虎通·宗族篇》同。古文家说，以上自高祖，下至玄孙为九族，此乃秦汉时制，其事较晚，不如今文家所说之古了。然《白虎通义》又载或说，谓尧时父母妻之族各三，周贬妻族以附父族，则今文家所说，亦已非极古之制。《白虎通义》此段，文有脱误，尧时之九族，无从知其详。然观下文引《诗》“邢侯之姨”，则其中该有妻之姊妹。总而言之：族制是随时改变的，然总是血缘上相近的人，和后世称父之同姓为族人，混同姓与同族为一不同，则是周以前所同的。九族中人，都是有服的。其无服的，则谓之党（《礼记·奔丧》郑《注》），是为父党，母党，妻党。&lt;/p>
&lt;p>同姓的人，因人口众多，血缘渐见疏远，其团结，是否因此就松懈了呢？不。所谓九族者，除父姓外，血缘上虽然亲近，却不是同居的。同姓则虽疏远而仍同居，所以生活共同，利害亦共同。在同居之时，固有其紧密的组织；即到人口多了，不能不分居，而彼此之间，仍有一定的联结，此即所谓宗法。宗法和古代的社会组织，有极大的关系。今略述其制如下：&lt;/p>
&lt;p>（一）凡同宗的人，都同奉一个始祖（均系此始祖之后）。&lt;/p>
&lt;p>（二）始祖的嫡长子，为大宗宗子。自此以后，嫡长子代代承袭，为大宗宗子。凡始祖的后人，都要尊奉他，受他的治理。穷困的却亦可以受他的救济。大宗宗子和族人的关系，是不论亲疏远近，永远如此的，是谓大宗“百世不迁”。&lt;/p>
&lt;p>（三）始祖之众子（嫡长子以外之子），皆别为小宗宗子。其嫡长子为继祢小宗。继祢小宗的嫡长子为继祖小宗。继祖小宗的嫡长子为继曾祖小宗。继曾祖小宗的嫡长子为继高祖小宗。继祢小宗，亲兄弟宗事他（受他治理，亦受他救济）。继祖小宗，从兄弟宗事他。继曾祖小宗，再从兄弟宗事他。继高祖小宗，三从兄弟宗事他。至四从兄弟，则与继六世祖之小宗宗子，亲尽无服，不再宗事他。是为小宗“五世则迁”（以一人之身论，当宗事与我同高、曾、祖、考四代的小宗宗子及大宗宗子。故曰：“小宗四，与大宗凡五。”）&lt;/p>
&lt;p>（四）如此，则或有无宗可归的人。但大宗宗子，还是要管理他，救济他的。而同出于一始祖之人，设或殇与无后，大宗的宗子，亦都得祭祀他。所以有一大宗宗子，则活人的治理、救济，死人的祭祀问题，都解决了。所以小宗可绝，大宗不可绝。大宗宗子无后，族人都当绝后以后大宗。&lt;/p>
&lt;p>以上是周代宗法的大略，见于《礼记·大传》的。《大传》所说大宗的始祖，是国君的众子。因为古者诸侯不敢祖天子，大夫不敢祖诸侯（《礼记·郊特牲》谓不敢立其庙而祭之。其实大宗的始祖，非大宗宗子，亦不敢祭。所以诸侯和天子，大夫和诸侯，大宗宗子和小宗宗子，小宗宗子和非宗子，其关系是一样的），所以国君的众子，要别立一宗。郑《注》又推而广之，及于始适异国的大夫。据此，宗法之立，实缘同出一祖的人太多了，一个承袭始祖的地位的人，管理有所不及，乃不得不随其支派，立此节级的组织，以便管理。迁居异地的人，旧时的族长，事实上无从管理他。此等组织，自然更为必要了。观此，即知宗法与封建，大有关系。因为封建是要将本族的人，分一部分出去的。有宗法的组织，则封之者和所封者之间，就可保持着一种联结了。然则宗法确能把同姓中亲尽情疏的人，联结在一起。他在九族之中，虽只联结得父姓一族。然在父姓之中，所联结者，却远较九族之制为广。怕合九族的总数，还不足以敌他。而且都是同居的人，又有严密的组织。母系氏族中，不知是否有与此相类的制度。即使有之，其功用，怕亦不如父系氏族的显著。因为氏族从母系转变到父系，本是和斗争有关系的。父系氏族而有此广大严密的组织，自然更能发挥其斗争的力量。我们所知，宗法之制，以周代为最完备，周这个氏族，在斗争上，是得到胜利的。宗法的组织，或者也是其中的一个原因。&lt;/p>
&lt;p>有族制以团结血缘相近的人，又有宗法以团结同出一祖的人，人类因血族而来的团结，可谓臻于极盛了。然而当其极盛之时，即其将衰之候。这是什么原因呢？社会组织的变化，经济实为其中最重要的原因。当进化尚浅之时，人类的互助，几于有合作而无分工。其后虽有分工，亦不甚繁复。大家所做的事，既然大致相同，又何必把过多的人联结在一起？所以人类联结的广大，是随着分工的精密而进展的。分工既密之后，自能将毫不相干的人，联结在一起。此等互相倚赖的人，虽然彼此未必相知，然总必直接间接，互相接触。接触既繁，前此因不相了解而互相猜忌的感情，就因之消除了。所以商业的兴起，实能消除异部族间敌对的感情。分工使个性显著。有特殊才能的人，容易发挥其所长，获得致富的机会。氏族中有私财的人逐渐多，卖买婚即于此时成立。说见上章。于是父权家庭成立了。孟子说：当时农夫之家，是五口和八口。说者以为一夫上父母下妻子；农民有弟，则为余夫，要另行授田（《梁惠王》及《滕文公上篇》），可见其家庭，已和现在普通的家庭一样了。士大夫之家，《仪礼·丧服传》说大功同财，似乎比农民的家庭要大些。然又说当时兄弟之间的情形道：“有东宫，有西宫，有南宫，有北宫，异居而同财。有余则归之宗，不足则资之宗。”则业已各住一所屋子，各有各的财产，不过几房之中，还保有一笔公款而已。其联结，实在是很薄弱的，和农夫的家庭，也相去无几了。在当时，只有有广大封土的人，其家庭要大些。这因为（一）他的原始，是以一氏族征服异氏族，而食其租税以自养的，所以宜于聚族而居，常作战斗的戒备。只要看《礼记》的《文王世子》，就知道古代所谓公族者，是怎样一个组织了。后来时异势殊，这种组织，实已无存在的必要。然既已习为故常，就难于猝然改革。这是一切制度，都有这惰性的。（二）其收入既多，生活日趋淫侈，家庭中管事服役的奴仆，以及技术人员，非常众多，其家庭遂特别大。这只要看《周官》的《天官》，就可以知道其情形。然此等家庭，随着封建的消灭，而亦渐趋消灭了。虽不乏新兴阶级的富豪，其自奉养，亦与素封之家无异，但毕竟是少数。于是氏族崩溃，家庭代之而兴。家庭的组织，是经济上的一个单位，所以是尽相生相养之道的。相生相养之道，是老者需人奉养，幼者需人抚育。这些事，自氏族崩溃后，既已无人负责，而专为中间一辈所谓一夫一妇者的责任。自然家庭的组织，不能不以一夫上父母下妻子为范围了。几千年以来，社会的生活情形，未曾大变，所以此种组织，迄亦未曾改变。&lt;/p>
&lt;p>看以上所述，可见族制的变迁，实以生活为其背景；而生活的变迁，则以经济为其最重要的原因。因为经济是最广泛，和社会上个个人，都有关系；而且其关系，是永远持续，无时间断的。自然对于人的影响，异常深刻，各种上层组织，都不得不随其变迁而变迁；而精神现象，亦受其左右而不自知了。在氏族时代，分工未密，一个氏族，在经济上，就是一个自给自足的团体。生活既互相倚赖，感情自然容易密切。不但对于同时的人如此，即对于以往的人亦然。因为我所赖以生存的团体，是由前人留遗下来的。一切知识技术等，亦自前辈递传给后辈。这时候的人，其生活，实与时间上已经过去的人关系深，而与空间上并时存在的人关系浅。尊祖、崇古等观念，自会油然而生。此等观念，实在是生活情形所造成的。后人不知此理，以为这是伦理道德上的当然，而要据之以制定人的生活，那就和社会进化的趋势，背道而驰了。大家族、小家庭等字样，现在的人用来，意义颇为混淆。西洋人学术上的用语，称一夫一妇，包括未婚子女的为小家庭；超过于此的为大家庭。中国社会，（一）小家庭和（二）一夫上父母下妻子的家庭，同样普遍。（三）兄弟同居的，亦自不乏。（四）至于五世同居，九世同居，宗族百口等，则为罕有的现象了。赵翼《陔余丛考》，尝统计此等极大的家庭（第四种），见于正史孝义、孝友传的：《南史》三人，《北史》十二人，《唐书》三十八人，《五代史》二人，《宋史》五十人，《元史》五人，《明史》二十六人。自然有（一）不在孝义、孝友传，而散见于他篇的；（二）又有正史不载，而见于他书的；（三）或竟未见记载的。然以中国之大，历史上时间之长，此等极大的家庭，总之是极少数，则理有可信。此等虽或由于伦理道德的提倡（顾炎武《华阴王氏宗祠记》：“程朱诸子，卓然有见于遗经。金元之代，有志者多求其说于南方，以授学者。及乎有明之初，风俗淳厚，而爱亲敬长之道，达诸天下。其能以宗法训其家人，或累世同居，称为义门者，往往而有。”可见同居之盛，由于理学家的提倡者不少），恐仍以别有原因者居多（《日知录》：“杜氏《通典》言：北齐之代，瀛、冀诸刘，清河张、宋，并州王氏，濮阳侯族，诸如此辈，将近万室。《北史·薛胤传》：为河北太守，有韩马两姓，各二千余家。今日中原北方，虽号甲族，无有至千丁者。户口之寡，族姓之衰，与江南相去敻绝。”陈宏谋《与杨朴园书》：“今直省惟闽中、江西、湖南，皆聚族而居，族各有祠。”则聚居之风，古代北盛于南，近世南盛于北，似由北齐之世，丧乱频仍，民皆合族以自卫；而南方山岭崎岖之地进化较迟，土著者既与合族而居之时，相去未远；流移者亦须合族而居，互相保卫之故）。似可认为古代氏族的遗迹，或后世家族的变态。然氏族所以崩溃，正由家族潜滋暗长于其中。此等所谓义门，纵或有古代之遗，亦必衰颓已甚。况又有因环境的特别，而把分立的家庭，硬行联结起来的。形式是而精神非，其不能持久，自然无待于言了。《后汉书·樊宏传》，说他先代三世共财，有田三百余顷。自己的田地里，就有陂渠，可以互相灌注。又有池鱼，牧畜，有求必给。“营理产业，物无所弃（这是因其生产的种类较多之故）。课役童隶，各得其宜。”（分工之法）要造器物，则先种梓漆。简直是一个大规模的生产自给自足的团体。历代类乎氏族的大家族，多有此意。此岂不问环境所可强为？然社会的广大，到底非此等大家族所能与之相敌，所以愈到后世，愈到开化的地方，其数愈少。这是类乎氏族的大家族，所以崩溃的真原因，毕竟还在经济上。但在政治上，亦自有其原因。因为所谓氏族，不但尽相生相养之责，亦有治理其族众之权。在国家兴起以后，此项权力，实与国权相冲突。所以国家在伦理上，对于此等大家族，虽或加以褒扬，而在政治上，又不得不加以摧折。所谓强宗巨家，遂多因国家的干涉，而益趋于崩溃了。略大于小家庭的家庭（第二、第三种）表面上似为伦理道德的见解所维持（历代屡有禁民父母在别籍异财等诏令，可参看《日知录》卷十三《分居》条），实则亦为经济状况所限制。因为在经济上，合则力强，分则力弱，以昔时的生活程度论，一夫一妇，在生产和消费方面，实多不能自立的。儒者以此等家庭之多，夸奖某地方风俗之厚，或且自诩其教化之功，就大谬不然了。然经济上虽有此需要，而私产制度，业已深入人心，父子兄弟之间，亦不能无分彼此。于是一方面牵于旧见解，迫于经济情形，不能不合；另一方面，则受私有财产风气的影响，而要求分；暗斗明争，家庭遂成为苦海。试看旧时伦理道德上的教训，戒人好货财、私妻子。而薄父母兄弟之说之多，便知此项家庭制度之岌岌可危。制度果然自己站得住，何须如此扶持呢？所以到近代，除极迂腐的人外，亦都不主张维持大家庭。如李绂有《别籍异财议》，即其一证。至西洋文化输入，论者更其提倡小家庭，而排斥大家庭了。然小家庭又是值得提倡的么？&lt;/p>
&lt;p>不论何等组织，总得和实际的生活相应，才能持久。小家庭制度，是否和现代人的生活相应呢？历来有句俗话，叫做“养儿防老，积谷防饥”。可见所谓家庭，实以扶养老者、抚育儿童，为其天职。然在今日，此等责任，不但苦于知识之不足（如看护病人，抚养教育儿童，均须专门知识），实亦为其力量所不及（兼日力财力言之。如一主妇不易看顾多数儿童，兼操家政。又如医药、教育的费用，不易负担）。在古代，劳力重于资本，丁多即可致富，而在今日，则适成为穷困的原因。因为生产的机键，自家庭而移于社会了，多丁不能增加生产，反要增加消费（如纺织事业）。儿童的教育，年限加长了，不但不能如从前，稍长大即为家庭挣钱，反须支出教育费。而一切家务，合之则省力，分之则多费的（如烹调、浣濯）。又因家庭范围太小，而浪费物质及劳力。男子终岁劳动，所入尚不足以赡其家。女子忙得和奴隶一般，家事还不能措置得妥帖。于是独身、晚婚等现象，相继发生。这些都是舶来品，和中国旧俗，大相径庭，然不久，其思想即已普遍于中流社会了。凡事切于生活的，总是容易风行的，从今以后，穷乡僻壤的儿女，也未必死心塌地，甘做家庭的奴隶了。固然，个人是很难打破旧制度，自定办法的。而性欲出于天然，自能把许多可怜的儿女，牵入此陈旧组织之中。然亦不过使老者不得其养，幼者不遂其长，而仍以生子不举等人为淘汰之法为救济罢了。这种现象，固已持续数千年，然在今日，业经觉悟之后，又何能坐视其如此呢？况且家庭的成立，本是以妇女的奴役为其原因的。在今日个人主义抬头，人格要受尊重的时代，妇女又何能长此被压制呢？资本主义的学者，每说动物有雌雄两性，共同鞠育其幼儿，而其同居期限，亦因以延长的，以为家庭的组织，实根于人类的天性，而无可改变。姑无论其所说动物界的情形，并不确实。即使退一步，承认其确实，而人是人，动物是动物；人虽然亦是动物之一，到底是动物中的人；人类的现象，安能以动物界的现象为限？他姑弗论，动物雌雄协力求食，即足以哺育其幼儿，人，为什么有夫妇协力，尚不能养活其子女的呢？或种动物，爱情限于家庭，而人类的爱情，超出于此以外，这正是人之所以为人，人之所以异于动物。论者不知人之爱家，乃因社会先有家庭的组织，使人之爱，以此形式而出现，正犹水之因方而为圭，遇圆而成璧；而反以为人类先有爱家之心，然后造成家庭制度；若将家庭破坏，便要“疾病不养；老幼孤独，不得其所”（《礼记·乐记》：“强者胁弱，众者暴寡；知者诈愚，勇者苦怯；疾病不养，老幼孤独，不得其所，此大乱之道也”），这真是倒果为因。殊不知家庭之制，把人分为五口八口的小团体，明明是互相倚赖的，偏使之此疆彼界，处于半敌对的地位，这正是疾病之所以不养，老幼孤独之所以不得其所。无后是中国人所引为大戚的，论者每说，这是拘于“不孝有三，无后为大”之义（《孟子·离娄上篇》）。而其以无后为不孝，则是迷信“鬼犹求食”（见《左传》宣公四年），深虑祭祀之绝。殊不知此乃古人的迷信，今人谁还迷信鬼犹求食来？其所以深虑无后，不过不愿其家之绝；所以不愿其家之绝，则由于人总有尽力经营的一件事，不忍坐视其灭亡，而家是中国人所尽力经营的，所以如此。家族之制，固然使人各分畛域，造成互相敌对的情形，然此自制度之咎，以爱家者之心论：则不但（一）夫妇、父子、兄弟之间，互尽扶养之责。（二）且推及于凡与家族有关系的人（如宗族姻亲等）。（三）并且悬念已死的祖宗。（四）以及未来不知谁何的子孙。前人传给我的基业，我必不肯毁坏，必要保持之，光大之，以传给后人，这正是极端利他心的表现。利他心是无一定形式的，在何种制度之下，即表现为何种形式。然而我们为什么要拘制着他，一定只许他在这种制度中表现呢？&lt;/p>
&lt;p>以上论族制的变迁，大略已具。现再略论继承之法。一个团体，总有一个领袖。在血缘团体之内，所谓父或母，自然很容易处于领袖地位的。父母死后，亦当然有一个继承其地位的人。女系氏族，在中国历史上，可考的有两种继承之法：（一）是以女子承袭财产，掌管祭祀。前章所述齐国的巫儿，即其遗迹。这大约是平时的族长。（二）至于战时及带有政治性质的领袖，则大约由男子尸其责，而由弟兄相及。殷代继承之法，是其遗迹。男系氏族，则由父子相继。其法又有多端：（一）如《左传》文公元年所说：“楚国之举，恒在少者。”这大约因幼子恒与父母同居，所以承袭其遗产（蒙古人之遗产，即归幼子承袭。其幼子称斡赤斤，译言守灶）。（二）至于承袭其父之威权地位，则自以长子为宜，而事实上亦以长子为易。（三）又古代妻妾，在社会上之地位亦大异。妻多出于贵族，妾则出于贱族，或竟是无母家的。古重婚姻，强大的外家及妻家，对于个人，是强有力的外援（如郑庄公的大子忽，不婚于齐，后来以无外援失位）；对于部族，亦是一个强有力的与国，所以立子又以嫡为宜。周人即系如此。以嫡为第一条件，长为第二条件。后来周代的文化，普行于全国，此项继承之法，遂为法律和习惯所共认了。然这只是承袭家长的地位，至于财产，则总是众子均分的（《清律》：分析家财、田产，不问妻、妾、婢生，但以子数均分。奸生之子，依子量与半分。无子立继者，与私生子均分）。所以中国的财产，不因遗产承袭，而生不均的问题。这是众子袭产，优于一子袭产之点。&lt;/p>
&lt;p>无后是人所不能免的，于是发生立后的问题。宗法盛行之世，有一大宗宗子，即生者的扶养，死者的祭祀，都可以不成问题，所以立后问题，容易解决。宗法既废，势非人人有后不可，就难了。在此情形之下，解决之法有三：（一）以女为后。（二）任立一人为后，不问其为同异姓。（三）在同姓中择立一人为后。（一）于情理最近，但宗祧继承，非徒承袭财产，亦兼掌管祭祀。以女为后，是和习惯相反的（春秋时，郑国以外孙为后，其外孙是莒国的儿子，《春秋》遂书“莒人灭郑”，见《公羊》襄公五、六年。按此实在是论国君承袭的，乃公法上的关系，然后世把经义普遍推行之于各方面，亦不管其为公法私法了）。既和习惯相反，则觊觎财产的人，势必群起而攻，官厅格于习俗，势必不能切实保护。本欲保其家的，或反因此而发生纠纷，所以势不能行。（二）即所谓养子，与家族主义的重视血统，而欲保其纯洁的趋势不合。于是只剩得第（三）的一途。法律欲维持传统观念，禁立异姓为后，在同姓中并禁乱昭穆之序（谓必辈行相当，如不得以弟为子等。其实此为古人所不禁，所谓“为人后者为之子”，见《公羊》成公十五年）。于是欲人人有后益难，清高宗时，乃立兼祧之法，以济其穷（一人可承数房之祀。生子多者，仍依次序，分承各房之后。依律例：大宗子兼祧小宗，小宗子兼祧大宗，皆以大宗为重，为大宗父母服三年，为小宗父母服期。小宗子兼祧小宗，以本生为重，为本生父母服三年，为兼祧父母服期。此所谓大宗，指长房，所谓小宗，指次房以下，与古所谓大宗小宗者异义。世俗有为本生父母及所兼祧之父母均服三年的，与律例不合）。宗祧继承之法，进化至此，可谓无遗憾了。然其间却有一难题。私有财产之世，法律理应保护个人的产权。他要给谁就给谁，要不给谁就不给谁。为后之子，既兼有承袭财产之权利，而法律上替他规定了种种条件，就不啻干涉其财产的传授了。于是传统的伦理观念，和私有财产制度，发生了冲突。到底传统的伦理观念是个陈旧不切实际的东西，表面上虽然像煞有介事，很有威权，实际上已和现代人的观念不合了。私有财产制度，乃现社会的秩序的根柢，谁能加以摇动？于是冲突之下，伦理观念，乃不得不败北而让步。法律上乃不得不承认所谓立爱，而且多方保护其产权（《清律例》：继子不得于所后之亲，听其告官别立。其或择立贤能，及所亲爱者，不许宗族以次序告争，并官司受理）。至于养子，法律虽禁其为嗣（实际上仍有之），亦不得不听其存在，且不得不听其酌给财产（亦见《清律例》）。因为国家到底是全国人民的国家，在可能范围内，必须兼顾全国人民各方面的要求，不能专代表家族的排外自私之念。在现制度之下，既不能无流离失所之人；家族主义者流，既勇于争袭遗产，而怯于收养同宗；有异姓的人肯收养他，国家其势说不出要禁止。不但说不出要禁止，在代表人道主义和维持治安的立场上说，无宁还是国家所希望的。既承认养子的存在，在事实上，自不得不听其酌给遗产了。这也是偏私的家族观念，对于公平的人道主义的让步，也可说是伦理观念的进步。&lt;/p>
&lt;p>假使宗祧继承的意思，而真是专于宗祧继承，则拥护同姓之男，排斥亲生之女，倒也还使人心服。因为立嗣之意，无非欲保其家，而家族的存在，是带着几分斗争性质的。在现制度之下，使男子从事于斗争，确较女子为适宜（这并非从个人的身心能力上言，乃是从社会关系上言），这也是事实。无如世俗争继的，口在宗祧，心存财产，都是前人所谓“其言蔼如，其心不可问”的。如此而霸占无子者的财产，排斥其亲生女，就未免使人不服了。所以有国民政府以来，废止宗祧继承，男女均分遗产的立法。这件事于理固当，而在短时间内，能否推行尽利，却是问题。旧律，遗产本是无男归女，无女入官的（近人笔记云：“宋初新定《刑统》，户绝资产下引《丧葬令》；诸身丧户绝者，所有部曲、客女、奴婢、店宅、资财，并令近亲转易货卖，将营葬事，及量营功德之外，余财并与女。无女均入以次近亲。无亲戚者，官为检校。若亡人在日，自有遗嘱处分，证验分明者，不用此令。此《丧葬令》乃《唐令》，知唐时所谓户绝，不必无近亲。虽有近亲，为营丧葬，不必立近亲为嗣子，而远亲不能争嗣，更无论矣。虽有近亲，为之处分，所余财产，仍传之亲女，而远亲不能争产，更无论矣。此盖先世相传之法，不始于唐。”按部曲、客女，见第四十章）。入官非人情所愿，强力推行，必多流弊，或至窒碍难行（如隐匿遗产，或近亲不易查明，以致事悬不决，其间更生他弊等）。归之亲女，最协人情。然从前的立嗣，除祭祀外，尚有一年老奉养的问题。而家族主义，是自私的。男系家族，尤其以男子为本位，而蔑视女子的人格。女子出嫁之后，更欲奉养其父母，势实有所为难。所以旧时论立嗣问题的人，都说最好是听其择立一人为嗣，主其奉养、丧葬、祭祀，而承袭其遗产。这不啻以本人的遗产，换得一个垂老的扶养，和死后的丧葬祭祀。今欲破除迷信，祭祀固无问题，对于奉养及丧葬，似亦不可无善法解决。不有遗产以为交易，在私有制度之下，谁肯顾及他人的生养死葬呢？所以有子者遗产男女均分，倒无问题，无子者财产全归于女，倒是有问题的。所以变法贵全变，革命要彻底。枝枝节节而为之，总只是头痛医头，脚痛医脚的对症疗法。&lt;/p>
&lt;p>姓氏的变迁，今亦须更一陈论。姓的起源，是氏族的称号，由女系易而为男系，说已见前。后来姓之外又有所谓氏。什么叫做氏呢？氏是所以表一姓之中的支派的。如后稷之后都姓姬，周公封于周，则以周为氏；其子伯禽封于鲁，则以鲁为氏（国君即以国为氏）；鲁桓公的三子，又分为孟孙、叔孙、季孙三氏是。始祖之姓，谓之正姓，氏亦谓之庶姓。正姓是永远不改的，庶姓则随时可改。因为同出于一祖的人太多了，其支分派别，亦不可无专名以表之，而专名沿袭太久，则共此一名的人太多，所以又不得不改（改氏的原因甚多，此只举其要改的根本原理。此外如因避难故而改氏以示别族等，亦是改氏的一种原因）。《后汉书·羌传》说：羌人种姓中，出了一个豪健的人，便要改用他的名字做种姓。如爰剑之后，五世至研，豪健，其子孙改称研种；十三世至烧当，复豪健，其子孙又改称烧当种是。这正和我国古代的改氏，原理相同。假如我们在鲁国，遇见一个人，问他尊姓，他说姓姬。这固然足以表示他和鲁君是一家。然而鲁君一家的人太多了，鲁君未必能个个照顾到，这个人，就未必一定有势力，我们听了，也未必肃然起敬。假若问他贵氏，他说是季孙，我们就知道他是赫赫有名的正卿的一家。正卿的同族，较之国君的同姓，人数要少些，其和正卿的关系，必较密切，我们闻言之下，就觉得炙手可热，不敢轻慢于他了。这是举其一端，其余可以类推（如以技为官，以官为氏，问其氏，即既可知其官，又可知其技）。所以古人的氏，确是有用的。至于正姓，虽不若庶姓的亲切，然婚姻之可通与否，全论正姓的异同。所以也是有用的。顾炎武《原姓篇》说春秋以前，男子称氏，女子称姓（在室冠之以序，如叔隗、季隗之类。出嫁，更冠以其夫之氏族，如宋伯姬、赵姬、卢蒲姜之类。在其所适之族，不必举出自己的氏族来，则亦以其父之氏族冠之，如骊姬、梁嬴之类。又有冠之以谥的，如成风、敬姜之类），这不是男子不论姓，不过举氏则姓可知罢了。女子和社会上无甚关系，所以但称姓而不称其氏，这又可以见得氏的作用。&lt;/p>
&lt;p>贵族的世系，在古代是有史官为之记载的。此即《周官》小史之职。记载天子世系的，谓之帝系；记载诸侯卿大夫世系的，谓之世本。这不过是后来的异名，其初原是一物。又瞽矇之职，“讽诵诗，世奠系”（疑当作奠世系）。《注》引杜子春说：谓瞽矇“主诵诗，并诵世系”。世系而可诵，似乎除统绪之外，还有其性行事迹等。颇疑《大戴礼记》的《帝系姓》，原出于小史所记；《五帝德》则是原出于瞽矇所诵的（自然不是完全的），这是说贵族。至于平民，既无人代他记载，而他自己又不能记载，遂有昧于其所自出的。《礼记·曲礼》谓买妾不知其姓，即由于此。然而后世的士大夫，亦多不知其姓氏之所由来的。这因为谱牒掌于史官，封建政体的崩溃，国破家亡，谱牒散失，自然不能知其姓氏之所由来了。婚姻的可通与否，既不复论古代的姓，新造姓氏之事亦甚少。即有之，亦历久不改。阅一时焉，即不复能表示其切近的关系，而为大多数人之所共，与古之正姓同。姓遂成为无用的长物，不过以其为人人之所有，囿于习惯，不能废除罢了。然各地方的强宗巨家，姓氏之所由来，虽不可知，而其在实际上的势力自在。各地方的人，也还尊奉他。在秦汉之世，习为固然，不受众人的注意。汉末大乱，各地方的强宗巨家，开始播迁，到了一个新地方，还要表明其本系某地方的某姓；而此时的选举制度，又重视门阀。于是又看重家世，而有魏晋以来的谱学了。见第四十章。&lt;/p>
&lt;h1 id="第三十九章政体">
 第三十九章　政体
 &lt;a class="anchor" href="#%e7%ac%ac%e4%b8%89%e5%8d%81%e4%b9%9d%e7%ab%a0%e6%94%bf%e4%bd%93">#&lt;/a>
&lt;/h1>
&lt;p>社会发达到一定的程度，国家就出现了。在国家出现之前，人类团结的方法，只靠血缘，其时重要的组织，就是氏族，对内的治理，对外的防御，都靠着它。世运渐进，血缘相异的人，接触渐多，人类的组织，遂不复以血统相同为限，聚居一地方的，亦不限于血统相同的人。于是氏族进而为部落。统治者的资格，非复族长而为酋长。其统治亦兼论地域，开国家领土的先河了。&lt;/p>
&lt;p>从氏族变为部落，大概经过这样的情形。在氏族的内部，因职业的分化，家族渐渐兴起。氏族的本身，遂至崩溃。各家族非如其在氏族时代，绝对平等，而有贫富之分。财富即是权力，氏族平和的情形，遂渐渐破坏，贫者和富者之间，发生了矛盾，不得不用权力统治。其在异氏族之间，则战斗甚烈。胜者以败者为俘虏，使服劳役，是为奴隶。其但征收其贡赋的，则为农奴。农奴、奴隶和主人之间，自然有更大的矛盾，需要强力镇压。因此故，益促成征服氏族的本身，发生变化。征服氏族的全体，是为平民。其中掌握事权的若干人，形成贵族。贵族中如有一个最高的首领，即为君主的前身。其初是贵族与平民相去近，平民和农奴、奴隶相去远。其后血统相同的作用渐微，掌握政权与否之关系渐大，则平民与农奴、奴隶相去转近，而其与贵族相去转远（参看下章）。但平民总仍略有参政之权，农奴和奴隶则否。政权的决定，在名义上最后属于一人的，是为君主政体。属于较少数人的，是为贵族政体。属于较多数人的，是为民主政体。这种分类之法，是出于亚里斯多德（Aristotle）的。虽与今日情形不同，然以论古代的政体，则仍觉其适合。&lt;/p>
&lt;p>氏族与部落，在实际上，是不易严密区分的。因为进化到部落时代，其内部，总还保有若干氏族时代的意味。从理论上言，则其团结，由于血统相同（虽实际未必相同，然苟被收容于其团体之内，即亦和血统相同的人，一律看待），而其统治，亦全本于亲族关系的，则为氏族。其不然的，则为部落。因其二者杂糅，不易区别，我们亦可借用《辽史》上的名词，称之为部族（见《营卫志》）。至于古代所谓国家，其意义，全和现在不同。古所谓国，是指诸侯的私产言之。包括（一）其住居之所，（二）及其有收益的土地。大夫之所谓家者亦然（古书上所谓国，多指诸侯的都城言。都城的起源，即为诸侯的住所。诸侯的封域以内，以财产意义言，并非全属诸侯所私有。其一部分，还是要用以分封的。对于此等地方，诸侯仅能收其贡而不能收其税赋。其能直接收其税赋，以为财产上的收入的，亦限于诸侯的采地。《尚书大传》说：“古者诸侯始受封，必有采地。其后子孙虽有罪黜，其采地不黜，使子孙贤者守之世世，以祠其始受封之人，此之谓兴灭国，继绝世”，即指此。采地从财产上论，是应该包括于国字之内的。《礼记·礼运》说：“天子有田以处其子孙，诸侯有国以处其子孙。”乃所谓互言以相备。说天子有田，即见得诸侯亦有田；说诸侯有国，即见得天子亦有国。在此等用法之下，田字的意义，亦包括国，国字的意义，亦包括田。乃古人语法如此）。今之所谓国家，古无此语。必欲求其相近的，则为“社稷”二字或“邦”字。社是土神，稷是谷神，是住居于同一地方的人，所共同崇奉的。故说社稷沦亡，即有整个团体覆灭之意。邦和封是一语。封之义为累土。两个部族交界之处，把土堆高些，以为标识，则谓之封。引申起来，任用何种方法，以表示疆界，都可以谓之封（如掘土为沟，以示疆界，亦可谓之封。故今辽宁省内，有地名沟帮子。帮字即邦字，亦即封字。上海洋泾浜之浜字，亦当作封）。疆界所至之地，即谓之邦。古邦字和国字，意义本各不同。汉高祖名邦，汉人讳邦字，都改作国。于是国字和邦字的意义混淆了。现在古书中有若干国字，本来是当作邦字的。如《诗经》里的“日辟国百里”、“日蹙国百里”便是。封域可以时有赢缩，城郭是不能时时改造的（國与域同从或声，其初当亦系一语，则国亦有界域之意。然久已分化为两语了。古书中用国字域字，十之九，意义是不同的）。&lt;/p>
&lt;p>贵族政体和民主政体，在古书上，亦未尝无相类的制度。然以大体言之，则君权之在中国，极为发达。君主的第一个资格，是从氏族时代的族长，沿袭而来的，所以古书上总说君是民之父母。其二则为政治或军事上之首领。其三则兼为宗教上之首领。所以天子祭天地，诸侯祭社稷等（《礼记·王制》），均有代表其群下而为祭司之权，而《书经》上说：“天降下民，作之君，作之师”（《孟子·梁惠王下篇》引），君主又操有最高的教育之权。&lt;/p>
&lt;p>君主前身，既然是氏族的族长，所以他的继承法，亦即是氏族族长的继承法。已见前章。在母系社会，则为兄终弟及，在父系社会，则为父死子继。当其为氏族族长时，无甚权利可争，而其关系亦小，所以立法并不十分精密。《左传》昭公二十六年，王子朝告诸侯，说周朝的继承法，适庶相同则论年，“年钧以德，德钧则卜”。两个人同年，是很容易的事情，同月，同日，同时则甚难，何至辨不出长幼来，而要用德、卜等漫无标准的条件？可见旧法并不甚密。《公羊》隐公元年何《注》说：“礼：适夫人无子，立右媵。右媵无子，立左媵。左媵无子，立适姪娣。适姪娣无子，立右媵姪娣。右媵姪娣无子，立左媵姪娣。质家亲亲先立娣。文家尊尊先立姪（《春秋》以殷为质家，周为文家），适子有孙而死，质家亲亲先立弟，文家尊尊先立孙。其双生，质家据见立先生，文家据本意立后生。”定得非常严密。这是后人因国君的继承，关系重大而为之补充的，乃系学说而非事实。&lt;/p>
&lt;p>周厉王被逐，宣王未立，周召二公，共和行政，凡十四年。主权不属于一人，和欧洲的贵族政体，最为相像。按《左传》襄公十四年，卫献公出奔，卫人立公孙剽，孙林父、甯殖相之，以听命于诸侯，此虽有君，实权皆在二相，和周召的共和，实际也有些相像。但形式上还是有君的。至于鲁昭公出奔，则鲁国亦并未立君，季氏对于国政，决不能一人专断，和共和之治，相像更甚了。可见贵族政体，古代亦有其端倪，不过未曾发达而成为一种制度。&lt;/p>
&lt;p>至于民主政治，则其遗迹更多了。我们简直可以说：古代是确有这种制度，而后来才破坏掉的。《周官》有大询于众庶之法，乡大夫“各帅其乡之众寡而致于朝”，小司寇“摈以序进而问焉”。其事项：为询国危，询国迁，询立君。按《左传》定公八年，卫侯欲叛晋，朝国人，使王孙贾问焉。哀公元年，吴召陈怀公，怀公亦朝国人而问，此即所谓询国危；盘庚要迁都于殷，人民不肯，盘庚“命众悉造于庭”，反复晓谕。其言，即今《书经》里的《盘庚篇》。周太王要迁居于岐，“属其父老而告之”（《孟子·梁惠王下篇》），此即所谓询国迁；《左传》昭公二十四年，周朝的王子朝和敬王争立，晋侯使士景伯往问。士伯立于乾祭（城门名），而问于介众（介众，大众）。哀公二十六年，越人纳卫侯，卫人亦致众而问。此即所谓询立君。可见《周官》之言，系根据古代政治上的习惯，并非理想之谈。《书经·洪范》：“汝则有大疑，谋及乃心，谋及卿士，谋及庶人，谋及卜筮。汝则从，龟从，筮从，卿士从，庶民从，是之谓大同。身其康强，子孙其逢，吉。汝则从，龟从，筮从，卿士逆，庶民逆，吉。卿士从，龟从，筮从，汝则逆，庶民逆，吉。庶民从，龟从，筮从，汝则逆，卿士逆，吉。汝则从，龟从，筮逆，卿士逆，庶民逆，作内吉，作外凶。龟筮共违于人，用静吉，用作凶。”此以一君主，二卿士，三庶人，四龟，五筮，各占一权，而以其多少数定吉凶，亦必系一种会议之法。并非随意询问。至于随意询问之事，如《孟子》所谓“国人皆曰贤，然后察之，见贤焉，然后用之”，“国人皆曰不可，然后察之，见不可焉，然后去之”，“国人皆曰可杀，然后察之，见可杀焉，然后杀之”（《梁惠王下篇》），以及《管子》所谓啧室之议等（见《桓公问篇》），似乎不过是周谘博采，并无必从的义务。然其初怕亦不然。野蛮部落，内部和同，无甚矛盾，舆论自极忠实。有大事及疑难之事，会议时竟有须全体通过，然后能行，并无所谓多数决的。然则舆论到后来，虽然效力渐薄，竟有如郑人游于乡校，以议执政，而然明欲毁乡校之事（见《左传》襄公三十年）。然在古初，必能影响行政，使当局者不能不从，又理有可信了。原始的制度，总是民主的。到后来，各方面的利害、冲突既深；政治的性质，亦益复杂，才变而由少数人专断。这是普遍的现象，无足怀疑的。有人说：中国自古就是专制，国人的政治能力，实在不及西人，固然抹杀史实。有人举此等民权遗迹以自豪，也是可以不必的。&lt;/p>
&lt;p>以上所述，是各部族内部的情形。至于合全国而观之，则是时正在部族林立之世。从前的史家，率称统一以前为封建时代，此语颇须斟酌。学术上的用语，不该太拘于文字的初诂。封建二字，原不妨扩而充之，兼包列国并立的事实，不必泥定字面，要有一个封他的人。然列国本来并立，和有一个封他的人，二者之间，究应立一区别。我以为昔人所谓封建时代，应再分为（一）部族时代，或称先封建时代；（二）封建时代较妥。所谓封建，应指（甲）慑服异部族，使其表示服从；（乙）打破异部族，改立自己的人为酋长；（丙）使本部族移殖于外言之。&lt;/p></description></item><item><title>上编-中国政治史</title><link>https://lwmfjc.github.io/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8A%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%8F%B2/</link><pubDate>Thu, 02 Jan 2025 23:20:15 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E4%B8%8A%E7%AF%87-%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB%E5%8F%B2/</guid><description>&lt;h1 id="第一章中国民族的由来">
 第一章　中国民族的由来
 &lt;a class="anchor" href="#%e7%ac%ac%e4%b8%80%e7%ab%a0%e4%b8%ad%e5%9b%bd%e6%b0%91%e6%97%8f%e7%9a%84%e7%94%b1%e6%9d%a5">#&lt;/a>
&lt;/h1>
&lt;p>社会是整个的，作起文化史来，分门别类，不过是我们分从各方面观察，讲到最后的目的，原是要集合各方面，以说明一个社会的盛衰，即其循着曲线进化的状况的。但是这件事很不容易。史事亡失的多了，我们现在，对于各方面，所知道的多很模糊（不但古代史籍缺乏之时，即至后世，史籍号称完备，然我们所要知道的事，仍很缺乏而多伪误。用现代新史学的眼光看起来，现在人类对于过去的知识，实在是很贫乏的），贸贸然据不完不备的材料，来说明一时代的盛衰，往往易流于武断。而且从中学到大学，永远是以时为经、以事为纬的，将各时代的事情，复述一遍，虽然详略不同，而看法失之单纯，亦难于引起兴趣。所以我这部书，变换一个方法，下册依文化的项目，把历代的情形，加以叙述，这一册依据时代，略述历代的盛衰。读者在读这一册时，对于历代的社会状况，阅读下册就会略有所知，则涉及时措辞可以从略，不至有头绪纷繁之苦；而于历代盛衰的原因，亦更易于明了了。&lt;/p>
&lt;p>叙述历代的盛衰，此即向来所谓政治史。中国从前的历史，所以被人讥诮为帝王的家谱，为相斫书，都由其偏重这一方面之故。然而矫枉过正，以为这一方面，可以视为无足重轻，也是不对的。现在的人民，正和生物在进化的中途需要外骨保护一样。这话怎样说呢？世界尚未臻于大同之境，人类不能免于彼此对立，就不免要靠着武力或者别种力量互相剥削。在一个团体之内，虽然有更高的权力，以评判其是非曲直，而制止其不正当的竞争，在各个团体之间，却至今还没有，到被外力侵犯之时，即不得不以强力自卫，此团体即所谓国家。一个国家之中，总包含着许多目的简单，有意用人力组成的团体，如实业团体、文化团体等都是。此等团体，和别一个国家内性质相同的团体，是用不着分界限的，能合作固好，能合并则更好。无如世界上现在还有用强力压迫人家，掠夺人家的事情，我们没有组织，就要受到人家的压迫、掠夺，而浸至无以自存了。这是现今时代国家所以重要的原因。世界上的人多着呢？为什么有些人能合组一个国家，有些人却要分做两国呢？这个原因，最重要的，就是民族的异同，而民族的根柢，则为文化。世界文化的发达，其无形的目的，总是向着大同之路走的，但非一蹴可几。未能至于大同之时，则文化相同的人民可以结为一体，通力合作，以共御外侮；文化不相同的则不能然，此即民族国家形成的原理。在现今世界上，非民族的国家固多，然总不甚稳固。其内部能平和相处，强大民族承认弱小民族自决权利的还好，其不然的，往往演成极激烈的争斗；而一民族强被分割的，亦必出死力以求其合，这是世界史上数见不鲜的事。所以民族国家，在现今，实在是一个最重要的组织。若干人民，其文化能互相融和而成为一个民族，一个民族而能建立一个强固的国家，都是很不容易的事。苟其能之，则这一个国家，就是这一个民族在今日世界上所以自卫，而对世界的进化尽更大的责任的良好工具了。&lt;/p>
&lt;p>中国是世界上最大的一个民族国家，这是无待于言的。一个大民族，固然总是融合许多小民族而成，然其中亦必有一主体。为中国民族主体的，无疑是汉族了。汉族的由来，在从前是很少有人提及的。这是因为从前人地理知识的浅薄，不知道中国以外还有许多地方之故。至于记载邃古的时代，自然是没有的。后来虽然有了，然距邃古的时代业已很远，又为神话的外衣所蒙蔽。一个民族不能自知其最古的历史，正和一个人不能自知其极小时候的情形一样。如其开化较晚，而其邻近有先进的民族，这一个民族的古史，原可藉那一个民族而流传，中国却又无有。那么，中国民族最古的情形，自然无从知道了。直至最近，中国民族的由来，才有人加以考究，而其初还是西人，到后来，中国人才渐加注意。从前最占势力的是“西来说”，即说中国民族，自西方高地而来。其中尤被人相信的，为中国民族来自黄河上源昆仑山之说。此所谓黄河上源，乃指今新疆的于阗河；所谓昆仑山，即指于阗河上源之山。这是因为：一、中国的开化，起于黄河流域；二、汉武帝时，汉使穷河源，说河源出于于阗。《史记·大宛列传》说，天子案古图书，河源出于昆仑。后人因汉代去古未远，相信武帝所案，必非无据之故。其实黄河上源，明明不出于阗。若说于阗河伏流地下，南出而为黄河上源，则为地势所不容，明明是个曲说。而昆仑的地名，在古书里也是很神秘的，并不能实指其处，这只要看《楚辞》的《招魂》、《淮南子》的《地形训》和《山海经》便知。所以以汉族开化起于黄河流域，而疑其来自黄河上源，因此而信今新疆西南部的山为汉族发祥之地，根据实在很薄弱。这一说，在旧时诸说中，是最有故书雅记做根据的，而犹如此，其他更不必论了。&lt;/p>
&lt;p>&lt;img src="img/000000.jpg" alt="" />
●北京猿人复原图&lt;/p>
\[Peking Man。按此名为安特生所名，协和医学院解剖学教授步达生（Davidson Black）名之为Sinanthropus Pekinensis，叶为耽名之曰震旦人，见所著《震旦人与周口店文化》，商务印书馆本\]&lt;p>。据考古学家的研究，其时约距今四十万年。其和中国人有无关系，殊不可知，不过因此而知东方亦是很古的人类起源之地罢了。其和历史时代可以连接的，则为民国十年辽宁锦西沙锅屯，河南渑池仰韶村，及十二三年甘肃临夏、宁定、民勤，青海贵德及青海沿岸所发现的彩色陶器，和俄属土耳其斯单所发现的酷相似。考古家安特生（J.G.Andersson）因谓中国民族，实自中亚经新疆、甘肃而来。但彩陶起自巴比仑，事在公元前3500年，传至小亚细亚，约在公元前2500年至前2000年，传至古希腊，则在前2000年至前1000年，俄属土耳其斯单早有铜器，河南、甘肃、青海之初期则无之，其时必在公元2500年之前，何以传播能如是之速？制铜之术，又何以不与制陶并传？斯坦因（Sir Aurel Stein）在新疆考古，所得汉、唐遗物极多，而先秦之物，则绝无所得，可见中国文化在先秦世实尚未行于西北，安特生之说，似不足信了（此说据金兆梓《中国人种及文化由来》，见《东方杂志》第二十六卷第二期）。民国十九年以后，山东历城的城子崖，滕县的安上村，都发现了黑色陶器。江苏武进的奄城，金山的戚家墩，吴县的磨盘山、黄壁山，浙江杭县的古荡、良渚，吴兴的钱山漾，嘉兴的双栖，平湖的乍浦，海盐的澉浦，亦得有新石器时代的石器、陶器，其中杭县的黑陶，颇与山东相类。又河域所得陶器，皆为条纹及席纹；南京、江、浙和山东邹县，福建武平，辽宁金县貔子窝及香港的陶器，则其文理为几何形。又山东、辽宁有有孔石斧，朝鲜、日本有有孔石厨刀，福建厦门、武平有有沟石锛，南洋群岛有有沟石斧，大洋洲木器所刻动物形，有的和中国铜器上的动物相像。北美阿拉斯加的土器，也有和中国相像的。然则中国沿海一带，实自有其文化。据民国十七年以后中央研究院在河南所发掘，安阳的侯家庄，濬县的大赉店，兼有彩色、黑色两种陶器，而安阳县北的小屯村，即1898、1899年发现甲骨文字之处，世人称为殷墟的，亦有几何纹的陶器。又江、浙石器中，有戈、矛及钺，河域惟殷墟有之。鬲为中国所独有，为鼎之前身，辽东最多，仰韶亦有之，甘肃、青海，则至后期才有。然则中国文化，在有史以前，似分东、西两系。东系以黑陶为代表，西系以彩陶为代表，而河南为其交会之地。彩陶为西方文化东渐的，代表中国固有的文化的，实为黑陶。试以古代文化现象证之：一、“国君无故不杀牛，大夫无故不杀羊，士无故不杀犬豕”，而鱼鳖则为常食。二、衣服材料，以麻、丝为主，裁制极其宽博。三、古代的人民，是巢居或湖居的。四、其货币多用贝。五、在宗教上又颇敬畏龙蛇。皆足证其文化起于东南沿海之处；彩陶文化之为外铄，似无疑义了。在古代，亚洲东方的民族，似可分为三系，而其处置头发的方法，恰可为其代表，这是一件极有趣味的事，即北族辫发、南族断发、中原冠带。《尔雅·释言》说：“齐，中也。”《释地》说：“自齐州以南戴日为丹穴，北戴斗极为空同，东至日所出为大平，西至日所入为大蒙。”“齐”即今之“脐”字，本有中央之义。古代的民族，总是以自己所居之地为中心的，齐州为汉族发祥之地，可无疑义了。然则齐州究在何处呢？我们固不敢断言其即后来的齐国，然亦必与之相近。又《尔雅·释地》说“中有岱岳”，而泰山为古代祭天之处，亦必和我民族起源之地有关。文化的发展，总是起于大河下流的，埃及和小亚细亚即其明证。与其说中国文化起于黄河上流，不如说其起于黄河下流的切于事情了。近来有些人，窥见此中消息，却又不知中国和南族之别，甚有以为中国人即是南族的，这个也不对。南族的特征是断发文身，断发即我国古代的髡刑，文身则是古代的黥刑。以南族的装饰为刑，可见其曾与南族相争斗，而以其俘虏为奴隶。近代的考古学，证明长城以北的古物，可分为三类：一、打制石器，其遗迹西起新疆，东至东三省，而限于西辽河、松花江以北，环绕着沙漠。二、细石器，限于兴安岭以西。与之相伴的遗物，有类似北欧及西伯利亚的，亦有类似中欧及西南亚的，两者均系狩猎或畜牧民族所为。三、磨制石器，北至黑龙江昂昂溪，东至朝鲜北境，则系黄河流域的农耕民族所为，其遗物多与有孔石斧及类鬲的土器并存，与山东龙口所得的土器极相似。可见我国民族，自古即介居南北两民族之间，而为东方文化的主干了（步达生言仰韶村、沙锅屯的遗骸，与今华北人同，日本清野谦次亦谓貔子窝遗骸，与仰韶村遗骸极相似）。&lt;/p>
&lt;p>&lt;img src="img/000001.jpg" alt="" />
●彩陶盆　仰韶文化半坡类型，公元前5000年—公元前4000年，陕西西安半坡遗址出土，高16.4厘米、口径40厘米，内绘鱼、鱼和人面相结合的花纹，这是仰韶文化早期流行的纹饰。有观点认为，鱼便是仰韶文化半坡类型的图腾&lt;/p>
&lt;h1 id="第二章中国史的年代">
 第二章　中国史的年代
 &lt;a class="anchor" href="#%e7%ac%ac%e4%ba%8c%e7%ab%a0%e4%b8%ad%e5%9b%bd%e5%8f%b2%e7%9a%84%e5%b9%b4%e4%bb%a3">#&lt;/a>
&lt;/h1>
&lt;p>讲历史要知道年代，正和讲地理要知道经纬线一般。有了经纬线，才知道某一地方在地球面上的某一点，和其余的地方距离如何，关系如何。有了年代，才知道某一件事发生在悠远年代中的某一时，当时各方面的情形如何，和其前后诸事件的关系如何。不然，就毫无意义了。&lt;/p>
&lt;p>正确的年代，原于（一）正确，（二）不断的记载。中国正确而又不断的记载，起于什么时候呢？那就是周朝厉、宣两王间的共和元年。下距民国纪元2752年，公历纪元841年，在世界各国中，要算是很早的了。但是比之于人类的历史，还如小巫之见大巫。世界之有人类，其正确的年代虽不可知，总得在四五十万年左右。历史确实的纪年，只有二千余年，正像人活了一百岁，只记得一年不到的事情，要做正确的年谱，就很难了。虽然历史无完整的记载，历史学家仍有推求之法。那便是据断片的记载，涉及天地现象的，用历法推算。中国用这方法的也很多。其中较为通行的，一为《汉书·律历志》所载刘歆之所推算，一为宋朝邵雍之所推算。刘歆所推算：周朝867年，殷朝629年，夏朝432年，虞舜在位五十年，唐尧在位七十年。周朝的灭亡，在民国纪元前2167年，公历纪元前256年，则唐尧的元年，在民国纪元前4215年，公历纪元前2305年。据邵雍所推算，则唐尧元年，在民国纪元前4268年，公历纪元前2357年。据历法推算，本是极可信据的，但前人的记载，未必尽确，后人的推算，也不能无误，所以也不可尽信。不过这所谓不可信，仅系不密合，论其大概，还是不误的。《孟子·公孙丑下篇》说：“由周而来，七百有余岁矣。”《尽心下篇》说：“由尧、舜至于汤，五百有余岁；由汤至于文王，五百有余岁；由文王至于孔子，五百有余岁。”乐毅报燕惠王书，称颂昭王破齐之功，说他“收八百岁之蓄积”。《韩非子·显学篇》说：“殷、周七百余岁，虞、夏二千余岁。”（此七百余岁但指周言）都和刘歆、邵雍所推算，相去不远。古人大略的记忆，十口相传，是不会大错的。然则我国历史上可知而不甚确实的年代，大约在四千年以上了。&lt;/p>
&lt;p>自此以上，连断片的记录，也都没有，则只能据发掘所得，推测其大略，是为先史时期。人类学家把人类所用的工具，分别它进化的阶段，最早的为旧石器时期，次之为新石器时期，都在有史以前，更次之为青铜器时期，更次之为铁器时期，就在有史以后了。我国近代发掘所得，据考古学家的推测：周口店的遗迹，约在旧石器前期之末，距今二万五千年至七万年。甘、青、河南遗迹，早的在新石器时期，在公历纪元前2600至3500年之间；&lt;/p>
&lt;p>晚的在青铜器时期，在公历纪元前1700至2600年之间。按古代南方铜器的发明，似较北方为早，则实际上，我国开化的年代，或许还在此以前。&lt;/p>
&lt;p>&lt;img src="img/000002.jpg" alt="" />
●旧石器时代·刮削器和尖状器山西省阳高县许家窑遗址出土。最长的5.6厘米，最短的2.7厘米。是10万年前的石器&lt;/p>
&lt;p>中国古书上，有的把古史的年代，说得极远而且极确实的，虽然不足为凭，然因其由来甚远，亦不可不一发其覆。按《续汉书律历志》载蔡邕议历法的话，说《元命苞》、《乾凿度》都以为自开辟至获麟（获麟是《春秋》的末一年，在公元前481年），二百七十六万岁。司马贞《补三皇本纪》，则说《春秋纬》称自开辟至获麟，凡三百二十七万六千岁，分为十纪。据《汉书·律历志》刘歆的三统历法，以十九年为一章，四章为一蔀，二十蔀为一纪，三纪为一元。二百七十五万九千二百八十年，乃是六百十三元之数。《汉书·王莽传》说：莽下三万六千岁历，三万六千被乘于九十一，就是三百二十七万六千年了。这都是乡壁虚造之谈，可谓毫无历史上的根据。&lt;/p>
&lt;p>&lt;img src="img/000003.jpg" alt="" />
●新石器时代·白陶山东维坊姚官庄出土。温酒器，高29.7厘米。是山东龙山文化遗存&lt;/p>
&lt;h1 id="第三章古代的开化">
 第三章　古代的开化
 &lt;a class="anchor" href="#%e7%ac%ac%e4%b8%89%e7%ab%a0%e5%8f%a4%e4%bb%a3%e7%9a%84%e5%bc%80%e5%8c%96">#&lt;/a>
&lt;/h1>
&lt;p>中国俗说，最早的帝王是盘古氏。古书有的说他和天地开辟并生，有的说他死后身体变化而成日月、山河、草木等。（徐整《三五历记》说：“天地混沌如鸡子，盘古生其中。万八千岁，天地开辟，阳清为天，阴浊为地，盘古在其中……天日高一丈，地日厚一丈，盘古日长一丈。如此万八千岁，天数极高，地数极深，盘古极长。”《五运历年记》说：“首生盘古，垂死化身：气成风云，声为雷霆，左眼为日，右眼为月，四肢、五体为四极、五岳，血液为江河，筋脉为地理，肌肉为田土，发髭为星辰，皮毛为草木，齿骨为金石，精髓为珠玉，汗流为雨，身之诸虫，因风所感，化为黎虻。”）这自然是附会之辞，不足为据。《后汉书·南蛮传》说：汉时长沙、武陵蛮（长沙、武陵，皆后汉郡名。长沙，治今湖南长沙县。武陵，治今湖南常德县）的祖宗，唤做盘瓠，乃是帝喾高辛氏的畜狗。当时有个犬戎国，为中国之患。高辛氏乃下令，说有能得犬戎吴将军的头的，赏他黄金万镒，还把自己的女儿嫁给他。令下之后，盘瓠衔了吴将军的头来。遂背了高辛氏的公主，走入南山，生了六男六女，自相夫妻，成为长沙、武陵蛮的祖宗。现在广西一带，还有祭祀盘古的。闽、浙的畲民，则奉盘瓠为始祖，其画像仍作狗形。有人说：盘古就是盘瓠，这话似乎很确。但是《后汉书》所记，只是长沙、武陵一支，而据古书所载，则盘古传说，分布之地极广，而且绝无为帝喾畜狗之说（据《路史》：会昌有盘古山，湘乡有盘古堡，雩都有盘古祠，成都、淮安、京兆亦皆有盘古庙。会昌，令江西会昌县。湘乡，今湖南湘乡县。雩都，今江西雩都县。成都，今四川成都县。淮安，今江苏淮安县。京兆，今西京），则盘古、盘瓠，究竟是一是二，还是一个疑问。如其是一，则盘古本非中国民族的始祖；如其是二，除荒渺的传说外，亦无事迹可考，只好置诸不论不议之列了。&lt;/p>
&lt;p>在盘古之后，而习惯上认为很早的帝王的，就是三皇、五帝。三皇、五帝之名，见于《周官》外史氏，并没说他是谁。后来异说甚多（三皇异说：《白虎通》或说，无遂人而有祝融。《礼记·曲礼正义》说：郑玄注《中候敕省图》引《运斗枢》，无遂人而有女娲。按《淮南子·天文训》、《览冥训》，《论衡·谈天》、《顺鼓》两篇，都说共工氏触不周之山，天柱折，地维缺，女娲炼五色石以补天，断鳌足以立四极。而司马贞《补三皇本纪》说系共工氏与祝融战，则女娲、祝融一人。祝融为火神，燧人是发明钻木取火的，可见其仍系一个部族。五帝异说：则汉代的古学家，于黄帝、颛顼之间，增加了一个少昊，于是五帝变成六人。郑玄注《中候敕省图》，乃谓德合五帝坐星，即可称帝，故“实六人而为五”。然总未免牵强。东晋晚出的《伪古文尚书》的《伪孔安国传序》，乃将三皇中的燧人除去，而将黄帝上升为三皇，于是六人为五的不通，给他弥缝过去了。《伪古文尚书》今已判明其为伪，人皆不之信，东汉古学家之说，则尚未显被推翻。但古学家此说，不过欲改五德终始说之相胜为相生，而又顾全汉朝之为火德，其作伪实无以异，而手段且更拙。按五德终始之说，创自邹衍，本依五行相胜的次序。依他的说法，是虞土、夏木、殷金、周火，所以秦始皇自以为水德，而汉初自以为土德。到刘向父子出，改五德的次序为五行相生，又以汉为尧后。而黄帝的称号为黄，黄为土色，其为土德，无可移易。如此，依五帝的旧次，颛顼金德，帝喾水德，尧是木德，与汉不同德了。于其间增一少昊为金德，则颛顼水德，帝喾木德，尧为火德，与汉相同；尧以后则虞土，夏金，殷水，周木，而汉以火德承之，秦人则被视为闰位，不算入五德相承次序。这是从前汉末年发生，至后汉而完成的一套五德终始的新说，其说明见于《后汉书·贾逵传》，其不能据以言古代帝王的统系，是毫无疑义的了），其较古的，还是《风俗通》引《含文嘉》，以燧人、伏羲、神农为三皇，《史记·五帝本纪》以黄帝、颛顼、帝喾、尧、舜为五帝之说。燧人、伏羲、神农，不是“身相接”的，五帝则有世系可考。&lt;/p>
&lt;p>据《史记·五帝本纪》及《大戴礼记·帝系篇》，其统系如下：&lt;/p>
&lt;p>&lt;img src="img/000004.jpg" alt="" />&lt;/p>
&lt;p>按五帝之说，源于五德终始，五德终始之说，创自邹衍，邹衍是齐人，《周官》所述的制度，多和《管子》相合，疑亦是齐学。古代本没有一个天子是世代相承的；即一国的世系较为连贯的，亦必自夏以后。夏、殷两代，后世的史家，都认为是当时的共主，亦是陷于时代错误的。据《史记·夏本纪》、《史记·殷本纪》所载，明明还是盛则诸侯来朝，衰则诸侯不至，何况唐、虞以上？所以三皇、五帝，只是后人造成的一个古史系统，实际上怕全不是这么一回事。但自夏以后，一国的世系，既略有可考；而自黄帝以后，诸帝王之间，亦略有不很正确的世系，总可藉以推测古史的大略了。&lt;/p>
&lt;p>古代帝王的称号，有所谓德号及地号（服虔说，见《礼记·月令》、《疏》），德号是以其所做的事业为根据的，地号则以其所居之地为根据。按古代国名、地名，往往和部族之名相混，还可以随着部族而迁移，所以虽有地号，其部族究在何处，仍难断言。至于德号，更不过代表社会开化的某阶段；或者某一个部族，特长于某种事业；并其所在之地而不可知，其可考见的真相，就更少了。然既有这些传说，究可略据之以为推测之资。传说中的帝王，较早而可考见社会进化的迹象的，是有巢氏和燧人氏。有巢氏教民构木为巢，燧人氏教民钻木取火，见于《韩非子》的《五蠹篇》。稍后则为伏羲、神农。伏羲氏始画八卦，作结绳而为网罟，以佃以渔；神农氏斫木为耜，揉木为耒，日中为市，见于《易经》的《系辞传》。有巢、燧人、神农都是德号，显而易见。伏羲氏，《易传》作包牺氏，包伏一声之转。据《风俗通》引《含文嘉》，是“下伏而化之”之意，羲化亦是一声。他是始画八卦的，大约在宗教上很有权威，其为德号，亦无疑义。这些都不过代表社会进化的一个阶段，究有其人与否，殊不可知。但各部族的进化，不会同时，某一个部族，对于某一种文化，特别进步得早，是可能有的。如此，我们虽不能说在古代确有发明巢居、取火、佃渔、耕稼的帝王，却不能否认对于这些事业，有一个先进的部族。既然有这部族，其时、地就该设法推考了。伏羲古称为太昊氏，风姓，据《左传》僖公二十一年所载，任、宿、须句、颛臾四国，是其后裔。任在今山东的济宁县，宿和须句都在东平县，颛臾在费县。神农，《礼记·月令》《疏》引《春秋说》，称为大庭氏。《左传》昭公十八年，鲁有大庭氏之库。鲁国的都城，即今山东曲阜县（《帝王世纪》说伏羲都陈，乃因左氏有“陈太昊之墟”之语而附会，不足信，见下文。又说神农氏都陈徙鲁，则因其承伏羲之后而附会的）。然则伏羲、神农，都在今山东东南部，和第一章所推测的汉族古代的根据地，是颇为相合的了。&lt;/p>
&lt;p>神农亦称炎帝，炎帝之后为黄帝，炎、黄之际，是有一次战事可以考见的，古史的情形，就更较明白了。《史记·五帝本纪》说：神农氏世衰，诸侯相侵伐，弗能征，而蚩尤氏最为暴。“黄帝乃征师诸侯，与蚩尤战于涿鹿之野，遂擒杀蚩尤。”又说：“炎帝欲侵陵诸侯，诸侯咸归轩辕。”（《史记·五帝本纪》说黄帝名轩辕，他书亦有称为轩辕氏的。按古书所谓名，兼包一切称谓，不限于名字之名。）轩辕“与炎帝战于阪泉之野，三战，然后得其志”。其说有些矛盾。《史记》的《五帝本纪》，和《大戴礼记》的《五帝德》，是大同小异的，《大戴礼记》此处，却只有和炎帝战于阪泉，而并没有和蚩尤战于涿鹿之事。神农、蚩尤，都是姜姓。《周书·史记篇》说“阪泉氏徙居独鹿”，独鹿之即涿鹿，亦显而易见。然则蚩尤、炎帝，即是一人，涿鹿、阪泉，亦系一地。《太平御览·州郡部》引《帝王世纪》转引《世本》，说涿鹿在彭城南，彭城是今江苏的铜山县（服虔谓涿鹿为汉之涿郡，即今河北涿县。皇甫谧、张晏谓在上谷，则因汉上谷郡有涿鹿县而云然，皆据后世的地名附会，不足信。汉涿鹿县即今察哈尔涿鹿县）。《世本》是古书，是较可信据的，然则汉族是时的发展，仍和鲁东南不远了。黄帝之后是颛顼，颛顼之后是帝喾，这是五帝说的旧次序。后人于其间增一少昊，这是要改五德终始之说相胜的次序为相生，又要顾全汉朝是火德而云然，无足深论。但是有传于后，而被后人认为共主的部族，在古代总是较强大的，其事迹仍旧值得考据，则无疑义。《史记·周本纪正义》引《帝王世纪》说：炎帝、黄帝、少昊，都是都于曲阜的，而黄帝自穷桑登帝位，少昊氏邑于穷桑，颛顼则始都穷桑，后徙帝丘。它说“穷桑在鲁北，或云穷桑即曲阜也”。《帝王世纪》，向来认为不足信之书，但只是病其牵合附会，其中的材料，还是出于古书的，只要不轻信其结论，其材料仍可采用。《左传》定公四年说伯禽封于少昊之墟，昭公二十年说：“少昊氏有四叔，世不失职，遂济穷桑”，则穷桑近鲁，少昊氏都于鲁之说，都非无据。帝丘地在今河北濮阳县，为后来卫国的都城。颛顼徙帝丘之说，乃因《左传》昭公十七年“卫颛顼之虚”而附会，然《左传》此说，与“陈太昊之墟”，“宋大辰之虚”，“郑祝融之虚”并举，大辰，无论如何，不能说为人名或国名（近人或谓即《后汉书》朝鲜半岛的辰国，证据未免太乏），则太昊、祝融、颛顼，亦系天神，颛顼徙都帝丘之说，根本不足信了。《史记·五帝本纪》说：黄帝正妃“嫘祖生二子，其后皆有天下。其一曰玄嚣，是为青阳，青阳降居江水”，此即后人指为少昊的。“其二曰昌意，降居若水，生高阳。”高阳即帝颛顼。后人以今之金沙江释此文的江水，鸦龙江释此文的若水，此乃大误。古代南方之水皆称江。《史记·殷本纪》引《汤诰》，说“东为江，北为济，西为河，南为淮，四渎己修，万民乃有居”，其所说的江，即明明不是长江（淮、泗、汝皆不入江，而《孟子·滕文公上篇》说禹“决汝、汉，排淮、泗，而注之江”，亦由于此）。《吕览·古乐篇》说：“帝颛顼生自若水，实处空桑，乃登为帝。”可见若水实与空桑相近。《山海经·海内经》说：“南海之内，黑水、青水之间，有木焉，名曰若木，若水出焉。”《说文》桑字作&lt;img src="images/000005.jpg" alt="" />，若水之若，实当作&lt;img src="images/000006.jpg" alt="" />，仍系桑字，特加&lt;img src="img/000007.jpg" alt="" />以象根形，后人认为若字实误。《楚辞》的若木，亦当作桑木，即神话中的扶桑，在日出之地（此据王筠说，见《说文释例》）。然则颛顼、帝喾，踪迹仍在东方了。&lt;/p>
&lt;p>继颛顼之后的是尧，继尧之后的是舜，继舜之后的是禹。尧、舜、禹的相继，据儒家的传说，是纯出于公心的，即所谓“禅让”，亦谓之“官天下”。但《庄子·盗跖篇》有尧杀长子之说，《吕览·去私》、《求人》两篇，都说尧有十子，而《孟子·万章上篇》和《淮南子·泰族训》，都说尧只有九子，很像尧的大子是被杀的（俞正燮即因此疑之，见所著《癸巳类稿·奡证》）。后来《竹书纪年》又有舜囚尧，并偃塞丹朱，使不与尧相见之说。刘知幾因之作《疑古篇》，把尧、舜、禹的相继，看作和后世的篡夺一样。其实都不是真相。古代君位与王位不同，在第三十九章中，业经说过。尧、舜、禹的相继，乃王位而非君位，这正和蒙古自成吉思汗以后的汗位一样。成吉思汗以后的大汗，也还是出于公举的（详见第二十七章）。前一个王老了，要指定一人替代，正可见得此时各部族之间，已有较密切的关系，所以共主之位，不容空缺。自夏以后，变为父子相传，古人谓之“家天下”，又可见得被举为王的一个部族，渐次强盛，可以久居王位了。&lt;/p>
&lt;p>尧、舜、禹之间，似乎还有一件大事，那便是汉族的开始西迁。古书中屡次说颛顼、帝喾、尧、舜、禹和共工、三苗的争斗（《淮南子·天文训》、《兵略训》，都说共工与颛顼争，《原道训》说共工与帝喾争。《周书·史记篇》说：共工亡于唐氏。《书经·尧典》说：舜流共工于幽州。《荀子·议兵篇》说：禹伐共工。《书经·尧典》又说：舜迁三苗于三危。《甫刑》说：“皇帝遏绝苗民，无世在下。”皇帝，《疏》引郑注以为颛顼，与《国语》、《楚语》相合。而《战国·魏策》，《墨子》的《兼爱》、《非攻》，《韩非子》的《五蠹》，亦均载禹征三苗之事）。共工、三苗都是姜姓之国，似乎姬、姜之争，历世不绝，而结果是姬姓胜利的。我的看法，却不是如此。《国语·周语》说：“共工欲壅防百川，堕高堙卑，鲧称遂共工之过，禹乃高高下下，疏川导滞。”似乎共工和鲧，治水都是失败的，至禹乃一变其法。然《礼记·祭法德》说“共工氏之霸九州也，其子曰后土，能平九州”，则共工氏治水之功，实与禹不相上下。后人说禹治水的功绩，和唐、虞、夏间的疆域，大抵根据《书经》中的《禹贡》，其实此篇所载，必非禹时实事。《书经》的《皋陶谟》载禹自述治水之功道：“予决九川，距四海，濬畎浍距川。”九川特极言其多。四海的海字，乃晦暗之义。古代交通不便，又各部族之间，多互相敌视，本部族以外的情形，就茫昧不明，所以夷、蛮、戎、狄，谓之四海（见《尔雅·释地》，中国西北两面均无海，而古称四海者以此）。州洲本系一字，亦即今之岛字，说见第五十章。《说文》川部：“州，水中可居者。昔尧遭洪水，民居水中高土，故曰九州。”此系唐、虞、夏间九州的真相，决非如《禹贡》所述，跨今黄河、长江两流域。同一时代的人，知识大抵相类，禹的治水，能否一变共工及鲧之法，实在是一个疑问。堙塞和疏导之法，在一个小区域之内，大约共工、鲧、禹，都不免要并用的。但区域既小，无论堙塞，即疏导，亦决不能挽回水灾的大势，所以我疑心共工、鲧、禹，虽然相继施功，实未能把水患解决，到禹的时代，汉族的一支，便开始西迁了。尧的都城，《汉书·地理志》说在晋阳，即今山西的太原县。郑玄《诗谱》说他后迁平阳，在今山西的临汾县。《帝王世纪》说舜都蒲阪，在今山西的永济县。又说禹都平阳，或于安邑，或于晋阳，安邑是今山西的夏县。这都是因后来的都邑而附会。《太平御览·州郡部》引《世本》说：尧之都后迁涿鹿；《孟子·离娄下篇》说：“舜生于诸冯，迁于负夏，卒于鸣条”。这都是较古之说。涿鹿在彭城说已见前。诸冯、负夏、鸣条皆难确考。然鸣条为后来汤放桀之处，桀当时是自西向东走的，则鸣条亦必在东方。而《周书·度邑解》说：“自洛汭延于伊汭，居易无固，其有夏之居。”这虽不就是禹的都城，然自禹的儿子启以后，就不闻有和共工、三苗争斗之事，则夏朝自禹以后，逐渐西迁，似无可疑。然则自黄帝至禹，对姜姓部族争斗的胜利，怕也只是姬姓部族自己夸张之辞，不过只有姬姓部族的传说，留遗下来，后人就认为事实罢了。为什么只有姬姓部族的传说，留遗于后呢？其中仍有个关键。大约当时东方的水患，是很烈的，而水利亦颇饶。因其水利颇饶，所以成为汉族发祥之地。因其水患很烈，所以共工、鲧、禹，相继施功而无可如何。禹的西迁，大约是为避水患的。当时西边的地方，必较东边为瘠，所以非到水久治无功时，不肯迁徙。然既迁徙之后，因地瘠不能不多用人力，文明程度转而因此进步，而留居故土的部族，反落其后了。这就是自夏以后，西方的历史传者较详，而东方较为茫昧之故。然则夏代的西迁，确是古史上的一个转折，而夏朝亦确是古史上的一个界划了。&lt;/p>
&lt;h1 id="第四章夏殷西周的事迹">
 第四章　夏殷西周的事迹
 &lt;a class="anchor" href="#%e7%ac%ac%e5%9b%9b%e7%ab%a0%e5%a4%8f%e6%ae%b7%e8%a5%bf%e5%91%a8%e7%9a%84%e4%ba%8b%e8%bf%b9">#&lt;/a>
&lt;/h1>
&lt;p>夏代事迹，有传于后的，莫如太康失国少康中兴一事。这件事，据《左传》、《周书》、《墨子》、《楚辞》所载（《左传》襄公四年、哀公元年，《周书·尝麦解》，《墨子·非乐》，《楚辞·离骚》），大略是如此的。禹的儿子启，荒于音乐和饮食。死后，他的儿子太康兄弟五人，起而作乱，是为五观。太康因此失国，人民和政权，都入于有穷后羿之手。太康传弟仲康，仲康传子相（夏朝此时，失掉的是王位，并非君位，所以仍旧相传）。羿因荒于游畋，又为其巨寒浞所杀。寒浞占据了羿的妻妾，生了两个儿子：一个唤做浇，一个唤做豷。夏朝这时候，依靠他同姓之国斟灌和斟寻。寒浞使浇把他们都灭掉，又灭掉夏后相。使浇住在唤做过，豷住在唤做戈的地方。夏后相的皇后，是仍国的女儿，相被灭时，正有身孕，逃归母家，生了一个儿子，是为少康。做了仍国的牧正。寒浞听得他有才干，使浇去寻找他。少康逃到虞国。虞国的国君，把两个女儿嫁给他，又把唤做纶的地方封他。有一个唤做靡的，当羿死时，逃到有鬲氏，就从有鬲氏收合斟灌、斟寻的余众，把寒浞灭掉。少康灭掉了浇，少康的儿子杼又灭掉了豷。穷国就此灭亡。这件事，虽然带些神话和传说的性质，然其匡廓尚算明白，颇可据以推求夏代的情形。旧说的释地，是全不足据的。《左传》说“后羿自迁于穷石”，又说羿“因夏民以代夏政”，则穷石即非夏朝的都城，亦必和夏朝的都城相近。《路史》说安丰有穷谷、穷水，就是穷国所在，其地在今安徽霍邱县。《汉书·地理志》《注》引应劭说：有穷是偃姓之国，皋陶之后。据《史记·五帝本纪》，皋陶之后，都是封在安徽六安一带的。过不可考。戈，据《左传》，地在宋、郑之间（见《左传》哀公十二年）。《春秋》桓公五年，天王使仍叔之子来聘，仍，《榖梁》作任，地在今山东的济宁县。虞国当系虞舜之后，旧说在今河南的虞城县。《周书》称太康兄弟五人为“殷之五子”。又说：“皇天哀禹，赐以彭寿，思正夏略。”殷似即后来的亳殷，在今河南的偃师县（即下文所引《春秋繁露》说汤作官邑于下洛之阳的。官宫二字古通用，作官邑就是造房屋和城郭。商朝的都城所在，都称为亳，此地大约本名殷，商朝所以又称殷朝）。彭寿该是立国于彭城的。按《世本》说禹都阳城，地在今河南的登封县，西迁未必能如此之速。综观自太康至少康之事，似乎夏朝的根据地，本在安徽西部，而逐渐迁徙到河南去，入于上章所引《周书》所说的“自洛汭延于伊汭”这一个区城的。都阳城该是夏朝后代的事，而不是禹时的事。从六安到霍邱，地势比较高一些，从苏北鲁南避水患而迁于此，又因战争的激荡而西北走向河南，似乎于情事还合。&lt;/p>
&lt;p>&lt;img src="img/000008.jpg" alt="" />
●夏·乳钉纹平底爵高22.5厘米，流至尾长31.5厘米，1975年河南偃师二里头出土&lt;/p>
&lt;p>但在这时候，东方的势力，亦还不弱，所以后来夏朝卒亡于商。商朝的始祖名契，封于商。郑玄说地在大华之阳，即今陕西的商县，未免太远。《史记·殷本纪》说：“自契至于成汤八迁。”《世本》说契居蕃，契的儿子昭明居砥石，昭明的儿子相土居商丘，扬雄《兖州牧箴》说“成汤五徙，卒归于亳”，合之恰得八数。蕃当即汉朝的蕃县，为今山东的滕县。商丘，当即后来宋国的都城，为今河南的商丘县。五迁地难悉考。据《吕览·慎大》、《具备》两篇，则汤尝居郼，郼即韦，为今河南的滑县。《春秋繁露·三代改制质文篇》说“汤受命而王，作官邑于下洛之阳”，此当即亳殷之地。《诗·商颂》说：“韦，顾既伐，昆吾，夏桀。”顾在今山东的范县。昆吾，据《左传》昭公十二年《传》楚灵王说“昔我皇祖伯父昆吾，旧许是宅”，该在今河南的许昌县，而哀公十七年，又说卫国有昆吾之观，卫国这时候，在今河北的濮阳县，则昆吾似自河北迁于河南。《史记·殷本纪》说：“汤自把钺以伐昆吾，遂伐桀。”“桀败于有娀之虚，桀奔于鸣条。”《左传》昭公四年“夏桀为仍之会，有缗叛之”，《韩非子·十过篇》亦有这话，仍作娀，则有娀，即有仍。鸣条为舜卒处，已见上章。合观诸说，商朝似乎兴于今鲁、豫之间，汤先平定了河南的北境，然后向南攻桀，桀败后是反向东南逃走的。观桀之不向西走而向东逃，可见此时伊、洛以西之地，还未开辟。&lt;/p>
&lt;p>据《史记》的《夏本纪》、《殷本纪》，夏朝传国共十七代，商朝则三十代。商朝的世数所以多于夏，大约是因其兼行兄终弟及之制而然。后来的鲁国，自庄公以前，都是一生一及，吴国亦有兄终弟及之法，请见第三十八章，这亦足以证明商朝的起于东方。商朝的事迹，较夏朝传者略多。据《史记》：成汤以后，第四代大甲，第九代大戊，第十三代祖乙，第十九代盘庚，第二十二代武丁，都是贤君，而武丁之时，尤其强盛。商朝的都城，是屡次迁徙的。第十代仲丁迁于隞地，在今河南荥泽县（隞，《书序》作嚣，《书序》不一定可信，所以今从《史记》。隞的所在，亦有异说。但古书皆东周至汉的人所述，尤其大多数是汉朝人写下来的，所以用的大抵多是当时的地名，所以古书的释地，和东周、秦、汉时地名相近的，必较可信。如隞即敖，今之荥泽县，为秦汉间敖仓所在，以此释仲丁所迁之隞，确实性就较大些。这是治古史的通例，不能一一具说，特于此发其凡）。第十二代河亶甲居相，在今河南内黄县。第十三代祖乙迁于邢，在今河北邢台县。到盘庚才迁回成汤的旧居亳殷。第二十七代武乙，复去亳居河北。今河南安阳县北的小屯村，即发现龟甲兽骨之处，据史学家所考证，其地即《史记·项羽本纪》所谓殷墟，不知是否武乙时所都。至共第三十代即最后一个君主纣，则居于朝歌，在今河南淇县。综观商朝历代的都邑，都在今河南省里的黄河两岸，还是汤居郼，营下洛之阳的旧观。周朝的势力，却更深入西北部了。&lt;/p>
&lt;p>周朝的始祖名弃，是舜之时居稷官的，封于邰。历若干代，至不窋，失官，奔于戎狄之间。再传至公刘，居邠，仍从事于农业。又十传至古公亶父，复为狄所逼，徙岐山下。邰，旧说是今陕西的武功县。邠是今陕西的邠县，岐是今陕西的岐山县。近人钱穆说，《左传》昭公元年说金天氏之裔子台骀封于汾川，《周书·度邑篇》说武王升汾之阜以望商邑，汾即邠，邰则因台骀之封而得名，都在今山西境内。亶父逾梁山而至岐，梁山在今陕西韩城县，岐山亦当距梁山不远（见所著《周初地理考》）。据他这说法，则后来文王居丰，武王居镐，在今陕西鄠县界内的，不是东下，乃是西上了。河、汾下流和渭水流域，地味最为肥沃，周朝是农业部族，自此向西拓展，和事势是很合的。古公亶父亦称太王，周至其时始强盛。传幼子季历以及文王，《论语》说他“三分天下有其二”（见《泰伯下篇》）。文王之子武王，遂灭纣。文王时曾打破耆国，而殷人振恐，武王则渡孟津而与纣战，耆国，在今山西的黎城县，自此向朝歌，乃今出天井关南下的隘道，孟津在今河南孟县南，武王大约是出今潼关到此的，这又可以看出周初自西向东发展的方向。然武王虽胜纣，并未能把商朝灭掉，仍以纣地封其子武庚，而使其弟管叔、蔡叔监之。武王崩，子成王幼，武王弟周公摄政，管、蔡和武庚都叛。据《周书·作雒解》，是时叛者，又有徐、奄及熊、盈。徐即后来的徐国，地在泗水流域，奄即后来的鲁国，熊为楚国的氏族，盈即嬴，乃秦国的姓。可见东方诸侯，此时皆服商而不服周。然周朝此时，颇有新兴之气。周公自己东征，平定了武庚和管叔、蔡叔，灭掉奄国。又使其子伯禽平定了淮夷、徐戎。于是封周公于鲁，使伯禽就国，又封太公望于齐，又经营今洛阳之地为东都，东方的旧势力，就给西方的新势力压服了。周公平定东方之后，据说就制礼作乐，摄政共七年，而归政于成王。周公死后，据说又有所谓“雷风之变”。这件事情，见于《书经》的《金縢篇》。据旧说：武王病时，周公曾请以身代，把祝策藏在金縢之匮中。周公死，成王葬以人臣之礼。天大雷雨，又刮起大风，田禾都倒了，大木也拔了出来。成王大惧，开金縢之匮，才知道周公请代武王之事，乃改用王礼葬周公，这一场灾异，才告平息。据郑玄的说法，则武王死后三年，成王服满了，才称自己年纪小，求周公摄政。摄政之后，管叔、蔡叔散布谣言，说周公要不利于成王，周公乃避居东都。成王尽执周公的属党。遇见了雷风之变，才把周公请回来。周公乃重行摄政。此说颇不合情理，然亦不会全属子虚。《左传》昭公七年，昭公要到楚国去，梦见襄公和他送行。子服惠伯说：“先君未尝适楚，故周公祖以道之，襄公适楚矣，而祖以道君。”据此，周公曾到过楚国，而《史记·蒙恬列传》，亦有周公奔楚之说，我颇疑心周公奔楚及其属党被执，乃是归政后之事。后来不知如何，又回到周朝。周公是否是善终，亦颇有可疑，杀害了一个人，因迷信的关系，又去求媚于他，这是野蛮时代常有的事，不足为怪。如此，则两说可通为一。楚国封于丹阳，其地实在丹、淅两水的会口（宋翔凤说，见《过庭录·楚鬻熊居丹阳武王徙郢考》），正当自武关东南出之路，据周公奔楚一事，我们又可见得周初发展的一条路线了。&lt;/p>
&lt;p>成王和他的儿子康王之时，称为西周的盛世。康王的儿子昭王，“南巡守不返，卒于江上”（《史记·周本纪》文）。这一个江字，也是南方之水的通称。其实昭王是伐楚而败，淹死在汉水里的，所以后来齐桓公伐楚，还把这件事情去诘问楚国（见《左传》僖公四年）。周朝对外的威力，开始受挫了。昭王子穆王，西征犬戎。其时徐偃王强，《后汉书·东夷传》谓其“率九夷以伐宗周，西至河上”。《后汉书》此语，未知何据（《博物志》亦载徐偃王之事，但《后汉书》所据，并不就是《博物志》，该是同据某一种古说的）。《礼记·檀弓下篇》载徐国容居的话，说“昔我先君驹王，西讨济于河”。驹王疑即偃王，则《后汉书》之说亦非全属子虚，被压服的东方，又想恢复其旧势了。然穆王使楚伐徐，偃王走死，则仍为西方所压服。穆王是周朝的雄主，在位颇久，当其时，周朝的声势，是颇振起的，穆王死后，就无此盛况了。穆王五传至厉王，因暴虐，为国人所逐，居外十四年。周朝的卿士周公、召公当国行政，谓之共和。厉王死于外，才立其子宣王。宣王号称中兴，然其在位之三十九年，与姜氏之戎战于千，为其所败。千在今山西的介休县，则周朝对于隔河的地方，业经控制不住，西方戎狄的势力，也渐次抬头了。至子幽王，遂为犬戎和南阳地方的申国所灭。幽王灭亡的事情，《史记》所载的，恢诡有类平话，决不是真相。《左传》昭公二十六年，载周朝的王子朝告诸侯的话，说这时候“携王干命，诸侯替之，而建王嗣，用迁郏鄏”（即东都之地，见《左传》宣公三年）。则幽王死后，西畿之地，还有一个携王。周朝当时，似乎是有内忧兼有外患的。携王为诸侯所废，周朝对于西畿之地，就不能控制了。而且介休败了；出武关向丹、淅的路，又已不通，只有对于东畿，还保存着相当的势力。平王于是迁居洛阳，号称东周，其事在公元前770年。&lt;/p>
&lt;h1 id="第五章春秋战国的竞争和秦国的统一">
 第五章　春秋战国的竞争和秦国的统一
 &lt;a class="anchor" href="#%e7%ac%ac%e4%ba%94%e7%ab%a0%e6%98%a5%e7%a7%8b%e6%88%98%e5%9b%bd%e7%9a%84%e7%ab%9e%e4%ba%89%e5%92%8c%e7%a7%a6%e5%9b%bd%e7%9a%84%e7%bb%9f%e4%b8%80">#&lt;/a>
&lt;/h1>
&lt;p>文化是从一个中心点，逐渐向各方面发展的。西周以前所传的，只有后世认为共主之国一个国家的历史，其余各方面的情形，都很茫昧。固然，书阙有间，不能因我们之无所见而断言其无有，然果有文化十分发达的地方，其事实也决不会全然失传的，于此，就可见得当时的文明，还是限于一个小区域之内了。东周以后则不然，斯时所传者，以各强国和文化较发达的地方的事迹为多，所谓天子之国，转若在无足重轻之列。原来古代所谓中原之地，不过自泰岱以西，华岳以东，太行以南，淮、汉以北，为今河南、山东的大部分，河北、山西的小部分。渭水流域的开发，怕还是西周兴起以来数百年间之事。到春秋时代，情形就大不然了。当时号称大国的，有晋、楚、齐、秦，其兴起较晚的，则有吴、越，乃在今山西的西南境，山东的东北境，陕西的中部，甘肃的东部，及江苏、浙江、安徽之境。在向来所称为中原之地的鲁、卫、宋、郑、陈、蔡、曹、许等，反夷为二三等国了。这实在是一个惊人的文化扩张。其原因何在呢？居于边地之国，因为和异族接近，以竞争磨砺而强，而其疆域亦易于拓展，该是其中最主要的。&lt;/p>
&lt;p>“周之东迁，晋、郑焉依。”（见《左传》隐公六年）即此便可见得当时王室的衰弱。古代大国的疆域，大约方百里，至春秋时则夷为三等国，其次等国大约方五百里，一等国则必方千里以上，请见第三十九章。当西周之世，合东西两畿之地，优足当春秋时的一个大国而有余，东迁以后，西畿既不能恢复，东畿地方，又颇受列国的剥削，周朝自然要夷于鲁、卫了。古语说“天无二日，民无二王”，这只是当时的一个希望。事实上，所谓王者，亦不过限于一区域之内，并不是普天之下，都服从他的。当春秋时，大约吴、楚等国称雄的区域，原不在周朝所管辖的范围内，所以各自称王。周天子所管辖的区域，因强国不止一个，没有一国能尽数慑服各国，所以不敢称王，只得以诸侯之长，即所谓霸主自居，这话在第三十九章中，亦已说过。所以春秋时代，大局的变迁，系于几个霸国手里。春秋之世，首起而称霸的是齐桓公。当时异民族杂居内地的颇多，也有相当强盛的，同族中的小国，颇受其压迫。（一）本来古代列国之间，多有同姓或婚姻的关系。（二）其不然的，则大国受了小国的朝贡，亦有加以保护的义务。（三）到这时候，文化相同之国，被文化不同之国所压迫，而互相救援，那更有些甫有萌芽的微茫的民族主义在内了。所以攘夷狄一举，颇为当时之人所称道。在这一点上，齐桓公的功绩是颇大的。他曾却狄以存邢、卫，又尝伐山戎以救燕（这个燕该是南燕，在今河南的封丘县。《史记》说它就是战国时的北燕，在今河北蓟县，怕是弄错了的，因为春秋时单称为燕的，都是南燕。即北燕的初封，我疑其亦距封丘不远，后来才迁徙到今蓟县，但其事无可考）。而他对于列国，征伐所至亦颇广。曾南伐楚，西向干涉晋国内乱，晚年又曾经略东夷。古人说“五霸桓公为盛”，信非虚语了。齐桓公的在位，系自前685至643年。桓公死后，齐国内乱，霸业遽衰。宋襄公欲继之称霸。然宋国较小，实力不足，前638年，为楚人所败，襄公受伤而死，北方遂无霸主。前632年，晋文公败楚于城濮（今山东濮县），楚国的声势才一挫。此时的秦国，亦已尽取西周旧地，东境至河，为西方一强国，然尚未能干涉中原之事。秦穆公初和晋国竞争不胜，前624年，打败了晋国的兵，亦仅称霸于西戎。中原之地，遂成为晋、楚争霸之局。前597年，楚庄王败晋于邲（今河南郑县），称霸。前591年卒。此时齐顷公亦图与晋争霸。前589年，为晋所败。前575年，晋厉公又败楚于鄢陵（今河南鄢县）。然楚仍与晋兵争不息。至前561年，楚国放弃争郑，晋悼公才称复霸。前546年，宋大夫向戌，善于晋、楚的执政，出而合二国之成，为弭兵之会，晋、楚的兵争，至此才告休息。自城濮之战至此，凡八十七年。弭兵盟后，楚灵王强盛，北方诸侯多奔走往与其朝会。然灵王奢侈而好兵争，不顾民力，旋因内乱被弑。此时吴国日渐强盛，而楚国政治腐败，前506年，楚国的都城，为吴阖闾所破，楚昭王藉秦援，仅得复国，楚国一时陷于不振，然越国亦渐强，起而乘吴之后。前496年，阖闾伐越，受伤而死。前494年，阖闾子夫差破越。夫差自此骄侈，北伐齐、鲁，与晋争长于黄池（今河南封丘县），前473年，越勾践灭吴，越遂徙都琅邪，与齐、晋会于徐州（今山东诸城县），称为霸王。然根基因此不固，至前333年而为楚所灭。&lt;/p></description></item><item><title>封面-版权-读后-自序</title><link>https://lwmfjc.github.io/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83-%E8%AF%BB%E5%90%8E-%E8%87%AA%E5%BA%8F/</link><pubDate>Thu, 02 Jan 2025 23:15:33 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E4%B8%AD%E5%9B%BD%E9%80%9A%E5%8F%B2%E5%90%95%E6%80%9D%E5%8B%89/%E5%B0%81%E9%9D%A2-%E7%89%88%E6%9D%83-%E8%AF%BB%E5%90%8E-%E8%87%AA%E5%BA%8F/</guid><description>&lt;h1 id="版权信息">
 版权信息
 &lt;a class="anchor" href="#%e7%89%88%e6%9d%83%e4%bf%a1%e6%81%af">#&lt;/a>
&lt;/h1>
&lt;p>中国通史&lt;/p>
&lt;p>作　　者：吕思勉&lt;/p>
&lt;p>责任编辑：周　宏&lt;/p>
&lt;p>特约编辑：邱承辉&lt;/p>
&lt;p>装帧设计：利　锐&lt;/p>
&lt;p>本书由天津博集新媒科技有限公司授权亚马逊全球范围发行&lt;/p>
&lt;p>&lt;img src="img/000001.jpg" alt="logo" />&lt;/p>
&lt;p>**目录 **&lt;/p>
&lt;p>版权信息&lt;/p>
&lt;p>吕思勉先生的史识与史德——《中国通史》读后&lt;/p>
&lt;p>自序
绪论&lt;/p>
&lt;p>上编 中国政治史
第一章 中国民族的由来&lt;/p>
&lt;p>第二章 中国史的年代&lt;/p>
&lt;p>第三章 古代的开化&lt;/p>
&lt;p>第四章 夏殷西周的事迹&lt;/p>
&lt;p>第五章 春秋战国的竞争和秦国的统一&lt;/p>
&lt;p>第六章 古代对于异族的同化&lt;/p>
&lt;p>第七章 古代社会的综述&lt;/p>
&lt;p>第八章 秦朝治天下的政策&lt;/p>
&lt;p>第九章 秦汉间封建政体的反动&lt;/p>
&lt;p>第十章 汉武帝的内政外交&lt;/p>
&lt;p>第十一章 前汉的衰亡&lt;/p>
&lt;p>第十二章 新室的兴亡&lt;/p>
&lt;p>第十三章 后汉的盛衰&lt;/p>
&lt;p>第十四章 后汉的分裂和三国&lt;/p>
&lt;p>第十五章 晋初的形势&lt;/p>
&lt;p>第十六章 五胡之乱（上）&lt;/p>
&lt;p>第十七章 五胡之乱（下）&lt;/p>
&lt;p>第十八章 南北朝的始末&lt;/p>
&lt;p>第十九章 南北朝隋唐间塞外的形势&lt;/p>
&lt;p>第二十章 隋朝和唐朝的盛世&lt;/p>
&lt;p>第二十一章 唐朝的中衰&lt;/p>
&lt;p>第二十二章 唐朝的衰亡和沙陀的侵入&lt;/p>
&lt;p>第二十三章 五代十国的兴亡和契丹的侵入&lt;/p>
&lt;p>第二十四章 唐宋时代中国文化的转变&lt;/p>
&lt;p>第二十五章 北宋的积弱&lt;/p></description></item><item><title>Markdown超级教程</title><link>https://lwmfjc.github.io/zh/docs/technology/Markdown/SuperTutorial/</link><pubDate>Wed, 01 Jan 2025 21:50:58 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Markdown/SuperTutorial/</guid><description>&lt;blockquote>
&lt;p>全篇转载自 &lt;a href="https://forum-zh.obsidian.md/t/topic/435">https://forum-zh.obsidian.md/t/topic/435&lt;/a>&lt;br>
作者obsidian论坛名-yikelee 成雙醬，感谢作者无私分享！&lt;/p>
&lt;/blockquote></description></item><item><title>test</title><link>https://lwmfjc.github.io/zh/docs/test/mytest/</link><pubDate>Wed, 01 Jan 2025 09:34:33 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/test/mytest/</guid><description>&lt;p>askdfjkasjdf
asdfkajskdf
asdfjaskdfj &lt;br>
sdk &lt;em>&lt;strong>哈哈哈这是要给测试&lt;/strong>&lt;/em> as jd afk&lt;br>
sdafkjasjdfkjk&lt;br>
fdasfdft.&lt;/p></description></item><item><title>TheLinuxCommandsHandbook</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/TheLinuxCommandsHandbook/</link><pubDate>Tue, 31 Dec 2024 21:52:35 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/TheLinuxCommandsHandbook/</guid><description>&lt;blockquote>
&lt;p>《TheLinuxCommandsHandbook》结合视频 &lt;a href="https://www.youtube.com/watch?v=ZtqBQ68cfJc">https://www.youtube.com/watch?v=ZtqBQ68cfJc&lt;/a> 看的&lt;/p>
&lt;/blockquote>
&lt;h1 id="command意义">
 Command意义
 &lt;a class="anchor" href="#command%e6%84%8f%e4%b9%89">#&lt;/a>
&lt;/h1>
&lt;p>更快，自动化，在任何Linux上工作，有些工作的基本需求&lt;/p>
&lt;h1 id="系统-unix和windows">
 系统-Unix和Windows
 &lt;a class="anchor" href="#%e7%b3%bb%e7%bb%9f-unix%e5%92%8cwindows">#&lt;/a>
&lt;/h1>
&lt;p>绿色-开源&lt;br>
红色-闭源&lt;br>
黄色-混合&lt;br>
&lt;img src="img/ly-20241226190213859.png" alt="" />&lt;/p>
&lt;p>图片中的Linux只是类Unix，而不是真正的Unix&lt;/p>
&lt;h1 id="freesoftware开源">
 FreeSoftware，开源
 &lt;a class="anchor" href="#freesoftware%e5%bc%80%e6%ba%90">#&lt;/a>
&lt;/h1>
&lt;p>GNU与Linux&lt;/p>
&lt;blockquote>
&lt;p>Linux只是一个&lt;strong>操作系统内核&lt;/strong>而已，而GNU提供了大量的自由软件来丰富在其之上各种应用程序。&lt;br>
绝大多数基于Linux内核的操作系统使用了大量的&lt;strong>GNU软件&lt;/strong>，包括了一个shell程序、工具、程序库、编译器及工具，还有许多其他程序 &lt;br>
&lt;strong>我们常说的Linux，准确地来讲，应该是叫“GNU/Linux”&lt;/strong>。虽然，我们没有为GNU和Linux的开发做出什么贡献，但是我们可以为GNU和Linux的宣传和应用做出微薄的努力，至少我们能够准确地去向其他人解释清楚GNU、Linux以及GNU/Linux之间的区别。让我们一起为GNU/Linux的推广贡献出自己的力量！&lt;/p>
&lt;/blockquote>
&lt;p>内核，用来连接硬件和软件的&lt;/p>
&lt;h1 id="trueunix">
 TrueUNIX
 &lt;a class="anchor" href="#trueunix">#&lt;/a>
&lt;/h1>
&lt;p>Unix一开始是收费的，后面出现Unix-like（类Unix），和Unix标准兼容。&lt;br>
Linux不是真正的Unix，而是类Unix。&lt;br>
Linux本身只是一个内核，连接&lt;strong>硬件&lt;/strong>和&lt;strong>软件&lt;/strong>&lt;br>
LinuxDistributions，Linux发行版(1000多种)&lt;br>
Linux内核是一些GUN工具，文档，包管理器，桌面环境窗口管理，和系统一些其他东西组成的一个系统&lt;br>
&lt;img src="img/ly-20241226190213859.png" alt="" />&lt;/p>
&lt;p>有开源的和不开源的，Linux(LinuxGUN)完全开源&lt;/p>
&lt;h1 id="shell">
 shell
 &lt;a class="anchor" href="#shell">#&lt;/a>
&lt;/h1>
&lt;p>windows（powershell）&lt;br>
把&lt;strong>命令&lt;/strong>交给系统&lt;br>
terminal（最古老时是一个硬件）&amp;ndash;屏幕+带键盘的物理设备，如今是一个软件&lt;br>
默认情况下，&lt;strong>Ubuntu和大多数Linux发行版&lt;/strong>是&lt;strong>bashshell&lt;/strong>，还有zsh&lt;/p>
&lt;h1 id="setup-and-installing">
 setup and installing
 &lt;a class="anchor" href="#setup-and-installing">#&lt;/a>
&lt;/h1>
&lt;p>如果有Mac或者其他Linux发行版，则不需要额外操作。（作者在Mac里装了Ubuntu虚拟机）&lt;/p>
&lt;h2 id="windowssubsystem">
 WindowsSubsystem
 &lt;a class="anchor" href="#windowssubsystem">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>wsl --install&lt;/code>&lt;br>
默认是Ubuntu&lt;/p>
&lt;h1 id="the-linux-handbook电子书内容">
 The Linux Handbook(电子书内容)
 &lt;a class="anchor" href="#the-linux-handbook%e7%94%b5%e5%ad%90%e4%b9%a6%e5%86%85%e5%ae%b9">#&lt;/a>
&lt;/h1>
&lt;p>&lt;strong>Linux 手册&lt;/strong>&lt;/p>
&lt;h2 id="preface">
 Preface
 &lt;a class="anchor" href="#preface">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>前言&lt;/strong>&lt;/p>
&lt;p>The Linux Handbook follows the 80/20 rule: learn in 20% of the time the 80% of a topic.&lt;br>
Linux 手册遵循 80/20 规则：用 20% 的时间学习某个主题的 80%。&lt;/p></description></item><item><title>01学天第一</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/01%E5%AD%A6%E5%A4%A9%E7%AC%AC%E4%B8%80/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/01%E5%AD%A6%E5%A4%A9%E7%AC%AC%E4%B8%80/</guid><description>&lt;p>11&lt;/p></description></item><item><title>02为政第二</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/02%E4%B8%BA%E6%94%BF%E7%AC%AC%E4%BA%8C/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/02%E4%B8%BA%E6%94%BF%E7%AC%AC%E4%BA%8C/</guid><description>&lt;p>11&lt;/p></description></item><item><title>03八佾第三</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/03%E5%85%AB%E4%BD%BE%E7%AC%AC%E4%B8%89/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/03%E5%85%AB%E4%BD%BE%E7%AC%AC%E4%B8%89/</guid><description>&lt;p>11&lt;/p></description></item><item><title>04里仁第四</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/04%E9%87%8C%E4%BB%81%E7%AC%AC%E5%9B%9B/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/04%E9%87%8C%E4%BB%81%E7%AC%AC%E5%9B%9B/</guid><description>&lt;p>11&lt;/p></description></item><item><title>05公治长第五</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AC%AC%E4%BA%94/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/05%E5%85%AC%E5%86%B6%E9%95%BF%E7%AC%AC%E4%BA%94/</guid><description>&lt;p>11&lt;/p></description></item><item><title>06雍也第六</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/06%E9%9B%8D%E4%B9%9F%E7%AC%AC%E5%85%AD/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/06%E9%9B%8D%E4%B9%9F%E7%AC%AC%E5%85%AD/</guid><description>&lt;p>11&lt;/p></description></item><item><title>07述而第七</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/07%E8%BF%B0%E8%80%8C%E7%AC%AC%E4%B8%83/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/07%E8%BF%B0%E8%80%8C%E7%AC%AC%E4%B8%83/</guid><description>&lt;p>11&lt;/p></description></item><item><title>08泰伯第八</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/08%E6%B3%B0%E4%BC%AF%E7%AC%AC%E5%85%AB/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/08%E6%B3%B0%E4%BC%AF%E7%AC%AC%E5%85%AB/</guid><description>&lt;p>11&lt;/p></description></item><item><title>09子罕第九</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/09%E5%AD%90%E7%BD%95%E7%AC%AC%E4%B9%9D/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/09%E5%AD%90%E7%BD%95%E7%AC%AC%E4%B9%9D/</guid><description>&lt;p>11&lt;/p></description></item><item><title>10乡党第十</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/10%E4%B9%A1%E5%85%9A%E7%AC%AC%E5%8D%81/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/10%E4%B9%A1%E5%85%9A%E7%AC%AC%E5%8D%81/</guid><description>&lt;p>11&lt;/p></description></item><item><title>11先进第十一</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/11%E5%85%88%E8%BF%9B%E7%AC%AC%E5%8D%81%E4%B8%80/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/11%E5%85%88%E8%BF%9B%E7%AC%AC%E5%8D%81%E4%B8%80/</guid><description>&lt;p>11&lt;/p></description></item><item><title>12颜渊第十二</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/12%E9%A2%9C%E6%B8%8A%E7%AC%AC%E5%8D%81%E4%BA%8C/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/12%E9%A2%9C%E6%B8%8A%E7%AC%AC%E5%8D%81%E4%BA%8C/</guid><description>&lt;p>11&lt;/p></description></item><item><title>13子路第十三</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/13%E5%AD%90%E8%B7%AF%E7%AC%AC%E5%8D%81%E4%B8%89/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/13%E5%AD%90%E8%B7%AF%E7%AC%AC%E5%8D%81%E4%B8%89/</guid><description>&lt;p>11&lt;/p></description></item><item><title>14宪问第十四</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/14%E5%AE%AA%E9%97%AE%E7%AC%AC%E5%8D%81%E5%9B%9B/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/14%E5%AE%AA%E9%97%AE%E7%AC%AC%E5%8D%81%E5%9B%9B/</guid><description>&lt;p>11&lt;/p></description></item><item><title>15卫灵公第十五</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AC%AC%E5%8D%81%E4%BA%94/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/15%E5%8D%AB%E7%81%B5%E5%85%AC%E7%AC%AC%E5%8D%81%E4%BA%94/</guid><description>&lt;p>11&lt;/p></description></item><item><title>16季氏第十六</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/16%E5%AD%A3%E6%B0%8F%E7%AC%AC%E5%8D%81%E5%85%AD/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/16%E5%AD%A3%E6%B0%8F%E7%AC%AC%E5%8D%81%E5%85%AD/</guid><description>&lt;p>11&lt;/p></description></item><item><title>17阳货第十七</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/17%E9%98%B3%E8%B4%A7%E7%AC%AC%E5%8D%81%E4%B8%83/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/17%E9%98%B3%E8%B4%A7%E7%AC%AC%E5%8D%81%E4%B8%83/</guid><description>&lt;p>11&lt;/p></description></item><item><title>18微子第十八</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/18%E5%BE%AE%E5%AD%90%E7%AC%AC%E5%8D%81%E5%85%AB/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/18%E5%BE%AE%E5%AD%90%E7%AC%AC%E5%8D%81%E5%85%AB/</guid><description>&lt;p>11&lt;/p></description></item><item><title>19子张第十九</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/19%E5%AD%90%E5%BC%A0%E7%AC%AC%E5%8D%81%E4%B9%9D/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/19%E5%AD%90%E5%BC%A0%E7%AC%AC%E5%8D%81%E4%B9%9D/</guid><description>&lt;p>11&lt;/p></description></item><item><title>20尧日第二十</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/20%E5%B0%A7%E6%97%A5%E7%AC%AC%E4%BA%8C%E5%8D%81/</link><pubDate>Sat, 28 Dec 2024 12:02:27 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%AE%BA%E8%AF%AD/20%E5%B0%A7%E6%97%A5%E7%AC%AC%E4%BA%8C%E5%8D%81/</guid><description>&lt;p>11&lt;/p></description></item><item><title>基本知识</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</link><pubDate>Wed, 25 Dec 2024 11:53:40 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</guid><description>&lt;h1 id="周朝君主世系图">
 周朝君主世系图
 &lt;a class="anchor" href="#%e5%91%a8%e6%9c%9d%e5%90%9b%e4%b8%bb%e4%b8%96%e7%b3%bb%e5%9b%be">#&lt;/a>
&lt;/h1>
&lt;h2 id="资治通鉴中">
 资治通鉴中
 &lt;a class="anchor" href="#%e8%b5%84%e6%b2%bb%e9%80%9a%e9%89%b4%e4%b8%ad">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>周威烈王&lt;/strong>始&lt;br>
&lt;img src="img/ly-20241225115821868.png" alt="" />&lt;/p>
&lt;h2 id="完整世系图">
 完整世系图
 &lt;a class="anchor" href="#%e5%ae%8c%e6%95%b4%e4%b8%96%e7%b3%bb%e5%9b%be">#&lt;/a>
&lt;/h2>
&lt;p>《资治通鉴》从&lt;strong>周威烈王&lt;/strong>(图里是32，这个第几任好像各家的算法不一致，不必深究)开始&lt;/p>
&lt;p>&lt;img src="img/ly-20241225115626940.png" alt="" />&lt;/p></description></item><item><title>001周纪一</title><link>https://lwmfjc.github.io/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/001%E5%91%A8%E7%BA%AA%E4%B8%80/</link><pubDate>Tue, 24 Dec 2024 21:48:46 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/culture/%E8%B5%84%E6%B2%BB%E9%80%9A%E9%89%B4/%E5%91%A8%E7%BA%AA/001%E5%91%A8%E7%BA%AA%E4%B8%80/</guid><description>&lt;blockquote>
&lt;p>資治通鑑卷第一&lt;/p>
&lt;p>朝散大夫右諫議大夫權御史中丞充理檢使上護軍賜紫金魚袋臣&lt;/p>
&lt;p>&lt;strong>司马光　奉敕编集&lt;/strong>&lt;/p>
&lt;p>後　　　　　　　　學　　　　　　　　天　　　　　　　台&lt;/p>
&lt;p>&lt;strong>胡三省　音　　註&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>周紀一&lt;/strong> 起著雍攝提格（戊寅），盡玄黓困敦（壬子），凡三十五年。&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>&lt;strong>爾雅&lt;/strong>&lt;/em>：太歲在甲曰閼逢，在乙曰旃zhān蒙，在丙曰柔兆，在丁曰強圉，在戊曰著雍，在己曰屠維，在庚曰上章，在辛曰重光，在壬曰玄黓yì，在癸曰昭陽，是為歲陽。在寅曰攝提格，在卯曰單閼，在辰曰執徐，在巳曰大荒落，在午曰敦牂，在未曰協洽，在申曰涒tūn灘，在酉曰作噩，在戌曰掩茂，在亥曰大淵獻，在子曰困敦，在丑曰赤奮若，是為歲名。&lt;em>&lt;strong>周紀&lt;/strong>&lt;/em>分註「起著雍攝提格」，起戊寅也。「盡玄黓困敦」，盡壬子也。閼，讀如字；史記作「焉」，於乾翻。著，陳如翻。雍，于容翻。黓，逸職翻。單閼，上音丹，又特連翻；下烏葛翻，又于連翻。牂，作郎翻。涒，吐魂翻。灘，吐丹翻。困敦，音頓。&lt;em>杜預&lt;/em> &lt;em>&lt;strong>世族譜&lt;/strong>&lt;/em>曰：&lt;em>周&lt;/em>，&lt;em>黃帝&lt;/em>之苗裔，&lt;em>姬&lt;/em>姓。&lt;em>后稷&lt;/em>之後，封于&lt;em>邰&lt;/em>；及&lt;em>夏&lt;/em>衰，&lt;em>稷&lt;/em>子&lt;em>不窋&lt;/em>zhú竄於西戎。至十二代孫&lt;em>太王&lt;/em>，避&lt;em>狄&lt;/em>遷&lt;em>岐&lt;/em>；至孫&lt;em>文王&lt;/em>受命，&lt;em>武王&lt;/em>克&lt;em>商&lt;/em>而有天下。自&lt;em>武王&lt;/em>至&lt;em>平王&lt;/em>凡十三世，自&lt;em>平王&lt;/em>至&lt;em>威烈王&lt;/em>又十八世，自&lt;em>威烈王&lt;/em>至&lt;em>赧王&lt;/em>又五世。&lt;em>張守節&lt;/em>曰：因&lt;em>太王&lt;/em>居&lt;em>周原&lt;/em>，國號曰&lt;em>周&lt;/em>。&lt;em>&lt;strong>地理志&lt;/strong>&lt;/em>云：&lt;em>右扶風美陽縣岐山&lt;/em>西北&lt;em>中水鄉&lt;/em>，&lt;em>周太王&lt;/em>所邑。&lt;em>括地志&lt;/em>云：故&lt;em>周城&lt;/em>一名&lt;em>美陽城&lt;/em>，在&lt;em>雍州武功縣&lt;/em>西北二十五里。紀，理也，統理眾事而系之年月。&lt;em>溫公&lt;/em>系年用&lt;em>&lt;strong>春秋&lt;/strong>&lt;/em>之法，因&lt;em>&lt;strong>史&lt;/strong>&lt;/em>、&lt;em>&lt;strong>漢&lt;/strong>&lt;/em>本紀而謂之紀。邰，湯來翻。夏，戶雅翻。窋，竹律翻。在雍，於用翻。&lt;/p>
&lt;/blockquote>
&lt;h1 id="威烈王">
 威烈王
 &lt;a class="anchor" href="#%e5%a8%81%e7%83%88%e7%8e%8b">#&lt;/a>
&lt;/h1>
&lt;p>名&lt;em>午&lt;/em>，&lt;em>考王&lt;/em>之子。&lt;em>&lt;strong>諡法&lt;/strong>&lt;/em>：猛以剛果曰威；有功安民曰烈。&lt;em>沈約&lt;/em>曰：諸複諡，有諡人，無諡法。&lt;/p>
&lt;h2 id="二十三年戊寅前四零三">
 二十三年（戊寅，前四零三）
 &lt;a class="anchor" href="#%e4%ba%8c%e5%8d%81%e4%b8%89%e5%b9%b4%e6%88%8a%e5%af%85%e5%89%8d%e5%9b%9b%e9%9b%b6%e4%b8%89">#&lt;/a>
&lt;/h2>
&lt;p>上距&lt;em>&lt;strong>春秋&lt;/strong>&lt;/em>獲麟七十八年，距&lt;em>&lt;strong>左傳&lt;/strong> &lt;em>趙襄子&lt;/em>惎jì&lt;/em>智伯*事七十一年。惎，毒也，音其冀翻。&lt;/p>
&lt;p>1&lt;strong>初命&lt;em>晉&lt;/em>&lt;/strong>‹府新田，山西侯马›&lt;strong>大夫&lt;em>魏&lt;/em>&lt;/strong>‹府安邑，山西夏县›&lt;strong>&lt;em>斯&lt;/em>、&lt;em>趙&lt;/em>&lt;/strong>‹府晋阳，山西太原›&lt;strong>&lt;em>籍&lt;/em>、&lt;em>韓&lt;/em>&lt;/strong>‹府平阳，山西临汾›&lt;strong>&lt;em>虔&lt;/em>為諸侯。&lt;/strong> 此&lt;em>溫公&lt;/em>書法所由始也。&lt;em>魏&lt;/em>之先，&lt;em>畢公&lt;/em>高後，與&lt;em>周&lt;/em>同姓；其苗裔曰&lt;em>畢萬&lt;/em>，始封于&lt;em>魏&lt;/em>，至&lt;em>魏舒&lt;/em>，始為&lt;em>晉&lt;/em>正卿；三世至&lt;em>斯&lt;/em>。&lt;em>趙&lt;/em>之先，&lt;em>造父&lt;/em>後；至&lt;em>叔帶&lt;/em>，始自&lt;em>周&lt;/em>適&lt;em>晉&lt;/em>；至&lt;em>趙夙&lt;/em>，始封于&lt;em>耿&lt;/em>。至&lt;em>趙盾&lt;/em>，始為&lt;em>晉&lt;/em>正卿，六世至&lt;em>籍&lt;/em>。&lt;em>韓&lt;/em>之先，出於&lt;em>周武王&lt;/em>，至&lt;em>韓武子&lt;/em>事&lt;em>晉&lt;/em>，封于&lt;em>韓原&lt;/em>。至&lt;em>韓厥&lt;/em>，為&lt;em>晉&lt;/em>正卿；六世至&lt;em>虔&lt;/em>。三家者，世為&lt;em>晉&lt;/em>大夫，於&lt;em>周&lt;/em>則陪臣也。&lt;em>周&lt;/em>室既衰，&lt;em>晉&lt;/em>主&lt;em>夏&lt;/em>盟，以尊王室，故命之為伯。三卿竊&lt;em>晉&lt;/em>之權，暴蔑其君，剖分其國，此王法所必誅也。&lt;em>威烈王&lt;/em>不惟不能誅之，又命之為諸侯，是崇獎奸名犯分之臣也，&lt;em>&lt;strong>通鑑&lt;/strong>&lt;/em>始於此，其所以謹名分歟！&lt;/p>
&lt;p>〖译文〗 [1]周威烈王姬午初次分封晋国大夫魏斯、赵籍、韩虔为诸侯国君。&lt;/p>
&lt;p>&lt;img src="img/000001.png" alt="" />&lt;/p>
&lt;p>&lt;img src="img/000002.png" alt="" />&lt;/p>
&lt;p>&lt;strong>臣&lt;em>光&lt;/em>曰：臣聞天子之職莫大於禮，禮莫大於分，分莫大於名。&lt;/strong> 分，扶問翻；下同。何謂禮？紀綱是也。&lt;strong>何謂分？君、臣是也。何謂名？公、侯、卿、大夫是也。&lt;/strong>&lt;/p>
&lt;p>〖译文〗 臣司马光曰：我知道天子的职责中最重要的是维护礼教，礼教中最重要的是区分地位，区分地位中最重要的是匡正名分。什么是礼教？就是法纪。什么是区分地位？就是君臣有别。什么是名分？就是公、侯、卿、大夫等官爵。&lt;/p>
&lt;p>&lt;strong>夫以四海之廣，&lt;/strong> 夫以，音扶。&lt;strong>兆民之眾，受制於一人，雖有絕倫之力，高世之智，莫&lt;/strong>【章︰十二行本「莫」下有「敢」字；乙十一行本同；孔本同。】&lt;strong>不奔走而服役者，豈非以禮為之紀綱&lt;/strong>【章︰十二行本，二字互乙；乙十一行本同；孔本同。】&lt;strong>哉！是故天子統三公，&lt;/strong> 統，他綜翻。&lt;strong>三公率諸侯，諸侯制卿大夫，卿大夫治士庶人。&lt;/strong> 治，直之翻。&lt;strong>貴以臨賤，賤以承貴。上之使下猶心腹之運手足，根本之制支葉，下之事上猶手足之衛心腹，支葉之庇本根，然後能上下相保而國家治安。&lt;/strong> 治，直吏翻。&lt;strong>故曰天子之職莫大於禮也。&lt;/strong>&lt;/p>
&lt;p>〖译文〗 四海之广，亿民之众，都受制于天子一人。尽管是才能超群、智慧绝伦的人，也不能不在天子足下为他奔走服务，这难道不是以礼作为礼纪朝纲的作用吗！所以，天子统率三公，三公督率诸侯国君，诸侯国君节制卿、大夫官员，卿、大夫官员又统治士人百姓。权贵支配贱民，贱民服从权贵。上层指挥下层就好像人的心腹控制四肢行动，树木的根和干支配枝和叶；下层服侍上层就好像人的四肢卫护心腹，树木的枝和叶遮护根和干，这样才能上下层互相保护，从而使国家得到长治久安。所以说，天子的职责没有比维护礼制更重要的了。&lt;/p>
&lt;p>&lt;strong>文王序&lt;em>&lt;strong>易&lt;/strong>&lt;/em>，以&lt;em>&lt;strong>乾&lt;/strong>&lt;/em>、&lt;em>&lt;strong>坤&lt;/strong>&lt;/em>為首。&lt;em>孔子&lt;/em>系之曰：「天尊地卑，乾坤定矣。 卑高以陳，貴賤位矣。」&lt;/strong> 系，戶計翻。&lt;strong>言君臣之位猶天地之不可易也。&lt;em>&lt;strong>春秋&lt;/strong>&lt;/em>抑諸侯，尊王&lt;/strong>【章︰十二行本「王」作「周」；乙十一行本同；孔本同；退齋校同。】&lt;strong>室，王人雖微，序於諸侯之上，以是見聖人於君臣之際未嘗不惓惓也&lt;/strong>。惓，逵員翻。&lt;em>&lt;strong>漢劉向傳&lt;/strong>&lt;/em>：忠臣畎quǎn畝，猶不忘君惓惓之義也。惓惓，猶言勤勤也。&lt;strong>非有&lt;em>&lt;strong>桀&lt;/strong>&lt;/em>&lt;/strong>‹姒履癸›、&lt;strong>&lt;em>&lt;strong>紂&lt;/strong>&lt;/em>&lt;/strong>‹子受辛›&lt;strong>之暴&lt;/strong>，&lt;strong>&lt;em>&lt;strong>湯&lt;/strong>&lt;/em>&lt;/strong>‹子天乙›、&lt;strong>&lt;em>&lt;strong>武&lt;/strong>&lt;/em>&lt;/strong>‹姬发›&lt;strong>之仁，人歸之，天命之，君臣之分當守節伏死而已矣。是故以&lt;em>微子&lt;/em>&lt;/strong>‹子启›&lt;strong>而代&lt;em>紂&lt;/em>&lt;/strong>‹子受辛›&lt;strong>則&lt;em>成湯&lt;/em>&lt;/strong>‹子天乙›&lt;strong>配天矣，&lt;/strong> &lt;em>&lt;strong>史記&lt;/strong>&lt;/em>：&lt;em>商帝乙&lt;/em>生三子：長曰&lt;em>微子啟&lt;/em>，次曰&lt;em>中衍&lt;/em>，季曰&lt;em>紂&lt;/em>。&lt;em>紂&lt;/em>之母為后。&lt;em>帝乙&lt;/em>欲立&lt;em>啟&lt;/em>為太子，太史據法爭之曰：「有妻之子，不可立妾之子。」乃立&lt;em>紂&lt;/em>。&lt;em>紂&lt;/em>卒以暴虐亡&lt;em>殷國&lt;/em>。&lt;em>孔鄭玄&lt;/em>義曰：物之大者莫若於天；推父比天，與之相配，行孝之大，莫大於此；所謂「嚴父莫大於配天」也。又&lt;em>孔氏&lt;/em>曰：&lt;em>&lt;strong>禮記&lt;/strong>&lt;/em>稱萬物本乎天，人本乎祖。俱為其本，可以相配，故王者皆以祖配天。&lt;em>&lt;strong>諡法&lt;/strong>&lt;/em>：除殘去虐曰湯。然諡法起于&lt;em>周&lt;/em>；蓋&lt;em>殷&lt;/em>人先有此號，&lt;em>周&lt;/em>人遂引以為諡法。分，扶問翻。長，知兩翻。卒，子恤翻。&lt;strong>以&lt;em>季札&lt;/em>而君&lt;em>吳&lt;/em>則&lt;em>太伯&lt;/em>血食矣，&lt;/strong> 吳王壽夢有子四人：長曰&lt;em>諸樊&lt;/em>，次曰&lt;em>餘祭&lt;/em>，次曰&lt;em>餘昩&lt;/em>，次曰&lt;em>季札&lt;/em>。&lt;em>季札&lt;/em>賢，&lt;em>壽夢&lt;/em>欲立之，&lt;em>季札&lt;/em>讓不可，於是立&lt;em>諸樊&lt;/em>。&lt;em>諸樊&lt;/em>卒，以授&lt;em>餘祭&lt;/em>，欲兄弟以次相傳，必致國于&lt;em>季札&lt;/em>；&lt;em>季札&lt;/em>終讓而逃之。其後&lt;em>諸樊&lt;/em>之子&lt;em>光&lt;/em>與&lt;em>餘昩&lt;/em>之子&lt;em>僚&lt;/em>爭國，至於&lt;em>夫差&lt;/em>，&lt;em>吳&lt;/em>遂以亡。宗廟之祭用牲，故曰血食。&lt;em>太伯&lt;/em>，&lt;em>吳&lt;/em>立國之君。&lt;em>范寧&lt;/em>曰：太者，善大之稱；伯者，長也。&lt;em>周太王&lt;/em>之元子，故曰&lt;em>太伯&lt;/em>。&lt;em>陸德明&lt;/em>曰：壽夢，莫公翻。餘祭，側介翻。餘昩，音末。&lt;strong>然二子寧亡國而不為者，誠以禮之大節不可亂也。故曰禮莫大於分也。&lt;/strong>&lt;/p>
&lt;p>〖译文〗 周文王演绎排列《易经》，以乾、坤为首位。孔子解释说：“天尊贵，地卑微，阳阴于是确定。由低至高排列有序，贵贱也就各得其位。”这是说君主和臣子之间的上下关系就像天和地一样不能互易。《春秋》一书贬低诸侯，尊崇周王室，尽管周王室的官吏地位不高，在书中排列顺序仍在诸侯国君之上，由此可见孔圣人对于君臣关系的关注。如果不是夏桀、商纣那样的暴虐昏君，对手又遇上商汤、周武王这样的仁德明主，使人民归心、上天赐命的话，君臣之间的名分只能是作臣子的恪守臣节，矢死不渝。所以如果商朝立贤明的微子为国君来取代纣王，成汤创立的商朝就可以永配上天；而吴国如果以仁德的季札做君主，开国之君太伯也可以永享祭祀。然而微子、季札二人宁肯国家灭亡也不愿做君主，实在是因为礼教的大节绝不可因此破坏。所以说，礼教中最重要的就是地位高下的区分。&lt;/p>
&lt;p>&lt;strong>夫禮，辨貴賤，序親疏，裁群物，制庶事，非名不著，非器不形；名以命之，器以別之，&lt;/strong> 夫，音扶。別，彼列翻。&lt;strong>然後上下粲然有倫，此禮之大經也。名器既亡，則禮安得獨在哉！昔&lt;em>仲叔于奚&lt;/em>有功于&lt;em>衛&lt;/em>，辭邑而請繁纓，&lt;em>孔子&lt;/em>以為不如多與之邑。惟名與器，不可以假人，君之所司也；政亡則國家從之。&lt;/strong> &lt;em>&lt;strong>左傳&lt;/strong>&lt;/em>：&lt;em>&lt;strong>衛孫桓子&lt;/strong>&lt;/em>帥師與&lt;em>齊&lt;/em>師戰於&lt;em>新築&lt;/em>‹河北大名南›，&lt;em>衛&lt;/em>師敗績。&lt;em>新築&lt;/em>人&lt;em>仲叔&lt;/em>于奚救&lt;em>孫桓子&lt;/em>，&lt;em>桓子&lt;/em>是以免。既而&lt;em>衛&lt;/em>人賞之邑，辭；請曲縣、繁纓以朝，許之。&lt;em>孔子&lt;/em>聞之曰：「不如多與之邑，惟名與器不可以假人。」繁纓，馬飾也。繁，馬鬣上飾；纓，馬膺前飾。&lt;em>晉志註&lt;/em>曰：纓在馬膺如索帬。繁，音蒲官翻。纓，伊盈翻。索，昔各翻。&lt;strong>&lt;em>衛&lt;/em>君待&lt;em>孔子&lt;/em>而為政，&lt;em>孔子&lt;/em>欲先正名，以為名不正則民無所措手足。&lt;/strong> 見&lt;em>&lt;strong>論語&lt;/strong>&lt;/em>。&lt;strong>夫繁纓，小物也，而&lt;em>孔子&lt;/em>惜之；正名，細務也，而&lt;em>孔子&lt;/em>先之：&lt;/strong> 先，悉薦翻。&lt;strong>誠以名器既亂則上下無以相保故也。夫事未有不生於微而成于著，聖人之慮遠，故能謹其微而治之。&lt;/strong> 治，直之翻；下同。&lt;strong>眾人之識近，故必待其著而後救之；治其微則用力寡而功多，救其著則竭力而不能及也。&lt;em>&lt;strong>易&lt;/strong>&lt;/em>曰：「履霜堅冰至，」&lt;/strong> &lt;em>&lt;strong>坤&lt;/strong>&lt;/em>初六爻辭。&lt;em>&lt;strong>象&lt;/strong>&lt;/em>曰：「履霜堅冰，陰始凝也。馴致其道，至堅冰也。」&lt;strong>&lt;em>&lt;strong>書&lt;/strong>&lt;/em>曰：「一日二日萬幾，」&lt;/strong> &lt;em>&lt;strong>皋陶謨&lt;/strong>&lt;/em>之辭。&lt;em>孔安國&lt;/em>&lt;em>&lt;strong>註&lt;/strong>&lt;/em> 曰：幾，微也。言當戒懼萬事之微。幾，居依翻。&lt;strong>謂此類也。故曰分莫大於名也。&lt;/strong> 分，扶問翻。&lt;/p>
&lt;p>〖译文〗 所谓礼教，在于分辨贵贱，排比亲疏，裁决万物，处理日常事物。没有一定的名位，就不能显扬；没有器物，就不能表现。只有用名位来分别称呼，用器物来分别标志，然后上下才能井然有序。这就是礼教的根本所在。如果名位、器物都没有了，那么礼教又怎么能单独存在呢！当年仲叔于奚为卫国建立了大功，他谢绝了赏赐的封地，却请求允许他享用贵族才应有的马饰。孔子认为不如多赏赐他一些封地，惟独名位和器物，绝不能假与他人，这是君王的职权象征；处理政事不坚持原则，国家也就会随着走向危亡。卫国国君期待孔子为他崐处理政事，孔子却先要确立名位，认为名位不正则百姓无所是从。马饰，是一种小器物，而孔子却珍惜它的价值；正名位，是一件小事情，而孔子却要先从它做起，就是因为名位、器物一紊乱，国家上下就无法相安互保。没有一件事情不是从微小之处产生而逐渐发展显著的，圣贤考虑久远，所以能够谨慎对待微小的变故及时予以处理；常人见识短浅，所以必等弊端闹大才来设法挽救。矫正初起的小错，用力小而收效大；挽救已明显的大害，往往是竭尽了全力 也不能成功。《易经》说：“行于霜上而知严寒冰冻将至。”《尚书》说：“先王每天都要兢兢业业地处理成千上万件事情。”就是指这类防微杜渐的例子。所以说，区分地位高下最重要的是匡正各个等级的名分。&lt;/p>
&lt;p>&lt;strong>嗚呼！&lt;em>幽&lt;/em>&lt;/strong>‹姬宫湦shēng›、&lt;strong>&lt;em>厲&lt;/em>&lt;/strong>‹姬胡›&lt;strong>失德，周道日衰，綱紀散壞，下陵上替，諸侯專征，&lt;/strong> 謂&lt;em>齊桓公&lt;/em>，&lt;em>晉文公&lt;/em>至&lt;em>悼公&lt;/em>以及&lt;em>楚莊王&lt;/em>、&lt;em>吳夫差&lt;/em>之類。&lt;strong>大夫擅政&lt;/strong>，謂晉六卿、魯三家、齊田氏之類。禮之大體什喪七八矣，喪，息浪翻。然文‹姬昌›、武‹姬发›之祀猶綿綿相屬者，屬，聯屬也，音之欲翻。凡聯屬之屬皆同音。蓋以周之子孫尚能守其名分故也。何以言之？昔晉文公‹姬重耳›有大功於王室，請隧於襄王‹姬郑›，襄王不許，曰：「王章也。未有代德而有二王，亦叔父之所惡也。不然，叔父有地而隧，又何請焉！」文公於是懼而不敢違。太叔帶之難，襄王出居於氾fàn‹河南襄城›。晉文公帥師納王，殺太叔帶。既定襄王於郟jiá，王勞之以地，辭；請隧焉，王弗許云云。杜預曰：闕地通路曰隧，此乃王者葬禮也。諸侯皆縣柩而下。王章者，章顯王者異於諸侯。古者天子謂同姓諸侯為伯父、叔父。隧，音遂。惡，烏路翻。難，乃旦翻。氾，音泛。勞，力到翻。闕，其月翻。縣，音玄。柩，其久翻。是故以周之地則不大於曹‹山東定陶›、滕‹山東滕州›，以周之民則不眾於邾‹山东邹县›、莒‹山東莒縣›，曹、滕、邾、莒，春秋時小國。莒，居許翻。然歷數百年，宗主天下，雖以晉、楚、齊、秦之強不敢加者，何哉？徒以名分尚存故也。至於季氏之於魯，田常之于齊，白公之于楚，智伯之于晉，魯大夫季氏，自季友以來，世執魯國之政。季平子逐昭公，季康子逐哀公，然終身北面，不敢篡國。田常，即陳恒。田氏本陳氏；溫公避國諱，改「恒」曰「常」。陳成子得齊國之政，殺闞止，弑簡公，而亦不敢自立。史記世家以陳敬仲完為田敬仲完，陳成子恒為田常，故通鑑因以為據。白公勝殺楚令尹子西、司馬子期，石乞曰：「焚庫弑王，不然不濟！」白公曰：「弑王不祥，焚庫無聚。」智伯當晉之衰，專其國政，侵伐鄰國，于晉大夫為最強；攻晉出公，出公道死。智伯欲并晉而不敢，乃奉哀公驕立之。其勢皆足以逐君而自為，然而卒不敢者，卒，子恤翻，終也。豈其力不足而心不忍哉，乃畏奸名犯分而天下共誅之也。奸，居寒翻，亦犯也。分，扶問翻。今晉大夫暴蔑其君，剖分晉國，史記六國年表：定王十六年，趙、魏、韓滅智伯，遂三分晉國。天子既不能討，又寵秩之，使列於諸侯，是區區之名分復不能守而并棄之也。陸德明經典釋文：凡復字，其義訓又者，并音扶又翻。先王之禮於斯盡矣！&lt;/p>
&lt;p>〖译文〗 呜呼！周幽王、周厉王丧失君德，周朝的气数每况愈下。礼纪朝纲土崩瓦解；下欺凌、上衰败；诸侯国君恣意征讨他人；士大夫擅自干预朝政；礼教从总体上已经有十之七八沦丧了。然而周文王、周武王开创的政权还能绵绵不断地延续下来，就是因为周王朝的子孙后裔尚能守定名位。为什么这样说呢？当年晋文公为周朝建立了大功，于是向周襄王请求允许他死后享用王室的隧葬礼制，周襄王没有准许，说：“周王制度明显。没有改朝换代而有两个天子，这也是作为叔父辈的晋文公您所反对的。不然的话，叔父您有地，愿意隧葬，又何必请示我呢？”晋文公于是感到畏惧而没有敢违反礼制。因此，周王室的地盘并不比曹国、滕国大，管辖的臣民也不比邾国、莒国多，然而经过几百年，仍然是天下的宗主，即使是晋、楚、齐、秦那样的强国也还不敢凌驾于其上，这是为什么呢？只是由于周王还保有天子的名分。再看看鲁国的大夫季氏、齐国的田常、楚国的白公胜、晋国的智伯，他们的势力都大得足以驱逐国君而自立，然而他们到底不敢这样做，难道是他们力量不足或是于心不忍吗？只不过是害怕奸夺名位僭犯身分而招致天下的讨伐罢了。现在晋国的三家大夫欺凌蔑视国君，瓜分了晋国，作为天子的周王不能派兵征讨，反而对他们加封赐爵，让他们列位于诸侯国君之中，这样做就使周王朝仅有的一点名分不能再守定而全部放弃了。周朝先王的礼教到此丧失干净！&lt;/p>
&lt;p>或者以為當是之時，周室微弱，三晉強盛，三家分晉國，時因謂之「三晉」，猶後之三秦、三齊也。雖欲勿許，其可得乎！是大不然。夫三晉雖強，苟不顧天下之誅而犯義侵禮，則不請於天子而自立矣。不請於天子而自立，則為悖逆之臣，夫，音扶。悖，蒲內翻，又蒲沒翻。天下苟有桓、文之君，必奉禮義而征之。今請於天子而天子許之，是受天子之命而為諸侯也，誰得而討之！故三晉之列于諸侯，非三晉之壞禮，乃天子自壞之也。壞，音怪，人毀之也。&lt;/p>
&lt;p>〖译文〗 有人认为当时周王室已经衰微，而晋国三家力量强盛，就算周王不想承认他们，又怎么能做得到呢！这种说法是完全错误的。晋国三家虽然强悍，但他们如果打算不顾天下的指责而公然侵犯礼义的话，就不会来请求周天子的批准，而是去自立为君了。不向天子请封而自立为国君，那就是叛逆之臣，天下如果有像齐桓公、晋文公那样的贤德诸侯，一定会尊奉礼义对他们进行征讨。现在晋国三家向天子请封，天子又批准了。他们就是奉天子命令而成为诸侯的，谁又能对他们加以讨伐呢！所以晋国三家大夫成为诸侯，并不是晋国三家破坏了礼教，正是周天子自已破坏了周朝的礼教啊！&lt;/p>
&lt;p>烏呼！君臣之禮既壞矣，此壞，其義為成壞之壞，讀如字。則天下以智力相雄長，長，知兩翻。遂使聖賢之後為諸侯者，社稷無不泯絕，謂齊、宋亡于田氏，魯、陳、越亡于楚，鄭亡于韓也。泯，彌忍翻，盡也，又彌鄰翻。毛晃曰：沒也，滅也。生民之類糜滅幾盡，說文曰：糜，糝sǎn也；取糜爛之義，音忙皮翻。幾，居依翻，又渠希翻，近也。豈不哀哉！&lt;/p></description></item><item><title>16-18</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/16-18/</link><pubDate>Tue, 24 Dec 2024 09:46:52 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/16-18/</guid><description>&lt;h1 id="向bash脚本添加参数">
 向bash脚本添加参数
 &lt;a class="anchor" href="#%e5%90%91bash%e8%84%9a%e6%9c%ac%e6%b7%bb%e5%8a%a0%e5%8f%82%e6%95%b0">#&lt;/a>
&lt;/h1>
&lt;h2 id="basic">
 basic
 &lt;a class="anchor" href="#basic">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>─ ~/shellTest ly@vmmin 10:37:24
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╰─❯ cat ./16myscript_cls.sh 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;You entered the argument: &lt;/span>$1&lt;span style="color:#e6db74">,&lt;/span>$2&lt;span style="color:#e6db74">,&lt;/span>$3&lt;span style="color:#e6db74">, and &lt;/span>$4&lt;span style="color:#e6db74">.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>╭─ ~/shellTest 16s ly@vmmin 10:37:18
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╰─❯ ./16myscript_cls.sh Linux1 Linux2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>You entered the argument: Linux1,Linux2,, and .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="示例1">
 示例1
 &lt;a class="anchor" href="#%e7%a4%ba%e4%be%8b1">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>╭─ ~/shellTest ly@vmmin 10:41:45
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╰─❯ cat ./16myscript_cls.sh 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls -lh $1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#echo &amp;#34;You entered the argument: $1,$2,$3, and $4.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╭─ ~/shellTest ly@vmmin 10:41:28
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╰─❯ ./16myscript_cls.sh /etc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total 792K
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root 3.0K May &lt;span style="color:#ae81ff">25&lt;/span> &lt;span style="color:#ae81ff">2023&lt;/span> adduser.conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">44&lt;/span> Dec &lt;span style="color:#ae81ff">17&lt;/span> 15:26 adjtime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root &lt;span style="color:#ae81ff">194&lt;/span> Dec &lt;span style="color:#ae81ff">23&lt;/span> 22:38 aliases
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x &lt;span style="color:#ae81ff">2&lt;/span> root root 4.0K Dec &lt;span style="color:#ae81ff">23&lt;/span> 22:38 alternatives
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x &lt;span style="color:#ae81ff">2&lt;/span> root root 4.0K Dec &lt;span style="color:#ae81ff">17&lt;/span> 15:24 apparmor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x &lt;span style="color:#ae81ff">8&lt;/span> root root 4.0K Dec &lt;span style="color:#ae81ff">17&lt;/span> 15:25 apparmor.d
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drwxr-xr-x &lt;span style="color:#ae81ff">9&lt;/span> root root 4.0K Dec &lt;span style="color:#ae81ff">17&lt;/span> 15:30 apt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r----- &lt;span style="color:#ae81ff">1&lt;/span> root daemon &lt;span style="color:#ae81ff">144&lt;/span> Oct &lt;span style="color:#ae81ff">16&lt;/span> &lt;span style="color:#ae81ff">2022&lt;/span> at.deny
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> root root 2.0K Mar &lt;span style="color:#ae81ff">30&lt;/span> &lt;span style="color:#ae81ff">2024&lt;/span> bash.bashrc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="示例2">
 示例2
 &lt;a class="anchor" href="#%e7%a4%ba%e4%be%8b2">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lines&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>ls -lh $1 | wc -l&lt;span style="color:#66d9ef">)&lt;/span> &lt;span style="color:#75715e">#行计数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;You hava &lt;/span>&lt;span style="color:#66d9ef">$((&lt;/span>$lines&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#66d9ef">))&lt;/span>&lt;span style="color:#e6db74"> objects in the &lt;/span>$1&lt;span style="color:#e6db74"> directory.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#$(($lines-1))这里用到了子shell&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#echo &amp;#34;You entered the argument: $1,$2,$3, and $4.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>╭─ ~/shellTest ly@vmmin 10:48:06
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╰─❯ ls -lh logfiles 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total 12K
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> ly ly &lt;span style="color:#ae81ff">0&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 23:07 a.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> ly ly &lt;span style="color:#ae81ff">120&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 23:17 a.log.tar.gz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> ly ly &lt;span style="color:#ae81ff">0&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 23:07 b.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> ly ly &lt;span style="color:#ae81ff">121&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 23:17 b.log.tar.gz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> ly ly &lt;span style="color:#ae81ff">0&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 23:07 c.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> ly ly &lt;span style="color:#ae81ff">121&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 23:17 c.log.tar.gz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> ly ly &lt;span style="color:#ae81ff">0&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 23:15 xx.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-r--r-- &lt;span style="color:#ae81ff">1&lt;/span> ly ly &lt;span style="color:#ae81ff">0&lt;/span> Dec &lt;span style="color:#ae81ff">22&lt;/span> 23:15 y.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╭─ ~/shellTest ly@vmmin 10:48:10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╰─❯ ./16myscript_cls.sh logfiles
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>You hava &lt;span style="color:#ae81ff">8&lt;/span> objects in the logfiles directory.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>head，表示前十行，可以看出total这些被算作一行了，所以上面的shell中-1&lt;/p></description></item><item><title>12-15</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/12-15/</link><pubDate>Mon, 23 Dec 2024 21:03:03 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/12-15/</guid><description>&lt;h1 id="functions-函数">
 functions 函数
 &lt;a class="anchor" href="#functions-%e5%87%bd%e6%95%b0">#&lt;/a>
&lt;/h1>
&lt;p>以&lt;code>update&lt;/code>这个脚本为基础编改&lt;br>
作用&lt;/p>
&lt;ul>
&lt;li>减少重复代码&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>release_file&lt;span style="color:#f92672">=&lt;/span>/etc/os-release
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>logfile&lt;span style="color:#f92672">=&lt;/span>/var/log/updater.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>errorlog&lt;span style="color:#f92672">=&lt;/span>/var/log/updater_errors.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>check_exit_status&lt;span style="color:#f92672">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $? -ne &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;An error occured,please check the &lt;/span>$errorlog&lt;span style="color:#e6db74"> file.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> grep -q &lt;span style="color:#e6db74">&amp;#34;Arch&amp;#34;&lt;/span> $release_file 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo pacman -Syu 1&amp;gt;&amp;gt;$logfile 2&amp;gt;&amp;gt;$errorlog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> check_exit_status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> grep -q &lt;span style="color:#e6db74">&amp;#34;Ubuntu&amp;#34;&lt;/span> $release_file &lt;span style="color:#f92672">||&lt;/span> grep -q &lt;span style="color:#e6db74">&amp;#34;Debian&amp;#34;&lt;/span> $release_file 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo apt update 1&amp;gt;&amp;gt;$logfile 2&amp;gt;&amp;gt;$errorlog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> check_exit_status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#默认yes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sudo apt dist-upgrade -y 1&amp;gt;&amp;gt;$logfile 2&amp;gt;&amp;gt;$errorlog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> check_exit_status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="casestatements">
 CaseStatements
 &lt;a class="anchor" href="#casestatements">#&lt;/a>
&lt;/h1>
&lt;h2 id="脚本">
 脚本
 &lt;a class="anchor" href="#%e8%84%9a%e6%9c%ac">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>╭─ ~/shellTest ly@vmmin 22:32:52
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╰─❯ cat ./13myscript_cls.sh 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>finished&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $finished -ne &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;What is your favorite Linux distribution?&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;1 - Arch&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;2 - CentOS&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;3 - Debian&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;4 - Mint&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;5 - Something else..&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;6 - exit&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> read distro;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> $distro in 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;Arch is xxx&amp;#34;&lt;/span>;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;CentOS is xbxxx&amp;#34;&lt;/span>;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;Debian is bbbxx&amp;#34;&lt;/span>;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 4&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;Mint is xxxxsss&amp;#34;&lt;/span>;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 5&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;Something els.xxxxx&amp;#34;&lt;/span>;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 6&lt;span style="color:#f92672">)&lt;/span> finished&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;now will exit&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> *&lt;span style="color:#f92672">)&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;you didn&amp;#39;t enter an xxxx choice.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">esac&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;Thanks for using this script.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="脚本执行">
 脚本执行
 &lt;a class="anchor" href="#%e8%84%9a%e6%9c%ac%e6%89%a7%e8%a1%8c">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>╭─ ~/shellTest ly@vmmin 22:32:11
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╰─❯ ./13myscript_cls.sh 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>What is your favorite Linux distribution?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> - Arch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> - CentOS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> - Debian
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> - Mint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">5&lt;/span> - Something &lt;span style="color:#66d9ef">else&lt;/span>..
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> - exit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Debian is bbbxx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>What is your favorite Linux distribution?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> - Arch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> - CentOS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> - Debian
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> - Mint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">5&lt;/span> - Something &lt;span style="color:#66d9ef">else&lt;/span>..
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> - exit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>u
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>you didn&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>t enter an xxxx choice.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>What is your favorite Linux distribution?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> - Arch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span> - CentOS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span> - Debian
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span> - Mint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">5&lt;/span> - Something &lt;span style="color:#66d9ef">else&lt;/span>..
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span> - exit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>now will exit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Thanks &lt;span style="color:#66d9ef">for&lt;/span> using this script. 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="schedulejobs">
 ScheduleJobs
 &lt;a class="anchor" href="#schedulejobs">#&lt;/a>
&lt;/h1>
&lt;h2 id="作用">
 作用
 &lt;a class="anchor" href="#%e4%bd%9c%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;p>脚本在特定时间运行&lt;/p></description></item><item><title>11DataStreams</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/11DataStreams/</link><pubDate>Mon, 23 Dec 2024 12:12:45 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/11DataStreams/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>下面的输出中，涉及到标准输出的，有十几行的那些，只列举了其中四五行&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;h1 id="概念">
 概念
 &lt;a class="anchor" href="#%e6%a6%82%e5%bf%b5">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>标准输入，标准输出，标准错误&lt;/li>
&lt;li>标准输出：打印到屏幕上的输出&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>╭─ ~ ly@vmmin 12:31:44
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╰─❯ ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>content.zh index.html myfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dufs.log install.sh shellTest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╭─ ~ ly@vmmin 12:32:21
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╰─❯ echo $?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>标准错误&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>╭─ ~ ly@vmmin 12:30:27
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╰─❯ ls /notexist
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls: cannot access &lt;span style="color:#e6db74">&amp;#39;/notexist&amp;#39;&lt;/span>: No such file or directory
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╭─ ~ ly@vmmin 12:30:59
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╰─❯ echo $?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="标准输出和标准错误">
 标准输出和标准错误
 &lt;a class="anchor" href="#%e6%a0%87%e5%87%86%e8%be%93%e5%87%ba%e5%92%8c%e6%a0%87%e5%87%86%e9%94%99%e8%af%af">#&lt;/a>
&lt;/h1>
&lt;h2 id="部分重定向">
 部分重定向
 &lt;a class="anchor" href="#%e9%83%a8%e5%88%86%e9%87%8d%e5%ae%9a%e5%90%91">#&lt;/a>
&lt;/h2>
&lt;h3 id="标准错误重定向-2">
 标准错误重定向 2&amp;gt;
 &lt;a class="anchor" href="#%e6%a0%87%e5%87%86%e9%94%99%e8%af%af%e9%87%8d%e5%ae%9a%e5%90%91-2">#&lt;/a>
&lt;/h3>
&lt;blockquote>
&lt;p>find，文件系统&lt;br>
find /etc -type f&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 下面是附加知识，最后没用到&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#新建一个用户，-m 让用户具有默认主目录，-d指定目录，-s指定用户登入后所使用的shell&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo useradd -d /home/ly1 -s /bin/bash -m ly1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#设置密码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo passwd ly1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了演示错误，先创建几个文件&lt;/p></description></item><item><title>07-10</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/07-10/</link><pubDate>Sat, 21 Dec 2024 12:00:26 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/07-10/</guid><description>&lt;h1 id="whileloops">
 WhileLoops
 &lt;a class="anchor" href="#whileloops">#&lt;/a>
&lt;/h1>
&lt;h2 id="范例">
 范例
 &lt;a class="anchor" href="#%e8%8c%83%e4%be%8b">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>myvar&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#小于或者等于10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $myvar -le &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo $myvar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> myvar&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$((&lt;/span> $myvar &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">))&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep 0.5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>╭─ ~/shellTest ≡ ly@vmmin 12:10:33
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>╰─❯ ./71myscript_cls.sh 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>数字会每隔0.5s就输出一次&lt;br>
对于&lt;code>myvar=$(( $myvar + 1 ))&lt;/code> ，&lt;code>$((expression))&lt;/code>形式表示算数运算，而且其中的空格是可以省略的&lt;/p>
&lt;h2 id="范例2">
 范例2
 &lt;a class="anchor" href="#%e8%8c%83%e4%be%8b2">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -f ~/testfile &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;As of &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>date&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">,the test file exists.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;As of &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>date&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">, the test ....has gone missing.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用来测试文件是否存在，运行前先新建一下文件&lt;code>touch ~/testfile&lt;/code>
运行一会后把文件删除，如图&lt;br>
&lt;img src="img/ly-20241221124800683.png" alt="" />&lt;/p></description></item><item><title>每日摘抄</title><link>https://lwmfjc.github.io/zh/docs/life/dailyExcerpt/</link><pubDate>Sat, 21 Dec 2024 11:02:36 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/life/dailyExcerpt/</guid><description>&lt;ul>
&lt;li>欲买桂花同载酒，终不似，少年游。&lt;/li>
&lt;li>君埋泉下泥销骨，我寄人间雪满头。&lt;/li>
&lt;li>吾不识青天高，黄地厚。唯见月寒日暖，来煎人寿。&lt;/li>
&lt;li>&amp;ldquo;老妈看不到你变老的样子了&amp;rdquo;&lt;/li>
&lt;li>我也曾闪亮如星，而非没入尘埃。&lt;/li>
&lt;li>我并非一直无人问津，也曾有人对我寄予厚望。&lt;/li>
&lt;li>&amp;ldquo;你要好好读书，将来让他们都有工作。&amp;rdquo;&lt;/li>
&lt;li>人道洛阳花似锦，偏我来时不逢春。&lt;/li>
&lt;/ul></description></item><item><title>06ExitCode</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/06ExitCode/</link><pubDate>Sat, 21 Dec 2024 10:25:30 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/06ExitCode/</guid><description>&lt;h1 id="意义">
 意义
 &lt;a class="anchor" href="#%e6%84%8f%e4%b9%89">#&lt;/a>
&lt;/h1>
&lt;p>用来确定代码是否执行成功&lt;/p>
&lt;h1 id="例子">
 例子
 &lt;a class="anchor" href="#%e4%be%8b%e5%ad%90">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>ls -l /misc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $? &lt;span style="color:#75715e">#输出2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls -l ~
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo $? &lt;span style="color:#75715e">#输出0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>$?&lt;/code>用来显示最近一个命令的状态，&lt;strong>零表示成功，非零表示失败&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#这个例子之前，作者用 sudo apt remove htop 命令把htop删除了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package&lt;span style="color:#f92672">=&lt;/span>htop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install $package
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;The exit code for ....is &lt;/span>$?&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>安装完毕后显示返回0&lt;br>
&lt;img src="img/ly-20241221090730345.png" alt="" />&lt;br>
另一个示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package&lt;span style="color:#f92672">=&lt;/span>notexist
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install $package
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;The exit code for ....is &lt;/span>$?&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#执行后显示&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Reading package lists... Done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Building dependency tree... Done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Reading state information... Done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#E: Unable to locate package notexist&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#The exit code for ....is 100&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="配合if语句">
 配合if语句
 &lt;a class="anchor" href="#%e9%85%8d%e5%90%88if%e8%af%ad%e5%8f%a5">#&lt;/a>
&lt;/h1>
&lt;h2 id="基本功能">
 基本功能
 &lt;a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e5%8a%9f%e8%83%bd">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>package&lt;span style="color:#f92672">=&lt;/span>htop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install $package
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $? -eq &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;The installation of &lt;/span>$package&lt;span style="color:#e6db74"> success...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;new comman here:&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> which $package
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$package&lt;span style="color:#e6db74"> failed ...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span> 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之前前作者用&lt;code>sudo apt remove htop&lt;/code>又把htop删除了，不过其实不删除也是走的&lt;code> echo &amp;quot;The installation of .....&amp;quot;&lt;/code>这个分支&lt;br>
结果：&lt;/p></description></item><item><title>05If</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/05If/</link><pubDate>Fri, 20 Dec 2024 18:03:12 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/05If/</guid><description>&lt;blockquote>
&lt;p>在shell中，零为真，非零为假。&lt;/p>
&lt;/blockquote>
&lt;h1 id="if-then-fi">
 if then fi
 &lt;a class="anchor" href="#if-then-fi">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>mynum&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">200&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[和]前后都要有空格&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $mynum -eq &lt;span style="color:#ae81ff">200&lt;/span> &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;The condition is true.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="img/ly-20241220220441993.png" alt="" />&lt;br>
编辑之后，按ctrl + O 保存文件&lt;br>
ctrl + T + Z 保持在后台，&lt;code>fg&lt;/code>+回车 恢复&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mynum&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">200&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[和]前后都要有空格&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $mynum -eq &lt;span style="color:#ae81ff">200&lt;/span> &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;The condition is true.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $mynum -eq &lt;span style="color:#ae81ff">300&lt;/span> &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;The variable does not equal 200.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="img/ly-20241220221311757.png" alt="" />&lt;/p>
&lt;h1 id="else-if">
 else if
 &lt;a class="anchor" href="#else-if">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mynum&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">300&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[和]前后都要有空格&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> $mynum -eq &lt;span style="color:#ae81ff">200&lt;/span> &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;The condition is true.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;The variable does not equal&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">fi
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="img/ly-20241220221542876.png" alt="" />&lt;/p></description></item><item><title>01-04</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/01-04/</link><pubDate>Fri, 20 Dec 2024 15:28:33 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/SHELLlearnLinuxTV_/01-04/</guid><description>&lt;h1 id="意义">
 意义
 &lt;a class="anchor" href="#%e6%84%8f%e4%b9%89">#&lt;/a>
&lt;/h1>
&lt;p>执行一系列命令&lt;/p>
&lt;h1 id="视频框架">
 视频框架
 &lt;a class="anchor" href="#%e8%a7%86%e9%a2%91%e6%a1%86%e6%9e%b6">#&lt;/a>
&lt;/h1>
&lt;ol>
&lt;li>介绍，欢迎&lt;/li>
&lt;li>HelloWorld&lt;/li>
&lt;li>变量&lt;/li>
&lt;li>数学函数&lt;/li>
&lt;li>if语句&lt;/li>
&lt;li>退出代码&lt;/li>
&lt;li>while循环&lt;/li>
&lt;li>更新脚本，保持服务器最新状态&lt;/li>
&lt;li>for循环&lt;/li>
&lt;li>脚本应该存储在文件系统哪个位置&lt;/li>
&lt;li>数据流，标准输入、标准输出、标准错误输出&lt;/li>
&lt;li>函数&lt;/li>
&lt;li>case语句&lt;/li>
&lt;li>调度作业（SchedulingJobs）Part1&lt;/li>
&lt;li>调度作业（SchedulingJobs）Part2&lt;/li>
&lt;li>传递参数&lt;/li>
&lt;li>备份脚本&lt;/li>
&lt;/ol>
&lt;h1 id="准备">
 准备
 &lt;a class="anchor" href="#%e5%87%86%e5%a4%87">#&lt;/a>
&lt;/h1>
&lt;p>需要一台运行Linux系统的计算机（或虚拟机）&lt;/p>
&lt;h1 id="一些基本操作">
 一些基本操作
 &lt;a class="anchor" href="#%e4%b8%80%e4%ba%9b%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h1>
&lt;h2 id="新建或编辑脚本">
 新建或编辑脚本
 &lt;a class="anchor" href="#%e6%96%b0%e5%bb%ba%e6%88%96%e7%bc%96%e8%be%91%e8%84%9a%e6%9c%ac">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>nano myscript.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="内容">
 内容
 &lt;a class="anchor" href="#%e5%86%85%e5%ae%b9">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="img/ly-20241220161539489.png" alt="" />&lt;br>
&lt;strong>ctrl + o 保存，ctrl + x 退出&lt;/strong>&lt;/p>
&lt;h2 id="如何执行脚本">
 如何执行脚本
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e8%84%9a%e6%9c%ac">#&lt;/a>
&lt;/h2>
&lt;h3 id="权限">
 权限
 &lt;a class="anchor" href="#%e6%9d%83%e9%99%90">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#给脚本赋予执行的权限&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo chmod +x myscript.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="执行">
 执行
 &lt;a class="anchor" href="#%e6%89%a7%e8%a1%8c">#&lt;/a>
&lt;/h3>
&lt;h4 id="执行前查看权限">
 执行前查看权限
 &lt;a class="anchor" href="#%e6%89%a7%e8%a1%8c%e5%89%8d%e6%9f%a5%e7%9c%8b%e6%9d%83%e9%99%90">#&lt;/a>
&lt;/h4>
&lt;p>&lt;img src="img/ly-20241220161925488.png" alt="" />&lt;/p>
&lt;h4 id="运行">
 运行
 &lt;a class="anchor" href="#%e8%bf%90%e8%a1%8c">#&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>./myscript.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="查看脚本">
 查看脚本
 &lt;a class="anchor" href="#%e6%9f%a5%e7%9c%8b%e8%84%9a%e6%9c%ac">#&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cat myscript.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="更多语句的脚本">
 更多语句的脚本
 &lt;a class="anchor" href="#%e6%9b%b4%e5%a4%9a%e8%af%ad%e5%8f%a5%e7%9a%84%e8%84%9a%e6%9c%ac">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pwd
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出&lt;br>
&lt;img src="img/ly-20241220162310803.png" alt="" />&lt;/p></description></item><item><title>基础</title><link>https://lwmfjc.github.io/zh/docs/technology/RegExp/baseCoreySchafer/base/</link><pubDate>Thu, 19 Dec 2024 17:49:52 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/RegExp/baseCoreySchafer/base/</guid><description>&lt;h1 id="环境">
 环境
 &lt;a class="anchor" href="#%e7%8e%af%e5%a2%83">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>使用视频作者给出的示例，&lt;code>https://github.com/CoreyMSchafer/code_snippets/tree/master/Regular-Expressions&lt;/code>&lt;/li>
&lt;li>使用sublimeText打开的文件，ctrl+f时要确认勾选正则及区分大小写&lt;br>
&lt;img src="img/ly-20241220122930504.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h1 id="simpletxt-基础操作">
 simple.txt-基础操作
 &lt;a class="anchor" href="#simpletxt-%e5%9f%ba%e7%a1%80%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h1>
&lt;h2 id="直接搜索">
 直接搜索
 &lt;a class="anchor" href="#%e7%9b%b4%e6%8e%a5%e6%90%9c%e7%b4%a2">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241220123410992.png" alt="" />&lt;/p>
&lt;h2 id="任意字符">
 任意字符
 &lt;a class="anchor" href="#%e4%bb%bb%e6%84%8f%e5%ad%97%e7%ac%a6">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241220123521273.png" alt="" />&lt;br>
这里默认不会显示所有，点击findAll才会出来&lt;/p>
&lt;h2 id="有些字符需要加反斜杠转义比如--点以及--斜杠本身">
 有些字符需要加反斜杠转义，比如 . （点）以及 \ （斜杠本身）
 &lt;a class="anchor" href="#%e6%9c%89%e4%ba%9b%e5%ad%97%e7%ac%a6%e9%9c%80%e8%a6%81%e5%8a%a0%e5%8f%8d%e6%96%9c%e6%9d%a0%e8%bd%ac%e4%b9%89%e6%af%94%e5%a6%82--%e7%82%b9%e4%bb%a5%e5%8f%8a--%e6%96%9c%e6%9d%a0%e6%9c%ac%e8%ba%ab">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>/////，从左到右，和书写方向一致的叫做(正)斜杠。&lt;br>
反之，叫做反斜杠 \&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="img/ly-20241220124259552.png" alt="" />&lt;br>
&lt;img src="img/ly-20241220124341898.png" alt="" />&lt;/p>
&lt;h2 id="一些元字符">
 一些元字符
 &lt;a class="anchor" href="#%e4%b8%80%e4%ba%9b%e5%85%83%e5%ad%97%e7%ac%a6">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>. - Any Character Except New Line 除了换行符的任意字符
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">\d&lt;/span> - Digit &lt;span style="color:#f92672">(&lt;/span>0-9&lt;span style="color:#f92672">)&lt;/span> 数字
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">\D&lt;/span> - Not a Digit &lt;span style="color:#f92672">(&lt;/span>0-9&lt;span style="color:#f92672">)&lt;/span> 非数字
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">\w&lt;/span> - Word Character &lt;span style="color:#f92672">(&lt;/span>a-z, A-Z, 0-9, _&lt;span style="color:#f92672">)&lt;/span> 单词字符，大小写字母+数字+下划线
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">\W&lt;/span> - Not a Word Character 非单词字符
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">\s&lt;/span> - Whitespace &lt;span style="color:#f92672">(&lt;/span>space, tab, newline&lt;span style="color:#f92672">)&lt;/span> 空白字符，空格+tab+换行符
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">\S&lt;/span> - Not Whitespace &lt;span style="color:#f92672">(&lt;/span>space, tab, newline&lt;span style="color:#f92672">)&lt;/span> 非空白字符
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">\b&lt;/span> - Word Boundary 边界字符-单词边界
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">\B&lt;/span> - Not a Word Boundary 非单词边界&lt;span style="color:#f92672">(&lt;/span>没有单词边界&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>^ - Beginning of a String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ - End of a String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[]&lt;/span> - Matches Characters in brackets
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>^ &lt;span style="color:#f92672">]&lt;/span> - Matches Characters NOT in brackets
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| - Either Or
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span> &lt;span style="color:#f92672">)&lt;/span> - Group
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Quantifiers:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>* - &lt;span style="color:#ae81ff">0&lt;/span> or More
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+ - &lt;span style="color:#ae81ff">1&lt;/span> or More
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>? - &lt;span style="color:#ae81ff">0&lt;/span> or One
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>3&lt;span style="color:#f92672">}&lt;/span> - Exact Number
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>3,4&lt;span style="color:#f92672">}&lt;/span> - Range of Numbers &lt;span style="color:#f92672">(&lt;/span>Minimum, Maximum&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#### Sample Regexs ####&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>a-zA-Z0-9_.+-&lt;span style="color:#f92672">]&lt;/span>+@&lt;span style="color:#f92672">[&lt;/span>a-zA-Z0-9-&lt;span style="color:#f92672">]&lt;/span>+&lt;span style="color:#ae81ff">\.&lt;/span>&lt;span style="color:#f92672">[&lt;/span>a-zA-Z0-9-.&lt;span style="color:#f92672">]&lt;/span>+
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="边界字符">
 边界字符
 &lt;a class="anchor" href="#%e8%be%b9%e7%95%8c%e5%ad%97%e7%ac%a6">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="img/ly-20241220145605631.png" alt="" />&lt;/p></description></item><item><title>pdfTest</title><link>https://lwmfjc.github.io/zh/docs/test/hello2/</link><pubDate>Sat, 14 Dec 2024 06:32:01 +0800</pubDate><guid>https://lwmfjc.github.io/zh/docs/test/hello2/</guid><description>&lt;p>sd44sdf&lt;br>
s2&lt;strong>345&lt;/strong>df&lt;br>
sssdfadf&lt;/p>
&lt;p>&lt;br>
111&lt;/p></description></item><item><title>使用PaperMode</title><link>https://lwmfjc.github.io/zh/docs/technology/Hugo/themes/PaperMod/01/</link><pubDate>Wed, 11 Dec 2024 08:23:34 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Hugo/themes/PaperMod/01/</guid><description>&lt;h1 id="地址">
 地址
 &lt;a class="anchor" href="#%e5%9c%b0%e5%9d%80">#&lt;/a>
&lt;/h1>
&lt;p>官方： &lt;a href="https://github.com/adityatelange/hugo-PaperMod/wiki/Installation">https://github.com/adityatelange/hugo-PaperMod/wiki/Installation&lt;/a> （有些东西没有同hugo官方同步）
非官方： &lt;a href="https://github.com/vanitysys28/hugo-papermod-wiki/blob/master/Home.md">https://github.com/vanitysys28/hugo-papermod-wiki/blob/master/Home.md&lt;/a> （与hugo官方更同步）&lt;/p>
&lt;h1 id="安装">
 安装
 &lt;a class="anchor" href="#%e5%ae%89%e8%a3%85">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>hugo new site blog.source --format yaml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd blog.source
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git init
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git submodule add --depth&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git submodule update --init --recursive &lt;span style="color:#75715e"># needed when you reclone your repo (submodules may not get cloned automatically) &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git submodule update --remote --merge
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>hugo进阶学习20-23</title><link>https://lwmfjc.github.io/zh/docs/technology/Hugo/GiraffeAcademy/advanced20-23/</link><pubDate>Tue, 10 Dec 2024 15:54:58 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Hugo/GiraffeAcademy/advanced20-23/</guid><description>&lt;p>&lt;img src="img/ly-20241212142130925.png" alt="" />&lt;/p>
&lt;h1 id="datefiles">
 DateFiles
 &lt;a class="anchor" href="#datefiles">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#960050;background-color:#1e0010">%&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">raw&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">%&lt;/span>} 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;classA&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;json位置: data\\classes.json&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;classA&amp;#34;&lt;/span>:{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;master&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;xiaoLi&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;number&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;05&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;classB&amp;#34;&lt;/span>:{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;master&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;aXiang&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;number&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;15&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;classC&amp;#34;&lt;/span>:{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;master&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;BaoCeng&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;number&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;20&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#960050;background-color:#1e0010">%&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">endraw&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">%&lt;/span>} 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>模板代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>{% raw %} 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{/* layouts\_default\single.html */}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{ define &amp;#34;main&amp;#34; }}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{ range .Site.Data.classes }}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> master:{{.master}}==number:{{.number}}&amp;lt;&lt;span style="color:#f92672">br&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{end}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{end}} 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{% endraw %} 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="img/ly-20241212142131035.png" alt="" />&lt;/p>
&lt;h1 id="partialtemplates">
 PartialTemplates
 &lt;a class="anchor" href="#partialtemplates">#&lt;/a>
&lt;/h1>
&lt;h2 id="传递全局范围">
 传递全局范围
 &lt;a class="anchor" href="#%e4%bc%a0%e9%80%92%e5%85%a8%e5%b1%80%e8%8c%83%e5%9b%b4">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>{% raw %} 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{/*layouts\partials\header.html*/}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">h1&lt;/span>&amp;gt;{{.Title}}&amp;lt;/&lt;span style="color:#f92672">h1&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="color:#f92672">p&lt;/span>&amp;gt;{{.Date}}&amp;lt;/&lt;span style="color:#f92672">p&lt;/span>&amp;gt; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{% endraw %} 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>{% raw %} 
{{/*layouts\_default\single.html*/}}
{{ define &amp;#34;main&amp;#34; }}
 {{ partial &amp;#34;header&amp;#34; . }}
 {{/*点.传递了当前文件的范围，代表了所有的范围，所有可以访问的变量*/}}
 &amp;lt;hr&amp;gt;
{{end}} 
{% endraw %} 
&lt;/code>&lt;/pre>&lt;p>预览：&lt;br>
&lt;img src="img/ly-20241212142131117.png" alt="" />&lt;/p></description></item><item><title>hugo进阶学习17-19</title><link>https://lwmfjc.github.io/zh/docs/technology/Hugo/GiraffeAcademy/advanced17-19/</link><pubDate>Mon, 09 Dec 2024 23:50:43 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Hugo/GiraffeAcademy/advanced17-19/</guid><description>&lt;p>&lt;img src="img/ly-20241212142130125.png" alt="" />&lt;/p>
&lt;h1 id="variable">
 Variable
 &lt;a class="anchor" href="#variable">#&lt;/a>
&lt;/h1>
&lt;h2 id="文件结构">
 文件结构
 &lt;a class="anchor" href="#%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142130325.png" alt="" />&lt;/p>
&lt;h2 id="实战">
 实战
 &lt;a class="anchor" href="#%e5%ae%9e%e6%88%98">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#a6e22e">raw&lt;/span> &lt;span style="color:#f92672">%&lt;/span>} 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{&lt;span style="color:#75715e">/*layouts\_default\single.html*/&lt;/span>}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{ &lt;span style="color:#a6e22e">define&lt;/span> &lt;span style="color:#e6db74">&amp;#34;main&amp;#34;&lt;/span> }}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">This&lt;/span> &lt;span style="color:#a6e22e">is&lt;/span> &lt;span style="color:#a6e22e">the&lt;/span> &lt;span style="color:#a6e22e">single&lt;/span> &lt;span style="color:#a6e22e">template&lt;/span>&amp;lt;&lt;span style="color:#a6e22e">br&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{&lt;span style="color:#75715e">/* 常见变量 */&lt;/span>}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>: {{ .&lt;span style="color:#a6e22e">Params&lt;/span>.&lt;span style="color:#a6e22e">title&lt;/span> }}&amp;lt;&lt;span style="color:#a6e22e">br&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span>: {{ .&lt;span style="color:#a6e22e">Title&lt;/span> }}&amp;lt;&lt;span style="color:#a6e22e">br&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">date&lt;/span>: {{ .&lt;span style="color:#a6e22e">Date&lt;/span> }}&amp;lt;&lt;span style="color:#a6e22e">br&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">url&lt;/span>: {{ .&lt;span style="color:#a6e22e">URL&lt;/span> }}&amp;lt;&lt;span style="color:#a6e22e">br&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">myvar&lt;/span>: {{ .&lt;span style="color:#a6e22e">Params&lt;/span>.&lt;span style="color:#a6e22e">myVar&lt;/span> }}&amp;lt;&lt;span style="color:#a6e22e">br&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{&lt;span style="color:#75715e">/* 定义变量 */&lt;/span>}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{ &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#a6e22e">myVarname&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;aString&amp;#34;&lt;/span> }}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">myVarname&lt;/span>:{{ &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#a6e22e">myVarname&lt;/span> }}&amp;lt;&lt;span style="color:#a6e22e">br&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="color:#a6e22e">h1&lt;/span> &lt;span style="color:#a6e22e">style&lt;/span>=&lt;span style="color:#e6db74">&amp;#34;color: {{ .Params.color }} ;&amp;#34;&lt;/span> &amp;gt;&lt;span style="color:#a6e22e">Single&lt;/span> &lt;span style="color:#a6e22e">Template&lt;/span>&amp;lt;&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">h1&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{ &lt;span style="color:#a6e22e">end&lt;/span> }} 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#a6e22e">endraw&lt;/span> &lt;span style="color:#f92672">%&lt;/span>} 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>{% raw %} 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title: &amp;#34;E-title&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date: 2024-12-07T12:43:21+08:00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>draft: true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>myVar: &amp;#34;myvalue&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>color: &amp;#34;red&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>This is dir3/e.md 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{% endraw %} 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="img/ly-20241212142130338.png" alt="" />&lt;/p></description></item><item><title>hugo进阶学习11-15</title><link>https://lwmfjc.github.io/zh/docs/technology/Hugo/GiraffeAcademy/advanced11-16/</link><pubDate>Sun, 08 Dec 2024 11:23:42 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Hugo/GiraffeAcademy/advanced11-16/</guid><description>&lt;blockquote>
&lt;p>这里使用的版本是&lt;strong>v0.26&lt;/strong>（很久之前的版本）&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="img/ly-20241212142128138.png" alt="" />&lt;/p>
&lt;h1 id="template-basic">
 template basic
 &lt;a class="anchor" href="#template-basic">#&lt;/a>
&lt;/h1>
&lt;p>模板分为list template和single template&lt;/p>
&lt;h2 id="文件夹结构">
 文件夹结构
 &lt;a class="anchor" href="#%e6%96%87%e4%bb%b6%e5%a4%b9%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>content目录结构&lt;br>
&lt;img src="img/ly-20241212142128249.png" alt="" />&lt;/p>
&lt;h2 id="list-template-列表模板">
 list template （列表模板）
 &lt;a class="anchor" href="#list-template-%e5%88%97%e8%a1%a8%e6%a8%a1%e6%9d%bf">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142128336.png" alt="" />&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142128415.png" alt="" />&lt;/p>
&lt;h2 id="single-template-单页模板">
 single template （单页模板）
 &lt;a class="anchor" href="#single-template-%e5%8d%95%e9%a1%b5%e6%a8%a1%e6%9d%bf">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142128493.png" alt="" />&lt;/p>
&lt;h2 id="特点">
 特点
 &lt;a class="anchor" href="#%e7%89%b9%e7%82%b9">#&lt;/a>
&lt;/h2>
&lt;p>所有的&lt;strong>列表之间&lt;/strong>都是长一样的（页眉，页脚，及内容（都是列表））&lt;br>
所有的&lt;strong>单页之间&lt;/strong>都是长一样的（一样的页眉页脚，一样的内容布局）&lt;/p>
&lt;h2 id="部分代码解释">
 部分代码解释
 &lt;a class="anchor" href="#%e9%83%a8%e5%88%86%e4%bb%a3%e7%a0%81%e8%a7%a3%e9%87%8a">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142128574.png" alt="" />&lt;/p>
&lt;h3 id="单页探索">
 单页探索
 &lt;a class="anchor" href="#%e5%8d%95%e9%a1%b5%e6%8e%a2%e7%b4%a2">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="img/ly-20241212142128655.png" alt="" />&lt;br>
&lt;img src="img/ly-20241212142128733.png" alt="" />&lt;/p>
&lt;h1 id="list-page-templates">
 list page templates
 &lt;a class="anchor" href="#list-page-templates">#&lt;/a>
&lt;/h1>
&lt;h2 id="文件夹结构-1">
 文件夹结构
 &lt;a class="anchor" href="#%e6%96%87%e4%bb%b6%e5%a4%b9%e7%bb%93%e6%9e%84-1">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142128811.png" alt="" />&lt;/p>
&lt;h2 id="文件内容">
 文件内容
 &lt;a class="anchor" href="#%e6%96%87%e4%bb%b6%e5%86%85%e5%ae%b9">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#content/_index&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">---&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;_Index&amp;#34;&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">---&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">This&lt;/span> &lt;span style="color:#a6e22e">is&lt;/span> &lt;span style="color:#a6e22e">the&lt;/span> &lt;span style="color:#a6e22e">home&lt;/span> &lt;span style="color:#a6e22e">page&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#content/dir1/_index&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">---&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">title&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;_Index&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">---&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">This&lt;/span> &lt;span style="color:#a6e22e">is&lt;/span> &lt;span style="color:#a6e22e">the&lt;/span> &lt;span style="color:#a6e22e">landing&lt;/span> &lt;span style="color:#a6e22e">page&lt;/span> &lt;span style="color:#a6e22e">for&lt;/span> &lt;span style="color:#a6e22e">dir1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="当前效果">
 当前效果
 &lt;a class="anchor" href="#%e5%bd%93%e5%89%8d%e6%95%88%e6%9e%9c">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142128890.png" alt="" />&lt;/p></description></item><item><title>hugo进阶学习01-10</title><link>https://lwmfjc.github.io/zh/docs/technology/Hugo/GiraffeAcademy/advanced01-10/</link><pubDate>Sat, 07 Dec 2024 21:17:37 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Hugo/GiraffeAcademy/advanced01-10/</guid><description>&lt;blockquote>
&lt;p>系列视频地址介绍&lt;br>
&lt;a href="https://www.youtube.com/watch?v=qtIqKaDlqXo&amp;amp;list=PLLAZ4kZ9dFpOnyRlyS-liKL5ReHDcj4G3">https://www.youtube.com/watch?v=qtIqKaDlqXo&amp;list=PLLAZ4kZ9dFpOnyRlyS-liKL5ReHDcj4G3&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="img/ly-20241212142126407.png" alt="" />&lt;/p>
&lt;h1 id="介绍">
 介绍
 &lt;a class="anchor" href="#%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>hugo是用来构建静态网站的&lt;/li>
&lt;li>但是也可以稍微做点动态生成的事&lt;/li>
&lt;li>这里使用的版本是&lt;strong>v0.26&lt;/strong>（很久之前的版本）&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>备注：标题&lt;strong>短代码&lt;/strong>之前（不包括短代码这篇）的笔记是回溯的，所以没有复制源代码下来，直接在视频再次截图的&lt;/p>
&lt;/blockquote>
&lt;h1 id="在windows上安装hugo">
 在Windows上安装hugo
 &lt;a class="anchor" href="#%e5%9c%a8windows%e4%b8%8a%e5%ae%89%e8%a3%85hugo">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>到github release下载，然后放到某个文件夹中&lt;br>
&lt;img src="img/ly-20241212142126606.png" alt="" />&lt;/li>
&lt;li>设置环境变量&lt;br>
&lt;img src="img/ly-20241212142126695.png" alt="" />&lt;/li>
&lt;li>验证环境变量&lt;br>
&lt;img src="img/ly-20241212142126780.png" alt="" />&lt;/li>
&lt;li>最后验证hugo版本&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>hugo version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="创建一个新的网站">
 创建一个新的网站
 &lt;a class="anchor" href="#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e6%96%b0%e7%9a%84%e7%bd%91%e7%ab%99">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>使用代码生成&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>hugo new site
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>文件夹结构&lt;br>
&lt;img src="img/ly-20241212142126859.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h1 id="使用主题">
 使用主题
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8%e4%b8%bb%e9%a2%98">#&lt;/a>
&lt;/h1>
&lt;p>这里是https://themes.gohugo.io&lt;br>
&lt;img src="img/ly-20241212142126939.png" alt="" /> 这里使用的是ga-hugo-theme（github中查找），并放到themes文件夹中&lt;br>
&lt;img src="img/ly-20241212142127018.png" alt="" />&lt;br>
之后在config.toml中使用主题&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">baseURL&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;http://example.org/&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">languageCode&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;en-us&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">title&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;My New Hugo Site&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">theme&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;ga-hugo-theme&amp;#34;&lt;/span> &lt;span style="color:#75715e">#添加这句话&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>启动博客&lt;br>
&lt;code>hugo serve&lt;/code>&lt;/li>
&lt;li>地址&lt;br>
&lt;code>localhost:1313&lt;/code>&lt;/li>
&lt;/ul>
&lt;h1 id="创建md文件">
 创建md文件
 &lt;a class="anchor" href="#%e5%88%9b%e5%bb%bamd%e6%96%87%e4%bb%b6">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>使用&lt;code>hugo new a.md&lt;/code>把文件创建在content/a.md或者&lt;code>hugo new dir2/d.md&lt;/code>把文件创建在&lt;code>content/dir2.md&lt;/code>下，这讲创建后的结构目录为&lt;br>
&lt;img src="img/ly-20241212142127095.png" alt="" />
&lt;ul>
&lt;li>总共5个文件，可以使用localhost:1313访问博客（默认列举所有（包括子文件夹）文件&lt;/li>
&lt;li>可以使用 localhost:1313/dir3访问dir3下所有文件列表(list)，localhost:1313/dir1访问dir1下所有文件列表 （都是content的直接子文件夹）&lt;/li>
&lt;li>如果没有dir1/dir2/_index.md这个文件 ，则不能直接使用localhost:1313/dir1/dir2访问dir1/dir2下所有文件&lt;/li>
&lt;li>查看dir1/dir2/index.md文件及效果&lt;br>
&lt;img src="img/ly-20241212142127255.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="frontmatter-前言">
 frontmatter (前言)
 &lt;a class="anchor" href="#frontmatter-%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>可以使用YAML，TOML，或者JSON&lt;/li>
&lt;li>md编码及效果&lt;br>
&lt;img src="img/ly-20241212142127336.png" alt="" />&lt;br>
&lt;img src="img/ly-20241212142127415.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h1 id="archetypes原型">
 archetypes（原型）
 &lt;a class="anchor" href="#archetypes%e5%8e%9f%e5%9e%8b">#&lt;/a>
&lt;/h1>
&lt;h2 id="默认的原型文件">
 默认的原型文件
 &lt;a class="anchor" href="#%e9%bb%98%e8%ae%a4%e7%9a%84%e5%8e%9f%e5%9e%8b%e6%96%87%e4%bb%b6">#&lt;/a>
&lt;/h2>
&lt;p>archetypes/default.md&lt;/p></description></item><item><title>border-theme背景图片问题</title><link>https://lwmfjc.github.io/zh/docs/technology/Obsidian/border-theme/</link><pubDate>Wed, 04 Dec 2024 09:10:11 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Obsidian/border-theme/</guid><description>&lt;h1 id="svg格式作为背景图片简单图片可行">
 svg格式作为背景图片（简单图片可行）
 &lt;a class="anchor" href="#svg%e6%a0%bc%e5%bc%8f%e4%bd%9c%e4%b8%ba%e8%83%8c%e6%99%af%e5%9b%be%e7%89%87%e7%ae%80%e5%8d%95%e5%9b%be%e7%89%87%e5%8f%af%e8%a1%8c">#&lt;/a>
&lt;/h1>
&lt;p>以下面这张图片为例&lt;br>
&lt;img src="img/ly-20241212142158272.svg" alt="" />
最简单的方式，用记事本/文本编辑器，打开svg图片，全选，复制，即&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;svg&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2000/svg&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">viewBox=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;0 0 1920 1080&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;g&lt;/span> &lt;span style="color:#a6e22e">transform=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> rotate(0 960 540) 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> translate(-0 -0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> scale(1)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;rect&lt;/span> &lt;span style="color:#a6e22e">width=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;1920&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">height=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;1080&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">fill=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;rgb(184, 171, 255)&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/rect&amp;gt;&amp;lt;g&lt;/span> &lt;span style="color:#a6e22e">transform=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;translate(0, 0)&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;path&lt;/span> &lt;span style="color:#a6e22e">fill=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;rgb(131, 114, 218)&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">fill-opacity=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">d=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;M0,352.943L45.714,350.075C91.429,347.207,182.857,341.471,274.286,340.581C365.714,339.692,457.143,343.65,548.571,344.095C640,344.54,731.429,341.472,822.857,303.183C914.286,264.894,1005.714,191.383,1097.143,185.175C1188.571,178.967,1280,240.06,1371.429,221.336C1462.857,202.612,1554.286,104.069,1645.714,98.48C1737.143,92.892,1828.571,180.258,1874.286,223.941L1920,267.624L1920,1080L1874.286,1080C1828.571,1080,1737.143,1080,1645.714,1080C1554.286,1080,1462.857,1080,1371.429,1080C1280,1080,1188.571,1080,1097.143,1080C1005.714,1080,914.286,1080,822.857,1080C731.429,1080,640,1080,548.571,1080C457.143,1080,365.714,1080,274.286,1080C182.857,1080,91.429,1080,45.714,1080L0,1080Z&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/path&amp;gt;&amp;lt;/g&amp;gt;&amp;lt;g&lt;/span> &lt;span style="color:#a6e22e">transform=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;translate(0, 360)&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;path&lt;/span> &lt;span style="color:#a6e22e">fill=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;rgb(79, 57, 180)&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">fill-opacity=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">d=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;M0,136.093L45.714,117.434C91.429,98.774,182.857,61.455,274.286,80.719C365.714,99.983,457.143,175.829,548.571,189.505C640,203.181,731.429,154.687,822.857,130.414C914.286,106.141,1005.714,106.09,1097.143,141.274C1188.571,176.458,1280,246.877,1371.429,284.697C1462.857,322.517,1554.286,327.739,1645.714,284.675C1737.143,241.611,1828.571,150.263,1874.286,104.589L1920,58.914L1920,720L1874.286,720C1828.571,720,1737.143,720,1645.714,720C1554.286,720,1462.857,720,1371.429,720C1280,720,1188.571,720,1097.143,720C1005.714,720,914.286,720,822.857,720C731.429,720,640,720,548.571,720C457.143,720,365.714,720,274.286,720C182.857,720,91.429,720,45.714,720L0,720Z&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/path&amp;gt;&amp;lt;/g&amp;gt;&amp;lt;g&lt;/span> &lt;span style="color:#a6e22e">transform=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;translate(0, 720)&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;path&lt;/span> &lt;span style="color:#a6e22e">fill=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;rgb(26, 0, 143)&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">fill-opacity=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">d=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;M0,107.121L45.714,134.307C91.429,161.493,182.857,215.866,274.286,254.33C365.714,292.794,457.143,315.35,548.571,300.514C640,285.679,731.429,233.452,822.857,180.313C914.286,127.174,1005.714,73.123,1097.143,43.365C1188.571,13.606,1280,8.141,1371.429,41.079C1462.857,74.017,1554.286,145.358,1645.714,167.782C1737.143,190.206,1828.571,163.713,1874.286,150.467L1920,137.221L1920,360L1874.286,360C1828.571,360,1737.143,360,1645.714,360C1554.286,360,1462.857,360,1371.429,360C1280,360,1188.571,360,1097.143,360C1005.714,360,914.286,360,822.857,360C731.429,360,640,360,548.571,360C457.143,360,365.714,360,274.286,360C182.857,360,91.429,360,45.714,360L0,360Z&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/path&amp;gt;&amp;lt;/g&amp;gt;&amp;lt;/g&amp;gt;&amp;lt;/svg&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后打开https://codepen.io/yoksel/details/MWKeKK 网站，在 Insert your SVG中粘贴，得到&lt;br>
&lt;img src="img/ly-20241212142158431.png" alt="" />&lt;br>
最后把url(&amp;quot;&amp;quot;) 这块复制【没有分号】，即&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">url&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;data:image/svg+xml,%3Csvg xmlns=&amp;#34;http://www.w3.org/2000/svg&amp;#34; viewBox=&amp;#34;0 0 1920 1080&amp;#34;%3E%3Cg transform=&amp;#34; rotate(0 960 540) translate(-0 -0) scale(1) &amp;#34;%3E%3Crect width=&amp;#34;1920&amp;#34; height=&amp;#34;1080&amp;#34; fill=&amp;#34;rgb(184, 171, 255)&amp;#34;%3E%3C/rect%3E%3Cg transform=&amp;#34;translate(0, 0)&amp;#34;%3E%3Cpath fill=&amp;#34;rgb(131, 114, 218)&amp;#34; fill-opacity=&amp;#34;1&amp;#34; d=&amp;#34;M0,352.943L45.714,350.075C91.429,347.207,182.857,341.471,274.286,340.581C365.714,339.692,457.143,343.65,548.571,344.095C640,344.54,731.429,341.472,822.857,303.183C914.286,264.894,1005.714,191.383,1097.143,185.175C1188.571,178.967,1280,240.06,1371.429,221.336C1462.857,202.612,1554.286,104.069,1645.714,98.48C1737.143,92.892,1828.571,180.258,1874.286,223.941L1920,267.624L1920,1080L1874.286,1080C1828.571,1080,1737.143,1080,1645.714,1080C1554.286,1080,1462.857,1080,1371.429,1080C1280,1080,1188.571,1080,1097.143,1080C1005.714,1080,914.286,1080,822.857,1080C731.429,1080,640,1080,548.571,1080C457.143,1080,365.714,1080,274.286,1080C182.857,1080,91.429,1080,45.714,1080L0,1080Z&amp;#34;%3E%3C/path%3E%3C/g%3E%3Cg transform=&amp;#34;translate(0, 360)&amp;#34;%3E%3Cpath fill=&amp;#34;rgb(79, 57, 180)&amp;#34; fill-opacity=&amp;#34;1&amp;#34; d=&amp;#34;M0,136.093L45.714,117.434C91.429,98.774,182.857,61.455,274.286,80.719C365.714,99.983,457.143,175.829,548.571,189.505C640,203.181,731.429,154.687,822.857,130.414C914.286,106.141,1005.714,106.09,1097.143,141.274C1188.571,176.458,1280,246.877,1371.429,284.697C1462.857,322.517,1554.286,327.739,1645.714,284.675C1737.143,241.611,1828.571,150.263,1874.286,104.589L1920,58.914L1920,720L1874.286,720C1828.571,720,1737.143,720,1645.714,720C1554.286,720,1462.857,720,1371.429,720C1280,720,1188.571,720,1097.143,720C1005.714,720,914.286,720,822.857,720C731.429,720,640,720,548.571,720C457.143,720,365.714,720,274.286,720C182.857,720,91.429,720,45.714,720L0,720Z&amp;#34;%3E%3C/path%3E%3C/g%3E%3Cg transform=&amp;#34;translate(0, 720)&amp;#34;%3E%3Cpath fill=&amp;#34;rgb(26, 0, 143)&amp;#34; fill-opacity=&amp;#34;1&amp;#34; d=&amp;#34;M0,107.121L45.714,134.307C91.429,161.493,182.857,215.866,274.286,254.33C365.714,292.794,457.143,315.35,548.571,300.514C640,285.679,731.429,233.452,822.857,180.313C914.286,127.174,1005.714,73.123,1097.143,43.365C1188.571,13.606,1280,8.141,1371.429,41.079C1462.857,74.017,1554.286,145.358,1645.714,167.782C1737.143,190.206,1828.571,163.713,1874.286,150.467L1920,137.221L1920,360L1874.286,360C1828.571,360,1737.143,360,1645.714,360C1554.286,360,1462.857,360,1371.429,360C1280,360,1188.571,360,1097.143,360C1005.714,360,914.286,360,822.857,360C731.429,360,640,360,548.571,360C457.143,360,365.714,360,274.286,360C182.857,360,91.429,360,45.714,360L0,360Z&amp;#34;%3E%3C/path%3E%3C/g%3E%3C/g%3E%3C/svg%3E&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>加上&lt;/p></description></item><item><title>obsidian-theme</title><link>https://lwmfjc.github.io/zh/docs/technology/Obsidian/obsidian-theme/</link><pubDate>Tue, 03 Dec 2024 15:32:01 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Obsidian/obsidian-theme/</guid><description>&lt;h1 id="主题推荐">
 主题推荐
 &lt;a class="anchor" href="#%e4%b8%bb%e9%a2%98%e6%8e%a8%e8%8d%90">#&lt;/a>
&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>Neumorphism-dark.json&lt;br>
&lt;img src="img/ly-20241212142158673.jpg" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Sunset-base64.json ✔
&lt;img src="img/ly-20241212142158832.jpg" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Obsidian-default-dark-alt ✔
&lt;img src="img/ly-20241212142158865.jpg" alt="" />&lt;br>
4. Obsidian-default-light-alt
&lt;img src="img/ly-20241212142158906.jpg" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Neumorphism.json
&lt;img src="img/ly-20241212142158942.jpg" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>eyefriendly ✔
&lt;img src="img/ly-20241212142158977.jpg" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>boundy ✔
&lt;img src="img/ly-20241212142159017.jpg" alt="" />
flexoki-light
&lt;img src="img/ly-20241212142159055.jpg" alt="" />Borderless-light
&lt;img src="img/ly-20241212142159093.jpg" alt="" />&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="关于obsidian主题border的背景图片设置">
 关于obsidian主题border的背景图片设置
 &lt;a class="anchor" href="#%e5%85%b3%e4%ba%8eobsidian%e4%b8%bb%e9%a2%98border%e7%9a%84%e8%83%8c%e6%99%af%e5%9b%be%e7%89%87%e8%ae%be%e7%bd%ae">#&lt;/a>
&lt;/h1>
&lt;p>配合StyleSettings，在StyleSettings的这里设置&lt;br>
&lt;img src="img/ly-20241212142159126.jpg" alt="" />&lt;/p>
&lt;h2 id="暂不明确">
 暂不明确
 &lt;a class="anchor" href="#%e6%9a%82%e4%b8%8d%e6%98%8e%e7%a1%ae">#&lt;/a>
&lt;/h2>
&lt;p>background中貌似存在转换规则，不是直接用url(&amp;quot;&amp;quot;)这个形式把图片base64放进来就可以了，目前觉得可能的转换规则&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>%3c 48+12&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">60&lt;/span> &amp;lt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>%3e 48+14&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">62&lt;/span> &amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>%23 32+3&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">35&lt;/span> &lt;span style="color:#75715e"># &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#下面的好像没用到，也不确定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>%2b 32+11&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">43&lt;/span> + 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>%3b ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>%2c ,
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>后续见另一篇文章&lt;br>
&lt;a href="_posts/study/obsidian/border-theme.md">border-theme&lt;/a>
{% post_link &amp;lsquo;study/obsidian/border-theme&amp;rsquo; &amp;lsquo;helo&amp;rsquo; %}&lt;/p></description></item><item><title>plugin</title><link>https://lwmfjc.github.io/zh/docs/technology/Obsidian/plugin/</link><pubDate>Tue, 03 Dec 2024 15:32:01 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Obsidian/plugin/</guid><description>&lt;p>&lt;a href="https://github.com/RainCat1998/obsidian-custom-attachment-location">obsidian-custom-attachment-location&lt;/a> v.28.1文件批量重命名有效，再往上都是无效的&lt;/p></description></item><item><title>rsync使用</title><link>https://lwmfjc.github.io/zh/docs/technology/Redis/rsync-use/</link><pubDate>Sun, 01 Dec 2024 19:07:54 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Redis/rsync-use/</guid><description>&lt;p>其实就是linux的cp功能（带增量复制）
#推送到rsync-k40
rsync -avz &amp;ndash;progress &amp;ndash;delete source-rsync -e &amp;lsquo;ssh -p 8022&amp;rsquo; &lt;a href="mailto:ly@192.168.1.101">ly@192.168.1.101&lt;/a>:/storage/emulated/0/000Ly/git/blog.source/source/attachments/rsync-k40
#推送到rsync-tabs8
rsync -avz &amp;ndash;progress &amp;ndash;delete source-rsync -e &amp;lsquo;ssh -p 8022&amp;rsquo; &lt;a href="mailto:ly@192.168.1.106">ly@192.168.1.106&lt;/a>:/storage/emulated/0/000Ly/git/blog.source/source/attachments/rsync-tabs8
#推送到rsync-pc
rsync -avz &amp;ndash;progress &amp;ndash;delete source-rsync -e &amp;lsquo;ssh -p 22&amp;rsquo; &lt;a href="mailto:ly@192.168.1.206">ly@192.168.1.206&lt;/a>:/mnt/hgfs/gitRepo/blog.source/source/attachments/rsync-pc&lt;/p>
&lt;p>#从手机上拉取
rsync -avz &amp;ndash;progress &amp;ndash;delete -e &amp;lsquo;ssh -p 8022&amp;rsquo; &lt;a href="mailto:ly@192.168.1.101">ly@192.168.1.101&lt;/a>:/storage/emulated/0/000Ly/git/blog.source/source/attachments/rsync-k40 source-rsync&lt;/p></description></item><item><title>知命不惧 日日自新</title><link>https://lwmfjc.github.io/zh/docs/life/20240626/</link><pubDate>Wed, 26 Jun 2024 15:17:25 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/life/20240626/</guid><description>&lt;p>视频分享&lt;br>
&lt;iframe style="height: 60vh;width: 100%;" src="//player.bilibili.com/player.html?isOutside=true&amp;amp;aid=766834265&amp;amp;bvid=BV1Gr4y1z7fs&amp;amp;cid=515298713&amp;amp;p=1" scrolling="no" border="0"
 frameborder="no" framespacing="0" allowfullscreen="true">&lt;/iframe>&lt;/p></description></item><item><title>如何搜索</title><link>https://lwmfjc.github.io/zh/docs/problem/Other/01/</link><pubDate>Fri, 26 Apr 2024 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/Other/01/</guid><description>&lt;h1 id="原则">
 原则
 &lt;a class="anchor" href="#%e5%8e%9f%e5%88%99">#&lt;/a>
&lt;/h1>
&lt;ol>
&lt;li>搜索的时候，要&lt;strong>简约&lt;/strong>，且尽量把&lt;strong>关键词分散&lt;/strong>，不要有&amp;quot;的&amp;quot;，&amp;ldquo;地&amp;rdquo;，或者其他动词什么的，尽量是&lt;strong>名词&lt;/strong>。&lt;/li>
&lt;li>关键词之间用&lt;strong>空格隔开&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>比如想要看一部电影，那么关键词有&amp;quot;电影名&amp;quot;，&amp;ldquo;bt&amp;rdquo;，&amp;ldquo;迅雷&amp;rdquo;，&amp;ldquo;阿里云盘&amp;rdquo;，&amp;ldquo;百度网盘&amp;rdquo;&lt;/p>
&lt;blockquote>
&lt;p>解释一下，这里来源（迅雷|阿里云盘|百度网盘），资源类型（bt）也是关键词&lt;/p>
&lt;/blockquote>
&lt;p>所以搜索就是**&amp;ldquo;孤注一掷 bt&amp;rdquo;，&amp;ldquo;孤注一掷 阿里云盘&amp;rdquo;，&amp;ldquo;孤注一掷 百度网盘&amp;rdquo;，&amp;ldquo;孤注一掷 迅雷&amp;rdquo;，注意，中间都有空格**&lt;/p>
&lt;h1 id="例子">
 例子
 &lt;a class="anchor" href="#%e4%be%8b%e5%ad%90">#&lt;/a>
&lt;/h1>
&lt;h2 id="bt种子形式">
 bt种子形式
 &lt;a class="anchor" href="#bt%e7%a7%8d%e5%ad%90%e5%bd%a2%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212141836193.png" alt="image-20240226132336128" />&lt;br>
点进来之后，滑到最下面（一般链接都是以浅蓝色标识，点过一次后就变成暗红色）&lt;br>
&lt;img src="img/ly-20241212141836507.png" alt="image-20240226132614759" />&lt;/p>
&lt;p>bt文件一般要用&amp;quot;迅雷&amp;quot;这个软件下载，上面随便点击一个，迅雷这个软件就会跳出来&lt;br>
&lt;img src="img/ly-20241212141836693.png" alt="image-20240226132743460" />&lt;br>
然后选择好目录点击确认就可以下载了&lt;/p>
&lt;h2 id="阿里云盘形式">
 阿里云盘形式
 &lt;a class="anchor" href="#%e9%98%bf%e9%87%8c%e4%ba%91%e7%9b%98%e5%bd%a2%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212141836869.png" alt="image-20240226133054195" />&lt;/p>
&lt;p>第一个链接有人提出质疑了，我们点下面那个，这是进入之后的画面：&lt;br>
&lt;img src="img/ly-20241212141837046.png" alt="image-20240226133201891" />&lt;br>
再点击&amp;quot;阿里xxxxxxxxxx&amp;quot;这个链接，进入阿里云盘：&lt;br>
&lt;img src="img/ly-20241212141837227.png" alt="image-20240226133251855" />&lt;/p>
&lt;p>点进来看视频文件还在不在，在的话，保存就可以了&lt;br>
&lt;img src="img/ly-20241212141837403.png" alt="image-20240226133340936" />&lt;br>
之后到自己的阿里云盘下载就行了&lt;/p>
&lt;h2 id="百度云盘形式">
 百度云盘形式
 &lt;a class="anchor" href="#%e7%99%be%e5%ba%a6%e4%ba%91%e7%9b%98%e5%bd%a2%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>百度云盘被限速了，不得已的情况下，不要用百度云盘，基本上前面两种形式的资源没找到的话，百度云盘大概率也不会有&lt;/p></description></item><item><title>起床临感</title><link>https://lwmfjc.github.io/zh/docs/life/20231227/</link><pubDate>Wed, 27 Dec 2023 09:33:42 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/life/20231227/</guid><description>&lt;p>所谓贵人，并不是封建迷信，而是指对你成长有帮助的人，不单单是直观的好。&lt;br>
在你蒸蒸日上的时候打压你，让你有所收敛；在你颓废堕落的时候鼓励你，使你积极向上。他们都是贵人，一阴一阳之谓道，如是而已。&lt;/p></description></item><item><title>20231101</title><link>https://lwmfjc.github.io/zh/docs/life/20231101/</link><pubDate>Wed, 01 Nov 2023 11:26:17 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/life/20231101/</guid><description>&lt;iframe style="height: 60vh;width: 100%;" src="//player.bilibili.com/player.html?aid=842039534&amp;amp;bvid=BV1m54y1C7SV&amp;amp;cid=233766005&amp;amp;p=1" scrolling="no" border="0"
 frameborder="no" framespacing="0" allowfullscreen="true">&lt;/iframe>
&lt;blockquote>
&lt;p>附(20231102)&lt;/p>
&lt;ol>
&lt;li>融入我中华文化的，才是自己人。想消灭我中华文化的，即使&lt;strong>占有了这片土地&lt;/strong>，也不能称之“功臣”。&lt;br>
当一个民族的文化被摧毁的时候，那个民族就是彻底灭亡了。&lt;/li>
&lt;li>不过，我觉得，只要是在&lt;strong>中国这片土地&lt;/strong>上(地理)，无论谁来，都会产生这样的文化，无例外。(&lt;strong>地理决定论&lt;/strong>)&lt;/li>
&lt;/ol>
&lt;/blockquote></description></item><item><title>成就</title><link>https://lwmfjc.github.io/zh/docs/life/archive/20231026/</link><pubDate>Thu, 26 Oct 2023 01:45:47 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/life/archive/20231026/</guid><description>&lt;ul>
&lt;li>任何事情的成功，都没有什么可骄傲的，不过是一物降一物，无他尔。&lt;/li>
&lt;li>人生最大的问题，是不想，而不是不能。&lt;/li>
&lt;/ul></description></item><item><title>沉没</title><link>https://lwmfjc.github.io/zh/docs/life/archive/20231013/</link><pubDate>Fri, 13 Oct 2023 00:24:18 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/life/archive/20231013/</guid><description>&lt;ul>
&lt;li>努力不一定有用，但是&lt;strong>虚度光阴&lt;/strong>难道就是对的吗？&lt;/li>
&lt;li>即使你一时找不到正确的路，但是你应该能一眼看出哪些是&lt;strong>错&lt;/strong>的，及时&lt;strong>避&lt;/strong>开。&lt;/li>
&lt;/ul></description></item><item><title>Linux操作符问题</title><link>https://lwmfjc.github.io/zh/docs/problem/Linux/20230919/</link><pubDate>Tue, 19 Sep 2023 17:59:37 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/Linux/20230919/</guid><description>&lt;h1 id="函数退出">
 函数退出
 &lt;a class="anchor" href="#%e5%87%bd%e6%95%b0%e9%80%80%e5%87%ba">#&lt;/a>
&lt;/h1>
&lt;p>函数退出状态：0（成功），非零（非正常，失败）&lt;/p>
&lt;h1 id="引号">
 引号
 &lt;a class="anchor" href="#%e5%bc%95%e5%8f%b7">#&lt;/a>
&lt;/h1>
&lt;p>双引号中使用转义字符可以防止展开&lt;br>
这意味着单词分割(空格制表换行分割单词)、路径名展开(*星号)、波浪线展开和花括号展开都将失效，然而&lt;strong>参数展开&lt;/strong>、
&lt;strong>算术展开&lt;/strong>和&lt;strong>命令替换&lt;/strong>仍然执行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;text ~/*.txt {a,b} &lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo foo&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74"> &lt;/span>&lt;span style="color:#66d9ef">$((&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#66d9ef">))&lt;/span>&lt;span style="color:#e6db74"> &lt;/span>$USER&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#75715e">#禁止部分&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>text ~/*.txt &lt;span style="color:#f92672">{&lt;/span>a,b&lt;span style="color:#f92672">}&lt;/span> foo &lt;span style="color:#ae81ff">4&lt;/span> me
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#39;text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER&amp;#39;&lt;/span> &lt;span style="color:#75715e">#全部禁止&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>text ~/*.txt &lt;span style="color:#f92672">{&lt;/span>a,b&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>echo foo&lt;span style="color:#66d9ef">)&lt;/span> &lt;span style="color:#66d9ef">$((&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#66d9ef">))&lt;/span> $USER
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="各种操作符">
 各种操作符
 &lt;a class="anchor" href="#%e5%90%84%e7%a7%8d%e6%93%8d%e4%bd%9c%e7%ac%a6">#&lt;/a>
&lt;/h1>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>[ expression ] / test&lt;/th>
 &lt;th>[[ expression ]]&lt;/th>
 &lt;th>$(( expression ))&lt;/th>
 &lt;th>$var&lt;/th>
 &lt;th>$( termi )&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>文件表达式 -e file，字符串表达式 -n string，整数表达式 integer1 -eq integer2&lt;/td>
 &lt;td>test增强，增加 [ str =~ regex ]，增加 ==&lt;br > [[ $FILE == foo.* ]]&lt;/td>
 &lt;td>整数加减乘除取余&lt;/td>
 &lt;td>取变量&lt;/td>
 &lt;td>执行命令/函数&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>termi取变量$必加，里面被看作命令参数，&amp;lt; &amp;gt; ( ) 必须转义 否则 小于号 &amp;lt; 大于号&amp;gt;被认为重定向&lt;/td>
 &lt;td>与[ ] 一致&lt;/td>
 &lt;td>取变量$可加可不加&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>termi取变量$必加&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;img src="img/ly-20241212141835875.png" alt="image-20230920195057911" />&lt;/p></description></item><item><title>鲇鱼后思</title><link>https://lwmfjc.github.io/zh/docs/life/archive/20230913/</link><pubDate>Wed, 13 Sep 2023 21:13:04 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/life/archive/20230913/</guid><description>&lt;ul>
&lt;li>鲇鱼事件其实出来很久了，一直没有太大关注，这几天突发兴致（某乎评论提到），就去了解了下。可能我对“官”这种东西，从小到大就定了性，所以如果查出个大清官，省吃俭用破衣烂衫，倒可算得上新闻。&lt;/li>
&lt;li>对于其言论，确实听了未尝不免义愤填膺。于是我就花了大半个小时义愤填膺&amp;hellip;&lt;/li>
&lt;li>一代人只能做一代人的事&amp;mdash;《走向共和》，官如此，民亦如此。如果作为普通老百姓，不能够跻身仕途，那就是先老老实实做好自己的本分&amp;ndash;照顾父母，照顾自己，照顾妻子，照顾儿女。总有人会替天行道，如果不是你，那就做好自己，教育好自己的子女，足以。不要三心二意，事物发展有其必然规律，有盛必有衰，自古皆如此。穷则独善其身，达则兼济天下。&lt;/li>
&lt;li>没有必要把自己带入高高在上的角色。也许自己到了那个地位，贪得更凶。真小人好过伪君子，伪君子往往会迷失自己，既做不了君子，又成不了小人。&lt;/li>
&lt;/ul></description></item><item><title>病愈 有感</title><link>https://lwmfjc.github.io/zh/docs/life/archive/20230912/</link><pubDate>Tue, 12 Sep 2023 20:11:46 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/life/archive/20230912/</guid><description>&lt;ul>
&lt;li>一个人只有&lt;strong>真正意识&lt;/strong>到事情的发展，是自己的错误导致，才会&lt;strong>真正改过自新&lt;/strong>。否则就会&lt;strong>怨天尤人&lt;/strong>，甚至&lt;strong>掩耳盗铃&lt;/strong>。&lt;/li>
&lt;li>世界万事万物，有优有劣。劣并不代表罪恶，不过是事物发展的某个&lt;strong>过程&lt;/strong>，如同生病的头疼脑热，“现象”，不过是提醒世人罢了。切勿以过程盖棺定论，&lt;strong>自暴自弃&lt;/strong>，及时&lt;strong>止损&lt;/strong>即可。&lt;/li>
&lt;/ul></description></item><item><title>Debian问题处理3</title><link>https://lwmfjc.github.io/zh/docs/problem/Linux/20230819/</link><pubDate>Sat, 19 Aug 2023 11:05:17 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/Linux/20230819/</guid><description>&lt;h1 id="fcitx配合各种软件出现的问题">
 fcitx配合各种软件出现的问题
 &lt;a class="anchor" href="#fcitx%e9%85%8d%e5%90%88%e5%90%84%e7%a7%8d%e8%bd%af%e4%bb%b6%e5%87%ba%e7%8e%b0%e7%9a%84%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h1>
&lt;blockquote>
&lt;p>本文章中出现的引号都是英文状态下的引号，切记！&lt;/p>
&lt;/blockquote>
&lt;h2 id="安装完毕后环境变量设置">
 安装完毕后环境变量设置
 &lt;a class="anchor" href="#%e5%ae%89%e8%a3%85%e5%ae%8c%e6%af%95%e5%90%8e%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e8%ae%be%e7%bd%ae">#&lt;/a>
&lt;/h2>
&lt;p>/etc/profile 和/etc/enviroment 均可，profile针对用户，environment针对系统。一般都是放profile里面&lt;/p>
&lt;h3 id="不行的话">
 不行的话
 &lt;a class="anchor" href="#%e4%b8%8d%e8%a1%8c%e7%9a%84%e8%af%9d">#&lt;/a>
&lt;/h3>
&lt;p>如果修改profile无效，则在/etc/enviroment添加修改&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#/etc/enviroment 末尾添加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fcitx &amp;amp; &lt;span style="color:#75715e">#这行要添加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export XIM_PROGRAM&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export XIM&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export GTK_IM_MODULE&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export QT_IM_MODULE&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export XMODIFIERS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;@im=fcitx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LANG&lt;span style="color:#f92672">=&lt;/span>zh_CN.UTF-8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>source后再重启一下哦&lt;/p>
&lt;h2 id="装了zsh后从终端打开idea等各种软件不出现fcitx输入法的问题">
 装了zsh后(从终端打开)idea等各种软件不出现fcitx输入法的问题
 &lt;a class="anchor" href="#%e8%a3%85%e4%ba%86zsh%e5%90%8e%e4%bb%8e%e7%bb%88%e7%ab%af%e6%89%93%e5%bc%80idea%e7%ad%89%e5%90%84%e7%a7%8d%e8%bd%af%e4%bb%b6%e4%b8%8d%e5%87%ba%e7%8e%b0fcitx%e8%be%93%e5%85%a5%e6%b3%95%e7%9a%84%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;p>在&lt;code>/.zshrc&lt;/code>最后添加&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>export XIM_PROGRAM&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export XIM&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export GTK_IM_MODULE&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export QT_IM_MODULE&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export XMODIFIERS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;@im=fcitx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LANG&lt;span style="color:#f92672">=&lt;/span>zh_CN.UTF-8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LC_MESSAGES&lt;span style="color:#f92672">=&lt;/span>en_US.UTF-8 &lt;span style="color:#75715e">#让终端报错时，显示英文 而不是中文&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也可以不在/.zshrc中追加这些，而是直接追加 &lt;code>source /etc/profile&lt;/code>或者&lt;code>/etc/enviroment&lt;/code>即可&lt;/p>
&lt;p>如果还有问题，就要在idea的配置文件&lt;code>idea.vmoptions&lt;/code>添加&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>-Drecreate.x11.input.method&lt;span style="color:#f92672">=&lt;/span>true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="如果使用系统默认终端的情况下出的问题">
 如果使用系统默认终端的情况下出的问题
 &lt;a class="anchor" href="#%e5%a6%82%e6%9e%9c%e4%bd%bf%e7%94%a8%e7%b3%bb%e7%bb%9f%e9%bb%98%e8%ae%a4%e7%bb%88%e7%ab%af%e7%9a%84%e6%83%85%e5%86%b5%e4%b8%8b%e5%87%ba%e7%9a%84%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h3>
&lt;p>可以在 ~/.bashrc最后添加这段话，重启试试&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>export XIM_PROGRAM&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export XIM&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export GTK_IM_MODULE&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export QT_IM_MODULE&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export XMODIFIERS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;@im=fcitx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LANG&lt;span style="color:#f92672">=&lt;/span>zh_CN.UTF-8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="各个文件的解释">
 各个文件的解释
 &lt;a class="anchor" href="#%e5%90%84%e4%b8%aa%e6%96%87%e4%bb%b6%e7%9a%84%e8%a7%a3%e9%87%8a">#&lt;/a>
&lt;/h1>
&lt;p>/etc/profile //用户级，所有用户登陆时才会执行 对于fcitx没效果(firefox无效)&lt;br>
/etc/enviroment //系统级，一般不修改 这里有效果&lt;br>
~/.bashrc //系统默认终端打开时执行
~/.zshrc //zsh使用前执行&lt;/p></description></item><item><title>Debian问题处理2</title><link>https://lwmfjc.github.io/zh/docs/problem/Linux/20230817/</link><pubDate>Thu, 17 Aug 2023 23:49:36 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/Linux/20230817/</guid><description>&lt;h1 id="代理">
 代理
 &lt;a class="anchor" href="#%e4%bb%a3%e7%90%86">#&lt;/a>
&lt;/h1>
&lt;p>Vmware里面的debian,连接外面物理机的v2ray。&lt;/p>
&lt;h2 id="对于浏览器">
 对于浏览器
 &lt;a class="anchor" href="#%e5%af%b9%e4%ba%8e%e6%b5%8f%e8%a7%88%e5%99%a8">#&lt;/a>
&lt;/h2>
&lt;p>无论是firefox还是chromium，都可以直接通过v2ray允许局域网，然后使用ProxySwitchOmege代理访问&lt;/p>
&lt;h2 id="对于命令">
 对于命令
 &lt;a class="anchor" href="#%e5%af%b9%e4%ba%8e%e5%91%bd%e4%bb%a4">#&lt;/a>
&lt;/h2>
&lt;p>可以使用proxychains，直接用apt-get 安装即可，注意事项&lt;/p>
&lt;h3 id="作用范围">
 作用范围
 &lt;a class="anchor" href="#%e4%bd%9c%e7%94%a8%e8%8c%83%e5%9b%b4">#&lt;/a>
&lt;/h3>
&lt;p>对tcp生效，ping是不生效的，不要白费力气&lt;/p>
&lt;h3 id="需要修改两个地方">
 需要修改两个地方
 &lt;a class="anchor" href="#%e9%9c%80%e8%a6%81%e4%bf%ae%e6%94%b9%e4%b8%a4%e4%b8%aa%e5%9c%b0%e6%96%b9">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>libproxychains.so.3 提示不存在 ly&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>whereis libproxychains.so.3 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#libproxychains.so.3: /usr/lib/x86_64-linux-gnu/libproxychains.so.3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#修改/usr/bin/proxychains&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#export LD_PRELOAD = libproxychains.so.3 修改为：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LD_PRELOAD &lt;span style="color:#f92672">=&lt;/span> /usr/lib/x86_64-linux-gnu/libproxychains.so.3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>l&amp;rsquo;y配置修改&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#修改文件/etc/proxychains.conf，在最后一行添加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>socks5 	192.168.1.201 &lt;span style="color:#ae81ff">1082&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>proxychains git pull
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#直接在命令最前面输入proxychains即可&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="直接网络gui配置代理">
 直接网络（gui）配置代理
 &lt;a class="anchor" href="#%e7%9b%b4%e6%8e%a5%e7%bd%91%e7%bb%9cgui%e9%85%8d%e7%bd%ae%e4%bb%a3%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;p>这个对于终端不生效&lt;/p>
&lt;h1 id="zsh安装">
 zsh安装
 &lt;a class="anchor" href="#zsh%e5%ae%89%e8%a3%85">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>proxychains wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>proxychains sh install.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="zsh主题安装">
 zsh主题安装
 &lt;a class="anchor" href="#zsh%e4%b8%bb%e9%a2%98%e5%ae%89%e8%a3%85">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>proxychains git clone --depth&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> https://github.com/romkatv/powerlevel10k.git &lt;span style="color:#e6db74">${&lt;/span>ZSH_CUSTOM&lt;span style="color:#66d9ef">:-&lt;/span>$HOME/.oh-my-zsh/custom&lt;span style="color:#e6db74">}&lt;/span>/themes/powerlevel10k
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#修改&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vim ~/.zshrc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ZSH_THEME&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;powerlevel10k/powerlevel10k&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重新配置 &lt;code>p10k configure&lt;/code>&lt;/p></description></item><item><title>Debian问题处理1</title><link>https://lwmfjc.github.io/zh/docs/problem/Linux/20230815/</link><pubDate>Tue, 15 Aug 2023 09:05:57 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/Linux/20230815/</guid><description>&lt;h1 id="清华源设置">
 清华源设置
 &lt;a class="anchor" href="#%e6%b8%85%e5%8d%8e%e6%ba%90%e8%ae%be%e7%bd%ae">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>vim /etc/apt/sources.list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#注释掉原来的，并添加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non-free non-free-firmware&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-updates main contrib non-free non-free-firmware&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm-backports main contrib non-free non-free-firmware&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bookworm-security main contrib non-free non-free-firmware&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deb https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># deb-src https://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="中文环境">
 中文环境
 &lt;a class="anchor" href="#%e4%b8%ad%e6%96%87%e7%8e%af%e5%a2%83">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>su
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get install locales
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#配置中文环境 1.选择zh开头的 2 后面选择en(cn也行，不影响输入法)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo dpkg-reconfigure locales
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#设置上海时区&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo timedatectl set-timezone Asia/Shanghai
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="中文输入法">
 中文输入法
 &lt;a class="anchor" href="#%e4%b8%ad%e6%96%87%e8%be%93%e5%85%a5%e6%b3%95">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#清除旧的环境&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get remove ibus &lt;span style="color:#75715e">#不兼容问题&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get remove fcitx5 fcitx5-chinese-addons 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get autoremove 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ly &lt;span style="color:#75715e"># gnome-shell-extension-kimpanel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install fcitx5 fcitx5-chinese-addons fcitx5-frontend-gtk4 fcitx5-frontend-gtk3 fcitx5-frontend-gtk2 fcitx5-frontend-qt5 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>im-config &lt;span style="color:#75715e">#配置使用fcitx5 &lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#环境变量添加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export XMODIFIERS&lt;span style="color:#f92672">=&lt;/span>@im&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export GTK_IM_MODULE&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export QT_IM_MODULE&lt;span style="color:#f92672">=&lt;/span>fcitx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#退出root用户权限，使用普通用户权限再终端&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fcitx5-configtool &lt;span style="color:#75715e">#配置中文输入法即可&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#附加组件-经典用户界面--这里可以修改字体及大小&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="其他">
 其他
 &lt;a class="anchor" href="#%e5%85%b6%e4%bb%96">#&lt;/a>
&lt;/h1>
&lt;p>应用程序-优化 修改默认字体大小&lt;/p></description></item><item><title>安卓手机及平板安装linuxDeploy的问题简记</title><link>https://lwmfjc.github.io/zh/docs/problem/Linux/20230803/</link><pubDate>Thu, 03 Aug 2023 12:06:46 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/Linux/20230803/</guid><description>&lt;blockquote>
&lt;p>为什么是简记呢，因为这几天折腾这些太累了，等以后回过头来重新操作再详细记载&lt;/p>
&lt;/blockquote>
&lt;h1 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h1>
&lt;h2 id="初衷">
 初衷
 &lt;a class="anchor" href="#%e5%88%9d%e8%a1%b7">#&lt;/a>
&lt;/h2>
&lt;p>一开始的初衷是为了在平板上使用idea，之前看了一篇docker使用idea的文章，心血来潮。所以想直接在平板的termux安装docker然后使用，结果一堆问题。后面妥协了，在手机上装，然后开远程吧&lt;/p>
&lt;blockquote>
&lt;p>这年头机在人在，所以装手机还是平板，还真没有很大的问题。后面使用情况证明：手机不需要开热点的情况（开热点是为了保证网络联通，在同一局域网），其实不怎么发热也不怎么耗电的。&lt;/p>
&lt;/blockquote>
&lt;h2 id="平板上">
 平板上
 &lt;a class="anchor" href="#%e5%b9%b3%e6%9d%bf%e4%b8%8a">#&lt;/a>
&lt;/h2>
&lt;p>本来想在tab s8平板上通过termux安装linux（无root权限），但是总会遇到一堆问题&amp;ndash;连系统都装不上。因为root会有两个问题，所以一开始没有考虑使用linuxDeploy（需要root）&lt;/p>
&lt;ul>
&lt;li>保修失效&lt;/li>
&lt;li>无法通过系统直接更新（需要线刷）&lt;/li>
&lt;/ul>
&lt;h2 id="手机上root">
 手机上（root）
 &lt;a class="anchor" href="#%e6%89%8b%e6%9c%ba%e4%b8%8aroot">#&lt;/a>
&lt;/h2>
&lt;h3 id="配置">
 配置
 &lt;a class="anchor" href="#%e9%85%8d%e7%bd%ae">#&lt;/a>
&lt;/h3>
&lt;p>后面尝试在root过的手机上安装linuxDeploy，照样有一堆问题，这里配上能使用的配置（能进系统）：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141834176.png" alt="ly-20241212141834176" />&lt;br>
我用的时候ssh端口改了一下，不过不影响，第一次用的22端口也是能连上的。初始用户写的root，这里也是设置的root。&lt;br>
最好挂载一下&lt;br>
&lt;img src="img/ly-20241212141834486.png" alt="ly-20241212141834486" />&lt;/p>
&lt;h3 id="问题">
 问题
 &lt;a class="anchor" href="#%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>用其他桌面环境，可能会导致图标没有（应该是就没有那个应用，比如浏览器），不过我这个配置完也没有浏览器，不过好在图标也没，不用自己再去移除了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>装完之后vns有出错过一次，突然就蹦了，死活连不上。后面我直接重装系统了（linux deploy），没有再出现问题。装完之后需要在&lt;code>etc/rc.local&lt;/code>添加:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#删除vns临时文件，保证每次启动都是使用端口:5901&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#(linux上显示:1，连接使用时要+5900，即使用5901端口)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm -rf /tmp/.X&lt;span style="color:#f92672">[&lt;/span>1-9&lt;span style="color:#f92672">]&lt;/span>-lock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rm -rf /tmp/.X11-unix/X&lt;span style="color:#f92672">[&lt;/span>1-9&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#保证系统每次启动后都自动启动vncserver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vncserver
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>电脑上随便找了个VNCServer 绿色免安装程序可以连上&lt;br>
&lt;img src="img/ly-20241212141834670.png" alt="ly-20241212141834670" />&lt;br>
平板上使用AVNC，电脑不方便截图，就不截了.. 类似长这样&lt;br>
&lt;img src="img/ly-20241212141834882.png" alt="ly-20241212141834882" />&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#常用命令(也不常，这两天用的最多的)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vncserver -kill :1 &lt;span style="color:#75715e">#强制关闭端口1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vncserver &lt;span style="color:#75715e">#启动&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>安装idea，也不用安装，就是去官网下载解压即可。问题：需要jdk11以上才能打开（疑惑，貌似之前在windows安装的时候没这要求，反正后面我妥协了，装了11，之后就是配置环境变量什么的）&lt;br>
一开始linuxDeploy的Ubuntu，然后..发现openjdk11装完之后，&lt;code>java -version&lt;/code>显示的10，一脸蒙圈，搞得后面又重装了Debian（中途还试了centos）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>装完没有中文输入法，系统装完就是要用的，如果随便打打命令倒是不需要中文输入法，但是如果打点代码写点注解，那蹩脚英语就&amp;hellip;总不能句句good good study,day day up..真是one day day de&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="问题处理">
 问题处理
 &lt;a class="anchor" href="#%e9%97%ae%e9%a2%98%e5%a4%84%e7%90%86">#&lt;/a>
&lt;/h1>
&lt;p>其实解决方案前面好像都说了，输入法单独开一块吧，比较恶心，主要是让我意识到了自己水平有多菜&amp;hellip;&lt;/p></description></item><item><title>JDK代理和CGLIB代理</title><link>https://lwmfjc.github.io/zh/docs/problem/JVM/20230526/</link><pubDate>Fri, 26 May 2023 09:29:06 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/JVM/20230526/</guid><description>&lt;blockquote>
&lt;p>完全转载自https://juejin.cn/post/7011357346018361375 ，以防丢失故作备份 。&lt;/p>
&lt;/blockquote>
&lt;h2 id="一什么是代理模式">
 一、什么是代理模式
 &lt;a class="anchor" href="#%e4%b8%80%e4%bb%80%e4%b9%88%e6%98%af%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>代理模式（Proxy Pattern）给某一个对象提供一个代理，并由代理对象控制原对象的引用。代理对象在客户端和目标对象之间起到中介作用。&lt;/p>
&lt;p>代理模式是常用的结构型设计模式之一，当直接访问某些对象存在问题时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。代理模式属于结构型设计模式，属于GOF23种设计模式之一。&lt;/p>
&lt;p>代理模式可以分为静态代理和动态代理两种类型，而动态代理中又分为JDK动态代理和CGLIB代理两种。
&lt;img src="img/ly-20241212141833243.png" alt="" />
&lt;strong>代理模式包含如下角色:&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Subject (抽象主题角色)&lt;/strong> 抽象主题角色声明了真实主题和代理主题的共同接口,这样一来在任何使用真实主题 的地方都可以使用代理主题。客户端需要针对抽象主题角色进行编程。&lt;/li>
&lt;li>&lt;strong>Proxy (代理主题角色)&lt;/strong> 代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象。 在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实 主体。代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主 题对象,并对真实主题对象的使用加以约束。代理角色通常在客户端调用所引用的真实主 题操作之前或之后还需要执行其他操作，而不仅仅是单纯的调用真实主题对象中的操作。&lt;/li>
&lt;li>&lt;strong>RealSubject (真实主题 角色)&lt;/strong> 真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业 务操作,客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。&lt;/li>
&lt;/ol>
&lt;h3 id="代理模式的优点">
 代理模式的优点
 &lt;a class="anchor" href="#%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f%e7%9a%84%e4%bc%98%e7%82%b9">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>代理模式能将代理对象与真实被调用的目标对象分离。&lt;/li>
&lt;li>一定程度上降低了系统的耦合度，扩展性好。&lt;/li>
&lt;li>可以起到保护目标对象的作用。&lt;/li>
&lt;li>可以对目标对象的功能增强。&lt;/li>
&lt;/ul>
&lt;h3 id="代理模式的缺点">
 代理模式的缺点
 &lt;a class="anchor" href="#%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f%e7%9a%84%e7%bc%ba%e7%82%b9">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>代理模式会造成系统设计中类的数量增加。&lt;/li>
&lt;li>在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。&lt;/li>
&lt;/ul>
&lt;h2 id="二jdk动态代理">
 二、JDK动态代理
 &lt;a class="anchor" href="#%e4%ba%8cjdk%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;p>在java的动态代理机制中，有两个重要的类或接口，一个是 &lt;code>InvocationHandler&lt;/code>(Interface)、另一个则是 &lt;code>Proxy&lt;/code>(Class)，这一个类和接口是实现我们动态代理所必须用到的。&lt;/p>
&lt;h3 id="invocationhandler">
 InvocationHandler
 &lt;a class="anchor" href="#invocationhandler">#&lt;/a>
&lt;/h3>
&lt;p>每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。&lt;/p>
&lt;p>InvocationHandler这个接口的唯一一个方法 invoke 方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>复制代码Object &lt;span style="color:#a6e22e">invoke&lt;/span>(Object proxy, Method method, Object&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> Throwable
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法一共接受三个参数，那么这三个参数分别代表如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>proxy&lt;/strong>:指代JDK动态生成的最终代理对象&lt;/li>
&lt;li>&lt;strong>method&lt;/strong>:指代的是我们所要调用真实对象的某个方法的Method对象&lt;/li>
&lt;li>&lt;strong>args&lt;/strong>:指代的是调用真实对象某个方法时接受的参数&lt;/li>
&lt;/ul>
&lt;h3 id="proxy">
 Proxy
 &lt;a class="anchor" href="#proxy">#&lt;/a>
&lt;/h3>
&lt;p>Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是newProxyInstance 这个方法：&lt;/p></description></item><item><title>03垃圾收集器与内存分配策略</title><link>https://lwmfjc.github.io/zh/docs/technology/JVM/understanding_the_jvm/03/</link><pubDate>Thu, 25 May 2023 20:04:33 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/JVM/understanding_the_jvm/03/</guid><description>&lt;blockquote>
&lt;p>学习《深入理解Java虚拟机》，感谢作者！&lt;/p>
&lt;/blockquote>
&lt;h3 id="代码清单3-9--xxmaxtenuringthreshod1说明">
 代码清单3-9 -XX:MaxTenuringThreshod=1说明
 &lt;a class="anchor" href="#%e4%bb%a3%e7%a0%81%e6%b8%85%e5%8d%953-9--xxmaxtenuringthreshod1%e8%af%b4%e6%98%8e">#&lt;/a>
&lt;/h3>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;/th>
 &lt;th>Eden[8M]&lt;/th>
 &lt;th>Survivor1[1M]&lt;/th>
 &lt;th>Survivor2[1M]&lt;/th>
 &lt;th>Old {10M}&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>初始&lt;/td>
 &lt;td>allocation1[0.25M]，allocation2[4MB]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>3执行时gc导致的变化&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>+allocation1[0.25M]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>+allocation2[4MB]&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>3执行后&lt;/td>
 &lt;td>+allocation3[4MB]&lt;/td>
 &lt;td>+allocation1[0.25M]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>+allocation2[4MB]&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>5执行时gc导致的变化&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>allocation2[4MB]，+allocation1[0.25M]&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>5执行后&lt;/td>
 &lt;td>+allocation3[4MB]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>allocation2[4MB]，+allocation1[0.25M]&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h3 id="代码清单3-9--xxmaxtenuringthreshod15说明">
 代码清单3-9 -XX:MaxTenuringThreshod=15说明
 &lt;a class="anchor" href="#%e4%bb%a3%e7%a0%81%e6%b8%85%e5%8d%953-9--xxmaxtenuringthreshod15%e8%af%b4%e6%98%8e">#&lt;/a>
&lt;/h3>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;/th>
 &lt;th>Eden[8M]&lt;/th>
 &lt;th>Survivor1[1M]&lt;/th>
 &lt;th>Survivor2[1M]&lt;/th>
 &lt;th>Old {10M}&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>初始&lt;/td>
 &lt;td>allocation1[0.25M]，allocation2[4MB]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>3执行时gc导致的变化&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>+allocation1[0.25M]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>+allocation2[4MB]&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>3执行后&lt;/td>
 &lt;td>+allocation3[4MB]&lt;/td>
 &lt;td>+allocation1[0.25M]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>+allocation2[4MB]&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>5执行时gc导致的变化&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>+allocation1[0.25M]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>allocation2[4MB]&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>5执行后&lt;/td>
 &lt;td>+allocation3[4MB]&lt;/td>
 &lt;td>+allocation1[0.25M]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>allocation2[4MB]，+allocation1[0.25M]&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h3 id="代码清单3-10-说明">
 代码清单3-10 说明
 &lt;a class="anchor" href="#%e4%bb%a3%e7%a0%81%e6%b8%85%e5%8d%953-10-%e8%af%b4%e6%98%8e">#&lt;/a>
&lt;/h3>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;/th>
 &lt;th>Eden[8M]&lt;/th>
 &lt;th>Survivor1[1M]&lt;/th>
 &lt;th>Survivor2[1M]&lt;/th>
 &lt;th>Old {10M}&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>初始&lt;/td>
 &lt;td>allocation1[0.25M]，&lt;br >allocation2[[0.25M]，allocation3[4M]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>4执行时gc导致的变化&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>+allocation1[0.25M]，&lt;br >+allocation2[[0.25M]，&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>+allocation3[4MB]&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>4执行后&lt;/td>
 &lt;td>+allocation4[4MB]&lt;/td>
 &lt;td>+allocation1[0.25M]，&lt;br >+allocation2[[0.25M]，&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>+allocation3[4MB]&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>6执行时gc导致的变化&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>allocation3[4MB]，&lt;br >+allocation1[0.25M]，&lt;br >+allocation2[[0.25M]，&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>6执行后&lt;/td>
 &lt;td>+allocation4[4MB]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>allocation3[4MB]，&lt;br >+allocation1[0.25M]，&lt;br >+allocation2[[0.25M]，&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h3 id="代码清单3-11-说明">
 代码清单3-11 说明
 &lt;a class="anchor" href="#%e4%bb%a3%e7%a0%81%e6%b8%85%e5%8d%953-11-%e8%af%b4%e6%98%8e">#&lt;/a>
&lt;/h3>
&lt;h4 id="-xx-handlepromotionfailure-关">
 -XX:-HandlePromotionFailure 关
 &lt;a class="anchor" href="#-xx-handlepromotionfailure-%e5%85%b3">#&lt;/a>
&lt;/h4>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;/th>
 &lt;th>Eden[8M]&lt;/th>
 &lt;th>Survivor1[1M]&lt;/th>
 &lt;th>Survivor2[1M]&lt;/th>
 &lt;th>Old {10M}&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>初始&lt;/td>
 &lt;td>allocation1[2M]，&lt;br >allocation2[2M]，&lt;br >allocation3[2M]&lt;br >allocation1[null]，allocation4[2M]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>5执行时gc导致的变化&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>+allocation2[2M]，+allocation3[2M] //总共4M&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>5执行后&lt;/td>
 &lt;td>+allocation4[2M]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>+allocation2[2M]，+allocation3[2M] //总共4M&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>6-&amp;gt;11&lt;/td>
 &lt;td>allocation4[2M]&lt;br >+allocation5[2M]，&lt;br >+allocation6[2M]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>allocation2[2M]，&lt;br >allocation3[2M] //总共4M，&lt;br >此时老年代连续可用空间在6M（或者说小于6M）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>11执行时gc导致的变化&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>allocation3[4MB]，&lt;br >+allocation1[0.25M]，&lt;br >+allocation2[[0.25M]，&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>11执行后&lt;/td>
 &lt;td>+allocation7[2MB]&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>&lt;/td>
 &lt;td>allocation3[4MB]，&lt;br >+allocation1[0.25M]，&lt;br >+allocation2[[0.25M]，&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h1 id="说明">
 说明
 &lt;a class="anchor" href="#%e8%af%b4%e6%98%8e">#&lt;/a>
&lt;/h1>
&lt;blockquote>
&lt;ol>
&lt;li>
&lt;p>书籍版权归著者和出版社所有&lt;/p></description></item><item><title>linux中调试open jdk</title><link>https://lwmfjc.github.io/zh/docs/problem/JVM/2023052302/</link><pubDate>Tue, 23 May 2023 14:29:06 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/JVM/2023052302/</guid><description>&lt;blockquote>
&lt;p>完全转载自https://lin1997.github.io/2020/07/19/debug-openjdk-on-ubuntu.html ，以防丢失故作备份，目前还没看懂。&lt;/p>
&lt;/blockquote>
&lt;h1 id="在ubuntu中编译和调试openjdk">
 在Ubuntu中编译和调试OpenJDK
 &lt;a class="anchor" href="#%e5%9c%a8ubuntu%e4%b8%ad%e7%bc%96%e8%af%91%e5%92%8c%e8%b0%83%e8%af%95openjdk">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://lin1997.github.io/archive.html?tag=OpenJDK">OpenJDK&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://lin1997.github.io/archive.html?tag=Ubuntu">Ubuntu&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://lin1997.github.io/archive.html?tag=CLion">CLion&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>2020年 07月19日&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="构建编译环境">
 构建编译环境
 &lt;a class="anchor" href="#%e6%9e%84%e5%bb%ba%e7%bc%96%e8%af%91%e7%8e%af%e5%a2%83">#&lt;/a>
&lt;/h2>
&lt;p>安装GCC编译器：&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo apt install build-essential
&lt;/code>&lt;/pre>&lt;p>安装OpenJDK依赖库：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>工具&lt;/th>
 &lt;th>库名称&lt;/th>
 &lt;th>安装命令&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>FreeType&lt;/td>
 &lt;td>The FreeType Project&lt;/td>
 &lt;td>&lt;code>sudo apt install libfreetype6-dev&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>CUPS&lt;/td>
 &lt;td>Common UNIX Printing System&lt;/td>
 &lt;td>&lt;code>sudo apt install libcups2-dev&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>X11&lt;/td>
 &lt;td>X Window System&lt;/td>
 &lt;td>&lt;code>sudo apt install libx11-dev libxext-dev libxrender-dev libxrandr-dev libxtst-dev libxt-dev&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>ALSA&lt;/td>
 &lt;td>Advanced Linux Sound Architecture&lt;/td>
 &lt;td>&lt;code>sudo apt install libasound2-dev&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>libffi&lt;/td>
 &lt;td>Portable Foreign Function Interface&lt;/td>
 &lt;td>&lt;code>sudo apt install libffi-dev&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Autoconf&lt;/td>
 &lt;td>Extensible Package of M4 Macros&lt;/td>
 &lt;td>&lt;code>sudo apt install autoconf&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>zip/unzip&lt;/td>
 &lt;td>unzip&lt;/td>
 &lt;td>&lt;code>sudo apt install zip unzip&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>fontconfig&lt;/td>
 &lt;td>fontconfig&lt;/td>
 &lt;td>&lt;code>sudo apt install libfontconfig1-dev&lt;/code>&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>假设要编译大版本号为N的JDK，我们还要安装一个大版本号&lt;strong>至少为N-1&lt;/strong>的、已经编译好的JDK作为“Bootstrap JDK”：&lt;/p></description></item><item><title>zsh卸载后root无法登录及vm扩容centos7报错处理</title><link>https://lwmfjc.github.io/zh/docs/problem/Linux/20230523/</link><pubDate>Tue, 23 May 2023 12:06:46 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/Linux/20230523/</guid><description>&lt;h1 id="zsh卸载后root无法登录">
 zsh卸载后root无法登录
 &lt;a class="anchor" href="#zsh%e5%8d%b8%e8%bd%bd%e5%90%8eroot%e6%97%a0%e6%b3%95%e7%99%bb%e5%bd%95">#&lt;/a>
&lt;/h1>
&lt;blockquote>
&lt;p>主要参考文档 &lt;a href="https://blog.csdn.net/Scoful/article/details/119746150">https://blog.csdn.net/Scoful/article/details/119746150&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>重启，开机引导进入下面的那个，按e进入编辑模式&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="img/ly-20241212141833490.png" alt="ly-20241212141833490" />&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>移动光标，找到&lt;code>ro crashkernel=auto&lt;/code>，修改为 &lt;code>rw init=sysroot/bin/sh&lt;/code>&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141833799.png" alt="ly-20241212141833799" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>按ctrl+x进入单用户模式界面&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="img/ly-20241212141833982.png" alt="ly-20241212141833982" />&lt;/p>
&lt;ol start="4">
&lt;li>输入chroot /sysroot 获取权限&lt;/li>
&lt;li>vim /etc/passwd&lt;/li>
&lt;li>第一行 ，root &amp;hellip;&amp;hellip;zsh，中&lt;code>/bin/zsh&lt;/code>，改为&lt;code>/bin/bash&lt;/code>&lt;/li>
&lt;li>用&lt;code>touch /.autorelabel&lt;/code>更新SELinux信息&lt;/li>
&lt;li>两次exit 推出chroot&lt;/li>
&lt;li>reboot 重启：需要一定时间，耐心等待&lt;/li>
&lt;/ol>
&lt;h1 id="vm扩容centos7">
 vm扩容centos7
 &lt;a class="anchor" href="#vm%e6%89%a9%e5%ae%b9centos7">#&lt;/a>
&lt;/h1>
&lt;p>这里是因为我在vm手动扩容后，进入centos7系统&amp;mdash;用了 可视化界面中的disk软件直接扩容，发生错误（具体错误我没注意，一闪而过了），后面呢我再使用命令&lt;code>resize2fs /dev/sda3&lt;/code>的时候，发现总是提示 busy&lt;/p>
&lt;h2 id="解决办法">
 解决办法
 &lt;a class="anchor" href="#%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;p>按照上面的办法，进入到第3步结束之后（&lt;strong>按ctrl+x进入单用户模式界面&lt;/strong> 要做）&lt;br>
输入 umount /dev/sda3 进行卸载&lt;br>
然后输入下面进行修复（极为重要），然后出现问题是否修复一直按&amp;rsquo;y&amp;rsquo;即可&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>xfs_repair /dev/sda4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>注：如果你当前文件系统是ext4，可以执行fsck.ext4 /dev/sda4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后输入 mount /dev/sda3 / 进行挂载（这步可能不需要）&lt;br>
最后 reboot 重启 &lt;br>
重启之后，再执行 &lt;code>resize2fs /dev/sda3&lt;/code> 即可&lt;/p></description></item><item><title>hexo在线查看pdf</title><link>https://lwmfjc.github.io/zh/docs/problem/Hexo/01/</link><pubDate>Tue, 25 Apr 2023 09:31:50 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/Hexo/01/</guid><description>&lt;h1 id="场景">
 场景
 &lt;a class="anchor" href="#%e5%9c%ba%e6%99%af">#&lt;/a>
&lt;/h1>
&lt;p>由于在看《mysql是如何运行的》，做md文件笔记时，发现好多都是按pdf一字不漏打出来。所以想着能不能直接&lt;strong>本地编辑pdf&lt;/strong>，然后博客上支持&lt;strong>在线查看&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>事后觉得这个方式有待斟酌，电脑上/平板上查看没啥问题，手机上查看字有点小，但也还能接受。==&amp;gt;待斟酌&lt;br>
不过下面的方案是可行的。&lt;/p>
&lt;/blockquote>
&lt;h1 id="准备">
 准备
 &lt;a class="anchor" href="#%e5%87%86%e5%a4%87">#&lt;/a>
&lt;/h1>
&lt;p>需要到官网下载 pdf.js&lt;/p>
&lt;p>&lt;a href="https://github.com/mozilla/pdf.js/releases">https://github.com/mozilla/pdf.js/releases&lt;/a> ，这里选择 v3.4.120中的&lt;a href="https://github.com/mozilla/pdf.js/releases/download/v3.4.120/pdfjs-3.4.120-dist.zip">pdfjs-3.4.120-dist.zip&lt;/a> ，最新版本好像有问题&lt;/p>
&lt;h1 id="操作">
 操作
 &lt;a class="anchor" href="#%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h1>
&lt;h2 id="pdfjs处理">
 pdfjs处理
 &lt;a class="anchor" href="#pdfjs%e5%a4%84%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;p>在source/下创建myjs/pdfjs文件夹，并解压到这个文件夹下&lt;br>
&lt;img src="img/ly-20241212141830564.png" alt="ly-20241212141830564" />&lt;/p>
&lt;p>修改pdfjs/web/viewer.js&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">fileOrigin&lt;/span> &lt;span style="color:#f92672">!==&lt;/span> &lt;span style="color:#a6e22e">viewerOrigin&lt;/span>) {&lt;span style="color:#75715e">//1563行左右
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Error(&lt;span style="color:#e6db74">&amp;#34;file origin does not match viewer&amp;#39;s&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//注释掉，为了处理跨域问题，注释掉后允许在线访问其他网站的pdf
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// if (fileOrigin !== viewerOrigin) {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//	throw new Error(&amp;#34;file origin does not match viewer&amp;#39;s&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="hexo配置修改">
 hexo配置修改
 &lt;a class="anchor" href="#hexo%e9%85%8d%e7%bd%ae%e4%bf%ae%e6%94%b9">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 找到# Directory下的skip_render项，添加忽略渲染的文件夹&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">skip_render&lt;/span>: [&lt;span style="color:#e6db74">&amp;#39;myjs/pdfjs/**/*&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="清理hexo中public及其他缓存文件">
 清理hexo中public及其他缓存文件
 &lt;a class="anchor" href="#%e6%b8%85%e7%90%86hexo%e4%b8%adpublic%e5%8f%8a%e5%85%b6%e4%bb%96%e7%bc%93%e5%ad%98%e6%96%87%e4%bb%b6">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span> hexo clean &amp;amp; hexo g
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="文件预览测试">
 文件预览测试
 &lt;a class="anchor" href="#%e6%96%87%e4%bb%b6%e9%a2%84%e8%a7%88%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h1>
&lt;h2 id="本地文件">
 本地文件
 &lt;a class="anchor" href="#%e6%9c%ac%e5%9c%b0%e6%96%87%e4%bb%b6">#&lt;/a>
&lt;/h2>
&lt;p>我们在hexo的source文件夹下，放置这样一个文件： source/pdf/my.pdf&lt;br>
&lt;img src="img/ly-20241212141830812.png" alt="ly-20241212141830812" />&lt;/p></description></item><item><title>07B+数索引的使用</title><link>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/07/</link><pubDate>Mon, 24 Apr 2023 14:32:22 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/07/</guid><description>&lt;blockquote>
&lt;p>学习《MySQL是怎样运行的》，感谢作者！&lt;/p>
&lt;/blockquote>
&lt;h1 id="innodb存储引擎的b树索引结论">
 InnoDB存储引擎的B+树索引：结论
 &lt;a class="anchor" href="#innodb%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e7%9a%84b%e6%a0%91%e7%b4%a2%e5%bc%95%e7%bb%93%e8%ae%ba">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>每个索引&lt;/strong>对应一颗B+树。B+树有好多层，&lt;strong>最下边一层&lt;/strong>是&lt;strong>叶子节点&lt;/strong>，其余是&lt;strong>内节点&lt;/strong>。所有&lt;strong>用户记录&lt;/strong>都存在B+树的&lt;strong>叶子节点&lt;/strong>，所有&lt;strong>目录项记录&lt;/strong>都存在内节点&lt;/li>
&lt;li>InnoDB 存储引擎会&lt;strong>自动为主键建立聚簇索引&lt;/strong>(如果&lt;strong>没有显式指定主键&lt;/strong>或者&lt;strong>没有声明不允许存储NULL的UNIQUE 键&lt;/strong>，它会自动添加主键) ， &lt;strong>聚簇索引&lt;/strong>的&lt;strong>叶子节点&lt;/strong>包含&lt;strong>完整的用户记录&lt;/strong>&lt;/li>
&lt;li>我们可以为感兴趣的列建立&lt;strong>二级索引&lt;/strong>，二级索引的叶子节点包含的用户记录由&lt;strong>索引列&lt;/strong>
&lt;strong>和主键&lt;/strong>组成。如果想通过二级索引查找完整的用户记录，需要执行&lt;strong>回表&lt;/strong>操作， 也就是在通过二级索引&lt;strong>找到主键值之后&lt;/strong>，再到&lt;strong>聚簇索引&lt;/strong>中查找完整的用户记录&lt;/li>
&lt;li>B+ 树中的&lt;strong>每层节点&lt;/strong>都按照&lt;strong>索引列的值从小到大的顺序排序&lt;/strong>组成了&lt;strong>双向链表&lt;/strong>，而且每个&lt;strong>页内的记录&lt;/strong>(无论是&lt;strong>用户记录&lt;/strong>还是&lt;strong>目录项记录&lt;/strong>)都按照索引列的值从小到大的顺序形成了一个单向链表。如果是联合索引， 则&lt;strong>页面&lt;/strong>和&lt;strong>记录&lt;/strong> &lt;strong>先&lt;/strong>按照索引列中前面的列的值排序：&lt;strong>如果该列的值相同&lt;/strong>，&lt;strong>再按照索引列中后面的列的值排序&lt;/strong>。比如， 我们对列c2 和c3建立了联合索引 &lt;strong>idx_c2_c3(c2， c3)&lt;/strong>，那么该索引中的页面和记录就&lt;strong>先按照c2 列&lt;/strong>的值进行排序；&lt;strong>如果c2 列的值相同&lt;/strong>， &lt;strong>再按照c3&lt;/strong> 列的值排序&lt;/li>
&lt;li>通过索引查找记录时，是&lt;strong>从B+ 树的根节点开始一层一层向下搜索的&lt;/strong>。由于每个页面(无论是&lt;strong>内节点页面&lt;/strong>还是&lt;strong>叶子节点页面&lt;/strong>〉中的记录都划分成了&lt;strong>若干个组&lt;/strong>， 每个组中&lt;strong>索引列值最大的记录&lt;/strong>在&lt;strong>页内的偏移量&lt;/strong>会被当作&lt;strong>槽&lt;/strong>依次存放在&lt;strong>页目录中&lt;/strong>(当然， 规定Supremum 记录比任何用户记录都大) ，因此可以在&lt;strong>页目录中通过二分法&lt;/strong>快速定位到&lt;strong>索引列等于某个值的记录&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>如果大家在阅读上述结论时哪怕有点疑惑， 那么下面的内容就不适合你，请回过头去反复阅读前面的章节&lt;/p>
&lt;/blockquote>
&lt;h1 id="b树索引示意图的简化">
 B+树索引示意图的简化
 &lt;a class="anchor" href="#b%e6%a0%91%e7%b4%a2%e5%bc%95%e7%a4%ba%e6%84%8f%e5%9b%be%e7%9a%84%e7%ae%80%e5%8c%96">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#创建新表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql&amp;gt; CREATE TABLE single_table&lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id INT NOT NULL AUTO_INCREMENT,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key1 VARCHAR&lt;span style="color:#f92672">(&lt;/span>100&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key2 INT,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key3 VARCHAR&lt;span style="color:#f92672">(&lt;/span>100&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key_part1 VARCHAR&lt;span style="color:#f92672">(&lt;/span>100&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key_part2 VARCHAR&lt;span style="color:#f92672">(&lt;/span>100&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key_part3 VARCHAR&lt;span style="color:#f92672">(&lt;/span>100&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> common_field VARCHAR&lt;span style="color:#f92672">(&lt;/span>100&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PRIMARY KEY &lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> KEY idx_key1&lt;span style="color:#f92672">(&lt;/span>key1&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UNIQUE KEY uk_key2&lt;span style="color:#f92672">(&lt;/span>key2&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> KEY idx_key3&lt;span style="color:#f92672">(&lt;/span>key3&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> KEY idx_key_part&lt;span style="color:#f92672">(&lt;/span>key_part1,key_part2,key_part3&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">)&lt;/span> Engine&lt;span style="color:#f92672">=&lt;/span>InnoDB CHARSET &lt;span style="color:#f92672">=&lt;/span> utf8;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如上，建立了&lt;strong>1个聚簇索引&lt;/strong>，&lt;strong>4个二级索引&lt;/strong>&lt;/p></description></item><item><title>06B+树索引</title><link>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/06/</link><pubDate>Sat, 22 Apr 2023 15:04:46 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/06/</guid><description>&lt;blockquote>
&lt;p>学习《MySQL是怎样运行的》，感谢作者！&lt;/p>
&lt;/blockquote>
&lt;h1 id="概述">
 概述
 &lt;a class="anchor" href="#%e6%a6%82%e8%bf%b0">#&lt;/a>
&lt;/h1>
&lt;p>数据页由&lt;strong>7个&lt;/strong>组成部分，各个数据页可以组成一个&lt;strong>双向链表&lt;/strong>，每个数据页中的记录会按照&lt;strong>主键值从小到大的顺序&lt;/strong>组成一个&lt;strong>单向链表&lt;/strong>。每个数据页都会为&lt;strong>它里面的记录&lt;/strong>生成一个&lt;strong>页目录&lt;/strong>，在通过主键查找某条记录的时候可以在&lt;strong>页目录&lt;/strong>中使用二分法快速定位到&lt;strong>对应的槽&lt;/strong>，然后再&lt;strong>遍历该槽&lt;/strong>对应&lt;strong>分组中的记录&lt;/strong>即可快速找到&lt;strong>指定&lt;/strong>的记录。&lt;strong>页和记录&lt;/strong>的关系&lt;/p>
&lt;blockquote>
&lt;p>页a，页b 可以&lt;strong>不在物理结构上相连&lt;/strong>，只要通过&lt;strong>双向链表相关联&lt;/strong>即可&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="img/ly-20241212142156258.png" alt="ly-20241212142156258" />&lt;/p>
&lt;h1 id="没有索引时进行查找">
 没有索引时进行查找
 &lt;a class="anchor" href="#%e6%b2%a1%e6%9c%89%e7%b4%a2%e5%bc%95%e6%97%b6%e8%bf%9b%e8%a1%8c%e6%9f%a5%e6%89%be">#&lt;/a>
&lt;/h1>
&lt;p>假设我们要搜索&lt;strong>某个列&lt;/strong>等于&lt;strong>某个常数&lt;/strong>的情况：&lt;br>
&lt;code>SELECT [查询列表] FROM 表名 WHERE 列名 = xxx&lt;/code>&lt;/p>
&lt;h2 id="在一个页中查找">
 在一个页中查找
 &lt;a class="anchor" href="#%e5%9c%a8%e4%b8%80%e4%b8%aa%e9%a1%b5%e4%b8%ad%e6%9f%a5%e6%89%be">#&lt;/a>
&lt;/h2>
&lt;p>假设记录极少，所有记录可以&lt;strong>存放到一个页中&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>以&lt;strong>主键&lt;/strong>位搜索条件：页目录中使用&lt;strong>二分法&lt;/strong>快速定位到对应的&lt;strong>槽&lt;/strong>，然后在&lt;strong>遍历槽对应分组中的记录&lt;/strong>，即可快速找到指定记录&lt;/li>
&lt;li>其他列作为搜索条件：对于&lt;strong>非主键&lt;/strong>，数据页没有为&lt;strong>非主键列&lt;/strong>建立所谓的&lt;strong>页目录&lt;/strong>，所以&lt;strong>无法通过二分法&lt;/strong>快速定位相应的槽。只能&lt;strong>从Infimum依次遍历&lt;/strong>单向链表中的每条记录，然后对比，效率极低&lt;/li>
&lt;/ul>
&lt;h2 id="在很多页中查找">
 在很多页中查找
 &lt;a class="anchor" href="#%e5%9c%a8%e5%be%88%e5%a4%9a%e9%a1%b5%e4%b8%ad%e6%9f%a5%e6%89%be">#&lt;/a>
&lt;/h2>
&lt;p>两个步骤：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>定位到记录所在的页&lt;/strong>&lt;/li>
&lt;li>从&lt;strong>所在页内&lt;/strong>查找相应的记录&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>没有索引&lt;/strong>情况下，不能快速定位到所在页，只能从&lt;strong>第一页&lt;/strong>沿着&lt;strong>双向链表&lt;/strong>一直往下找，而如果是主键，每一页则可以在&lt;strong>页目录&lt;/strong>二分查找。&lt;br>
不过由于要&lt;strong>遍历所有页&lt;/strong>，所以超级&lt;strong>耗时&lt;/strong>&lt;/p>
&lt;h1 id="索引">
 索引
 &lt;a class="anchor" href="#%e7%b4%a2%e5%bc%95">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#例子&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql&amp;gt; CREATE TABLE index_demo&lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c1 INT,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c2 INT,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c3 CHAR&lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PRIMARY KEY&lt;span style="color:#f92672">(&lt;/span>c1&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">)&lt;/span> ROW_FORMAT&lt;span style="color:#f92672">=&lt;/span>COMPACT;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>完整的行格式&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="img/ly-20241212142156429.png" alt="ly-20241212142156429" />&lt;/p>
&lt;p>简化的行格式&lt;br>
&lt;img src="img/ly-20241212142156467.png" alt="ly-20241212142156467" />&lt;/p>
&lt;ul>
&lt;li>record_type：&lt;strong>记录头信息&lt;/strong>的一项属性，表示&lt;strong>记录的类型&lt;/strong>。0：普通记录，2：Infimum记录，3：Supremum记录，1还没用过等会再说&lt;/li>
&lt;li>next_record：&lt;strong>记录头信息&lt;/strong>的一项属性，表示从当前记录的&lt;strong>真实数据&lt;/strong>到&lt;strong>下一条记录真实数据&lt;/strong>的距离&lt;/li>
&lt;li>各个列的值：这里只展示在index_demo表中的&lt;strong>3个列&lt;/strong>，分别是c1、c2、c3&lt;/li>
&lt;li>其他信息：包括&lt;strong>隐藏列&lt;/strong>及&lt;strong>记录的额外信息&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>改为竖着查看：&lt;br>
&lt;img src="img/ly-20241212142156521.png" alt="ly-20241212142156521" />&lt;/p>
&lt;blockquote>
&lt;p>上面图6-4的箭头其实有一点点出入，应该是指向z真实数据第1列那个位置，如下
&lt;img src="img/ly-20241212142156561.png" alt="ly-20241212142156561" />&lt;/p></description></item><item><title>05InnoDB数据页结构</title><link>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/05/</link><pubDate>Fri, 21 Apr 2023 10:35:29 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/05/</guid><description>&lt;blockquote>
&lt;p>学习《MySQL是怎样运行的》，感谢作者！&lt;/p>
&lt;/blockquote>
&lt;h1 id="不同类型的页简介">
 不同类型的页简介
 &lt;a class="anchor" href="#%e4%b8%8d%e5%90%8c%e7%b1%bb%e5%9e%8b%e7%9a%84%e9%a1%b5%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h1>
&lt;p>页是&lt;strong>InnoDB管理存储空间&lt;/strong>的基本单位，1个页的大小一般是16KB&lt;/p>
&lt;blockquote>
&lt;p>InnoDB为了不同目的设计多种不同类型的页，包括&lt;strong>存放表空间头部信息&lt;/strong>
的页、&lt;strong>存放Change Buffer 信息&lt;/strong>的页、&lt;strong>存放INODE信息&lt;/strong>的页、&lt;strong>存放undo 日志信息&lt;/strong>的页&lt;/p>
&lt;/blockquote>
&lt;p>这里说的是&lt;strong>存放表中记录&lt;/strong>的那种类型的页，这种&lt;strong>存放记录&lt;/strong>的页称为&lt;strong>索引页&lt;/strong>（INDEX页）&lt;/p>
&lt;blockquote>
&lt;p>暂时称之为&lt;strong>数据页&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;h1 id="数据页结构快览">
 数据页结构快览
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e9%a1%b5%e7%bb%93%e6%9e%84%e5%bf%ab%e8%a7%88">#&lt;/a>
&lt;/h1>
&lt;p>1个页有16KB，这部分存储空间被划分为了多个部分（7部分），不同部分有不同的功能&lt;br>
&lt;img src="img/ly-20241212142155323.png" alt="ly-20241212142155323" />&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>名称&lt;/th>
 &lt;th>中文名&lt;/th>
 &lt;th>占用空间&lt;/th>
 &lt;th>大小&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>File Header&lt;/td>
 &lt;td>文件头部&lt;/td>
 &lt;td>38 字节&lt;/td>
 &lt;td>页的一些通用信息&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Page Header&lt;/td>
 &lt;td>页面头部&lt;/td>
 &lt;td>56 字节&lt;/td>
 &lt;td>数据页专有的一些信息&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Infimum + Supremum&lt;/td>
 &lt;td>页面中的最小记录和最大记录&lt;/td>
 &lt;td>26 字节&lt;/td>
 &lt;td>两个虚拟的记录&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>User Records&lt;/td>
 &lt;td>用户记录&lt;/td>
 &lt;td>不确定&lt;/td>
 &lt;td>用户存储的记录内容&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Free Space&lt;/td>
 &lt;td>空闲空间&lt;/td>
 &lt;td>不确定&lt;/td>
 &lt;td>页中尚未使用的空间&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Page Directory&lt;/td>
 &lt;td>页目录&lt;/td>
 &lt;td>不确定&lt;/td>
 &lt;td>某些记录的相对位置&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>File Trailer&lt;/td>
 &lt;td>文件尾部&lt;/td>
 &lt;td>8 字节&lt;/td>
 &lt;td>校验页是否完整&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h1 id="记录在页中的存储">
 记录在页中的存储
 &lt;a class="anchor" href="#%e8%ae%b0%e5%bd%95%e5%9c%a8%e9%a1%b5%e4%b8%ad%e7%9a%84%e5%ad%98%e5%82%a8">#&lt;/a>
&lt;/h1>
&lt;p>每插入一条记录，从&lt;strong>Free Space&lt;/strong>申请一个记录大小的空间，并&lt;strong>将这个空间划分到UserRecords&lt;/strong>部分。当FreeSpace部分的空间全部被UserRecords部分替代掉后，意味着该页用完。如果再插入，就需要申请新的页&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142155485.png" alt="ly-20241212142155485" />&lt;/p>
&lt;h2 id="记录头信息的秘密">
 记录头信息的秘密
 &lt;a class="anchor" href="#%e8%ae%b0%e5%bd%95%e5%a4%b4%e4%bf%a1%e6%81%af%e7%9a%84%e7%a7%98%e5%af%86">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>mysql&amp;gt; CREATE TABLE page_demo&lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c1 INT,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c2 INT,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c3 VARCHAR&lt;span style="color:#f92672">(&lt;/span>10000&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PRIMARY KEY&lt;span style="color:#f92672">(&lt;/span>c1&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">)&lt;/span> CHARSET&lt;span style="color:#f92672">=&lt;/span>ascii ROW_FORMAT&lt;span style="color:#f92672">=&lt;/span>COMPACT;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Query OK, &lt;span style="color:#ae81ff">0&lt;/span> rows affected &lt;span style="color:#f92672">(&lt;/span>0.03 sec&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="img/ly-20241212142155528.png" alt="ly-20241212142155528" />&lt;/p></description></item><item><title>04InnoDB记录存储结构</title><link>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/04/</link><pubDate>Tue, 18 Apr 2023 20:00:03 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/04/</guid><description>&lt;blockquote>
&lt;p>学习《MySQL是怎样运行的》，感谢作者！&lt;/p>
&lt;/blockquote>
&lt;h1 id="问题">
 问题
 &lt;a class="anchor" href="#%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h1>
&lt;p>表数据存在哪，以什么格式存放，MySQL以什么方式来访问&lt;br>
存储引擎：对表中数据进行&lt;strong>存储&lt;/strong>和&lt;strong>写入&lt;/strong>&lt;br>
InnoDB是MySQL默认的存储引擎，这章主要讲&lt;strong>InnoDB存储引擎的记录存储结构&lt;/strong>&lt;/p>
&lt;h1 id="innodb页简介">
 InnoDB页简介
 &lt;a class="anchor" href="#innodb%e9%a1%b5%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h1>
&lt;p>&lt;strong>注意，是简介&lt;/strong>&lt;br>
InnoDB：将表中的数据&lt;strong>存储到磁盘上&lt;/strong>&lt;br>
真正处理数据的过程：内存中。所以需要&lt;strong>把磁盘中数据加载到内存中&lt;/strong>，如果是&lt;strong>写入&lt;/strong>或&lt;strong>修改&lt;/strong>请求，还需要把&lt;strong>内存&lt;/strong>中的内容&lt;strong>刷新到磁盘&lt;/strong>上&lt;br>
获取记录：不是一条条从磁盘读，InnoDB将数据划分为若干个页，以&lt;strong>页&lt;/strong>作为&lt;strong>磁盘&lt;/strong>和&lt;strong>内存&lt;/strong>之间交互的基本单位。页大小-&amp;gt; 一般是16KB&lt;br>
一般情况：一次最少从磁盘读取16KB的内容&lt;strong>到内存中&lt;/strong>，一次最少把内存中的16KB内容&lt;strong>刷新到磁盘&lt;/strong>中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>mysql&amp;gt; SHOW VARIABLES LIKE &lt;span style="color:#e6db74">&amp;#39;innodb_page_size&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+------------------+-------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| Variable_name | Value |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+------------------+-------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| innodb_page_size | &lt;span style="color:#ae81ff">16384&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+------------------+-------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> row in set &lt;span style="color:#f92672">(&lt;/span>0.00 sec&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>只能在第一次初始化MySQL数据目录时指定，之后&lt;strong>再也不能更改&lt;/strong>（通过mysqld &amp;ndash;initialize初始化数据目录[旧版本]）&lt;/p>
&lt;h1 id="innodb行格式">
 InnoDB行格式
 &lt;a class="anchor" href="#innodb%e8%a1%8c%e6%a0%bc%e5%bc%8f">#&lt;/a>
&lt;/h1>
&lt;p>以记录为单位向表中插入数据，而这些记录在&lt;strong>磁盘上的存放形式&lt;/strong>也被称为&lt;strong>行格式&lt;/strong>或者&lt;strong>记录格式&lt;/strong>&lt;br>
目前有4中&lt;strong>不同类型的行格式&lt;/strong>：COMPACT、REDUNDANT、DYNAMIC和COMPRESSED&lt;/p>
&lt;blockquote>
&lt;p>compact [kəmˈpækt]契约&lt;br>
redundant[rɪˈdʌndənt] 冗余的&lt;br>
dynamic[daɪˈnæmɪk]动态的&lt;br>
compressed [kəmˈprest] 压缩的&lt;/p>
&lt;/blockquote>
&lt;h2 id="指定行格式的语法">
 指定行格式的语法
 &lt;a class="anchor" href="#%e6%8c%87%e5%ae%9a%e8%a1%8c%e6%a0%bc%e5%bc%8f%e7%9a%84%e8%af%ad%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;p>CREATE TABLE 表名(列的信息) ROW_FORMAT=行格式名称&lt;br>
ALTER TABLE 表名 ROW_FORMATE=行格式名称&lt;br>
如下，在数据库xiaohaizi下创建一个表&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>CREATE TABLE record_format_demo&lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c1 VARCHAR&lt;span style="color:#f92672">(&lt;/span>10&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c2 VARCHAR&lt;span style="color:#f92672">(&lt;/span>10&lt;span style="color:#f92672">)&lt;/span> NOT NULL,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c3 CHAR&lt;span style="color:#f92672">(&lt;/span>10&lt;span style="color:#f92672">)&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c4 VARCHAR&lt;span style="color:#f92672">(&lt;/span>10&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">)&lt;/span> CHARSET&lt;span style="color:#f92672">=&lt;/span>ascii ROW_FORMAT&lt;span style="color:#f92672">=&lt;/span>COMPACT; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#回顾：ascii每个字符1字节即可表示，且只有空格标点数字字母不可见字符&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#插入两条数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>INSERT INTO record_format_demo&lt;span style="color:#f92672">(&lt;/span>c1,c2,c3,c4&lt;span style="color:#f92672">)&lt;/span> VALUES&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;aaaa&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;bbb&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;cc&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;d&amp;#39;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>,&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#39;eeee&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;fff&amp;#39;&lt;/span>,NULL,NULL&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查询&lt;/p></description></item><item><title>03字符集和比较规则</title><link>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/03/</link><pubDate>Mon, 17 Apr 2023 22:15:01 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/03/</guid><description>&lt;blockquote>
&lt;p>学习《MySQL是怎样运行的》，感谢作者！&lt;/p>
&lt;/blockquote>
&lt;h1 id="字符集">
 字符集
 &lt;a class="anchor" href="#%e5%ad%97%e7%ac%a6%e9%9b%86">#&lt;/a>
&lt;/h1>
&lt;p>把哪些字符映射成二进制数据：&lt;strong>字符范围&lt;/strong>&lt;br>
怎么映射：字符-&amp;gt;二进制数据，编码；二进制-&amp;gt;字符，解码&lt;br>
字符集：&lt;strong>某个字符范围的编码规则&lt;/strong>&lt;br>
同一种字符集可以有多种比较规则&lt;/p>
&lt;h2 id="重要的字符集">
 重要的字符集
 &lt;a class="anchor" href="#%e9%87%8d%e8%a6%81%e7%9a%84%e5%ad%97%e7%ac%a6%e9%9b%86">#&lt;/a>
&lt;/h2>
&lt;p>ASCAII字符集：128个，包括空格标点数字大小写及不可见字符，使用一个字节编码&lt;br>
ISO 8859-1字符集：256个，ASCAII基础扩充128个西欧常用字符（包括德法），使用1个字节，别名Latin1&lt;br>
GB2312字符集：收录部分汉字，兼容ASCAII字符集，如果字符在ASCAII字符集中则采用1字节，否则两字节。即&lt;strong>变长编码方式&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>区分某个字节，&lt;strong>代表一个单独字符&lt;/strong>，还是&lt;strong>某个字符的一部分&lt;/strong>。&lt;br>
比如0xB0AE75，由于是16进制，所有两个代表1个字节。所以这里有三个字节，其中最后那个字节为7*16+5=117 &amp;lt; 127 所以代表一个单独字符。而AE=10 * 16 +15=175 &amp;gt;127 ，所以是某个字符的一部分&lt;/p>
&lt;/blockquote>
&lt;p>GBK字符集：对GB2312字符集扩充，编码方式兼容GB2312&lt;br>
UTF-8字符集：几乎收录所有字符，且不断扩充，兼容ASCAII字符集。变长：采用1&lt;del>4字节&lt;br>
L-&amp;gt;0x4C 1字节，啊-&amp;gt;0xE5958A，两字节&lt;br>
UTF-8是Unicode字符集的一种编码方案，Unicode字符集有三种方案：UTF-8(1&lt;/del>4字节编码一个字符)，UTF-16(2或4字节编码一个字符)，UTF-32(4字节编码一个字符)&lt;/p>
&lt;blockquote>
&lt;p>对于**“我”**，ASCLL中没有，UTF-8中采用3字节编码，GB22312采用2字节编码&lt;/p>
&lt;/blockquote>
&lt;h1 id="mysql中支持的字符集和比较规则">
 MySQL中支持的字符集和比较规则
 &lt;a class="anchor" href="#mysql%e4%b8%ad%e6%94%af%e6%8c%81%e7%9a%84%e5%ad%97%e7%ac%a6%e9%9b%86%e5%92%8c%e6%af%94%e8%be%83%e8%a7%84%e5%88%99">#&lt;/a>
&lt;/h1>
&lt;p>MySQL中，区分utf8mb3和utf8mb4，前者只是用1&lt;del>3字节表示字符；后者使用1&lt;/del>4字节表示字符。MySQL中，utf8代表utf8mb3。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#查看当前MySQL支持的字符集(注意，是字符集，名称都是小写)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Default collation 默认比较规则&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql&amp;gt; SHOW CHARSET;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+----------+---------------------------------+---------------------+--------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| Charset | Description | Default collation | Maxlen |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+----------+---------------------------------+---------------------+--------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| big5 | Big5 Traditional Chinese | big5_chinese_ci | &lt;span style="color:#ae81ff">2&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| dec8 | DEC West European | dec8_swedish_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| cp850 | DOS West European | cp850_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| hp8 | HP West European | hp8_english_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| koi8r | KOI8-R Relcom Russian | koi8r_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| latin1 | cp1252 West European | latin1_swedish_ci | &lt;span style="color:#ae81ff">1&lt;/span> | &amp;lt;---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| latin2 | ISO 8859-2 Central European | latin2_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> | &amp;lt;---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| swe7 | 7bit Swedish | swe7_swedish_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| ascii | US ASCII | ascii_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> | &amp;lt;---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| ujis | EUC-JP Japanese | ujis_japanese_ci | &lt;span style="color:#ae81ff">3&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| sjis | Shift-JIS Japanese | sjis_japanese_ci | &lt;span style="color:#ae81ff">2&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| hebrew | ISO 8859-8 Hebrew | hebrew_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| tis620 | TIS620 Thai | tis620_thai_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| euckr | EUC-KR Korean | euckr_korean_ci | &lt;span style="color:#ae81ff">2&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| koi8u | KOI8-U Ukrainian | koi8u_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| gb2312 | GB2312 Simplified Chinese | gb2312_chinese_ci | &lt;span style="color:#ae81ff">2&lt;/span> | &amp;lt;---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| greek | ISO 8859-7 Greek | greek_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| cp1250 | Windows Central European | cp1250_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| gbk | GBK Simplified Chinese | gbk_chinese_ci | &lt;span style="color:#ae81ff">2&lt;/span> | &amp;lt;---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| latin5 | ISO 8859-9 Turkish | latin5_turkish_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| armscii8 | ARMSCII-8 Armenian | armscii8_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| utf8 | UTF-8 Unicode | utf8_general_ci | &lt;span style="color:#ae81ff">3&lt;/span> | &amp;lt;---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| ucs2 | UCS-2 Unicode | ucs2_general_ci | &lt;span style="color:#ae81ff">2&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| cp866 | DOS Russian | cp866_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| keybcs2 | DOS Kamenicky Czech-Slovak | keybcs2_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| macce | Mac Central European | macce_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| macroman | Mac West European | macroman_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| cp852 | DOS Central European | cp852_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| latin7 | ISO 8859-13 Baltic | latin7_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> | 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| utf8mb4 | UTF-8 Unicode | utf8mb4_general_ci | &lt;span style="color:#ae81ff">4&lt;/span> | &amp;lt;---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| cp1251 | Windows Cyrillic | cp1251_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| utf16 | UTF-16 Unicode | utf16_general_ci | &lt;span style="color:#ae81ff">4&lt;/span> | &amp;lt;---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| utf16le | UTF-16LE Unicode | utf16le_general_ci | &lt;span style="color:#ae81ff">4&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| cp1256 | Windows Arabic | cp1256_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| cp1257 | Windows Baltic | cp1257_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| utf32 | UTF-32 Unicode | utf32_general_ci | &lt;span style="color:#ae81ff">4&lt;/span> | &amp;lt;---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| binary | Binary pseudo charset | binary | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| geostd8 | GEOSTD8 Georgian | geostd8_general_ci | &lt;span style="color:#ae81ff">1&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| cp932 | SJIS &lt;span style="color:#66d9ef">for&lt;/span> Windows Japanese | cp932_japanese_ci | &lt;span style="color:#ae81ff">2&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| eucjpms | UJIS &lt;span style="color:#66d9ef">for&lt;/span> Windows Japanese | eucjpms_japanese_ci | &lt;span style="color:#ae81ff">3&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| gb18030 | China National Standard GB18030 | gb18030_chinese_ci | &lt;span style="color:#ae81ff">4&lt;/span> |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+----------+---------------------------------+---------------------+--------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">41&lt;/span> rows in set &lt;span style="color:#f92672">(&lt;/span>0.00 sec&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>字符集的比较规则（这里先看utf8的）&lt;/p></description></item><item><title>02启动选项和系统变量</title><link>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/02/</link><pubDate>Mon, 17 Apr 2023 20:49:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/02/</guid><description>&lt;blockquote>
&lt;p>学习《MySQL是怎样运行的》，感谢作者！&lt;/p>
&lt;/blockquote>
&lt;h1 id="启动选项和配置文件">
 启动选项和配置文件
 &lt;a class="anchor" href="#%e5%90%af%e5%8a%a8%e9%80%89%e9%a1%b9%e5%92%8c%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6">#&lt;/a>
&lt;/h1>
&lt;p>在程序启动时指定的设置项，也称之为&lt;strong>启动选项startup option&lt;/strong>（可以在命令行中/配置文件中 指定）&lt;br>
&lt;strong>由于在centos7中使用systemctl start mysqld启动mysql，所以好像没法用命令行指定启动选项了&lt;/strong>&lt;/p>
&lt;p>程序(可能有些程序新版本已经没有了)的对应类别和能读取的组：&lt;br>
&lt;img src="img/ly-20241212142154302.png" alt="ly-20241212142154302" />&lt;/p>
&lt;p>这里讲配置文件的方式设置启动选项：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#添加配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vim /etc/my.cnf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>server&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>skip-networking &lt;span style="color:#75715e">#禁止tcp网络连接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>default-storage-engine&lt;span style="color:#f92672">=&lt;/span>MyISAM &lt;span style="color:#75715e">#建表默认使用M有ISAM存储引擎&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#效果&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>▶ mysql -h127.0.0.1 -uroot -p
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Enter password: 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ERROR &lt;span style="color:#ae81ff">2003&lt;/span> &lt;span style="color:#f92672">(&lt;/span>HY000&lt;span style="color:#f92672">)&lt;/span>: Can&lt;span style="color:#e6db74">&amp;#39;t connect to MySQL server on &amp;#39;&lt;/span>127.0.0.1&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> &lt;span style="color:#f92672">(&lt;/span>111&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#去除tcp网络连接限制后新建一个表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>▶ mysql -h127.0.0.1 -uroot -p &lt;span style="color:#75715e">#可以连接上&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql&amp;gt; create table default_storage_engine_demo&lt;span style="color:#f92672">(&lt;/span>i int&lt;span style="color:#f92672">)&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Query OK, &lt;span style="color:#ae81ff">0&lt;/span> rows affected &lt;span style="color:#f92672">(&lt;/span>0.01 sec&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql&amp;gt; show create table default_storage_engine_demo;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-----------------------------+----------------------------------------------------------------------------------------------------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| Table | Create Table |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-----------------------------+----------------------------------------------------------------------------------------------------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| default_storage_engine_demo | CREATE TABLE &lt;span style="color:#e6db74">`&lt;/span>default_storage_engine_demo&lt;span style="color:#e6db74">`&lt;/span> &lt;span style="color:#f92672">(&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">`&lt;/span>i&lt;span style="color:#e6db74">`&lt;/span> int&lt;span style="color:#f92672">(&lt;/span>11&lt;span style="color:#f92672">)&lt;/span> DEFAULT NULL
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">)&lt;/span> ENGINE&lt;span style="color:#f92672">=&lt;/span>MyISAM DEFAULT CHARSET&lt;span style="color:#f92672">=&lt;/span>latin1 |
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果多个配置文件都配置了某个选项，如&lt;code>/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf&lt;/code>都配置了，则以最后一个配置的为主&lt;br>
如果同一个配置文件，比如[server]组和[mysqld]组都出现了default-storage-engine配置，则以后出现的组中的配置为准&lt;br>
如果一个启动选项既在命令行中出现，又在配置文件中配置，则以命令行中的为准&lt;/p></description></item><item><title>01初识MySQL</title><link>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/01/</link><pubDate>Mon, 17 Apr 2023 11:39:48 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/MySQL/how_mysql_run/01/</guid><description>&lt;blockquote>
&lt;p>学习《MySQL是怎样运行的》，感谢作者！&lt;/p>
&lt;/blockquote>
&lt;h1 id="原文">
 原文
 &lt;a class="anchor" href="#%e5%8e%9f%e6%96%87">#&lt;/a>
&lt;/h1>
&lt;h1 id="下载与安装">
 下载与安装
 &lt;a class="anchor" href="#%e4%b8%8b%e8%bd%bd%e4%b8%8e%e5%ae%89%e8%a3%85">#&lt;/a>
&lt;/h1>
&lt;p>环境Centos7&lt;/p>
&lt;p>添加MySQL5.7仓库&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo rpm -ivh https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>解决证书问题&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看是否添加成功&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo yum repolist all | grep mysql | grep 启用 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql-connectors-community/x86_64 MySQL Connectors Community 启用: &lt;span style="color:#ae81ff">213&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql-tools-community/x86_64 MySQL Tools Community 启用: &lt;span style="color:#ae81ff">96&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql57-community/x86_64 MySQL 5.7 Community Server 启用: &lt;span style="color:#ae81ff">642&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MySQL安装&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo yum -y install mysql-community-server
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="运行与密码修改">
 运行与密码修改
 &lt;a class="anchor" href="#%e8%bf%90%e8%a1%8c%e4%b8%8e%e5%af%86%e7%a0%81%e4%bf%ae%e6%94%b9">#&lt;/a>
&lt;/h1>
&lt;p>Centos7中安装目录查看，在/usr/bin中，与Max有所不同&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>whereis mysql
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql: /usr/bin/mysql /usr/lib64/mysql /usr/share/mysql /usr/share/man/man1/mysql.1.gz
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls /usr/bin |grep mysql
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysqladmin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysqlbinlog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysqlcheck
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql_config_editor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysqld_pre_systemd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysqldump
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysqldumpslow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysqlimport
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql_install_db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql_plugin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysqlpump
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql_secure_installation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysqlshow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysqlslap
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql_ssl_rsa_setup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql_tzinfo_to_sql
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysql_upgrade
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加mysqld目录到环境变量中（这里可省略，因为mysqld默认在/usr/bin中了&lt;/p></description></item><item><title>redis集群搭建</title><link>https://lwmfjc.github.io/zh/docs/technology/Redis/redis-cluster/</link><pubDate>Thu, 13 Apr 2023 23:27:30 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Redis/redis-cluster/</guid><description>&lt;blockquote>
&lt;p>转载自https://www.cnblogs.com/Yunya-Cnblogs/p/14608937.html（添加小部分笔记）感谢作者!&lt;/p>
&lt;p>部分参考自 &lt;a href="https://www.cnblogs.com/ysocean/p/12328088.html">https://www.cnblogs.com/ysocean/p/12328088.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="基本准备">
 基本准备
 &lt;a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e5%87%86%e5%a4%87">#&lt;/a>
&lt;/h1>
&lt;p>&lt;img src="img/ly-20241212142159186.png" alt="ly-20241212142159186.png" />&lt;/p>
&lt;h2 id="架构">
 架构
 &lt;a class="anchor" href="#%e6%9e%b6%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>采用Centos7，Redis版本为6.2，架构如下：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142159238.png" alt="ly-20241212142159238" />&lt;/p>
&lt;h2 id="hosts修改">
 hosts修改
 &lt;a class="anchor" href="#hosts%e4%bf%ae%e6%94%b9">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>vim /etc/hosts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#添加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.1.101 node1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.1.102 node2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.1.103 node3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="集群准备">
 集群准备
 &lt;a class="anchor" href="#%e9%9b%86%e7%be%a4%e5%87%86%e5%a4%87">#&lt;/a>
&lt;/h2>
&lt;h3 id="对每个节点">
 对每个节点
 &lt;a class="anchor" href="#%e5%af%b9%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>下载redis并解压到 /usr/local/redis-cluster中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cd /usr/local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir redis-cluster
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar -zxvf redis* -C /usr/local/redis*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>进入redis根目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>make
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>安装完毕&lt;/p>
&lt;/li>
&lt;li>
&lt;p>hosts修改&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>vim /etc/hosts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#添加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.1.101 node1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.1.102 node2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.1.103 node3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="配置文件修改6个节点中的每一个">
 配置文件修改(6个节点中的每一个)
 &lt;a class="anchor" href="#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e4%bf%ae%e6%94%b96%e4%b8%aa%e8%8a%82%e7%82%b9%e4%b8%ad%e7%9a%84%e6%af%8f%e4%b8%80%e4%b8%aa">#&lt;/a>
&lt;/h2>
&lt;p>创建多级目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>mkdir -p /usr/local/redis_cluster/redis_63&lt;span style="color:#f92672">{&lt;/span>79,80&lt;span style="color:#f92672">}&lt;/span>/&lt;span style="color:#f92672">{&lt;/span>conf,pid,logs&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="img/ly-20241212142159275.png" alt="ly-20241212142159275" />&lt;/p>
&lt;p>编写配置文件&lt;/p></description></item><item><title>科目</title><link>https://lwmfjc.github.io/zh/docs/technology/Other/kaoshi/</link><pubDate>Thu, 13 Apr 2023 23:27:30 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Other/kaoshi/</guid><description>&lt;h2 id="科目">
 科目
 &lt;a class="anchor" href="#%e7%a7%91%e7%9b%ae">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>1022/9:00-11:30&lt;/p>
&lt;ul>
&lt;li>00024 普通逻辑 2010&lt;/li>
&lt;li>02197 概率论与数理统计（二）2018&lt;/li>
&lt;li>02318 计算机组成原理 2016&lt;/li>
&lt;li>02324 离散数学 2014&lt;/li>
&lt;li>02331 数据结构 2012&lt;/li>
&lt;li>03709 马克思主义基本原理概论 2018&lt;/li>
&lt;li>04747 Java语言程序设计（一） 2019&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>1022/14:30-17:00&lt;/p>
&lt;ul>
&lt;li>00023 高等数学（工本） 2019&lt;/li>
&lt;li>00342 高级语言程序设计（一）2017&lt;/li>
&lt;li>02326 操作系统 2017&lt;/li>
&lt;li>04730 电子技术基础（三） 2006&lt;/li>
&lt;li>04735 数据库系统原理 2018&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>1023/09:00-11:30&lt;/p>
&lt;ul>
&lt;li>02325 计算机系统结构 2012&lt;/li>
&lt;li>03708 中国近现代史纲要 2018&lt;/li>
&lt;li>04737 C++程序设计 2019&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>1023/14:30-17:00&lt;/p>
&lt;ul>
&lt;li>0015 英语（二）2012&lt;/li>
&lt;li>02333 软件工程 2011&lt;/li>
&lt;li>04741 计算机网络原理 2018&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>基本操作</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/basic/</link><pubDate>Wed, 05 Apr 2023 17:23:19 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/basic/</guid><description>&lt;h1 id="yum源替换成阿里云">
 yum源替换成阿里云
 &lt;a class="anchor" href="#yum%e6%ba%90%e6%9b%bf%e6%8d%a2%e6%88%90%e9%98%bf%e9%87%8c%e4%ba%91">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>yum install -y wget
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 备份&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 下载&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 重建缓存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum clean all
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum makecache
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="java环境搭建">
 Java环境搭建
 &lt;a class="anchor" href="#java%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>yum search java | grep jdk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install -y java-1.8.0-openjdk-devel.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># java -version 正常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># javac -version 正常&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="解压相关">
 解压相关
 &lt;a class="anchor" href="#%e8%a7%a3%e5%8e%8b%e7%9b%b8%e5%85%b3">#&lt;/a>
&lt;/h1>
&lt;p>-zxvf&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>tar -zxvf redis* -C /usr/local/redis*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># z ：表示 tar 包是被 gzip 压缩过的 (后缀是.tar.gz)，所以解压时需要用 gunzip 解压 (.tar不需要)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># x ：表示 从 tar 包中把文件提取出来&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># v ：表示 显示打包过程详细信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># f ：指定被处理的文件是什么&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 适用于参数分开使用的情况，连续无分隔参数不应该再使用（所以上面的命令不标准），&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 应该是 tar zxvf redis* -C /usr/local/redis*&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="主题修改">
 主题修改
 &lt;a class="anchor" href="#%e4%b8%bb%e9%a2%98%e4%bf%ae%e6%94%b9">#&lt;/a>
&lt;/h1>
&lt;p>oh my zsh&lt;/p></description></item><item><title>vmware上linux主机的安装和克隆</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/create_clone/</link><pubDate>Wed, 29 Mar 2023 17:23:19 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/create_clone/</guid><description>&lt;h1 id="安装">
 安装
 &lt;a class="anchor" href="#%e5%ae%89%e8%a3%85">#&lt;/a>
&lt;/h1>
&lt;h2 id="虚拟机向导">
 虚拟机向导
 &lt;a class="anchor" href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%90%91%e5%af%bc">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>典型&amp;mdash;稍后安装&amp;ndash;linux&amp;ndash;RedhatEnterpriseLinux7 64&lt;/li>
&lt;li>虚拟机名称rheCentos700&lt;/li>
&lt;li>接下来都默认即可(20G硬盘，2G内存，网络适配器(桥接模式))&lt;/li>
&lt;/ol>
&lt;h2 id="安装界面">
 安装界面
 &lt;a class="anchor" href="#%e5%ae%89%e8%a3%85%e7%95%8c%e9%9d%a2">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>日期&amp;ndash;亚洲上海，键盘&amp;ndash;汉语，语言支持&amp;ndash;简体中文(中国)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>软件安装&lt;br>
最小安装&amp;mdash;&amp;gt; 兼容性程序库+开发工具&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其他存储选项&amp;ndash;配置分区&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>/boot 1G 标准分区，文件系统ext4&lt;/li>
&lt;li>swap 2G 标准分区 ，文件系统swap&lt;/li>
&lt;li>/ 17G 标准分区，文件系统ext4&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>网络和主机名&lt;br>
打开网络+设置主机名(rheCentos700)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>完成&amp;mdash;过程中配置密码 默认用户root+其他用户ly&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="安装完成后修改ip及网关">
 安装完成后修改ip及网关
 &lt;a class="anchor" href="#%e5%ae%89%e8%a3%85%e5%ae%8c%e6%88%90%e5%90%8e%e4%bf%ae%e6%94%b9ip%e5%8f%8a%e7%bd%91%e5%85%b3">#&lt;/a>
&lt;/h2>
&lt;h3 id="centos">
 Centos
 &lt;a class="anchor" href="#centos">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;code>vi /etc/sysconfig/network-scripts/ifcfg-ens**&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改部分键值对&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>BOOTPROTO&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;static&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IPADDR&lt;span style="color:#f92672">=&lt;/span>192.168.1.100
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NETMASK&lt;span style="color:#f92672">=&lt;/span>255.255.255.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GATEWAY&lt;span style="color:#f92672">=&lt;/span>192.168.1.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DNS1&lt;span style="color:#f92672">=&lt;/span>223.5.5.5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DNS2&lt;span style="color:#f92672">=&lt;/span>223.6.6.6
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>systemctl restart network&lt;/code>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="debian">
 Debian
 &lt;a class="anchor" href="#debian">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>查看当前网卡&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>ip link
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#2: ens33: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># link/ether 00:0c:29:ed:95:f5 brd ff:ff:ff:ff:ff:ff&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># altname enp2s1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>得知网卡名为ens33&lt;/p></description></item><item><title>mysql执行计划</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0606lymysql-query-execution-plan/</link><pubDate>Tue, 14 Mar 2023 22:34:52 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0606lymysql-query-execution-plan/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>本文来自公号 MySQL 技术，JavaGuide 对其做了补充完善。原文地址：https://mp.weixin.qq.com/s/d5OowNLtXBGEAbT31sSH4g&lt;/p>
&lt;/blockquote>
&lt;p>优化 SQL 的第一步应该是读懂 SQL 的执行计划。本篇文章，我们一起来学习下 MySQL &lt;code>EXPLAIN&lt;/code> 执行计划相关知识。&lt;/p>
&lt;h2 id="什么是执行计划">
 什么是执行计划？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>执行计划&lt;/strong> 是指一条 SQL 语句在经过 &lt;strong>MySQL 查询优化器&lt;/strong> 的优化会后，具体的执行方式。&lt;/p>
&lt;p>执行计划通常用于 &lt;strong>SQL 性能分析&lt;/strong>、&lt;strong>优化&lt;/strong>等场景。通过 &lt;code>EXPLAIN&lt;/code> 的结果，可以了解到如&lt;strong>数据表的查询顺序&lt;/strong>、数据查询操作的&lt;strong>操作类型&lt;/strong>、&lt;strong>哪些索引&lt;/strong>可以被命中、哪些索引&lt;strong>实际&lt;/strong>会命中、每个数据表有多少&lt;strong>行记录被查询&lt;/strong>等信息。&lt;/p>
&lt;h2 id="如何获取执行计划">
 如何获取执行计划？
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e8%8e%b7%e5%8f%96%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 提交准备数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">SET&lt;/span> NAMES utf8mb4;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SET&lt;/span> FOREIGN_KEY_CHECKS &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- ----------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- Table structure for dept_emp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- ----------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>emp_no&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">varchar&lt;/span>(&lt;span style="color:#ae81ff">128&lt;/span>) &lt;span style="color:#66d9ef">CHARACTER&lt;/span> &lt;span style="color:#66d9ef">SET&lt;/span> utf8mb4 &lt;span style="color:#66d9ef">COLLATE&lt;/span> utf8mb4_0900_ai_ci &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>other1&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">varchar&lt;/span>(&lt;span style="color:#ae81ff">255&lt;/span>) &lt;span style="color:#66d9ef">CHARACTER&lt;/span> &lt;span style="color:#66d9ef">SET&lt;/span> utf8mb4 &lt;span style="color:#66d9ef">COLLATE&lt;/span> utf8mb4_0900_ai_ci &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>other2&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">varchar&lt;/span>(&lt;span style="color:#ae81ff">255&lt;/span>) &lt;span style="color:#66d9ef">CHARACTER&lt;/span> &lt;span style="color:#66d9ef">SET&lt;/span> utf8mb4 &lt;span style="color:#66d9ef">COLLATE&lt;/span> utf8mb4_0900_ai_ci &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>) &lt;span style="color:#66d9ef">USING&lt;/span> BTREE,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">INDEX&lt;/span> &lt;span style="color:#f92672">`&lt;/span>index_emp_no&lt;span style="color:#f92672">`&lt;/span>(&lt;span style="color:#f92672">`&lt;/span>emp_no&lt;span style="color:#f92672">`&lt;/span>) &lt;span style="color:#66d9ef">USING&lt;/span> BTREE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) &lt;span style="color:#66d9ef">ENGINE&lt;/span> &lt;span style="color:#f92672">=&lt;/span> InnoDB &lt;span style="color:#66d9ef">CHARACTER&lt;/span> &lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#f92672">=&lt;/span> utf8mb4 &lt;span style="color:#66d9ef">COLLATE&lt;/span> &lt;span style="color:#f92672">=&lt;/span> utf8mb4_0900_ai_ci ROW_FORMAT &lt;span style="color:#f92672">=&lt;/span> Dynamic;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- ----------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- Records of dept_emp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- ----------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">VALUES&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;a1&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o11&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;012&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">VALUES&lt;/span> (&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;a2&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o21&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o22&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">VALUES&lt;/span> (&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;a3&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o31&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o32&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">VALUES&lt;/span> (&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;a4&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o41&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o42&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#f92672">`&lt;/span>dept_emp&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">VALUES&lt;/span> (&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;a5&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o51&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;o52&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SET&lt;/span> FOREIGN_KEY_CHECKS &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MySQL 为我们提供了 &lt;code>EXPLAIN&lt;/code> 命令，来获取执行计划的相关信息。&lt;/p></description></item><item><title>sql常见面试题总结01</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/ly0503lysql-question-01/</link><pubDate>Sun, 12 Mar 2023 17:53:18 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/ly0503lysql-question-01/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>题目来源于：&lt;a href="https://www.nowcoder.com/exam/oj?page=1&amp;amp;tab=SQL%e7%af%87&amp;amp;topicId=298">牛客题霸 - SQL 必知必会&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="检索数据">
 检索数据
 &lt;a class="anchor" href="#%e6%a3%80%e7%b4%a2%e6%95%b0%e6%8d%ae">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>select&lt;/code> 用于从数据库中查询数据。&lt;/p>
&lt;h3 id="从-customers-表中检索所有的-id">
 从 Customers 表中检索所有的 ID
 &lt;a class="anchor" href="#%e4%bb%8e-customers-%e8%a1%a8%e4%b8%ad%e6%a3%80%e7%b4%a2%e6%89%80%e6%9c%89%e7%9a%84-id">#&lt;/a>
&lt;/h3>
&lt;p>现有表 &lt;code>Customers&lt;/code> 如下：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>cust_id&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>A&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>B&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>C&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>编写 SQL 语句，从 &lt;code>Customers&lt;/code> 表中检索所有的 &lt;code>cust_id&lt;/code>。&lt;/p>
&lt;p>答案：&lt;/p>
&lt;pre tabindex="0">&lt;code>select cust_id
from Customers;
&lt;/code>&lt;/pre>&lt;h3 id="检索并列出已订购产品的清单">
 检索并列出已订购产品的清单
 &lt;a class="anchor" href="#%e6%a3%80%e7%b4%a2%e5%b9%b6%e5%88%97%e5%87%ba%e5%b7%b2%e8%ae%a2%e8%b4%ad%e4%ba%a7%e5%93%81%e7%9a%84%e6%b8%85%e5%8d%95">#&lt;/a>
&lt;/h3>
&lt;p>表 &lt;code>OrderItems&lt;/code> 含有非空的列 &lt;code>prod_id&lt;/code> 代表商品 id，包含了所有已订购的商品（有些已被订购多次）。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>prod_id&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>a1&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>a2&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>a3&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>a4&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>a5&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>a6&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>a7&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>编写 SQL 语句，检索并列出所有已订购商品（&lt;code>prod_id&lt;/code>）的去重后的清单。&lt;/p>
&lt;p>答案：&lt;/p>
&lt;pre tabindex="0">&lt;code>select distinct prod_id
from OrderItems;
&lt;/code>&lt;/pre>&lt;p>知识点：&lt;code>distinct&lt;/code> 用于返回列中的唯一不同值。&lt;/p>
&lt;h3 id="检索所有列">
 检索所有列
 &lt;a class="anchor" href="#%e6%a3%80%e7%b4%a2%e6%89%80%e6%9c%89%e5%88%97">#&lt;/a>
&lt;/h3>
&lt;p>现在有 &lt;code>Customers&lt;/code> 表（表中含有列 &lt;code>cust_id&lt;/code> 代表客户 id，&lt;code>cust_name&lt;/code> 代表客户姓名）&lt;/p></description></item><item><title>sql语法基础知识总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/ly0504lysql-syntax-summary/</link><pubDate>Sun, 12 Mar 2023 17:52:48 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/ly0504lysql-syntax-summary/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>本文整理完善自下面这两份资料：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://juejin.cn/post/6844903790571700231">SQL 语法速成手册&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.begtut.com/mysql/mysql-tutorial.html">MySQL 超全教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="基本概念">
 基本概念
 &lt;a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">#&lt;/a>
&lt;/h2>
&lt;h3 id="数据库术语">
 数据库术语
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e6%9c%af%e8%af%ad">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;code>数据库（database）&lt;/code> - 保存有组织的数据的容器（通常是一个文件或一组文件）。&lt;/li>
&lt;li>&lt;code>数据表（table）&lt;/code> - 某种特定类型数据的结构化清单。&lt;/li>
&lt;li>&lt;code>模式（schema）&lt;/code> - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。&lt;/li>
&lt;li>&lt;code>列（column）&lt;/code> - 表中的一个字段。所有表都是由一个或多个列组成的。&lt;/li>
&lt;li>&lt;code>行（row）&lt;/code> - 表中的一个记录。&lt;/li>
&lt;li>&lt;code>主键（primary key）&lt;/code> - 一列（或一组列），其值能够唯一标识表中每一行。&lt;/li>
&lt;/ul>
&lt;h3 id="sql-语法">
 SQL 语法
 &lt;a class="anchor" href="#sql-%e8%af%ad%e6%b3%95">#&lt;/a>
&lt;/h3>
&lt;p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。&lt;/p>
&lt;h4 id="sql-语法结构">
 SQL 语法结构
 &lt;a class="anchor" href="#sql-%e8%af%ad%e6%b3%95%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h4>
&lt;p>&lt;img src="img/ly-20241212141857484.jpg" alt="img" />&lt;/p>
&lt;p>SQL 语法结构包括：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>子句&lt;/code>&lt;/strong> - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）&lt;/li>
&lt;li>&lt;strong>&lt;code>表达式&lt;/code>&lt;/strong> - 可以产生任何标量值，或由列和行的数据库表&lt;/li>
&lt;li>&lt;strong>&lt;code>谓词&lt;/code>&lt;/strong> - 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。&lt;/li>
&lt;li>&lt;strong>&lt;code>查询&lt;/code>&lt;/strong> - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。&lt;/li>
&lt;li>&lt;strong>&lt;code>语句&lt;/code>&lt;/strong> - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。&lt;/li>
&lt;/ul>
&lt;h4 id="sql-语法要点">
 SQL 语法要点
 &lt;a class="anchor" href="#sql-%e8%af%ad%e6%b3%95%e8%a6%81%e7%82%b9">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>SQL 语句不区分大小写&lt;/strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如：&lt;code>SELECT&lt;/code> 与 &lt;code>select&lt;/code> 、&lt;code>Select&lt;/code> 是相同的。&lt;/li>
&lt;li>&lt;strong>多条 SQL 语句必须以分号（&lt;code>;&lt;/code>）分隔&lt;/strong>。&lt;/li>
&lt;li>处理 SQL 语句时，&lt;strong>所有空格都被忽略&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>SQL 语句可以写成一行，也可以分写为多行。&lt;/p></description></item><item><title>redis问题图解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/diagram/</link><pubDate>Mon, 27 Feb 2023 22:11:02 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/diagram/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>
&lt;p>主从复制原理&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141920958.png" alt="主从复制原理" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>哨兵模式(简单)&lt;br>
&lt;img src="img/ly-20241212141921249.png" alt="ly-20241212141921249" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>哨兵模式详解&lt;/p>
&lt;blockquote>
&lt;p>先配置&lt;strong>主从模式&lt;/strong>，再配置&lt;strong>哨兵模式&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>所有的哨兵 sentinel.conf 都是配置为监听master&amp;ndash;&amp;gt; 192.168.14.101，如果主机宕机，sentinel.conf 中的配置也会自动更改为选举后的&lt;img src="img/ly-20241212141921408.png" alt="ly-20241212141921408" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Java客户端连接原理&lt;/p>
&lt;blockquote>
&lt;p>客户端是和Sentinel来进行交互的,通过Sentinel来获取真正的Redis节点信息,然后来操作.实际工作时,Sentinel 内部维护了一个主题队列,用来保存Redis的节点信息,并实时更新,客户端订阅了这个主题,然后实时的去获取这个队列的Redis节点信息.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">代码相对比较简单
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">**/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//1.设置sentinel 各个节点集合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> sentinelSet &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashSet&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinelSet.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;192.168.14.101:26379&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinelSet.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;192.168.14.102:26380&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sentinelSet.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;192.168.14.103:26381&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//2.设置jedispool 连接池配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>JedisPoolConfig config &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> JedisPoolConfig();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>config.&lt;span style="color:#a6e22e">setMaxTotal&lt;/span>(10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>config.&lt;span style="color:#a6e22e">setMaxWaitMillis&lt;/span>(1000);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//3.设置mastername,sentinelNode集合,配置文件,Redis登录密码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>JedisSentinelPool jedisSentinelPool &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> JedisSentinelPool(&lt;span style="color:#e6db74">&amp;#34;mymaster&amp;#34;&lt;/span>,sentinelSet,config,&lt;span style="color:#e6db74">&amp;#34;123&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Jedis jedis &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jedis &lt;span style="color:#f92672">=&lt;/span> jedisSentinelPool.&lt;span style="color:#a6e22e">getResource&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//获取Redis中key=hello的值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String value &lt;span style="color:#f92672">=&lt;/span> jedis.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e.&lt;span style="color:#a6e22e">printStackTrace&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(jedis &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jedis.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;p>&lt;img src="img/ly-20241212141921579.png" alt="ly-20241212141921579" />&lt;/p></description></item><item><title>3种常用的缓存读写策略详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/ly0703ly3-commonly-used-cache-read-and-write-strategies/</link><pubDate>Fri, 24 Feb 2023 09:31:52 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/ly0703ly3-commonly-used-cache-read-and-write-strategies/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>看到很多小伙伴简历上写了“&lt;strong>熟练使用缓存&lt;/strong>”，但是被我问到“&lt;strong>缓存常用的3种读写策略&lt;/strong>”的时候却一脸懵逼。&lt;/p>
&lt;p>在我看来，造成这个问题的原因是我们在学习 Redis 的时候，可能只是简单了写一些 Demo，并没有去关注缓存的读写策略，或者说压根不知道这回事。&lt;/p>
&lt;p>但是，搞懂3种常见的缓存读写策略对于实际工作中使用缓存以及面试中被问到缓存都是非常有帮助的！&lt;/p>
&lt;p>&lt;strong>下面介绍到的三种模式各有优劣，不存在最佳模式，根据具体的业务场景选择适合自己的缓存读写模式。&lt;/strong>&lt;/p>
&lt;h3 id="cache-aside-pattern旁路缓存模式">
 Cache Aside Pattern（旁路缓存模式）
 &lt;a class="anchor" href="#cache-aside-pattern%e6%97%81%e8%b7%af%e7%bc%93%e5%ad%98%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。&lt;/strong>&lt;/p>
&lt;p>Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是&lt;strong>以 db 的结果为准&lt;/strong>。&lt;/p>
&lt;p>下面我们来看一下这个策略模式下的缓存读写步骤。&lt;/p>
&lt;p>&lt;strong>写&lt;/strong> ：&lt;/p>
&lt;ul>
&lt;li>先更新 db&lt;/li>
&lt;li>然后直接删除 cache 。&lt;/li>
&lt;/ul>
&lt;p>简单画了一张图帮助大家理解写的步骤。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141916648.jpg" alt="img" />&lt;/p>
&lt;p>&lt;strong>读&lt;/strong> :&lt;/p>
&lt;ul>
&lt;li>从 cache 中读取数据，读取到就直接返回&lt;/li>
&lt;li>cache 中读取不到的话，就从 db 中读取数据返回&lt;/li>
&lt;li>再把数据放到 cache 中。&lt;/li>
&lt;/ul>
&lt;p>简单画了一张图帮助大家理解读的步骤。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141916935.png" alt="ly-20241212141916935" />&lt;/p>
&lt;p>你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。&lt;/p>
&lt;p>比如说面试官很可能会追问：“&lt;strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？&lt;/strong>”&lt;/p>
&lt;p>&lt;strong>答案：&lt;/strong> 那肯定是不行的！因为这样可能会造成 &lt;strong>数据库（db）和缓存（Cache）数据不一致&lt;/strong>的问题。&lt;/p>
&lt;p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。&lt;/p>
&lt;p>这个过程可以简单描述为：&lt;/p>
&lt;blockquote>
&lt;p>请求 1 先把 cache 中的 A 数据删除 -&amp;gt; 请求 2 从 db 中读取数据【&lt;strong>此时请求2把脏数据(对于请求1来说是)更新到缓存去了&lt;/strong>】-&amp;gt;请求 1 再把 db 中的 A 数据更新，即请求1的操作非原子&lt;/p></description></item><item><title>redis内存碎片</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/ly0704lyredis-memory-fragmentation/</link><pubDate>Fri, 24 Feb 2023 09:26:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/ly0704lyredis-memory-fragmentation/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="什么是内存碎片">
 什么是内存碎片?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87">#&lt;/a>
&lt;/h2>
&lt;p>你可以将内存碎片简单地理解为那些&lt;strong>不可用的空闲内存&lt;/strong>。&lt;/p>
&lt;p>举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141917438.png" alt="ly-20241212141917438" />&lt;/p>
&lt;p>Redis 内存碎片虽然不会影响 Redis 性能，但是会&lt;strong>增加内存消耗&lt;/strong>。&lt;/p>
&lt;h2 id="为什么会有-redis-内存碎片">
 为什么会有 Redis 内存碎片?
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e6%9c%89-redis-%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87">#&lt;/a>
&lt;/h2>
&lt;p>Redis 内存碎片产生比较常见的 2 个原因：&lt;/p>
&lt;p>&lt;strong>1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。&lt;/strong>&lt;/p>
&lt;p>以下是这段 Redis 官方的原话：&lt;/p>
&lt;blockquote>
&lt;p>To store user keys, Redis allocates at most as much memory as the &lt;code>maxmemory&lt;/code> setting enables (however there are small extra allocations possible).&lt;/p>
&lt;/blockquote>
&lt;p>Redis 使用 &lt;code>zmalloc&lt;/code> 方法(Redis 自己实现的内存分配方法)进行内存分配的时候，除了要分配 &lt;code>size&lt;/code> 大小的内存之外，还会多分配 &lt;code>PREFIX_SIZE&lt;/code> 大小的内存。&lt;/p>
&lt;p>&lt;code>zmalloc&lt;/code> 方法源码如下（源码地址：https://github.com/antirez/redis-tools/blob/master/zmalloc.c）：&lt;/p>
&lt;pre tabindex="0">&lt;code>void *zmalloc(size_t size) {
 // 分配指定大小的内存
 void *ptr = malloc(size+PREFIX_SIZE);
 if (!ptr) zmalloc_oom_handler(size);
#ifdef HAVE_MALLOC_SIZE
 update_zmalloc_stat_alloc(zmalloc_size(ptr));
 return ptr;
#else
 *((size_t*)ptr) = size;
 update_zmalloc_stat_alloc(size+PREFIX_SIZE);
 return (char*)ptr+PREFIX_SIZE;
#endif
}
&lt;/code>&lt;/pre>&lt;p>另外，Redis 可以使用&lt;strong>多种内存分配器&lt;/strong>来分配内存（ &lt;strong>libc&lt;/strong>、&lt;strong>jemalloc&lt;/strong>、&lt;strong>tcmalloc&lt;/strong>），默认使用 &lt;a href="https://github.com/jemalloc/jemalloc">jemalloc&lt;/a>，而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节&amp;hellip;&amp;hellip;）来分配内存的。jemalloc 划分的内存单元如下图所示：&lt;/p></description></item><item><title>redis特殊数据结构</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/ly0702lyredis-spec-data-structure/</link><pubDate>Thu, 23 Feb 2023 23:02:58 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/ly0702lyredis-spec-data-structure/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>除了 5 种基本的数据结构之外，Redis 还支持 3 种特殊的数据结构 ：&lt;strong>Bitmap&lt;/strong>、&lt;strong>HyperLogLog&lt;/strong>、&lt;strong>GEO&lt;/strong>。&lt;/p>
&lt;h2 id="bitmap">
 Bitmap
 &lt;a class="anchor" href="#bitmap">#&lt;/a>
&lt;/h2>
&lt;h3 id="介绍">
 介绍
 &lt;a class="anchor" href="#%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h3>
&lt;p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, &lt;strong>只需要一个 bit 位来表示某个元素对应的值&lt;/strong>或者&lt;strong>状态&lt;/strong>，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。&lt;/p>
&lt;p>你可以将 Bitmap 看作是一个&lt;strong>存储二进制数字（0 和 1）的数组&lt;/strong>，数组中每个元素的下标叫做 offset（偏移量）。&lt;/p>
&lt;p>&lt;a href="https://camo.githubusercontent.com/1c1ce8351556fe9727cadfd385fdbd6f449d92a174bbd65db5383791fec05a13/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f64617461626173652f72656469732f696d6167652d32303232303732303139343135343133332e706e67">&lt;img src="https://camo.githubusercontent.com/1c1ce8351556fe9727cadfd385fdbd6f449d92a174bbd65db5383791fec05a13/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f64617461626173652f72656469732f696d6167652d32303232303732303139343135343133332e706e67" alt="img" />&lt;/a>&lt;/p>
&lt;h3 id="常用命令">
 常用命令
 &lt;a class="anchor" href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4">#&lt;/a>
&lt;/h3>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>命令&lt;/th>
 &lt;th>介绍&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>SETBIT key offset value&lt;/td>
 &lt;td>设置指定 offset 位置的值&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>GETBIT key offset&lt;/td>
 &lt;td>获取指定 offset 位置的值&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>BITCOUNT key start end&lt;/td>
 &lt;td>获取 start 和 end 之前值为 1 的元素个数&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>BITOP operation destkey key1 key2 &amp;hellip;&lt;/td>
 &lt;td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>Bitmap 基本操作演示&lt;/strong> ：&lt;/p></description></item><item><title>redis基本数据结构</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/ly0701lyredis-base-data-structures/</link><pubDate>Thu, 23 Feb 2023 14:22:58 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/ly0701lyredis-base-data-structures/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>Redis 共有 5 种基本数据结构：&lt;strong>String&lt;/strong>（字符串）、&lt;strong>List&lt;/strong>（列表）、&lt;strong>Set&lt;/strong>（集合）、&lt;strong>Hash&lt;/strong>（散列）、&lt;strong>Zset&lt;/strong>（有序集合）。&lt;/p>
&lt;p>这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（&lt;strong>SDS&lt;/strong>）、&lt;strong>LinkedList&lt;/strong>（双向链表）、&lt;strong>Hash Table&lt;/strong>（哈希表）、&lt;strong>SkipList&lt;/strong>（跳跃表）、&lt;strong>Intset&lt;/strong>（整数集合）、&lt;strong>ZipList&lt;/strong>（压缩列表）、&lt;strong>QuickList&lt;/strong>（快速列表）。&lt;/p>
&lt;p>Redis 基本数据结构的底层数据结构实现如下：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>String&lt;/th>
 &lt;th>List&lt;/th>
 &lt;th>Hash&lt;/th>
 &lt;th>Set&lt;/th>
 &lt;th>Zset&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>SDS&lt;/td>
 &lt;td>LinkedList/ZipList/QuickList&lt;/td>
 &lt;td>Hash Table、ZipList&lt;/td>
 &lt;td>ZipList、Intset&lt;/td>
 &lt;td>ZipList、SkipList&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。&lt;/p>
&lt;p>你可以在 Redis 官网上找到 Redis 数据结构非常详细的介绍：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://redis.com/redis-enterprise/data-structures/">Redis Data Structures&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://redis.io/docs/manual/data-types/data-types-tutorial/">Redis Data types tutorial&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>未来随着 Redis 新版本的发布，可能会有新的数据结构出现，通过查阅 Redis 官网对应的介绍，你总能获取到最靠谱的信息。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141914862.png" alt="ly-20241212141914862" />&lt;/p>
&lt;h2 id="string字符串">
 String（字符串）
 &lt;a class="anchor" href="#string%e5%ad%97%e7%ac%a6%e4%b8%b2">#&lt;/a>
&lt;/h2>
&lt;h3 id="介绍">
 介绍
 &lt;a class="anchor" href="#%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h3>
&lt;p>String 是 Redis 中最简单同时也是最常用的一个数据结构。&lt;/p></description></item><item><title>redis面试题02</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/ly0706lyredis-questions-02/</link><pubDate>Thu, 23 Feb 2023 11:16:04 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/ly0706lyredis-questions-02/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="redis-事务">
 Redis 事务
 &lt;a class="anchor" href="#redis-%e4%ba%8b%e5%8a%a1">#&lt;/a>
&lt;/h2>
&lt;h3 id="如何使用-redis-事务">
 如何使用 Redis 事务？
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-redis-%e4%ba%8b%e5%8a%a1">#&lt;/a>
&lt;/h3>
&lt;p>Redis 可以通过 &lt;strong>&lt;code>MULTI&lt;/code>，&lt;code>EXEC&lt;/code>，&lt;code>DISCARD&lt;/code> 和 &lt;code>WATCH&lt;/code>&lt;/strong> 等命令来实现事务(transaction)功能。&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;gt; MULTI
OK
&amp;gt; SET PROJECT &amp;#34;JavaGuide&amp;#34;
QUEUED
&amp;gt; GET PROJECT
QUEUED
&amp;gt; EXEC
1) OK
2) &amp;#34;JavaGuide&amp;#34;
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://redis.io/commands/multi">&lt;code>MULTI&lt;/code>&lt;/a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 &lt;a href="https://redis.io/commands/exec">&lt;code>EXEC&lt;/code>&lt;/a> 命令后，再执行所有的命令。&lt;/p>
&lt;p>这个过程是这样的：&lt;/p>
&lt;ol>
&lt;li>开始事务（&lt;code>MULTI&lt;/code>）；&lt;/li>
&lt;li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；&lt;/li>
&lt;li>执行事务(&lt;code>EXEC&lt;/code>)。&lt;/li>
&lt;/ol>
&lt;p>你也可以通过 &lt;a href="https://redis.io/commands/discard">&lt;code>DISCARD&lt;/code>&lt;/a> 命令取消一个事务，它会清空事务队列中保存的所有命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&amp;gt; MULTI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; SET PROJECT &lt;span style="color:#e6db74">&amp;#34;JavaGuide&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>QUEUED
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; GET PROJECT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>QUEUED
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; DISCARD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OK
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以通过&lt;a href="https://redis.io/commands/watch">&lt;code>WATCH&lt;/code>&lt;/a> 命令监听指定的 Key，当调用 &lt;code>EXEC&lt;/code> 命令执行事务时，如果一个被 &lt;code>WATCH&lt;/code> 命令监视的 Key 被 &lt;strong>其他客户端/Session&lt;/strong> 修改的话，整个事务都不会被执行。&lt;/p></description></item><item><title>redis面试题01</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/ly0705lyredis-questions-01/</link><pubDate>Wed, 22 Feb 2023 11:31:11 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/Redis/ly0705lyredis-questions-01/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="redis-基础">
 Redis 基础
 &lt;a class="anchor" href="#redis-%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是-redis">
 什么是 Redis？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-redis">#&lt;/a>
&lt;/h3>
&lt;p>&lt;a href="https://redis.io/">Redis&lt;/a> 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在&lt;strong>内存&lt;/strong>中的（内存数据库），&lt;strong>读写&lt;/strong>速度非常&lt;strong>快&lt;/strong>，被广泛应用于&lt;strong>缓存方向&lt;/strong>。并且，Redis 存储的是 &lt;strong>KV 键值对&lt;/strong>数据。&lt;/p>
&lt;p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 &lt;strong>String&lt;/strong>、&lt;strong>Hash&lt;/strong>、【&lt;strong>List&lt;/strong>、&lt;strong>Set&lt;/strong>、】&lt;strong>Sorted Set&lt;/strong>、&lt;strong>Bitmap&lt;/strong>）。并且，Redis 还支持&lt;strong>事务&lt;/strong> 、&lt;strong>持久化&lt;/strong>、&lt;strong>Lua 脚本&lt;/strong>、多种开箱即用的&lt;strong>集群&lt;/strong>方案（&lt;strong>Redis Sentinel&lt;/strong>、&lt;strong>Redis Cluster&lt;/strong>）。&lt;/p>
&lt;p>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。&lt;/p>
&lt;p>个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的&lt;a href="https://try.redis.io/">在线 Redis 环境&lt;/a>来实际体验 Redis。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141918257.png" alt="ly-20241212141918257" />&lt;/p>
&lt;p>全世界有非常多的网站使用到了 Redis ，&lt;a href="https://techstacks.io/">techstacks.io&lt;/a> 专门维护了一个&lt;a href="https://techstacks.io/tech/redis">使用 Redis 的热门站点列表&lt;/a> ，感兴趣的话可以看看。&lt;/p>
&lt;h3 id="redis-为什么这么快">
 Redis 为什么这么快？
 &lt;a class="anchor" href="#redis-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%99%e4%b9%88%e5%bf%ab">#&lt;/a>
&lt;/h3>
&lt;p>Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：&lt;/p>
&lt;ul>
&lt;li>Redis 基于&lt;strong>内存&lt;/strong>，内存的访问速度是磁盘的上千倍；&lt;/li>
&lt;li>Redis &lt;strong>基于 Reactor 模式&lt;/strong>设计开发了一套&lt;strong>高效的事件处理模型&lt;/strong>，主要是&lt;strong>单线程事件循环&lt;/strong>和 &lt;strong>IO 多路复用&lt;/strong>（Redis 线程模式后面会详细介绍到）；&lt;/li>
&lt;li>Redis 内置了多种&lt;strong>优化过后的数据结构&lt;/strong>实现，性能非常高。&lt;/li>
&lt;/ul>
&lt;p>下面这张图片总结的挺不错的，分享一下，出自 &lt;a href="https://twitter.com/alexxubyte/status/1498703822528544770">Why is Redis so fast?&lt;/a> 。&lt;/p></description></item><item><title>web-real-time-message-push</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/web-real-time-message-push/</link><pubDate>Tue, 21 Feb 2023 09:26:53 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/web-real-time-message-push/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>原文地址：https://juejin.cn/post/7122014462181113887，JavaGuide 对本文进行了完善总结。&lt;/p>
&lt;/blockquote>
&lt;p>我有一个朋友做了一个小破站，现在要实现一个站内信 Web 消息推送的功能，对，就是下图这个小红点，一个很常用的功能。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142025733.png" alt="站内信 Web 消息推送" />&lt;/p>
&lt;p>不过他还没想好用什么方式做，这里我帮他整理了一下几种方案，并简单做了实现。&lt;/p>
&lt;h2 id="什么是消息推送-什么是消息推送">
 &lt;a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%b6%88%e6%81%af%e6%8e%a8%e9%80%81">#&lt;/a> 什么是消息推送？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%b6%88%e6%81%af%e6%8e%a8%e9%80%81-%e4%bb%80%e4%b9%88%e6%98%af%e6%b6%88%e6%81%af%e6%8e%a8%e9%80%81">#&lt;/a>
&lt;/h2>
&lt;p>推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。&lt;/p>
&lt;p>消息推送通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备 APP 进行的主动消息推送。&lt;/p>
&lt;p>消息推送一般又分为 Web 端消息推送和移动端消息推送。&lt;/p>
&lt;p>移动端消息推送示例 ：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142025900.png" alt="移动端消息推送示例" />&lt;/p>
&lt;p>Web 端消息推送示例：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142026025.png" alt="Web 端消息推送示例" />&lt;/p>
&lt;p>在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，&lt;strong>只要触发某个事件（主动分享了资源或者后台主动推送消息）&lt;/strong>，&lt;strong>Web 页面的通知小红点就会实时的 &lt;code>+1&lt;/code>&lt;/strong> 就可以了。&lt;/p>
&lt;p>通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142026150.png" alt="ly-20241212142026150" />&lt;/p>
&lt;p>消息推送无非是推（push）和拉（pull）两种形式，下边我们逐个了解下。&lt;/p>
&lt;h2 id="消息推送常见方案-消息推送常见方案">
 &lt;a href="#%e6%b6%88%e6%81%af%e6%8e%a8%e9%80%81%e5%b8%b8%e8%a7%81%e6%96%b9%e6%a1%88">#&lt;/a> 消息推送常见方案
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e6%8e%a8%e9%80%81%e5%b8%b8%e8%a7%81%e6%96%b9%e6%a1%88-%e6%b6%88%e6%81%af%e6%8e%a8%e9%80%81%e5%b8%b8%e8%a7%81%e6%96%b9%e6%a1%88">#&lt;/a>
&lt;/h2>
&lt;h3 id="短轮询-短轮询">
 &lt;a href="#%e7%9f%ad%e8%bd%ae%e8%af%a2">#&lt;/a> 短轮询
 &lt;a class="anchor" href="#%e7%9f%ad%e8%bd%ae%e8%af%a2-%e7%9f%ad%e8%bd%ae%e8%af%a2">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>轮询(polling)&lt;/strong> 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为&lt;strong>短轮询&lt;/strong>和&lt;strong>长轮询&lt;/strong>。&lt;/p>
&lt;p>短轮询很好理解，&lt;strong>指定的时间间隔&lt;/strong>，&lt;strong>由浏览器向服务器发出 HTTP 请求&lt;/strong>，&lt;strong>服务器实时返回未读消息数据给客户端，浏览器再做渲染显示&lt;/strong>。&lt;/p>
&lt;p>一个简单的 JS 定时器就可以搞定，&lt;strong>每秒钟请求一次未读消息数接口&lt;/strong>，返回的数据展示即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">setInterval&lt;/span>(() &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 方法请求
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">messageCount&lt;/span>().&lt;span style="color:#a6e22e">then&lt;/span>((&lt;span style="color:#a6e22e">res&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">code&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">messageCount&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}, &lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，&lt;strong>由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求&lt;/strong>，势必会对服务端造成很大压力，浪费带宽和服务器资源。&lt;/p>
&lt;h3 id="长轮询-长轮询">
 &lt;a href="#%e9%95%bf%e8%bd%ae%e8%af%a2">#&lt;/a> 长轮询
 &lt;a class="anchor" href="#%e9%95%bf%e8%bd%ae%e8%af%a2-%e9%95%bf%e8%bd%ae%e8%af%a2">#&lt;/a>
&lt;/h3>
&lt;p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如 Nacos 和 Apollo 配置中心，消息队列 Kafka、RocketMQ 中都有用到长轮询。&lt;/p></description></item><item><title>Java定时任务详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/schedule-task/</link><pubDate>Tue, 21 Feb 2023 09:17:31 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/schedule-task/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="为什么需要定时任务">
 为什么需要定时任务？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1">#&lt;/a>
&lt;/h2>
&lt;p>我们来看一下几个非常常见的业务场景：&lt;/p>
&lt;ol>
&lt;li>某系统&lt;strong>凌晨要进行数据备份&lt;/strong>。&lt;/li>
&lt;li>某电商平台，用户&lt;strong>下单半个小时未支付的情况下需要自动取消&lt;/strong>订单。&lt;/li>
&lt;li>某媒体聚合平台，&lt;strong>每 10 分钟动态抓取某某网站的数据&lt;/strong>为自己所用。&lt;/li>
&lt;li>某博客平台，支持&lt;strong>定时发送文章&lt;/strong>。&lt;/li>
&lt;li>某基金平台，&lt;strong>每晚定时计算用户当日收益情况并推送给用户最新的数据&lt;/strong>。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ol>
&lt;p>这些场景往往都要求我们在某个特定的时间去做某个事情。&lt;/p>
&lt;h2 id="单机定时任务技术选型">
 单机定时任务技术选型
 &lt;a class="anchor" href="#%e5%8d%95%e6%9c%ba%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%e6%8a%80%e6%9c%af%e9%80%89%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="timer">
 Timer
 &lt;a class="anchor" href="#timer">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>java.util.Timer&lt;/code>是 JDK 1.3 开始就已经支持的一种定时任务的实现方式。&lt;/p>
&lt;p>&lt;code>Timer&lt;/code> 内部使用一个叫做 &lt;code>TaskQueue&lt;/code> 的类存放定时任务，它是一个&lt;strong>基于最小堆实现的优先级队列&lt;/strong>。&lt;code>TaskQueue&lt;/code> 会按照&lt;strong>任务距离下一次执行时间的大小&lt;/strong>将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次&lt;strong>只需要取出堆顶的任务&lt;/strong>运行即可！&lt;/p>
&lt;p>&lt;code>Timer&lt;/code> 使用起来比较简单，通过下面的方式我们就能创建一个 1s 之后执行的定时任务。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 示例代码：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TimerTask task &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> TimerTask() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;当前时间: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Date() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;线程名称: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Thread.&lt;span style="color:#a6e22e">currentThread&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;当前时间: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Date() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;线程名称: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Thread.&lt;span style="color:#a6e22e">currentThread&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Timer timer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Timer(&lt;span style="color:#e6db74">&amp;#34;Timer&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> delay &lt;span style="color:#f92672">=&lt;/span> 1000L;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>timer.&lt;span style="color:#a6e22e">schedule&lt;/span>(task, delay);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//输出：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>当前时间: Fri May 28 15:18:47 CST 2021n线程名称: main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>当前时间: Fri May 28 15:18:48 CST 2021n线程名称: Timer
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不过其缺陷较多，比如一个 &lt;code>Timer&lt;/code> 一个线程，这就导致 &lt;code>Timer&lt;/code> 的任务的执行&lt;strong>只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止（&lt;code>Timer&lt;/code> 只捕获了 &lt;code>InterruptedException&lt;/code> ）&lt;/strong>。&lt;/p></description></item><item><title>敏感词过滤方案总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly06ly_sentive-words-filter/</link><pubDate>Tue, 21 Feb 2023 08:57:26 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly06ly_sentive-words-filter/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>系统需要对用户输入的文本进行&lt;strong>敏感词过滤&lt;/strong>如色情、政治、暴力相关的词汇。&lt;/p>
&lt;p>敏感词过滤用的使用比较多的 &lt;strong>Trie 树算法&lt;/strong> 和 &lt;strong>DFA 算法&lt;/strong>。&lt;/p>
&lt;h2 id="算法实现">
 算法实现
 &lt;a class="anchor" href="#%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">#&lt;/a>
&lt;/h2>
&lt;h3 id="trie-树">
 Trie 树
 &lt;a class="anchor" href="#trie-%e6%a0%91">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>Trie 树&lt;/strong> 也称为&lt;strong>字典树&lt;/strong>、&lt;strong>单词查找树&lt;/strong>，&lt;strong>哈系树&lt;/strong>(&lt;strong>这里是不是写错了，哈希树？&lt;/strong>)的一种变种，通常被用于&lt;strong>字符串匹配&lt;/strong>，用来解决在一组字符串集合中快速查找某个字符串的问题。像&lt;strong>浏览器搜索的关键词提示&lt;/strong>一般就是基于 Trie 树来做的。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142025084.png" alt="img" />&lt;/p>
&lt;p>假如我们的敏感词库中有以下敏感词：&lt;/p>
&lt;ul>
&lt;li>高清有码&lt;/li>
&lt;li>高清 AV&lt;/li>
&lt;li>东京冷&lt;/li>
&lt;li>东京热&lt;/li>
&lt;/ul>
&lt;p>我们构造出来的敏感词 Trie 树就是下面这样的：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142025337.png" alt="ly-20241212142025337" />&lt;/p>
&lt;p>当我们要查找对应的字符串“东京热”的话，我们会把这个字符串切割成单个的字符“东”、“京”、“热”，然后我们&lt;strong>从 Trie 树的根节点开始匹配&lt;/strong>。&lt;/p>
&lt;p>可以看出， &lt;strong>Trie 树的核心原理其实很简单，就是通过公共前缀来提高字符串匹配效率。&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://mvnrepository.com/artifact/org.apache.commons/commons-collections4">Apache Commons Collecions&lt;/a> 这个库中就有 Trie 树实现：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142025461.png" alt="ly-20241212142025461.png" />&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Trie&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> trie &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> PatriciaTrie&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trie.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Abigail&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;student&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trie.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Abi&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;doctor&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trie.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Annabel&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;teacher&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trie.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Christina&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;student&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trie.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Chris&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;doctor&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Assertions.&lt;span style="color:#a6e22e">assertTrue&lt;/span>(trie.&lt;span style="color:#a6e22e">containsKey&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Abigail&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>assertEquals(&lt;span style="color:#e6db74">&amp;#34;{Abi=doctor, Abigail=student}&amp;#34;&lt;/span>, trie.&lt;span style="color:#a6e22e">prefixMap&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Abi&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>assertEquals(&lt;span style="color:#e6db74">&amp;#34;{Chris=doctor, Christina=student}&amp;#34;&lt;/span>, trie.&lt;span style="color:#a6e22e">prefixMap&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Chr&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Aho-Corasick（AC）自动机是一种建立在 Trie 树上的一种改进算法，是一种多模式匹配算法，由贝尔实验室的研究人员 Alfred V. Aho 和 Margaret J.Corasick 发明。&lt;/p></description></item><item><title>权限系统设计详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly05ly_design-of-authority-system/</link><pubDate>Mon, 20 Feb 2023 15:54:05 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly05ly_design-of-authority-system/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>作者：转转技术团队&lt;/p>
&lt;p>原文：https://mp.weixin.qq.com/s/ONMuELjdHYa0yQceTj01Iw&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>ly：比较繁琐，大概看了前面的部分&lt;/p>
&lt;/blockquote>
&lt;h2 id="老权限系统的问题与现状">
 老权限系统的问题与现状
 &lt;a class="anchor" href="#%e8%80%81%e6%9d%83%e9%99%90%e7%b3%bb%e7%bb%9f%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%8e%e7%8e%b0%e7%8a%b6">#&lt;/a>
&lt;/h2>
&lt;p>转转公司在过去并没有一个统一的权限管理系统，权限管理由各业务自行研发或是使用其他业务的权限系统，权限管理的不统一带来了不少问题：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>各业务重复造轮子&lt;/strong>，维护成本高&lt;/li>
&lt;li>&lt;strong>各系统只解决部分场景&lt;/strong>问题，方案不够通用，新项目选型时没有可靠的权限管理方案&lt;/li>
&lt;li>&lt;strong>缺乏统一的日志管理&lt;/strong>与&lt;strong>审批流程&lt;/strong>，在授权信息追溯上十分困难&lt;/li>
&lt;/ol>
&lt;p>基于上述问题，去年底公司启动建设转转统一权限系统，目标是开发一套灵活、易用、安全的权限管理系统，供各业务使用。&lt;/p>
&lt;h2 id="业界权限系统的设计方式">
 业界权限系统的设计方式
 &lt;a class="anchor" href="#%e4%b8%9a%e7%95%8c%e6%9d%83%e9%99%90%e7%b3%bb%e7%bb%9f%e7%9a%84%e8%ae%be%e8%ae%a1%e6%96%b9%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>目前业界主流的权限模型有两种，下面分别介绍下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>基于角色的访问控制（RBAC）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>基于属性的访问控制（ABAC）&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="rbac-模型">
 RBAC 模型
 &lt;a class="anchor" href="#rbac-%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>基于角色的访问控制（Role-Based Access Control，简称 RBAC）&lt;/strong> 指的是通过用户的&lt;strong>角色（Role）&lt;strong>授权其&lt;/strong>相关权限&lt;/strong>，实现了灵活的访问控制，&lt;strong>相比直接授予用户权限&lt;/strong>，要更加简单、高效、可扩展。&lt;/p>
&lt;p>一个用户可以拥有若干角色，每一个角色又可以被&lt;strong>分配若干权限&lt;/strong>这样，就构造成“&lt;strong>用户-角色-权限&lt;/strong>” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系。&lt;/p>
&lt;p>用一个图来描述如下：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142024163.png" alt="ly-20241212142024163" />&lt;/p>
&lt;p>当使用 &lt;code>RBAC模型&lt;/code> 时，通过分析用户的实际情况，基于共同的职责和需求，&lt;strong>授予他们不同角色&lt;/strong>。这种 &lt;strong>&lt;code>用户 -&amp;gt; 角色 -&amp;gt; 权限&lt;/code>&lt;/strong> 间的关系，让我们可以不用再单独管理单个用户权限，用户&lt;strong>从授予的角色里面获取所需的权限&lt;/strong>。&lt;/p>
&lt;p>以一个简单的场景（Gitlab 的权限系统）为例，用户系统中有 &lt;code>Admin&lt;/code>、&lt;code>Maintainer&lt;/code>、&lt;code>Operator&lt;/code> 三种角色，这三种角色分别具备不同的权限，比如只有 &lt;code>Admin&lt;/code> 具备创建代码仓库、删除代码仓库的权限，其他的角色都不具备。我们授予某个用户 &lt;code>Admin&lt;/code> 这个角色，他就具备了 &lt;strong>创建代码仓库&lt;/strong> 和 &lt;strong>删除代码仓库&lt;/strong> 这两个权限。&lt;/p>
&lt;p>通过 &lt;code>RBAC模型&lt;/code> ，当存在多个用户拥有相同权限时，我们只需要创建好拥有该权限的角色，然后给不同的用户分配不同的角色，后续只需要修改角色的权限，就能自动修改角色内所有用户的权限。&lt;/p>
&lt;h3 id="abac-模型">
 ABAC 模型
 &lt;a class="anchor" href="#abac-%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>基于属性的访问控制（Attribute-Based Access Control，简称 ABAC）&lt;/strong> 是一种比 &lt;code>RBAC模型&lt;/code> 更加灵活的授权模型，它的原理是&lt;strong>通过各种属性来动态判断一个操作是否可以被允许&lt;/strong>。这个模型在云系统中使用的比较多，比如 AWS，阿里云等。&lt;/p>
&lt;p>考虑下面这些场景的权限控制：&lt;/p>
&lt;ol>
&lt;li>授权&lt;strong>某个人具体某本书的编辑&lt;/strong>权限&lt;/li>
&lt;li>当一个文档的&lt;strong>所属部门&lt;/strong>跟&lt;strong>用户的部门相同&lt;/strong>时，用户可以访问这个文档&lt;/li>
&lt;li>当&lt;strong>用户是一个文档的拥有者&lt;/strong>并且&lt;strong>文档的状态是草稿&lt;/strong>，用户可以编辑这个文档&lt;/li>
&lt;li>早上&lt;strong>九点前禁止 A 部门的人访问&lt;/strong> B 系统&lt;/li>
&lt;li>在&lt;strong>除了上海以外的地方禁止以管理员身份访问&lt;/strong> A 系统&lt;/li>
&lt;li>用户&lt;strong>对 2022-06-07 之前创建的订单&lt;/strong>有操作权限&lt;/li>
&lt;/ol>
&lt;p>可以发现上述的场景通过 &lt;code>RBAC模型&lt;/code> 很难去实现，因为 &lt;code>RBAC模型&lt;/code> 仅仅描述了用户可以做什么操作，但是操作的条件，以及操作的数据，&lt;code>RBAC模型&lt;/code> 本身是没有这些限制的。但这恰恰是 &lt;code>ABAC模型&lt;/code> 的长处，&lt;code>ABAC模型&lt;/code> 的思想是基于&lt;strong>用户&lt;/strong>、访问的&lt;strong>数据的属性&lt;/strong>、以及各&lt;strong>种环境因素&lt;/strong>去动态计算用户是否有权限进行操作。&lt;/p></description></item><item><title>sso单点登录</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly04ly_sso-intro/</link><pubDate>Mon, 20 Feb 2023 15:20:23 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly04ly_sso-intro/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>本文授权转载自 ： &lt;a href="https://ken.io/note/sso-design-implement">https://ken.io/note/sso-design-implement&lt;/a> 作者：ken.io&lt;/p>
&lt;/blockquote>
&lt;h2 id="sso-介绍">
 SSO 介绍
 &lt;a class="anchor" href="#sso-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是-sso">
 什么是 SSO？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-sso">#&lt;/a>
&lt;/h3>
&lt;p>SSO 英文全称 &lt;strong>Single Sign On&lt;/strong>，单点登录。SSO 是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。&lt;/p>
&lt;p>例如你登录网易账号中心（https://reg.163.com/ ）之后访问以下站点都是登录状态。&lt;/p>
&lt;ul>
&lt;li>网易直播 &lt;a href="https://v.163.com/">https://v.163.com&lt;/a>&lt;/li>
&lt;li>网易博客 &lt;a href="https://blog.163.com/">https://blog.163.com&lt;/a>&lt;/li>
&lt;li>网易花田 &lt;a href="https://love.163.com/">https://love.163.com&lt;/a>&lt;/li>
&lt;li>网易考拉 &lt;a href="https://www.kaola.com/">https://www.kaola.com&lt;/a>&lt;/li>
&lt;li>网易 Lofter &lt;a href="http://www.lofter.com/">http://www.lofter.com&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="sso-有什么好处">
 SSO 有什么好处？
 &lt;a class="anchor" href="#sso-%e6%9c%89%e4%bb%80%e4%b9%88%e5%a5%bd%e5%a4%84">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>用户角度&lt;/strong> :用户能够做到一次登录多次使用，无需记录多套用户名和密码，省心。&lt;/li>
&lt;li>&lt;strong>系统管理员角度&lt;/strong> : 管理员只需维护好一个统一的账号中心就可以了，方便。&lt;/li>
&lt;li>&lt;strong>新系统开发角度:&lt;/strong> 新系统开发时只需直接对接统一的账号中心即可，简化开发流程，省时。&lt;/li>
&lt;/ol>
&lt;h2 id="sso-设计与实现">
 SSO 设计与实现
 &lt;a class="anchor" href="#sso-%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0">#&lt;/a>
&lt;/h2>
&lt;p>本篇文章也主要是为了探讨如何设计&amp;amp;实现一个 SSO 系统&lt;/p>
&lt;p>以下为需要实现的核心功能：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>单点登录&lt;/strong>&lt;/li>
&lt;li>&lt;strong>单点登出&lt;/strong>&lt;/li>
&lt;li>支持&lt;strong>跨域单点登录&lt;/strong>&lt;/li>
&lt;li>支持&lt;strong>跨域单点登出&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="核心应用与依赖">
 核心应用与依赖
 &lt;a class="anchor" href="#%e6%a0%b8%e5%bf%83%e5%ba%94%e7%94%a8%e4%b8%8e%e4%be%9d%e8%b5%96">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="img/ly-20241212142023133.jpg" alt="单点登录（SSO）设计" />&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>应用/模块/对象&lt;/th>
 &lt;th>说明&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>前台站点&lt;/td>
 &lt;td>需要登录的站点&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SSO 站点-登录&lt;/td>
 &lt;td>提供登录的页面&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SSO 站点-登出&lt;/td>
 &lt;td>提供注销登录的入口&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SSO 服务-登录&lt;/td>
 &lt;td>提供登录服务&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SSO 服务-登录状态&lt;/td>
 &lt;td>提供登录状态校验/登录信息查询的服务&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SSO 服务-登出&lt;/td>
 &lt;td>提供用户注销登录的服务&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>数据库&lt;/td>
 &lt;td>存储用户账户信息&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>缓存&lt;/td>
 &lt;td>存储用户的登录信息，通常使用 Redis&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h3 id="用户登录状态的存储与校验">
 用户登录状态的存储与校验
 &lt;a class="anchor" href="#%e7%94%a8%e6%88%b7%e7%99%bb%e5%bd%95%e7%8a%b6%e6%80%81%e7%9a%84%e5%ad%98%e5%82%a8%e4%b8%8e%e6%a0%a1%e9%aa%8c">#&lt;/a>
&lt;/h3>
&lt;p>常见的 Web 框架对于 Session 的实现都是&lt;strong>生成一个 SessionId 存储在浏览器 Cookie&lt;/strong> 中。然后&lt;strong>将 Session 内容存储在服务器端内存&lt;/strong>中，这个 &lt;a href="https://ken.io/">ken.io&lt;/a> 在之前&lt;a href="https://ken.io/note/session-principle-skill">Session 工作原理&lt;/a>中也提到过。整体也是借鉴这个思路。&lt;/p></description></item><item><title>jwt身份认证优缺点</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly03ly_jwt-advantages-disadvantages/</link><pubDate>Mon, 20 Feb 2023 14:40:15 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly03ly_jwt-advantages-disadvantages/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>在 &lt;a href="https://javaguide.cn/system-design/security/jwt-intro.html">JWT 基本概念详解&lt;/a>这篇文章中，我介绍了：&lt;/p>
&lt;ul>
&lt;li>什么是 JWT?&lt;/li>
&lt;li>JWT 由哪些部分组成？&lt;/li>
&lt;li>如何基于 JWT 进行身份验证？&lt;/li>
&lt;li>JWT 如何防止 Token 被篡改？&lt;/li>
&lt;li>如何加强 JWT 的安全性？&lt;/li>
&lt;/ul>
&lt;p>这篇文章，我们一起探讨一下 JWT 身份认证的&lt;strong>优缺点&lt;/strong>以及&lt;strong>常见问题的解决办法&lt;/strong>。&lt;/p>
&lt;h2 id="jwt-的优势">
 JWT 的优势
 &lt;a class="anchor" href="#jwt-%e7%9a%84%e4%bc%98%e5%8a%bf">#&lt;/a>
&lt;/h2>
&lt;p>相比于 Session 认证的方式来说，使用 JWT 进行身份认证主要有下面 4 个优势。&lt;/p>
&lt;h3 id="无状态">
 无状态
 &lt;a class="anchor" href="#%e6%97%a0%e7%8a%b6%e6%80%81">#&lt;/a>
&lt;/h3>
&lt;p>JWT 自身&lt;strong>包含了身份验证所需要的所有信息&lt;/strong>，因此，我们的&lt;strong>服务器不需要存储 Session&lt;/strong> 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。&lt;/p>
&lt;p>不过，也正是由于 JWT 的无状态，也导致了它最大的缺点：&lt;strong>不可控！&lt;/strong>&lt;/p>
&lt;p>就比如说，我们想要在 &lt;strong>JWT 有效期内废弃一个 JWT&lt;/strong> 或者&lt;strong>更改它的权限&lt;/strong>的话，&lt;strong>并不会立即生效&lt;/strong>，通常需要等到有效期过后才可以。再比如说，&lt;strong>当用户 Logout 的话，JWT 也还有效&lt;/strong>。除非，我们在&lt;strong>后端增加额外的处理&lt;/strong>逻辑比如&lt;strong>将失效的 JWT 存储&lt;/strong>起来，后端先验证 JWT 是否有效再进行处理。具体的解决办法，我们会在后面的内容中详细介绍到，这里只是简单提一下。&lt;/p>
&lt;h3 id="有效避免了-csrf-攻击">
 有效避免了 CSRF 攻击
 &lt;a class="anchor" href="#%e6%9c%89%e6%95%88%e9%81%bf%e5%85%8d%e4%ba%86-csrf-%e6%94%bb%e5%87%bb">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>[ˈfɔːdʒəri] forgery 伪造&lt;/code>&lt;/p>
&lt;p>&lt;strong>CSRF（Cross Site Request Forgery）&lt;/strong> 一般被翻译为 &lt;strong>跨站请求伪造&lt;/strong>，属于网络攻击领域范围。相比于 SQL 脚本注入、XSS 等安全攻击方式，&lt;strong>CSRF&lt;/strong> 的知名度并没有它们高。但是，它的确是我们开发系统时必须要考虑的安全隐患。就连业内技术标杆 Google 的产品 Gmail 也曾在 2007 年的时候爆出过 CSRF 漏洞，这给 Gmail 的用户造成了很大的损失。&lt;/p></description></item><item><title>jwt-intro</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly02ly_jwt-intro/</link><pubDate>Mon, 20 Feb 2023 14:28:07 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly02ly_jwt-intro/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="img/ly-20241212142022219.png" alt="image.png" />&lt;/p>
&lt;h2 id="什么是-jwt">
 什么是 JWT?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-jwt">#&lt;/a>
&lt;/h2>
&lt;p>JWT （JSON Web Token） 是目前&lt;strong>最流行的跨域认证解决方案&lt;/strong>，是一种&lt;strong>基于 Token 的认证授权机制&lt;/strong>。 从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。&lt;/p>
&lt;blockquote>
&lt;p>跨域认证的问题&lt;br>
互联网服务离不开用户认证。一般流程是下面这样。&lt;/p>
&lt;p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是&lt;strong>服务器集群，或者是跨域的服务导向架构&lt;/strong>，就要求 &lt;strong>session 数据共享&lt;/strong>，&lt;strong>每台服务器都能够读取 session&lt;/strong>。&lt;/p>
&lt;p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？&lt;/p>
&lt;p>一种解决方案是 &lt;strong>session 数据持久化&lt;/strong>，&lt;strong>写入数据库&lt;/strong>或&lt;strong>别的持久层&lt;/strong>。各种服务收到请求后，都&lt;strong>向持久层请求数据&lt;/strong>。这种方案的优点是架构清晰，缺点是工程量比较大。另外，&lt;strong>持久层&lt;/strong>万一挂了，就会单点失败。&lt;/p>
&lt;p>另一种方案是服务器索性&lt;strong>不保存 session 数据&lt;/strong>了，所有&lt;strong>数据都保存在客户端&lt;/strong>，每次请求都发回服务器。JWT 就是这种方案的一个代表。&lt;/p>
&lt;/blockquote>
&lt;p>JWT 自身包含了身份验证所需要的所有信息，因此，我们的&lt;strong>服务器不需要存储 Session 信息&lt;/strong>。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。&lt;/p>
&lt;blockquote>
&lt;p>ly：我觉得这里的重点就是，服务器不存储Session以维护&amp;quot;用户&amp;quot;和cookie(session id)的关系了&lt;/p>
&lt;/blockquote>
&lt;p>可以看出，&lt;strong>JWT 更符合设计 RESTful API 时的「Stateless（无状态）」原则&lt;/strong> 。&lt;/p>
&lt;p>并且， 使用 JWT 认证可以有效&lt;strong>避免 CSRF 攻击&lt;/strong>，因为 JWT 一般是&lt;strong>存在在 localStorage&lt;/strong> 中，使用 JWT 进行身份验证的过程中是不会涉及到 Cookie 的。&lt;/p>
&lt;p>我在 &lt;a href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/system-design/security/advantages&amp;amp;disadvantages-of-jwt.md">JWT 优缺点分析&lt;/a>这篇文章中有详细介绍到使用 JWT 做身份认证的优势和劣势。&lt;/p>
&lt;p>下面是 &lt;a href="https://tools.ietf.org/html/rfc7519">RFC 7519&lt;/a> 对 JWT 做的较为正式的定义。&lt;/p></description></item><item><title>认证授权基础概念详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly01ly_basis-of-authority-certification/</link><pubDate>Mon, 20 Feb 2023 09:44:23 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/security/ly01ly_basis-of-authority-certification/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="认证-authentication-和授权-authorization的区别是什么">
 认证 (Authentication) 和授权 (Authorization)的区别是什么？
 &lt;a class="anchor" href="#%e8%ae%a4%e8%af%81-authentication-%e5%92%8c%e6%8e%88%e6%9d%83-authorization%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>这是一个绝大多数人都会混淆的问题。首先先从读音上来认识这两个名词，很多人都会把它俩的读音搞混，所以我建议你先先去查一查这两个单词到底该怎么读，他们的具体含义是什么。&lt;/p>
&lt;p>说简单点就是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>认证 (Authentication)：&lt;/strong> 你是谁。&lt;code>[ɔːˌθentɪˈkeɪʃn] 身份验证&lt;/code>&lt;/li>
&lt;li>&lt;strong>授权 (Authorization)：&lt;/strong> 你有权限干什么。&lt;code>[ˌɔːθəraɪˈzeɪʃn] 授权&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>稍微正式点（啰嗦点）的说法就是 ：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Authentication（认证）&lt;/strong> 是&lt;strong>验证&lt;/strong>您的身份的凭据（例如用户名/用户 ID 和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。&lt;/li>
&lt;li>&lt;strong>Authorization（授权）&lt;/strong> 发生在 &lt;strong>Authentication（认证）&lt;/strong> 之后。授权嘛，光看意思大家应该就明白，它主要&lt;strong>掌管&lt;/strong>我们访问系统的&lt;strong>权限&lt;/strong>。比如有些特定资源只能具有特定权限的人才能访问比如 admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。&lt;/li>
&lt;/ul>
&lt;p>认证 ：&lt;/p>
&lt;p>&lt;img src="https://camo.githubusercontent.com/0fa88e0ac6b2ed5aec983f25d3e7cce0b16dc1935630dd4edbef73b335fe8137/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303630343136303930383335322e706e67" alt="img" />&lt;/p>
&lt;p>授权：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142020901.jpg" alt="img" />&lt;/p>
&lt;p>这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。&lt;/p>
&lt;h2 id="rbac-模型了解吗">
 RBAC 模型了解吗？
 &lt;a class="anchor" href="#rbac-%e6%a8%a1%e5%9e%8b%e4%ba%86%e8%a7%a3%e5%90%97">#&lt;/a>
&lt;/h2>
&lt;p>系统权限控制最常采用的访问控制模型就是 &lt;strong>RBAC 模型&lt;/strong> 。&lt;/p>
&lt;p>&lt;strong>什么是 RBAC 呢？&lt;/strong>&lt;/p>
&lt;p>RBAC 即&lt;strong>基于角色的权限访问控制&lt;/strong>（&lt;strong>Role-Based Access Control&lt;/strong>）。这是一种通过角色关联权限，角色同时又关联用户的授权的方式。&lt;/p>
&lt;p>简单地说：一个&lt;strong>用户可以拥有若干角色&lt;/strong>，每一个&lt;strong>角色又可以被分配若干权限&lt;/strong>，这样就构造成“&lt;strong>用户-角色-权限&lt;/strong>” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系，如下图&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142021163.png" alt="image.png" />&lt;/p>
&lt;p>&lt;strong>在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。&lt;/strong>&lt;/p>
&lt;p>本系统的权限设计相关的表如下（一共 5 张表，2 张用户建立表之间的联系）：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142021291.png" alt="ly-20241212142021291.png" />&lt;/p>
&lt;p>通过这个权限模型，我们可以创建不同的角色并为不同的角色分配不同的权限范围（菜单）。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142021421.png" alt="ly-20241212142021421" />&lt;/p>
&lt;p>通常来说，如果系统对于权限控制要求&lt;strong>比较严格&lt;/strong>的话，一般都会选择使用 &lt;strong>RBAC&lt;/strong> 模型来做权限控制。&lt;/p>
&lt;h2 id="什么是-cookie--cookie-的作用是什么">
 什么是 Cookie ? Cookie 的作用是什么?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-cookie--cookie-%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142021557.jpg" alt="img" />&lt;/p></description></item><item><title>单元测试</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/basis/unit-test/</link><pubDate>Mon, 20 Feb 2023 09:38:24 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/basis/unit-test/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="何谓单元测试">
 何谓单元测试？
 &lt;a class="anchor" href="#%e4%bd%95%e8%b0%93%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h2>
&lt;p>维基百科是这样介绍单元测试的：&lt;/p>
&lt;blockquote>
&lt;p>在计算机编程中，单元测试（Unit Testing）是针对&lt;strong>程序模块&lt;/strong>（软件设计的最小单位）进行的&lt;strong>正确性检验测试&lt;/strong>工作。&lt;/p>
&lt;p>程序单元是应用的 &lt;strong>最小可测试部件&lt;/strong> 。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是&lt;strong>方法&lt;/strong>，包括基类（超类）、抽象类、或者派生类（子类）中的方法。&lt;/p>
&lt;/blockquote>
&lt;p>由于每个单元有独立的逻辑，在做单元测试时，为了隔离外部依赖，确保这些依赖&lt;strong>不影响验证逻辑&lt;/strong>，我们经常会用到 Fake、Stub 与 Mock 。&lt;/p>
&lt;p>关于 Fake、Mock 与 Stub 这几个概念的解读，可以看看这篇文章：&lt;a href="https://zhuanlan.zhihu.com/p/26942686">测试中 Fakes、Mocks 以及 Stubs 概念明晰 - 王下邀月熊 - 2018&lt;/a> 。&lt;/p>
&lt;h2 id="为什么需要单元测试">
 为什么需要单元测试？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h2>
&lt;h3 id="为重构保驾护航">
 为重构保驾护航
 &lt;a class="anchor" href="#%e4%b8%ba%e9%87%8d%e6%9e%84%e4%bf%9d%e9%a9%be%e6%8a%a4%e8%88%aa">#&lt;/a>
&lt;/h3>
&lt;p>我在&lt;a href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/system-design/basis/refactoring.md">重构&lt;/a>这篇文章中这样写到：&lt;/p>
&lt;blockquote>
&lt;p>单元测试可以&lt;strong>为重构提供信心&lt;/strong>，降低重构的成本。我们要像重视生产代码那样，重视单元测试。&lt;/p>
&lt;/blockquote>
&lt;p>每个开发者都会经历重构，重构后把代码改坏了的情况并不少见，很可能你只是修改了一个很简单的方法就导致系统出现了一个比较严重的错误。&lt;/p>
&lt;p>如果有了单元测试的话，就不会存在这个隐患了。写完一个类，把单元测试写了，确保这个类逻辑正确；写第二个类，单元测试&amp;hellip;..写 100 个类，道理一样，每个类做到第一点“&lt;strong>保证逻辑正确性&lt;/strong>”，100 个类拼在一起肯定不出问题。你大可以放心一边重构，一边运行 APP；而不是整体重构完，提心吊胆地 run。&lt;/p>
&lt;h3 id="提高代码质量">
 提高代码质量
 &lt;a class="anchor" href="#%e6%8f%90%e9%ab%98%e4%bb%a3%e7%a0%81%e8%b4%a8%e9%87%8f">#&lt;/a>
&lt;/h3>
&lt;p>由于每个单元有独立的逻辑，做单元测试时需要&lt;strong>隔离外部依赖&lt;/strong>，确保这些依赖&lt;strong>不影响验证逻辑&lt;/strong>。因为要把各种依赖分离，单元测试会&lt;strong>促进工程进行组件拆分&lt;/strong>，整理工程依赖关系，更大程度减少代码耦合。这样写出来的代码，更好维护，更好扩展，从而提高代码质量。&lt;/p>
&lt;h3 id="减少-bug">
 减少 bug
 &lt;a class="anchor" href="#%e5%87%8f%e5%b0%91-bug">#&lt;/a>
&lt;/h3>
&lt;p>一个机器，由各种细小的零件组成，如果其中某件零件坏了，机器运行故障。必须保证每个零件都按设计图要求的规格，机器才能正常运行。&lt;/p>
&lt;p>一个&lt;strong>可单元测试的工程&lt;/strong>，会把&lt;strong>业务&lt;/strong>、&lt;strong>功能&lt;/strong>分割成规模更小、有独立的逻辑部件，称为单元。单元测试的目标，就是保证&lt;strong>各个单元的逻辑正确性&lt;/strong>。单元测试保障工程各个“零件”按“规格”（需求）执行，从而保证整个“机器”（项目）运行正确，最大限度减少 bug。&lt;/p>
&lt;h3 id="快速定位-bug">
 快速定位 bug
 &lt;a class="anchor" href="#%e5%bf%ab%e9%80%9f%e5%ae%9a%e4%bd%8d-bug">#&lt;/a>
&lt;/h3>
&lt;p>如果程序有 bug，我们运行一次全部单元测试，找到&lt;strong>不通过的测试&lt;/strong>，可以很快地定位对应的执行代码。修复代码后，运行对应的单元测试；如还不通过，继续修改，运行测试&amp;hellip;..直到&lt;strong>测试通过&lt;/strong>。&lt;/p>
&lt;h3 id="持续集成依赖单元测试">
 持续集成依赖单元测试
 &lt;a class="anchor" href="#%e6%8c%81%e7%bb%ad%e9%9b%86%e6%88%90%e4%be%9d%e8%b5%96%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h3>
&lt;p>持续集成需要依赖单元测试，当持续集成服务自动构建新代码之后，会自动运行单元测试来发现代码错误。&lt;/p>
&lt;h2 id="谁逼你写单元测试">
 谁逼你写单元测试？
 &lt;a class="anchor" href="#%e8%b0%81%e9%80%bc%e4%bd%a0%e5%86%99%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h2>
&lt;h3 id="领导要求">
 领导要求
 &lt;a class="anchor" href="#%e9%a2%86%e5%af%bc%e8%a6%81%e6%b1%82">#&lt;/a>
&lt;/h3>
&lt;p>有些经验丰富的领导，或多或少都会要求团队写单元测试。对于有一定工作经验的队友，这要求挺合理；对于经验尚浅的、毕业生，恐怕要死要活了，连代码都写不好，还要写单元测试，are you kidding me？&lt;/p></description></item><item><title>代码重构指南</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/basis/refactoring/</link><pubDate>Fri, 17 Feb 2023 17:28:30 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/basis/refactoring/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>前段时间重读了&lt;a href="https://book.douban.com/subject/30468597/">《重构：改善代码既有设计》&lt;/a>，收货颇多。于是，简单写了一篇文章来聊聊我对重构的看法。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142016683.jpg" alt="img" />&lt;/p>
&lt;h2 id="何谓重构">
 何谓重构？
 &lt;a class="anchor" href="#%e4%bd%95%e8%b0%93%e9%87%8d%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>学习重构必看的一本神书《重构：改善代码既有设计》从两个角度给出了重构的定义：&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>重构（名词）：对&lt;strong>软件内部结构的一种调整&lt;/strong>，目的是在&lt;strong>不改变软件可观察行为&lt;/strong>的前提下，&lt;strong>提高其可理解性&lt;/strong>，&lt;strong>降低其修改成本&lt;/strong>。&lt;/li>
&lt;li>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，&lt;strong>调整&lt;/strong>其结构。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>用更贴近工程师的语言来说： &lt;strong>重构就是利用设计模式(如组合模式、策略模式、责任链模式)、软件设计原则（如 SOLID 原则、YAGNI 原则、KISS 原则）和重构手段（如封装、继承、构建测试体系）来让代码更容易理解，更易于修改。&lt;/strong>&lt;/p>
&lt;p>软件设计原则指导着我们组织和规范代码，同时，重构也是为了能够尽量设计出尽量满足软件设计原则的软件。&lt;/p>
&lt;p>正确重构的核心在于 &lt;strong>步子一定要小，每一步的重构都不会影响软件的正常运行，可以随时停止重构。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>常见的设计模式如下&lt;/strong> ：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142016942.jpg" alt="img" />&lt;/p>
&lt;p>更全面的设计模式总结，可以看 &lt;strong>&lt;a href="https://github.com/iluwatar/java-design-patterns">java-design-patterns&lt;/a>&lt;/strong> 这个开源项目。&lt;/p>
&lt;p>&lt;strong>常见的软件设计原则如下&lt;/strong> ：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142017073.jpg" alt="img" />&lt;/p>
&lt;p>更全面的设计原则总结，可以看 &lt;strong>&lt;a href="https://github.com/iluwatar/java-design-patterns">java-design-patterns&lt;/a>&lt;/strong> 和 &lt;strong>&lt;a href="https://github.com/nusr/hacker-laws-zh">hacker-laws-zh&lt;/a>&lt;/strong> 这两个开源项目。&lt;/p>
&lt;h2 id="为什么要重构">
 为什么要重构？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e9%87%8d%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>在上面介绍重构定义的时候，我从比较抽象的角度介绍了重构的好处：重构的主要目的主要是&lt;strong>提升代码&amp;amp;架构&lt;/strong>的&lt;strong>灵活性/可扩展性&lt;/strong>以及复用性。&lt;/p>
&lt;p>如果对应到一个真实的项目，重构具体能为我们带来什么好处呢？&lt;/p>
&lt;ol>
&lt;li>&lt;strong>让代码更容易理解&lt;/strong> ： 通过添加注释、命名规范、逻辑优化等手段可以让我们的代码更容易被理解；&lt;/li>
&lt;li>&lt;strong>避免代码腐化&lt;/strong> ：通过重构干掉坏味道代码；&lt;/li>
&lt;li>&lt;strong>加深对代码的理解&lt;/strong> ：重构代码的过程会加深你对某部分代码的理解；&lt;/li>
&lt;li>&lt;strong>发现潜在 bug&lt;/strong> ：是这样的，很多潜在的 bug ，都是我们在重构的过程中发现的；&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ol>
&lt;p>看了上面介绍的关于重构带来的好处之后，你会发现重构的最终目标是 &lt;strong>提高软件开发速度和质量&lt;/strong> 。&lt;/p>
&lt;p>重构并不会减慢软件开发速度，相反，如果代码质量和软件设计较差，当我们想要添加新功能的话，开发速度会越来越慢。到了最后，甚至都有想要重写整个系统的冲动。&lt;/p>
&lt;p>[&lt;img src="img/ly-20241212142017203.jpg" alt="img" />&lt;/p>
&lt;p>《重构：改善代码既有设计》这本书中这样说：&lt;/p>
&lt;blockquote>
&lt;p>重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。&lt;/p>
&lt;/blockquote>
&lt;h2 id="何时进行重构">
 何时进行重构？
 &lt;a class="anchor" href="#%e4%bd%95%e6%97%b6%e8%bf%9b%e8%a1%8c%e9%87%8d%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>重构在是开发过程中随时可以进行的，&lt;strong>见机行事&lt;/strong>即可，并不需要单独分配一两天的时间专门用来重构。&lt;/p>
&lt;h3 id="提交代码之前">
 提交代码之前
 &lt;a class="anchor" href="#%e6%8f%90%e4%ba%a4%e4%bb%a3%e7%a0%81%e4%b9%8b%e5%89%8d">#&lt;/a>
&lt;/h3>
&lt;p>《重构：改善代码既有设计》这本书介绍了一个 &lt;strong>营地法则&lt;/strong> 的概念:&lt;/p>
&lt;blockquote>
&lt;p>编程时，需要遵循营地法则：保证&lt;strong>你离开时的代码库一定比来时更健康&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>这个概念表达的核心思想其实很简单：在你提交代码的之前，花一会时间想一想，我这次的提交是让项目代码变得更健康了，还是更腐化了，或者说没什么变化？&lt;/p></description></item><item><title>代码命名指南</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/basis/naming/</link><pubDate>Fri, 17 Feb 2023 17:22:14 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/basis/naming/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>我还记得我刚工作那一段时间， 项目 Code Review 的时候，我经常因为变量命名不规范而被 “diss”!&lt;/p>
&lt;p>究其原因还是自己那会经验不足，而且，大学那会写项目的时候不太注意这些问题，想着只要把功能实现出来就行了。&lt;/p>
&lt;p>但是，工作中就不一样，为了代码的可读性、可维护性，项目组对于代码质量的要求还是很高的！&lt;/p>
&lt;p>前段时间，项目组新来的一个实习生也经常在 Code Review 因为变量命名不规范而被 “diss”，这让我想到自己刚到公司写代码那会的日子。&lt;/p>
&lt;p>于是，我就简单写了这篇关于变量命名规范的文章，希望能对同样有此困扰的小伙伴提供一些帮助。&lt;/p>
&lt;p>确实，编程过程中，有太多太多让我们头疼的事情了，比如命名、维护其他人的代码、写测试、与其他人沟通交流等等。&lt;/p>
&lt;p>据说之前在 Quora 网站，由接近 5000 名程序员票选出来的最难的事情就是“命名”。&lt;/p>
&lt;p>大名鼎鼎的《重构》的作者老马（Martin Fowler）曾经在&lt;a href="https://martinfowler.com/bliki/TwoHardThings.html">TwoHardThings&lt;/a>这篇文章中提到过CS 领域有两大最难的事情：一是 &lt;strong>缓存失效&lt;/strong> ，一是 &lt;strong>程序命名&lt;/strong> 。&lt;/p>
&lt;p>&lt;a href="https://camo.githubusercontent.com/55cdff0a451c1d8245d7734247bdb08cfaa79257ce2a03763cb03c27a3056f19/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6a6176612d67756964652d626c6f672f6d617274696e672d6e616d696e672e706e67">&lt;img src="img/ly-20241212142015914.jpg" alt="img" />&lt;/a>&lt;/p>
&lt;p>这个句话实际上也是老马引用别人的，类似的表达还有很多。比如分布式系统领域有两大最难的事情：一是 &lt;strong>保证消息顺序&lt;/strong> ，一是 &lt;strong>严格一次传递&lt;/strong> 。&lt;/p>
&lt;p>&lt;a href="https://camo.githubusercontent.com/595f6479028a874a759e29bfbc9df6c33e8e83b77c9cf7adeafd9aca696072ba/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6a6176612d67756964652d626c6f672f32303231303632393130343834343634352e706e67">&lt;img src="img/ly-20241212142016111.jpg" alt="img" />&lt;/a>&lt;/p>
&lt;p>今天咱们就单独拎出 “&lt;strong>命名&lt;/strong>” 来聊聊！&lt;/p>
&lt;p>这篇文章配合我之前发的 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;amp;mid=2247486449&amp;amp;idx=1&amp;amp;sn=c3b502529ff991c7180281bcc22877af&amp;amp;chksm=cea2443af9d5cd2c1c87049ed15ccf6f88275419c7dbe542406166a703b27d0f3ecf2af901f8&amp;amp;token=999884676&amp;amp;lang=zh_CN#rd">《编码 5 分钟，命名 2 小时？史上最全的 Java 命名规范参考！》&lt;/a> 这篇文章阅读效果更佳哦！&lt;/p>
&lt;h2 id="为什么需要重视命名">
 为什么需要重视命名？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e9%87%8d%e8%a7%86%e5%91%bd%e5%90%8d">#&lt;/a>
&lt;/h2>
&lt;p>咱们需要先搞懂为什么要重视编程中的命名这一行为，它对于我们的编码工作有着什么意义。&lt;/p>
&lt;p>&lt;strong>为什么命名很重要呢？&lt;/strong> 这是因为 &lt;strong>好的命名即是注释，别人一看到你的命名就知道你的变量、方法或者类是做什么的！&lt;/strong>&lt;/p>
&lt;p>简单来说就是 &lt;strong>别人根据你的命名就能知道你的代码要表达的意思&lt;/strong> （不过，前提这个人也要有&lt;strong>基本的英语&lt;/strong>知识，对于一些编程中常见的单词比较熟悉）。&lt;/p>
&lt;p>简单举个例子说明一下命名的重要性。&lt;/p>
&lt;p>《Clean Code》这本书明确指出：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。&lt;/strong>&lt;/p>
&lt;p>举个例子：&lt;/p>
&lt;p>去掉下面复杂的注释，只需要创建一个&lt;strong>与注释所言同一事物的函数&lt;/strong>即可&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// check to see if the employee is eligible for full benefits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> ((employee.&lt;span style="color:#a6e22e">flags&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> HOURLY_FLAG) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (employee.&lt;span style="color:#a6e22e">age&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> 65))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>应替换为&lt;/p></description></item><item><title>软件工程简明教程</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/basis/software-engineering/</link><pubDate>Fri, 17 Feb 2023 15:38:09 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/basis/software-engineering/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>大部分软件开发从业者，都会忽略软件开发中的一些最基础、最底层的一些概念。但是，这些软件开发的概念对于软件开发来说非常重要，就像是软件开发的基石一样。这也是我写这篇文章的原因。&lt;/p>
&lt;h2 id="何为软件工程">
 何为软件工程？
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;p>1968 年 NATO（北大西洋公约组织）提出了&lt;strong>软件危机&lt;/strong>（&lt;strong>Software crisis&lt;/strong>）一词。同年，为了解决软件危机问题，“&lt;strong>软件工程&lt;/strong>”的概念诞生了。一门叫做软件工程的学科也就应运而生。&lt;/p>
&lt;p>随着时间的推移，软件工程这门学科也经历了一轮又一轮的完善，其中的一些核心内容比如软件开发模型越来越丰富实用！&lt;/p>
&lt;p>&lt;strong>什么是软件危机呢？&lt;/strong>&lt;/p>
&lt;p>简单来说，软件危机描述了当时软件开发的一个痛点：我们&lt;strong>很难高效地开发出质量高&lt;/strong>的软件。&lt;/p>
&lt;p>Dijkstra（Dijkstra算法的作者） 在 1972年图灵奖获奖感言中也提高过软件危机，他是这样说的：“导致软件危机的主要原因是机器变得功能强大了几个数量级！坦率地说：只要没有机器，编程就完全没有问题。当我们有一些弱小的计算机时，编程成为一个温和的问题，而现在我们有了庞大的计算机，编程也同样成为一个巨大的问题”。&lt;/p>
&lt;p>&lt;strong>说了这么多，到底什么是软件工程呢？&lt;/strong>&lt;/p>
&lt;p>工程是&lt;strong>为了解决实际的问题将理论应用于实践&lt;/strong>。软件工程指的就是将&lt;strong>工程思想&lt;/strong>应用于&lt;strong>软件开发&lt;/strong>。&lt;/p>
&lt;p>上面是我对软件工程的定义，我们再来看看比较权威的定义。IEEE 软件工程汇刊给出的定义是这样的：　(1)将&lt;strong>系统化&lt;/strong>的、&lt;strong>规范&lt;/strong>的、&lt;strong>可量化&lt;/strong>的方法应用到软件的&lt;strong>开发&lt;/strong>、运&lt;strong>行&lt;/strong>及&lt;strong>维护&lt;/strong>中，即将工程化方法应用于软件。　(2)在(1)中所述方法的研究。&lt;/p>
&lt;p>总之，软件工程的终极目标就是：&lt;strong>在更少资源消耗的情况下，创造出更好、更容易维护的软件。&lt;/strong>&lt;/p>
&lt;h2 id="软件开发过程">
 软件开发过程
 &lt;a class="anchor" href="#%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e8%bf%87%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e8%bf%87%e7%a8%8b">维基百科是这样定义软件开发过程&lt;/a>的：&lt;/p>
&lt;blockquote>
&lt;p>软件开发过程（英语：software development process），或软件过程（英语：software process），是软件开发的开发生命周期（software development life cycle），其各个阶段实现了软件的&lt;strong>需求定义与分析&lt;/strong>、&lt;strong>设计&lt;/strong>、&lt;strong>实现&lt;/strong>、&lt;strong>测试&lt;/strong>、交付和&lt;strong>维护&lt;/strong>。软件过程是在开发与构建系统时应遵循的步骤，是软件开发的路线图。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>需求分析 ：分析用户的需求，建立逻辑模型。&lt;/li>
&lt;li>软件设计 ： 根据需求分析的结果对软件架构进行设计。&lt;/li>
&lt;li>编码 ：编写程序运行的源代码。&lt;/li>
&lt;li>测试 : 确定测试用例，编写测试报告。&lt;/li>
&lt;li>交付 ：将做好的软件交付给客户。&lt;/li>
&lt;li>维护 ：对软件进行维护比如解决 bug，完善功能。&lt;/li>
&lt;/ul>
&lt;p>软件开发过程只是比较笼统的层面上，一定义了一个软件开发可能涉及到的一些流程。&lt;/p>
&lt;p>软件开发模型更具体地定义了软件开发过程，对开发过程提供了强有力的理论支持。&lt;/p>
&lt;h2 id="软件开发模型">
 软件开发模型
 &lt;a class="anchor" href="#%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;p>软件开发模型有很多种，比如&lt;strong>瀑布模型（Waterfall Model）&lt;/strong>、&lt;strong>快速原型模型（Rapid Prototype Model）&lt;/strong>、&lt;strong>V模型（V-model）&lt;/strong>、&lt;strong>W模型（W-model）&lt;/strong>、&lt;strong>敏捷开发模型&lt;/strong>。其中最具有代表性的还是 &lt;strong>瀑布模型&lt;/strong> 和 &lt;strong>敏捷开发&lt;/strong> 。&lt;/p>
&lt;p>&lt;strong>瀑布模型&lt;/strong> 定义了一套完成的软件开发周期，完整地展示了一个软件的的生命周期。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142018153.png" alt="ly-20241212142018153" />&lt;/p>
&lt;p>&lt;strong>敏捷开发模型&lt;/strong> 是目前使用的最多的一种软件开发模型。&lt;a href="https://wiki.mbalib.com/wiki/%e6%95%8f%e6%8d%b7%e5%bc%80%e5%8f%91">MBA智库百科对敏捷开发的描述&lt;/a>是这样的:&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>敏捷开发&lt;/strong> 是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过&lt;strong>测试&lt;/strong>，具备&lt;strong>集成&lt;/strong>和&lt;strong>可运行&lt;/strong>的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。&lt;/p>
&lt;/blockquote>
&lt;p>像现在比较常见的一些概念比如 &lt;strong>持续集成&lt;/strong> 、&lt;strong>重构&lt;/strong> 、&lt;strong>小版本发布&lt;/strong> 、&lt;strong>低文档&lt;/strong> 、&lt;strong>站会&lt;/strong> 、&lt;strong>结对编程&lt;/strong> 、&lt;strong>测试驱动开发&lt;/strong> 都是敏捷开发的核心。&lt;/p></description></item><item><title>restFul</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/basis/restful/</link><pubDate>Fri, 17 Feb 2023 14:35:02 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lycly_system-design/basis/restful/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="img/ly-20241212142017481.png" alt="img" />&lt;/p>
&lt;p>这篇文章简单聊聊后端程序员必备的 RESTful API 相关的知识。&lt;/p>
&lt;p>开始正式介绍 RESTful API 之前，我们需要首先搞清 ：&lt;strong>API 到底是什么？&lt;/strong>&lt;/p>
&lt;h2 id="何为-api-何为-api">
 &lt;a href="#%e4%bd%95%e4%b8%ba-api">#&lt;/a> 何为 API？
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba-api-%e4%bd%95%e4%b8%ba-api">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142017744.png" alt="img" />&lt;/p>
&lt;p>&lt;strong>API（Application Programming Interface）&lt;/strong> 翻译过来是应用程序编程接口的意思。&lt;/p>
&lt;p>我们在进行后端开发的时候，主要的工作就是&lt;strong>为前端&lt;/strong>或者&lt;strong>其他后端服务&lt;/strong>提供 &lt;strong>AP&lt;/strong>I 比如&lt;strong>查询用户数据的 API&lt;/strong> 。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142017877.png" alt="ly-20241212142017877" />&lt;/p>
&lt;p>但是， API 不仅仅代表后端系统暴露的接口，像框架中提供的方法也属于 API 的范畴。&lt;/p>
&lt;p>为了方便大家理解，我再列举几个例子 🌰：&lt;/p>
&lt;ol>
&lt;li>你通过某电商网站搜索某某商品，电商网站的前端就调用了后端提供了&lt;strong>搜索商品相关的 API&lt;/strong>。&lt;/li>
&lt;li>你使用 JDK 开发 Java 程序，想要读取用户的输入的话，你就需要使用 JDK 提供的 &lt;strong>IO 相关的 API&lt;/strong>。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ol>
&lt;p>你可以把 API 理解为&lt;strong>程序与程序之间通信的桥梁&lt;/strong>，其本质就是一个&lt;strong>函数&lt;/strong>而已。另外，API 的使用也不是没有章法的，它的规则由（比如&lt;strong>数据输入&lt;/strong>和&lt;strong>输出&lt;/strong>的格式）API 提供方制定。&lt;/p>
&lt;h2 id="何为-restful-api-何为-restful-api">
 &lt;a href="#%e4%bd%95%e4%b8%ba-restful-api">#&lt;/a> 何为 RESTful API？
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba-restful-api-%e4%bd%95%e4%b8%ba-restful-api">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>RESTful API&lt;/strong> 经常也被叫做 &lt;strong>REST API&lt;/strong>，它是基于 REST 构建的 API。这个 REST 到底是什么，我们后文在讲，涉及到的概念比较多。&lt;/p>
&lt;p>如果你看 RESTful API 相关的文章的话一般都比较晦涩难懂，主要是因为 REST 涉及到的一些概念比较难以理解。但是，实际上，我们平时开发用到的 RESTful API 的知识非常简单也很容易概括！&lt;/p></description></item><item><title>性能测试入门</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly05ly_performance-test/</link><pubDate>Fri, 17 Feb 2023 11:37:08 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly05ly_performance-test/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>性能测试一般情况下都是由测试这个职位去做的，那还需要我们开发学这个干嘛呢？&lt;strong>了解性能测试的指标&lt;/strong>、&lt;strong>分类&lt;/strong>以及&lt;strong>工具&lt;/strong>等知识有助于我们更好地去&lt;strong>写出性能更好&lt;/strong>的程序，另外作为开发这个角色，如果你会性能测试的话，相信也会为你的履历加分不少。&lt;/p>
&lt;p>这篇文章是我会结合自己的实际经历以及在测试这里取的经所得，除此之外，我还借鉴了一些优秀书籍，希望对你有帮助。&lt;/p>
&lt;p>本文思维导图：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142046226.png" alt="img" />&lt;/p>
&lt;h2 id="一-不同角色看网站性能-一-不同角色看网站性能">
 &lt;a href="#%e4%b8%80-%e4%b8%8d%e5%90%8c%e8%a7%92%e8%89%b2%e7%9c%8b%e7%bd%91%e7%ab%99%e6%80%a7%e8%83%bd">#&lt;/a> 一 不同角色看网站性能
 &lt;a class="anchor" href="#%e4%b8%80-%e4%b8%8d%e5%90%8c%e8%a7%92%e8%89%b2%e7%9c%8b%e7%bd%91%e7%ab%99%e6%80%a7%e8%83%bd-%e4%b8%80-%e4%b8%8d%e5%90%8c%e8%a7%92%e8%89%b2%e7%9c%8b%e7%bd%91%e7%ab%99%e6%80%a7%e8%83%bd">#&lt;/a>
&lt;/h2>
&lt;h3 id="_1-1-用户-11-用户">
 &lt;a href="#_1-1-%e7%94%a8%e6%88%b7">#&lt;/a> 1.1 用户
 &lt;a class="anchor" href="#_1-1-%e7%94%a8%e6%88%b7-11-%e7%94%a8%e6%88%b7">#&lt;/a>
&lt;/h3>
&lt;p>当用户打开一个网站的时候，最关注的是什么？当然是&lt;strong>网站响应速度的快慢&lt;/strong>。比如我们点击了淘宝的主页，淘宝需要多久将首页的内容呈现在我的面前，我点击了提交订单按钮需要多久返回结果等等。&lt;/p>
&lt;p>所以，用户在体验我们系统的时候往往根据你的响应速度的快慢来评判你的网站的性能。&lt;/p>
&lt;h3 id="_1-2-开发人员-12-开发人员">
 &lt;a href="#_1-2-%e5%bc%80%e5%8f%91%e4%ba%ba%e5%91%98">#&lt;/a> 1.2 开发人员
 &lt;a class="anchor" href="#_1-2-%e5%bc%80%e5%8f%91%e4%ba%ba%e5%91%98-12-%e5%bc%80%e5%8f%91%e4%ba%ba%e5%91%98">#&lt;/a>
&lt;/h3>
&lt;p>用户与开发人员都关注速度，这个速度实际上就是我们的系统&lt;strong>处理用户请求的速度&lt;/strong>。&lt;/p>
&lt;p>开发人员一般情况下很难直观的去评判自己网站的性能，我们往往会根据网站&lt;strong>当前的架构&lt;/strong>以及&lt;strong>基础设施&lt;/strong>情况给一个大概的值,比如：&lt;/p>
&lt;ol>
&lt;li>项目架构是分布式的吗？&lt;/li>
&lt;li>用到了&lt;strong>缓存&lt;/strong>和&lt;strong>消息队列&lt;/strong>没有？&lt;/li>
&lt;li>&lt;strong>高并发&lt;/strong>的业务有没有特殊处理？&lt;/li>
&lt;li>&lt;strong>数据库设计&lt;/strong>是否合理？&lt;/li>
&lt;li>系统用到的&lt;strong>算法&lt;/strong>是否还需要优化？&lt;/li>
&lt;li>系统是否存在&lt;strong>内存泄露&lt;/strong>的问题？&lt;/li>
&lt;li>项目使用的 &lt;strong>Redis 缓存多大&lt;/strong>？服务器&lt;strong>性能&lt;/strong>如何？用的是&lt;strong>机械硬盘&lt;/strong>还是&lt;strong>固态硬盘&lt;/strong>？&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ol>
&lt;h3 id="_1-3-测试人员-13-测试人员">
 &lt;a href="#_1-3-%e6%b5%8b%e8%af%95%e4%ba%ba%e5%91%98">#&lt;/a> 1.3 测试人员
 &lt;a class="anchor" href="#_1-3-%e6%b5%8b%e8%af%95%e4%ba%ba%e5%91%98-13-%e6%b5%8b%e8%af%95%e4%ba%ba%e5%91%98">#&lt;/a>
&lt;/h3>
&lt;p>测试人员一般会根据性能测试工具来测试，然后一般会做出一个表格。这个表格可能会涵盖下面这些重要的内容：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>响应时间&lt;/strong>；&lt;/li>
&lt;li>&lt;strong>请求成功率&lt;/strong>；&lt;/li>
&lt;li>吞吐量；&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ol>
&lt;h3 id="_1-4-运维人员-14-运维人员">
 &lt;a href="#_1-4-%e8%bf%90%e7%bb%b4%e4%ba%ba%e5%91%98">#&lt;/a> 1.4 运维人员
 &lt;a class="anchor" href="#_1-4-%e8%bf%90%e7%bb%b4%e4%ba%ba%e5%91%98-14-%e8%bf%90%e7%bb%b4%e4%ba%ba%e5%91%98">#&lt;/a>
&lt;/h3>
&lt;p>运维人员会倾向于根据&lt;strong>基础设施&lt;/strong>和&lt;strong>资源的利用率&lt;/strong>来判断网站的性能，比如我们的服务器资源使用是否合理、数据库资源是否存在滥用的情况、当然，这是传统的运维人员，现在 Devpos 火起来后，单纯干运维的很少了。我们这里暂且还保留有这个角色。&lt;/p>
&lt;h2 id="二-性能测试需要注意的点-二-性能测试需要注意的点">
 &lt;a href="#%e4%ba%8c-%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e7%9a%84%e7%82%b9">#&lt;/a> 二 性能测试需要注意的点
 &lt;a class="anchor" href="#%e4%ba%8c-%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e7%9a%84%e7%82%b9-%e4%ba%8c-%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e7%9a%84%e7%82%b9">#&lt;/a>
&lt;/h2>
&lt;p>几乎没有文章在讲性能测试的时候提到这个问题，大家都会讲如何去性能测试，有哪些性能测试指标这些东西。&lt;/p>
&lt;h3 id="_2-1-了解系统的业务场景-21-了解系统的业务场景">
 &lt;a href="#_2-1-%e4%ba%86%e8%a7%a3%e7%b3%bb%e7%bb%9f%e7%9a%84%e4%b8%9a%e5%8a%a1%e5%9c%ba%e6%99%af">#&lt;/a> 2.1 了解系统的业务场景
 &lt;a class="anchor" href="#_2-1-%e4%ba%86%e8%a7%a3%e7%b3%bb%e7%bb%9f%e7%9a%84%e4%b8%9a%e5%8a%a1%e5%9c%ba%e6%99%af-21-%e4%ba%86%e8%a7%a3%e7%b3%bb%e7%bb%9f%e7%9a%84%e4%b8%9a%e5%8a%a1%e5%9c%ba%e6%99%af">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>性能测试之前更需要你了解当前的系统的业务场景。&lt;/strong> 对系统业务了解的不够深刻，我们很容易犯测试方向偏执的错误，从而导致我们&lt;strong>忽略了对系统某些更需要性能测试的地方进行测试&lt;/strong>。比如我们的系统可以为用户提供发送邮件的功能，用户配置成功邮箱后只需输入相应的邮箱之后就能发送，系统每天&lt;strong>大概能处理上万次&lt;/strong>发邮件的请求。很多人看到这个可能就直接开始使用相关工具测试邮箱发送接口，但是，发送邮件这个场景可能不是当前系统的性能瓶颈，这么多人用我们的系统发邮件， 还可能有&lt;strong>很多人一起发&lt;/strong>邮件，单单这个场景就这么人用，那&lt;strong>用户管理可能才是性能瓶颈&lt;/strong>吧！&lt;/p>
&lt;h3 id="_2-2-历史数据非常有用-22-历史数据非常有用">
 &lt;a href="#_2-2-%e5%8e%86%e5%8f%b2%e6%95%b0%e6%8d%ae%e9%9d%9e%e5%b8%b8%e6%9c%89%e7%94%a8">#&lt;/a> 2.2 历史数据非常有用
 &lt;a class="anchor" href="#_2-2-%e5%8e%86%e5%8f%b2%e6%95%b0%e6%8d%ae%e9%9d%9e%e5%b8%b8%e6%9c%89%e7%94%a8-22-%e5%8e%86%e5%8f%b2%e6%95%b0%e6%8d%ae%e9%9d%9e%e5%b8%b8%e6%9c%89%e7%94%a8">#&lt;/a>
&lt;/h3>
&lt;p>当前系统所留下的历史数据非常重要，一般情况下，我们可以&lt;strong>通过相应的些历史数据&lt;/strong>初步判定这个系统&lt;strong>哪些接口调用的比较多&lt;/strong>、&lt;strong>哪些 service&lt;/strong> 承受的压力最大，这样的话，我们就可以针对这些地方进行更细致的性能测试与分析。&lt;/p>
&lt;p>另外，这些地方也就像这个系统的一个短板一样，优化好了这些地方会为我们的系统带来质的提升。&lt;/p>
&lt;h3 id="三-性能测试的指标-三-性能测试的指标">
 &lt;a href="#%e4%b8%89-%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95%e7%9a%84%e6%8c%87%e6%a0%87">#&lt;/a> 三 性能测试的指标
 &lt;a class="anchor" href="#%e4%b8%89-%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95%e7%9a%84%e6%8c%87%e6%a0%87-%e4%b8%89-%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95%e7%9a%84%e6%8c%87%e6%a0%87">#&lt;/a>
&lt;/h3>
&lt;h3 id="_3-1-响应时间-31-响应时间">
 &lt;a href="#_3-1-%e5%93%8d%e5%ba%94%e6%97%b6%e9%97%b4">#&lt;/a> 3.1 响应时间
 &lt;a class="anchor" href="#_3-1-%e5%93%8d%e5%ba%94%e6%97%b6%e9%97%b4-31-%e5%93%8d%e5%ba%94%e6%97%b6%e9%97%b4">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>响应时间就是用户发出请求到用户收到系统处理结果所需要的时间。&lt;/strong> 重要吗？实在太重要！&lt;/p></description></item><item><title>超时&amp;重试详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly04ly_timout-and-retry/</link><pubDate>Fri, 17 Feb 2023 10:57:02 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly04ly_timout-and-retry/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>由于&lt;strong>网络&lt;/strong>问题、&lt;strong>系统&lt;/strong>或者&lt;strong>服务内部&lt;/strong>的 Bug、服务器&lt;strong>宕机&lt;/strong>、操作&lt;strong>系统崩溃&lt;/strong>等问题的不确定性，我们的系统或者服务永远不可能保证时刻都是可用的状态。&lt;/p>
&lt;p>为了最大限度的减小系统或者服务出现故障之后带来的影响，我们需要用到的 &lt;strong>超时（Timeout）&lt;/strong> 和 &lt;strong>重试（Retry）&lt;/strong> 机制。&lt;/p>
&lt;p>想要把超时和重试机制讲清楚其实很简单，因为它俩本身就不是什么高深的概念。&lt;/p>
&lt;p>虽然超时和重试机制的思想很简单，但是它俩是真的非常实用。你平时接触到的绝大部分涉及到&lt;strong>远程调用&lt;/strong>的系统或者服务都会应用超时和重试机制。尤其是对于微服务系统来说，正确设置超时和重试非常重要。单体服务通常只涉及&lt;strong>数据库&lt;/strong>、&lt;strong>缓存&lt;/strong>、&lt;strong>第三方 API&lt;/strong>、&lt;strong>中间件&lt;/strong>等的网络调用，而微服务&lt;strong>系统内部各个服务之间还存在着网络调用&lt;/strong>。&lt;/p>
&lt;h2 id="超时机制-超时机制">
 &lt;a href="#%e8%b6%85%e6%97%b6%e6%9c%ba%e5%88%b6">#&lt;/a> 超时机制
 &lt;a class="anchor" href="#%e8%b6%85%e6%97%b6%e6%9c%ba%e5%88%b6-%e8%b6%85%e6%97%b6%e6%9c%ba%e5%88%b6">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是超时机制-什么是超时机制">
 &lt;a href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%b6%85%e6%97%b6%e6%9c%ba%e5%88%b6">#&lt;/a> 什么是超时机制？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%b6%85%e6%97%b6%e6%9c%ba%e5%88%b6-%e4%bb%80%e4%b9%88%e6%98%af%e8%b6%85%e6%97%b6%e6%9c%ba%e5%88%b6">#&lt;/a>
&lt;/h3>
&lt;p>超时机制说的是&lt;strong>当一个请求超过指定的时间&lt;/strong>（比如 1s）还没有被处理的话，这个请求就会&lt;strong>直接被取消并抛出指定的异常&lt;/strong>或者&lt;strong>错误&lt;/strong>（比如 &lt;code>504 Gateway Timeout&lt;/code>）。&lt;/p>
&lt;p>我们平时接触到的超时可以简单分为下面 2 种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>连接超时（ConnectTimeout）&lt;/strong> ：客户端与服务端&lt;strong>建立连接&lt;/strong>的最长等待时间。&lt;/li>
&lt;li>&lt;strong>读取超时（ReadTimeout）&lt;/strong> ：客户端和服务端&lt;strong>已经建立连接&lt;/strong>，&lt;strong>客户端等待服务端处理完请求的最长时间&lt;/strong>。实际项目中，我们关注比较多的还是&lt;strong>读取超时&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>一些连接池客户端框架中可能还会有&lt;strong>获取连接超&lt;/strong>时&lt;strong>和&lt;/strong>空闲连接清理超时**。&lt;/p>
&lt;p>如果没有设置超时的话，就可能会导致服务端&lt;strong>连接数爆炸&lt;/strong>和&lt;strong>大量请求堆积&lt;/strong>的问题。&lt;/p>
&lt;p>这些堆积的连接和请求会&lt;strong>消耗系统资源&lt;/strong>，&lt;strong>影响新收到的请求&lt;/strong>的处理。严重的情况下，甚至会&lt;strong>拖垮整个系统或者服务&lt;/strong>。&lt;/p>
&lt;p>我之前在实际项目就遇到过类似的问题，整个网站无法正常处理请求，服务器负载直接快被拉满。后面发现原因是项目超时设置错误加上客户端请求处理异常，导致服务端连接数直接接近 40w+，这么多堆积的连接直接把系统干趴了。&lt;/p>
&lt;h3 id="超时时间应该如何设置-超时时间应该如何设置">
 &lt;a href="#%e8%b6%85%e6%97%b6%e6%97%b6%e9%97%b4%e5%ba%94%e8%af%a5%e5%a6%82%e4%bd%95%e8%ae%be%e7%bd%ae">#&lt;/a> 超时时间应该如何设置？
 &lt;a class="anchor" href="#%e8%b6%85%e6%97%b6%e6%97%b6%e9%97%b4%e5%ba%94%e8%af%a5%e5%a6%82%e4%bd%95%e8%ae%be%e7%bd%ae-%e8%b6%85%e6%97%b6%e6%97%b6%e9%97%b4%e5%ba%94%e8%af%a5%e5%a6%82%e4%bd%95%e8%ae%be%e7%bd%ae">#&lt;/a>
&lt;/h3>
&lt;p>超时到底设置多长时间是一个难题！超时值设置太高或者太低都有风险。如果设置太高的话，会&lt;strong>降低超时机制的有效性&lt;/strong>，比如你设置超时为 10s 的话，那设置超时就没啥意义了，系统&lt;strong>依然可能会出现大量慢请求堆积&lt;/strong>的问题。如果&lt;strong>设置太低&lt;/strong>的话，就可能会导致在&lt;strong>系统或者服务在某些处理请求速度变慢&lt;/strong>的情况下（比如请求突然增多），&lt;strong>大量请求重试（超时通常会结合重试）继续加重系统或者服务的压力&lt;/strong>，进而导致整个系统或者服务被拖垮的问题。&lt;/p>
&lt;p>通常情况下，我们建议读取超时设置为 &lt;strong>1500ms&lt;/strong> ,这是一个比较普适的值。如果你的系统或者服务对于延迟比较敏感的话，那读取超时值可以适当在 &lt;strong>1500ms&lt;/strong> 的基础上进行缩短。反之，读取超时值也可以在 &lt;strong>1500ms&lt;/strong> 的基础上进行加长，不过，尽量还是不要超过 &lt;strong>1500ms&lt;/strong> 。连接超时可以适当设置长一些，建议在 &lt;strong>1000ms ~ 5000ms&lt;/strong> 之内。&lt;/p>
&lt;p>没有银弹！超时值具体该设置多大，还是要根据实际项目的需求和情况慢慢调整优化得到。&lt;/p>
&lt;p>更上一层，参考&lt;a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">美团的Java线程池参数动态配置open in new window&lt;/a>思想，我们也可以将超时弄成可配置化的参数而不是固定的，比较简单的一种办法就是将超时的值放在配置中心中。这样的话，我们就可以根据系统或者服务的状态动态调整超时值了。&lt;/p>
&lt;h2 id="重试机制-重试机制">
 &lt;a href="#%e9%87%8d%e8%af%95%e6%9c%ba%e5%88%b6">#&lt;/a> 重试机制
 &lt;a class="anchor" href="#%e9%87%8d%e8%af%95%e6%9c%ba%e5%88%b6-%e9%87%8d%e8%af%95%e6%9c%ba%e5%88%b6">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是重试机制-什么是重试机制">
 &lt;a href="#%e4%bb%80%e4%b9%88%e6%98%af%e9%87%8d%e8%af%95%e6%9c%ba%e5%88%b6">#&lt;/a> 什么是重试机制？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e9%87%8d%e8%af%95%e6%9c%ba%e5%88%b6-%e4%bb%80%e4%b9%88%e6%98%af%e9%87%8d%e8%af%95%e6%9c%ba%e5%88%b6">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>重试机制一般配合超时机制&lt;/strong>一起使用，指的是&lt;strong>多次发送相同的请求&lt;/strong>来&lt;strong>避免瞬态故障&lt;/strong>和&lt;strong>偶然性故障&lt;/strong>。&lt;/p>
&lt;p>瞬态故障可以简单理解为&lt;strong>某一瞬间系统偶然出现的故障&lt;/strong>，并不会持久。偶然性故障可以理解为哪些在&lt;strong>某些情况下偶尔出现的故障&lt;/strong>，频率通常较低。&lt;/p>
&lt;p>重试的核心思想是&lt;strong>通过消耗服务器的资源来尽可能获得请求更大概率被成功处理&lt;/strong>。由于瞬态故障和偶然性故障是很少发生的，因此，重试对于服务器的资源消耗几乎是可以被忽略的。&lt;/p>
&lt;h3 id="重试的次数如何设置-重试的次数如何设置">
 &lt;a href="#%e9%87%8d%e8%af%95%e7%9a%84%e6%ac%a1%e6%95%b0%e5%a6%82%e4%bd%95%e8%ae%be%e7%bd%ae">#&lt;/a> 重试的次数如何设置？
 &lt;a class="anchor" href="#%e9%87%8d%e8%af%95%e7%9a%84%e6%ac%a1%e6%95%b0%e5%a6%82%e4%bd%95%e8%ae%be%e7%bd%ae-%e9%87%8d%e8%af%95%e7%9a%84%e6%ac%a1%e6%95%b0%e5%a6%82%e4%bd%95%e8%ae%be%e7%bd%ae">#&lt;/a>
&lt;/h3>
&lt;p>重试的次数不宜过多，否则依然会对系统负载造成比较大的压力。&lt;/p></description></item><item><title>服务限流详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly03ly_limit-request/</link><pubDate>Thu, 16 Feb 2023 17:06:11 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly03ly_limit-request/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>针对软件系统来说，限流就是&lt;strong>对请求的速率进行限制&lt;/strong>，&lt;strong>避免瞬时的大量请求击垮软件系统&lt;/strong>。毕竟，软件系统的处理能力是有限的。如果说超过了其处理能力的范围，软件系统可能直接就挂掉了。&lt;/p>
&lt;p>限流可能会&lt;strong>导致用户的请求无法被正确处理&lt;/strong>，不过，这往往也是&lt;strong>权衡了软件系统的稳定性之后得到的最优解&lt;/strong>。&lt;/p>
&lt;p>现实生活中，处处都有限流的实际应用，就比如&lt;strong>排队买票&lt;/strong>是为了避免大量用户涌入购票而导致&lt;strong>售票员无法处理&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142045484.jpg" alt="排队示意图" />&lt;/p>
&lt;h2 id="常见限流算法有哪些">
 常见限流算法有哪些？
 &lt;a class="anchor" href="#%e5%b8%b8%e8%a7%81%e9%99%90%e6%b5%81%e7%ae%97%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b">#&lt;/a>
&lt;/h2>
&lt;p>简单介绍 4 种非常好理解并且容易实现的限流算法！&lt;/p>
&lt;blockquote>
&lt;p>图片来源于 InfoQ 的一篇文章&lt;a href="https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673">《分布式服务限流实战，已经为你排好坑了》&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h3 id="固定窗口计数器算法">
 固定窗口计数器算法
 &lt;a class="anchor" href="#%e5%9b%ba%e5%ae%9a%e7%aa%97%e5%8f%a3%e8%ae%a1%e6%95%b0%e5%99%a8%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h3>
&lt;p>固定窗口其实就是时间窗口。&lt;strong>固定窗口计数器算法&lt;/strong> 规定了我们&lt;strong>单位时间处理的请求数量&lt;/strong>。&lt;/p>
&lt;p>假如我们规定系统中某个接口 1 分钟只能访问 33 次的话，使用固定窗口计数器算法的实现思路如下：&lt;/p>
&lt;ul>
&lt;li>给定一个变量 &lt;code>counter&lt;/code> 来&lt;strong>记录当前接口处理的请求数量&lt;/strong>，初始值为 0（代表接口当前 1 分钟内还未处理请求）。&lt;/li>
&lt;li>1 分钟之内每处理一个请求之后就将 &lt;code>counter+1&lt;/code> ，当 &lt;code>counter=33&lt;/code> 之后（也就是说在这 1 分钟内接口已经被访问 33 次的话），后续的请求就会被全部拒绝。&lt;/li>
&lt;li>等到 1 分钟结束后，将 &lt;code>counter&lt;/code> 重置 0，重新开始计数。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>这种限流算法无法保证限流速率，因而无法保证突然激增的流量。&lt;/strong>&lt;/p>
&lt;p>就比如说我们限制某个接口 1 分钟只能访问 1000 次，该接口的 QPS 为 500，前 55s 这个接口 1 个请求没有接收，后 1s 突然接收了 1000 个请求。然后，在当前场景下，这 1000 个请求在 1s 内是没办法被处理的，系统直接就被瞬时的大量请求给击垮了。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142045643.jpg" alt="固定窗口计数器算法" />&lt;/p></description></item><item><title>冗余设计</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly02ly_redundancy/</link><pubDate>Thu, 16 Feb 2023 16:54:24 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly02ly_redundancy/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>title&lt;/th>
 &lt;th>category&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>冗余设计详解&lt;/td>
 &lt;td>高可用&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>冗余设计是&lt;strong>保证系统和数据高可用&lt;/strong>的最常的手段。&lt;/p>
&lt;p>对于服务来说，冗余的思想就是&lt;strong>相同的服务部署多份&lt;/strong>，如果正在使用的服务突然挂掉的话，系统可以&lt;strong>很快切换&lt;/strong>到备份服务上，大大减少系统的不可用时间，提高系统的可用性。&lt;/p>
&lt;p>对于数据来说，冗余的思想就是&lt;strong>相同的数据备份多份&lt;/strong>，这样就可以很简单地&lt;strong>提高数据的安全性&lt;/strong>。&lt;/p>
&lt;p>实际上，日常生活中就有非常多的冗余思想的应用。&lt;/p>
&lt;p>拿我自己来说，我对于重要文件的保存方法就是冗余思想的应用。我日常所使用的重要文件都会&lt;strong>同步一份在 Github 以及个人云盘&lt;/strong>上，这样就可以保证即使电脑硬盘损坏，我也可以通过 Github 或者个人云盘找回自己的重要文件。&lt;/p>
&lt;p>&lt;strong>高可用集群（High Availability Cluster，简称 HA Cluster）&lt;/strong>、&lt;strong>同城灾备&lt;/strong>、&lt;strong>异地灾备&lt;/strong>、&lt;strong>同城多活&lt;/strong>和&lt;strong>异地多活&lt;/strong>是冗余思想在高可用系统设计中最典型的应用。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>高可用集群&lt;/strong> : 同一份服务部署两份或者多份，当正在使用的服务突然挂掉的话，可以切换到另外一台服务，从而保证服务的高可用。&lt;/li>
&lt;li>&lt;strong>同城灾备&lt;/strong> ：一整个集群可以部署在同一个机房，而同城灾备中相同服务部署在&lt;strong>同一个城市&lt;/strong>的&lt;strong>不同机房&lt;/strong>中。并且，&lt;strong>备用服务不处理请求&lt;/strong>。这样可以避免机房出现意外情况比如停电、火灾。&lt;/li>
&lt;li>&lt;strong>异地灾备&lt;/strong> ：类似于同城灾备，不同的是，相同服务部署在&lt;strong>异地&lt;/strong>（通常距离较远，甚至是在不同的城市或者国家）的&lt;strong>不同机房&lt;/strong>中&lt;/li>
&lt;li>&lt;strong>同城多活&lt;/strong> ：类似于同城灾备，但&lt;strong>备用服务可以处理请求&lt;/strong>，这样可以充分利用系统资源，提高系统的并发。&lt;/li>
&lt;li>&lt;strong>异地多活&lt;/strong> : 将服务部署在&lt;strong>异地的不同机房&lt;/strong>中，并且，它们可以同时&lt;strong>对外提供服务&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>高可用集群&lt;strong>单纯是服务的冗余&lt;/strong>，并没有强调地域。同城灾备、异地灾备、同城多活和异地多活实现了地域上的冗余。&lt;/p>
&lt;p>同城和异地的主要区别在于&lt;strong>机房之间的距离&lt;/strong>。异地通常距离较远，甚至是在不同的城市或者国家。&lt;/p>
&lt;p>和传统的灾备设计相比，同城多活和异地多活最明显的改变在于**“多活”&lt;strong>，即所有站点都是&lt;/strong>同时在对外提供服务&lt;strong>的。异地多活是为了应对突发状况比如&lt;/strong>火灾**、&lt;strong>地震&lt;/strong>等自然或者人为灾害。&lt;/p>
&lt;p>光做好冗余还不够，必须要配合上 &lt;strong>故障转移&lt;/strong> 才可以！ 所谓&lt;strong>故障转移&lt;/strong>，简单来说就是&lt;strong>实现不可用服务快速且自动地切换到可用服务&lt;/strong>，整个&lt;strong>过程不需要人为干涉&lt;/strong>。&lt;/p>
&lt;p>举个例子：哨兵模式的 Redis 集群中，&lt;strong>如果 Sentinel（哨兵） 检测到 master 节点出现故障的话， 它就会帮助我们实现故障转移，自动将某一台 slave 升级为 master&lt;/strong>，确保整个 Redis 系统的可用性。整个过程完全自动，不需要人工介入。我在&lt;a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7">《Java 面试指北》&lt;/a>的「技术面试题篇」中的数据库部分详细介绍了 Redis 集群相关的知识点&amp;amp;面试题，感兴趣的小伙伴可以看看。&lt;/p>
&lt;p>再举个例子：&lt;strong>Nginx 可以结合 Keepalived 来实现高可用。如果 Nginx 主服务器宕机的话，Keepalived 可以自动进行故障转移，备用 Nginx 主服务器升级为主服务。并且，这个切换对外是透明的，因为使用的虚拟 IP，虚拟 IP 不会改变&lt;/strong>。我在&lt;a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7">《Java 面试指北》&lt;/a>的「技术面试题篇」中的「服务器」部分详细介绍了 Nginx 相关的知识点&amp;amp;面试题，感兴趣的小伙伴可以看看。&lt;/p>
&lt;p>&lt;strong>异地多活&lt;/strong>架构实施起来非常难，需要考虑的因素非常多。本人不才，实际项目中并没有实践过异地多活架构，我对其了解还停留在书本知识。&lt;/p></description></item><item><title>高可用系统设计指南</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly01ly_high-availability-system-design/</link><pubDate>Thu, 16 Feb 2023 15:43:06 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyfly_high-availability/ly01ly_high-availability-system-design/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="什么是高可用可用性的判断标准是啥">
 什么是高可用？可用性的判断标准是啥？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e9%ab%98%e5%8f%af%e7%94%a8%e5%8f%af%e7%94%a8%e6%80%a7%e7%9a%84%e5%88%a4%e6%96%ad%e6%a0%87%e5%87%86%e6%98%af%e5%95%a5">#&lt;/a>
&lt;/h2>
&lt;p>高可用描述的是&lt;strong>一个系统在大部分时间都是可用的&lt;/strong>，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，&lt;strong>服务仍然是可用的&lt;/strong>。&lt;/p>
&lt;p>一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。&lt;/p>
&lt;p>除此之外，系统的可用性还可以用&lt;strong>某功能的失败次数&lt;/strong>与&lt;strong>总的请求次数&lt;/strong>之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。&lt;/p>
&lt;h2 id="哪些情况会导致系统不可用">
 哪些情况会导致系统不可用？
 &lt;a class="anchor" href="#%e5%93%aa%e4%ba%9b%e6%83%85%e5%86%b5%e4%bc%9a%e5%af%bc%e8%87%b4%e7%b3%bb%e7%bb%9f%e4%b8%8d%e5%8f%af%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>黑客攻击；&lt;/li>
&lt;li>&lt;strong>硬件故障&lt;/strong>，比如服务器坏掉。&lt;/li>
&lt;li>&lt;strong>并发量/用户请求量激增&lt;/strong>导致整个服务宕掉或者部分服务不可用。&lt;/li>
&lt;li>代码中的坏味道导致内存泄漏或者其他问题导致&lt;strong>程序挂掉&lt;/strong>。&lt;/li>
&lt;li>网站架构某个&lt;strong>重要的角色&lt;/strong>比如 &lt;strong>Nginx&lt;/strong> 或者&lt;strong>数据库&lt;/strong>突然不可用。&lt;/li>
&lt;li>自然灾害或者&lt;strong>人为破坏&lt;/strong>。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ol>
&lt;h2 id="有哪些提高系统可用性的方法">
 有哪些提高系统可用性的方法？
 &lt;a class="anchor" href="#%e6%9c%89%e5%93%aa%e4%ba%9b%e6%8f%90%e9%ab%98%e7%b3%bb%e7%bb%9f%e5%8f%af%e7%94%a8%e6%80%a7%e7%9a%84%e6%96%b9%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;h3 id="注重代码质量测试严格把关">
 注重代码质量，测试严格把关
 &lt;a class="anchor" href="#%e6%b3%a8%e9%87%8d%e4%bb%a3%e7%a0%81%e8%b4%a8%e9%87%8f%e6%b5%8b%e8%af%95%e4%b8%a5%e6%a0%bc%e6%8a%8a%e5%85%b3">#&lt;/a>
&lt;/h3>
&lt;p>我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 &lt;strong>CodeReview&lt;/strong>，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！&lt;/p>
&lt;p>另外，安利几个对提高代码质量有实际效果的神器：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.sonarqube.org/">Sonarqube&lt;/a>；&lt;/li>
&lt;li>Alibaba 开源的 Java 诊断工具 &lt;a href="https://arthas.aliyun.com/doc/">Arthas&lt;/a>；&lt;/li>
&lt;li>&lt;a href="https://github.com/alibaba/p3c">阿里巴巴 Java 代码规范&lt;/a>（Alibaba Java Code Guidelines）；&lt;/li>
&lt;li>IDEA 自带的代码分析等工具。&lt;/li>
&lt;/ul>
&lt;h3 id="使用集群减少单点故障">
 使用集群，减少单点故障
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8%e9%9b%86%e7%be%a4%e5%87%8f%e5%b0%91%e5%8d%95%e7%82%b9%e6%95%85%e9%9a%9c">#&lt;/a>
&lt;/h3>
&lt;p>先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用&lt;strong>集群&lt;/strong>，&lt;strong>避免单点故障&lt;/strong>。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例挂了，不到一秒就会有另外一台 Redis 实例顶上。&lt;/p></description></item><item><title>rocketmq常见面试题</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-questions/</link><pubDate>Wed, 15 Feb 2023 09:58:47 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-questions/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>本文来自读者 &lt;a href="https://github.com/Snailclimb/JavaGuide/pull/291">PR&lt;/a>。&lt;/p>
&lt;blockquote>
&lt;p>主要是rocket mq的几个问题&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;h2 id="1-单机版消息中心">
 1 单机版消息中心
 &lt;a class="anchor" href="#1-%e5%8d%95%e6%9c%ba%e7%89%88%e6%b6%88%e6%81%af%e4%b8%ad%e5%bf%83">#&lt;/a>
&lt;/h2>
&lt;p>一个消息中心，最基本的需要支持多生产者、多消费者，例如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Scratch&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 实际中会有 nameserver 服务来找到 broker 具体位置以及 broker 主从信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Broker broker &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Broker();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Producer producer1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Producer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> producer1.&lt;span style="color:#a6e22e">connectBroker&lt;/span>(broker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Producer producer2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Producer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> producer2.&lt;span style="color:#a6e22e">connectBroker&lt;/span>(broker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Consumer consumer1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Consumer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer1.&lt;span style="color:#a6e22e">connectBroker&lt;/span>(broker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Consumer consumer2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Consumer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer2.&lt;span style="color:#a6e22e">connectBroker&lt;/span>(broker);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 2; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> producer1.&lt;span style="color:#a6e22e">asyncSendMsg&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;producer1 send msg&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> producer2.&lt;span style="color:#a6e22e">asyncSendMsg&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;producer2 send msg&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;broker has msg:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> broker.&lt;span style="color:#a6e22e">getAllMagByDisk&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 1; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;consumer1 consume msg：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> consumer1.&lt;span style="color:#a6e22e">syncPullMsg&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 3; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;consumer2 consume msg：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> consumer2.&lt;span style="color:#a6e22e">syncPullMsg&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Producer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Broker broker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">connectBroker&lt;/span>(Broker broker) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">broker&lt;/span> &lt;span style="color:#f92672">=&lt;/span> broker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">asyncSendMsg&lt;/span>(String msg) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (broker &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;please connect broker first&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> broker.&lt;span style="color:#a6e22e">sendMsg&lt;/span>(msg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }).&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Consumer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Broker broker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">connectBroker&lt;/span>(Broker broker) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">broker&lt;/span> &lt;span style="color:#f92672">=&lt;/span> broker;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">syncPullMsg&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> broker.&lt;span style="color:#a6e22e">getMsg&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Broker&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 对应 RocketMQ 中 MessageQueue，默认情况下 1 个 Topic 包含 4 个 MessageQueue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> LinkedBlockingQueue&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> messageQueue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LinkedBlockingQueue(Integer.&lt;span style="color:#a6e22e">MAX_VALUE&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 实际发送消息到 broker 服务器使用 Netty 发送&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sendMsg&lt;/span>(String msg) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> messageQueue.&lt;span style="color:#a6e22e">put&lt;/span>(msg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 实际会同步或异步落盘，异步落盘使用的定时任务定时扫描落盘&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getMsg&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> messageQueue.&lt;span style="color:#a6e22e">take&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getAllMagByDisk&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringBuilder sb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder(&lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> messageQueue.&lt;span style="color:#a6e22e">iterator&lt;/span>().&lt;span style="color:#a6e22e">forEachRemaining&lt;/span>((msg) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sb.&lt;span style="color:#a6e22e">append&lt;/span>(msg &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sb.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>问题：&lt;/p></description></item><item><title>rocketmq介绍</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-intro/</link><pubDate>Wed, 15 Feb 2023 09:58:20 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/rocketmq-intro/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="消息队列扫盲">
 消息队列扫盲
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e6%89%ab%e7%9b%b2">#&lt;/a>
&lt;/h2>
&lt;p>消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道是啥吧？&lt;/p>
&lt;p>所以问题并不是消息队列是什么，而是 &lt;strong>消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？&lt;/strong>&lt;/p>
&lt;h3 id="消息队列为什么会出现-消息队列为什么会出现">
 &lt;a href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e5%87%ba%e7%8e%b0">#&lt;/a> 消息队列为什么会出现？
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e5%87%ba%e7%8e%b0-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e5%87%ba%e7%8e%b0">#&lt;/a>
&lt;/h3>
&lt;p>消息队列算是作为后端程序员的一个必备技能吧，因为&lt;strong>分布式应用必定涉及到各个系统之间的通信问题&lt;/strong>，这个时候消息队列也应运而生了。可以说&lt;strong>分布式&lt;/strong>的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的&lt;strong>中间件&lt;/strong>了。&lt;/p>
&lt;h3 id="消息队列能用来干什么-消息队列能用来干什么">
 &lt;a href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e8%83%bd%e7%94%a8%e6%9d%a5%e5%b9%b2%e4%bb%80%e4%b9%88">#&lt;/a> 消息队列能用来干什么？
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e8%83%bd%e7%94%a8%e6%9d%a5%e5%b9%b2%e4%bb%80%e4%b9%88-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e8%83%bd%e7%94%a8%e6%9d%a5%e5%b9%b2%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;h4 id="异步-异步">
 &lt;a href="#%e5%bc%82%e6%ad%a5">#&lt;/a> 异步
 &lt;a class="anchor" href="#%e5%bc%82%e6%ad%a5-%e5%bc%82%e6%ad%a5">#&lt;/a>
&lt;/h4>
&lt;p>你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么&lt;strong>中间非要插一个消息队列&lt;/strong>呢？我不能直接进行通信吗？&lt;/p>
&lt;p>很好👍，你又提出了一个概念，&lt;strong>同步通信&lt;/strong>。就比如现在业界使用比较多的 &lt;code>Dubbo&lt;/code> 就是一个适用于各个系统之间&lt;strong>同步通信的 &lt;code>RPC&lt;/code> 框架&lt;/strong>。&lt;/p>
&lt;p>我来举个🌰吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142042093.jpg" alt="img" />&lt;/p>
&lt;p>我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。&lt;/p>
&lt;p>当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短信系统这玩意又不是很有必要，它仅仅是一个&lt;strong>辅助功能增强用户体验感&lt;/strong>而已。我现在整个调用流程就有点 &lt;strong>头重脚轻&lt;/strong> 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142042330.jpg" alt="img" />&lt;/p>
&lt;p>这样&lt;strong>整个系统的调用链又变长&lt;/strong>了，整个时间就变成了550ms。&lt;/p>
&lt;p>当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。&lt;/p>
&lt;p>我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦😋😋😋” 咦~~~ 为了多吃点，真恶心。&lt;/p>
&lt;p>然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。&lt;/p>
&lt;p>最终我们从大妈手中接过饭菜然后去寻找座位了&amp;hellip;&lt;/p>
&lt;p>回想一下，我们在给大妈发送需要的信息之后我们是 &lt;strong>同步等待大妈给我配好饭菜&lt;/strong> 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142042452.jpg" alt="img" />&lt;/p>
&lt;p>那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 &lt;strong>(传达一个消息)&lt;/strong> ，然后我们就可以在饭桌上安心的玩手机了 &lt;strong>(干自己其他事情)&lt;/strong> ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以干其他事情了，这是一个 &lt;strong>异步&lt;/strong> 的概念。&lt;/p>
&lt;p>所以，为了解决这一个问题，聪明的程序员在中间也加了个类似于服务员的中间件——消息队列。这个时候我们就可以把模型给改造了。&lt;/p>
&lt;p>&lt;img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38124f55eaea.jpg" alt="img" />&lt;/p>
&lt;p>这样，我们在将消息存入消息队列之后我们就可以直接返回了(我们告诉服务员我们要吃什么然后玩手机)，所以整个耗时只是 &lt;strong>150ms + 10ms = 160ms&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>但是你需要注意的是，整个流程的时长是没变的，就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的。&lt;/p></description></item><item><title>message-queue</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/base/</link><pubDate>Wed, 15 Feb 2023 09:56:36 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyely_high-performance/message-mq/base/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>“RabbitMQ？”“Kafka？”“RocketMQ？”&amp;hellip;在日常学习与开发过程中，我们常常听到消息队列这个关键词。我也在我的多篇文章中提到了这个概念。可能你是熟练使用消息队列的老手，又或者你是不懂消息队列的新手，不论你了不了解消息队列，本文都将带你搞懂消息队列的一些&lt;strong>基本理论&lt;/strong>。&lt;/p>
&lt;p>如果你是老手，你可能从本文学到你之前不曾注意的一些关于消息队列的重要概念，如果你是新手，相信本文将是你打开消息队列大门的一板砖。&lt;/p>
&lt;h2 id="什么是消息队列">
 什么是消息队列？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97">#&lt;/a>
&lt;/h2>
&lt;p>我们可以把消息队列看作是一个&lt;strong>存放消息的容器&lt;/strong>，当我们需要使用消息的时候，直接&lt;strong>从容器中取出消息&lt;/strong>供自己使用即可。由于队列 Queue 是一种&lt;strong>先进先出&lt;/strong>的数据结构，所以消费消息时也是&lt;strong>按照顺序来消费&lt;/strong>的。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142040452.jpg" alt="Message queue" />&lt;/p>
&lt;p>参与消息传递的双方称为&lt;strong>生产者&lt;/strong>和&lt;strong>消费者&lt;/strong>，生产者负责&lt;strong>发送&lt;/strong>消息，消费者负责&lt;strong>处理&lt;/strong>消息。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142040705.png" alt="发布/订阅（Pub/Sub）模型" />&lt;/p>
&lt;p>我们知道操作系统中的进程通信的一种很重要的方式就是消息队列。我们这里提到的&lt;strong>消息队列&lt;/strong>稍微有点区别，更多指的是&lt;strong>各个服务&lt;/strong>以及&lt;strong>系统内部各个组件&lt;/strong>/&lt;strong>模块&lt;/strong>之前的通信，属于一种&lt;strong>中间件&lt;/strong>。&lt;/p>
&lt;p>随着分布式和微服务系统的发展，消息队列在系统设计中有了&lt;strong>更大的发挥&lt;/strong>空间，使用消息队列可以&lt;strong>降低系统耦合性&lt;/strong>、&lt;strong>实现任务异步&lt;/strong>、&lt;strong>有效地进行流量削峰&lt;/strong>，是分布式和微服务系统中重要的组件之一。&lt;/p>
&lt;h2 id="消息队列有什么用">
 消息队列有什么用？
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;p>通常来说，使用消息队列能为我们的系统带来下面三点好处：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>通过异步处理提高系统性能（减少响应所需时间）。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>削峰/限流&lt;/strong>&lt;/li>
&lt;li>&lt;strong>降低系统耦合性。&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的&lt;strong>简历上涉及到消息队列&lt;/strong>这方面的内容，这个时候推荐&lt;strong>你结合你自己的项目&lt;/strong>来回答。&lt;/p>
&lt;h3 id="通过异步处理提高系统性能减少响应所需时间">
 通过异步处理提高系统性能（减少响应所需时间）
 &lt;a class="anchor" href="#%e9%80%9a%e8%bf%87%e5%bc%82%e6%ad%a5%e5%a4%84%e7%90%86%e6%8f%90%e9%ab%98%e7%b3%bb%e7%bb%9f%e6%80%a7%e8%83%bd%e5%87%8f%e5%b0%91%e5%93%8d%e5%ba%94%e6%89%80%e9%9c%80%e6%97%b6%e9%97%b4">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="img/ly-20241212142040821.png" alt="ly-20241212142040821" />&lt;/p>
&lt;p>将用户的请求数据&lt;strong>存储到消息队列之后就立即返回结果&lt;/strong>。随后，系统再对消息进行消费。&lt;/p>
&lt;p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的&lt;strong>业务校验&lt;/strong>、&lt;strong>写数据库&lt;/strong>等操作中&lt;strong>可能失败&lt;/strong>。因此，&lt;strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合&lt;/strong>，比如用户在提交订单之后，订单数据写入消息队列，&lt;strong>不能立即返回用户订单提交成功&lt;/strong>，需要在消息队列的订单&lt;strong>消费者进程真正处理完该订单之后&lt;/strong>，甚至&lt;strong>出库&lt;/strong>后，再通过电子邮件或短信通知用户订单成功，&lt;strong>以免交易纠纷&lt;/strong>。这就类似我们平时手机订火车票和电影票。&lt;/p>
&lt;h3 id="削峰限流">
 削峰/限流
 &lt;a class="anchor" href="#%e5%89%8a%e5%b3%b0%e9%99%90%e6%b5%81">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。&lt;/strong>&lt;/p>
&lt;p>举例：在电子商务一些&lt;strong>秒杀&lt;/strong>、&lt;strong>促销&lt;/strong>活动中，合理使用消息队列可以&lt;strong>有效抵御促销活动&lt;/strong>刚开始大量订单涌入对系统的冲击。如下图所示：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142040941.jpg" alt="削峰" />&lt;/p>
&lt;h3 id="降低系统耦合性">
 降低系统耦合性
 &lt;a class="anchor" href="#%e9%99%8d%e4%bd%8e%e7%b3%bb%e7%bb%9f%e8%80%a6%e5%90%88%e6%80%a7">#&lt;/a>
&lt;/h3>
&lt;p>使用消息队列还可以降低系统耦合性。我们知道如果&lt;strong>模块之间不存在直接调用&lt;/strong>，那么新增模块或者修改模块就对其他模块影响较小，这样系统的&lt;strong>可扩展性&lt;/strong>无疑更好一些。还是直接上图吧：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142041055.jpg" alt="解耦" />&lt;/p>
&lt;p>&lt;strong>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息&lt;/strong>，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。&lt;/p>
&lt;p>&lt;strong>消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。&lt;/strong> 从上图可以看到&lt;strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合&lt;/strong>，消息发送者将消息&lt;strong>发送至分布式消息队列即结束&lt;/strong>对消息的处理，消息接受者&lt;strong>从分布式消息队列获取该消息后进行后续处理&lt;/strong>，并不需要知道该消息从何而来。&lt;strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计&lt;/strong>。&lt;/p>
&lt;p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息&lt;strong>继续发送出去，等待其他消息接受者订阅该消息&lt;/strong>。因此&lt;strong>基于事件（消息对象）驱动的业务架构&lt;/strong>可以是一系列流程。&lt;/p>
&lt;p>另外，为了&lt;strong>避免消息队列服务器宕机&lt;/strong>造成消息丢失，会将成功发送到消息队列的消息&lt;strong>存储在消息生产者服务器上&lt;/strong>，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，&lt;strong>生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>备注：&lt;/strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了&lt;strong>发布-订阅&lt;/strong>模式，还有&lt;strong>点对点订阅&lt;/strong>模式（&lt;strong>一个消息只有一个消费者&lt;/strong>），我们比较常用的是发布-订阅模式。另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。&lt;/p>
&lt;h2 id="使用消息队列哪些问题">
 使用消息队列哪些问题？
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>系统可用性降低：&lt;/strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你&lt;strong>不用考虑消息丢失或者说 MQ 挂掉&lt;/strong>等等的情况，但是，引入 MQ 之后你就需要去考虑了！&lt;/li>
&lt;li>&lt;strong>系统复杂性提高：&lt;/strong> 加入 MQ 之后，你需要保证消息没有被&lt;strong>重复消费&lt;/strong>、处理&lt;strong>消息丢失&lt;/strong>的情况、保证&lt;strong>消息传递&lt;/strong>的顺序性等等问题！&lt;/li>
&lt;li>&lt;strong>一致性问题：&lt;/strong> 我上面讲了消息队列可以实现&lt;strong>异步&lt;/strong>，消息队列带来的异步确实可以提高系统响应速度。但是，&lt;strong>万一消息的真正消费者并没有正确消费消息&lt;/strong>怎么办？这样就会导致数据不一致的情况了!&lt;/li>
&lt;/ul>
&lt;h2 id="jms-和-amqp">
 JMS 和 AMQP
 &lt;a class="anchor" href="#jms-%e5%92%8c-amqp">#&lt;/a>
&lt;/h2>
&lt;h3 id="jms-是什么">
 JMS 是什么？
 &lt;a class="anchor" href="#jms-%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>JMS（JAVA Message Service,java 消息服务）是 java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。&lt;strong>JMS（JAVA Message Service，Java 消息服务）API 是一个消息服务的标准或者说是规范&lt;/strong>，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。&lt;/p></description></item><item><title>cdn</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyely_high-performance/ly02ly_cdn/</link><pubDate>Tue, 14 Feb 2023 16:57:38 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyely_high-performance/ly02ly_cdn/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="什么是-cdn-">
 什么是 CDN ？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-cdn-">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>CDN&lt;/strong> 全称是 Content Delivery Network/&lt;strong>Content Distribution Network&lt;/strong>，翻译过的意思是 &lt;strong>内容分发网络&lt;/strong> 。&lt;/p>
&lt;p>我们可以将内容分发网络拆开来看：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>内容&lt;/strong> ：指的是&lt;strong>静态资源&lt;/strong>比如图片、视频、文档、JS、CSS、HTML。&lt;/li>
&lt;li>&lt;strong>分发网络&lt;/strong> ：指的是将这些静态资源&lt;strong>分发到位于多个不同的地理位置机房中的服务器&lt;/strong>上，这样，就可以实现静态资源的&lt;strong>就近访问&lt;/strong>比如北京的用户直接访问北京机房的数据。&lt;/li>
&lt;/ul>
&lt;p>所以，简单来说，&lt;strong>CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。&lt;/strong>&lt;/p>
&lt;p>类似于京东建立的庞大的仓储运输体系，京东物流在全国拥有非常多的仓库，仓储网络几乎覆盖全国所有区县。这样的话，用户下单的第一时间，商品就从距离用户最近的仓库，直接发往对应的配送站，再由京东小哥送到你家。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142039678.jpg" alt="京东仓配系统" />&lt;/p>
&lt;p>你可以将 CDN 看作是服务上一层的特殊缓存服务，分布在全国各地，主要用来处理静态资源的请求。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142039917.jpg" alt="CDN 简易示意图" />&lt;/p>
&lt;p>我们经常拿&lt;strong>全站加速&lt;/strong>和&lt;strong>内容分发&lt;/strong>网络做对比，不要把两者搞混了！全站加速（不同云服务商叫法不同，腾讯云叫 ECDN、阿里云叫 DCDN）既可以加速&lt;strong>静态资源&lt;/strong>又可以加速&lt;strong>动态资源&lt;/strong>，**内容分发网络（CDN）**主要针对的是 &lt;strong>静态资源&lt;/strong> 。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142040034.png" alt="ly-20241212142040034" />&lt;/p>
&lt;p>绝大部分公司都会在项目开发中交使用 &lt;strong>CDN 服务&lt;/strong>，但很少会有自建 CDN 服务的公司。基于&lt;strong>成本、稳定性和易用性&lt;/strong>考虑，建议&lt;strong>直接选择专业的云厂商&lt;/strong>（比如阿里云、腾讯云、华为云、青云）或者 CDN 厂商（比如网宿、蓝汛）提供的开箱即用的 CDN 服务。&lt;/p>
&lt;p>很多朋友可能要问了：&lt;strong>既然是就近访问，为什么不直接将服务部署在多个不同的地方呢？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>成本太高&lt;/strong>，需要部署多份相同的服务。&lt;/li>
&lt;li>静态资源通常占用空间比较大且经常会被访问到，如果直接使用&lt;strong>服务器或者缓存&lt;/strong>来处理静态资源请求的话，对&lt;strong>系统资源消耗非常大&lt;/strong>，可能会影响到系统其他服务的正常运行。&lt;/li>
&lt;/ul>
&lt;p>同一个服务在在多个不同的地方部署多份（比如&lt;strong>同城灾备&lt;/strong>、&lt;strong>异地灾备&lt;/strong>、&lt;strong>同城多活&lt;/strong>、&lt;strong>异地多活&lt;/strong>）是为了实现系统的高可用而不是就近访问。&lt;/p>
&lt;h2 id="cdn-工作原理是什么">
 CDN 工作原理是什么？
 &lt;a class="anchor" href="#cdn-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>搞懂下面 3 个问题也就搞懂了 CDN 的工作原理：&lt;/p>
&lt;ol>
&lt;li>静态资源是如何被缓存到 CDN 节点中的？&lt;/li>
&lt;li>如何找到最合适的 CDN 节点？&lt;/li>
&lt;li>如何防止静态资源被盗用？&lt;/li>
&lt;/ol>
&lt;h3 id="静态资源是如何被缓存到-cdn-节点中的">
 静态资源是如何被缓存到 CDN 节点中的？
 &lt;a class="anchor" href="#%e9%9d%99%e6%80%81%e8%b5%84%e6%ba%90%e6%98%af%e5%a6%82%e4%bd%95%e8%a2%ab%e7%bc%93%e5%ad%98%e5%88%b0-cdn-%e8%8a%82%e7%82%b9%e4%b8%ad%e7%9a%84">#&lt;/a>
&lt;/h3>
&lt;p>你可以通过&lt;strong>预热&lt;/strong>的方式将源站的资源同步到 CDN 的节点中。这样的话，用户&lt;strong>首次请求资源&lt;/strong>可以直接从 CDN 节点中取，无需回源。这样可以降低源站压力，提升用户体验。&lt;/p></description></item><item><title>数据库读写分离&amp;分库分表详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyely_high-performance/ly01ly_read-and-write-separation-and-library-subtable/</link><pubDate>Tue, 14 Feb 2023 16:38:42 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyely_high-performance/ly01ly_read-and-write-separation-and-library-subtable/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="读写分离">
 读写分离
 &lt;a class="anchor" href="#%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是读写分离">
 什么是读写分离？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb">#&lt;/a>
&lt;/h3>
&lt;p>见名思意，根据读写分离的名字，我们就可以知道：&lt;strong>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。&lt;/strong> 这样的话，就能够&lt;strong>小幅提升写&lt;/strong>性能，&lt;strong>大幅提升读&lt;/strong>性能。&lt;/p>
&lt;p>我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142038662.png" alt="ly-20241212142038662" />&lt;/p>
&lt;p>一般情况下，我们都会选择&lt;strong>一主多从&lt;/strong>，也就是一台&lt;strong>主数据库负责写&lt;/strong>，其他的&lt;strong>从数据库负责读&lt;/strong>。主库和从库之间会进行数据&lt;strong>同步&lt;/strong>，以保证&lt;strong>从库&lt;/strong>中数据的&lt;strong>准确性&lt;/strong>。这样的架构实现起来比较&lt;strong>简单&lt;/strong>，并且也&lt;strong>符合系统的写少读多&lt;/strong>的特点。&lt;/p>
&lt;h3 id="读写分离会带来什么问题如何解决">
 读写分离会带来什么问题？如何解决？
 &lt;a class="anchor" href="#%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb%e4%bc%9a%e5%b8%a6%e6%9d%a5%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3">#&lt;/a>
&lt;/h3>
&lt;p>读写分离对于提升数据库的并发非常有效，但是，同时也会引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 &lt;strong>主从同步延迟&lt;/strong> 。&lt;/p>
&lt;p>主从同步延迟问题的解决，没有特别好的一种方案（可能是我太菜了，欢迎评论区补充）。你可以根据自己的业务场景，参考一下下面几种解决办法。&lt;/p>
&lt;p>&lt;strong>1.强制将读请求路由到主库处理。&lt;/strong>&lt;/p>
&lt;p>既然你从库的数据过期了，那我就&lt;strong>直接从主库读取&lt;/strong>嘛！这种方案虽然会增加主库的压力，但是，实现起来比较简单，也是我了解到的使用最多的一种方式。&lt;/p>
&lt;p>比如 &lt;strong>&lt;code>Sharding-JDBC&lt;/code>&lt;/strong> 就是采用的这种方案。通过使用 Sharding-JDBC 的 &lt;strong>&lt;code>HintManager&lt;/code> 分片键值管理器&lt;/strong>，我们可以&lt;strong>强制使用主库&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>HintManager hintManager &lt;span style="color:#f92672">=&lt;/span> HintManager.&lt;span style="color:#a6e22e">getInstance&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hintManager.&lt;span style="color:#a6e22e">setMasterRouteOnly&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 继续JDBC操作&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于这种方案，你可以将那些必须获取最新数据的读请求都交给主库处理。&lt;/p>
&lt;p>&lt;strong>2.延迟读取。&lt;/strong>&lt;/p>
&lt;p>还有一些朋友肯定会想既然主从同步存在延迟，那我就在&lt;strong>延迟之后读取&lt;/strong>啊，比如主从同步延迟 0.5s,那我就 1s 之后再读取数据。这样多方便啊！方便是方便，但是也很扯淡。&lt;/p>
&lt;p>不过，如果你是这样设计业务流程就会好很多：对于一些&lt;strong>对数据比较敏感&lt;/strong>的场景，你可以在&lt;strong>完成写请求之后&lt;/strong>，&lt;strong>避免立即&lt;/strong>进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。&lt;/p>
&lt;p>另外，&lt;a href="https://time.geekbang.org/column/intro/100020801?code=ieY8HeRSlDsFbuRtggbBQGxdTh-1jMASqEIeqzHAKrI%3D">《MySQL 实战 45 讲》&lt;/a>这个专栏中的&lt;a href="https://time.geekbang.org/column/article/77636">《读写分离有哪些坑？》&lt;/a>这篇文章还介绍了很多其他比较实际的解决办法，感兴趣的小伙伴可以自行研究一下。&lt;/p>
&lt;h3 id="如何实现读写分离">
 如何实现读写分离？
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb">#&lt;/a>
&lt;/h3>
&lt;p>不论是使用哪一种读写分离具体的实现方案，想要&lt;strong>实现读写分离&lt;/strong>一般包含如下几步：&lt;/p>
&lt;ol>
&lt;li>部署多台数据库，选择&lt;strong>其中的一台作为主&lt;/strong>数据库，&lt;strong>其他&lt;/strong>的一台或者多台&lt;strong>作为从&lt;/strong>数据库。&lt;/li>
&lt;li>&lt;strong>保证&lt;/strong>主数据库和从数据库之间的数据是&lt;strong>实时同步&lt;/strong>的，这个过程也就是我们常说的&lt;strong>主从复制&lt;/strong>。&lt;/li>
&lt;li>系统将&lt;strong>写请求交给主&lt;/strong>数据库处理，读请求交给从数据库处理。[ 使用上 ]&lt;/li>
&lt;/ol>
&lt;p>落实到项目本身的话，常用的方式有两种：&lt;/p>
&lt;p>&lt;strong>1.代理方式&lt;/strong>&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142038906.png" alt="ly-20241212142038906" />&lt;/p>
&lt;p>我们可以在&lt;strong>应用&lt;/strong>和&lt;strong>数据&lt;/strong>中间&lt;strong>加了一个代理层&lt;/strong>。&lt;strong>应用&lt;/strong>程序所有的&lt;strong>数据请求都交给代理层&lt;/strong>处理，代理层负责&lt;strong>分离读写&lt;/strong>请求，将它们&lt;strong>路由到对应的数据库&lt;/strong>中。&lt;/p>
&lt;p>提供类似功能的中间件有 &lt;strong>MySQL Router&lt;/strong>（官方）、&lt;strong>Atlas&lt;/strong>（基于 MySQL Proxy）、&lt;strong>Maxscale&lt;/strong>、&lt;strong>MyCat&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>2.组件方式&lt;/strong>&lt;/p>
&lt;p>在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。&lt;/p>
&lt;p>这也是我&lt;strong>比较推荐&lt;/strong>的一种方式。这种方式目前在各种互联网公司中&lt;strong>用的最多&lt;/strong>的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 &lt;strong>&lt;code>sharding-jdbc&lt;/code>&lt;/strong> ，&lt;strong>直接引入 jar&lt;/strong> 包即可使用，非常方便。同时，也&lt;strong>节省了很多运维的成本&lt;/strong>。&lt;/p></description></item><item><title>zookeeper实战</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly08ly_zookeeper-in-action/</link><pubDate>Tue, 14 Feb 2023 10:45:39 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly08ly_zookeeper-in-action/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-前言">
 1. 前言
 &lt;a class="anchor" href="#1-%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>这篇文章简单给演示一下 ZooKeeper 常见命令的使用以及 ZooKeeper Java客户端 Curator 的基本使用。介绍到的内容都是最基本的操作，能满足日常工作的基本需要。&lt;/p>
&lt;p>如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！&lt;/p>
&lt;h2 id="2-zookeeper-安装和使用">
 2. ZooKeeper 安装和使用
 &lt;a class="anchor" href="#2-zookeeper-%e5%ae%89%e8%a3%85%e5%92%8c%e4%bd%bf%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;h3 id="21-使用docker-安装-zookeeper">
 2.1. 使用Docker 安装 zookeeper
 &lt;a class="anchor" href="#21-%e4%bd%bf%e7%94%a8docker-%e5%ae%89%e8%a3%85-zookeeper">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>a.使用 Docker 下载 ZooKeeper&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker pull zookeeper:3.5.8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>b.运行 ZooKeeper&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -d --name zookeeper -p 2181:2181 zookeeper:3.5.8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="22-连接-zookeeper-服务">
 2.2. 连接 ZooKeeper 服务
 &lt;a class="anchor" href="#22-%e8%bf%9e%e6%8e%a5-zookeeper-%e6%9c%8d%e5%8a%a1">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>a.进入ZooKeeper容器中&lt;/strong>&lt;/p>
&lt;p>先使用 &lt;code>docker ps&lt;/code> 查看 ZooKeeper 的 ContainerID，然后使用 &lt;code>docker exec -it ContainerID /bin/bash&lt;/code> 命令进入容器中。&lt;/p>
&lt;p>&lt;strong>b.先进入 bin 目录,然后通过 &lt;code>./zkCli.sh -server 127.0.0.1:2181&lt;/code>命令连接ZooKeeper 服务&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>root@eaf70fc620cb:/apache-zookeeper-3.5.8-bin# cd bin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你看到控制台成功打印出如下信息的话，说明你已经成功连接 ZooKeeper 服务。&lt;/p></description></item><item><title>zookeeper进阶</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly07ly_zookeeper-plus/</link><pubDate>Mon, 13 Feb 2023 17:30:07 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly07ly_zookeeper-plus/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;a href="https://juejin.im/user/5c33853851882525ea106810">FrancisQ&lt;/a> 投稿。&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-好久不见">
 1. 好久不见
 &lt;a class="anchor" href="#1-%e5%a5%bd%e4%b9%85%e4%b8%8d%e8%a7%81">#&lt;/a>
&lt;/h2>
&lt;p>离上一篇文章的发布也快一个月了，想想已经快一个月没写东西了，其中可能有期末考试、课程设计和驾照考试，但这都不是借口！&lt;/p>
&lt;p>一到冬天就懒的不行，望广大掘友督促我🙄🙄✍️✍️。&lt;/p>
&lt;blockquote>
&lt;p>文章很长，先赞后看，养成习惯。❤️ 🧡 💛 💚 💙 💜&lt;/p>
&lt;/blockquote>
&lt;h2 id="2-什么是zookeeper">
 2. 什么是ZooKeeper
 &lt;a class="anchor" href="#2-%e4%bb%80%e4%b9%88%e6%98%afzookeeper">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>ZooKeeper&lt;/code> 由 &lt;code>Yahoo&lt;/code> 开发，后来捐赠给了 &lt;code>Apache&lt;/code> ，现已成为 &lt;code>Apache&lt;/code> 顶级项目。&lt;code>ZooKeeper&lt;/code> 是一个开源的&lt;strong>分布式应用程序协调服务器&lt;/strong>，其为&lt;strong>分布式系统提供一致性&lt;/strong>服务。其一致性是通过基于 &lt;code>Paxos&lt;/code> 算法的 &lt;code>ZAB&lt;/code> 协议完成的。其主要功能包括：&lt;strong>配置维护&lt;/strong>、&lt;strong>分布式同步&lt;/strong>、&lt;strong>集群管理&lt;/strong>、&lt;strong>分布式事务&lt;/strong>等。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142035025.png" alt="ly-20241212142035025" />&lt;/p>
&lt;p>简单来说， &lt;code>ZooKeeper&lt;/code> 是一个 &lt;strong>分布式协调服务框架&lt;/strong> 。分布式？协调服务？这啥玩意？🤔🤔&lt;/p>
&lt;p>其实解释到分布式这个概念的时候，我发现有些同学并不是能把 &lt;strong>分布式和集群&lt;/strong> 这两个概念很好的理解透。前段时间有同学和我探讨起分布式的东西，他说分布式不就是加机器吗？一台机器不够用再加一台抗压呗。当然加机器这种说法也无可厚非，你一个分布式系统必定涉及到多个机器，但是你别忘了，计算机学科中还有一个相似的概念—— &lt;code>Cluster&lt;/code> ，集群不也是加机器吗？但是 &lt;strong>集群 和 分布式&lt;/strong> 其实就是两个&lt;strong>完全不同的概念&lt;/strong>。&lt;/p>
&lt;p>比如，我现在有一个秒杀服务，并发量太大单机系统承受不住，那我加几台服务器也 &lt;strong>一样&lt;/strong> 提供秒杀服务，这个时候就是 &lt;strong>&lt;code>Cluster&lt;/code> 集群&lt;/strong> 。&lt;/p>
&lt;p>&lt;a href="https://camo.githubusercontent.com/87c9624f298e404de4aa6387af959870f61d9461a2a60de3a31f5ee47385360d/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f66666362303830656236366632343266666364386432303437613766343661612e706e67">&lt;img src="img/ly-20241212142035275.jpg" alt="cluster" />&lt;/a>&lt;/p>
&lt;p>但是，我现在换一种方式，我将一个秒杀服务 &lt;strong>拆分成多个子服务&lt;/strong> ，比如创建订单服务，增加积分服务，扣优惠券服务等等，&lt;strong>然后我将这些子服务都部署在不同的服务器上&lt;/strong> ，这个时候就是 &lt;strong>&lt;code>Distributed&lt;/code> 分布式&lt;/strong> 。&lt;/p>
&lt;p>&lt;a href="https://camo.githubusercontent.com/d2c1c6b9feb20352ecfa8182cdb3058d7dd3ffeec287cc66286461ca34226323/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f30373139316633386161393437623030373565356330613661303139613131642e706e67">&lt;img src="img/ly-20241212142035394.jpg" alt="distributed" />&lt;/a>&lt;/p>
&lt;p>而我为什么反驳同学所说的分布式就是加机器呢？因为我认为加机器更加适用于构建&lt;strong>集群&lt;/strong>，因为它真是只有加机器。而对于分布式来说，你首先需要将&lt;strong>业务进行拆分&lt;/strong>，然后&lt;strong>再加机器&lt;/strong>（不仅仅是加机器那么简单），同时你还要去解决&lt;strong>分布式带来的一系列问题&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142035517.jpg" alt="img" />&lt;/p>
&lt;p>比如各个分布式组件&lt;strong>如何协调&lt;/strong>起来，如何&lt;strong>减少&lt;/strong>各个系统之间的&lt;strong>耦合度&lt;/strong>，&lt;strong>分布式事务&lt;/strong>的处理，如何去&lt;strong>配置整个分布式系统&lt;/strong>等等。&lt;code>ZooKeeper&lt;/code> 主要就是解决这些问题的。&lt;/p>
&lt;h2 id="3-一致性问题">
 3. 一致性问题
 &lt;a class="anchor" href="#3-%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142035639.png" alt="image.png" />&lt;/p></description></item><item><title>zookeeper介绍</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly06ly_zookeeper-intro/</link><pubDate>Mon, 13 Feb 2023 15:59:20 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly06ly_zookeeper-intro/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-前言">
 1. 前言
 &lt;a class="anchor" href="#1-%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>相信大家对 ZooKeeper 应该不算陌生。但是你真的了解 ZooKeeper 到底有啥用不？如果别人/面试官让你给他讲讲对于 ZooKeeper 的认识，你能回答到什么地步呢？&lt;/p>
&lt;p>拿我自己来说吧！我本人曾经使用 Dubbo 来做分布式项目的时候，使用了 ZooKeeper 作为&lt;strong>注册中心&lt;/strong>。为了保证分布式系统能够&lt;strong>同步访问某个资源&lt;/strong>，我还使用 ZooKeeper 做过&lt;strong>分布式锁&lt;/strong>。另外，我在学习 Kafka 的时候，知道 &lt;strong>Kafka&lt;/strong> 很多功能的实现&lt;strong>依赖了 ZooKeeper&lt;/strong>。&lt;/p>
&lt;p>前几天，总结项目经验的时候，我突然问自己 ZooKeeper 到底是个什么东西？想了半天，脑海中只是简单的能浮现出几句话：&lt;/p>
&lt;ol>
&lt;li>ZooKeeper 可以被用作&lt;strong>注册中心、分布式锁&lt;/strong>；&lt;/li>
&lt;li>ZooKeeper 是 &lt;strong>Hadoop 生态系统&lt;/strong>的一员；&lt;/li>
&lt;li>构建 ZooKeeper 集群的时候，使用的服务器最好是&lt;strong>奇数台&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>由此可见，我对于 ZooKeeper 的理解仅仅是停留在了表面。&lt;/p>
&lt;p>所以，通过本文，希望带大家稍微详细的了解一下 ZooKeeper 。如果没有学过 ZooKeeper ，那么本文将会是你进入 ZooKeeper 大门的垫脚砖。如果你已经接触过 ZooKeeper ，那么本文将带你回顾一下 ZooKeeper 的一些基础概念。&lt;/p>
&lt;p>另外，本文不光会涉及到 ZooKeeper 的一些概念，后面的文章会介绍到 ZooKeeper 常见命令的使用以及使用 Apache Curator 作为 ZooKeeper 的客户端。&lt;/p>
&lt;p>&lt;em>如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！&lt;/em>&lt;/p>
&lt;h2 id="2-zookeeper-介绍">
 2. ZooKeeper 介绍
 &lt;a class="anchor" href="#2-zookeeper-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;h3 id="21-zookeeper-由来">
 2.1. ZooKeeper 由来
 &lt;a class="anchor" href="#21-zookeeper-%e7%94%b1%e6%9d%a5">#&lt;/a>
&lt;/h3>
&lt;p>正式介绍 ZooKeeper 之前，我们先来看看 ZooKeeper 的由来，还挺有意思的。&lt;/p></description></item><item><title>rpc_http</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly04ly_rpc-http/</link><pubDate>Sat, 11 Feb 2023 19:59:58 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly04ly_rpc-http/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="img/ly-20241212142032772.png" alt="" />&lt;/p>
&lt;p>我正在参与掘金技术社区创作者签约计划招募活动，&lt;a href="https://juejin.cn/post/7112770927082864653">点击链接报名投稿&lt;/a>。&lt;/p>
&lt;p>我想起了我刚工作的时候，第一次接触RPC协议，当时就很懵，我HTTP协议用的好好的，为什么还要用RPC协议？&lt;/p>
&lt;p>于是就到网上去搜。&lt;/p>
&lt;p>不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在&lt;strong>用一个我们不认识的概念去解释另外一个我们不认识的概念&lt;/strong>，懂的人不需要看，不懂的人看了还是不懂。&lt;/p>
&lt;p>这种看了，又好像没看的感觉，云里雾里的很难受，&lt;strong>我懂&lt;/strong>。&lt;/p>
&lt;p>为了避免大家有强烈的&lt;strong>审丑疲劳&lt;/strong>，今天我们来尝试重新换个方式讲一讲。&lt;/p>
&lt;h3 id="从tcp聊起">
 从TCP聊起
 &lt;a class="anchor" href="#%e4%bb%8etcp%e8%81%8a%e8%b5%b7">#&lt;/a>
&lt;/h3>
&lt;p>作为一个程序员，假设我们需要在A电脑的进程发一段数据到B电脑的进程，我们一般会在代码里使用socket进行编程。&lt;/p>
&lt;p>这时候，我们可选项一般也就&lt;strong>TCP和UDP二选一。TCP可靠，UDP不可靠。&lt;/strong> 除非是马总这种神级程序员（早期QQ大量使用UDP），否则，只要稍微对可靠性有些要求，普通人一般无脑选TCP就对了。&lt;/p>
&lt;p>类似下面这样。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fd&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">socket(AF_INET,SOCK_STREAM,0);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">复制代码&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>SOCK_STREAM&lt;/code>，是指使用&lt;strong>字节流&lt;/strong>传输数据，说白了就是&lt;strong>TCP协议&lt;/strong>。&lt;/p>
&lt;p>在定义了socket之后，我们就可以愉快的对这个socket进行操作，比如用&lt;code>bind()&lt;/code>绑定IP端口，用&lt;code>connect()&lt;/code>发起建连。&lt;/p>
&lt;p>&lt;img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f410977cda814d32b0eff3645c385a8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="握手建立连接流程" />&lt;/p>
&lt;p>在连接建立之后，我们就可以使用&lt;code>send()&lt;/code>发送数据，&lt;code>recv()&lt;/code>接收数据。&lt;/p>
&lt;p>光这样一个纯裸的TCP连接，就可以做到收发数据了，那是不是就够了？&lt;/p>
&lt;p>不行，这么用会有问题。&lt;/p>
&lt;h3 id="使用纯裸tcp会有什么问题">
 使用纯裸TCP会有什么问题
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8%e7%ba%af%e8%a3%b8tcp%e4%bc%9a%e6%9c%89%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h3>
&lt;p>八股文常背，TCP是有三个特点，&lt;strong>面向连接&lt;/strong>、&lt;strong>可靠&lt;/strong>、基于&lt;strong>字节流&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acb4508111cb47d8a3df6734d04818bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="TCP是什么" />&lt;/p>
&lt;p>这三个特点真的概括的&lt;strong>非常精辟&lt;/strong>，这个八股文我们没白背。&lt;/p>
&lt;p>每个特点展开都能聊一篇文章，而今天我们需要关注的是&lt;strong>基于字节流&lt;/strong>这一点。&lt;/p>
&lt;p>字节流可以理解为一个双向的通道里流淌的数据，这个&lt;strong>数据&lt;/strong>其实就是我们常说的二进制数据，简单来说就是一大堆 &lt;strong>01 串&lt;/strong>。纯裸TCP收发的这些 01 串之间是&lt;strong>没有任何边界&lt;/strong>的，你根本不知道到哪个地方才算一条完整消息。
&lt;img src="img/ly-20241212142033022.png" alt="" />&lt;/p>
&lt;p>正因为这个没有&lt;strong>任何边界&lt;/strong>的特点，所以当我们选择使用TCP发送 &lt;strong>&amp;ldquo;夏洛&amp;quot;和&amp;quot;特烦恼&amp;rdquo;&lt;/strong> 的时候，接收端收到的就是 &lt;strong>&amp;ldquo;夏洛特烦恼&amp;rdquo;&lt;/strong> ，这时候接收端没发区分你是想要表达 &lt;strong>&amp;ldquo;夏洛&amp;rdquo;+&amp;ldquo;特烦恼&amp;rdquo;&lt;/strong> 还是 &lt;strong>&amp;ldquo;夏洛特&amp;rdquo;+&amp;ldquo;烦恼&amp;rdquo;&lt;/strong> 。&lt;/p>
&lt;p>&lt;img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e120d0f1152419585565f693e744a3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="消息对比" />&lt;/p>
&lt;p>这就是所谓的&lt;strong>粘包问题&lt;/strong>，之前也写过一篇专门的&lt;a href="https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F0-YBxU1cSbDdzcZEZjmQYA">文章&lt;/a>聊过这个问题。&lt;/p>
&lt;p>说这个的目的是为了告诉大家，纯裸TCP是不能直接拿来用的，你需要在这个基础上加入一些&lt;strong>自定义的规则&lt;/strong>，用于区分&lt;strong>消息边界&lt;/strong>。&lt;/p>
&lt;p>于是我们会把每条要发送的数据都包装一下，比如加入&lt;strong>消息头&lt;/strong>，&lt;strong>消息头里写清楚一个完整的包长度是多少&lt;/strong>，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的&lt;strong>消息体&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb29659d4907446e9f70551c44c6369f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="消息边界长度标志" />&lt;/p>
&lt;p>而这里头提到的&lt;strong>消息头&lt;/strong>，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的&lt;strong>协议。&lt;/strong>&lt;/p>
&lt;p>每个使用TCP的项目都可能会定义一套类似这样的协议解析标准，他们可能&lt;strong>有区别，但原理都类似&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>于是基于TCP，就衍生了非常多的协议，比如HTTP和RPC。&lt;/strong>&lt;/p>
&lt;h3 id="http和rpc">
 HTTP和RPC
 &lt;a class="anchor" href="#http%e5%92%8crpc">#&lt;/a>
&lt;/h3>
&lt;p>我们回过头来看网络的分层图。&lt;/p>
&lt;p>&lt;img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04b603b5bd2443209233deea87816161~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="四层网络协议" />&lt;/p>
&lt;p>&lt;strong>TCP是传输层的协议&lt;/strong>，而基于TCP造出来的HTTP和&lt;strong>各类&lt;/strong>RPC协议，它们都只是定义了不同消息格式的&lt;strong>应用层协议&lt;/strong>而已。&lt;/p>
&lt;p>&lt;strong>HTTP&lt;/strong>协议（&lt;strong>H&lt;/strong>yper &lt;strong>T&lt;/strong>ext &lt;strong>T&lt;/strong>ransfer &lt;strong>P&lt;/strong>rotocol），又叫做&lt;strong>超文本传输协议&lt;/strong>。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是HTTP协议。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142033146.png" alt="" />&lt;/p></description></item><item><title>rpc基础及面试题</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly05ly_rpc-intro/</link><pubDate>Sat, 11 Feb 2023 19:41:34 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly05ly_rpc-intro/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>简单介绍一下 RPC 相关的基础概念。&lt;/p>
&lt;h2 id="何为-rpc">
 何为 RPC?
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba-rpc">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>RPC（Remote Procedure Call）&lt;/strong> 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。&lt;/p>
&lt;p>&lt;strong>为什么要 RPC ？&lt;/strong> 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP还是UDP）、序列化方式等等方面。&lt;/p>
&lt;p>&lt;strong>RPC 能帮助我们做什么呢？&lt;/strong> 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。&lt;/p>
&lt;p>举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。&lt;/p>
&lt;p>一言蔽之：&lt;strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。&lt;/strong>&lt;/p>
&lt;h2 id="rpc-的原理是什么">
 RPC 的原理是什么?
 &lt;a class="anchor" href="#rpc-%e7%9a%84%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC的 核心功能看作是下面👇 5 个部分实现的：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>客户端（服务消费端）&lt;/strong> ：调用远程方法的一端。&lt;/li>
&lt;li>&lt;strong>客户端 Stub（桩）&lt;/strong> ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。&lt;/li>
&lt;li>&lt;strong>网络传输&lt;/strong> ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty（推荐）。&lt;/li>
&lt;li>&lt;strong>服务端 Stub（桩）&lt;/strong> ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。&lt;/li>
&lt;li>&lt;strong>服务端（服务提供端）&lt;/strong> ：提供远程方法的一端。&lt;/li>
&lt;/ol>
&lt;p>具体原理图如下，后面我会串起来将整个RPC的过程给大家说一下。&lt;/p>
&lt;p>&lt;a href="https://camo.githubusercontent.com/5e8198844ec97b718219e83fec147089c73daadc5c987752787bfa4d4d538c24/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31322d362f33373334353835312e6a7067">&lt;img src="img/ly-20241212142033652.jpg" alt="RPC原理图" />&lt;/a>&lt;/p>
&lt;ol>
&lt;li>服务消费端（client）以本地调用的方式调用远程服务；&lt;/li>
&lt;li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：&lt;code>RpcRequest&lt;/code>；&lt;/li>
&lt;li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；&lt;/li>
&lt;li>服务端 Stub（桩）收到消息将消息反序列化为Java对象: &lt;code>RpcRequest&lt;/code>；&lt;/li>
&lt;li>服务端 Stub（桩）根据&lt;code>RpcRequest&lt;/code>中的类、方法、方法参数等信息调用本地的方法；&lt;/li>
&lt;li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：&lt;code>RpcResponse&lt;/code>（序列化）发送至消费方；&lt;/li>
&lt;li>客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:&lt;code>RpcResponse&lt;/code> ，这样也就得到了最终结果。over!&lt;/li>
&lt;/ol>
&lt;p>相信小伙伴们看完上面的讲解之后，已经了解了 RPC 的原理。&lt;/p></description></item><item><title>分布式锁</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly03ly_distributed-lock/</link><pubDate>Sat, 11 Feb 2023 13:24:32 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly03ly_distributed-lock/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。&lt;/p>
&lt;h2 id="什么是分布式锁">
 什么是分布式锁？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81">#&lt;/a>
&lt;/h2>
&lt;p>对于单机多线程来说，在 Java 中，我们通常使用 &lt;code>ReetrantLock&lt;/code> 类、&lt;code>synchronized&lt;/code> 关键字这类 JDK 自带的 &lt;strong>本地锁&lt;/strong> 来控制&lt;strong>一个 JVM 进程&lt;/strong>内的&lt;strong>多个线程&lt;/strong>对&lt;strong>本地共享资源&lt;/strong>的访问。&lt;/p>
&lt;p>下面是我对本地锁画的一张示意图。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142031650.png" alt="ly-20241212142031650" />&lt;/p>
&lt;p>从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。&lt;/p>
&lt;p>&lt;strong>分布式系统&lt;/strong>下，&lt;strong>不同的服务/客户端&lt;/strong>通常&lt;strong>运行在独立的 JVM 进程&lt;/strong>上。如果&lt;strong>多个 JVM 进程共享同一份资源&lt;/strong>的话，使用&lt;strong>本地锁就没办法实现&lt;/strong>资源的互斥访问了。于是，&lt;strong>分布式锁&lt;/strong> 就诞生了。&lt;/p>
&lt;p>举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程&lt;strong>不在同一个 JVM 进程&lt;/strong>中也能&lt;strong>获取到同一把锁&lt;/strong>，进而实现&lt;strong>共享资源的互斥访问&lt;/strong>。&lt;/p>
&lt;p>下面是我对分布式锁画的一张示意图。&lt;/p>
&lt;p>&lt;a href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/distributed-system/images/distributed-lock/distributed-lock.png">&lt;img src="img/ly-20241212142031903.png" alt="分布式锁" />&lt;/a>&lt;/p>
&lt;p>从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，&lt;strong>同一时刻只有一个线程可以获取到分布式锁访问共享资源&lt;/strong>。&lt;/p>
&lt;p>一个最基本的分布式锁需要满足：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>互斥&lt;/strong> ：任意一个时刻，锁只能被一个线程持有；&lt;/li>
&lt;li>&lt;strong>高可用&lt;/strong> ：锁服务是高&lt;strong>可用&lt;/strong>的。并且，&lt;strong>即使客户端的释放锁的代码逻辑出现问题(这里说的是异常，不是说代码写的有问题)&lt;/strong>，锁最终&lt;strong>一定还是会被释放&lt;/strong>，&lt;strong>不会影响其他线程&lt;/strong>对共享资源的访问。&lt;/li>
&lt;li>&lt;strong>可重入&lt;/strong>：&lt;strong>(同)一个节点&lt;/strong>获取了锁之后，还可以&lt;strong>再次&lt;/strong>获取锁。&lt;/li>
&lt;/ul>
&lt;p>通常情况下，我们一般会选择基于 &lt;strong>Redis&lt;/strong> 或者 &lt;strong>ZooKeeper&lt;/strong> 实现分布式锁，Redis 用的要更多一点，我这里也以 Redis 为例介绍分布式锁的实现。&lt;/p>
&lt;h2 id="基于-redis-实现分布式锁">
 基于 Redis 实现分布式锁
 &lt;a class="anchor" href="#%e5%9f%ba%e4%ba%8e-redis-%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81">#&lt;/a>
&lt;/h2>
&lt;h3 id="如何基于-redis-实现一个最简易的分布式锁">
 如何基于 Redis 实现一个最简易的分布式锁？
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e5%9f%ba%e4%ba%8e-redis-%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e6%9c%80%e7%ae%80%e6%98%93%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81">#&lt;/a>
&lt;/h3>
&lt;p>不论是实现&lt;strong>锁(本地)&lt;strong>还是&lt;/strong>分布式锁&lt;/strong>，核心都在于**“互斥”**。&lt;/p>
&lt;p>在 Redis 中， &lt;code>SETNX&lt;/code> 命令是可以帮助我们实现互斥。&lt;code>SETNX&lt;/code> 即 &lt;strong>SET&lt;/strong> if &lt;strong>N&lt;/strong>ot e&lt;strong>X&lt;/strong>ists (对应 Java 中的 &lt;code>setIfAbsent&lt;/code> 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， &lt;code>SETNX&lt;/code> 啥也不做。&lt;/p></description></item><item><title>分布式id</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly02ly_distributed-id/</link><pubDate>Sat, 11 Feb 2023 13:00:31 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly02ly_distributed-id/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="分布式-id-介绍">
 分布式 ID 介绍
 &lt;a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f-id-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是-id">
 什么是 ID？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-id">#&lt;/a>
&lt;/h3>
&lt;p>日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。&lt;/p>
&lt;p>我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人、地址 ID 对应且仅对应&lt;/p>
&lt;p>简单来说，&lt;strong>ID 就是数据的唯一标识&lt;/strong>。&lt;/p>
&lt;h3 id="什么是分布式-id">
 什么是分布式 ID？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%88%86%e5%b8%83%e5%bc%8f-id">#&lt;/a>
&lt;/h3>
&lt;p>分布式 ID 是&lt;strong>分布式系统下的 ID&lt;/strong>。分布式 ID &lt;strong>不存在与现实生活中(属于技术上的问题，跟业务无关)&lt;/strong>，属于计算机系统中的一个概念。&lt;/p>
&lt;p>我简单举一个&lt;strong>分库分表&lt;/strong>的例子。&lt;/p>
&lt;p>我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 &lt;strong>Sharding-JDBC&lt;/strong>）。&lt;/p>
&lt;p>在分库之后， &lt;strong>数据遍布在不同服务器上的数据库&lt;/strong>，数据库的自增主键已经没办法满足生成的主键唯一了。&lt;strong>我们如何为不同的数据节点生成全局唯一主键呢？&lt;/strong>&lt;/p>
&lt;p>这个时候就需要生成&lt;strong>分布式 ID&lt;/strong>了。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142029621.png" alt="ly-20241212142029621" />&lt;/p>
&lt;h3 id="分布式-id-需要满足哪些要求">
 分布式 ID 需要满足哪些要求?
 &lt;a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f-id-%e9%9c%80%e8%a6%81%e6%bb%a1%e8%b6%b3%e5%93%aa%e4%ba%9b%e8%a6%81%e6%b1%82">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="img/ly-20241212142029864.png" alt="ly-20241212142029864" />&lt;/p>
&lt;p>分布式 ID 作为分布式系统中必不可少的一环，很多地方都要用到分布式 ID。&lt;/p>
&lt;p>一个最基本的分布式 ID 需要满足下面这些要求：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>全局唯一&lt;/strong> ：ID 的&lt;strong>全局唯一性&lt;/strong>肯定是首先要满足的！&lt;/li>
&lt;li>&lt;strong>高性能&lt;/strong> ： 分布式 ID 的&lt;strong>生成速度要快&lt;/strong>，对本地资源消耗要小。&lt;/li>
&lt;li>&lt;strong>高可用&lt;/strong> ：生成分布式 ID 的服务要保证&lt;strong>可用性无限接近于 100%&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>方便易用&lt;/strong> ：拿来即用，&lt;strong>使用方便，快速接入&lt;/strong>！&lt;/li>
&lt;/ul>
&lt;p>除了这些之外，一个比较好的分布式 ID 还应保证：&lt;/p></description></item><item><title>api网关</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly01ly_api-gateway/</link><pubDate>Fri, 10 Feb 2023 22:26:59 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/ly01ly_api-gateway/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="什么是网关有什么用">
 什么是网关？有什么用？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%bd%91%e5%85%b3%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;p>微服务背景下，一个系统被&lt;strong>拆分为多个服务&lt;/strong>，但是像&lt;strong>安全认证&lt;/strong>，&lt;strong>流量控制&lt;/strong>，&lt;strong>日志&lt;/strong>，&lt;strong>监控&lt;/strong>等功能是每个服务都需要的，没有网关的话，我们就需要在&lt;strong>每个服务&lt;/strong>中单独实现，这使得我们做了很多重复的事情并且没有一个&lt;strong>全局的视图来统一管理&lt;/strong>这些功能。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142028983.png" alt="ly-20241212142028983.png" />&lt;/p>
&lt;p>一般情况下，网关可以为我们提供&lt;strong>请求转发&lt;/strong>、&lt;strong>安全认证（身份/权限认证）&lt;/strong>、&lt;strong>流量控制&lt;/strong>、&lt;strong>负载均衡&lt;/strong>、&lt;strong>降级熔断&lt;/strong>、&lt;strong>日志&lt;/strong>、&lt;strong>监控&lt;/strong>等功能。&lt;/p>
&lt;p>上面介绍了这么多功能，实际上，网关主要做了一件事情：&lt;strong>请求过滤&lt;/strong> 。&lt;/p>
&lt;h2 id="有哪些常见的网关系统">
 有哪些常见的网关系统？
 &lt;a class="anchor" href="#%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e7%bd%91%e5%85%b3%e7%b3%bb%e7%bb%9f">#&lt;/a>
&lt;/h2>
&lt;h3 id="netflix-zuul">
 Netflix Zuul
 &lt;a class="anchor" href="#netflix-zuul">#&lt;/a>
&lt;/h3>
&lt;p>Zuul 是 Netflix 开发的一款提供&lt;strong>动态路由&lt;/strong>、&lt;strong>监控&lt;/strong>、&lt;strong>弹性&lt;/strong>、&lt;strong>安全&lt;/strong>的网关服务。&lt;/p>
&lt;p>Zuul 主要通过&lt;strong>过滤器（类似于 AOP）来过滤请求&lt;/strong>，从而实现网关必备的各种功能。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142029228.jpg" alt="Zuul架构" />&lt;/p>
&lt;p>我们可以自定义过滤器来处理请求，并且，Zuul 生态本身就有很多现成的过滤器供我们使用。就比如限流可以直接用国外朋友写的 &lt;a href="https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit">spring-cloud-zuul-ratelimit&lt;/a> (这里只是举例说明，一般是配合 hystrix 来做限流)：&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;dependency&amp;gt;
 &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-zuul&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
 &amp;lt;groupId&amp;gt;com.marcosbarbero.cloud&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;spring-cloud-zuul-ratelimit&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;2.2.0.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Zuul 1.x &lt;strong>基于同步 IO，性能较差&lt;/strong>。Zuul 2.x &lt;strong>基于 Netty 实现了异步 IO&lt;/strong>，性能得到了大幅改进。&lt;/p>
&lt;ul>
&lt;li>Github 地址 ： &lt;a href="https://github.com/Netflix/zuul">https://github.com/Netflix/zuul&lt;/a>&lt;/li>
&lt;li>官方 Wiki ： &lt;a href="https://github.com/Netflix/zuul/wiki">https://github.com/Netflix/zuul/wiki&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="spring-cloud-gateway">
 Spring Cloud Gateway
 &lt;a class="anchor" href="#spring-cloud-gateway">#&lt;/a>
&lt;/h3>
&lt;p>SpringCloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 **Zuul **。准确点来说，应该是 &lt;strong>Zuul 1.x&lt;/strong>。SpringCloud Gateway 起步要比 Zuul 2.x 更早。&lt;/p></description></item><item><title>raft算法</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/raft-algorithm/</link><pubDate>Fri, 10 Feb 2023 17:10:36 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/raft-algorithm/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-背景">
 1 背景
 &lt;a class="anchor" href="#1-%e8%83%8c%e6%99%af">#&lt;/a>
&lt;/h2>
&lt;p>当今的数据中心和应用程序在高度动态的环境中运行，为了应对&lt;strong>高度动态&lt;/strong>的环境，它们&lt;strong>通过额外的服务器进行横向扩展&lt;/strong>，并且&lt;strong>根据需求进行扩展和收&lt;/strong>缩。同时，服务器和网络故障也很常见。&lt;/p>
&lt;p>因此，系统必须在正常操作期间处理服务器的上下线。它们必须对变故&lt;strong>做出反应并在几秒钟内自动适应&lt;/strong>；对客户来说的话，明显的中断通常是不可接受的。&lt;/p>
&lt;p>幸运的是，分布式共识可以帮助应对这些挑战。&lt;/p>
&lt;h3 id="11-拜占庭将军">
 1.1 拜占庭将军
 &lt;a class="anchor" href="#11-%e6%8b%9c%e5%8d%a0%e5%ba%ad%e5%b0%86%e5%86%9b">#&lt;/a>
&lt;/h3>
&lt;p>在介绍共识算法之前，先介绍一个简化版拜占庭将军的例子来帮助理解共识算法。&lt;/p>
&lt;blockquote>
&lt;p>假设多位拜占庭将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成是否要进攻的一致性决定？&lt;/p>
&lt;/blockquote>
&lt;p>解决方案大致可以理解成：先在所有的将军中选出一个大将军，用来做出所有的决定。&lt;/p>
&lt;p>举例如下：假如现在一共有 3 个将军 A，B 和 C，每个将军都有一个随机时间的倒计时器，&lt;strong>倒计时一结束&lt;/strong>，这个将军就&lt;strong>把自己当成大将军候选人&lt;/strong>，然后派信使&lt;strong>传递选举投票的信息给将军 B 和 C&lt;/strong>，如果将军 B 和 C &lt;strong>还没有把自己当作候选人&lt;/strong>（自己的倒计时还没有结束），并且&lt;strong>没有把选举票投给其他人&lt;/strong>，它们就会把票投给将军 A，信使回到将军 A 时，将军 A 知道自己收到了足够的票数，成为大将军。在有了大将军之后，&lt;strong>是否需要进攻就由大将军 A&lt;/strong> 决定，然后再去派信使通知另外两个将军，自己已经成为了大将军。如果一段时间还没收到将军 B 和 C 的回复（信使可能会被暗杀），那就再重派一个信使，直到收到回复。&lt;/p>
&lt;h3 id="12-共识算法">
 1.2 共识算法
 &lt;a class="anchor" href="#12-%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h3>
&lt;p>共识是可容错系统中的一个基本问题：&lt;strong>即使面对故障，服务器也可以在共享状态上达成一致&lt;/strong>。&lt;/p>
&lt;p>共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组&lt;code>Server&lt;/code>的状态机计算相同状态的副本，即使有一部分的&lt;code>Server&lt;/code>宕机了它们仍然能够继续运行。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142028468.jpg" alt="rsm-architecture.png" />&lt;/p>
&lt;pre tabindex="0">&lt;code>图-1 复制状态机架构
&lt;/code>&lt;/pre>&lt;p>一般通过&lt;strong>使用复制日志来实现复制状态机&lt;/strong>。&lt;strong>每个&lt;code>Server&lt;/code>存储着一份包括命令序列的日志文件&lt;/strong>，状态机会按顺序执行这些命令。因为每个日志包含相同的命令，并且顺序也相同，所以每个状态机处理相同的命令序列。由于状态机是确定性的，所以&lt;strong>处理相同的状态，得到相同的输出&lt;/strong>。&lt;/p>
&lt;p>因此共识算法的工作就是&lt;strong>保持复制日志的一致性&lt;/strong>。服务器上的共识模块从客户端接收命令并将它们添加到日志中。它与其他服务器上的共识模块通信，以确保即使某些服务器发生故障。每个日志最终包含相同顺序的请求。一旦命令被正确地复制，它们就被称为已提交。每个服务器的状态机按照日志顺序处理已提交的命令，并将输出返回给客户端，因此，这些服务器形成了一个单一的、高度可靠的状态机。&lt;/p>
&lt;p>适用于实际系统的共识算法通常具有以下特性：&lt;/p>
&lt;ul>
&lt;li>安全。&lt;strong>确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性&lt;/strong>，包括&lt;strong>网络延迟&lt;/strong>、&lt;strong>分区&lt;/strong>、&lt;strong>包丢失&lt;/strong>、&lt;strong>复制&lt;/strong>和&lt;strong>重新排序&lt;/strong>。&lt;/li>
&lt;li>高可用。只要&lt;strong>大多数服务器都是可操作&lt;/strong>的，并且可以相互通信，也可以与客户端进行通信，那么这些服务器就可以看作完全功能可用的。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障。假设服务器因停止而发生故障；它们&lt;strong>稍后可能会从稳定存储上的状态中恢复并重新加入集群&lt;/strong>。&lt;/li>
&lt;li>一致性不依赖时序。错误的时钟和极端的消息延迟，在&lt;strong>最坏的情况下也只会造成可用性问题，而不会产生一致性问题&lt;/strong>。&lt;/li>
&lt;li>在集群中大多数服务器响应，&lt;strong>命令就可以完成&lt;/strong>，不会被少数运行缓慢的服务器来影响整体系统性能。&lt;/li>
&lt;/ul>
&lt;h2 id="2-基础">
 2 基础
 &lt;a class="anchor" href="#2-%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;h3 id="21-节点类型">
 2.1 节点类型
 &lt;a class="anchor" href="#21-%e8%8a%82%e7%82%b9%e7%b1%bb%e5%9e%8b">#&lt;/a>
&lt;/h3>
&lt;p>一个 Raft 集群包括若干服务器，以典型的 5 服务器集群举例。在任意的时间，每个服务器一定会处于以下三个状态中的一个：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Leader&lt;/code>：负责发起心跳，响应客户端，创建日志，同步日志。&lt;/li>
&lt;li>&lt;code>Candidate&lt;/code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。&lt;/li>
&lt;li>&lt;code>Follower&lt;/code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。&lt;/li>
&lt;/ul>
&lt;p>在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。&lt;/p></description></item><item><title>paxos算法</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/paxos-algorithm/</link><pubDate>Fri, 10 Feb 2023 17:02:45 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/paxos-algorithm/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="背景">
 背景
 &lt;a class="anchor" href="#%e8%83%8c%e6%99%af">#&lt;/a>
&lt;/h2>
&lt;p>Paxos 算法是 Leslie Lamport（&lt;a href="https://zh.wikipedia.org/wiki/%e8%8e%b1%e6%96%af%e5%88%a9%c2%b7%e5%85%b0%e4%bc%af%e7%89%b9">莱斯利·兰伯特&lt;/a>）在 &lt;strong>1990&lt;/strong> 年提出了一种分布式系统 &lt;strong>共识&lt;/strong> 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是&lt;strong>没有恶意节点&lt;/strong>）。&lt;/p>
&lt;p>为了介绍 Paxos 算法，兰伯特专门写了一篇幽默风趣的论文。在这篇论文中，他虚拟了一个叫做 Paxos 的希腊城邦来更形象化地介绍 Paxos 算法。&lt;/p>
&lt;p>不过，审稿人并不认可这篇论文的幽默。于是，他们就给兰伯特说：“如果你想要成功发表这篇论文的话，必须删除所有 Paxos 相关的故事背景”。兰伯特一听就不开心了：“我凭什么修改啊，你们这些审稿人就是缺乏幽默细胞，发不了就不发了呗！”。&lt;/p>
&lt;p>于是乎，提出 Paxos 算法的那篇论文在当时并没有被成功发表。&lt;/p>
&lt;p>直到 1998 年，系统研究中心 (Systems Research Center，SRC）的两个技术研究员需要找一些合适的分布式算法来服务他们正在构建的分布式系统，Paxos 算法刚好可以解决他们的部分需求。因此，兰伯特就把论文发给了他们。在看了论文之后，这俩大佬觉得论文还是挺不错的。于是，兰伯特在 &lt;strong>1998&lt;/strong> 年重新发表论文 &lt;a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf">《The Part-Time Parliament》&lt;/a>。&lt;/p>
&lt;p>论文发表之后，各路学者直呼看不懂，言语中还略显调侃之意。这谁忍得了，在 &lt;strong>2001&lt;/strong> 年的时候，兰伯特专门又写了一篇 &lt;a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf">《Paxos Made Simple》&lt;/a> 的论文来简化对 Paxos 的介绍，主要讲述&lt;strong>两阶段共识协议&lt;/strong>部分，顺便还不忘嘲讽一下这群学者。&lt;/p>
&lt;p>《Paxos Made Simple》这篇论文就 14 页，相比于 《The Part-Time Parliament》的 33 页精简了不少。最关键的是这篇论文的摘要就一句话：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142028075.png" alt="ly-20241212142028075" />&lt;/p>
&lt;blockquote>
&lt;p>The Paxos algorithm, when presented in plain English, is very simple.&lt;/p>
&lt;/blockquote>
&lt;p>翻译过来的意思大概就是：&lt;strong>当我用无修饰的英文来描述时，Paxos 算法真心简单！&lt;/strong>&lt;/p>
&lt;p>有没有感觉到来自兰伯特大佬满满地嘲讽的味道？&lt;/p></description></item><item><title>CAP&amp;BASE 理论</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/cap_base-theorem/</link><pubDate>Fri, 10 Feb 2023 15:03:48 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lydly_distributed_system/base/cap_base-theorem/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>经历过技术面试的小伙伴想必对 CAP &amp;amp; BASE 这个两个理论已经再熟悉不过了！&lt;/p>
&lt;p>我当年参加面试的时候，不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个&lt;strong>分布式相关的理论&lt;/strong>。一是因为这两个分布式基础理论是学习分布式知识的&lt;strong>必备前置基础&lt;/strong>，二是因为很多面试官自己比较熟悉这两个理论（方便提问）。&lt;/p>
&lt;p>我们非常有必要将这两个理论搞懂，并且能够用自己的理解给别人讲出来。&lt;/p>
&lt;h2 id="cap-理论">
 CAP 理论
 &lt;a class="anchor" href="#cap-%e7%90%86%e8%ae%ba">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/CAP%e5%ae%9a%e7%90%86">CAP 理论/定理&lt;/a>起源于 2000 年，由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 &lt;strong>布鲁尔定理（Brewer’s theorem）&lt;/strong>&lt;/p>
&lt;p>2 年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 发表了布鲁尔猜想的证明，CAP 理论正式成为&lt;strong>分布式领域的定理&lt;/strong>。&lt;/p>
&lt;h3 id="简介">
 简介
 &lt;a class="anchor" href="#%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h3>
&lt;blockquote>
&lt;p>&lt;code>[kənˈsɪstənsi] consistency 一致性&lt;/code>&lt;br>
&lt;code>[əˌveɪlə'bɪləti] availability 可用性 &lt;/code>,&lt;br>
&lt;code>[pɑːˈtɪʃn] 分割 [ˈtɒlərəns] 容忍, &lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>CAP&lt;/strong> 也就是 &lt;strong>Consistency（一致性）&lt;/strong>、&lt;strong>Availability（可用性）&lt;/strong>、&lt;strong>Partition Tolerance（分区容错性）&lt;/strong> 这三个单词首字母组合。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142027432.png" alt="ly-20241212142027432" />&lt;/p>
&lt;p>CAP 理论的提出者布鲁尔在提出 CAP 猜想的时候，并没有详细定义 &lt;strong>Consistency&lt;/strong>、&lt;strong>Availability&lt;/strong>、&lt;strong>Partition Tolerance&lt;/strong> 三个单词的明确定义。&lt;/p>
&lt;p>因此，对于 CAP 的民间解读有很多，一般比较被大家推荐的是下面 👇 这种版本的解读。&lt;/p>
&lt;p>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计&lt;strong>读写操作&lt;/strong>时，只能同时满足以下三点中的两个：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>一致性（Consistency）&lt;/strong> : 所有节点&lt;strong>访问同一份最新的数据副本&lt;/strong>&lt;/li>
&lt;li>&lt;strong>可用性（Availability）&lt;/strong>: &lt;strong>非故障的节点在合理的时间内返回合理的响应&lt;/strong>（不是错误或者超时的响应）。&lt;/li>
&lt;li>&lt;strong>分区容错性（Partition Tolerance）&lt;/strong> : 分布式系统出现网络分区的时候，&lt;strong>仍然能够对外提供服务&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>什么是网络分区？&lt;/strong>&lt;/p></description></item><item><title>Mybatis原理系列(3)</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle3/</link><pubDate>Fri, 10 Feb 2023 11:27:48 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle3/</guid><description>&lt;blockquote>
&lt;p>转载自https://www.jianshu.com/p/4e268828db48（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>还没看完&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>在上篇文章中，我们讲解了MyBatis的启动流程，以及启动过程中涉及到的组件，在本篇文中，我们继续探索SqlSession,SqlSessionFactory,SqlSessionFactoryBuilder的关系。SqlSession作为MyBatis的核心组件，可以说MyBatis的所有操作都是围绕SqlSession来展开的。对&lt;strong>SqlSession理解透彻&lt;/strong>，才能全面掌握MyBatis。&lt;/p>
&lt;/blockquote>
&lt;h4 id="1-sqlsession初识">
 1. SqlSession初识
 &lt;a class="anchor" href="#1-sqlsession%e5%88%9d%e8%af%86">#&lt;/a>
&lt;/h4>
&lt;p>SqlSession在一开始就介绍过是高级接口，类似于JDBC操作的connection对象，它包装了数据库连接，通过这个接口我们可以实现增删改查，提交/回滚事物，关闭连接，获取代理类等操作。SqlSession是个接口，其默认实现是DefaultSqlSession。SqlSession是线程不安全的，每个线程都会有自己唯一的SqlSession，不同线程间调用同一个SqlSession会出现问题，因此在使用完后需要close掉。&lt;/p>
&lt;p>&lt;img src="https:////upload-images.jianshu.io/upload_images/1183379-d5d3c96bed2f4352.png?imageMogr2/auto-orient/strip%7cimageView2/2/w/413/format/webp" alt="img" />&lt;/p>
&lt;p>SqlSession的方法&lt;/p>
&lt;h4 id="2-sqlsession的创建">
 2. SqlSession的创建
 &lt;a class="anchor" href="#2-sqlsession%e7%9a%84%e5%88%9b%e5%bb%ba">#&lt;/a>
&lt;/h4>
&lt;p>SqlSessionFactoryBuilder的build()方法使用建造者模式创建了SqlSessionFactory接口对象，SqlSessionFactory接口的默认实现是DefaultSqlSessionFactory。SqlSessionFactory使用实例工厂模式来创建SqlSession对象。SqlSession,SqlSessionFactory,SqlSessionFactoryBuilder的关系如下(图画得有点丑&amp;hellip;)：&lt;/p>
&lt;p>&lt;img src="https:////upload-images.jianshu.io/upload_images/1183379-8e031424b84ca308.png?imageMogr2/auto-orient/strip%7cimageView2/2/w/1200/format/webp" alt="img" />&lt;/p>
&lt;p>类图&lt;/p>
&lt;p>DefaultSqlSessionFactory中openSession是有两种方法一种是openSessionFromDataSource，另一种是openSessionFromConnection。这两种是什么区别呢？从字面意义上将，一种是从数据源中获取SqlSession对象，一种是由已有连接获取SqlSession。SqlSession实际是对数据库连接的一层包装，数据库连接是个珍贵的资源，如果频繁的创建销毁将会影响吞吐量，因此使用数据库连接池化技术就可以复用数据库连接了。因此openSessionFromDataSource会从数据库连接池中获取一个连接，然后包装成一个SqlSession对像。openSessionFromConnection则是直接包装已有的连接并返回SqlSession对像。&lt;/p>
&lt;p>openSessionFromDataSource 主要经历了以下几步：&lt;/p>
&lt;ol>
&lt;li>从获取configuration中获取Environment对象，Environment包含了数据库配置&lt;/li>
&lt;li>从Environment获取DataSource数据源&lt;/li>
&lt;li>从DataSource数据源中获取Connection连接对象&lt;/li>
&lt;li>从DataSource数据源中获取TransactionFactory事物工厂&lt;/li>
&lt;li>从TransactionFactory中创建事物Transaction对象&lt;/li>
&lt;li>创建Executor对象&lt;/li>
&lt;li>包装configuration和Executor对象成DefaultSqlSession对象&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> SqlSession &lt;span style="color:#a6e22e">openSessionFromDataSource&lt;/span>(ExecutorType execType, TransactionIsolationLevel level, &lt;span style="color:#66d9ef">boolean&lt;/span> autoCommit) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Transaction tx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Environment environment &lt;span style="color:#f92672">=&lt;/span> configuration.&lt;span style="color:#a6e22e">getEnvironment&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> TransactionFactory transactionFactory &lt;span style="color:#f92672">=&lt;/span> getTransactionFactoryFromEnvironment(environment);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tx &lt;span style="color:#f92672">=&lt;/span> transactionFactory.&lt;span style="color:#a6e22e">newTransaction&lt;/span>(environment.&lt;span style="color:#a6e22e">getDataSource&lt;/span>(), level, autoCommit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Executor executor &lt;span style="color:#f92672">=&lt;/span> configuration.&lt;span style="color:#a6e22e">newExecutor&lt;/span>(tx, execType);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> DefaultSqlSession(configuration, executor, autoCommit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> closeTransaction(tx); &lt;span style="color:#75715e">// may have fetched a connection so lets call close()&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> ExceptionFactory.&lt;span style="color:#a6e22e">wrapException&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Error opening session. Cause: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> e, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ErrorContext.&lt;span style="color:#a6e22e">instance&lt;/span>().&lt;span style="color:#a6e22e">reset&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> SqlSession &lt;span style="color:#a6e22e">openSessionFromConnection&lt;/span>(ExecutorType execType, Connection connection) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> autoCommit;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> autoCommit &lt;span style="color:#f92672">=&lt;/span> connection.&lt;span style="color:#a6e22e">getAutoCommit&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (SQLException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Failover to true, as most poor drivers&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// or databases won&amp;#39;t support transactions&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> autoCommit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Environment environment &lt;span style="color:#f92672">=&lt;/span> configuration.&lt;span style="color:#a6e22e">getEnvironment&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> TransactionFactory transactionFactory &lt;span style="color:#f92672">=&lt;/span> getTransactionFactoryFromEnvironment(environment);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Transaction tx &lt;span style="color:#f92672">=&lt;/span> transactionFactory.&lt;span style="color:#a6e22e">newTransaction&lt;/span>(connection);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Executor executor &lt;span style="color:#f92672">=&lt;/span> configuration.&lt;span style="color:#a6e22e">newExecutor&lt;/span>(tx, execType);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> DefaultSqlSession(configuration, executor, autoCommit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> ExceptionFactory.&lt;span style="color:#a6e22e">wrapException&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Error opening session. Cause: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> e, e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ErrorContext.&lt;span style="color:#a6e22e">instance&lt;/span>().&lt;span style="color:#a6e22e">reset&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3-sqlsession的使用">
 3. SqlSession的使用
 &lt;a class="anchor" href="#3-sqlsession%e7%9a%84%e4%bd%bf%e7%94%a8">#&lt;/a>
&lt;/h4>
&lt;p>SqlSession 获取成功后，我们就可以使用其中的方法了，比如直接使用SqlSession发送sql语句，或者通过mapper映射文件的方式来使用，在上两篇文章中我们都是通过mapper映射文件来使用的，接下来就介绍第一种，直接使用SqlSession发送sql语句。&lt;/p></description></item><item><title>Mybatis原理系列(2)</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle2/</link><pubDate>Fri, 10 Feb 2023 11:04:31 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle2/</guid><description>&lt;blockquote>
&lt;p>转载自https://www.jianshu.com/p/7d6b891180a3（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在上篇文章中，我们举了一个例子如何使用MyBatis，但是对其中&lt;strong>dao层&lt;/strong>，&lt;strong>entity层&lt;/strong>，&lt;strong>mapper层&lt;/strong>间的关系不得而知，从此篇文章开始，笔者将&lt;strong>从MyBatis的启动流程&lt;/strong>着手，真正的开始研究MyBatis源码了。&lt;/p>
&lt;/blockquote>
&lt;h4 id="1-mybatis启动代码示例">
 1. MyBatis启动代码示例
 &lt;a class="anchor" href="#1-mybatis%e5%90%af%e5%8a%a8%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b">#&lt;/a>
&lt;/h4>
&lt;p>在上篇文章中，介绍了MyBatis的相关配置和各层代码编写，本文将以下代码展开描述和介绍MyBatis的启动流程，并简略的介绍各个模块的作用，&lt;strong>各个模块的细节部分将在其它文章中呈现&lt;/strong>。&lt;/p>
&lt;p>回顾下上文中使用mybatis的部分代码，包括七步。每步虽然都是一行代码，但是隐藏了很多细节。接下来我们将围绕这起步展开了解。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Slf4j&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyBatisBootStrap&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 1. 读取配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InputStream inputStream &lt;span style="color:#f92672">=&lt;/span> Resources.&lt;span style="color:#a6e22e">getResourceAsStream&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;mybatis-config.xml&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2. 创建SqlSessionFactory工厂&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SqlSessionFactory sqlSessionFactory &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SqlSessionFactoryBuilder().&lt;span style="color:#a6e22e">build&lt;/span>(inputStream);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 3. 获取sqlSession&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SqlSession sqlSession &lt;span style="color:#f92672">=&lt;/span> sqlSessionFactory.&lt;span style="color:#a6e22e">openSession&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 4. 获取Mapper&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TTestUserMapper userMapper &lt;span style="color:#f92672">=&lt;/span> sqlSession.&lt;span style="color:#a6e22e">getMapper&lt;/span>(TTestUserMapper.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 5. 执行接口方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TTestUser userInfo &lt;span style="color:#f92672">=&lt;/span> userMapper.&lt;span style="color:#a6e22e">selectByPrimaryKey&lt;/span>(16L);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;userInfo = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> JSONUtil.&lt;span style="color:#a6e22e">toJsonStr&lt;/span>(userInfo));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 6. 提交事物&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sqlSession.&lt;span style="color:#a6e22e">commit&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 7. 关闭资源&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sqlSession.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inputStream.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (Exception e){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">error&lt;/span>(e.&lt;span style="color:#a6e22e">getMessage&lt;/span>(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-读取配置">
 2. 读取配置
 &lt;a class="anchor" href="#2-%e8%af%bb%e5%8f%96%e9%85%8d%e7%bd%ae">#&lt;/a>
&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1. 读取配置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>InputStream inputStream &lt;span style="color:#f92672">=&lt;/span> Resources.getResourceAsStream(&lt;span style="color:#e6db74">&amp;#34;mybatis-config.xml&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在&lt;strong>mybatis-config.xml&lt;/strong>中我们配置了&lt;strong>属性&lt;/strong>，&lt;strong>环境&lt;/strong>，&lt;strong>映射文件路径&lt;/strong>等，其实不仅可以配置以上内容，还可以配置&lt;strong>插件&lt;/strong>，&lt;strong>反射工厂&lt;/strong>，&lt;strong>类型处理器&lt;/strong>等等其它内容。在启动流程中的第一步我们就需要&lt;strong>读取这个配置文件&lt;/strong>，并获取一个输入流为下一步解析配置文件作准备。&lt;/p></description></item><item><title>Mybatis原理系列(1)</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle1/</link><pubDate>Fri, 10 Feb 2023 08:54:26 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/principle/mybatis-principle1/</guid><description>&lt;blockquote>
&lt;p>转载自https://www.jianshu.com/p/ada025f97a07（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>作为Java码农，无论在面试中，还是在工作中都会遇到MyBatis的相关问题。笔者从大学开始就接触MyBatis，到现在为止都是会用，知道怎么配置，怎么编写xml，但是不知道Mybatis核心原理，一遇到问题就复制错误信息百度解决。为了改变这种境地，鼓起勇气开始下定决心阅读MyBatis源码，并开始记录阅读过程，希望和大家分享。&lt;/p>
&lt;/blockquote>
&lt;h4 id="1-初识mybatis">
 1. 初识MyBatis
 &lt;a class="anchor" href="#1-%e5%88%9d%e8%af%86mybatis">#&lt;/a>
&lt;/h4>
&lt;p>还记得当初接触MyBatis时，觉得要配置很多，而且sql要单独写在xml中，相比Hibernate来说简直不太友好，直到后来出现了复杂的业务需求，需要编写相应的复杂的sql，此时用Hibernate反而更加麻烦了，用MyBatis是真香了。因此笔者对MyBatis的第一印象就是&lt;strong>将业务关注的sql&lt;/strong>和&lt;strong>java代码&lt;/strong>进行了解耦，在业务复杂变化的时候，相应的数据库操作需要相应进行修改，&lt;strong>如果通过java代码构建操作数据逻辑&lt;/strong>，这不断变动的需求对程序员的耐心是极大的考验。如果&lt;strong>将sql统一的维护在一个文件&lt;/strong>里，java代码用接口定义，在需求变动时，&lt;strong>只用改相应的sql&lt;/strong>，从而&lt;strong>减少了修改量&lt;/strong>，&lt;strong>提高开发效率&lt;/strong>。以上也是经常在面试中经常问到的Hibernate和MyBatis间的区别一点。&lt;/p>
&lt;p>切到正题，Mybatis是什么呢？&lt;/p>
&lt;p>Mybatis SQL 映射框架使得一个&lt;strong>面向对象构建的应用程序&lt;/strong>去&lt;strong>访问一个关系型数据库&lt;/strong>变得更容易。MyBatis使用&lt;strong>XML描述符&lt;/strong>或&lt;strong>注解&lt;/strong>将&lt;strong>对象&lt;/strong>与&lt;strong>存储过程&lt;/strong>或&lt;strong>SQL语句耦合&lt;/strong>。与对象关系映射工具相比，简单性是MyBatis数据映射器的最大优势。&lt;/p>
&lt;p>以上是Mybatis的官方解释，其中“映射”，“面向对象”，“关系型”，“xml”等等都是Mybatis的关键词，也是我们了解了Mybatis原理后，会恍然大悟的地方。笔者现在不详述这些概念，在最后总结的时候再进行详述。我们只要知道Mybatis为我们操作数据库提供了很大的便捷。&lt;/p>
&lt;h4 id="2-源码下载">
 2. 源码下载
 &lt;a class="anchor" href="#2-%e6%ba%90%e7%a0%81%e4%b8%8b%e8%bd%bd">#&lt;/a>
&lt;/h4>
&lt;blockquote>
&lt;p>这里建议使用maven即可，在pom.xml添加以下依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>mysql&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>mysql-connector-java&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>8.0.32&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.mybatis&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>mybatis&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>3.5.6&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!--这里还添加了一些辅助的依赖--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!--lombok--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.projectlombok&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>lombok&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.18.8&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!--日志模块--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.apache.logging.log4j&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>log4j-api&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>2.17.1&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在ExternalLibraries 的mybatis:3.5.6里找到，就能看到目录结构 ，随便找一个进去 idea右上角会出现DownloadSource之类的字样 ，点击即可&lt;br>
&lt;img src="img/ly-20241212142014144.png" alt="ly-20241212142014144" />&lt;/p>
&lt;/blockquote>
&lt;p>我们首先要从github上下载源码，&lt;a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fmybatis%2Fmybatis-3">仓库地址&lt;/a>，然后在IDEA中clone代码&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142014403.png" alt="img" />&lt;/p>
&lt;p>在打开中的IDEA中，选择vsc -&amp;gt; get from version control -&amp;gt; 复制刚才的地址&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142014541.png" alt="img" />&lt;/p>
&lt;p>image.png&lt;/p>
&lt;p>点击clone即可&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142014681.png" alt="img" />&lt;/p></description></item><item><title>Mybatis面试</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/MyBatis-interview/</link><pubDate>Thu, 09 Feb 2023 16:34:39 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/MyBatis/MyBatis-interview/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;p>部分疑问参考自 &lt;a href="https://blog.csdn.net/Gherbirthday0916">https://blog.csdn.net/Gherbirthday0916&lt;/a> 感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h3 id="-和--的区别是什么">
 #{} 和 ${} 的区别是什么？
 &lt;a class="anchor" href="#-%e5%92%8c--%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>注：这道题是面试官面试我同事的。&lt;/p>
&lt;p>答：&lt;/p>
&lt;ul>
&lt;li>&lt;code>${}&lt;/code>是 Properties &lt;strong>文件中的变量占位符&lt;/strong>，它可以用于&lt;strong>标签属性值&lt;/strong>和 &lt;strong>sql 内部&lt;/strong>，属于&lt;strong>静态文本替换&lt;/strong>，比如${driver}会被静态替换为&lt;code>com.mysql.jdbc. Driver&lt;/code>。&lt;/li>
&lt;li>&lt;code>#{}&lt;/code>是 sql 的参数占位符，MyBatis 会&lt;strong>将 sql 中的&lt;code>#{}&lt;/code>&lt;strong>替换为&lt;/strong>? 号&lt;/strong>，在 sql 执行前会使用 &lt;strong>PreparedStatement 的参数设置&lt;/strong>方法，&lt;strong>按序给 sql 的? 号占位符设置参数值&lt;/strong>，比如 ps.setInt(0, parameterValue)，&lt;code>#{item.name}&lt;/code> 的取值方式为使用&lt;strong>反射从参数对象中获取 item 对象的 name 属性值&lt;/strong>，相当于 &lt;strong>&lt;code>param.getItem().getName()&lt;/code>&lt;/strong>。 [&lt;strong>这里用到了反射&lt;/strong>]&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>在&lt;strong>底层构造完整SQL&lt;/strong>语句时，MyBatis的两种&lt;strong>传参方式&lt;/strong>所采取的方式不同。&lt;code>#{Parameter}&lt;/code>采用&lt;strong>预编译&lt;/strong>的方式构造SQL，&lt;strong>避免了 SQL注入&lt;/strong> 的产生。而**&lt;code>${Parameter}&lt;/code>采用拼接&lt;strong>的方式构造SQL，在&lt;/strong>对用户输入过滤不严格**的前提下，此处很可能存在SQL注入&lt;/p>
&lt;/blockquote>
&lt;h3 id="xml-映射文件中除了常见的-selectinsertupdatedelete-标签之外还有哪些标签">
 xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？
 &lt;a class="anchor" href="#xml-%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6%e4%b8%ad%e9%99%a4%e4%ba%86%e5%b8%b8%e8%a7%81%e7%9a%84-selectinsertupdatedelete-%e6%a0%87%e7%ad%be%e4%b9%8b%e5%a4%96%e8%bf%98%e6%9c%89%e5%93%aa%e4%ba%9b%e6%a0%87%e7%ad%be">#&lt;/a>
&lt;/h3>
&lt;p>注：这道题是京东面试官面试我时问的。&lt;/p>
&lt;p>答：还有很多其他的标签， &lt;strong>&lt;code>&amp;lt;resultMap&amp;gt;&lt;/code>&lt;/strong> 、 &lt;strong>&lt;code>&amp;lt;parameterMap&amp;gt;&lt;/code>&lt;/strong> 、 &lt;strong>&lt;code>&amp;lt;sql&amp;gt;&lt;/code>&lt;/strong> 、 &lt;strong>&lt;code>&amp;lt;include&amp;gt;&lt;/code>&lt;/strong> 、 &lt;strong>&lt;code>&amp;lt;selectKey&amp;gt;&lt;/code>&lt;/strong> ，加上动态 sql 的 9 个标签， &lt;strong>&lt;code>trim|where|set|foreach|if|choose|when|otherwise|bind&lt;/code>&lt;/strong> 等，其中 &lt;code>&amp;lt;sql&amp;gt;&lt;/code> 为 sql 片段标签，通过 &lt;code>&amp;lt;include&amp;gt;&lt;/code> 标签引入 sql 片段， &lt;code>&amp;lt;selectKey&amp;gt;&lt;/code> 为不支持自增的主键生成策略标签。&lt;/p></description></item><item><title>ConditionalOnClass实践</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/conditional_on_class/</link><pubDate>Thu, 09 Feb 2023 15:38:01 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/conditional_on_class/</guid><description>&lt;h1 id="两个测试方向">
 两个测试方向
 &lt;a class="anchor" href="#%e4%b8%a4%e4%b8%aa%e6%b5%8b%e8%af%95%e6%96%b9%e5%90%91">#&lt;/a>
&lt;/h1>
&lt;h2 id="方向1两个maven项目">
 方向1：两个maven项目
 &lt;a class="anchor" href="#%e6%96%b9%e5%90%911%e4%b8%a4%e4%b8%aamaven%e9%a1%b9%e7%9b%ae">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>详见git上的 conditional_on_class_main 项目以及 conditional_on_class2 项目&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>
&lt;p>基础maven项目 conditional_on_class2&lt;br>
pom文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;project&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span style="color:#f92672">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.example&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>conditional_on_class_2&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0-SNAPSHOT&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>java类&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> com;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LyReferenceImpl&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">sayWord&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello one&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>简单的SpringBoot项目 conditional_on_class_main&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!--pom文件--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;project&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span style="color:#f92672">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.example&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>conditional_on_class_main&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0-SNAPSHOT&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;parent&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.boot&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-boot-starter-parent&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>2.7.8&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/parent&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!--把1配置的bean引用进来--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.example&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>conditional_on_class_2&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0-SNAPSHOT&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>provided&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;optional&amp;gt;&lt;/span>true&lt;span style="color:#f92672">&amp;lt;/optional&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.boot&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-boot-starter-web&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;build&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugins&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.boot&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-boot-maven-plugin&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;configuration&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;excludes&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- 默认会将conditional_on_class_2 打包进去,现在会配置SayExist
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">						如果放开注释,那么会配置SayNotExist--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!--&amp;lt;dependency&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> &amp;lt;artifactId&amp;gt;conditional_on_class_2&amp;lt;/artifactId&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> &amp;lt;/dependency&amp;gt;--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/excludes&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;jvmArguments&amp;gt;&lt;/span>-Dfile.encoding=UTF-8&lt;span style="color:#f92672">&amp;lt;/jvmArguments&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/configuration&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;executions&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;execution&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;goals&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;goal&amp;gt;&lt;/span>repackage&lt;span style="color:#f92672">&amp;lt;/goal&amp;gt;&lt;/span>&lt;span style="color:#75715e">&amp;lt;!--可以把依赖的包都打包到生成的Jar包中 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/goals&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/execution&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/executions&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugins&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/build&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//两个配置类 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//配置类1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> com.config;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> com.service.ISay;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> com.service.SayExist;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.springframework.context.annotation.Bean;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.springframework.context.annotation.Configuration;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//不要放在方法里面,否则会报错&amp;#34;java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ConditionalOnClass&lt;/span>(value &lt;span style="color:#f92672">=&lt;/span> com.&lt;span style="color:#a6e22e">LyReferenceImpl&lt;/span>.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ExistConfiguration&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ISay &lt;span style="color:#a6e22e">getISay1&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SayExist();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//配置类2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> com.config;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> com.service.ISay;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> com.service.SayNotExist;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.springframework.context.annotation.Bean;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.springframework.context.annotation.Configuration;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ConditionalOnMissingClass&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;com.LyReferenceImpl&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">NotExistConfiguration&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ISay &lt;span style="color:#a6e22e">getISay1&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SayNotExist();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="方向23个maven项目建议用这个理解">
 方向2：3个maven项目(建议用这个理解)
 &lt;a class="anchor" href="#%e6%96%b9%e5%90%9123%e4%b8%aamaven%e9%a1%b9%e7%9b%ae%e5%bb%ba%e8%ae%ae%e7%94%a8%e8%bf%99%e4%b8%aa%e7%90%86%e8%a7%a3">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>注意，这里可能还漏了一个问题，那就是 这个conditional_on_class1 的configuration之所以能够被自动装配，是因为和 conditional_on_class_main1的Application类是同一个包，所以不用特殊处理。如果是其他包名的话，那么是需要用到spring boot的自动装配机制的：在conditional_on_class1 工程的 resources 包下创建&lt;code>META-INF/spring.factories&lt;/code>，并写上Config类的全类名&lt;/p></description></item><item><title>SpringBoot自动装配原理</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/ly05ly_springboot-auto-assembly/</link><pubDate>Thu, 09 Feb 2023 10:37:36 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/ly05ly_springboot-auto-assembly/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>每次问到 Spring Boot， 面试官非常喜欢问这个问题：“讲述一下 SpringBoot 自动装配原理？”。&lt;/p>
&lt;p>我觉得我们可以从以下几个方面回答：&lt;/p>
&lt;ol>
&lt;li>什么是 &lt;strong>SpringBoot 自动装配&lt;/strong>？&lt;/li>
&lt;li>SpringBoot 是&lt;strong>如何实现自动装配&lt;/strong>的？&lt;strong>如何实现按需加载&lt;/strong>？&lt;/li>
&lt;li>&lt;strong>如何实现一个 Starter&lt;/strong>？&lt;/li>
&lt;/ol>
&lt;p>篇幅问题，这篇文章并没有深入，小伙伴们也可以直接使用 debug 的方式去看看 SpringBoot 自动装配部分的源代码。&lt;/p>
&lt;h2 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>使用过 Spring 的小伙伴，一定有被 XML 配置统治的恐惧。即使 Spring 后面引入了基于注解的配置，我们在开启某些 Spring 特性或者引入第三方依赖的时候，还是需要用 XML 或 Java 进行显式配置。&lt;/p>
&lt;p>举个例子。没有 Spring Boot 的时候，我们写一个 RestFul Web 服务，还首先需要进行如下配置。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RESTConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> View &lt;span style="color:#a6e22e">jsonTemplate&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MappingJackson2JsonView view &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> MappingJackson2JsonView();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> view.&lt;span style="color:#a6e22e">setPrettyPrint&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> view;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ViewResolver &lt;span style="color:#a6e22e">viewResolver&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BeanNameViewResolver();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>spring&lt;span style="color:#f92672">-&lt;/span>servlet.&lt;span style="color:#a6e22e">xml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>beans xmlns&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xmlns:xsi&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span> xmlns:context&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.springframework.org/schema/context&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xmlns:mvc&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.springframework.org/schema/mvc&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xsi:schemaLocation&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> http://www.springframework.org/schema/context/ http://www.springframework.org/schema/context/spring-context.xsd
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> http://www.springframework.org/schema/mvc/ http://www.springframework.org/schema/mvc/spring-mvc.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>context:component&lt;span style="color:#f92672">-&lt;/span>scan base&lt;span style="color:#f92672">-&lt;/span>package&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;com.howtodoinjava.demo&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>mvc:annotation&lt;span style="color:#f92672">-&lt;/span>driven &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;!--&lt;/span> JSON Support &lt;span style="color:#f92672">--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bean name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;viewResolver&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">=&amp;#34;&lt;/span>&lt;span style="color:#a6e22e">org&lt;/span>.&lt;span style="color:#a6e22e">springframework&lt;/span>.&lt;span style="color:#a6e22e">web&lt;/span>.&lt;span style="color:#a6e22e">servlet&lt;/span>.&lt;span style="color:#a6e22e">view&lt;/span>.&lt;span style="color:#a6e22e">BeanNameViewResolver&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;bean name=&amp;#34;&lt;/span>jsonTemplate&lt;span style="color:#e6db74">&amp;#34; class=&amp;#34;&lt;/span>org.&lt;span style="color:#a6e22e">springframework&lt;/span>.&lt;span style="color:#a6e22e">web&lt;/span>.&lt;span style="color:#a6e22e">servlet&lt;/span>.&lt;span style="color:#a6e22e">view&lt;/span>.&lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">MappingJackson2JsonView&lt;/span>&lt;span style="color:#e6db74">&amp;#34;/&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;lt;/beans&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是，Spring Boot 项目，我们只需要添加相关依赖，无需配置，通过启动下面的 &lt;code>main&lt;/code> 方法即可。&lt;/p></description></item><item><title>spring 设计模式</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/ly04ly_spring-design-patterns/</link><pubDate>Wed, 08 Feb 2023 20:18:14 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/ly04ly_spring-design-patterns/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>“JDK 中用到了哪些设计模式? Spring 中用到了哪些设计模式? ”这两个问题，在面试中比较常见。&lt;/p>
&lt;p>我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下。&lt;/p>
&lt;p>由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的设计模式。&lt;/p>
&lt;h2 id="控制反转ioc和依赖注入di">
 控制反转(IoC)和依赖注入(DI)
 &lt;a class="anchor" href="#%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%acioc%e5%92%8c%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5di">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>IoC(Inversion of Control,控制反转)&lt;/strong> 是 Spring 中一个非常非常重要的概念，它不是什么技术，而是一种&lt;strong>解耦的设计思想&lt;/strong>。IoC 的主要目的是借助于“第三方”(Spring 中的 IoC 容器) 实现&lt;strong>具有依赖关系的对象之间的解耦&lt;/strong>(IOC 容器管理对象，你只管使用即可)，从而降低代码之间的耦合度。&lt;/p>
&lt;p>&lt;strong>IoC 是一个原则，而不是一个模式，以下模式（但不限于）实现了 IoC 原则。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142011328.jpg" alt="ioc-patterns" />&lt;/p>
&lt;p>&lt;strong>Spring IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。&lt;/strong> IoC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。&lt;/p>
&lt;p>在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你&lt;strong>只需要配置好，然后在需要的地方引用&lt;/strong>就行了，这大大增加了项目的可维护性且降低了开发难度。&lt;/p>
&lt;blockquote>
&lt;p>关于 Spring IOC 的理解，推荐看这一下知乎的一个回答：https://www.zhihu.com/question/23277575/answer/169698662 ，非常不错。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>控制反转怎么理解呢?&lt;/strong> 举个例子：&amp;quot;&lt;strong>对象 a 依赖了对象 b，当对象 a 需要使用 对象 b 的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象 a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b 的时候， 我们可以指定 IOC 容器去创建一个对象 b 注入到对象 a 中&lt;/strong>&amp;quot;。 对象 a 获得依赖对象 b 的过程,由&lt;strong>主动&lt;/strong>行为变为了&lt;strong>被动&lt;/strong>行为，控制权反转，这就是控制反转名字的由来。&lt;/p></description></item><item><title>Spring事务详情</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/ly03ly_spring-transaction/</link><pubDate>Wed, 08 Feb 2023 16:08:16 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/ly03ly_spring-transaction/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>前段时间答应读者的 &lt;strong>Spring 事务&lt;/strong> 分析总结终于来了。这部分内容比较重要，不论是对于工作还是面试，但是网上比较好的参考资料比较少。&lt;/p>
&lt;h2 id="什么是事务">
 什么是事务？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%8b%e5%8a%a1">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。&lt;/strong>&lt;/p>
&lt;p>相信大家应该都能背上面这句话了，下面我结合我们日常的真实开发来谈一谈。&lt;/p>
&lt;p>我们系统的&lt;strong>每个业务方法&lt;/strong>可能包括了&lt;strong>多个原子性的数据库操作&lt;/strong>，比如下面的 &lt;code>savePerson()&lt;/code> 方法中就有&lt;strong>两个&lt;/strong>原子性的数据库操作。&lt;strong>这些&lt;/strong>原子性的数据库&lt;strong>操作&lt;/strong>是&lt;strong>有依赖&lt;/strong>的，它们要么&lt;strong>都执行&lt;/strong>，要不就&lt;strong>都不执行&lt;/strong>。&lt;/p>
&lt;pre tabindex="0">&lt;code>	public void savePerson() {
		personDao.save(person);
		personDetailDao.save(personDetail);
	}
&lt;/code>&lt;/pre>&lt;p>另外，需要格外注意的是：&lt;strong>事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的 &lt;code>innodb&lt;/code>引擎。但是，如果把数据库引擎变为 &lt;code>myisam&lt;/code>，那么程序也就不再支持事务了！&lt;/strong>&lt;/p>
&lt;p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>将小明的余额减少 1000 元。&lt;/li>
&lt;li>将小红的余额增加 1000 元。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>万一在这两个操作之间突然出现错误比如银行系统崩溃或者网络故障，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OrdersService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> AccountDao accountDao;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setOrdersDao&lt;/span>(AccountDao accountDao) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">accountDao&lt;/span> &lt;span style="color:#f92672">=&lt;/span> accountDao;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Transactional&lt;/span>(propagation &lt;span style="color:#f92672">=&lt;/span> Propagation.&lt;span style="color:#a6e22e">REQUIRED&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> isolation &lt;span style="color:#f92672">=&lt;/span> Isolation.&lt;span style="color:#a6e22e">DEFAULT&lt;/span>, readOnly &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>, timeout &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">accountMoney&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//小红账户多1000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		accountDao.&lt;span style="color:#a6e22e">addMoney&lt;/span>(1000,xiaohong);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">//模拟突然出现的异常，比如银行中可能为突然停电等等&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果没有配置事务管理的话会造成，小红账户多了1000而小明账户没有少钱&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 10 &lt;span style="color:#f92672">/&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">//小王账户少1000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		accountDao.&lt;span style="color:#a6e22e">reduceMoney&lt;/span>(1000,xiaoming);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外，数据库事务的 &lt;strong>ACID&lt;/strong> 四大特性是事务的基础，下面简单来了解一下。&lt;/p></description></item><item><title>Spring/SpringBoot常用注解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/ly02ly_spring-annotations/</link><pubDate>Wed, 08 Feb 2023 14:56:32 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/ly02ly_spring-annotations/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h3 id="0前言">
 0.前言
 &lt;a class="anchor" href="#0%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h3>
&lt;p>可以毫不夸张地说，这篇文章介绍的 Spring/SpringBoot 常用注解基本已经涵盖你工作中遇到的大部分常用的场景。对于每一个注解我都说了具体用法，掌握搞懂，使用 SpringBoot 来开发项目基本没啥大问题了！&lt;/p>
&lt;p>&lt;strong>为什么要写这篇文章？&lt;/strong>&lt;/p>
&lt;p>最近看到网上有一篇关于 SpringBoot 常用注解的文章被转载的比较多，我看了文章内容之后属实觉得质量有点低，并且有点会误导没有太多实际使用经验的人（这些人又占据了大多数）。所以，自己索性花了大概 两天时间简单总结一下了。&lt;/p>
&lt;p>&lt;strong>因为我个人的能力和精力有限，如果有任何不对或者需要完善的地方，请帮忙指出！Guide 哥感激不尽！&lt;/strong>&lt;/p>
&lt;h3 id="1-springbootapplication">
 1. &lt;code>@SpringBootApplication&lt;/code>
 &lt;a class="anchor" href="#1-springbootapplication">#&lt;/a>
&lt;/h3>
&lt;p>这里先单独拎出&lt;code>@SpringBootApplication&lt;/code> 注解说一下，虽然我们一般不会主动去使用它。&lt;/p>
&lt;p>&lt;em>Guide 哥：这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SpringBootApplication&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SpringSecurityJwtGuideApplication&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(java.&lt;span style="color:#a6e22e">lang&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SpringApplication.&lt;span style="color:#a6e22e">run&lt;/span>(SpringSecurityJwtGuideApplication.&lt;span style="color:#a6e22e">class&lt;/span>, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以把 &lt;code>@SpringBootApplication&lt;/code>看作是 &lt;code>@Configuration&lt;/code>、&lt;code>@EnableAutoConfiguration&lt;/code>、&lt;code>@ComponentScan&lt;/code> 注解的集合。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> org.springframework.boot.autoconfigure;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Target&lt;/span>(ElementType.&lt;span style="color:#a6e22e">TYPE&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Retention&lt;/span>(RetentionPolicy.&lt;span style="color:#a6e22e">RUNTIME&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Documented&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Inherited&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SpringBootConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@EnableAutoConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ComponentScan&lt;/span>(excludeFilters &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">@Filter&lt;/span>(type &lt;span style="color:#f92672">=&lt;/span> FilterType.&lt;span style="color:#a6e22e">CUSTOM&lt;/span>, classes &lt;span style="color:#f92672">=&lt;/span> TypeExcludeFilter.&lt;span style="color:#a6e22e">class&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">@Filter&lt;/span>(type &lt;span style="color:#f92672">=&lt;/span> FilterType.&lt;span style="color:#a6e22e">CUSTOM&lt;/span>, classes &lt;span style="color:#f92672">=&lt;/span> AutoConfigurationExcludeFilter.&lt;span style="color:#a6e22e">class&lt;/span>) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">@interface&lt;/span> SpringBootApplication {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> org.springframework.boot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Target&lt;/span>(ElementType.&lt;span style="color:#a6e22e">TYPE&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Retention&lt;/span>(RetentionPolicy.&lt;span style="color:#a6e22e">RUNTIME&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Documented&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">@interface&lt;/span> SpringBootConfiguration {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据 SpringBoot 官网，这三个注解的作用分别是：&lt;/p></description></item><item><title>spring 常见面试题总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/</link><pubDate>Tue, 07 Feb 2023 16:48:03 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>这篇文章主要是想通过一些问题，加深大家对于 Spring 的理解，所以不会涉及太多的代码！&lt;/p>
&lt;p>下面的很多问题我自己在使用 Spring 的过程中也并没有注意，自己也是临时查阅了很多资料和书籍补上的。网上也有一些很多关于 Spring 常见问题/面试题整理的文章，我感觉大部分都是互相 copy，而且很多问题也不是很好，有些回答也存在问题。所以，自己花了一周的业余时间整理了一下，希望对大家有帮助。&lt;/p>
&lt;h2 id="spring-基础">
 Spring 基础
 &lt;a class="anchor" href="#spring-%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是-spring-框架">
 什么是 Spring 框架?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-spring-%e6%a1%86%e6%9e%b6">#&lt;/a>
&lt;/h3>
&lt;p>Spring 是一款&lt;strong>开源&lt;/strong>的&lt;strong>轻量级 Java 开发框架&lt;/strong>，旨在提高开发人员的&lt;strong>开发效率&lt;/strong>以及系统的&lt;strong>可维护性&lt;/strong>。&lt;/p>
&lt;p>我们一般说 Spring 框架指的都是 Spring Framework，它是很&lt;strong>多模块的集合&lt;/strong>，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 &lt;strong>IoC&lt;/strong>（&lt;strong>Inversion of Control:控制反转&lt;/strong>） 和 &lt;strong>AOP&lt;/strong>(&lt;strong>Aspect-Oriented Programming:面向切面编程&lt;/strong>)、可以很方便地&lt;strong>对数据库进行访问&lt;/strong>、可以很&lt;strong>方便地集成第三方组件&lt;/strong>（&lt;strong>电子邮件&lt;/strong>，&lt;strong>任务&lt;/strong>，&lt;strong>调度&lt;/strong>，缓存等等）、对&lt;strong>单元测试&lt;/strong>支持比较好、支持 &lt;strong>RESTful Java 应用程序&lt;/strong>的开发。&lt;/p>
&lt;p>[&lt;img src="img/ly-20241212142008049.jpg" alt="img" />&lt;/p>
&lt;p>Spring 最核心的思想就是不重新造轮子，&lt;strong>开箱即用&lt;/strong>，提高开发效率。&lt;/p>
&lt;p>Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！&lt;/p>
&lt;p>🤐 多提一嘴 ： &lt;strong>语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。&lt;/strong>&lt;/p>
&lt;p>Spring 提供的核心功能主要是 &lt;strong>IoC&lt;/strong> 和 &lt;strong>AOP&lt;/strong>。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！&lt;/p>
&lt;ul>
&lt;li>Spring 官网：https://spring.io/&lt;/li>
&lt;li>Github 地址： &lt;a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="spring-包含的模块有哪些">
 Spring 包含的模块有哪些？
 &lt;a class="anchor" href="#spring-%e5%8c%85%e5%90%ab%e7%9a%84%e6%a8%a1%e5%9d%97%e6%9c%89%e5%93%aa%e4%ba%9b">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>Spring4.x 版本&lt;/strong> ：&lt;/p></description></item><item><title>git</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyaly_dev_tools/git/</link><pubDate>Tue, 07 Feb 2023 16:14:19 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyaly_dev_tools/git/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="版本控制">
 版本控制
 &lt;a class="anchor" href="#%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是版本控制">
 什么是版本控制
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>版本控制&lt;/strong>是一种&lt;strong>记录一个&lt;/strong>或&lt;strong>若干文件内容变化&lt;/strong>，以便&lt;strong>将来查阅特定版本修订情况&lt;/strong>的系统。 除了&lt;strong>项目源代码&lt;/strong>，你还可以对&lt;strong>任何类型的文件&lt;/strong>进行版本控制。&lt;/p>
&lt;h3 id="为什么要版本控制">
 为什么要版本控制
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6">#&lt;/a>
&lt;/h3>
&lt;p>有了它你就可以将某个文件&lt;strong>回溯到之前的状态&lt;/strong>，甚至将&lt;strong>整个项目都回退到过去某个时间点&lt;/strong>的状态，你可以&lt;strong>比较&lt;/strong>文件的变化细节，&lt;strong>查出最后&lt;/strong>是谁修改了哪个地方，从而&lt;strong>找出导致怪异问题&lt;/strong>出现的原因，又是&lt;strong>谁在何时报告了&lt;/strong>某个功能缺陷等等。&lt;/p>
&lt;h3 id="本地版本控制系统">
 本地版本控制系统
 &lt;a class="anchor" href="#%e6%9c%ac%e5%9c%b0%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e7%b3%bb%e7%bb%9f">#&lt;/a>
&lt;/h3>
&lt;p>许多人习惯用&lt;strong>复制整个项目&lt;/strong>目录的方式来&lt;strong>保存不同的版本&lt;/strong>，或许还会&lt;strong>改名加上备份时间&lt;/strong>以示区别。 这么做唯一的好处就是&lt;strong>简单&lt;/strong>，但是特别容&lt;strong>易犯错&lt;/strong>。 有时候会&lt;strong>混淆&lt;/strong>所在的工作目录，一不小心会&lt;strong>写错&lt;/strong>文件或者&lt;strong>覆盖&lt;/strong>意想外的文件。&lt;/p>
&lt;p>为了解决这个问题，人们很久以前就开发了许多种&lt;strong>本地版本控制&lt;/strong>系统，大多都是采用某种&lt;strong>简单的数据库&lt;/strong>来&lt;strong>记录文件的历次更新&lt;/strong>差异。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142006392.png" alt="image.png" />&lt;/p>
&lt;h3 id="集中化的版本控制系统">
 集中化的版本控制系统
 &lt;a class="anchor" href="#%e9%9b%86%e4%b8%ad%e5%8c%96%e7%9a%84%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e7%b3%bb%e7%bb%9f">#&lt;/a>
&lt;/h3>
&lt;p>接下来人们又遇到一个问题，如何让在&lt;strong>不同系统上的开发者协同&lt;/strong>工作？ 于是，&lt;strong>集中化的版本控制&lt;/strong>系统（&lt;strong>Centralized Version Control Systems&lt;/strong>，简称 &lt;strong>CVCS&lt;/strong>）应运而生。&lt;/p>
&lt;p>集中化的版本控制系统都有一个&lt;strong>单一的集中管理的服务器&lt;/strong>，&lt;strong>保存所有文件的修订版本&lt;/strong>，而协同工作的人们都通过客户端&lt;strong>连到这台服务器&lt;/strong>，取出&lt;strong>最新&lt;/strong>的文件或者&lt;strong>提交更新&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142006663.png" alt="image.png" />&lt;/p>
&lt;p>这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>单点故障：&lt;/strong> &lt;strong>中央服务器宕机&lt;/strong>，则其他人无法使用；如果中心数据库磁盘损坏又没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被&lt;strong>保存在单一&lt;/strong>位置，就有&lt;strong>丢失所有历史更新记录&lt;/strong>的风险。&lt;/li>
&lt;li>&lt;strong>必须联网才能工作：&lt;/strong> &lt;strong>受网络&lt;/strong>状况、带宽影响。&lt;/li>
&lt;/ul>
&lt;h3 id="分布式版本控制系统">
 分布式版本控制系统
 &lt;a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e7%b3%bb%e7%bb%9f">#&lt;/a>
&lt;/h3>
&lt;p>于是分布式版本控制系统（&lt;strong>Distributed Version Control System&lt;/strong>，简称 &lt;strong>DVCS&lt;/strong>）面世了。 Git 就是一个典型的分布式版本控制系统。&lt;/p>
&lt;p>这类系统，客户端并&lt;strong>不只提取最新版本的文件快照&lt;/strong>，而是把&lt;strong>代码仓库完整地镜像&lt;/strong>下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用&lt;strong>任何一个镜像出来的本地仓库&lt;/strong>恢复。 因为每一次的克隆操作，实际上都是一次对&lt;strong>代码仓库的完整备份&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142006803.png" alt="image.png" />&lt;/p>
&lt;p>分布式版本控制系统可以&lt;strong>不用联网就可以工作&lt;/strong>，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要&lt;strong>将自己的修改推送给别人&lt;/strong>就可以了。但是，在实际使用分布式版本控制系统的时候，很少会&lt;strong>直接进行推送&lt;/strong>修改，而是&lt;strong>使用一台充当“中央服务器”&lt;strong>的东西。这个服务器的作用仅仅是用来&lt;/strong>方便“交换”大家的修改&lt;/strong>，没有它大家也一样干活，只是交换修改不方便而已。&lt;/p>
&lt;p>分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其&lt;strong>强大的分支管理&lt;/strong>等功能。&lt;/p>
&lt;h2 id="认识-git">
 认识 Git
 &lt;a class="anchor" href="#%e8%ae%a4%e8%af%86-git">#&lt;/a>
&lt;/h2>
&lt;h3 id="git-简史">
 Git 简史
 &lt;a class="anchor" href="#git-%e7%ae%80%e5%8f%b2">#&lt;/a>
&lt;/h3>
&lt;p>Linux 内核项目组当时使用分布式版本控制系统 &lt;strong>BitKeeper&lt;/strong> 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 &lt;strong>Linus Torvalds&lt;/strong>）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。&lt;/p></description></item><item><title>maven</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyaly_dev_tools/maven/</link><pubDate>Tue, 07 Feb 2023 13:28:19 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/lyaly_dev_tools/maven/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>这部分内容主要根据 Maven 官方文档整理，做了对应的删减，主要保留比较重要的部分，不涉及实战，主要是一些重要概念的介绍。&lt;/p>
&lt;/blockquote>
&lt;h2 id="maven-介绍">
 Maven 介绍
 &lt;a class="anchor" href="#maven-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://github.com/apache/maven">Maven&lt;/a> 官方文档是这样介绍的 Maven 的：&lt;/p>
&lt;blockquote>
&lt;p>Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project&amp;rsquo;s build, reporting and documentation from a central piece of information.&lt;/p>
&lt;p>Apache Maven 的本质是一个&lt;strong>软件项目管理&lt;/strong>和&lt;strong>理解&lt;/strong>工具。基于&lt;strong>项目对象模型&lt;/strong> (&lt;strong>Project Object Model&lt;/strong>，POM) 的概念，Maven 可以从&lt;strong>一条中心信息&lt;/strong> &lt;strong>管理&lt;/strong>项目的&lt;strong>构建&lt;/strong>、&lt;strong>报告&lt;/strong>和&lt;strong>文档&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>什么是 POM？&lt;/strong> 每一个 Maven 工程都有一个 &lt;strong>&lt;code>pom.xml&lt;/code>&lt;/strong> 文件，位于根目录中，包含项目&lt;strong>构建生命周期&lt;/strong>的详细信息。通过 &lt;code>pom.xml&lt;/code> 文件，我们可以定义&lt;strong>项目&lt;/strong>的&lt;strong>坐标&lt;/strong>、&lt;strong>项目依赖&lt;/strong>、&lt;strong>项目信息&lt;/strong>、&lt;strong>插件信息&lt;/strong>等等配置。&lt;/p>
&lt;p>对于开发者来说，Maven 的主要作用主要有 3 个：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>项目构建&lt;/strong> ：提供&lt;strong>标准&lt;/strong>的、&lt;strong>跨平台&lt;/strong>的&lt;strong>自动化项目构建&lt;/strong>方式。&lt;/li>
&lt;li>&lt;strong>依赖管理&lt;/strong> ：&lt;strong>方便快捷&lt;/strong>的&lt;strong>管理项目依赖的资源&lt;/strong>（&lt;strong>jar 包&lt;/strong>），避免&lt;strong>资源间的版本冲突&lt;/strong>问题。&lt;/li>
&lt;li>&lt;strong>统一开发结构&lt;/strong> ：提供&lt;strong>标准&lt;/strong>的、&lt;strong>统一&lt;/strong>的&lt;strong>项目结构&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>关于 Maven 的基本使用这里就不介绍了，建议看看官网的 5 分钟上手 Maven 的教程：&lt;a href="https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html">Maven in 5 Minutes&lt;/a> 。&lt;/p></description></item><item><title>Atomic预备知识</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly030301lyatomicpre/</link><pubDate>Fri, 03 Feb 2023 11:04:33 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly030301lyatomicpre/</guid><description>&lt;h3 id="java实现cas的原理非javaguide">
 Java实现CAS的原理[非javaguide]
 &lt;a class="anchor" href="#java%e5%ae%9e%e7%8e%b0cas%e7%9a%84%e5%8e%9f%e7%90%86%e9%9d%9ejavaguide">#&lt;/a>
&lt;/h3>
&lt;p>i++是非线程安全的，因为&lt;strong>i++不是原子&lt;/strong>操作；可以使用&lt;strong>synchronized和CAS实现加锁&lt;/strong>&lt;/p>
&lt;p>&lt;strong>synchronized是悲观锁&lt;/strong>，一旦获得锁，其他线程进入后就会阻塞等待锁；而&lt;strong>CAS是乐观锁&lt;/strong>，执行时不会加锁，假设没有冲突，&lt;strong>如果因为冲突失败了就重试&lt;/strong>，直到成功&lt;/p>
&lt;ul>
&lt;li>
&lt;p>乐观锁和悲观锁&lt;/p>
&lt;ul>
&lt;li>这是一种分类方式&lt;/li>
&lt;li>&lt;strong>悲观锁&lt;/strong>，总是认为&lt;strong>每次访问共享资源会发生冲突&lt;/strong>，所以&lt;strong>必须对每次数据操作加锁&lt;/strong>，以&lt;strong>保证临界区的程序同一时间只能有一个线程&lt;/strong>在执行&lt;/li>
&lt;li>乐观锁，又称**“无锁”**，&lt;strong>假设对共享资源访问没有冲突&lt;/strong>，线程可以不停的执行，无需加锁无需等待；一旦发生冲突，通常是使用一种称为CAS的技术保证线程执行安全
&lt;ul>
&lt;li>无锁没有锁的存在，因此不可能发生死锁，即&lt;strong>乐观锁天生免疫死锁&lt;/strong>&lt;/li>
&lt;li>乐观锁用于**“读多写少”&lt;strong>的环境，&lt;strong>避免加锁频繁影响性能&lt;/strong>；悲观锁用于&lt;/strong>“写多读少”&lt;strong>，避免&lt;/strong>频繁失败及重试**影响性能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>CAS概念，即CompareAndSwap ，比较和交换，CAS中，有三个值（概念上）&lt;br>
V：要更新的变量(var)；E：期望值（expected）；N：新值（new）
判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。
一般来说，预期值E本质上指的是“旧值”（判断是否修改了）&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>如果有一个多个线程共享的变量&lt;code>i&lt;/code>原本等于5，我现在在线程A中，想把它设置为新的值6;&lt;/li>
&lt;li>我们使用CAS来做这个事情；&lt;/li>
&lt;li>（首先要把原来的值5在线程中保存起来）&lt;/li>
&lt;li>接下来是原子操作：首先我们&lt;strong>用（现在的i）去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6&lt;/strong>，此次CAS成功，&lt;code>i&lt;/code>的值被设置成了6；&lt;/li>
&lt;li>如果不等于5，说明&lt;code>i&lt;/code>被其它线程改过了（比如现在&lt;code>i&lt;/code>的值为2），那么我就什么也不做，此次CAS失败，&lt;code>i&lt;/code>的值仍然为2。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>其中i为V，5为E，6为N&lt;/p>
&lt;/blockquote>
&lt;p>CAS是一种原子操作，它是一种系统原语，是一条CPU原子指令，从CPU层面保证它的原子性（&lt;strong>不可能出现说，判断了对比了i为5之后，正准备更新它的值，此时该值被其他线程改了&lt;/strong>）&lt;/p>
&lt;p>当&lt;strong>多个线程同时使用CAS操作一个变量&lt;/strong>时，&lt;strong>只有一个会胜出，并成功更新&lt;/strong>，&lt;strong>其余均会失败&lt;/strong>，但&lt;strong>失败的线程并不会被挂起&lt;/strong>，仅是&lt;strong>被告知失败，并且允许再次尝试&lt;/strong>，当然也&lt;strong>允许失败的线程放弃&lt;/strong>操作。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Java实现CAS的原理 - Unsafe类&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在Java中，如果一个方法是native的，那Java就不负责具体实现它，而是交给底层的JVM使用c或者c++去实现&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Java中有一个Unsafe类，在sun.misc包中，里面有一些native方法，其中包括：&lt;/p>
&lt;blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">compareAndSwapObject&lt;/span>(Object o, &lt;span style="color:#66d9ef">long&lt;/span> offset,Object expected, Object x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">compareAndSwapInt&lt;/span>(Object o, &lt;span style="color:#66d9ef">long&lt;/span> offset,&lt;span style="color:#66d9ef">int&lt;/span> expected,&lt;span style="color:#66d9ef">int&lt;/span> x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">compareAndSwapLong&lt;/span>(Object o, &lt;span style="color:#66d9ef">long&lt;/span> offset,&lt;span style="color:#66d9ef">long&lt;/span> expected,&lt;span style="color:#66d9ef">long&lt;/span> x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//------&amp;gt;AtomicInteger.class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AtomicInteger&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Number &lt;span style="color:#66d9ef">implements&lt;/span> java.&lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Serializable&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> serialVersionUID &lt;span style="color:#f92672">=&lt;/span> 6214790243416807050L;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// setup to use Unsafe.compareAndSwapInt for updates&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Unsafe unsafe &lt;span style="color:#f92672">=&lt;/span> Unsafe.&lt;span style="color:#a6e22e">getUnsafe&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> valueOffset;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> valueOffset &lt;span style="color:#f92672">=&lt;/span> unsafe.&lt;span style="color:#a6e22e">objectFieldOffset&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (AtomicInteger.&lt;span style="color:#a6e22e">class&lt;/span>.&lt;span style="color:#a6e22e">getDeclaredField&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;value&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (Exception ex) { &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Error(ex); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">volatile&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">getAndIncrement&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">return&lt;/span> unsafe.&lt;span style="color:#a6e22e">getAndAddInt&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, valueOffset, 1);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;pre>&lt;code>}
&lt;/code>&lt;/pre>
&lt;p>}&lt;/p></description></item><item><title>MySQL高性能优化规范建议总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0611lymysql-high-performance-optimization-specification-recommendations/</link><pubDate>Fri, 20 Jan 2023 11:36:34 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0611lymysql-high-performance-optimization-specification-recommendations/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>索引优化相关&lt;/p>
&lt;ol>
&lt;li>in 代替 or&lt;/li>
&lt;li>not exist 代替 not in&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h1 id="数据库命名规范">
 数据库命名规范
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%91%bd%e5%90%8d%e8%a7%84%e8%8c%83">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>所有&lt;strong>数据库对象&lt;/strong>名称必须使用&lt;strong>小写字母&lt;/strong>并用&lt;strong>下划线分割&lt;/strong>&lt;/li>
&lt;li>所有数据库对象名称&lt;strong>禁止使用 MySQL 保留关键字&lt;/strong>（如果表名中包含关键字查询时，需要将其用单引号括起来）&lt;/li>
&lt;li>数据库对象的命名要能做到&lt;strong>见名识意&lt;/strong>，并且最好&lt;strong>不要超过 32 个&lt;/strong>字符&lt;/li>
&lt;li>&lt;strong>临时库表&lt;/strong>必须&lt;strong>以 &lt;code>tmp_&lt;/code> 为前缀&lt;/strong>并以日期为后缀，&lt;strong>备份表&lt;/strong>必须&lt;strong>以 &lt;code>bak_&lt;/code> 为前缀&lt;/strong>并&lt;strong>以日期 (时间戳) 为后缀&lt;/strong>&lt;/li>
&lt;li>所有&lt;strong>存储相同数据的列名和列类型&lt;/strong>必须一致（&lt;strong>一般作为关联列&lt;/strong>，如果查询时关联列&lt;strong>类型不一致会自动进行数据类型隐式转换&lt;/strong>，会&lt;strong>造成列上的索引失效&lt;/strong>，导致查询效率降低）&lt;/li>
&lt;/ul>
&lt;h1 id="数据库基本设计规范">
 数据库基本设计规范
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%9f%ba%e6%9c%ac%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83">#&lt;/a>
&lt;/h1>
&lt;h2 id="所有表必须使用innodb存储引擎">
 所有表必须使用InnoDB存储引擎
 &lt;a class="anchor" href="#%e6%89%80%e6%9c%89%e8%a1%a8%e5%bf%85%e9%a1%bb%e4%bd%bf%e7%94%a8innodb%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。&lt;/li>
&lt;li>InnoDB 支持&lt;strong>事务&lt;/strong>，支持&lt;strong>行级锁&lt;/strong>，更好的&lt;strong>恢复性&lt;/strong>，&lt;strong>高并发&lt;/strong>下性能更好&lt;/li>
&lt;/ul>
&lt;h2 id="数据库和表的字符集统一使用utf-8">
 数据库和表的字符集统一使用UTF-8
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%92%8c%e8%a1%a8%e7%9a%84%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bb%9f%e4%b8%80%e4%bd%bf%e7%94%a8utf-8">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>兼容性&lt;/strong>更好，&lt;strong>统一字符集&lt;/strong>可以避免由于字符集转换产生的&lt;strong>乱码&lt;/strong>，不同的字符集进行比较前需要进行转换会造成&lt;strong>索引失效&lt;/strong>，如果数据库中有&lt;strong>存储 emoji 表情&lt;/strong>的需要，字符集需要采用 &lt;strong>utf8mb4&lt;/strong> 字符集。&lt;/p>
&lt;p>参考文章：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/horses/article/details/107243447">MySQL 字符集不一致导致索引失效的一个真实案例open in new window&lt;/a>&lt;/li>
&lt;li>[MySQL 字符集详解&lt;/li>
&lt;/ul>
&lt;h2 id="所有表和字段都需要添加注释">
 所有表和字段都需要添加注释
 &lt;a class="anchor" href="#%e6%89%80%e6%9c%89%e8%a1%a8%e5%92%8c%e5%ad%97%e6%ae%b5%e9%83%bd%e9%9c%80%e8%a6%81%e6%b7%bb%e5%8a%a0%e6%b3%a8%e9%87%8a">#&lt;/a>
&lt;/h2>
&lt;p>使用 &lt;strong>comment 从句添加表&lt;/strong>和&lt;strong>列的备注&lt;/strong>，从一开始就进行数据字典的维护&lt;/p>
&lt;h2 id="尽量控制单表数据量的大小建议控制在500万以内">
 尽量控制单表数据量的大小，建议控制在500万以内
 &lt;a class="anchor" href="#%e5%b0%bd%e9%87%8f%e6%8e%a7%e5%88%b6%e5%8d%95%e8%a1%a8%e6%95%b0%e6%8d%ae%e9%87%8f%e7%9a%84%e5%a4%a7%e5%b0%8f%e5%bb%ba%e8%ae%ae%e6%8e%a7%e5%88%b6%e5%9c%a8500%e4%b8%87%e4%bb%a5%e5%86%85">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>500 万并不是 MySQL 数据库的限制，&lt;strong>过大会造成修改表结构&lt;/strong>，&lt;strong>备份&lt;/strong>，&lt;strong>恢复&lt;/strong>都会有很大的问题。&lt;/p></description></item><item><title>MySQL常见面试题总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0610lymysql-questions-01/</link><pubDate>Fri, 20 Jan 2023 11:36:06 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0610lymysql-questions-01/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!====&lt;/p>
&lt;/blockquote>
&lt;h1 id="mysql基础">
 MySQL基础
 &lt;a class="anchor" href="#mysql%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h1>
&lt;h2 id="关系型数据库介绍">
 关系型数据库介绍
 &lt;a class="anchor" href="#%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>关系型数据库&lt;/strong>，建立在&lt;strong>关系模型&lt;/strong>的基础上的数据库。表明数据库中所&lt;strong>存储&lt;/strong>的数据之间的&lt;strong>联系&lt;/strong>（一对一、一对多、多对多）&lt;/li>
&lt;li>关系型数据库中，我们的数据都被&lt;strong>存放在各种表&lt;/strong>中（比如用户表），表中的&lt;strong>每一行&lt;/strong>存放着&lt;strong>一条数据（比如一个用户的信息）&lt;/strong>
&lt;img src="img/ly-20241212141910786.png" alt="关系型数据库表关系" />&lt;/li>
&lt;li>大部分关系型数据库都使用&lt;strong>SQL&lt;/strong>来操作数据库中的数据，并且大部分&lt;strong>关系型数据库&lt;/strong>都支持&lt;strong>事务&lt;/strong>的&lt;strong>四大特性（ACID）&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>常见的关系型数据库&lt;/strong>&lt;br>
&lt;strong>MySQL&lt;/strong>、&lt;strong>PostgreSQL&lt;/strong>、&lt;strong>Oracle&lt;/strong>、&lt;strong>SQL Server&lt;/strong>、&lt;strong>SQLite&lt;/strong>（&lt;strong>微信本地的聊天记录&lt;/strong>的存储就是用的 SQLite） &amp;hellip;&amp;hellip;&lt;/p>
&lt;h2 id="mysql介绍">
 MySQL介绍
 &lt;a class="anchor" href="#mysql%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212141911084.png" alt="img" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>MySQL是一种&lt;strong>关系型数据库&lt;/strong>，主要用于&lt;strong>持久化存储&lt;/strong>我们系统中的一些数据比如&lt;strong>用户信息&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于 MySQL 是&lt;strong>开源&lt;/strong>免费并且比较&lt;strong>成熟&lt;/strong>的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 &lt;strong>GPL(General Public License 通用性公开许可证)&lt;/strong> 的许可下下载并根据&lt;strong>个性化的需要&lt;/strong>对其进行&lt;strong>修改&lt;/strong>。MySQL 的默认端口号是&lt;strong>3306&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="mysql基础架构">
 MySQL基础架构
 &lt;a class="anchor" href="#mysql%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>MySQL的一个&lt;strong>简要机构图&lt;/strong>，客户端的一条&lt;strong>SQL语句&lt;/strong>在MySQL内部如何执行
&lt;img src="img/ly-20241212141911246.png" alt="ly-20241212141911246" />&lt;/li>
&lt;li>MySQL主要由几部分构成
&lt;ol>
&lt;li>&lt;strong>连接器&lt;/strong>：&lt;strong>身份认证&lt;/strong>和&lt;strong>权限相关&lt;/strong>（登录MySQL的时候）&lt;/li>
&lt;li>&lt;strong>查询缓存&lt;/strong>：执行&lt;strong>查询&lt;/strong>语句的时候，会先&lt;strong>查询缓存&lt;/strong>（MySQL8.0版本后&lt;strong>移除&lt;/strong>，因为这个功能不太实用）&lt;/li>
&lt;li>&lt;strong>分析器&lt;/strong>：&lt;strong>没有命中缓存&lt;/strong>的话，SQL语句就会经过分析器，分析器说白了就是要先看你的SQL语句&lt;strong>要干嘛&lt;/strong>，再检查你的&lt;strong>SQL语句语法&lt;/strong>是否正确&lt;/li>
&lt;li>&lt;strong>优化器&lt;/strong>：按照&lt;strong>MySQL认为最优的方案&lt;/strong>去执行&lt;/li>
&lt;li>&lt;strong>执行器&lt;/strong>：&lt;strong>执行&lt;/strong>语句，然后从&lt;strong>存储引擎返回&lt;/strong>数据。执行语句之前会&lt;strong>先判断是否有权限&lt;/strong>，如果没有权限，就会报错&lt;/li>
&lt;li>&lt;strong>插件式存储引擎&lt;/strong>：主要负责&lt;strong>数据&lt;/strong>的&lt;strong>存储&lt;/strong>和&lt;strong>读取&lt;/strong>，采用的是&lt;strong>插件式架构&lt;/strong>，支持&lt;strong>InnoDB&lt;/strong>、&lt;strong>MyISAM&lt;/strong>、&lt;strong>Memory&lt;/strong>等多种存储引擎&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h1 id="mysql存储引擎">
 MySQL存储引擎
 &lt;a class="anchor" href="#mysql%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e">#&lt;/a>
&lt;/h1>
&lt;p>MySQL&lt;strong>核心&lt;/strong>在于&lt;strong>存储引擎&lt;/strong>&lt;/p>
&lt;h2 id="mysql支持哪些存储引擎默认使用哪个">
 MySQL支持哪些存储引擎？默认使用哪个？
 &lt;a class="anchor" href="#mysql%e6%94%af%e6%8c%81%e5%93%aa%e4%ba%9b%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e9%bb%98%e8%ae%a4%e4%bd%bf%e7%94%a8%e5%93%aa%e4%b8%aa">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>MySQL支持&lt;strong>多种存储引擎&lt;/strong>，可以通过&lt;code>show engines&lt;/code>命令来&lt;strong>查看MySQL支持的所有存储引擎&lt;/strong>
&lt;img src="img/ly-20241212141911409.png" alt="查看 MySQL 提供的所有存储引擎" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>默认&lt;/strong>存储引擎为InnoDB，并且，所有存储引擎中&lt;strong>只有InnoDB是事务性存储引擎&lt;/strong>，也就是说&lt;strong>只有InnoDB支持事务&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>这里使用MySQL 8.x&lt;/strong>
MySQL 5.5.5之前，MyISAM是MySQL的默认存储引擎；5.5.5之后，InnoDB是MySQL的默认存储引擎，可以通过&lt;code>select version()&lt;/code>命令查看你的MySQL版本&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>mysql&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#a6e22e">version&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+-----------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#a6e22e">version&lt;/span>() &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+-----------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>.&lt;span style="color:#ae81ff">0&lt;/span>.&lt;span style="color:#ae81ff">27&lt;/span> &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+-----------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span> row &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#66d9ef">set&lt;/span> (&lt;span style="color:#ae81ff">0&lt;/span>.&lt;span style="color:#ae81ff">00&lt;/span> sec) 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用&lt;code>show variables like %storage_engine%&lt;/code>命令直接查看MySQL&lt;strong>当前默认的存储引擎&lt;/strong> &lt;br>
&lt;img src="img/ly-20241212141911580.png" alt="查看 MySQL 当前默认的存储引擎" />&lt;/p></description></item><item><title>MySQL中的隐式转换造成的索引失效</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0609lyindex-invalidation-caused-by-implicit-conversion/</link><pubDate>Thu, 19 Jan 2023 17:10:48 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0609lyindex-invalidation-caused-by-implicit-conversion/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;p>本篇文章基于MySQL 5.7.26，原文：https://www.guitu18.com/post/2019/11/24/61.html&lt;/p>
&lt;/blockquote>
&lt;h1 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>关于&lt;strong>数据库优化&lt;/strong>，最常见的莫过于&lt;strong>索引失效&lt;/strong>，数据量多的时候比较明显，处理不及时会造成&lt;strong>雪球效应&lt;/strong>，最终导致&lt;strong>数据库卡死甚至瘫痪&lt;/strong>。&lt;/li>
&lt;li>这里说的是&lt;strong>隐式转换造成的索引失效&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="数据准备">
 数据准备
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%87%86%e5%a4%87">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 创建测试数据表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span> test1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>test1&lt;span style="color:#f92672">`&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(&lt;span style="color:#ae81ff">11&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>num1&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(&lt;span style="color:#ae81ff">11&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>num2&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">varchar&lt;/span>(&lt;span style="color:#ae81ff">11&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>type1&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(&lt;span style="color:#ae81ff">4&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>type2&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(&lt;span style="color:#ae81ff">4&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>str1&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">varchar&lt;/span>(&lt;span style="color:#ae81ff">100&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>str2&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">varchar&lt;/span>(&lt;span style="color:#ae81ff">100&lt;/span>) &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>num1&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>num1&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>num2&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>num2&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>type1&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>type1&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>str1&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>str1&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>str2&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>str2&lt;span style="color:#f92672">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) &lt;span style="color:#66d9ef">ENGINE&lt;/span>&lt;span style="color:#f92672">=&lt;/span>InnoDB &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">CHARSET&lt;/span>&lt;span style="color:#f92672">=&lt;/span>utf8;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 创建存储过程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">PROCEDURE&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span> pre_test1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DELIMITER &lt;span style="color:#f92672">//&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">PROCEDURE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>pre_test1&lt;span style="color:#f92672">`&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BEGIN
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">DECLARE&lt;/span> i &lt;span style="color:#66d9ef">INT&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> autocommit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">WHILE&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">10000000&lt;/span> DO
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#f92672">@&lt;/span>str1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">SUBSTRING&lt;/span>(&lt;span style="color:#a6e22e">MD5&lt;/span>(&lt;span style="color:#a6e22e">RAND&lt;/span>()),&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">20&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 每100条数据str2产生一个null值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">THEN&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#f92672">@&lt;/span>str2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">ELSE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#f92672">@&lt;/span>str2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">@&lt;/span>str1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> END &lt;span style="color:#66d9ef">IF&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#a6e22e">test1&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>num1&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>num2&lt;span style="color:#f92672">`&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>type1&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>type2&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>str1&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>str2&lt;span style="color:#f92672">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">VALUES&lt;/span> (&lt;span style="color:#a6e22e">CONCAT&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, i), &lt;span style="color:#a6e22e">CONCAT&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, i),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">CONCAT&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, i), i&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>, i&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#f92672">@&lt;/span>str1, &lt;span style="color:#f92672">@&lt;/span>str2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 事务优化，每一万条数据提交一次事务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">THEN&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> COMMIT;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> END &lt;span style="color:#66d9ef">IF&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> END &lt;span style="color:#66d9ef">WHILE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>END;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">//&lt;/span> DELIMITER ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 执行存储过程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CALL&lt;/span> &lt;span style="color:#a6e22e">pre_test1&lt;/span>(); 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中，七个字段，首先使用存储过程生成 1000 万条测试数据， 测试表一共建立了 7 个字段（包括主键），&lt;strong>&lt;code>num1&lt;/code>&lt;strong>和&lt;/strong>&lt;code>num2&lt;/code>&lt;strong>保存的是和&lt;code>ID&lt;/code>一样的顺序数字，其中&lt;/strong>&lt;code>num2&lt;/code>是字符串类型&lt;/strong>。 &lt;strong>&lt;code>type1&lt;/code>&lt;strong>和&lt;/strong>&lt;code>type2&lt;/code>&lt;strong>保存的都是主键对 5 的取模，目的是模拟实际应用中常用&lt;/strong>类似 type 类型&lt;/strong>的数据，但是**&lt;code>type2&lt;/code>是没有建立索引&lt;strong>的。 &lt;code>str1&lt;/code>和&lt;code>str2&lt;/code>都是保存了一个 &lt;strong>20 位长度的随机字符串&lt;/strong>，&lt;/strong>&lt;code>str1&lt;/code>不能为&lt;code>NULL&lt;/code>，&lt;code>str2&lt;/code>允许为&lt;code>NULL&lt;/code>&lt;strong>，相应的生成测试数据的时候我也会&lt;/strong>在&lt;code>str2&lt;/code>字段生产少量&lt;code>NULL&lt;/code>值**（每 100 条数据产生一个&lt;code>NULL&lt;/code>值）。&lt;/p></description></item><item><title>MySQL数据库时间类型数据存储建议</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0608lysome-thoughts-on-database-storage-time/</link><pubDate>Thu, 19 Jan 2023 17:10:06 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0608lysome-thoughts-on-database-storage-time/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="不要用字符串存储日期">
 不要用字符串存储日期
 &lt;a class="anchor" href="#%e4%b8%8d%e8%a6%81%e7%94%a8%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ad%98%e5%82%a8%e6%97%a5%e6%9c%9f">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>优点：简单直白&lt;/li>
&lt;li>缺点
&lt;ol>
&lt;li>字符串&lt;strong>占有的空间更大&lt;/strong>&lt;/li>
&lt;li>字符串存储的日期&lt;strong>效率比较低&lt;/strong>（逐个字符进行比较），&lt;strong>无法用日期相关的API&lt;/strong>进行计算和比较&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h1 id="datetime和timestamp之间抉择">
 Datetime和Timestamp之间抉择
 &lt;a class="anchor" href="#datetime%e5%92%8ctimestamp%e4%b9%8b%e9%97%b4%e6%8a%89%e6%8b%a9">#&lt;/a>
&lt;/h1>
&lt;p>Datetime 和 Timestamp 是 MySQL 提供的两种&lt;strong>比较相似&lt;/strong>的保存时间的数据类型。他们两者究竟该如何选择呢？&lt;/p>
&lt;p>&lt;strong>通常我们都会首选 Timestamp&lt;/strong>&lt;/p>
&lt;h2 id="datetime类型没有时区信息">
 Datetime类型没有时区信息
 &lt;a class="anchor" href="#datetime%e7%b1%bb%e5%9e%8b%e6%b2%a1%e6%9c%89%e6%97%b6%e5%8c%ba%e4%bf%a1%e6%81%af">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>DateTime 类型是没有时区信息的（时区无关）&lt;/strong> ，DateTime 类型保存的时间都是&lt;strong>当前会话所设置的时区&lt;/strong>对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。不要小看这个问题，很多系统就是因为这个问题闹出了很多笑话。&lt;/li>
&lt;li>&lt;strong>Timestamp 和时区有关&lt;/strong>。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是&lt;strong>在不同时区&lt;/strong>，&lt;strong>查询到同一个条记录此字段的值会不一样&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>案例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 建表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>time_zone_test&lt;span style="color:#f92672">`&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">bigint&lt;/span>(&lt;span style="color:#ae81ff">20&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">AUTO_INCREMENT&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>date_time&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">datetime&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>time_stamp&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">timestamp&lt;/span> &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">CURRENT_TIMESTAMP&lt;/span> &lt;span style="color:#66d9ef">ON&lt;/span> &lt;span style="color:#66d9ef">UPDATE&lt;/span> &lt;span style="color:#66d9ef">CURRENT_TIMESTAMP&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) &lt;span style="color:#66d9ef">ENGINE&lt;/span>&lt;span style="color:#f92672">=&lt;/span>InnoDB &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">CHARSET&lt;/span>&lt;span style="color:#f92672">=&lt;/span>utf8; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 插入数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#a6e22e">time_zone_test&lt;/span>(date_time,time_stamp) &lt;span style="color:#66d9ef">VALUES&lt;/span>(&lt;span style="color:#a6e22e">NOW&lt;/span>(),&lt;span style="color:#a6e22e">NOW&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 查看数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">select&lt;/span> date_time,time_stamp &lt;span style="color:#66d9ef">from&lt;/span> time_zone_test;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 结果
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> +---------------------+---------------------+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">| date_time | time_stamp |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">+---------------------+---------------------+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">| 2020-01-11 09:53:32 | 2020-01-11 09:53:32 |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">+---------------------+---------------------+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">------ 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修改时区并查看数据&lt;/p></description></item><item><title>SQL语句在MySQL中的执行过程</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0605lyhow-sql-executed-in-mysql/</link><pubDate>Thu, 19 Jan 2023 10:20:57 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0605lyhow-sql-executed-in-mysql/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;p>原文 &lt;a href="https://github.com/kinglaw1204">https://github.com/kinglaw1204&lt;/a> 感谢作者&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>本篇文章会分析&lt;strong>一个SQL语句&lt;/strong>在MySQL的&lt;strong>执行流程&lt;/strong>，包括&lt;strong>SQL的查询&lt;/strong>在MySQL内部会怎么&lt;strong>流转&lt;/strong>，&lt;strong>SQL语句的更新&lt;/strong>是怎么完成的&lt;/li>
&lt;li>分析之前先看看&lt;strong>MySQL的基础架构&lt;/strong>，知道了MySQL由&lt;strong>哪些组件&lt;/strong>组成以及&lt;strong>这些组件的作用&lt;/strong>是什么，可以帮助我们&lt;strong>理解&lt;/strong>和&lt;strong>解决&lt;/strong>这些问题&lt;/li>
&lt;/ul>
&lt;h1 id="mysql基础架构分析">
 MySQL基础架构分析
 &lt;a class="anchor" href="#mysql%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h1>
&lt;p>&lt;img src="img/ly-20241212141908611.png" alt="ly-20241212141908611" />&lt;/p>
&lt;h2 id="mysql基本架构概览">
 MySQL基本架构概览
 &lt;a class="anchor" href="#mysql%e5%9f%ba%e6%9c%ac%e6%9e%b6%e6%9e%84%e6%a6%82%e8%a7%88">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>下图是MySQL的简要架构图，从下图可以看到&lt;strong>用户的SQL语句&lt;/strong>在MySQL内部是&lt;strong>如何执行的&lt;/strong>&lt;/li>
&lt;li>先简单介绍一个下图涉及的一些组件的基本作用
&lt;img src="img/ly-20241212141908907.png" alt="ly-20241212141908907" />
&lt;ol>
&lt;li>&lt;strong>连接器&lt;/strong>： &lt;strong>身份认证&lt;/strong>和&lt;strong>权限相关&lt;/strong>（登录MySQL的时候）&lt;/li>
&lt;li>&lt;strong>查询缓存&lt;/strong>：执行查询语句的时候，会&lt;strong>先查询缓存&lt;/strong>（MySQL8.0版本后移除，因为这个功能不太实用）&lt;/li>
&lt;li>&lt;strong>分析器&lt;/strong>：&lt;strong>没有命中&lt;/strong>缓存的话，SQL语句就会经过分析器，分析器说白了就是要&lt;strong>先看&lt;/strong>你的SQL语句干嘛，再&lt;strong>检查&lt;/strong>你的SQL语句&lt;strong>语法&lt;/strong>是否正确&lt;/li>
&lt;li>&lt;strong>优化器&lt;/strong>：按照&lt;strong>MySQL认为最优的方案&lt;/strong>去执行&lt;/li>
&lt;li>&lt;strong>执行器&lt;/strong>：&lt;strong>执行语句&lt;/strong>，然后从&lt;strong>存储引擎&lt;/strong>返回数据&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>简单来说 MySQL 主要分为 Server 层和存储引擎层：
&lt;ul>
&lt;li>&lt;strong>Server 层&lt;/strong>：主要包括&lt;strong>连接器&lt;/strong>、&lt;strong>查询缓存&lt;/strong>、&lt;strong>分析器&lt;/strong>、&lt;strong>优化器&lt;/strong>、&lt;strong>执行器&lt;/strong>等，所有&lt;strong>跨存储引擎&lt;/strong>的功能都在这一层实现，比如&lt;strong>存储过程&lt;/strong>、&lt;strong>触发器&lt;/strong>、&lt;strong>视图&lt;/strong>，&lt;strong>函数&lt;/strong>等，还有一个&lt;strong>通用的日志模块 binlog 日志模块&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>存储引擎&lt;/strong>： 主要负责数据的&lt;strong>存储&lt;/strong>和&lt;strong>读取&lt;/strong>，采用&lt;strong>可以替换的插件式架构&lt;/strong>，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 &lt;strong>redolog 模块&lt;/strong>。&lt;strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="server层基本组件介绍">
 Server层基本组件介绍
 &lt;a class="anchor" href="#server%e5%b1%82%e5%9f%ba%e6%9c%ac%e7%bb%84%e4%bb%b6%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212141909073.png" alt="ly-20241212141909073" />&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>连接器&lt;/strong>
连接器主要和&lt;strong>身份认证&lt;/strong>和&lt;strong>权限相关&lt;/strong>的功能相关，就好比一个级别很高的门卫一样&lt;/p>
&lt;blockquote>
&lt;p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户&lt;strong>账户密码&lt;/strong>已通过，连接器会到&lt;strong>权限表&lt;/strong>中查询&lt;strong>该用户的所有权限&lt;/strong>，之后在这个连接里的权限逻辑判断都是会依赖&lt;strong>此时读取到的权限数据&lt;/strong>，也就是说，&lt;strong>后续只要这个连接不断开&lt;/strong>，&lt;strong>即使&lt;/strong>管理员&lt;strong>修改&lt;/strong>了该用户的权限，该用户也是不受影响的。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>查询缓存（MySQL8.0 版本后移除）&lt;/strong>&lt;br>
查询缓存&lt;strong>主要用来缓存&lt;/strong>我们所执行的 &lt;strong>SELECT 语句&lt;/strong>以及该&lt;strong>语句的结果集&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>
&lt;p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 &lt;strong>Key-Value&lt;/strong> 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如&lt;strong>你对一个表更新&lt;/strong>的话，&lt;strong>这个表上的所有的查询缓存都会被清空&lt;/strong>。对于&lt;strong>不经常更新的数据&lt;/strong>来说，&lt;strong>使用缓存还是可以&lt;/strong>的。所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>MySQL &lt;strong>8.0 版本后删除了缓存&lt;/strong>的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了&lt;/p></description></item><item><title>innodb引擎对MVCC的实现</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0604lyinnodb-implementation-of-mvcc/</link><pubDate>Mon, 16 Jan 2023 19:23:55 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0604lyinnodb-implementation-of-mvcc/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="一致性非锁定读和锁定读">
 一致性非锁定读和锁定读
 &lt;a class="anchor" href="#%e4%b8%80%e8%87%b4%e6%80%a7%e9%9d%9e%e9%94%81%e5%ae%9a%e8%af%bb%e5%92%8c%e9%94%81%e5%ae%9a%e8%af%bb">#&lt;/a>
&lt;/h1>
&lt;h2 id="一致性非锁定读">
 一致性非锁定读
 &lt;a class="anchor" href="#%e4%b8%80%e8%87%b4%e6%80%a7%e9%9d%9e%e9%94%81%e5%ae%9a%e8%af%bb">#&lt;/a>
&lt;/h2>
&lt;p>★★非锁定★★&lt;/p>
&lt;ul>
&lt;li>对于&lt;strong>一致性非锁定读（Consistent Nonlocking Reads）&lt;strong>的实现，通常做法是&lt;/strong>加一个版本号&lt;/strong>或者&lt;strong>时间戳&lt;/strong>字段，在更新数据的同时&lt;strong>版本号+1&lt;/strong>或者&lt;strong>更新时间戳&lt;/strong>。查询时，将&lt;strong>当前可见的版本号&lt;/strong>与&lt;strong>对应记录的版本号&lt;/strong>进行比对，如果&lt;strong>记录的版本&lt;/strong>小于&lt;strong>可见版本&lt;/strong>，则表示&lt;strong>该记录可见&lt;/strong>&lt;/li>
&lt;li>&lt;strong>InnoDB&lt;/strong>存储引擎中，&lt;strong>多版本控制（multi versioning）&lt;strong>即是非锁定读的实现。如果读取的行&lt;/strong>正在执行DELETE&lt;/strong>或&lt;strong>UPDATE&lt;/strong>操作，这时读取操作&lt;strong>不会去等待行上&lt;/strong> &lt;strong>锁的释放&lt;/strong>.相反地，Inn哦DB存储引擎会去读取&lt;strong>行的一个快照数据&lt;/strong>，对于这种&lt;strong>读取历史数据&lt;/strong>的方式，我们叫它&lt;strong>快照读（snapshot read）&lt;/strong>。&lt;/li>
&lt;li>在 &lt;strong>&lt;code>Repeatable Read&lt;/code>&lt;/strong> 和 &lt;strong>&lt;code>Read Committed&lt;/code>&lt;/strong> 两个隔离级别下，如果是执行普通的 &lt;code>select&lt;/code> 语句（&lt;strong>不包括 &lt;code>select ... lock in share mode&lt;/code> ,&lt;code>select ... for update&lt;/code>&lt;/strong>）则会使用 &lt;strong>&lt;code>一致性非锁定读（MVCC）&lt;/code>&lt;/strong>。并且在 &lt;strong>&lt;code>Repeatable Read&lt;/code> 下 &lt;code>MVCC&lt;/code> 实现了可重复读和防止部分幻读&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="锁定读">
 锁定读
 &lt;a class="anchor" href="#%e9%94%81%e5%ae%9a%e8%af%bb">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>如果执行的是下列语句，就是&lt;strong>锁定读（Locking Reads）&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;code>select ... lock in share&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>select ... for update&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>insert &lt;/code>、&lt;code>upate&lt;/code>、&lt;code>delete&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>锁定读下，读取的是数据的最新版本，这种读也被称为&lt;strong>当前读current read&lt;/strong>。&lt;strong>锁定读&lt;/strong>会对读取到的记录加锁&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>select ... lock in share mode &lt;/code>：对(读取到的)记录加&lt;strong>S锁&lt;/strong>，其他事务也可以加S锁，如果加X锁则会被阻塞&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>select ... for update&lt;/code>、&lt;code>insert&lt;/code>、&lt;code>update&lt;/code>、&lt;code>delete&lt;/code>：对记录加&lt;strong>X锁&lt;/strong>，且其他事务不能加任何锁&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>在一致性非锁定读下，即使读取的记录&lt;strong>已被其他事务加上X锁&lt;/strong>，这时记录也是可以被读取的，即读取的&lt;strong>快照数据&lt;/strong>。&lt;/p></description></item><item><title>MySQL事务隔离级别详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0603lytransaction-isolation-level/</link><pubDate>Mon, 16 Jan 2023 01:00:44 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0603lytransaction-isolation-level/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="事务隔离级别总结">
 事务隔离级别总结
 &lt;a class="anchor" href="#%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>SQL标准定义了&lt;strong>四个隔离级别&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>READ-UNCOMMITTED(读取未提交)&lt;/strong>：&lt;strong>最低&lt;/strong>的隔离级别，允许读取&lt;strong>尚未提交的数据&lt;/strong>变更，可能会导致&lt;strong>脏读、幻读或不可重复读&lt;/strong>&lt;/li>
&lt;li>&lt;strong>READ-COMMITED(读取已提交)&lt;/strong>：允许读取&lt;strong>并发事务&lt;/strong> &lt;strong>已经提交&lt;/strong>的数据，可以阻止&lt;strong>脏读&lt;/strong>，但是&lt;strong>幻读&lt;/strong>或&lt;strong>不可重复读&lt;/strong>仍有可能发生&lt;/li>
&lt;li>&lt;strong>REPEATABLE-READ(可重复读)&lt;/strong>：对&lt;strong>同一字段的多次读取&lt;/strong>结果都是一致的，除非数据是被&lt;strong>本身事务自己&lt;/strong>所修改，可以&lt;strong>阻止脏读&lt;/strong>和&lt;strong>不可重复读&lt;/strong>，但&lt;strong>幻读&lt;/strong>仍有可能发生&lt;/li>
&lt;li>&lt;strong>SERIALIZABLE(可串行化)&lt;/strong>：&lt;strong>最高&lt;/strong>的隔离级别，&lt;strong>完全服从ACID&lt;/strong>的隔离级别。所有的&lt;strong>事务依次逐个&lt;/strong>执行，这样事务之间就&lt;strong>完全不可能产生干扰&lt;/strong>，也就是说，该级别可以防止&lt;strong>脏读&lt;/strong>、&lt;strong>不可重复读&lt;/strong>以及&lt;strong>幻读&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: center">隔离级别&lt;/th>
 &lt;th style="text-align: center">脏读&lt;/th>
 &lt;th style="text-align: center">不可重复读&lt;/th>
 &lt;th style="text-align: center">幻读&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: center">READ-UNCOMMITTED&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">READ-COMMITTED&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">REPEATABLE-READ&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">SERIALIZABLE&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 &lt;strong>REPEATABLE-READ（可重读）&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>使用命令查看，通过&lt;code>SELECT @@tx_isolation;&lt;/code>。&lt;br>
MySQL 8.0 该命令改为&lt;code>SELECT @@transaction_isolation;&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>MySQL&amp;gt; SELECT @@tx_isolation;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-----------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| @@tx_isolation |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-----------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| REPEATABLE-READ |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+-----------------+ 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>从上面对SQL标准定义了&lt;strong>四个隔离级别&lt;/strong>的介绍可以看出，标准的SQL隔离级别里，&lt;strong>REPEATABLE-READ(可重复读)&lt;strong>是不可以防止幻读的。但是，&lt;strong>InnoDB实现的REPEATABLE-READ&lt;/strong> 隔离级别其实是可以&lt;/strong>解决幻读&lt;/strong>问题发生的，分两种情况&lt;/p>
&lt;ol>
&lt;li>&lt;strong>快照读&lt;/strong>：由&lt;strong>MVCC&lt;/strong>机制来保证不出现幻读&lt;/li>
&lt;li>&lt;strong>当前读&lt;/strong>：使用&lt;strong>Next-Key Lock&lt;/strong>进行&lt;strong>加锁&lt;/strong>来保证不出现幻读，Next-Key Lock是&lt;strong>行锁（Record Lock ）和间隙锁（Gap Lock）的结合&lt;/strong>，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖&lt;strong>间隙锁&lt;/strong> (&lt;strong>只用间隙锁不行，因为间隙锁是 &amp;gt; 或 &amp;lt; ，不包括等于，所以再可重复读下原记录可能会被删掉&lt;/strong>)&lt;/li>
&lt;/ol>
&lt;p>因为&lt;strong>隔离级别越低，事务请求的锁越少&lt;/strong>，所以大部分数据库系统的隔离级别都是 &lt;strong>READ-COMMITTED&lt;/strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 &lt;strong>REPEATABLE-READ&lt;/strong> 并不会有任何性能损失。&lt;/p></description></item><item><title>日志</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0602lymysql-logs/</link><pubDate>Sat, 14 Jan 2023 17:31:53 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0602lymysql-logs/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>首先要了解一个东西 ：WAL，全称 Write-Ahead Logging&lt;code>，它的关键点就是&lt;/code>先写日志，再写磁盘&lt;/p>
&lt;blockquote>
&lt;p>在概念上，innodb通过***force log at commit***机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;ol>
&lt;li>
&lt;p>WAL 机制的原理也很简单：&lt;strong>修改并不直接写入到数据库文件中，而是写入到另外一个称为 WAL 的文件中；如果事务失败，WAL 中的记录会被忽略，撤销修改；如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 WAL 的数据库系统不会再每新增一条 WAL 日志就将其刷入数据库文件中，一般&lt;strong>积累一定的量然后批量写入，通常使用页为单位，这是磁盘的写入单位&lt;/strong>。 同步 &lt;strong>WAL 文件和数据库文件的行为被称为 checkpoint（检查点）&lt;/strong>，一般在 WAL 文件积累到一定页数修改的时候；当然，有些系统也可以手动执行 checkpoint。执行 checkpoint 之后，WAL 文件可以被清空，这样可以保证 WAL 文件不会因为太大而性能下降。&lt;/p>
&lt;p>有些数据库系统读取请求也可以使用 WAL，通过读取 WAL 最新日志就可以获取到数据的最新状态&lt;/p>
&lt;blockquote>
&lt;p>关于checkpoint：https://www.cnblogs.com/chenpingzhao/p/5107480.html&lt;strong>思考一下这个场景&lt;/strong>：如果重做日志可以无限地增大，同时缓冲池也足够大 ，那么是不需要将缓冲池中页的新版本刷新回磁盘。因为当发生宕机时，完全可以通过重做日志来恢复整个数据库系统中的数据到宕机发生的时刻。但是这需要两个前提条件：1、缓冲池可以缓存数据库中所有的数据；2、重做日志可以无限增大&lt;/p>
&lt;p>因此Checkpoint（检查点）技术就诞生了，目的是解决以下几个问题：1、&lt;strong>缩短数据库的恢复时间&lt;/strong>；2、&lt;strong>缓冲池不够用时，将脏页刷新到磁盘&lt;/strong>；3、&lt;strong>重做日志不可用时，刷新脏页&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>当数据库发生宕机时，数据库&lt;strong>不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘&lt;/strong>。数据库只需对Checkpoint后的重做日志进行恢复，这样就大大缩短了恢复的时间。&lt;/li>
&lt;li>当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。&lt;/li>
&lt;li>当重做日志出现不可用时，因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大的，重做日志可以被重用的部分是指这些重做日志已经不再需要，当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，因此这部分就可以被覆盖重用。如果重做日志还需要使用，那么必须强制Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>mysql 的 WAL，大家可能都比较熟悉。mysql 通过 redo、undo 日志实现 WAL。redo log 称为重做日志，每当有操作时，在&lt;strong>数据变更之前将操作写入 redo log&lt;/strong>，这样当发生掉电之类的情况时系统可以在重启后继续操作。undo log 称为撤销日志，当一些变更执行到一半无法完成时，可以根据撤销日志恢复到变更之间的状态。mysql 中用 redo log 来在系统 Crash 重启之类的情况时修复数据（事务的持久性），而 undo log 来保证事务的原子性。&lt;/p></description></item><item><title>索引</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0601lymysql-index/</link><pubDate>Tue, 10 Jan 2023 22:09:25 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/MySQL/ly0601lymysql-index/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="补充索引基础知识引自b站sgg视频">
 补充索引基础知识(引自b站sgg视频)
 &lt;a class="anchor" href="#%e8%a1%a5%e5%85%85%e7%b4%a2%e5%bc%95%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86%e5%bc%95%e8%87%aab%e7%ab%99sgg%e8%a7%86%e9%a2%91">#&lt;/a>
&lt;/h1>
&lt;ol>
&lt;li>存储引擎，数据的基本单位是&lt;strong>页&lt;/strong>，如果数据很少，只有一页，那就简单，是直接二分查找(不涉及磁盘IO)；如果数据很多，有好几个页，那么需要对页建立一种数据结构，能够最快定位到哪一页，然后减少磁盘IO&lt;/li>
&lt;/ol>
&lt;h1 id="索引介绍">
 索引介绍
 &lt;a class="anchor" href="#%e7%b4%a2%e5%bc%95%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>索引是一种用于&lt;strong>快速查询&lt;/strong>和&lt;strong>检索数据&lt;/strong>的数据结构，其本质可以看成是一种&lt;strong>排序好&lt;/strong>的数据结构&lt;/p>
&lt;blockquote>
&lt;p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>索引底层数据结构存在很多种类型，常见的索引结构有：&lt;strong>B树&lt;/strong>，&lt;strong>B+树&lt;/strong>和&lt;strong>Hash&lt;/strong>、&lt;strong>红黑树&lt;/strong>。在MySQL中，无论是Innodb还是MyIsam，都使用了B+树作为索引结构&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="索引的优缺点">
 索引的优缺点
 &lt;a class="anchor" href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9">#&lt;/a>
&lt;/h1>
&lt;p>&lt;strong>优点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>使用索引可以大大&lt;strong>加快&lt;/strong> 数据的检索速度（大大&lt;strong>减少检索的数据量&lt;/strong>）, 这也是创建索引的最主要的原因。&lt;/li>
&lt;li>通过创建&lt;strong>唯一性索引&lt;/strong>，可以保证数据库表中&lt;strong>每一行数据的唯一性&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>创建索引&lt;/strong>和&lt;strong>维护索引&lt;/strong>需要&lt;strong>耗费许多&lt;/strong>时间。当对表中的数据进行&lt;strong>增删改&lt;/strong>的时候，如果数据有索引，那么&lt;strong>索引也需要动态的修改&lt;/strong>，会&lt;strong>降低 SQL 执行效率&lt;/strong>。&lt;/li>
&lt;li>索引需要使用&lt;strong>物理文件存储&lt;/strong>，也会&lt;strong>耗费一定空间&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>索引一定会提高查询性能吗&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>多数情况下，&lt;strong>索引查询&lt;/strong>都是比&lt;strong>全表扫描&lt;/strong>要快的。但是如果数据库的&lt;strong>数据量不大&lt;/strong>，那么使用&lt;strong>索引也不一定能够带来很大提升&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="索引的底层数据结构">
 索引的底层数据结构
 &lt;a class="anchor" href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h1>
&lt;h2 id="hash表">
 Hash表
 &lt;a class="anchor" href="#hash%e8%a1%a8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>哈希表是键值对的集合，通过&lt;strong>键（key）&lt;strong>即可&lt;/strong>快速取出对应的值（value）&lt;/strong>，因此哈希表可以&lt;strong>快速检索数据（接近O(1))&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为何能够通过key快速取出value呢？原因在于&lt;strong>哈希算法（也叫散列算法）&lt;/strong>。通过哈希算法，我们可以&lt;strong>快速找到key对应的index&lt;/strong>，找到了index也就找到了对应的value&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>hash &lt;span style="color:#f92672">=&lt;/span> hashfunc(key)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>index &lt;span style="color:#f92672">=&lt;/span> hash &lt;span style="color:#f92672">%&lt;/span> array_size
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意，图中keys[天蓝色]是&lt;strong>字符串&lt;/strong>，&lt;strong>不是什么莫名其妙的人&lt;/strong>
&lt;img src="img/ly-20241212141858665.png" alt="ly-20241212141858665" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>哈希算法有个 &lt;strong>Hash 冲突&lt;/strong> 问题，也就是说&lt;strong>多个不同的 key 最后得到的 index 相同&lt;/strong>。通常情况下，我们常用的解决办法是 &lt;strong>链地址法&lt;/strong>。链地址法就是&lt;strong>将哈希冲突数据存放在链表中&lt;/strong>。就比如 JDK1.8 之前 &lt;code>HashMap&lt;/code> 就是通过&lt;strong>链地址法来解决哈希冲突&lt;/strong>的。不过，JDK1.8 以后&lt;code>HashMap&lt;/code>&lt;strong>为了减少链表过长&lt;/strong>的时候搜索时间过长引入了&lt;strong>红黑树&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为了减&lt;strong>少 Hash 冲突&lt;/strong>的发生，一个&lt;strong>好的哈希函数&lt;/strong>应该**“均匀地”将数据分布**在整个可能的哈希值集合中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于&lt;strong>Hash索引&lt;/strong>不支持&lt;strong>顺序&lt;/strong>和&lt;strong>范围查询&lt;/strong>，假如要对表中的数据进行&lt;strong>排序&lt;/strong>或者&lt;strong>进行范围查询&lt;/strong>，那&lt;strong>Hash索引&lt;/strong>就不行了，并且，&lt;strong>每次IO&lt;/strong>只能取一个&lt;/p>
&lt;blockquote>
&lt;p>例如： &lt;code>SELECT * FROM tb1 WHERE id &amp;lt; 500 ; &lt;/code>&lt;/p></description></item><item><title>字符集详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/ly0502lycharactor-set/</link><pubDate>Tue, 10 Jan 2023 16:48:22 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/ly0502lycharactor-set/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>图示总结&lt;br>
&lt;img src="img/ly-20241212141855666.png" alt="ly-20241212141855666" />&lt;/p>
&lt;ul>
&lt;li>MySQL字符编码集有&lt;strong>两套UTF-8&lt;/strong>编码实现：&lt;strong>utf-8&lt;/strong> 和 &lt;strong>utf8mb4&lt;/strong>&lt;br>
而其中，utf-8 &lt;strong>不支持存储&lt;/strong>emoji符号和一些比较复杂的汉字、繁体字，会出错&lt;/li>
&lt;/ul>
&lt;h1 id="何为字符集">
 何为字符集
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba%e5%ad%97%e7%ac%a6%e9%9b%86">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>字符是&lt;strong>各种文字&lt;/strong>和&lt;strong>符号&lt;/strong>的统称，包括&lt;strong>各个国家文字&lt;/strong>、&lt;strong>标点符号&lt;/strong>、&lt;strong>表情&lt;/strong>、&lt;strong>数字&lt;/strong>等等&lt;/p>
&lt;ul>
&lt;li>字符集就是&lt;strong>一系列字符&lt;/strong>的集合，字符集的种类较多，每个字符集可以表示的&lt;strong>字符范围&lt;/strong>通常不同，就比如说&lt;strong>有些字符集&lt;/strong>无法表示汉字&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>计算机只能存储&lt;strong>二进制&lt;/strong>的数据，那&lt;strong>英文&lt;/strong>、&lt;strong>汉字&lt;/strong>、&lt;strong>表情&lt;/strong>等字符应该如何存储呢&lt;/p>
&lt;ul>
&lt;li>
&lt;p>我们要将这些&lt;strong>字符和二进制的数据一一对应&lt;/strong>起来，比如说字符“a”对应“01100001”，反之，“01100001”对应 “a”。我们将字符对应二进制数据的过程称为&amp;quot;&lt;strong>字符编码&lt;/strong>&amp;quot;，反之，二进制数据解析成字符的过程称为“&lt;strong>字符解码&lt;/strong>”。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141855958.png" alt="ly-20241212141855958" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="有哪些常见的字符集">
 有哪些常见的字符集
 &lt;a class="anchor" href="#%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e5%ad%97%e7%ac%a6%e9%9b%86">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>常见的字符集有&lt;strong>ASCLL&lt;/strong>、&lt;strong>GB2312&lt;/strong>、&lt;strong>GBK&lt;/strong>、&lt;strong>UTF-8&lt;/strong>&lt;/li>
&lt;li>不同的字符集的主要区别在于
&lt;ol>
&lt;li>可以表示的&lt;strong>字符范围&lt;/strong>&lt;/li>
&lt;li>&lt;strong>编码方式&lt;/strong>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h2 id="ascll">
 ASCLL
 &lt;a class="anchor" href="#ascll">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>ASCII&lt;/strong> (&lt;strong>A&lt;/strong>merican &lt;strong>S&lt;/strong>tandard &lt;strong>C&lt;/strong>ode for &lt;strong>I&lt;/strong>nformation &lt;strong>I&lt;/strong>nterchange，美国信息交换标准代码) 是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>为什么 ASCII 字符集没有考虑到中文等其他字符呢？&lt;/strong> 因为计算机是美国人发明的，当时，计算机的发展还处于比较雏形的时代，还未在其他国家大规模使用。因此，美国发布 ASCII 字符集的时候没有考虑兼容其他国家的语言&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一个 ASCII 码长度是一个字节也就是 8 个 bit，比如“a”对应的 ASCII 码是“01100001”。不过，最高位是 0 仅仅作为校验位，其余 7 位使用 0 和 1 进行组合，所以，ASCII 字符集可以定义 128（2^7）个字符&lt;/p>
&lt;blockquote>
&lt;p>由于，ASCII 码可以表示的字符实在是太少了。后来，人们对其进行了扩展得到了 &lt;strong>ASCII 扩展字符集&lt;/strong> 。ASCII 扩展字符集使用 8 位（bits）表示一个字符，所以，ASCII 扩展字符集可以定义 256（2^8）个字符&lt;/p></description></item><item><title>树</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/cs_basics/data-structure/tree/</link><pubDate>Mon, 09 Jan 2023 15:52:34 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/cs_basics/data-structure/tree/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>树是一种类似现实生活中的树的数据结构（&lt;strong>倒置的树&lt;/strong>）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>任何一颗非空树&lt;strong>只有一个根节点&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一棵树具有以下特点：&lt;/p>
&lt;ol>
&lt;li>一棵树中的任何两个节点有且仅有唯一的一条路相通 （因为每个结点只会有一个父节点）&lt;/li>
&lt;li>一棵树如果有n个节点，那么它一定恰好有n-1条边&lt;/li>
&lt;li>一棵树不包括回路&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>下面是一颗&lt;strong>二叉树&lt;/strong>
&lt;img src="img/ly-20241212141852140.png" alt="ly-20241212141852140" />
深度和高度是对应的；根节点所在层为1层&lt;/p>
&lt;/li>
&lt;li>
&lt;p>常用概念&lt;/p>
&lt;ol>
&lt;li>
&lt;p>节点：树中每个元素都可以统称为节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根节点：顶层节点，或者说没有父节点的节点。上图中A节点就是根节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>兄弟节点：具有&lt;strong>相同父节点的节点&lt;/strong>互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>叶子节点：&lt;strong>没有子节点&lt;/strong>的节点。上图中的 D、F、H、I 都是叶子节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>节点的高度**（跟叶子节点有关，同一层不一定一样）&lt;strong>：&lt;strong>该节点到叶子节点&lt;/strong>的&lt;/strong>最长&lt;strong>路径&lt;/strong>所包含的&lt;strong>边数&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>节点的深度**（跟根节点有关，同一层是一样的）&lt;strong>：&lt;strong>根节点到该节点&lt;/strong>的路径所包含的&lt;/strong>边数**&lt;/p>
&lt;/li>
&lt;li>
&lt;p>节点的层数：节点的深度+1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>树的高度：根节点的高度&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h1 id="二叉树的分类">
 二叉树的分类
 &lt;a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%88%86%e7%b1%bb">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>**二叉树（Binary tree）**是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构&lt;/li>
&lt;li>&lt;strong>二叉树&lt;/strong>的分支，通常被称为&lt;strong>左子树&lt;/strong>或&lt;strong>右子树&lt;/strong>，并且，&lt;strong>二叉树&lt;/strong>的分支具有左右次序，不能随意颠倒&lt;/li>
&lt;li>&lt;strong>二叉树&lt;/strong>的第i层至多拥有&lt;strong>2^(i-1)&lt;/strong> 个节点&lt;br>
深度为&lt;strong>k&lt;/strong>的二叉树至多总共有 &lt;strong>2^(k+1) -1&lt;/strong> 个节点 （深度为k，最多k + 1 层，最多为满二叉树的情况）&lt;br>
至少有2^(k) 个节点，即 深度为k-1的二叉树的最多的节点再加1&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>（关于节点的深度的定义国内争议比较多，我个人比较认可维基百科对&lt;a href="https://zh.wikipedia.org/wiki/%e6%a0%91_%28%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%29#/%e6%9c%af%e8%af%ad">节点深度的定义open in new window&lt;/a>）。
&lt;img src="img/ly-20241212141852434.png" alt="ly-20241212141852434" />&lt;/p>
&lt;/blockquote>
&lt;h2 id="满二叉树">
 满二叉树
 &lt;a class="anchor" href="#%e6%bb%a1%e4%ba%8c%e5%8f%89%e6%a0%91">#&lt;/a>
&lt;/h2>
&lt;p>一个二叉树，如果每一个&lt;strong>层&lt;/strong>的结点数都达到最大值，则这个二叉树就是 &lt;strong>满二叉树&lt;/strong>。也就是说，如果一个&lt;strong>二叉树的层数&lt;/strong>为 K，且结点总数是(2^k) -1 ，则它就是 &lt;strong>满二叉树&lt;/strong>。
&lt;img src="img/ly-20241212141852640.png" alt="ly-20241212141852640" />&lt;/p></description></item><item><title>堆</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/cs_basics/data-structure/heap/</link><pubDate>Fri, 06 Jan 2023 10:46:19 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/cs_basics/data-structure/heap/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="什么是堆">
 什么是堆
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%a0%86">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>堆是&lt;strong>满足以下条件&lt;/strong>的树
堆中每一个节点值都&lt;strong>大于等于（或小于等于）子树中所有节点&lt;/strong>。或者说，任意一个节点的值**都大于等于（或小于等于）**所有子节点的值&lt;/p>
&lt;blockquote>
&lt;p>大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>堆不一定是完全二叉树&lt;/strong>，为了方便&lt;strong>存储&lt;/strong>和&lt;strong>索引&lt;/strong>，我们通常用完全二叉树的形式来表示堆&lt;br>
广为人知的&lt;strong>斐波那契堆&lt;/strong>和&lt;strong>二项堆&lt;/strong>就不是完全二叉树，它们甚至都&lt;strong>不是二叉树&lt;/strong>&lt;/li>
&lt;li>(二叉)堆是一个数组，它可以被看成是一个&lt;strong>近似的完全二叉树&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>下面给出的图是否是堆（通过定义）&lt;/p>
&lt;p>1，2是。
3不是。
&lt;img src="img/ly-20241212141845610.png" alt="ly-20241212141845610" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="堆的用途">
 堆的用途
 &lt;a class="anchor" href="#%e5%a0%86%e7%9a%84%e7%94%a8%e9%80%94">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>当我们&lt;strong>只关心&lt;/strong>所有数据中的&lt;strong>最大值&lt;/strong>或者&lt;strong>最小值&lt;/strong>，存在&lt;strong>多次获取最大值&lt;/strong>或者&lt;strong>最小值&lt;/strong>，多次插入或删除数据时，就可以使用堆。&lt;/p>
&lt;blockquote>
&lt;p>有小伙伴可能会想到用&lt;strong>有序数组&lt;/strong>，初始化一个有序数组时间复杂度是 &lt;code>O(nlog(n))&lt;/code>&lt;strong>[也就是将一堆数字乱序排序，最快是O(nlog(n))]&lt;/strong>，查找最大值或者最小值时间复杂度都是 &lt;code>O(1)&lt;/code>，但是，涉及到更新（插入或删除）数据时，时间复杂度为 &lt;code>O(n)&lt;/code>，即使是使用复杂度为 &lt;code>O(log(n))&lt;/code> 的二分法找到要插入或者删除的数据，在移动数据时也需要 &lt;code>O(n)&lt;/code> 的时间复杂度。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>相对于有序数组而言，堆的主要优势在于更新数据效率较高&lt;/p>
&lt;ul>
&lt;li>堆的&lt;strong>初始化时间复杂度&lt;/strong>为O(nlog(n))，堆可以做到&lt;strong>O(1)&lt;strong>的时间复杂度取出&lt;/strong>最大值&lt;/strong>或者&lt;strong>最小值&lt;/strong>，&lt;strong>O(log(n))&lt;strong>的时间复杂度&lt;/strong>插入或者删除&lt;/strong>数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="堆的分类">
 堆的分类
 &lt;a class="anchor" href="#%e5%a0%86%e7%9a%84%e5%88%86%e7%b1%bb">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>堆分为&lt;strong>最大堆&lt;/strong>和&lt;strong>最小堆&lt;/strong>，二者的区别在于节点的&lt;strong>排序方式&lt;/strong>
&lt;ul>
&lt;li>最大堆：堆中的每一个节点的值&lt;strong>都大于&lt;/strong>子树中&lt;strong>所有节点&lt;/strong>的值&lt;/li>
&lt;li>最小堆：堆中的每一个节点的值&lt;strong>都小于&lt;/strong>子树中&lt;strong>所有节点&lt;/strong>的值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如图，图1是最大堆，图2是最小堆
&lt;img src="img/ly-20241212141845906.png" alt="ly-20241212141845906" />&lt;/li>
&lt;/ul>
&lt;h1 id="堆的存储">
 堆的存储
 &lt;a class="anchor" href="#%e5%a0%86%e7%9a%84%e5%ad%98%e5%82%a8">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>由于&lt;strong>完全二叉树的优秀性质&lt;/strong>，&lt;strong>利用数组存储二叉树&lt;/strong>即节省空间，又&lt;strong>方便索引&lt;/strong>（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为 &lt;code>2*i&lt;/code>，右子节点序号为 &lt;code>2*i+1&lt;/code>）。&lt;/li>
&lt;li>为了&lt;strong>方便存储&lt;/strong>和&lt;strong>索引&lt;/strong>，&lt;strong>（二叉）堆&lt;/strong>可以用&lt;strong>完全二叉树&lt;/strong>的形式进行存储。存储的方式如下图所示
&lt;img src="img/ly-20241212141846083.png" alt="ly-20241212141846083" />&lt;/li>
&lt;/ul>
&lt;h1 id="堆的操作">
 堆的操作
 &lt;a class="anchor" href="#%e5%a0%86%e7%9a%84%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>堆的更新操作主要包括两种：&lt;strong>插入元素&lt;/strong>和&lt;strong>删除堆顶元素&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>堆是一个公平的公司，&lt;strong>有能力的人&lt;/strong>自然会走到与他能力所匹配的位置&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;h2 id="插入元素">
 插入元素
 &lt;a class="anchor" href="#%e6%8f%92%e5%85%a5%e5%85%83%e7%b4%a0">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>将要插入的元素放到&lt;strong>最后&lt;/strong>
&lt;img src="img/ly-20241212141846259.png" alt="ly-20241212141846259" />&lt;/li>
&lt;li>从底向上，如果&lt;strong>父节点&lt;/strong>比&lt;strong>该元素小&lt;/strong>，则该节点和父节点交换（其实就是一棵树有3个（最多）节点，与树上最大的节点比较）
直到无法交换（已经与根节点比较过）
&lt;img src="img/ly-20241212141846433.png" alt="ly-20241212141846433" />
&lt;img src="img/ly-20241212141846614.png" alt="ly-20241212141846614" />&lt;/li>
&lt;/ol>
&lt;h2 id="删除堆顶元素">
 删除堆顶元素
 &lt;a class="anchor" href="#%e5%88%a0%e9%99%a4%e5%a0%86%e9%a1%b6%e5%85%83%e7%b4%a0">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>根据堆的性质可知，&lt;strong>最大堆&lt;/strong>的堆盯元素为所有元素中最大的，&lt;strong>最小堆&lt;/strong>的堆顶元素是所有元素中最小的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当我们需要多次查找&lt;strong>最大元素&lt;/strong>或者&lt;strong>最小元素&lt;/strong>的时候，可以利用堆来实现&lt;/p>
&lt;/li>
&lt;li>
&lt;p>删除堆顶元素后，为了保持&lt;strong>堆的性质&lt;/strong>，需要对堆的结构进行调整，我们可以将这个过程称之为&lt;strong>堆化&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>自底向上&lt;/strong>的堆化，上述的&lt;strong>插入元素&lt;/strong>所使用的，就是自顶向上的&lt;strong>堆化&lt;/strong>，元素从最底部向上移动&lt;/li>
&lt;li>&lt;strong>自顶向下&lt;/strong>的堆化，元素由&lt;strong>顶部向下&lt;/strong>移动。在讲解删除堆顶元素的方法时，我将阐述这&lt;strong>两种操作的过程&lt;/strong>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>自底向上堆化&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>在堆这个公司中，会出现老大离职的现象，老大离职之后，它的位置就空出来了&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>
&lt;p>首先删除堆顶元素，使得数组中下标为1的位置空出
&lt;img src="img/ly-20241212141846789.png" alt="ly-20241212141846789" />&lt;/p></description></item><item><title>图</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/cs_basics/data-structure/graph/</link><pubDate>Mon, 26 Dec 2022 08:47:25 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/cs_basics/data-structure/graph/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>图是一种较为复杂的&lt;strong>非线性&lt;/strong>结构&lt;/li>
&lt;li>&lt;strong>线性&lt;/strong>数据结构的元素满足唯一的线性关系，&lt;strong>每个元素&lt;/strong>（除第一个和最后一个外）只有一个&lt;strong>直接前驱&lt;/strong>和一个&lt;strong>直接后继&lt;/strong>&lt;/li>
&lt;li>&lt;strong>树形&lt;/strong>数据结构的元素之间有着明显的&lt;strong>层级关系&lt;/strong>&lt;/li>
&lt;li>&lt;strong>图形&lt;/strong>结构的元素之间的关系是任意的
&lt;ul>
&lt;li>图就是由&lt;strong>顶点&lt;/strong>的&lt;strong>有穷非空集合&lt;/strong>和顶点之间的&lt;strong>边&lt;/strong>组成的集合，通常表示为：&lt;strong>G（V，E）&lt;/strong>，其中，G表示一个图，V表示顶点的集合，E表示边的集合&lt;/li>
&lt;li>下面显示的即&lt;strong>图&lt;/strong>这种数据结构，而且还是一张&lt;strong>有向图&lt;/strong>
&lt;img src="img/ly-20241212141841748.png" alt="ly-20241212141841748" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="图的基本概念">
 图的基本概念
 &lt;a class="anchor" href="#%e5%9b%be%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">#&lt;/a>
&lt;/h1>
&lt;h2 id="顶点">
 顶点
 &lt;a class="anchor" href="#%e9%a1%b6%e7%82%b9">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>图中的&lt;strong>数据元素&lt;/strong>，我们称之为&lt;strong>顶点&lt;/strong>，图至少有一个&lt;strong>顶点&lt;/strong>（&lt;strong>有穷非空&lt;/strong>集合）&lt;/li>
&lt;li>对应到好友关系图，&lt;strong>每一个用户&lt;/strong>就代表&lt;strong>一个顶点&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="边">
 边
 &lt;a class="anchor" href="#%e8%be%b9">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>顶点之间的&lt;strong>关系&lt;/strong>用&lt;strong>边&lt;/strong>表示&lt;/li>
&lt;li>对应到好友关系图，两个用户是好友的话，那两者之间就存在一条&lt;strong>边&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="度">
 度
 &lt;a class="anchor" href="#%e5%ba%a6">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>度表示一个顶点包含多少条边&lt;/li>
&lt;li>有向图中，分为&lt;strong>出度&lt;/strong>和&lt;strong>入度&lt;/strong>，出度表示&lt;strong>从该顶点出去的边&lt;/strong>的条数，入度表示&lt;strong>从进入该顶点的边&lt;/strong>的条数&lt;/li>
&lt;li>对应到好友关系图，度就代表了某个人的&lt;strong>好友数量&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="无向图和有向图">
 无向图和有向图
 &lt;a class="anchor" href="#%e6%97%a0%e5%90%91%e5%9b%be%e5%92%8c%e6%9c%89%e5%90%91%e5%9b%be">#&lt;/a>
&lt;/h2>
&lt;p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用&lt;strong>不带箭头的边&lt;/strong>表示，这样的图就是&lt;strong>无向图&lt;/strong>。&lt;/p>
&lt;p>有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用&lt;strong>带箭头的边&lt;/strong>表示二者的关系，这样的图就是&lt;strong>有向图&lt;/strong>。&lt;/p>
&lt;h2 id="无权图和带权图">
 无权图和带权图
 &lt;a class="anchor" href="#%e6%97%a0%e6%9d%83%e5%9b%be%e5%92%8c%e5%b8%a6%e6%9d%83%e5%9b%be">#&lt;/a>
&lt;/h2>
&lt;p>对于一个关系，如果我们只关心关系的有无，而&lt;strong>不关心关系有多强&lt;/strong>，那么就可以用&lt;strong>无权图&lt;/strong>表示二者的关系。&lt;/p>
&lt;p>对于一个关系，如果我们既&lt;strong>关心关系的有无&lt;/strong>，也关心&lt;strong>关系的强度&lt;/strong>，比如描述地图上&lt;strong>两个城市的关系&lt;/strong>，需要用到&lt;strong>距离&lt;/strong>，那么就用&lt;strong>带权图&lt;/strong>来表示，&lt;strong>带权图中的每一条边一个数值表示权值&lt;/strong>，代表&lt;strong>关系的强度&lt;/strong>。&lt;/p>
&lt;p>下图就是一个&lt;strong>带权有向图&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141842057.png" alt="ly-20241212141842057" />&lt;/p>
&lt;h1 id="图的存储">
 图的存储
 &lt;a class="anchor" href="#%e5%9b%be%e7%9a%84%e5%ad%98%e5%82%a8">#&lt;/a>
&lt;/h1>
&lt;h2 id="邻接矩阵存储">
 邻接矩阵存储
 &lt;a class="anchor" href="#%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5%e5%ad%98%e5%82%a8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>邻接矩阵将图用&lt;strong>二维矩阵&lt;/strong>存储，是一种比较&lt;strong>直观&lt;/strong>的表示方式&lt;/li>
&lt;li>如果第i个顶点和第j个顶点&lt;strong>有关系&lt;/strong>，且&lt;strong>关系权值&lt;/strong>为n，则A[i] [j] = n&lt;/li>
&lt;li>在无向图中，我们只关心关系的有无，所以当&lt;strong>顶点i&lt;/strong>和&lt;strong>顶点j&lt;/strong>有关系时，A[i] [j]=1 ; 当顶点i和顶点j没有关系时，A[i] [j] = 0 ，如下图所示&lt;br>
&lt;img src="img/ly-20241212141842233.png" alt="ly-20241212141842233" />
无向图的邻接矩阵是一个&lt;strong>对称&lt;/strong>矩阵，因为在无向图中，&lt;strong>顶点i&lt;/strong>和&lt;strong>顶点j&lt;/strong>有关系，则&lt;strong>顶点j&lt;/strong>和&lt;strong>顶点i&lt;/strong>必有关系&lt;/li>
&lt;li>有向图的邻接矩阵存储
&lt;img src="img/ly-20241212141842414.png" alt="ly-20241212141842414" />
邻接矩阵存储的方式优点是&lt;strong>简单直接（直接使用一个二维数组即可）&lt;/strong>，并且在获取两个顶点之间的关系的时候也非常高效*直接获取指定位置的&lt;strong>数组&lt;/strong>元素。但是这种存储方式的确定啊也比较明显&lt;strong>即 比较浪费空间&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="邻接表存储">
 邻接表存储
 &lt;a class="anchor" href="#%e9%82%bb%e6%8e%a5%e8%a1%a8%e5%ad%98%e5%82%a8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另一种存储方法&amp;ndash;&lt;strong>邻接表&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>邻接链表使用一个&lt;strong>链表&lt;/strong>来存储某个顶点的&lt;strong>所有后继相邻顶点&lt;/strong>。对于图中每个顶点Vi ，把所有邻接于Vi 的顶点Vj 链接成一个&lt;strong>单链表&lt;/strong>&lt;/p></description></item><item><title>线性数据结构</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/cs_basics/data-structure/linear-data-structure/</link><pubDate>Tue, 20 Dec 2022 13:34:59 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/cs_basics/data-structure/linear-data-structure/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="数组">
 数组
 &lt;a class="anchor" href="#%e6%95%b0%e7%bb%84">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>数组（Array）是一种常见数据结构，由&lt;strong>相同类型的元素（element）&lt;strong>组成，并且是使用一块&lt;/strong>连续的内存&lt;/strong>来存储&lt;/li>
&lt;li>直接可以利用元素的**索引（index）**可以计算出该元素对应的存储地址&lt;/li>
&lt;li>数组的特点是：提供&lt;strong>随机访问&lt;/strong>并且&lt;strong>容量有限&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>假设数组长度为n：&lt;br>
访问：O(1) //访问特定位置的元素&lt;/p>
&lt;p>插入：O(n) //最坏的情况插入在数组的&lt;strong>首部&lt;/strong>并需要&lt;strong>移动所有元素&lt;/strong>时&lt;/p>
&lt;p>删除：O(n) //最坏的情况发生在删除数组的&lt;strong>开头&lt;/strong>并需要移动&lt;strong>第一元素&lt;/strong>后面所有的元素时&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="img/ly-20241212141849981.png" alt="ly-20241212141849981" />&lt;/p>
&lt;h1 id="链表">
 链表
 &lt;a class="anchor" href="#%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h1>
&lt;h2 id="链表简介">
 链表简介
 &lt;a class="anchor" href="#%e9%93%be%e8%a1%a8%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>链表（LinkedList）虽然是一种&lt;strong>线性表&lt;/strong>，但是并&lt;strong>不会按线性&lt;/strong>的顺序&lt;strong>存储&lt;/strong>数据，使用的&lt;strong>不是&lt;/strong>连续的内存空间来&lt;strong>存储数据&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>链表的&lt;strong>插入&lt;/strong>和&lt;strong>删除&lt;/strong>操作的复杂度为O(1)，只需要直到目标位置元素的&lt;strong>上一个元素&lt;/strong>即可。但是，在&lt;strong>查找一个节点&lt;/strong>或者&lt;strong>访问特定位置&lt;/strong>的节点的时候复杂度为&lt;strong>O(n)&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用链表结构可以&lt;strong>克服数组需要预先知道数据大小&lt;/strong>的缺点，链表结构可以充分利用&lt;strong>计算机内存空间&lt;/strong>，实现灵活的&lt;strong>内存动态管理&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>但链表&lt;strong>不会节省空间&lt;/strong>，相比于数组会&lt;strong>占用&lt;/strong>更多空间，因为链表中&lt;strong>每个节点&lt;/strong>存放的还有&lt;strong>指向其他节点&lt;/strong>的指针。除此之外，链表不具有&lt;strong>数组随机读取&lt;/strong>的优点&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;h2 id="链表分类">
 链表分类
 &lt;a class="anchor" href="#%e9%93%be%e8%a1%a8%e5%88%86%e7%b1%bb">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>单链表&lt;/strong>、&lt;strong>双向链表&lt;/strong>、&lt;strong>循环链表&lt;/strong>、&lt;strong>双向循环链表&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>假设链表中有&lt;strong>n个元素&lt;/strong>&lt;br>
访问：O(n) //访问特地给位置的元素&lt;/p>
&lt;p>插入删除：O(1) //必须要知道插入元素的位置&lt;/p>
&lt;/blockquote>
&lt;h3 id="单链表">
 单链表
 &lt;a class="anchor" href="#%e5%8d%95%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>单链表&lt;/strong>只有一个方向，结点&lt;strong>只有一个后继指针next&lt;/strong>指向后面的节点。因此，链表这种数据结构通常在&lt;strong>物理内存&lt;/strong>上是&lt;strong>不连续&lt;/strong>的&lt;/li>
&lt;li>我们习惯性地把&lt;strong>第一个结点&lt;/strong>叫做&lt;strong>头结点&lt;/strong>，链表通常有一个&lt;strong>不保存任何值的head节点&lt;/strong>（头结点），通过头结点我们可以&lt;strong>遍历整个链表&lt;/strong>，尾结点通常&lt;strong>指向null&lt;/strong>&lt;/li>
&lt;li>如下图
&lt;img src="img/ly-20241212141850281.png" alt="ly-20241212141850281" />&lt;/li>
&lt;/ul>
&lt;h3 id="循环链表">
 循环链表
 &lt;a class="anchor" href="#%e5%be%aa%e7%8e%af%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>循环链表是一种&lt;strong>特殊的单链表&lt;/strong>，和单链表不同的是&lt;strong>循环链表的尾结点&lt;/strong>不是指向null，而是&lt;strong>指向链表的头结点&lt;/strong>&lt;/li>
&lt;li>如图
&lt;img src="img/ly-20241212141850545.png" alt="ly-20241212141850545" />&lt;/li>
&lt;/ul>
&lt;h3 id="双向链表">
 双向链表
 &lt;a class="anchor" href="#%e5%8f%8c%e5%90%91%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>双向链表包含&lt;strong>两个指针&lt;/strong>，一个&lt;strong>prev&lt;/strong>指向&lt;strong>前一个节点&lt;/strong>，另一个&lt;strong>next&lt;/strong>指向&lt;/li>
&lt;li>如图
&lt;img src="img/ly-20241212141850726.png" alt="ly-20241212141850726" />&lt;/li>
&lt;/ul>
&lt;h3 id="双向循环链表">
 双向循环链表
 &lt;a class="anchor" href="#%e5%8f%8c%e5%90%91%e5%be%aa%e7%8e%af%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h3>
&lt;p>双向循环链表的&lt;strong>最后一个节点的next&lt;/strong>指向head，而head的&lt;strong>prev&lt;/strong>指向最后一个节点，构成一个环&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141850919.png" alt="ly-20241212141850919" />&lt;/p>
&lt;h2 id="应用场景">
 应用场景
 &lt;a class="anchor" href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>如果需要支持&lt;strong>随机访问&lt;/strong>的话，链表无法做到&lt;/li>
&lt;li>如果需要&lt;strong>存储的数据元素个数不确定&lt;/strong>，并且需要经常&lt;strong>添加&lt;/strong>和&lt;strong>删除&lt;/strong>数据的话，使用&lt;strong>链表&lt;/strong>比较合适&lt;/li>
&lt;li>如果需要&lt;strong>存储的数据元素&lt;/strong>的个数确定，并且不需要&lt;strong>经常添加&lt;/strong>和&lt;strong>删除&lt;/strong>数据的话，使用数组比较合适&lt;/li>
&lt;/ul>
&lt;h2 id="数组-vs-链表">
 数组 vs 链表
 &lt;a class="anchor" href="#%e6%95%b0%e7%bb%84-vs-%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>数组支持&lt;strong>随机访问&lt;/strong>，链表不支持&lt;/li>
&lt;li>数组使用的是&lt;strong>连续内存空间&lt;/strong> &lt;strong>对CPU缓存机制&lt;/strong>友好，链表则&lt;strong>相反&lt;/strong>&lt;/li>
&lt;li>数组的&lt;strong>大小固定&lt;/strong>，而链表则&lt;strong>天然支持动态扩容&lt;/strong>。如果生命的数组过小，需要另外申请一个&lt;strong>更大的内存空间&lt;/strong>存放数组元素，然后将&lt;strong>原数组拷贝进去&lt;/strong>，这个操作比较耗时&lt;/li>
&lt;/ul>
&lt;h1 id="栈">
 栈
 &lt;a class="anchor" href="#%e6%a0%88">#&lt;/a>
&lt;/h1>
&lt;h2 id="栈简介">
 栈简介
 &lt;a class="anchor" href="#%e6%a0%88%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>栈（stack）只允许在&lt;strong>有序的线性数据集合&lt;/strong>的&lt;strong>一端&lt;/strong>（称为栈顶top）进行&lt;strong>加入数据（push）&lt;strong>和&lt;/strong>移除数据（pop）&lt;/strong>。因而按照**后进先出（LIFO，Last In First Out）**的原理运作。&lt;/li>
&lt;li>栈中，&lt;strong>push&lt;/strong>和&lt;strong>pop&lt;/strong>的操作都发生在栈顶&lt;/li>
&lt;li>栈常用&lt;strong>一维数组&lt;/strong>或&lt;strong>链表&lt;/strong>来实现，用数组实现的叫&lt;strong>顺序栈&lt;/strong>，用链表实现的叫做&lt;strong>链式栈&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>假设堆栈中有n个元素。
访问：O（n）//最坏情况
插入删除：O（1）//顶端插入和删除元素&lt;/p></description></item><item><title>数据库基础</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/ly0501lybasis/</link><pubDate>Tue, 20 Dec 2022 11:19:14 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/database/ly0501lybasis/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>这部分内容由于涉及太多概念性内容，所以参考了维基百科和百度百科相应的介绍。&lt;/p>
&lt;/blockquote>
&lt;h1 id="什么是数据库数据库管理系统数据库系统数据库管理员">
 什么是数据库，数据库管理系统，数据库系统，数据库管理员
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%95%b0%e6%8d%ae%e5%ba%93%e6%95%b0%e6%8d%ae%e5%ba%93%e7%ae%a1%e7%90%86%e7%b3%bb%e7%bb%9f%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e6%95%b0%e6%8d%ae%e5%ba%93%e7%ae%a1%e7%90%86%e5%91%98">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>数据库&lt;/strong>：数据库（&lt;strong>DataBase 简称DB&lt;/strong>）就是&lt;strong>信息的集合&lt;/strong>或者说&lt;strong>数据库管理系统管理的数据的集合&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>数据库管理系统&lt;/strong>：数据库管理系统（&lt;strong>Database Management System 简称DBMS&lt;/strong>）是一种&lt;strong>操纵和管理数据库&lt;/strong>的大型软件，通常用于建立、使用和维护 &lt;strong>数据库&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>数据库系统（范围最大）&lt;/strong>：数据库系统（Data Base System，简称DBS）通常由**软件、数据和数据管理员（DBA）**组成。&lt;/li>
&lt;li>&lt;strong>数据库管理员&lt;/strong>：数据库管理员（Database Adminitrator，简称DBA）负责全面&lt;strong>管理和控制&lt;/strong>数据库系统 &lt;strong>(是一个人)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>数据库系统基本构成&lt;/strong>如下图所示&lt;br>
&lt;img src="img/ly-20241212141854630.png" alt="ly-20241212141854630" />&lt;/p>
&lt;h1 id="什么是元组码候选码主码外码主属性非主属性">
 什么是元组，码，候选码，主码，外码，主属性，非主属性
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%85%83%e7%bb%84%e7%a0%81%e5%80%99%e9%80%89%e7%a0%81%e4%b8%bb%e7%a0%81%e5%a4%96%e7%a0%81%e4%b8%bb%e5%b1%9e%e6%80%a7%e9%9d%9e%e4%b8%bb%e5%b1%9e%e6%80%a7">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>元组&lt;/strong>：元组（tuple）是&lt;strong>关系数据库&lt;/strong>中的&lt;strong>基本概念&lt;/strong>，&lt;strong>关系&lt;/strong>是一张表，表中的&lt;strong>每行&lt;/strong>（即数据库中的每条&lt;strong>记录&lt;/strong>）就是一个元组，每列就是一个属性。在&lt;strong>二维表&lt;/strong>里，元组也成为&lt;strong>行&lt;/strong>&lt;/li>
&lt;li>&lt;strong>码&lt;/strong>：码就是能&lt;strong>唯一标识实体&lt;/strong>的属性，对应表中的&lt;strong>列&lt;/strong>&lt;/li>
&lt;li>&lt;strong>候选码&lt;/strong>：若关系中的&lt;strong>某一属性&lt;/strong>或&lt;strong>属性组的值&lt;/strong>能&lt;strong>唯一的标识一个元组&lt;/strong>，而&lt;strong>其任何、子集都不能再标识&lt;/strong>，则称该&lt;strong>属性组&lt;/strong>为&lt;strong>候选码&lt;/strong>。例如：在学生实体中，&lt;strong>“学号”&lt;strong>是能唯一的区分学生实体的，同时又假设&lt;/strong>“姓名”、“班级”的属性组合&lt;/strong>足以区分学生实体，那么**{学号}&lt;strong>和&lt;/strong>{姓名，班级}&lt;strong>都是&lt;/strong>候选码**。&lt;/li>
&lt;li>&lt;strong>主码&lt;/strong>：主码也叫&lt;strong>主键&lt;/strong>，主码是&lt;strong>从候选码&lt;/strong>中选出来的。一个实体集中只能有&lt;strong>一个主码&lt;/strong>，但可以有&lt;strong>多个候选码&lt;/strong>&lt;/li>
&lt;li>&lt;strong>外码&lt;/strong>：外码也叫&lt;strong>外键&lt;/strong>。如果&lt;strong>一个关系中的一个属性&lt;/strong>是&lt;strong>另外一个关系中的主码&lt;/strong>则这个属性为外码。&lt;/li>
&lt;li>&lt;strong>主属性&lt;/strong> ： &lt;strong>候选码中出现过的属性&lt;/strong>称为主属性(&lt;strong>这里强调单个&lt;/strong>）。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然&lt;strong>工号和身份证号&lt;/strong>都能够唯一标示这个关系，所以都是候选码。&lt;strong>工号、身份证号这两个属性就是主属性&lt;/strong>。如果主码是一个属性组，那么属性组中的属性都是主属性。&lt;/li>
&lt;li>&lt;strong>非主属性：&lt;/strong> &lt;strong>不包含在任何一个候选码中的属性&lt;/strong>称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。&lt;/li>
&lt;/ul>
&lt;h1 id="主键和外键有什么区别">
 主键和外键有什么区别
 &lt;a class="anchor" href="#%e4%b8%bb%e9%94%ae%e5%92%8c%e5%a4%96%e9%94%ae%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>主键(主码)&lt;/strong> ：主键用于&lt;strong>唯一标识一个元组&lt;/strong>，不能有重复，不允许为空。一个表只能有一个主键。&lt;/li>
&lt;li>&lt;strong>外键(外码)&lt;/strong> ：外键用来和其他表建立联系用，&lt;strong>外键是另一表的主键&lt;/strong>，外键是可以有重复的，可以是空值。一个表可以有多个外键&lt;/li>
&lt;/ul>
&lt;h1 id="为什么不推荐使用外键与级联">
 为什么不推荐使用外键与级联
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e6%8e%a8%e8%8d%90%e4%bd%bf%e7%94%a8%e5%a4%96%e9%94%ae%e4%b8%8e%e7%ba%a7%e8%81%94">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>对于外键和级联，阿里巴巴开发手册这样说道&lt;/p>
&lt;blockquote>
&lt;p>【强制】不得使用外键与级联，一切&lt;strong>外键概念&lt;/strong>必须在应用层解决。&lt;/p>
&lt;p>说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。&lt;/p>
&lt;p>缺点： &lt;strong>外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风 险; 外键影响数据库的插入速度&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>为什么不要使用外键&lt;/p>
&lt;ol>
&lt;li>
&lt;p>增加了复杂性&lt;/p>
&lt;blockquote>
&lt;p>a. 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦, &lt;strong>测试数据极为不方便&lt;/strong>; b. 外键的主从关系是定的，假如那天需求有变化，&lt;strong>数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>增加了额外操作&lt;/p></description></item><item><title>jvm监控和故障处理工具 总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0408lyjdk-monitoring-and-troubleshooting-tools/</link><pubDate>Mon, 19 Dec 2022 16:04:34 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0408lyjdk-monitoring-and-troubleshooting-tools/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="jdk-命令行工具">
 JDK 命令行工具
 &lt;a class="anchor" href="#jdk-%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%b7%a5%e5%85%b7">#&lt;/a>
&lt;/h1>
&lt;p>这些命令在 JDK 安装目录下的 bin 目录下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>jps&lt;/code>&lt;/strong> (JVM Process Status）: 类似 UNIX 的 &lt;code>ps&lt;/code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；&lt;/li>
&lt;li>&lt;strong>&lt;code>jstat&lt;/code>&lt;/strong>（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;&lt;/li>
&lt;li>&lt;strong>&lt;code>jinfo&lt;/code>&lt;/strong> (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;&lt;/li>
&lt;li>&lt;strong>&lt;code>jmap&lt;/code>&lt;/strong> (Memory Map for Java) : 生成堆转储快照;&lt;/li>
&lt;li>&lt;strong>&lt;code>jhat&lt;/code>&lt;/strong> (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;&lt;/li>
&lt;li>&lt;strong>&lt;code>jstack&lt;/code>&lt;/strong> (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。&lt;/li>
&lt;/ul>
&lt;h2 id="jps-查看所有-java-进程">
 jps: 查看所有 Java 进程
 &lt;a class="anchor" href="#jps-%e6%9f%a5%e7%9c%8b%e6%89%80%e6%9c%89-java-%e8%bf%9b%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>jps&lt;/code>(JVM Process Status) 命令类似 UNIX 的 &lt;code>ps&lt;/code> 命令。&lt;/p></description></item><item><title>jvm参数</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0406lyjvm-params/</link><pubDate>Mon, 19 Dec 2022 15:24:01 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0406lyjvm-params/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>本文由 JavaGuide 翻译自 &lt;a href="https://www.baeldung.com/jvm-parameters">https://www.baeldung.com/jvm-parametersopen in new window&lt;/a>，并对文章进行了大量的完善补充。翻译不易，如需转载请注明出处，作者：&lt;a href="https://www.baeldung.com/author/baeldung/">baeldungopen in new window&lt;/a> 。&lt;/p>
&lt;/blockquote>
&lt;h1 id="概述">
 概述
 &lt;a class="anchor" href="#%e6%a6%82%e8%bf%b0">#&lt;/a>
&lt;/h1>
&lt;p>本篇文章中，将掌握最常用的&lt;strong>JVM参数配置&lt;/strong>。下面提到了一些概念，&lt;strong>堆&lt;/strong>、&lt;strong>方法区&lt;/strong>、&lt;strong>垃圾回收&lt;/strong>等。&lt;/p>
&lt;h1 id="堆内存相关">
 堆内存相关
 &lt;a class="anchor" href="#%e5%a0%86%e5%86%85%e5%ad%98%e7%9b%b8%e5%85%b3">#&lt;/a>
&lt;/h1>
&lt;p>Java 虚拟机所管理的&lt;strong>内存中最大的一块&lt;/strong>，&lt;strong>Java 堆&lt;/strong>是&lt;strong>所有线程共享的一块内存区域&lt;/strong>，在虚拟机&lt;strong>启动时创建&lt;/strong>。此内存区域的&lt;strong>唯一目的就是存放对象实例&lt;/strong>，&lt;strong>几乎&lt;/strong> &lt;strong>所有的对象实例&lt;/strong>以及&lt;strong>数组&lt;/strong>都在这里分配内存。&lt;br>
&lt;img src="img/ly-20241212142002639.png" alt="ly-20241212142002639" />&lt;/p>
&lt;h2 id="显式指定堆内存-xms和-xmx">
 显式指定堆内存-Xms和-Xmx
 &lt;a class="anchor" href="#%e6%98%be%e5%bc%8f%e6%8c%87%e5%ae%9a%e5%a0%86%e5%86%85%e5%ad%98-xms%e5%92%8c-xmx">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>与&lt;strong>性能相关&lt;/strong>的最常见实践之一是根据应用程序要求&lt;strong>初始化堆内存&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果我们需要指定&lt;strong>最小&lt;/strong>和&lt;strong>最大堆&lt;/strong>大小（推荐显示指定大小）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>-Xms&amp;lt;heap size&amp;gt;&lt;span style="color:#f92672">[&lt;/span>unit&lt;span style="color:#f92672">]&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-Xmx&amp;lt;heap size&amp;gt;&lt;span style="color:#f92672">[&lt;/span>unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>heap size&lt;/strong> 表示要初始化内存的具体大小。&lt;/li>
&lt;li>&lt;strong>unit&lt;/strong> 表示要初始化内存的单位。单位为***“ g”*** (GB) 、&lt;em>&lt;strong>“ m”&lt;/strong>&lt;/em>（MB）、&lt;em>&lt;strong>“ k”&lt;/strong>&lt;/em>（KB）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>举例，为JVM分配最小2GB和最大5GB的堆内存大小&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>-Xms2G -Xmx5G
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="显示新生代内存young-generation">
 显示新生代内存（Young Generation）
 &lt;a class="anchor" href="#%e6%98%be%e7%a4%ba%e6%96%b0%e7%94%9f%e4%bb%a3%e5%86%85%e5%ad%98young-generation">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>在堆总可用内存配置完成之后，第二大影响因素是为 &lt;strong>&lt;code>Young Generation&lt;/code>&lt;/strong> 在堆内存所占的比例。默认情况下，&lt;strong>YG 的最小大小为 1310 &lt;em>MB&lt;/em>&lt;/strong>，最大大小为&lt;em>无限制&lt;/em>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>两种指定 &lt;strong>新生代内存(Young Generation)&lt;/strong> 大小的方法&lt;/p>
&lt;ol>
&lt;li>
&lt;p>通过 &lt;code>-XX:NewSize&lt;/code> 和 &lt;code>-XX:MaxNewSize &lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-&lt;/span>XX:NewSize&lt;span style="color:#f92672">=&amp;lt;&lt;/span>young size&lt;span style="color:#f92672">&amp;gt;[&lt;/span>unit&lt;span style="color:#f92672">]&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-&lt;/span>XX:MaxNewSize&lt;span style="color:#f92672">=&amp;lt;&lt;/span>young size&lt;span style="color:#f92672">&amp;gt;[&lt;/span>unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如，为新生代分配&lt;strong>最小256m&lt;/strong>的内存，&lt;strong>最大1024m&lt;/strong>的内存我们的参数为：&lt;/p></description></item><item><title>类文件结构</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0403lyclass-structure/</link><pubDate>Sun, 18 Dec 2022 08:24:36 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0403lyclass-structure/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="概述">
 概述
 &lt;a class="anchor" href="#%e6%a6%82%e8%bf%b0">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>Java中，JVM可以理解的代码就叫做&lt;strong>字节码&lt;/strong>（即扩展名为.class的文件），它不面向任何特定的处理器，只&lt;strong>面向虚拟机&lt;/strong>&lt;/li>
&lt;li>Java语言通过&lt;strong>字节码&lt;/strong>的方式，在一定程度上解决了&lt;strong>传统解释型语言执行效率低&lt;/strong>的问题，同时又保留了&lt;strong>解释型语言&lt;/strong>可移植的特点。所以Java程序运行时&lt;strong>效率极高&lt;/strong>，且由于字节码并不针对一种特定的&lt;strong>机器&lt;/strong>。因此，Java程序无需重新编译便可在&lt;strong>多种不通操作系统的计算机&lt;/strong>运行&lt;/li>
&lt;li>Clojure（Lisp 语言的一种方言）、Groovy、Scala 等语言都是运行在 Java 虚拟机之上。下图展示了&lt;strong>不同的语言被不同的编译器&lt;/strong>编译&lt;strong>成&lt;code>.class&lt;/code>&lt;strong>文件&lt;/strong>最终运行在 Java 虚拟机&lt;/strong>之上。&lt;strong>&lt;code>.class&lt;/code>文件的二进制格式&lt;/strong>可以使用 &lt;a href="https://www.x-ways.net/winhex/">WinHexopen in new window&lt;/a> 查看。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="img/ly-20241212141957797.png" alt="ly-20241212141957797" />&lt;/p>
&lt;p>.class文件是不同语言在&lt;strong>Java虚拟机&lt;/strong>之间的重要桥梁，同时也是&lt;strong>支持Java跨平台&lt;/strong>很重要的一个原因&lt;/p>
&lt;h1 id="class文件结构总结">
 Class文件结构总结
 &lt;a class="anchor" href="#class%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h1>
&lt;p>根据Java虚拟机规范，Class文件通过&lt;strong>ClassFile&lt;/strong>定义，有点类似C语言的&lt;strong>结构体&lt;/strong>&lt;/p>
&lt;p>ClassFile的结构如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ClassFile {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u4 magic; &lt;span style="color:#75715e">//Class 文件的标志&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 minor_version;&lt;span style="color:#75715e">//Class 的小版本号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 major_version;&lt;span style="color:#75715e">//Class 的大版本号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 constant_pool_count;&lt;span style="color:#75715e">//常量池的数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cp_info constant_pool&lt;span style="color:#f92672">[&lt;/span>constant_pool_count&lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#75715e">//常量池&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 access_flags;&lt;span style="color:#75715e">//Class 的访问标记&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 this_class;&lt;span style="color:#75715e">//当前类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 super_class;&lt;span style="color:#75715e">//父类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 interfaces_count;&lt;span style="color:#75715e">//接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 interfaces&lt;span style="color:#f92672">[&lt;/span>interfaces_count&lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#75715e">//一个类可以实现多个接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 fields_count;&lt;span style="color:#75715e">//Class 文件的字段属性&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> field_info fields&lt;span style="color:#f92672">[&lt;/span>fields_count&lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#75715e">//一个类可以有多个字段&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 methods_count;&lt;span style="color:#75715e">//Class 文件的方法数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method_info methods&lt;span style="color:#f92672">[&lt;/span>methods_count&lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#75715e">//一个类可以有个多个方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 attributes_count;&lt;span style="color:#75715e">//此类的属性表中的属性数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attribute_info attributes&lt;span style="color:#f92672">[&lt;/span>attributes_count&lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#75715e">//属性表集合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="img/ly-20241212141958065.png" alt="ly-20241212141958065" />&lt;/p></description></item><item><title>类加载器详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0405lyclassloader-detail/</link><pubDate>Sat, 17 Dec 2022 22:39:21 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0405lyclassloader-detail/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="回顾一下类加载过程">
 回顾一下类加载过程
 &lt;a class="anchor" href="#%e5%9b%9e%e9%a1%be%e4%b8%80%e4%b8%8b%e7%b1%bb%e5%8a%a0%e8%bd%bd%e8%bf%87%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;p>开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。&lt;/p>
&lt;ul>
&lt;li>类加载过程：&lt;strong>加载-&amp;gt;连接-&amp;gt;初始化&lt;/strong>。&lt;/li>
&lt;li>连接过程又可分为三步：&lt;strong>验证-&amp;gt;准备-&amp;gt;解析&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>[&lt;img src="img/ly-20241212142001796.jpg" alt="类加载过程" />&lt;/p>
&lt;p>加载是类加载过程的第一步，主要完成下面 3 件事情：&lt;/p>
&lt;ol>
&lt;li>通过&lt;strong>全类名&lt;/strong>获取定义此类的&lt;strong>二进制字节流&lt;/strong>&lt;/li>
&lt;li>将字节流所代表的静态存储结构&lt;strong>转换为方法区的运行时数据结构&lt;/strong>&lt;/li>
&lt;li>在&lt;strong>内存&lt;/strong>中生成一个代表该类的 &lt;strong>&lt;code>Class&lt;/code> 对象&lt;/strong>，作为&lt;strong>方法区这些数据的访问入口&lt;/strong>&lt;/li>
&lt;/ol>
&lt;h2 id="类加载器">
 类加载器
 &lt;a class="anchor" href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8">#&lt;/a>
&lt;/h2>
&lt;h3 id="类加载器介绍">
 类加载器介绍
 &lt;a class="anchor" href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h3>
&lt;p>类加载器从 JDK 1.0 就出现了，最初只是为了满足 Java Applet（已经被淘汰） 的需要。后来，慢慢成为 Java 程序中的一个重要组成部分，赋予了 &lt;strong>Java 类可以被动态加载到 JVM&lt;/strong> 中并执行的能力。&lt;/p>
&lt;p>根据官方 API 文档的介绍：&lt;/p>
&lt;blockquote>
&lt;p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a &amp;ldquo;class file&amp;rdquo; of that name from a file system.&lt;/p></description></item><item><title>类加载过程</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0404lyclassloader-process/</link><pubDate>Fri, 16 Dec 2022 10:06:50 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0404lyclassloader-process/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="类的声明周期">
 类的声明周期
 &lt;a class="anchor" href="#%e7%b1%bb%e7%9a%84%e5%a3%b0%e6%98%8e%e5%91%a8%e6%9c%9f">#&lt;/a>
&lt;/h1>
&lt;p>&lt;img src="img/ly-20241212141959924.png" alt="ly-20241212141959924" />&lt;/p>
&lt;h1 id="类加载过程">
 类加载过程
 &lt;a class="anchor" href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e8%bf%87%e7%a8%8b">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>Class文件，需要&lt;strong>加载到虚拟机中&lt;/strong>之后才能运行和使用，那么虚拟机是&lt;strong>如何加载&lt;/strong>这些Class文件呢&lt;/li>
&lt;li>系统加载Class类文件需要三步：&lt;strong>加载&lt;/strong>-&amp;gt;&lt;strong>连接&lt;/strong>-&amp;gt;&lt;strong>初始化&lt;/strong>。连接过程又分为三步：&lt;strong>验证&lt;/strong>-&amp;gt;&lt;strong>准备&lt;/strong>-&amp;gt;&lt;strong>解析&lt;/strong>&lt;br>
&lt;img src="img/ly-20241212142000194.png" alt="ly-20241212142000194" />&lt;/li>
&lt;/ul>
&lt;h2 id="加载">
 加载
 &lt;a class="anchor" href="#%e5%8a%a0%e8%bd%bd">#&lt;/a>
&lt;/h2>
&lt;p>类加载的第一步，主要完成3件事情&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>构造与类相关联的方法表&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>&lt;strong>通过全类名&lt;/strong>获取定义此类的&lt;strong>二进制字节流&lt;/strong>&lt;/li>
&lt;li>将&lt;strong>字节流&lt;/strong>所代表的&lt;strong>静态存储结构&lt;/strong>，转换为&lt;strong>方法区&lt;/strong>的&lt;strong>运行时数据结构&lt;/strong>&lt;/li>
&lt;li>在内存中生成一个该类的&lt;strong>Class对象&lt;/strong>，作为&lt;strong>方法区&lt;/strong>这些数据的访问入口&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>虚拟机规范对上面3点不具体，比较灵活&lt;/p>
&lt;ol>
&lt;li>对于1 没有具体指明从哪里获取、怎样获取。可以从ZIP包读取 （JAR/EAR/WAR格式的基础）、其他文件生成（JSP）等&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;ul>
&lt;li>非数组类的加载阶段（加载阶段&lt;strong>获取类的二进制字节流&lt;/strong>的动作）是可控性最强的阶段，这一步我们可以去完成还可以&lt;strong>自定义类加载器&lt;/strong>去&lt;strong>控制字节流&lt;/strong>的获取方式（重写一个类加载器的**loadClass()**方法&lt;/li>
&lt;li>数组类型&lt;strong>不通过&lt;/strong>类加载器创建，它由&lt;strong>Java虚拟机&lt;/strong>直接创建&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>加载阶段&lt;/strong>和&lt;strong>连接阶段&lt;/strong>的部分内容是&lt;strong>交叉执行&lt;/strong>的，即加载阶段尚未结束，连接阶段就可能已经开始了&lt;/p>
&lt;h2 id="验证">
 验证
 &lt;a class="anchor" href="#%e9%aa%8c%e8%af%81">#&lt;/a>
&lt;/h2>
&lt;p>验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的&lt;strong>字节流&lt;/strong>中包含的信息&lt;strong>符合《Java 虚拟机规范》&lt;strong>的全部约束要求，保证这些信息被当作代码运行后&lt;/strong>不会危害虚拟机自身的安全&lt;/strong>。&lt;/p>
&lt;p>验证阶段主要由&lt;strong>四个&lt;/strong>检验阶段组成：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>文件格式&lt;/strong>验证（Class 文件格式检查）&lt;/li>
&lt;li>&lt;strong>元数据&lt;/strong>验证（字节码语义检查）&lt;/li>
&lt;li>&lt;strong>字节码&lt;/strong>验证（程序语义检查）&lt;/li>
&lt;li>&lt;strong>符号引用&lt;/strong>验证（类的正确性检查）&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="img/ly-20241212142000337.png" alt="ly-20241212142000337" />&lt;/p>
&lt;h2 id="准备">
 准备
 &lt;a class="anchor" href="#%e5%87%86%e5%a4%87">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>准备阶段是正式&lt;strong>为类变量分配内存&lt;/strong>并&lt;strong>设置类变量初始值&lt;/strong>的阶段，这些内存都将在&lt;strong>方法区&lt;/strong>中分配，注意：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>这时候进行内存分配的&lt;strong>仅&lt;/strong>包括&lt;strong>类变量&lt;/strong>（&lt;strong>ClassVariables&lt;/strong>，即&lt;strong>静态变量&lt;/strong>：被&lt;code>static&lt;/code>关键字修饰的变量，&lt;strong>只与类相关&lt;/strong>，因此被称为&lt;strong>类变量&lt;/strong>），而&lt;strong>不包括&lt;/strong>实例变量。&lt;/p>
&lt;blockquote>
&lt;p>实例变量会在&lt;strong>对象实例化&lt;/strong>时，随着对象一块分配到&lt;strong>Java堆&lt;/strong>中&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>从概念上讲，类变量所使用的内存都应当在 &lt;strong>方法区&lt;/strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 &lt;strong>JDK 7 及之后&lt;/strong>，HotSpot 已经把&lt;strong>原本放在永久代&lt;/strong>的&lt;strong>字符串常量池&lt;/strong>、&lt;strong>静态变量&lt;/strong>等移动到&lt;strong>堆&lt;/strong>中，这个时候&lt;strong>类变量&lt;/strong>则会随着 **Class 对象（上面有提到，内存区生成Class对象）**一起存放在 Java 堆中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这里所设置的初始值**&amp;ldquo;通常情况&amp;rdquo;&lt;strong>下是&lt;/strong>数据类型默认的零值（如 0、0L、null、false 等**），比如我们定义了**&lt;code>public static int value=111&lt;/code>** ，那么 value 变量在准备阶段的&lt;strong>初始值就是 0 而不是 111&lt;/strong>（&lt;strong>初始化&lt;/strong>阶段才会赋值）。&lt;strong>特殊情况&lt;/strong>：比如给 &lt;strong>value 变量加上了 final&lt;/strong> 关键字&lt;code>public static final int value=111&lt;/code> ，那么准备阶段 value 的值就被赋值为 111&lt;/p></description></item><item><title>java垃圾回收</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0402lygarbage-collection/</link><pubDate>Mon, 12 Dec 2022 15:58:48 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0402lygarbage-collection/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h1>
&lt;p>当&lt;strong>需要排查各种内存溢出问题&lt;/strong>、当&lt;strong>垃圾收集&lt;/strong>成为系统达到更高并发的瓶颈时，我们就需要对这些**“自动化”&lt;strong>的技术实施必要的&lt;/strong>监控&lt;strong>和&lt;/strong>调节**&lt;/p>
&lt;h1 id="堆空间的基本结构">
 堆空间的基本结构
 &lt;a class="anchor" href="#%e5%a0%86%e7%a9%ba%e9%97%b4%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>Java的&lt;strong>自动内存管理&lt;/strong>主要是针对对象内存的&lt;strong>回收&lt;/strong>和对象内存的&lt;strong>分配&lt;/strong>。且Java自动内存管理最核心的功能是&lt;strong>堆&lt;/strong>内存中的对象&lt;strong>分配&lt;/strong>和&lt;strong>回收&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Java堆是垃圾收集器管理的主要区域，因此也被称作&lt;strong>GC堆（Garbage Collected Heap）&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从&lt;strong>垃圾回收的角度&lt;/strong>来说，由于现在收集器基本都采用&lt;strong>分代垃圾收集算法&lt;/strong>，所以Java堆被划分为了几个不同的区域，这样我们就可以&lt;strong>根据各个区域的特点&lt;/strong>选择&lt;strong>合适的垃圾收集算法&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>JDK7版本及JDK7版本之前，堆内存被通常分为下面三部分：&lt;/p>
&lt;ol>
&lt;li>新生代内存（Young Generation）&lt;/li>
&lt;li>老生代（Old Generation）&lt;/li>
&lt;li>永久代（Permanent Generation）&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://javaguide.cn/assets/hotspot-heap-structure.41533631.png" alt="hotspot-heap-structure" />&lt;/p>
&lt;p>JDK8版本之后PermGen（永久）已被Metaspace（元空间）取代，且已经不在堆里面了，元空间使用的是&lt;strong>直接内存&lt;/strong>。&lt;/p>
&lt;h1 id="内存分配和回收原则">
 内存分配和回收原则
 &lt;a class="anchor" href="#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%92%8c%e5%9b%9e%e6%94%b6%e5%8e%9f%e5%88%99">#&lt;/a>
&lt;/h1>
&lt;h2 id="对象优先在eden区分配">
 对象优先在Eden区分配
 &lt;a class="anchor" href="#%e5%af%b9%e8%b1%a1%e4%bc%98%e5%85%88%e5%9c%a8eden%e5%8c%ba%e5%88%86%e9%85%8d">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>多数情况下，对象在&lt;strong>新生代中Eden区&lt;/strong>分配。当Eden区没有足够空间进行分配时，会触发一次MinorGC
首先，先添加一下参数打印GC详情：&lt;code>-XX:+PrintGCDetails&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">GCTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> allocation1, allocation2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		allocation1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>30900&lt;span style="color:#f92672">*&lt;/span>1024&lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#75715e">//会用掉3万多K&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行后的结果（这里应该是配过xms和xmx了，即堆内存大小）
&lt;img src="img/ly-20241212141955776.jpg" alt="img" />
如上，&lt;strong>Eden区内存几乎被分配完全&lt;/strong>（即使程序什么都不做，新生代也会使用2000多K）&lt;/p>
&lt;blockquote>
&lt;p>注： PSYoungGen 为 38400K ，= 33280K + 5120K （Survivor区总会有一个是空的，所以只加了一个5120K ）&lt;/p>
&lt;/blockquote>
&lt;p>假如我们再为allocation2分配内存会怎么样(不处理的话，年轻代会溢出)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>allocation2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>900 &lt;span style="color:#f92672">*&lt;/span> 1024&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="img/ly-20241212141956049.jpg" alt="img" />
在给allocation2分配内存之前，Eden区内存几乎已经被分配完。所以当&lt;strong>Eden区没有足够空间进行分配时&lt;/strong>，虚拟机将发起一次MinorGC。GC期间虚拟机又发现&lt;strong>allocation1无法存入空间&lt;/strong>，所以只好通过&lt;strong>分配担保机制&lt;/strong>，把&lt;strong>新生代的对象&lt;/strong>，&lt;strong>提前转移到老年代&lt;/strong>去，老年代的空间足够存放allocation1，&lt;strong>所以不会出现Full GC（这里可能是之前的说法，可能只是要表达老年代的GC，而不是Full GC(整堆GC) ）&lt;/strong>　　&lt;/p>
&lt;p>执行MinorGC后，&lt;strong>后面分配的对象如果能够存在Eden区&lt;/strong>的话，还是会在Eden区分配内存&lt;br>
执行如下代码验证：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">GCTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 		&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> allocation1, allocation2,allocation3,allocation4,allocation5;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 		allocation1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>32000&lt;span style="color:#f92672">*&lt;/span>1024&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 		allocation2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>1000&lt;span style="color:#f92672">*&lt;/span>1024&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 		allocation3 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>1000&lt;span style="color:#f92672">*&lt;/span>1024&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 		allocation4 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>1000&lt;span style="color:#f92672">*&lt;/span>1024&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 		allocation5 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>1000&lt;span style="color:#f92672">*&lt;/span>1024&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="大对象直接进入老年代">
 大对象直接进入老年代
 &lt;a class="anchor" href="#%e5%a4%a7%e5%af%b9%e8%b1%a1%e7%9b%b4%e6%8e%a5%e8%bf%9b%e5%85%a5%e8%80%81%e5%b9%b4%e4%bb%a3">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>大对象就是需要连续空间的对象（&lt;strong>字符串&lt;/strong>、&lt;strong>数组&lt;/strong>等）&lt;/li>
&lt;li>大对象直接进入老年代，主要是为了避免为&lt;strong>大对象分配内存时&lt;/strong>，由于&lt;strong>分配担保机制(这好像跟分配担保机制没有太大关系)&lt;strong>带来的复制而&lt;/strong>降低效率&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;ul>
&lt;li>
&lt;p>假设大对象最后会晋升老年代，而新生代是基于复制算法来回收垃圾的，由两个Survivor区域配合完成复制算法，如果新生代中出现大对象且能屡次躲过GC，那这个对象就会在两个Survivor区域中来回复制，直至最后升入老年代，而大对象在内存里来回复制移动，就会消耗更多的时间。&lt;/p></description></item><item><title>jvm-intro</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0407lyjvm-intro/</link><pubDate>Fri, 09 Dec 2022 08:48:22 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0407lyjvm-intro/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!&lt;/p>
&lt;p>原文地址： &lt;a href="https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28">https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28&lt;/a> 感谢原作者分享！！&lt;/p>
&lt;/blockquote>
&lt;h1 id="jvm的基本介绍">
 JVM的基本介绍
 &lt;a class="anchor" href="#jvm%e7%9a%84%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>JVM，JavaVirtualMachine的缩写，虚拟出来的计算机，通过在实际的计算机上&lt;strong>仿真模拟&lt;/strong>各类计算机功能实现&lt;/li>
&lt;li>JVM类似一台小电脑，运行在windows或者linux这些&lt;strong>真实操作系统环境下&lt;/strong>，&lt;strong>直接&lt;/strong>和操作系统交互，&lt;strong>与硬件不直接交互&lt;/strong>，操作系统帮我们完成和硬件交互的工作&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="img/ly-20241212142002924.png" alt="img" />&lt;/p>
&lt;h2 id="java文件是如何运行的">
 Java文件是如何运行的
 &lt;a class="anchor" href="#java%e6%96%87%e4%bb%b6%e6%98%af%e5%a6%82%e4%bd%95%e8%bf%90%e8%a1%8c%e7%9a%84">#&lt;/a>
&lt;/h2>
&lt;p>场景假设：我们写了一个HelloWorld.java，这是一个文本文件。JVM不认识文本文件，所以&lt;strong>需要一个编译&lt;/strong>，让其(xxx.java)成为一个&lt;strong>JVM会读的二进制文件&amp;mdash;&amp;gt; HelloWorld.class&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>类加载器
如果JVM想要执行这个.class文件，需要将其**(这里应该指的二进制文件)&lt;strong>装进&lt;/strong>类加载器**中，它就像一个搬运工一样，会把所有的.class文件全部搬进JVM里面
&lt;img src="img/ly-20241212142003190.png" alt="img" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>方法区&lt;/p>
&lt;blockquote>
&lt;p>类加载器将.class文件搬过来，就是先丢到这一块上&lt;/p>
&lt;/blockquote>
&lt;p>方法区是用于&lt;strong>存放类似于元数据信息方面的数据&lt;/strong>的，比如&lt;strong>类信息&lt;/strong>、&lt;strong>常量&lt;/strong>、&lt;strong>静态变量&lt;/strong>、&lt;strong>编译后代码&lt;/strong>&amp;hellip;等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>堆
堆主要放一些&lt;strong>存储的数据&lt;/strong>，比如&lt;strong>对象实例&lt;/strong>、&lt;strong>数组&lt;/strong>&amp;hellip;等，它和&lt;strong>方法区&lt;/strong>都同属于&lt;strong>线程共享区域&lt;/strong>，即它们都是&lt;strong>线程不安全&lt;/strong>的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>栈&lt;/p>
&lt;p>线程独享&lt;br>
栈是我们&lt;strong>代码运行空间&lt;/strong>，我们编写的&lt;strong>每一个方法&lt;/strong>都会放到&lt;strong>栈&lt;/strong>里面运行。&lt;br>
名词：&lt;strong>本地方法栈&lt;/strong>或&lt;strong>本地方法接口&lt;/strong>，不过我们基本不会涉及这两块内容，这&lt;strong>两底层使用C&lt;/strong>进行工作，&lt;strong>和Java没有太大关系&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>程序计数器
主要就是完成一个加载工作，类似于一个指针一样的，&lt;strong>指向下一行我们需要执行的代码&lt;/strong>。和栈一样，都是&lt;strong>线程独享&lt;/strong>的，就是&lt;strong>每一个线程都会自己对应的一块区域&lt;/strong>而不会存在并发和多线程问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>小总结
&lt;img src="img/ly-20241212142003329.png" alt="img" />&lt;/p>
&lt;ol>
&lt;li>Java文件经过编译后编程.class字节码文件&lt;/li>
&lt;li>字节码文件通过类加载器被搬运到 JVM虚拟机中&lt;/li>
&lt;li>虚拟机主要的5大块：&lt;strong>方法区、堆&lt;/strong> 都为&lt;strong>线程共享&lt;/strong>区域，有线程安全问题；&lt;strong>栈&lt;/strong>和&lt;strong>本地方法栈&lt;/strong>和&lt;strong>计数器&lt;/strong>都是&lt;strong>独享&lt;/strong>区域，不存在线程安全问题，而JVM的调优主要就是围绕&lt;strong>堆&lt;/strong>、&lt;strong>栈&lt;/strong>两大块进行&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="简单的代码例子">
 简单的代码例子
 &lt;a class="anchor" href="#%e7%ae%80%e5%8d%95%e7%9a%84%e4%bb%a3%e7%a0%81%e4%be%8b%e5%ad%90">#&lt;/a>
&lt;/h2>
&lt;p>一个简单的学生类及main方法:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sayName&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;student&amp;#39;s name is : &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>main方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">App&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Student student &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Student(&lt;span style="color:#e6db74">&amp;#34;tellUrDream&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> student.&lt;span style="color:#a6e22e">sayName&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>★★ 执行main方法的步骤如下&lt;/p></description></item><item><title>memory-area</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0401lymemory-area/</link><pubDate>Wed, 07 Dec 2022 13:49:39 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/JVM/ly0401lymemory-area/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;p>如果没有特殊说明，针对的都是HotSpot虚拟机&lt;/p>
&lt;/blockquote>
&lt;h1 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>对于Java程序员，虚拟机自动管理机制，不需要像C/C++程序员为每一个new 操作去写对应的delete/free 操作，不容易出现&lt;strong>内存泄漏&lt;/strong> 和 &lt;strong>内存溢出&lt;/strong>问题&lt;/li>
&lt;li>但由于内存控制权交给Java虚拟机，一旦出现&lt;strong>内存泄漏和溢出&lt;/strong>方面问题，如果不了解虚拟机是怎么样使用内存，那么很难&lt;strong>排查任务&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="运行时数据区域">
 运行时数据区域
 &lt;a class="anchor" href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e6%95%b0%e6%8d%ae%e5%8c%ba%e5%9f%9f">#&lt;/a>
&lt;/h1>
&lt;p>&lt;strong>Java虚拟机&lt;/strong>在执行Java程序的过程中，会把它管理的内存，&lt;strong>划分成若干个&lt;/strong>不同的数据区域&lt;/p>
&lt;p>JDK1.8之前：&lt;/p>
&lt;ol>
&lt;li>线程共享
堆，方法区【永久代】(包括运行时常量池)&lt;/li>
&lt;li>线程私有
虚拟机栈、本地方法栈、程序计数器&lt;/li>
&lt;li>本地内存(包括直接内存)&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="img/ly-20241212141952681.png" alt="ly-20241212141952681" />&lt;/p>
&lt;p>JDK1.8之后：&lt;br>
&lt;img src="img/ly-20241212141952951.png" alt="Java 运行时数据区域（JDK1.8 之后）" />
1.8之后整个永久代改名叫&amp;quot;元空间&amp;quot;，且移到了本地内存中&lt;/p>
&lt;p>规范（概括）：&lt;br>
&lt;strong>线程私有&lt;/strong>：程序计数器，虚拟机栈，本地方法栈&lt;/p>
&lt;p>&lt;strong>线程共享&lt;/strong>：堆，方法区，直接内存（非运行时数据区的一部分）&lt;/p>
&lt;blockquote>
&lt;p>Java虚拟机规范对于运行时数据区域的规定是相当宽松的，以堆为例：&lt;/p>
&lt;ol>
&lt;li>堆可以是连续，也可以不连续&lt;/li>
&lt;li>大小可以固定，也可以运行时按需扩展&lt;/li>
&lt;li>虚拟机实现者可以使用任何&lt;strong>垃圾回收算法管理堆&lt;/strong>，设置不进行垃圾收集&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h2 id="程序计数器">
 程序计数器
 &lt;a class="anchor" href="#%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>是一块较小内存空间，看作是&lt;strong>当前线程所执行的字节码&lt;/strong>的&lt;strong>行号指示器&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>java程序流程&lt;br>
&lt;img src="img/ly-20241212141953092.png" alt="ly-20241212141953092" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>字节码解释器，工作时通过&lt;strong>改变这个计数器的值&lt;/strong>来选取下一条需要执行的&lt;strong>字节码指令&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>而且，为了&lt;strong>线程切换后恢复到正确执行位置&lt;/strong>，每条线程需要一个独立程序计数器，各线程计数器互不影响，独立存储，我们称这类内存区域为**&amp;ldquo;线程私有&amp;rdquo;**的内存&lt;/p>
&lt;/li>
&lt;li>
&lt;p>总结，&lt;strong>程序计数器&lt;/strong>的作用&lt;/p>
&lt;ul>
&lt;li>字节码解释器通过&lt;strong>改变程序计数器来依次读取指令&lt;/strong>，从而实现代码的流程控制&lt;/li>
&lt;li>多线程情况下，&lt;strong>程序计数器用于记录当前线程执行的位置&lt;/strong>，从而当线程被切回来的时候能够知道该线程上次运行到哪&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随线程创建而创建，线程结束而死亡&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;h2 id="java虚拟机栈">
 Java虚拟机栈
 &lt;a class="anchor" href="#java%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>Java虚拟机栈，&lt;strong>简称&amp;quot;栈&amp;quot;&lt;/strong>，也是线程私有的，生命周期和线程相同，随线程创建而创建，线程死亡而死亡&lt;/li>
&lt;li>除了&lt;strong>Native方法&lt;/strong>调用的是&lt;strong>通过本地方法栈实现&lt;/strong>的，其他所有的Java方法调用都是通过&lt;strong>栈&lt;/strong>来实现的（需要和其他运行时数据区域比如&lt;strong>程序计数器&lt;/strong>配合）&lt;/li>
&lt;li>&lt;strong>方法调用的数据&lt;/strong>需要通过栈进行&lt;strong>传递&lt;/strong>，&lt;strong>每一次方法调用&lt;/strong>都会有一个对应的&lt;strong>栈帧被压入栈&lt;/strong>，每一个&lt;strong>方法调用结束后&lt;/strong>，都会有一个&lt;strong>栈帧被弹出&lt;/strong>。&lt;/li>
&lt;li>栈由一个个&lt;strong>栈帧&lt;/strong>组成，每个栈帧包括&lt;strong>局部变量表&lt;/strong>、&lt;strong>操作数栈&lt;/strong>、&lt;strong>动态链接&lt;/strong>、&lt;strong>方法返回地址&lt;/strong>。
栈为&lt;strong>先进后出&lt;/strong>，且只支持&lt;strong>出栈&lt;/strong>和&lt;strong>入栈&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="img/ly-20241212141953237.png" alt="Java 虚拟机栈" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>局部变量表：存放&lt;strong>编译器可知&lt;/strong>的各种&lt;strong>数据类型&lt;/strong>(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型，不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是一个&lt;strong>指向一个代表对象的句柄或其他与此对象相关的位置&lt;/strong>)
&lt;img src="img/ly-20241212141953378.png" alt="局部变量表" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>操作数栈 作为方法调用的&lt;strong>中转站&lt;/strong>使用，用于存放方法执行过程中产生的&lt;strong>中间计算结果&lt;/strong>。计算过程中产生的临时变量也放在操作数栈中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>动态链接 主要服务&lt;strong>一个方法需要调用其他方法&lt;/strong>的场景。&lt;/p>
&lt;blockquote>
&lt;p>在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了&lt;strong>将符号引用转换为调用方法的直接引用&lt;/strong>。&lt;/p></description></item><item><title>completablefuture-intro</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0311lycompletablefuture-intro/</link><pubDate>Tue, 06 Dec 2022 17:13:41 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0311lycompletablefuture-intro/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>Java8被引入的一个非常有用的用于异步编程的类【&lt;strong>没看&lt;/strong>】&lt;/p>
&lt;h1 id="简单介绍">
 简单介绍
 &lt;a class="anchor" href="#%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h1>
&lt;p>CompletableFuture同时实现了&lt;strong>Future&lt;/strong>和&lt;strong>CompletionStage&lt;/strong>接口&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CompletableFuture&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Future&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>, CompletionStage&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>CompletableFuture&lt;/code> 除了提供了更为好用和强大的 &lt;code>Future&lt;/code> 特性之外，还提供了函数式编程的能力。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141948027.png" alt="img" />&lt;/p>
&lt;p>Future接口有5个方法：&lt;/p>
&lt;ul>
&lt;li>&lt;code>boolean cancel(boolean mayInterruptIfRunning)&lt;/code> ：尝试取消执行任务。&lt;/li>
&lt;li>&lt;code>boolean isCancelled()&lt;/code> ：判断任务是否被取消。&lt;/li>
&lt;li>&lt;code>boolean isDone()&lt;/code> ： 判断任务是否已经被执行完成。&lt;/li>
&lt;li>&lt;code>get()&lt;/code> ：等待任务执行完成并获取运算结果。&lt;/li>
&lt;li>&lt;code>get(long timeout, TimeUnit unit)&lt;/code> ：多了一个超时时间。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="img/ly-20241212141948313.png" alt="img" />&lt;/p>
&lt;p>&lt;code>CompletionStage&amp;lt;T&amp;gt; &lt;/code>接口中的方法比较多，CompoletableFuture的函数式能力就是这个接口赋予的，大量使用&lt;strong>Java8引入的函数式编程&lt;/strong>&lt;/p>
&lt;h1 id="常见操作">
 常见操作
 &lt;a class="anchor" href="#%e5%b8%b8%e8%a7%81%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h1>
&lt;h2 id="创建completablefuture">
 创建CompletableFuture
 &lt;a class="anchor" href="#%e5%88%9b%e5%bb%bacompletablefuture">#&lt;/a>
&lt;/h2>
&lt;p>两种方法：new关键字或 CompletableFuture自带的静态工厂方法 &lt;code>runAysnc()&lt;/code>或&lt;code>supplyAsync()&lt;/code>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>通过new关键字
这个方式，可以看作是将&lt;strong>CompletableFuture当作Future&lt;/strong>来使用，如下：&lt;/p>
&lt;blockquote>
&lt;p>我们通过创建了一个结果值类型为 &lt;code>RpcResponse&amp;lt;Object&amp;gt;&lt;/code> 的 &lt;code>CompletableFuture&lt;/code>，你可以把 &lt;code>resultFuture&lt;/code> 看作是异步运算结果的载体&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>CompletableFuture&lt;span style="color:#f92672">&amp;lt;&lt;/span>RpcResponse&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> resultFuture &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CompletableFuture&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;p>如果后面某个时刻，得到了最终结果，可以调用complete()方法传入结果，表示resultFuture已经被完成：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// complete() 方法只能调用一次，后续调用将被忽略。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>resultFuture.&lt;span style="color:#a6e22e">complete&lt;/span>(rpcResponse);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过isDone()检查是否完成：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isDone&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>获取异步结果，使用get() ，调用get()方法的线程会阻塞 直到CompletableFuture完成运算：
&lt;code>rpcResponse = completableFuture.get();&lt;/code>&lt;/p></description></item><item><title>ThreadLocal详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0310lythreadlocal/</link><pubDate>Mon, 05 Dec 2022 17:31:52 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0310lythreadlocal/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;p>本文来自一枝花算不算浪漫投稿， 原文地址：&lt;a href="https://juejin.cn/post/6844904151567040519">https://juejin.cn/post/6844904151567040519open in new window&lt;/a>。 感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>思维导图&lt;br>
&lt;img src="img/ly-20241212141945045.png" alt="img" />&lt;/p>
&lt;h1 id="目录">
 目录
 &lt;a class="anchor" href="#%e7%9b%ae%e5%bd%95">#&lt;/a>
&lt;/h1>
&lt;h1 id="threadlocal代码演示">
 ThreadLocal代码演示
 &lt;a class="anchor" href="#threadlocal%e4%bb%a3%e7%a0%81%e6%bc%94%e7%a4%ba">#&lt;/a>
&lt;/h1>
&lt;p>&lt;strong>简单使用&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ThreadLocalTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> messages &lt;span style="color:#f92672">=&lt;/span> Lists.&lt;span style="color:#a6e22e">newArrayList&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> ThreadLocal&lt;span style="color:#f92672">&amp;lt;&lt;/span>ThreadLocalTest&lt;span style="color:#f92672">&amp;gt;&lt;/span> holder &lt;span style="color:#f92672">=&lt;/span> ThreadLocal.&lt;span style="color:#a6e22e">withInitial&lt;/span>(ThreadLocalTest::&lt;span style="color:#66d9ef">new&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(String message) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> holder.&lt;span style="color:#a6e22e">get&lt;/span>().&lt;span style="color:#a6e22e">messages&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">clear&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> messages &lt;span style="color:#f92672">=&lt;/span> holder.&lt;span style="color:#a6e22e">get&lt;/span>().&lt;span style="color:#a6e22e">messages&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> holder.&lt;span style="color:#a6e22e">remove&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;size: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> holder.&lt;span style="color:#a6e22e">get&lt;/span>().&lt;span style="color:#a6e22e">messages&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> messages;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadLocalTest.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;一枝花算不算浪漫&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(holder.&lt;span style="color:#a6e22e">get&lt;/span>().&lt;span style="color:#a6e22e">messages&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadLocalTest.&lt;span style="color:#a6e22e">clear&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 结果 
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">[一枝花算不算浪漫]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">size: 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>简单使用2&lt;/strong>&lt;/p></description></item><item><title>Atomic原子类介绍</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0309lyatomic-classes/</link><pubDate>Mon, 05 Dec 2022 09:24:36 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0309lyatomic-classes/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>文章开头先用例子介绍几种类型的api使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> com.aqs;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> lombok.*;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.util.concurrent.atomic.*;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Data&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Getter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Setter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ToString&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果要为atomicReferenceFieldUpdater服务,必须加上volatile修饰&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">volatile&lt;/span> Integer age;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AtomicTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;原子更新数值---------------&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AtomicInteger atomicInteger &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> AtomicInteger();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i1 &lt;span style="color:#f92672">=&lt;/span> atomicInteger.&lt;span style="color:#a6e22e">incrementAndGet&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;原子增加后为&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;原子更新数组---------------&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>3&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AtomicIntegerArray atomicIntegerArray &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> AtomicIntegerArray(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> atomicIntegerArray.&lt;span style="color:#a6e22e">addAndGet&lt;/span>(1, 3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;数组元素[&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;]增加后为&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;数组为&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> atomicIntegerArray);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;原子更新对象---------------&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User user1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;ly1&amp;#34;&lt;/span>, 10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User user2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;ly2&amp;#34;&lt;/span>, 20);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User user3 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;ly3&amp;#34;&lt;/span>, 30);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AtomicReference&lt;span style="color:#f92672">&amp;lt;&lt;/span>User&lt;span style="color:#f92672">&amp;gt;&lt;/span> atomicReference &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> AtomicReference&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(user1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> atomicReference.&lt;span style="color:#a6e22e">compareAndSet&lt;/span>(user2, user3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;更新&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> (b &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#34;成功&amp;#34;&lt;/span> : &lt;span style="color:#e6db74">&amp;#34;失败&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;引用里值为&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>atomicReference.&lt;span style="color:#a6e22e">get&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> b1 &lt;span style="color:#f92672">=&lt;/span> atomicReference.&lt;span style="color:#a6e22e">compareAndSet&lt;/span>(user1, user3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;更新&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> (b1 &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#34;成功&amp;#34;&lt;/span> : &lt;span style="color:#e6db74">&amp;#34;失败&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;引用里值为&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>atomicReference.&lt;span style="color:#a6e22e">get&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;原子更新对象属性---------------&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User user4&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;ly4&amp;#34;&lt;/span>,40);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AtomicReferenceFieldUpdater&lt;span style="color:#f92672">&amp;lt;&lt;/span>User, Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> atomicReferenceFieldUpdater &lt;span style="color:#f92672">=&lt;/span> AtomicReferenceFieldUpdater.&lt;span style="color:#a6e22e">newUpdater&lt;/span>(User.&lt;span style="color:#a6e22e">class&lt;/span>, Integer.&lt;span style="color:#a6e22e">class&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;age&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> b2 &lt;span style="color:#f92672">=&lt;/span> atomicReferenceFieldUpdater.&lt;span style="color:#a6e22e">compareAndSet&lt;/span>(user4, 41, 400);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;更新&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>(b2&lt;span style="color:#f92672">?&lt;/span>&lt;span style="color:#e6db74">&amp;#34;成功&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;失败&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;引用里user4值为&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>atomicReferenceFieldUpdater.&lt;span style="color:#a6e22e">get&lt;/span>(user4));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> b3 &lt;span style="color:#f92672">=&lt;/span> atomicReferenceFieldUpdater.&lt;span style="color:#a6e22e">compareAndSet&lt;/span>(user4, 40, 400);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;更新&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>(b3&lt;span style="color:#f92672">?&lt;/span>&lt;span style="color:#e6db74">&amp;#34;成功&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;失败&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;引用里user4值为&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>atomicReferenceFieldUpdater.&lt;span style="color:#a6e22e">get&lt;/span>(user4));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;其他使用---------------&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User user5&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;ly5&amp;#34;&lt;/span>,50);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User user6&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;ly6&amp;#34;&lt;/span>,60);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User user7&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;ly7&amp;#34;&lt;/span>,70);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AtomicMarkableReference&lt;span style="color:#f92672">&amp;lt;&lt;/span>User&lt;span style="color:#f92672">&amp;gt;&lt;/span> userAtomicMarkableReference&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> AtomicMarkableReference&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(user5,&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> b4 &lt;span style="color:#f92672">=&lt;/span> userAtomicMarkableReference.&lt;span style="color:#a6e22e">weakCompareAndSet&lt;/span>(user6, user7, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;更新&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>(b4&lt;span style="color:#f92672">?&lt;/span>&lt;span style="color:#e6db74">&amp;#34;成功&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;失败&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;引用里值为&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>userAtomicMarkableReference.&lt;span style="color:#a6e22e">getReference&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> b5 &lt;span style="color:#f92672">=&lt;/span> userAtomicMarkableReference.&lt;span style="color:#a6e22e">weakCompareAndSet&lt;/span>(user5, user7, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;更新&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>(b5&lt;span style="color:#f92672">?&lt;/span>&lt;span style="color:#e6db74">&amp;#34;成功&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;失败&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;引用里值为&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>userAtomicMarkableReference.&lt;span style="color:#a6e22e">getReference&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> b6 &lt;span style="color:#f92672">=&lt;/span> userAtomicMarkableReference.&lt;span style="color:#a6e22e">weakCompareAndSet&lt;/span>(user5, user7, &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;更新&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>(b6&lt;span style="color:#f92672">?&lt;/span>&lt;span style="color:#e6db74">&amp;#34;成功&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;失败&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;引用里值为&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>userAtomicMarkableReference.&lt;span style="color:#a6e22e">getReference&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;AtomicStampedReference使用---------------&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User user80&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;ly8&amp;#34;&lt;/span>,80);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User user90&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;ly9&amp;#34;&lt;/span>,90);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User user100&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;ly10&amp;#34;&lt;/span>,100);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AtomicStampedReference&lt;span style="color:#f92672">&amp;lt;&lt;/span>User&lt;span style="color:#f92672">&amp;gt;&lt;/span> userAtomicStampedReference&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> AtomicStampedReference&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(user80,80);&lt;span style="color:#75715e">//版本80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...每次更改stamp都加1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//这里假设中途被改成81了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> b7 &lt;span style="color:#f92672">=&lt;/span> userAtomicStampedReference.&lt;span style="color:#a6e22e">compareAndSet&lt;/span>(user80, user100,81,90);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;更新&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>(b7&lt;span style="color:#f92672">?&lt;/span>&lt;span style="color:#e6db74">&amp;#34;成功&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;失败&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;引用里值为&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>userAtomicStampedReference.&lt;span style="color:#a6e22e">getReference&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> b8 &lt;span style="color:#f92672">=&lt;/span> userAtomicStampedReference.&lt;span style="color:#a6e22e">compareAndSet&lt;/span>(user80, user100,80,90);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;更新&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>(b8&lt;span style="color:#f92672">?&lt;/span>&lt;span style="color:#e6db74">&amp;#34;成功&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;失败&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;引用里值为&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>userAtomicStampedReference.&lt;span style="color:#a6e22e">getReference&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">原子更新数值---------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">原子增加后为1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">原子更新数组---------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">数组元素[1]增加后为3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">数组为[0, 3, 0]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">原子更新对象---------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">更新失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">引用里值为User(name=ly1, age=10)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">更新成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">引用里值为User(name=ly3, age=30)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">原子更新对象属性---------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">更新失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">引用里user4值为40
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">更新成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">引用里user4值为400
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">其他使用---------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">更新失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">引用里值为User(name=ly5, age=50)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">更新失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">引用里值为User(name=ly5, age=50)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">更新成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">引用里值为User(name=ly7, age=70)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">AtomicStampedReference使用---------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">更新失败
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">引用里值为User(name=ly8, age=80)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">更新成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">引用里值为User(name=ly10, age=100)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">Process finished with exit code 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="原子类介绍">
 原子类介绍
 &lt;a class="anchor" href="#%e5%8e%9f%e5%ad%90%e7%b1%bb%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>在化学上，原子是构成一般物质的最小单位，化学反应中是不可分割的，Atomic指&lt;strong>一个操作是不可中断的&lt;/strong>，即使在多个线程一起执行时，一个操作一旦开始就&lt;strong>不会被其他线程干扰&lt;/strong>&lt;/li>
&lt;li>原子类&amp;ndash;&amp;gt;具有原子/原子操作特征的类&lt;/li>
&lt;li>并发包java.util.concurrent 的原子类都放着&lt;code>java.util.concurrent.atomic&lt;/code>中
&lt;img src="img/ly-20241212141944757.png" alt="ly-20241212141944757" />&lt;/li>
&lt;li>根据操作的数据类型，可以将JUC包中的原子类分为4类（基本类型、数组类型、引用类型、对象的属性修改类型）
&lt;ul>
&lt;li>
&lt;p>基本类型
使用原子方式更新基本类型，包括&lt;strong>AtomicInteger 整型原子类&lt;/strong>，&lt;strong>AtomicLong 长整型原子类&lt;/strong>，AtomicBoolean 布尔型原子类&lt;/p></description></item><item><title>aqs详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0308lyaqs-details/</link><pubDate>Wed, 30 Nov 2022 14:48:01 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0308lyaqs-details/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>Semaphore [ˈseməfɔː(r)]&lt;/code>&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>何为 AQS？AQS 原理了解吗？&lt;/li>
&lt;li>&lt;code>CountDownLatch&lt;/code> 和 &lt;code>CyclicBarrier&lt;/code> 了解吗？两者的区别是什么？&lt;/li>
&lt;li>用过 &lt;code>Semaphore&lt;/code> 吗？应用场景了解吗？&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h1 id="aqs简单介绍">
 AQS简单介绍
 &lt;a class="anchor" href="#aqs%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h1>
&lt;p>AQS,AbstractQueueSyschronizer，即抽象队列同步器，这个类在java.util.concurrent.locks包下面&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141944167.png" alt="ly-20241212141944167" />&lt;/p>
&lt;p>AQS是一个抽象类，主要用来构建&lt;strong>锁&lt;/strong>和&lt;strong>同步器&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AbstractQueuedSynchronizer&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> AbstractOwnableSynchronizer &lt;span style="color:#66d9ef">implements&lt;/span> java.&lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Serializable&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AQS &lt;strong>为构建锁和同步器提供了一些通用功能&lt;/strong>的实现，因此，使用 AQS 能简单且高效地&lt;strong>构造出应用广泛的大量的同步器&lt;/strong>，比如我们提到的 &lt;strong>&lt;code>ReentrantLock&lt;/code>&lt;/strong>，&lt;strong>&lt;code>Semaphore&lt;/code>&lt;/strong>，其他的诸如 &lt;code>ReentrantReadWriteLock&lt;/code>，&lt;code>SynchronousQueue&lt;/code>，&lt;code>FutureTask&lt;/code>(jdk1.7) 等等皆是基于 AQS 的。&lt;/p>
&lt;h1 id="aqs原理">
 AQS原理
 &lt;a class="anchor" href="#aqs%e5%8e%9f%e7%90%86">#&lt;/a>
&lt;/h1>
&lt;h2 id="aqs核心思想">
 AQS核心思想
 &lt;a class="anchor" href="#aqs%e6%a0%b8%e5%bf%83%e6%80%9d%e6%83%b3">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来&lt;/strong>&lt;/p>
&lt;p>AQS 核心思想是，如果被请求的&lt;strong>共享资源（AQS内部）&lt;strong>空闲，则将&lt;/strong>当前请求资源的线程&lt;/strong>设置为&lt;strong>有效&lt;/strong>的工作线程，并且将&lt;strong>共享资源&lt;/strong>设置为&lt;strong>锁定&lt;/strong>状态。如果被请求的共享资源&lt;strong>被占用&lt;/strong>，那么就需要一套&lt;strong>线程阻塞等待&lt;/strong>以及&lt;strong>被唤醒时锁分配&lt;/strong>的机制，这个机制 AQS 是用 &lt;strong>CLH 队列锁&lt;/strong>实现的，即&lt;strong>将暂时获取不到锁的线程加入到队列&lt;/strong>中。&lt;/p>
&lt;blockquote>
&lt;p>CLH(Craig,Landin and Hagersten)队列是一个&lt;strong>虚拟的双向队列&lt;/strong>（虚拟的双向队列即&lt;strong>不存在队列实例&lt;/strong>，仅存在结点之间的关联关系）。AQS 是&lt;strong>将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点&lt;/strong>（Node）来实现锁的分配。&lt;br>
[ 搜索了一下，CLH好像是人名 ]
在 CLH 同步队列中，一个节点表示一个线程，它保存着&lt;strong>线程的引用&lt;/strong>（thread）、 当前节点在&lt;strong>队列中的状态&lt;/strong>（waitStatus）、&lt;strong>前驱节点&lt;/strong>（prev）、&lt;strong>后继节点&lt;/strong>（next）。&lt;br>
CLH队列结构&lt;br>
&lt;img src="img/ly-20241212141944445.png" alt="ly-20241212141944445" />&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>AQS（AbstractQueuedSynchronized）原理图&lt;br>
&lt;img src="img/ly-20241212141944597.png" alt="ly-20241212141944597" />&lt;/p>
&lt;p>AQS使用一个&lt;strong>int成员变量来表示同步状态&lt;/strong>，通过内置的&lt;strong>线程等待队列&lt;/strong>来获取资源线程的排队工作。&lt;br>
&lt;code>state&lt;/code> 变量由 &lt;code>volatile&lt;/code> 修饰，用于展示&lt;strong>当前临界资源的获锁&lt;/strong>情况。&lt;/p></description></item><item><title>java常见并发容器</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0307lyconcurrent-collections/</link><pubDate>Tue, 29 Nov 2022 16:58:59 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0307lyconcurrent-collections/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>JDK提供的容器，大部分在java.util.concurrent包中&lt;/p>
&lt;ul>
&lt;li>ConcurrentHashMap：线程安全的&lt;strong>HashMap&lt;/strong>&lt;/li>
&lt;li>CopyOnWriteArrayList：线程安全的&lt;strong>List&lt;/strong>，在读多写少的场合性能非常好，远好于Vector&lt;/li>
&lt;li>&lt;strong>ConcurrentLinkedQueue&lt;/strong>：高效的&lt;strong>并发队列&lt;/strong>，使用&lt;strong>链表&lt;/strong>实现，可以看作一个&lt;strong>线程安全的LinkedList&lt;/strong>，是一个&lt;strong>非阻塞队列&lt;/strong>&lt;/li>
&lt;li>&lt;strong>BlockingQueue&lt;/strong>：这是一个接口，JDK内部通过链表、数组等方式实现了该接口。表示&lt;strong>阻塞队列&lt;/strong>，非常适合用于作为数据共享的通道&lt;/li>
&lt;li>ConcorrentSkipListMap：&lt;strong>跳表&lt;/strong>的实现，是一个Map，使用&lt;strong>跳表的数据结构进行快速查找&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="concurrenthashmap">
 ConcurrentHashMap
 &lt;a class="anchor" href="#concurrenthashmap">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>HashMap是线程不安全的，并发场景下要保证线程安全，可以使用Collections.synchronizedMap()方法来包装HashMap，但这是通过&lt;strong>使用一个全局的锁&lt;/strong>来&lt;strong>同步不同线程间的并发访问&lt;/strong>，因此会带来性能问题&lt;/li>
&lt;li>建议使用ConcurrentHashMap，&lt;strong>不论是读操作还是写操作&lt;/strong>都能保证高性能：读操作（几乎）不需要加锁，而写操作时通过&lt;strong>锁分段(这里说的是JDK1.7？)&lt;strong>技术，只对&lt;/strong>所操作的段加锁&lt;/strong>而不影响客户端对其他段的访问&lt;/li>
&lt;/ul>
&lt;h1 id="copyonwritearraylist">
 CopyOnWriteArrayList
 &lt;a class="anchor" href="#copyonwritearraylist">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//源码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CopyOnWriteArrayList&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">extends&lt;/span> Object
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">implements&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span>, RandomAccess, Cloneable, Serializable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>在很多应用场景中，&lt;strong>读操作可能会远远大于写操作&lt;/strong>&lt;/li>
&lt;li>我们应该允许&lt;strong>多个线程同时访问List内部数据&lt;/strong>（针对读）&lt;/li>
&lt;li>与ReentrantReadWriteLock读写锁思想非常类似，即&lt;strong>读读共享&lt;/strong>、&lt;strong>写写互斥&lt;/strong>、&lt;strong>读写互斥&lt;/strong>、&lt;strong>写读互斥&lt;/strong>&lt;/li>
&lt;li>不一样的是，CopyOnWriteArrayList&lt;strong>读取时完全不需要加锁&lt;/strong>，且&lt;strong>写入也不会阻塞读取操作&lt;/strong>，只有&lt;strong>写入和写入之间需要同步等待&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h2 id="copyonwritearraylist是如何做到的">
 CopyOnWriteArrayList是如何做到的
 &lt;a class="anchor" href="#copyonwritearraylist%e6%98%af%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0%e7%9a%84">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;code>CopyOnWriteArrayList&lt;/code> 类的&lt;strong>所有可变操作（add，set 等等）都是通过创建底层数组的新副本&lt;/strong>来实现的。当 List 需要被修改的时候，并不修改原有内容，而是&lt;strong>对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据&lt;/strong>，这样就可以保证写操作不会影响读操作了。&lt;/li>
&lt;li>从 &lt;code>CopyOnWriteArrayList&lt;/code> 的名字就能看出 &lt;code>CopyOnWriteArrayList&lt;/code> 是满足 &lt;strong>&lt;code>CopyOnWrite&lt;/code>&lt;/strong> 的&lt;/li>
&lt;li>在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就&lt;strong>将指向原来内存指针指向新的内存(注意，是指向，而不是重新拷贝★重要★)&lt;/strong>，原来的内存就可以被回收掉了&lt;/li>
&lt;/ul>
&lt;h2 id="copyonwritearraylist-读取和写入源码简单分析">
 CopyOnWriteArrayList 读取和写入源码简单分析
 &lt;a class="anchor" href="#copyonwritearraylist-%e8%af%bb%e5%8f%96%e5%92%8c%e5%86%99%e5%85%a5%e6%ba%90%e7%a0%81%e7%ae%80%e5%8d%95%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>CopyOnWriteArrayList读取操作的实现
&lt;strong>读取操作没有任何同步控制&lt;/strong>和&lt;strong>锁&lt;/strong>操作，理由就是内部数组array不会发生修改，只会&lt;strong>被另一个array替换&lt;/strong>，因此可以保证数据安全&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/** The array, accessed only via getArray/setArray. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">transient&lt;/span> &lt;span style="color:#66d9ef">volatile&lt;/span> Object&lt;span style="color:#f92672">[]&lt;/span> array;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> E &lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> index) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> get(getArray(), index);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@SuppressWarnings&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unchecked&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> E &lt;span style="color:#a6e22e">get&lt;/span>(Object&lt;span style="color:#f92672">[]&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> index) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (E) a&lt;span style="color:#f92672">[&lt;/span>index&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> Object&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">getArray&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> array;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>CopyOnWriteArrayList写入操作的实现
在添加集合的时候加了锁，保证同步，&lt;strong>避免多线程写的时候会copy出多个副本&lt;/strong>&lt;/p></description></item><item><title>线程池最佳实践</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0306lythread-pool-best/</link><pubDate>Tue, 29 Nov 2022 11:31:20 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0306lythread-pool-best/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="线程池知识回顾">
 线程池知识回顾
 &lt;a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9f%a5%e8%af%86%e5%9b%9e%e9%a1%be">#&lt;/a>
&lt;/h2>
&lt;h3 id="1-为什么要使用线程池">
 1. 为什么要使用线程池
 &lt;a class="anchor" href="#1-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>池化技术的思想，主要是为了&lt;strong>减少每次获取资源（线程资源）的消耗&lt;/strong>，提高对资源的利用率&lt;/li>
&lt;li>线程池提供了一种&lt;strong>限制&lt;/strong>和&lt;strong>管理资源&lt;/strong>（包括执行一个任务）的方法，每个线程池还维护一些&lt;strong>基本统计&lt;/strong>信息，例如已完成任务的数量&lt;/li>
&lt;/ul>
&lt;p>好处：&lt;/p>
&lt;ol>
&lt;li>降低资源消耗&lt;/li>
&lt;li>提高响应速度&lt;/li>
&lt;li>提高线程的可管理性&lt;/li>
&lt;/ol>
&lt;h3 id="2-线程池在实际项目的使用场景">
 2. 线程池在实际项目的使用场景
 &lt;a class="anchor" href="#2-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%9c%a8%e5%ae%9e%e9%99%85%e9%a1%b9%e7%9b%ae%e7%9a%84%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af">#&lt;/a>
&lt;/h3>
&lt;p>线程池一般用于执行&lt;strong>多个不相关联的耗时任务&lt;/strong>，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务&lt;strong>同时执行&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141942375.png" alt="ly-20241212141942375" />&lt;/p>
&lt;h3 id="3-如何使用线程池">
 3. 如何使用线程池
 &lt;a class="anchor" href="#3-%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0">#&lt;/a>
&lt;/h3>
&lt;p>一般是通过 &lt;code>ThreadPoolExecutor&lt;/code> 的构造函数来创建线程池，然后提交任务给线程池执行就可以了。构造函数如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">ThreadPoolExecutor&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> corePoolSize,&lt;span style="color:#75715e">//线程池的核心线程数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> maximumPoolSize,&lt;span style="color:#75715e">//线程池的最大线程数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> keepAliveTime,&lt;span style="color:#75715e">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TimeUnit unit,&lt;span style="color:#75715e">//时间单位&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BlockingQueue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Runnable&lt;span style="color:#f92672">&amp;gt;&lt;/span> workQueue,&lt;span style="color:#75715e">//任务队列，用来储存等待执行任务的队列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadFactory threadFactory,&lt;span style="color:#75715e">//线程工厂，用来创建线程，一般默认即可&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RejectedExecutionHandler handler&lt;span style="color:#75715e">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (corePoolSize &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0 &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maximumPoolSize &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 0 &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> maximumPoolSize &lt;span style="color:#f92672">&amp;lt;&lt;/span> corePoolSize &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keepAliveTime &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalArgumentException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (workQueue &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">||&lt;/span> threadFactory &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">||&lt;/span> handler &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> NullPointerException();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">corePoolSize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> corePoolSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">maximumPoolSize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> maximumPoolSize;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">workQueue&lt;/span> &lt;span style="color:#f92672">=&lt;/span> workQueue;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">keepAliveTime&lt;/span> &lt;span style="color:#f92672">=&lt;/span> unit.&lt;span style="color:#a6e22e">toNanos&lt;/span>(keepAliveTime);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">threadFactory&lt;/span> &lt;span style="color:#f92672">=&lt;/span> threadFactory;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">handler&lt;/span> &lt;span style="color:#f92672">=&lt;/span> handler;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用代码：&lt;/p></description></item><item><title>java线程池详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0305lyjava-thread-pool/</link><pubDate>Wed, 23 Nov 2022 14:40:41 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0305lyjava-thread-pool/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="一-使用线程池的好处">
 一 使用线程池的好处
 &lt;a class="anchor" href="#%e4%b8%80-%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e5%a5%bd%e5%a4%84">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>池化技术：减少每次获取资源的消耗，提高对资源的利用率&lt;/li>
&lt;li>线程池提供一种&lt;strong>限制&lt;/strong>和&lt;strong>管理资源（包括执行一个任务）&lt;strong>的方式，每个线程池还维护一些基本统计信息，例如&lt;/strong>已完成任务&lt;/strong>的数量&lt;/li>
&lt;li>线程池的好处
&lt;ul>
&lt;li>降低&lt;strong>资源消耗&lt;/strong>（重复利用，降低&lt;strong>线程创建和销毁&lt;/strong>造成的消耗）&lt;/li>
&lt;li>提高&lt;strong>响应速度&lt;/strong>（任务到达直接执行，&lt;strong>无需等待线程创建&lt;/strong>）&lt;/li>
&lt;li>提高线程&lt;strong>可管理性&lt;/strong>（&lt;strong>避免无休止创建&lt;/strong>，使用线程池统一&lt;strong>分配&lt;/strong>、&lt;strong>调优&lt;/strong>、&lt;strong>监控&lt;/strong>）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="二-executor框架">
 二 Executor框架
 &lt;a class="anchor" href="#%e4%ba%8c-executor%e6%a1%86%e6%9e%b6">#&lt;/a>
&lt;/h2>
&lt;p>Java5之后，通过Executor启动线程，比使用Thread的start方法更好，更&lt;strong>易于管理&lt;/strong>，&lt;strong>效率高&lt;/strong>，还能有助于避免this逃逸的问题&lt;/p>
&lt;blockquote>
&lt;p>this逃逸，指的是&lt;strong>构造函数返回之前&lt;/strong>，&lt;strong>其他线程就持有该对象的引用&lt;/strong>，会导致调用尚未构造完全的对象&lt;br>
例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ThisEscape&lt;/span> { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">ThisEscape&lt;/span>() { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(&lt;span style="color:#66d9ef">new&lt;/span> EscapeRunnable()).&lt;span style="color:#a6e22e">start&lt;/span>(); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">EscapeRunnable&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Runnable { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通过ThisEscape.this就可以引用外围类对象, 但是此时外围类对象可能还没有构造完成, 即发生了外围类的this引用的逃逸 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>处理办法 &lt;strong>//不要在构造函数中运行线程&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ThisEscape&lt;/span> { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Thread t; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">ThisEscape&lt;/span>() { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(&lt;span style="color:#66d9ef">new&lt;/span> EscapeRunnable()); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ... &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//也就是说对象没有构造完成前，不要调用ThisEscape.this即可&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t.&lt;span style="color:#a6e22e">start&lt;/span>(); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">EscapeRunnable&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Runnable { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通过ThisEscape.this就可以引用外围类对象, 此时可以保证外围类对象已经构造完成 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/blockquote>
&lt;p>Executor框架不仅包括&lt;strong>线程池的管理&lt;/strong>，提供&lt;strong>线程工厂&lt;/strong>、&lt;strong>队列&lt;/strong>以及&lt;strong>拒绝策略&lt;/strong>。&lt;/p></description></item><item><title>java内存模型</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0304lyjmm/</link><pubDate>Mon, 21 Nov 2022 10:57:24 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0304lyjmm/</guid><description>&lt;blockquote>
&lt;p>引用自https://github.com/Snailclimb/JavaGuide&lt;/p>
&lt;/blockquote>
&lt;h2 id="从cpu缓存模型说起">
 从CPU缓存模型说起
 &lt;a class="anchor" href="#%e4%bb%8ecpu%e7%bc%93%e5%ad%98%e6%a8%a1%e5%9e%8b%e8%af%b4%e8%b5%b7">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>redis是为了解决&lt;strong>程序处理速度和访问常规关系型数据库速度不对等&lt;/strong>的问题，&lt;strong>CPU缓存则是为了解决CPU处理速度和内存处理速度不对等的问题&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>我们把内存看作外存的高速缓存，程序运行时把外存的数据复制到内存，由于&lt;strong>内存的处理速度远高于外存&lt;/strong>，这样提高了处理速度&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>总结，&lt;strong>CPU Cache缓存的是内存数据&lt;/strong>，用于解决&lt;strong>CPU处理速度和内存不匹配&lt;/strong>的问题，&lt;strong>内存缓存的是硬盘数据&lt;/strong>用于解决硬盘访问速度过慢的问题
CPU Cache示意图：&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141939038.png" alt="ly-20241212141939038" />
CPU Cache通常分为三层，分别叫L1，L2，L3 Cache
工作方式： &lt;strong>先复制一份数据到CPUCache中，当CPU需要用的时候就可以从CPUCache中读取数据，运算完成后，将运算得到的数据，写回MainMemory中&lt;/strong>，此时，会出现&lt;strong>内存缓存不一致的问题&lt;/strong>，例子：执行了i++，如果两个线程同时执行，假设两个线程从CPUCach中读取的i=1，两个线程做了1++运算完之后再写回MainMemory，此时i=2 而正确结果为3&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CPU为了解决&lt;strong>内存缓存不一致&lt;/strong>问题，可以通过制定&lt;strong>缓存一致协议（比如MESI协议）或其他手段&lt;/strong>。这个&lt;strong>缓存一致协议&lt;/strong>，指的是在 &lt;strong>CPU 高速缓存与主内存交互的时候需要遵守的原则和规范&lt;/strong>
&lt;img src="img/ly-20241212141939314.png" alt="ly-20241212141939314" />
操作系统，通过&lt;strong>内存模型MemoryModel&lt;/strong>定义一系列规范来解决这个问题&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="java内存模型">
 Java内存模型
 &lt;a class="anchor" href="#java%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212141939466.png" alt="ly-20241212141939466" />&lt;/p>
&lt;h2 id="指令重排序">
 指令重排序
 &lt;a class="anchor" href="#%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92%e5%ba%8f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>什么是指令重排序？&lt;/strong> 简单来说就是系统在&lt;strong>执行代码的时候并不一定是按照你写的代码的顺序&lt;/strong>依次执行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指令重排有下面2种&lt;/p>
&lt;ul>
&lt;li>&lt;strong>编译器优化重排&lt;/strong>：编译器（包括 JVM、JIT 编译器等）在不改变&lt;strong>单线程程序语义&lt;/strong>的前提下，重新安排语句的执行顺序。&lt;/li>
&lt;li>&lt;strong>指令并行重排&lt;/strong>：现代处理器采用了&lt;strong>指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行&lt;/strong>。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>另外，&lt;strong>内存系统&lt;/strong>也会有“重排序”，但又不是真正意义上的重排序。在 JMM 里表现为&lt;strong>主存和本地内存的内容可能不一致&lt;/strong>，进而&lt;strong>导致程序在多线程下执行可能出现问题&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>即Java源代码会经历 &lt;strong>编译器优化重排&lt;/strong>&amp;mdash;&amp;gt;&lt;strong>指令并行重排&lt;/strong>&amp;mdash;&amp;gt;&lt;strong>内存系统重排&lt;/strong>，最终&lt;strong>编程&lt;/strong>操作系统可执行的&lt;strong>指令序列&lt;/strong>&lt;/p>
&lt;p>极其重要★：指令重排序可以&lt;strong>保证串行语义一致&lt;/strong>，但是&lt;strong>没有义务保证多线程间的语义也一致&lt;/strong>，所以在多线程下&lt;strong>指令重排&lt;/strong>可能导致一些问题&lt;/p>
&lt;blockquote>
&lt;p>编译器和处理器的指令重排序的处理方式不一样。对于&lt;strong>编译器&lt;/strong>，通过&lt;strong>禁止特定类型的编译器重排序&lt;/strong>的方式来禁止重排序。对于&lt;strong>处理器&lt;/strong>，通过&lt;strong>插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）&lt;strong>的方式来禁止特定类型的处理器重排序。&lt;strong>指令并行重&lt;/strong>排和&lt;/strong>内存系统重排&lt;/strong>都属于是&lt;strong>处理器级别的指令重排序&lt;/strong>。&lt;/p>
&lt;p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种 &lt;strong>CPU 指令&lt;/strong>，用来&lt;strong>禁止处理器指令发生重排序&lt;/strong>（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使&lt;strong>处理器写入、读取值之前&lt;/strong>，将&lt;strong>主内存的值写入高速缓存&lt;/strong>，&lt;strong>清空无效队列&lt;/strong>，从而保障变量的可见性。&lt;/p>
&lt;/blockquote>
&lt;h2 id="jmmjavamemorymode">
 JMM（JavaMemoryMode）
 &lt;a class="anchor" href="#jmmjavamemorymode">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是-jmm为什么需要-jmm">
 什么是 JMM？为什么需要 JMM？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-jmm%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-jmm">#&lt;/a>
&lt;/h3>
&lt;blockquote>
&lt;p>一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。&lt;strong>如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了&lt;/strong>。&lt;strong>Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>实际上，对于Java来说，可以&lt;strong>把JMM看作是Java定义的并发编程相关的一组规范&lt;/strong>，除了抽象了线程和主内存之间的关系之外，还规定了&lt;strong>从Java源代码到CPU可执行指令的转化过程&lt;/strong>要遵守哪些和并发相关的原则和规范，主要目的是为了&lt;strong>简化多线程编程&lt;/strong>，&lt;strong>增强程序可移植性&lt;/strong>。&lt;/p>
&lt;p>为什么要遵守这些并发相关的原则和规范呢？因为在&lt;strong>并发编程&lt;/strong>下，CPU多级缓存和指令重排这类设计会导致程序运行出问题，比如&lt;strong>指令重排&lt;/strong>，为此JMM抽象了&lt;strong>happens-before&lt;/strong>原则&lt;/p>
&lt;blockquote>
&lt;p>JMM 说白了就是定义了一些规范来解决这些问题，开发者可以利用这些规范更方便地开发多线程程序。对于 Java 开发者说，你&lt;strong>不需要了解底层原理&lt;/strong>，&lt;strong>直接使用并发相关的一些关键字&lt;/strong>和&lt;strong>类&lt;/strong>（比如 &lt;code>volatile&lt;/code>、&lt;code>synchronized&lt;/code>、各种 &lt;code>Lock&lt;/code>）即可开发出并发安全的程序。&lt;/p></description></item><item><title>并发03</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0303lyconcurrent-03/</link><pubDate>Mon, 07 Nov 2022 16:04:33 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0303lyconcurrent-03/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="线程池">
 线程池
 &lt;a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>为什么要使用线程池&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>池化技术：&lt;strong>线程池&lt;/strong>、&lt;strong>数据库连接池&lt;/strong>、&lt;strong>Http连接池&lt;/strong>&lt;/li>
&lt;li>池化技术思想意义：为了减少每次&lt;strong>获取资源&lt;/strong>的&lt;strong>消耗&lt;/strong>，提高对&lt;strong>资源的利用率&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>线程池提供了&lt;strong>限制&lt;/strong>和&lt;strong>管理&lt;/strong> &lt;strong>资源&lt;/strong>(包括执行一个任务)的方式&lt;/li>
&lt;li>每个线程池还维护&lt;strong>基本统计信息&lt;/strong>，例如&lt;strong>已完成&lt;/strong>任务的数量&lt;/li>
&lt;li>好处：
&lt;ol>
&lt;li>&lt;strong>降低资源消耗&lt;/strong> &lt;strong>重复利用已创建线程&lt;/strong>降低&lt;strong>线程创建&lt;/strong>和&lt;strong>销毁&lt;/strong>造成的消耗&lt;/li>
&lt;li>提高响应速度 任务到达时，任务可以&lt;strong>不需等到线程创建&lt;/strong>就能继续执行&lt;/li>
&lt;li>提高线程的&lt;strong>可管理性&lt;/strong> 线程是稀缺资源，如果无限制创建，不仅&lt;strong>消耗系统资源&lt;/strong>，还会&lt;strong>降低系统的稳定性&lt;/strong>，使用线程池统一&lt;strong>管理分配&lt;/strong>、&lt;strong>调优&lt;/strong>和&lt;strong>监控&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>实现Runnable接口和Callable接口的区别&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//Callable的用法 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TestLy&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果加上volatile,就能保证可见性，线程1 才能停止&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> stop &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;&lt;span style="color:#75715e">//对象属性&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> InterruptedException, ExecutionException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FutureTask&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> futureTask&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> FutureTask&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> Callable&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">call&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;等3s再把结果给你&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TimeUnit.&lt;span style="color:#a6e22e">SECONDS&lt;/span>.&lt;span style="color:#a6e22e">sleep&lt;/span>(3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(futureTask).&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String s &lt;span style="color:#f92672">=&lt;/span> futureTask.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;3s后获取到了结果&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(&lt;span style="color:#66d9ef">new&lt;/span> Runnable() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;abc&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }).&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">等3s再把结果给你
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">3s后获取到了结果hello world
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">abc
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>Runnable接口不会返回结果或抛出检查异常，Callable接口可以&lt;/p></description></item><item><title>锁升级</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly03122lylock_escalation/</link><pubDate>Sun, 06 Nov 2022 12:31:02 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly03122lylock_escalation/</guid><description>&lt;blockquote>
&lt;p>以下内容均转自 &lt;a href="https://www.cnblogs.com/wuqinglong/p/9945618.html">https://www.cnblogs.com/wuqinglong/p/9945618.html&lt;/a>，部分疑惑参考自另一作者 &lt;a href="https://github.com/farmerjohngit/myblog/issues/12">https://github.com/farmerjohngit/myblog/issues/12&lt;/a> ，感谢原作者。&lt;/p>
&lt;p>【&lt;strong>目前还是存有部分疑虑（轻量级锁那块）&lt;/strong>，可能需要详细看源码才能释疑】&lt;/p>
&lt;/blockquote>
&lt;h2 id="概述">
 概述
 &lt;a class="anchor" href="#%e6%a6%82%e8%bf%b0">#&lt;/a>
&lt;/h2>
&lt;p>传统的synchronized为重量级锁（&lt;strong>使用操作系统互斥量（&lt;code>mutex&lt;/code>）来实现的传统锁&lt;/strong>），但是随着JavaSE1.6对synchronized优化后，部分情况下他就没有那么重了。本文介绍了JavaSE1.6为了减少获得锁和释放锁带来的性能消耗而引入的&lt;strong>偏向锁&lt;/strong>和&lt;strong>轻量级锁&lt;/strong>，以及&lt;strong>锁结构&lt;/strong>、及&lt;strong>锁升级&lt;/strong>过程&lt;/p>
&lt;h2 id="实现同步的基础">
 实现同步的基础
 &lt;a class="anchor" href="#%e5%ae%9e%e7%8e%b0%e5%90%8c%e6%ad%a5%e7%9a%84%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;p>Java中&lt;strong>每个对象&lt;/strong>都可以&lt;strong>作为锁&lt;/strong>，具体变现形式&lt;/p>
&lt;ol>
&lt;li>对于&lt;strong>普通同步&lt;/strong>方法，锁是&lt;strong>当前实例对象&lt;/strong>&lt;/li>
&lt;li>对于&lt;strong>静态同步&lt;/strong>方法，锁是&lt;strong>当前类的Class对象&lt;/strong>&lt;/li>
&lt;li>对于&lt;strong>同步方法块&lt;/strong>，锁是&lt;strong>synchronized括号里配置的对象&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>一个线程试图访问同步代码块时，必须&lt;strong>获取锁&lt;/strong>；在&lt;strong>退出&lt;/strong>或者&lt;strong>抛出异常&lt;/strong>时，必须&lt;strong>释放锁&lt;/strong>&lt;/p>
&lt;h2 id="实现方式">
 实现方式
 &lt;a class="anchor" href="#%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>JVM 基于&lt;strong>进入和退出 Monitor 对象&lt;/strong>来实现&lt;strong>方法同步&lt;/strong>和&lt;strong>代码块同步&lt;/strong>，但是两者的&lt;strong>实现细节不一样&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>代码块同步&lt;/strong>：通过使用 &lt;strong>monitorenter&lt;/strong> 和 &lt;strong>monitorexit&lt;/strong> 指令实现的&lt;/li>
&lt;li>同步方法：&lt;strong>ACC_SYNCHRONIZED&lt;/strong> 修饰&lt;/li>
&lt;/ol>
&lt;p>monitorenter 指令是在&lt;strong>编译后插入到同步代码块的开始位置&lt;/strong>，而 monitorexit 指令是在&lt;strong>编译后插入到同步代码块的结束处或异常处&lt;/strong>&lt;/p>
&lt;p>对于同步方法，&lt;strong>进入方法前&lt;/strong>添加一个 monitorenter 指令，&lt;strong>退出方法后&lt;/strong>添加一个 monitorexit 指令。&lt;/p>
&lt;p>demo：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Demo&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f1&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (Demo.&lt;span style="color:#a6e22e">class&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">synchronized&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f2&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译之后的字节码（使用 javap )&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f1&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> descriptor: ()V
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flags: ACC_PUBLIC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Code:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#f92672">=&lt;/span>2, locals&lt;span style="color:#f92672">=&lt;/span>3, args_size&lt;span style="color:#f92672">=&lt;/span>1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0: ldc &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>2 &lt;span style="color:#75715e">// class me/snail/base/Demo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 2: dup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3: astore_1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 4: monitorenter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 5: getstatic &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>3 &lt;span style="color:#75715e">// Field java/lang/System.out:Ljava/io/PrintStream;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 8: ldc &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>4 &lt;span style="color:#75715e">// String Hello World.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 10: invokevirtual &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>5 &lt;span style="color:#75715e">// Method java/io/PrintStream.println:(Ljava/lang/String;)V&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 13: aload_1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 14: monitorexit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 15: &lt;span style="color:#66d9ef">goto&lt;/span> 23
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 18: astore_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 19: aload_1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 20: monitorexit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 21: aload_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 22: athrow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 23: &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Exception table:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> from to target type
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 5 15 18 any
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 18 21 18 any
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LineNumberTable:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> line 6: 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> line 7: 5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> line 8: 13
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> line 9: 23
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StackMapTable: number_of_entries &lt;span style="color:#f92672">=&lt;/span> 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frame_type &lt;span style="color:#f92672">=&lt;/span> 255 &lt;span style="color:#75715e">/* full_frame */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_delta &lt;span style="color:#f92672">=&lt;/span> 18
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> locals &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">me&lt;/span>&lt;span style="color:#f92672">/&lt;/span>snail&lt;span style="color:#f92672">/&lt;/span>base&lt;span style="color:#f92672">/&lt;/span>Demo, &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">java&lt;/span>&lt;span style="color:#f92672">/&lt;/span>lang&lt;span style="color:#f92672">/&lt;/span>Object &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">java&lt;/span>&lt;span style="color:#f92672">/&lt;/span>lang&lt;span style="color:#f92672">/&lt;/span>Throwable &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frame_type &lt;span style="color:#f92672">=&lt;/span> 250 &lt;span style="color:#75715e">/* chop */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_delta &lt;span style="color:#f92672">=&lt;/span> 4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">synchronized&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f2&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> descriptor: ()V
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flags: ACC_PUBLIC, ACC_SYNCHRONIZED
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Code:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#f92672">=&lt;/span>2, locals&lt;span style="color:#f92672">=&lt;/span>1, args_size&lt;span style="color:#f92672">=&lt;/span>1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0: getstatic &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>3 &lt;span style="color:#75715e">// Field java/lang/System.out:Ljava/io/PrintStream;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3: ldc &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>4 &lt;span style="color:#75715e">// String Hello World.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 5: invokevirtual &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>5 &lt;span style="color:#75715e">// Method java/io/PrintStream.println:(Ljava/lang/String;)V&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 8: &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LineNumberTable:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> line 12: 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> line 13: 8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>先说 &lt;strong>f1() 方法&lt;/strong>，发现其中&lt;strong>一个 monitorenter 对应了两个 monitorexit&lt;/strong>，这是不对的。&lt;strong>但是&lt;/strong>仔细看 #15: goto 语句，直接跳转到了 #23: return 处，再看 #22: athrow 语句发现，原来&lt;strong>第二个 monitorexit&lt;/strong> 是&lt;strong>保证同步代码块抛出异常&lt;/strong>时锁能&lt;strong>得到正确的释放&lt;/strong>而存在的，这就理解了。&lt;/p></description></item><item><title>(该文弃用)锁升级</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated2/</link><pubDate>Thu, 03 Nov 2022 11:08:59 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated2/</guid><description>&lt;p>本文主要讲解synchronized原理和偏向锁、轻量级锁、重量级锁的升级过程，基本都转自&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/MariaOzawa/article/details/107665689">https://blog.csdn.net/MariaOzawa/article/details/107665689&lt;/a> 原作者:&lt;a href="https://blog.csdn.net/MariaOzawa">MariaOzawa&lt;/a>&lt;/p>
&lt;h2 id="简介">
 简介
 &lt;a class="anchor" href="#%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>为什么需要锁&lt;br>
并发编程中，多个线程访问同一共享资源时，必须考虑如何维护数据的&lt;strong>原子性&lt;/strong>&lt;/li>
&lt;li>历史
&lt;ul>
&lt;li>JDK1.5之前，Java依靠Synchronized关键字实现锁功能，Synchronized是&lt;strong>Jvm&lt;/strong>实现的&lt;strong>内置锁&lt;/strong>，锁的&lt;strong>获取与释放&lt;/strong>由JVM隐式实现&lt;/li>
&lt;li>JDK1.5，并发包新增Lock接口实现锁功能，提供同步功能，使用时&lt;strong>显式获取和释放锁&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>区别
&lt;ul>
&lt;li>Lock同步锁基于Java实现，Synchronized基于底层操作系统的MutexLock实现
&lt;code>/ˈmjuːtɛks/ &lt;/code>，每次&lt;strong>获取和释放锁&lt;/strong>都会带来&lt;strong>用户态和内核态的切换&lt;/strong>，从而&lt;strong>增加系统性能开销&lt;/strong>，性能糟糕，又称&lt;strong>重量级锁&lt;/strong>&lt;/li>
&lt;li>JDK1.6之后，对&lt;strong>Synchronized同步锁&lt;/strong>做了&lt;strong>充分优化&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="synchronized同步锁实现原理">
 Synchronized同步锁实现原理
 &lt;a class="anchor" href="#synchronized%e5%90%8c%e6%ad%a5%e9%94%81%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Synchronized实现同步锁的两种方式：修饰方法；修饰方法块&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 关键字在实例方法上，锁为当前实例&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">synchronized&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">method1&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// code&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 关键字在代码块上，锁为括号里面的对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">method2&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object o &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Object();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (o) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// code&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里使用编译&amp;ndash;及javap 打印字节文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>javac -encoding UTF-8 SyncTest.java //先运行编译class文件命令
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>javap -v SyncTest.class //再通过javap打印出字节文件
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果如下，Synchronized修饰代码块时，由monitorenter和monitorexist指令实现同步。进入monitorenter指令后线程持有Monitor对象；退出monitorenter指令后，线程释放该Monitor对象&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">method2&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> descriptor: ()V
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flags: ACC_PUBLIC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Code:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#f92672">=&lt;/span>2, locals&lt;span style="color:#f92672">=&lt;/span>4, args_size&lt;span style="color:#f92672">=&lt;/span>1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 0: &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>2 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 3: dup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 4: invokespecial &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>1 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 7: astore_1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 8: aload_1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 9: dup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 10: astore_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 11: monitorenter &lt;span style="color:#75715e">//monitorenter 指令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 12: aload_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 13: monitorexit &lt;span style="color:#75715e">//monitorexit 指令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 14: &lt;span style="color:#66d9ef">goto&lt;/span> 22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 17: astore_3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 18: aload_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 19: monitorexit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 20: aload_3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 21: athrow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 22: &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Exception table:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> from to target type
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 12 14 17 any
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 17 20 17 any
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LineNumberTable:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> line 18: 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> line 19: 8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> line 21: 12
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> line 22: 22
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StackMapTable: number_of_entries &lt;span style="color:#f92672">=&lt;/span> 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frame_type &lt;span style="color:#f92672">=&lt;/span> 255 &lt;span style="color:#75715e">/* full_frame */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_delta &lt;span style="color:#f92672">=&lt;/span> 17
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> locals &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">com&lt;/span>&lt;span style="color:#f92672">/&lt;/span>demo&lt;span style="color:#f92672">/&lt;/span>io&lt;span style="color:#f92672">/&lt;/span>SyncTest, &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">java&lt;/span>&lt;span style="color:#f92672">/&lt;/span>lang&lt;span style="color:#f92672">/&lt;/span>Object, &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">java&lt;/span>&lt;span style="color:#f92672">/&lt;/span>lang&lt;span style="color:#f92672">/&lt;/span>Object &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">java&lt;/span>&lt;span style="color:#f92672">/&lt;/span>lang&lt;span style="color:#f92672">/&lt;/span>Throwable &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frame_type &lt;span style="color:#f92672">=&lt;/span> 250 &lt;span style="color:#75715e">/* chop */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset_delta &lt;span style="color:#f92672">=&lt;/span> 4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果Synchronized修饰同步方法，代替monitorenter和monitorexit的是 &lt;code>ACC_SYNCHRONIZED&lt;/code>标志，即：JVM使用该访问标志区分方法是否为同步方法。方法调用时，调用指令检查是否设置ACC_SYNCHRONIZED标志，如有，则执行线程&lt;strong>先持有&lt;/strong>该Monitor对象，再执行该方法；&lt;strong>运行期间&lt;/strong>，&lt;strong>其他线程无法获取到该Monitor&lt;/strong>对象；方法&lt;strong>执行完成&lt;/strong>后，&lt;strong>释放该Monitor&lt;/strong>对象
javap -v xx.class 字节文件查看&lt;/p></description></item><item><title>post</title><link>https://lwmfjc.github.io/zh/docs/problem/Linux/20221101/</link><pubDate>Tue, 01 Nov 2022 09:05:57 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/Linux/20221101/</guid><description>&lt;ul>
&lt;li>
&lt;p>在安装可视化的时候，出现&lt;code>需要libmysqlclient.so.18()(64bit)&lt;/code>解决方案&lt;/p>
&lt;blockquote>
&lt;p>将mysql卸载即可
&lt;a href="http://wenfeifei.com/art/detail/yGM1BG4">http://wenfeifei.com/art/detail/yGM1BG4&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul></description></item><item><title>(该文弃用)锁升级</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated/</link><pubDate>Mon, 31 Oct 2022 11:08:59 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/lock_escalation_deprecated/</guid><description>&lt;h2 id="简介">
 简介
 &lt;a class="anchor" href="#%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;p>无锁 =&amp;gt; 偏向锁 =&amp;gt; 轻量锁 =&amp;gt; 重量锁&lt;/p>
&lt;p>复习Class类锁和实例对象锁，说明Class类锁和实例对象锁不是同一把锁，互相不影响&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> InterruptedException { 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object object&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> Object();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(()&lt;span style="color:#f92672">-&amp;gt;&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (Customer.&lt;span style="color:#a6e22e">class&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(Thread.&lt;span style="color:#a6e22e">currentThread&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>()&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Object.class类锁&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TimeUnit.&lt;span style="color:#a6e22e">SECONDS&lt;/span>.&lt;span style="color:#a6e22e">sleep&lt;/span>(5);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e.&lt;span style="color:#a6e22e">printStackTrace&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(Thread.&lt;span style="color:#a6e22e">currentThread&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>()&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34;结束并释放锁&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },&lt;span style="color:#e6db74">&amp;#34;线程1&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//保证线程1已经获得类锁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TimeUnit.&lt;span style="color:#a6e22e">SECONDS&lt;/span>.&lt;span style="color:#a6e22e">sleep&lt;/span>(2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e.&lt;span style="color:#a6e22e">printStackTrace&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(()&lt;span style="color:#f92672">-&amp;gt;&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (object){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(Thread.&lt;span style="color:#a6e22e">currentThread&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>()&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34;获得object实例对象锁&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(Thread.&lt;span style="color:#a6e22e">currentThread&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>()&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34;结束并释放锁&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },&lt;span style="color:#e6db74">&amp;#34;线程2&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 输出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">线程1Object.class类锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">线程2获得object实例对象锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">线程2结束并释放锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">线程1结束并释放锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>总结图 , 00 , 01 , 10 ，没有11&lt;/p></description></item><item><title>对象内存布局和对象头</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly03121lyobject-concurrent/</link><pubDate>Sun, 30 Oct 2022 16:56:16 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly03121lyobject-concurrent/</guid><description>&lt;h2 id="对象布局">
 对象布局
 &lt;a class="anchor" href="#%e5%af%b9%e8%b1%a1%e5%b8%83%e5%b1%80">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>heap&lt;/strong> （&lt;strong>where&lt;/strong>）: &lt;strong>new (eden ,s0 ,s1) ,old, metaspace&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对象的构成元素（what）
HotSpot虚拟机里，对象在&lt;strong>堆内存中的存储布局&lt;/strong>分为三个部分
&lt;img src="img/ly-20241212141948626.png" alt="ly-20241212141948626" />&lt;/p>
&lt;ul>
&lt;li>对象头（Header）
&lt;ul>
&lt;li>&lt;strong>对象标记 MarkWord&lt;/strong>&lt;/li>
&lt;li>&lt;strong>类元信息&lt;/strong>（类型指针 Class Pointer，指向方法区的地址）&lt;/li>
&lt;li>对象头多大 &lt;strong>length&lt;/strong>（数组才有）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>实例数据（Instance Data）&lt;/li>
&lt;li>对其填充（Padding，保证整个对象大小，是8个字节的倍数）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="对象头">
 对象头
 &lt;a class="anchor" href="#%e5%af%b9%e8%b1%a1%e5%a4%b4">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>对象标记&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>Object o= new Object(); //new一个对象，占内存多少&lt;/li>
&lt;li>o.hashCode() //hashCode存在对象哪个地方&lt;/li>
&lt;li>synchronized(o){ } //对象被锁了多少次（可重入锁）&lt;/li>
&lt;li>System.gc(); //躲过了几次gc（次数）&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>上面这些，&lt;strong>哈希码&lt;/strong>、&lt;strong>gc标记&lt;/strong>、&lt;strong>gc次数&lt;/strong>、&lt;strong>同步锁标记&lt;/strong>、&lt;strong>偏向锁持有者&lt;/strong>，都保存在&lt;strong>对象标记&lt;/strong>里面
&lt;img src="img/ly-20241212141948895.png" alt="ly-20241212141948895" />&lt;/p>
&lt;ol>
&lt;li>如果在64位系统中，对象头中，**mark word（对象标记）**占用8个字节（64位）；**class pointer（类元信息）**占用8个字节，总共16字节（忽略压缩指针）&lt;/li>
&lt;li>无锁的时候，
&lt;img src="img/ly-20241212141949076.png" alt="ly-20241212141949076" />&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>类型指针
注意下图，指向方法区中（模板）的地址
&lt;img src="img/ly-20241212141949249.png" alt="ly-20241212141949249" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="实例数据和对齐填充">
 实例数据和对齐填充
 &lt;a class="anchor" href="#%e5%ae%9e%e4%be%8b%e6%95%b0%e6%8d%ae%e5%92%8c%e5%af%b9%e9%bd%90%e5%a1%ab%e5%85%85">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>实例数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用来存放类的属性（Filed）数据信息，包括父类的属性信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对齐填充&lt;/p>
&lt;/li>
&lt;li>
&lt;p>填充到长度为8字节，因为虚拟机要求&lt;strong>对象起始地址必须是8字节的整数倍&lt;/strong>（对齐填充不一定存在）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>示例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Customer&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> id;&lt;span style="color:#75715e">//4字节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> flag&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">false&lt;/span>; &lt;span style="color:#75715e">//1字节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//Customer customer=new Customer();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//该对象大小：对象头（对象标记8+类型指针8）+实例数据（4+1）=21字节 ===&amp;gt; 为了对齐填充，则为24字节&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="源码查看">
 源码查看
 &lt;a class="anchor" href="#%e6%ba%90%e7%a0%81%e6%9f%a5%e7%9c%8b">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="img/ly-20241212141949397.png" alt="ly-20241212141949397" />&lt;/p></description></item><item><title>并发02</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0302lyconcurrent-02/</link><pubDate>Fri, 28 Oct 2022 14:15:06 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0302lyconcurrent-02/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="jmmjavamemorymodel">
 JMM（JavaMemoryModel)
 &lt;a class="anchor" href="#jmmjavamemorymodel">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://lwmfjc.github.io/2022/11/21/review/java_guide/java/concurrent/jmm">详见-知识点&lt;/a>
&lt;img src="img/ly-20241212141935173.png" alt="Java内存模型" />&lt;/p>
&lt;h2 id="volatile关键字">
 volatile关键字
 &lt;a class="anchor" href="#volatile%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>保证变量可见性&lt;/p>
&lt;ul>
&lt;li>
&lt;p>使用volatile关键字保证变量可见性，如果将变量声明为volatile则&lt;strong>指示JVM该变量是共享且不稳定&lt;/strong>的，每次使用它都到&lt;strong>主存&lt;/strong>中读取&lt;br>
&lt;img src="img/ly-20241212141935463.png" alt="ly-20241212141935463" />&lt;/p>
&lt;blockquote>
&lt;p>volatile关键字并非Java语言特有，在C语言里也有，它最原始的意义就是&lt;strong>禁用CPU缓存&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>volatile关键字只能&lt;strong>保证数据可见性&lt;/strong>，&lt;strong>不能保证数据原子性&lt;/strong>。&lt;strong>synchronized&lt;/strong>关键字两者都能保证&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不可见的例子&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> com.concurrent; 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.util.concurrent.TimeUnit;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TestLy&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果加上volatile,就能保证可见性，线程1 才能停止&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> stop &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;&lt;span style="color:#75715e">//对象属性&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> InterruptedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TestLy atomicTest &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> TestLy();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>atomicTest.&lt;span style="color:#a6e22e">stop&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//这里不能加System.out.println ,因为这个方法内部用了synchronized修饰,会导致获取主内存的值，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//就没法展示效果了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*System.out.println(&amp;#34;1还没有停止&amp;#34;);*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(Thread.&lt;span style="color:#a6e22e">currentThread&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>()&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34;停止了&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },&lt;span style="color:#e6db74">&amp;#34;线程1&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TimeUnit.&lt;span style="color:#a6e22e">SECONDS&lt;/span>.&lt;span style="color:#a6e22e">sleep&lt;/span>(1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e.&lt;span style="color:#a6e22e">printStackTrace&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> atomicTest.&lt;span style="color:#a6e22e">stop&lt;/span>&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(Thread.&lt;span style="color:#a6e22e">currentThread&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>()&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34;让线程1停止&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },&lt;span style="color:#e6db74">&amp;#34;线程2&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#66d9ef">true&lt;/span>){}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>如何禁止指令重排
使用&lt;strong>volatile&lt;/strong>关键字，除了可以保证&lt;strong>变量的可见性&lt;/strong>，还能&lt;strong>防止JVM指令重排&lt;/strong>。当我们对这个变量进行读写操作的时候，-会通过插入特定的&lt;strong>内存屏障&lt;/strong>来禁止指令重排&lt;/p></description></item><item><title>基础</title><link>https://lwmfjc.github.io/zh/docs/technology/springCloud/bl_zhouyang/base/</link><pubDate>Thu, 27 Oct 2022 16:46:21 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/springCloud/bl_zhouyang/base/</guid><description>&lt;ul>
&lt;li>springCloud涉及到的技术有哪些
&lt;img src="img/ly-20241212142201709.png" alt="ly-20241212142201709" />&lt;/li>
&lt;li>约定 &amp;gt; 配置 &amp;gt; 编码&lt;/li>
&lt;li>&lt;/li>
&lt;/ul></description></item><item><title>并发01</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0301lyconcurrent-01/</link><pubDate>Wed, 26 Oct 2022 16:46:32 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Concurrent/ly0301lyconcurrent-01/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>什么是进程和线程&lt;/p>
&lt;ul>
&lt;li>
&lt;p>进程：是程序的&lt;strong>一次执行过程&lt;/strong>，是系统运行程序的&lt;strong>基本单位&lt;/strong>
系统运行一个程序，即一个进程从&lt;strong>创建、运行到消亡&lt;/strong>的过程&lt;/p>
&lt;ul>
&lt;li>
&lt;p>启动main函数则启动了一个JVM进程，&lt;strong>main函数所在线程&lt;/strong>为进程中的一个线程，也称&lt;strong>主线程&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以下为一个个的进程&lt;br>
&lt;img src="img/ly-20241212141934200.png" alt="ly-20241212141934200" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>查看java进程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>jps -l
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">32&lt;/span> org.jetbrains.jps.cmdline.Launcher
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10084&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">16244&lt;/span> com.Test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">17400&lt;/span> sun.tools.jps.Jps
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>杀死进程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span> taskkill /f /pid &lt;span style="color:#ae81ff">16244&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>何为线程&lt;/p>
&lt;ul>
&lt;li>
&lt;p>线程，比进程更小的执行单位&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同类的&lt;strong>多个线程&lt;/strong>共享&lt;strong>进程&lt;/strong>的&lt;strong>堆和方法区&lt;/strong>资源，但每个线程有自己的&lt;strong>程序计数器、虚拟机栈、本地方法栈&lt;/strong>，又被称为&lt;strong>轻量级进程&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Java天生就是多线程程序，如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MultiThread&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 获取 Java 线程管理 MXBean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	ThreadMXBean threadMXBean &lt;span style="color:#f92672">=&lt;/span> ManagementFactory.&lt;span style="color:#a6e22e">getThreadMXBean&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		ThreadInfo&lt;span style="color:#f92672">[]&lt;/span> threadInfos &lt;span style="color:#f92672">=&lt;/span> threadMXBean.&lt;span style="color:#a6e22e">dumpAllThreads&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 遍历线程信息，仅打印线程 ID 和线程名称信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">for&lt;/span> (ThreadInfo threadInfo : threadInfos) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> threadInfo.&lt;span style="color:#a6e22e">getThreadId&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;] &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> threadInfo.&lt;span style="color:#a6e22e">getThreadName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>5&lt;span style="color:#f92672">]&lt;/span> Attach Listener &lt;span style="color:#75715e">//添加事件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>4&lt;span style="color:#f92672">]&lt;/span> Signal Dispatcher &lt;span style="color:#75715e">// 分发处理给 JVM 信号的线程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>3&lt;span style="color:#f92672">]&lt;/span> Finalizer &lt;span style="color:#75715e">//调用对象 finalize 方法的线程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]&lt;/span> Reference Handler &lt;span style="color:#75715e">//清除 reference 线程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> main &lt;span style="color:#75715e">//main 线程,程序入口&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，一个Java程序的运行，是main线程和多个其他线程同时运行&lt;/p></description></item><item><title>io模型</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/IO/ly0203lyio-model/</link><pubDate>Wed, 26 Oct 2022 14:17:58 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/IO/ly0203lyio-model/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/360878783">https://zhuanlan.zhihu.com/p/360878783&lt;/a> IO多路复用讲解，这是一个与系统底层有关的知识点，需要一些操作系统调用代码才知道IO多路复用省的时间。&lt;/p>
&lt;/blockquote>
&lt;h2 id="io">
 I/O
 &lt;a class="anchor" href="#io">#&lt;/a>
&lt;/h2>
&lt;h3 id="何为io">
 何为I/O
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%baio">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>I/O(&lt;strong>Input/Output&lt;/strong>)，即&lt;strong>输入/输出&lt;/strong>
从计算机结构的角度来解读一下I/O，根据冯诺依曼结构，计算机结构分为5大部分：&lt;strong>运算器&lt;/strong>、&lt;strong>控制器&lt;/strong>、&lt;strong>存储器&lt;/strong>、&lt;strong>输入设备&lt;/strong>、&lt;strong>输出设备&lt;/strong>
&lt;img src="img/ly-20241212141951603.png" alt="ly-20241212141951603" />
其中，输入设备：键盘；输出设备：显示器
网卡、硬盘既属于输入设备也属于输出设备&lt;/li>
&lt;li>输入设备&lt;strong>向计算机输入（内存）&lt;strong>数据，输出设备&lt;/strong>接收计算机（内存）&lt;strong>输出的数据，即I/O描述了&lt;/strong>计算机系统&lt;/strong>与&lt;strong>外部设备&lt;/strong>之间&lt;strong>通信&lt;/strong>的过程&lt;/li>
&lt;li>从应用程序的角度解读I/O
&lt;ul>
&lt;li>为了保证系统稳定性和安全性，一个进程的地址空间划分为&lt;strong>用户空间User space&lt;/strong>和&lt;strong>内核空间Kernel space&lt;/strong> &lt;code>kernel	英[ˈkɜːnl]&lt;/code>&lt;/li>
&lt;li>平常运行的应用程序都运行在用户空间，只有&lt;strong>内核空间才能进行系统态级别&lt;/strong>的&lt;strong>资源&lt;/strong>有关操作&amp;mdash;&lt;strong>文件管理、进程通信、内存管理&lt;/strong>&lt;/li>
&lt;li>如果要进行IO操作，就得依赖&lt;strong>内核空间&lt;/strong>的能力，&lt;strong>用户空间的程序&lt;/strong>不能直接访问&lt;strong>内核空间&lt;/strong>&lt;/li>
&lt;li>用户进程要想执行IO操作，必须通过&lt;strong>系统调用&lt;/strong>来间接访问内核空间&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于&lt;strong>磁盘IO（读写文件）&lt;strong>和&lt;/strong>网络IO（网络请求和响应）&lt;/strong>，从应用程序视角来看，&lt;strong>应用程序&lt;/strong>对操作系统的&lt;strong>内核&lt;/strong>发起&lt;strong>IO调用（系统调用）&lt;/strong>，操作系统负责的&lt;strong>内核&lt;/strong>执行具体&lt;strong>IO&lt;/strong>操作
&lt;ul>
&lt;li>&lt;strong>应用程序只是发起了IO操作调用&lt;/strong>，而具体的IO执行则由&lt;strong>操作系统内核&lt;/strong>完成&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>应用程序&lt;strong>发起I/O后&lt;/strong>，经历两个步骤
&lt;ul>
&lt;li>内核&lt;strong>等待I/O设备&lt;/strong>准备好数据&lt;/li>
&lt;li>内核将数据&lt;strong>从内核空间&lt;/strong>拷贝&lt;strong>到用户空间&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="有哪些常见的io模型">
 有哪些常见的IO模型
 &lt;a class="anchor" href="#%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84io%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h3>
&lt;p>UNIX系统下，包括5种：&lt;strong>同步阻塞I/O&lt;/strong>，&lt;strong>同步非阻塞I/O&lt;/strong>，&lt;strong>I/O多路复用&lt;/strong>、&lt;strong>信号驱动I/O&lt;/strong>和&lt;strong>异步I/O&lt;/strong>&lt;/p>
&lt;h2 id="java中3中常见io模型">
 Java中3中常见I/O模型
 &lt;a class="anchor" href="#java%e4%b8%ad3%e4%b8%ad%e5%b8%b8%e8%a7%81io%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="bio-blocking-io-">
 BIO (Blocking I/O )
 &lt;a class="anchor" href="#bio-blocking-io-">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>应用程序发起read调用后，会一直阻塞，&lt;strong>直到内核把数据拷贝到用户空间&lt;/strong>
&lt;img src="img/ly-20241212141951883.png" alt="ly-20241212141951883" />&lt;/li>
&lt;/ul>
&lt;h3 id="nio-non-blockingnew-io">
 NIO (Non-blocking/New I/O)
 &lt;a class="anchor" href="#nio-non-blockingnew-io">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>对于java.nio包，提供了&lt;strong>Channel&lt;/strong>、&lt;strong>Selector&lt;/strong>、&lt;strong>Buffer&lt;/strong>等抽象概念，对于&lt;strong>高负载高并发&lt;/strong>，应使用NIO&lt;/li>
&lt;li>NIO是I/O多路复用模型，属于&lt;strong>同步非阻塞IO&lt;/strong>模型
&lt;ul>
&lt;li>
&lt;p>&lt;strong>一般的同步非阻塞 IO 模型&lt;/strong>中，应用程序会&lt;strong>一直发起 read&lt;/strong> 调用。&lt;br>
等待&lt;strong>数据从内核空间拷贝到用户空&lt;/strong>间的这段时间里，&lt;strong>线程依然是阻塞&lt;/strong>的**，**直到在内核把数据拷贝到用户空间。&lt;/p>
&lt;p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。&lt;/p>
&lt;p>但是，这种 IO 模型同样存在问题：&lt;strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。&lt;/strong>&lt;/p></description></item><item><title>io设计模式</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/IO/ly0202lyio-design-patterns/</link><pubDate>Mon, 24 Oct 2022 23:40:53 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/IO/ly0202lyio-design-patterns/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="装饰器模式">
 装饰器模式
 &lt;a class="anchor" href="#%e8%a3%85%e9%a5%b0%e5%99%a8%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>​	类图：&lt;br>
​	&lt;img src="img/ly-20241212141951023.png" alt="ly-20241212141951023" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>装饰器，Decorator，装饰器模式可以在&lt;strong>不改变原有对象的情况下拓展其功能&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>★装饰器模式，&lt;strong>通过组合替代继承&lt;/strong>来扩展原始类功能，在一些&lt;strong>继承关系较复杂&lt;/strong>的场景（IO这一场景各种类的继承关系就比较复杂）下更加实用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于字节流，&lt;strong>FilterInputStream（对应输入流）和FilterOutputStream（对应输出流）&lt;strong>是&lt;/strong>装饰器模式的核心&lt;/strong>，分别用于&lt;strong>增强（继承了）InputStream&lt;/strong>和&lt;strong>OutputStream&lt;/strong>子类对象的功能
Filter （过滤的意思），中间（Closeable）下面这两条&lt;strong>虚线代表实现&lt;/strong>；最下面的&lt;strong>实线代表继承&lt;/strong>
&lt;img src="img/ly-20241212141951298.png" alt="ly-20241212141951298" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其中BufferedInputStream（字节缓冲输入流）、DataInputStream等等都是FilterInputStream的子类，对应的BufferedOutputStream和DataOutputStream都是FilterOutputStream的子类&lt;/p>
&lt;/li>
&lt;li>
&lt;p>例子，使用BufferedInputStream（字节缓冲输入流）来增强FileInputStream功能&lt;/p>
&lt;ul>
&lt;li>
&lt;p>BufferedInputStream源码（构造函数）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> DEFAULT_BUFFER_SIZE &lt;span style="color:#f92672">=&lt;/span> 8192;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">BufferedInputStream&lt;/span>(InputStream in) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>(in, DEFAULT_BUFFER_SIZE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">BufferedInputStream&lt;/span>(InputStream in, &lt;span style="color:#66d9ef">int&lt;/span> size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">super&lt;/span>(in);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (size &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;Buffer size &amp;lt;= 0&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>size&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> (BufferedInputStream bis &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedInputStream(&lt;span style="color:#66d9ef">new&lt;/span> FileInputStream(&lt;span style="color:#e6db74">&amp;#34;input.txt&amp;#34;&lt;/span>))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> content;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> skip &lt;span style="color:#f92672">=&lt;/span> bis.&lt;span style="color:#a6e22e">skip&lt;/span>(2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((content &lt;span style="color:#f92672">=&lt;/span> bis.&lt;span style="color:#a6e22e">read&lt;/span>()) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>((&lt;span style="color:#66d9ef">char&lt;/span>) content);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">catch&lt;/span> (IOException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e.&lt;span style="color:#a6e22e">printStackTrace&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ZipInputStream和ZipOutputStream还可以用来增强BufferedInputStream和BufferedOutputStream的能力&lt;/p></description></item><item><title>io基础</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/IO/ly0201lyio/</link><pubDate>Sun, 23 Oct 2022 12:21:12 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/IO/ly0201lyio/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="简介">
 简介
 &lt;a class="anchor" href="#%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>IO，即Input/Output，输入和输出，输入就是&lt;strong>数据输入到计算机内存&lt;/strong>；输出则是&lt;strong>输出到外部存储&lt;/strong>（如&lt;strong>数据库&lt;/strong>、&lt;strong>文件&lt;/strong>、&lt;strong>远程主机&lt;/strong>）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据数据处理方式，又分为&lt;strong>字节流&lt;/strong>和&lt;strong>字符流&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基类&lt;/p>
&lt;ul>
&lt;li>字节输入流 &lt;strong>InputStream&lt;/strong>，字符输入流 &lt;strong>Reader&lt;/strong>&lt;/li>
&lt;li>字节输出流 &lt;strong>OutputStream&lt;/strong>, 字符输出流 &lt;strong>Writer&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="字节流">
 字节流
 &lt;a class="anchor" href="#%e5%ad%97%e8%8a%82%e6%b5%81">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>字节输入流 InputStream
InputStream用于从源头（通常是文件）&lt;strong>读取数据（字节信息）到内存&lt;/strong>中，java.io.InputStream抽象类是&lt;strong>所有字节输入流的父类&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>常用方法&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;code>read()&lt;/code> ：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 &lt;code>-1&lt;/code> ，表示文件结束。&lt;/li>
&lt;li>&lt;code>read(byte b[ ])&lt;/code> : 从输入流中读取一些字节存储到数组 &lt;code>b&lt;/code> 中。如果数组 &lt;code>b&lt;/code> 的长度为零，则不读取。如果没有可用字节读取，返回 &lt;code>-1&lt;/code>。如果有可用字节读取，则最多读取的字节数最多等于 &lt;code>b.length&lt;/code> ， 返回读取的字节数。这个方法等价于 &lt;code>read(b, 0, b.length)&lt;/code>。&lt;/li>
&lt;li>&lt;code>read(byte b[], int off, int len)&lt;/code> ：在&lt;code>read(byte b[ ])&lt;/code> 方法的基础上增加了 &lt;code>off&lt;/code> 参数（偏移量）和 &lt;code>len&lt;/code> 参数（要读取的最大字节数）。&lt;/li>
&lt;li>&lt;code>skip(long n)&lt;/code> ：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。&lt;/li>
&lt;li>&lt;code>available()&lt;/code> ：返回输入流中可以读取的字节数。&lt;/li>
&lt;li>&lt;code>close()&lt;/code> ：关闭输入流释放相关的系统资源。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>Java9 新增了多个实用方法&lt;/p></description></item><item><title>ConcurrentHashMap源码</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Collection/ly0105lysource-code-concurrenthashmap/</link><pubDate>Sat, 22 Oct 2022 18:26:52 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Collection/ly0105lysource-code-concurrenthashmap/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="总结">
 总结
 &lt;a class="anchor" href="#%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h2>
&lt;p>Java7 中 &lt;code>ConcurrentHashMap&lt;/code> 使用的&lt;strong>分段锁&lt;/strong>，也就是&lt;strong>每一个 Segment&lt;/strong> 上同时只有一个线程可以操作，&lt;strong>每一个 &lt;code>Segment&lt;/code>&lt;/strong> 都是一个类似 &lt;code>HashMap&lt;/code> 数组的结构，每一个HashMap&lt;strong>可以扩容&lt;/strong>，它的&lt;strong>冲突会转化为链表&lt;/strong>。但是 &lt;code>Segment&lt;/code> 的个数一但初始化就不能改变。&lt;/p>
&lt;p>Java8 中的 &lt;code>ConcurrentHashMap&lt;/code> 使用的 &lt;code>Synchronized&lt;/code> 锁加 CAS 的机制。结构也由 Java7 中的 &lt;strong>&lt;code>Segment&lt;/code> 数组 + &lt;code>HashEntry&lt;/code> 数组 + 链表&lt;/strong> 进化成了 &lt;strong>Node 数组 + 链表 / 红黑树&lt;/strong>，&lt;strong>Node 是类似于一个 HashEntry 的结构&lt;/strong>。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。&lt;/p>
&lt;h2 id="源码-略过">
 源码 （略过）
 &lt;a class="anchor" href="#%e6%ba%90%e7%a0%81-%e7%95%a5%e8%bf%87">#&lt;/a>
&lt;/h2>
&lt;h2 id="concurrenthashmap17">
 ConcurrentHashMap1.7
 &lt;a class="anchor" href="#concurrenthashmap17">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>存储结构
&lt;ul>
&lt;li>Segment数组（该数组用来加锁，每个数组元素是一个HashEntry数组（该数组可能包含链表）&lt;/li>
&lt;li>如图，ConcurrentHashMap由多个Segment组合，每一个Segment是一个类似HashMap的结构，每一个HashMap内部可以扩容，但是Segment个数初始化后不能改变，默认16个（即默认支持16个线程并发）
&lt;img src="img/ly-20241212141930985.png" alt="ly-20241212141930985" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="concurrenthashmap18">
 ConcurrentHashMap1.8
 &lt;a class="anchor" href="#concurrenthashmap18">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>存储结构
&lt;img src="img/ly-20241212141931187.png" alt="ly-20241212141931187" />
可以发现 Java8 的 ConcurrentHashMap 相对于 Java7 来说变化比较大，不再是之前的 &lt;strong>Segment 数组 + HashEntry 数组 + 链表&lt;/strong>，而是 &lt;strong>Node 数组 + 链表 / 红黑树&lt;/strong>。当冲突链表达到一定长度时，链表会转换成红黑树。&lt;/p></description></item><item><title>HashMap源码</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Collection/ly0106lysource-code-hashmap/</link><pubDate>Fri, 21 Oct 2022 15:30:09 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Collection/ly0106lysource-code-hashmap/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="hashmap简介">
 HashMap简介
 &lt;a class="anchor" href="#hashmap%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>HashMap用来存放&lt;strong>键值对&lt;/strong>，基于哈希表的Map接口实现，是&lt;strong>非线程安全&lt;/strong>的&lt;/li>
&lt;li>可以存储null的key和value，但null作为键只能有一个&lt;/li>
&lt;li>JDK8之前，HashMap由&lt;strong>数组和链表&lt;/strong>组成，链表是为了解决哈希冲突而存在；JDK8之后，当链表大于阈值（默认8），则会选择&lt;strong>转为红黑树&lt;/strong>（当数组长度大于64则进行转换，否则只是扩容），以&lt;strong>减少搜索时间&lt;/strong>&lt;/li>
&lt;li>HashMap默认初始化大小为16，每次&lt;strong>扩容为原容量2倍&lt;/strong>，且总是使用2的幂作为哈希表的大小&lt;/li>
&lt;/ul>
&lt;h2 id="底层数据结构分析">
 底层数据结构分析
 &lt;a class="anchor" href="#%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>JDK8之前，HashMap底层是&lt;strong>数组和链表&lt;/strong>，即&lt;strong>链表散列&lt;/strong>；通过key的hashCode，经过扰动函数，获得hash值，然后再通过(n-1) &amp;amp; hash 判断当前元素存放位置（n指的是数组长度），如果当前位置存在元素，就判断元素与要存入的元素的hash值以及key是否相同，相同则覆盖，否则通过&lt;strong>拉链法&lt;/strong>解决&lt;br>
&lt;img src="img/ly-20241212141931350.png" alt="ly-20241212141931350" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>扰动函数，即hash(Object key)方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//JDK1.8 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">hash&lt;/span>(Object key) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> h;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// key.hashCode()：返回散列值也就是hashcode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ^ ：按位异或&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// &amp;gt;&amp;gt;&amp;gt;:无符号右移，忽略符号位，空位都以0补齐&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (key &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> 0 : (h &lt;span style="color:#f92672">=&lt;/span> key.&lt;span style="color:#a6e22e">hashCode&lt;/span>()) &lt;span style="color:#f92672">^&lt;/span> (h &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 16);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>JDK1.7&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//JDK1.7 , 则扰动了4次，性能较差&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">hash&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> h) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// This function ensures that hashCodes that differ only by&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// constant multiples at each bit position have a bounded&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// number of collisions (approximately 8 at default load factor).&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> h &lt;span style="color:#f92672">^=&lt;/span> (h &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 20) &lt;span style="color:#f92672">^&lt;/span> (h &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 12);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> h &lt;span style="color:#f92672">^&lt;/span> (h &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 7) &lt;span style="color:#f92672">^&lt;/span> (h &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 4);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>JDK1.8之后，当链表长度大于阈值（默认为 8）时，会首先调用 &lt;code>treeifyBin()&lt;/code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有&lt;strong>当数组长度大于或者等于 64&lt;/strong> 的情况下，才会执行转换红黑树操作，以减少搜索时间。&lt;strong>否则，就是只是执行 &lt;code>resize()&lt;/code> 方法对数组扩容&lt;/strong>。相关源码这里就不贴了，重点关注 &lt;code>treeifyBin()&lt;/code>方法即可！&lt;/p></description></item><item><title>ArrayList源码</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Collection/ly0104lysource-code-ArrayList/</link><pubDate>Thu, 20 Oct 2022 17:01:47 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Collection/ly0104lysource-code-ArrayList/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="简介">
 简介
 &lt;a class="anchor" href="#%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>底层是数组队列，相当于&lt;strong>动态数组&lt;/strong>，能&lt;strong>动态增长&lt;/strong>，可以在添加大量元素前先使用&lt;strong>ensureCapacity&lt;/strong>来增加ArrayList容量，&lt;strong>减少递增式再分配的数量&lt;/strong>
源码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ArrayList&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> AbstractList&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">implements&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span>, RandomAccess, Cloneable, java.&lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Serializable&lt;/span>{ }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>Random Access，标志接口，表明这个接口的List集合支持&lt;strong>快速随机访问&lt;/strong>，这里是指可&lt;strong>通过元素序号快速访问&lt;/strong>&lt;/li>
&lt;li>实现Cloneable接口，能&lt;strong>被克隆&lt;/strong>&lt;/li>
&lt;li>实现java.io.Serializable，&lt;strong>支持序列化&lt;/strong>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>ArrayList和Vector区别&lt;/p>
&lt;ul>
&lt;li>ArrayList和Vector都是List的实现类，Vector出现的比较早，底层都是Object[] 存储&lt;/li>
&lt;li>ArrayList线程不安全（适合频繁查找，线程不安全 ）&lt;/li>
&lt;li>Vector 线程安全的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ArrayList与LinkedList区别&lt;/p>
&lt;ul>
&lt;li>
&lt;p>都是&lt;strong>不同步&lt;/strong>的，即不保证线程安全&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ArrayList底层为Object数组；LinkedList底层使用&lt;strong>双向链表数据结构&lt;/strong>(1.6之前为循环链表，1.7取消了循环)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>插入和删除是否受元素位置影响&lt;/p>
&lt;ul>
&lt;li>
&lt;p>ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置影响[ 默认增加到末尾，O(1) ; 在指定位置，则O(n) , 要往后移动]&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LinkedList采用链表存储，所以对于add(E e)方法，还是O(1)；如果是在指定位置插入和删除，则为O(n) 因为需要遍历将指针移动到指定位置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//LinkedList默认添加到最后&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(E e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> linkLast(e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>LinkedList&lt;strong>不支持高效随机元素访问&lt;/strong>，而ArrayList支持（通过get(int index))&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内存空间占用
ArrayList的空间浪费主要体现在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费在，每个元素都需要比ArrayList更多空间（要存放直接前驱和直接后继以及(当前)数据)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3-扩容机制分析--jdk8-">
 3. 扩容机制分析 ( JDK8 )
 &lt;a class="anchor" href="#3-%e6%89%a9%e5%ae%b9%e6%9c%ba%e5%88%b6%e5%88%86%e6%9e%90--jdk8-">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>ArrayList的构造函数&lt;/p>
&lt;ul>
&lt;li>三种方式初始化，构造方法源码&lt;/li>
&lt;li>空参，指定大小，指定集合 （如果集合类型非Object[].class，则使用Arrays.copyOf转为Object[].class)&lt;/li>
&lt;li>以无参构造方式创建ArrayList时，实际上初始化赋值的是空数组；当真正操作时才分配容量，即添加第一个元素时扩容为10&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 默认初始容量大小
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> DEFAULT_CAPACITY &lt;span style="color:#f92672">=&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Object&lt;span style="color:#f92672">[]&lt;/span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA &lt;span style="color:#f92672">=&lt;/span> {};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *默认构造函数，使用初始容量10构造一个空列表(无参数构造)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">ArrayList&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">elementData&lt;/span> &lt;span style="color:#f92672">=&lt;/span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 带初始容量参数的构造函数。（用户自己指定容量）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">ArrayList&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> initialCapacity) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (initialCapacity &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {&lt;span style="color:#75715e">//初始容量大于0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//创建initialCapacity大小的数组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">elementData&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Object&lt;span style="color:#f92672">[&lt;/span>initialCapacity&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (initialCapacity &lt;span style="color:#f92672">==&lt;/span> 0) {&lt;span style="color:#75715e">//初始容量等于0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//创建空数组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">elementData&lt;/span> &lt;span style="color:#f92672">=&lt;/span> EMPTY_ELEMENTDATA;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {&lt;span style="color:#75715e">//初始容量小于0，抛出异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;Illegal Capacity: &amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialCapacity);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *如果指定的集合为null，throws NullPointerException。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">ArrayList&lt;/span>(Collection&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> E&lt;span style="color:#f92672">&amp;gt;&lt;/span> c) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elementData &lt;span style="color:#f92672">=&lt;/span> c.&lt;span style="color:#a6e22e">toArray&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((size &lt;span style="color:#f92672">=&lt;/span> elementData.&lt;span style="color:#a6e22e">length&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// c.toArray might (incorrectly) not return Object[] (see 6260652)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (elementData.&lt;span style="color:#a6e22e">getClass&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> Object&lt;span style="color:#f92672">[]&lt;/span>.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elementData &lt;span style="color:#f92672">=&lt;/span> Arrays.&lt;span style="color:#a6e22e">copyOf&lt;/span>(elementData, size, Object&lt;span style="color:#f92672">[]&lt;/span>.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// replace with empty array.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">elementData&lt;/span> &lt;span style="color:#f92672">=&lt;/span> EMPTY_ELEMENTDATA;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>以无参构造参数函数为例
&lt;strong>先看下面的 add()方法扩容&lt;/strong>&lt;/p></description></item><item><title>集合使用注意事项</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Collection/ly0103lycollections-precautions-for-use/</link><pubDate>Wed, 19 Oct 2022 17:26:07 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Collection/ly0103lycollections-precautions-for-use/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="集合判空">
 集合判空
 &lt;a class="anchor" href="#%e9%9b%86%e5%90%88%e5%88%a4%e7%a9%ba">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>//阿里巴巴开发手册&lt;/p>
&lt;p>&lt;strong>判断所有集合内部的元素是否为空，使用 &lt;code>isEmpty()&lt;/code> 方法，而不是 &lt;code>size()==0&lt;/code> 的方式。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>isEmpty()可读性更好，且&lt;strong>绝大部分情况下时间复杂度为O(1)&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有例外：ConcurrentHashMap的size()和isEmpty() 时间复杂度均不是O(1)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">size&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> sumCount();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ((n &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0L) &lt;span style="color:#f92672">?&lt;/span> 0 :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (n &lt;span style="color:#f92672">&amp;gt;&lt;/span> (&lt;span style="color:#66d9ef">long&lt;/span>)Integer.&lt;span style="color:#a6e22e">MAX_VALUE&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> Integer.&lt;span style="color:#a6e22e">MAX_VALUE&lt;/span> :
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#66d9ef">int&lt;/span>)n);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">sumCount&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CounterCell&lt;span style="color:#f92672">[]&lt;/span> as &lt;span style="color:#f92672">=&lt;/span> counterCells; CounterCell a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> baseCount;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (as &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> as.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((a &lt;span style="color:#f92672">=&lt;/span> as&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum &lt;span style="color:#f92672">+=&lt;/span> a.&lt;span style="color:#a6e22e">value&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isEmpty&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sumCount() &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 0L; &lt;span style="color:#75715e">// ignore transient negative values&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="集合转map">
 集合转Map
 &lt;a class="anchor" href="#%e9%9b%86%e5%90%88%e8%bd%acmap">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>//阿里巴巴开发手册&lt;/p></description></item><item><title>集合_2</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Collection/ly0102lycollection_2/</link><pubDate>Tue, 18 Oct 2022 08:54:49 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Collection/ly0102lycollection_2/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="map">
 Map
 &lt;a class="anchor" href="#map">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>HashMap和Hashtable的区别&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>HashMap是非线程安全&lt;/strong>的，&lt;strong>Hashtable是线程安全&lt;/strong>的，因为Hashtable内部方法&lt;strong>都经过synchronized&lt;/strong>修饰（不过要保证线程安全&lt;strong>一般用ConcurrentHashMap&lt;/strong>）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于加了synchronized修饰，HashTable&lt;strong>效率&lt;/strong>没有HashMap高&lt;/p>
&lt;/li>
&lt;li>
&lt;p>HashMap&lt;strong>可以存储null的key和value&lt;/strong>，但&lt;strong>null作为键&lt;/strong>只能有一个**；&lt;strong>HashTable&lt;/strong>不允许有null键和null值**&lt;/p>
&lt;/li>
&lt;li>
&lt;p>初始容量及每次扩容&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Hashtable默认初始大小11&lt;/strong>，之后&lt;strong>扩容为2n+1&lt;/strong>;HashMap&lt;strong>初始大小16&lt;/strong>，之后&lt;strong>扩容变为原来的2倍&lt;/strong>&lt;/li>
&lt;li>如果指定初始大小，HashTable直接使用初始大小&lt;br>
而&lt;code>HashMap&lt;/code> 会将其&lt;strong>扩充为 2 的幂次方&lt;/strong>大小（&lt;code>HashMap&lt;/code> 中的**&lt;code>tableSizeFor()&lt;/code>**方法保证，下面给出了源代码）。也就是说 &lt;code>HashMap&lt;/code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>底层数据结构&lt;/p>
&lt;ul>
&lt;li>JDK1.8之后&lt;strong>HashMap&lt;/strong>解决哈希冲突时，当&lt;strong>链表大于阈值（默认8）&lt;strong>时，将链表&lt;/strong>转为红黑树&lt;/strong>（转换&lt;strong>前&lt;/strong>判断，如果当前&lt;strong>数组长度小于64&lt;/strong>，则&lt;strong>先进行数组扩容&lt;/strong>，而不转成红黑树），以减少搜索时间。&lt;/li>
&lt;li>Hashtable&lt;strong>没有&lt;/strong>上面的机制&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">HashMap 中带有初始容量的构造函数：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">HashMap&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> initialCapacity, &lt;span style="color:#66d9ef">float&lt;/span> loadFactor) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (initialCapacity &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;Illegal initial capacity: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialCapacity);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (initialCapacity &lt;span style="color:#f92672">&amp;gt;&lt;/span> MAXIMUM_CAPACITY)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initialCapacity &lt;span style="color:#f92672">=&lt;/span> MAXIMUM_CAPACITY;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (loadFactor &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 0 &lt;span style="color:#f92672">||&lt;/span> Float.&lt;span style="color:#a6e22e">isNaN&lt;/span>(loadFactor))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;Illegal load factor: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadFactor);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">loadFactor&lt;/span> &lt;span style="color:#f92672">=&lt;/span> loadFactor;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">threshold&lt;/span> &lt;span style="color:#f92672">=&lt;/span> tableSizeFor(initialCapacity);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">HashMap&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> initialCapacity) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>(initialCapacity, DEFAULT_LOAD_FACTOR);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*下面这个方法保证了 HashMap 总是使用 2 的幂作为哈希表的大小。*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Returns a power of two size for the given target capacity.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">tableSizeFor&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> cap) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> cap &lt;span style="color:#f92672">-&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">|=&lt;/span> n &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">|=&lt;/span> n &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">|=&lt;/span> n &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 4;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">|=&lt;/span> n &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 8;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n &lt;span style="color:#f92672">|=&lt;/span> n &lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> 16;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (n &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0) &lt;span style="color:#f92672">?&lt;/span> 1 : (n &lt;span style="color:#f92672">&amp;gt;=&lt;/span> MAXIMUM_CAPACITY) &lt;span style="color:#f92672">?&lt;/span> MAXIMUM_CAPACITY : n &lt;span style="color:#f92672">+&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>HashMap和hashSet区别&lt;/p></description></item><item><title>集合_1</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Collection/ly0101lycollection_1/</link><pubDate>Mon, 17 Oct 2022 08:55:24 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Collection/ly0101lycollection_1/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="集合包括collection和mapcollection-存放单一元素map-存放键值对">
 集合包括&lt;code>Collection&lt;/code>和&lt;code>Map&lt;/code>，Collection 存放单一元素。Map 存放键值对
 &lt;a class="anchor" href="#%e9%9b%86%e5%90%88%e5%8c%85%e6%8b%accollection%e5%92%8cmapcollection-%e5%ad%98%e6%94%be%e5%8d%95%e4%b8%80%e5%85%83%e7%b4%a0map-%e5%ad%98%e6%94%be%e9%94%ae%e5%80%bc%e5%af%b9">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212141928129.png" alt="ly-20241212141928129" />&lt;/p>
&lt;h2 id="listsetqueuemap区别">
 List，Set，Queue，Map区别
 &lt;a class="anchor" href="#listsetqueuemap%e5%8c%ba%e5%88%ab">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;code>List&lt;/code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。&lt;/li>
&lt;li>&lt;code>Set&lt;/code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。&lt;/li>
&lt;li>&lt;code>Queue&lt;/code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。&lt;/li>
&lt;li>&lt;code>Map&lt;/code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，&amp;ldquo;x&amp;rdquo; 代表 key，&amp;ldquo;y&amp;rdquo; 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。&lt;/li>
&lt;/ul>
&lt;h2 id="各种集合框架--底层数据结构">
 各种集合框架&amp;ndash;底层数据结构
 &lt;a class="anchor" href="#%e5%90%84%e7%a7%8d%e9%9b%86%e5%90%88%e6%a1%86%e6%9e%b6--%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>List
&lt;ul>
&lt;li>ArrayList、Vector &amp;mdash;-&amp;gt; Object[] 数组&lt;/li>
&lt;li>LinkedList 双向链表 (jdk 1.6 之前为循环链表, 1.7 取消了循环)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Set
&lt;ul>
&lt;li>HashSet （无序，唯一），且&lt;strong>基于HashMap&lt;/strong>&lt;/li>
&lt;li>LinkedHashSet 是HashSet的子类，基于&lt;strong>LinkedHashMap&lt;/strong>
(LinkedHashMap内部基于HashMap实现)&lt;/li>
&lt;li>TreeSet(有序，唯一) ：红黑树（自平衡的排序二叉树）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Queue (队列)
&lt;ul>
&lt;li>PriorityQueue：Object[] 数组来实现二叉堆&lt;/li>
&lt;li>ArrayQueue：Object[] 数组+ 双指针&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Map
&lt;ul>
&lt;li>
&lt;p>&lt;code>HashMap&lt;/code>： JDK1.8 之前 &lt;code>HashMap&lt;/code> 由&lt;strong>数组+链表&lt;/strong>组成的，数组是 &lt;code>HashMap&lt;/code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当&lt;strong>链表长度大于阈值&lt;/strong>（&lt;strong>默认为 8&lt;/strong>）（将&lt;strong>链表转换成红黑树前&lt;/strong>会判断，如果&lt;strong>当前数组的长度小于 64&lt;/strong>，那么会选择&lt;strong>先进行数组扩容&lt;/strong>，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间&lt;/p></description></item><item><title>语法糖</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0011lysyntactic_sugar/</link><pubDate>Wed, 12 Oct 2022 17:36:26 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0011lysyntactic_sugar/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="简介">
 简介
 &lt;a class="anchor" href="#%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;p>语法糖（Syntactic Sugar）也称&lt;strong>糖衣语法&lt;/strong>，指的是在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用，简而言之，让程序更加&lt;strong>简洁&lt;/strong>，有更高的&lt;strong>可读性&lt;/strong>&lt;/p>
&lt;h2 id="java中有哪些语法糖">
 Java中有哪些语法糖
 &lt;a class="anchor" href="#java%e4%b8%ad%e6%9c%89%e5%93%aa%e4%ba%9b%e8%af%ad%e6%b3%95%e7%b3%96">#&lt;/a>
&lt;/h2>
&lt;p>Java&lt;strong>虚拟机并不支持&lt;/strong>这些语法糖，这些语法糖在&lt;strong>编译阶段就会被还原成简单的基础语法&lt;/strong>结构，这个过程就是解语法糖&lt;/p>
&lt;ul>
&lt;li>&lt;code>javac&lt;/code>命令可以将后缀为&lt;code>.java&lt;/code>的源文件编译为后缀名为&lt;code>.class&lt;/code>的&lt;strong>可以运行于Java虚拟机的字节码&lt;/strong>。其中，&lt;code>com.sun.tools.javac.main.JavaCompiler&lt;/code>的源码中，&lt;code>compile()&lt;/code>中有一个步骤就是调用&lt;code>desugar()&lt;/code>，这个方法就是负责&lt;strong>解语法糖&lt;/strong>的实现的&lt;/li>
&lt;li>Java中的语法糖，包括 &lt;strong>泛型&lt;/strong>、&lt;strong>变长参数&lt;/strong>、&lt;strong>条件编译&lt;/strong>、&lt;strong>自动拆装箱&lt;/strong>、&lt;strong>内部类&lt;/strong>等&lt;/li>
&lt;/ul>
&lt;h3 id="switch支持string与枚举">
 switch支持String与枚举
 &lt;a class="anchor" href="#switch%e6%94%af%e6%8c%81string%e4%b8%8e%e6%9e%9a%e4%b8%be">#&lt;/a>
&lt;/h3>
&lt;p>switch本身原本只支持基本类型，如int、char&lt;br>
&lt;img src="img/ly-20241212141927344.png" alt="ly-20241212141927344" />&lt;/p>
&lt;p>int是比较数值，而char则是比较其ascii码，所以其实对于编译器来说，都是int类型(整型)，比如&lt;code>byte&lt;/code>。&lt;code>short&lt;/code>，&lt;code>char&lt;/code>(ackii 码是整型)以及&lt;code>int&lt;/code>。
&lt;img src="img/ly-20241212141927646.png" alt="ly-20241212141927646" />&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141927801.png" alt="ly-20241212141927801" />
而对于enum类型，&lt;br>
&lt;img src="img/ly-20241212141927960.png" alt="ly-20241212141927960" />&lt;/p>
&lt;p>对于switch中使用String，则：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">switchDemoString&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String str &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (str) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//反编译之后&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">switchDemoString&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">switchDemoString&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String args&lt;span style="color:#f92672">[]&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String str &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String s;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span>((s &lt;span style="color:#f92672">=&lt;/span> str).&lt;span style="color:#a6e22e">hashCode&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> 99162322:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(s.&lt;span style="color:#a6e22e">equals&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> 113318802:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(s.&lt;span style="color:#a6e22e">equals&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>即switch判断是通过**equals()&lt;strong>和&lt;/strong>hashCode()**方法来实现的&lt;/p></description></item><item><title>java_spi</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0010lyjava_spi/</link><pubDate>Wed, 12 Oct 2022 10:12:52 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0010lyjava_spi/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h3 id="简介">
 简介
 &lt;a class="anchor" href="#%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h3>
&lt;p>为了实现在&lt;strong>模块装配&lt;/strong>的时候&lt;strong>不用再程序里面动态指明&lt;/strong>，这就需要一种&lt;strong>服务发现&lt;/strong>机制。JavaSPI就是提供了这样的一个机制：&lt;strong>为某个接口寻找服务实现&lt;/strong>的机制。有点类似IoC的思想，将装配的控制权交到了程序之外&lt;/p>
&lt;h3 id="spi介绍">
 SPI介绍
 &lt;a class="anchor" href="#spi%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h3>
&lt;p>SPI，ServiceProviderInterface
使用SPI：Spring框架、数据库加载驱动、日志接口、以及Dubbo的扩展实现&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141926732.png" alt="ly-20241212141926732" />&lt;/p>
&lt;p>感觉下面这个图不太对，被调用方应该
一般&lt;strong>模块之间&lt;/strong>都是&lt;strong>通过接口&lt;/strong>进行通讯，&lt;/p>
&lt;blockquote>
&lt;p>当&lt;strong>实现方&lt;/strong>提供了&lt;strong>接口和实现&lt;/strong>，我们可以通过&lt;strong>调用实现方的接口&lt;/strong>从而拥有&lt;strong>实现方给我们提供的能力&lt;/strong>，这就是 API ，这种&lt;strong>接口和实现&lt;/strong>都是放在实现方的。&lt;/p>
&lt;p>当接口存在于&lt;strong>调用方&lt;/strong>这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。[&lt;strong>可以理解成业务方，或者说使用方。它使用了这个接口，而且制定了接口规范，但是具体实现，由被调用方实现&lt;/strong>]&lt;/p>
&lt;p>我的理解：被调用方（提供接口的人），调用方（使用接口的人），但是其实这里只把调用方&amp;ndash;&amp;gt;使用接口的人 这个关系是对的。&lt;/p>
&lt;p>也就是说，正常情况下由被调用方自己提供接口和实现，即API。而现在，由调用方（这里的调用方其实可以理解成上面的被调用方），提供了接口还使用了接口，而由被调用方进行接口实现&lt;/p>
&lt;/blockquote>
&lt;h3 id="实战演示">
 实战演示
 &lt;a class="anchor" href="#%e5%ae%9e%e6%88%98%e6%bc%94%e7%a4%ba">#&lt;/a>
&lt;/h3>
&lt;p>SLF4J只是一个日志门面（接口），但是SLF4J的具体实现可以有多种，如：Logback/Log4j/Log4j2等等&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141927020.png" alt="ly-20241212141927020" />&lt;/p>
&lt;h4 id="简易版本">
 简易版本
 &lt;a class="anchor" href="#%e7%ae%80%e6%98%93%e7%89%88%e6%9c%ac">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>ServiceProviderInterface&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目录结构&lt;/p>
&lt;pre tabindex="0">&lt;code>│ service-provider-interface.iml
│
├─.idea
│ │ .gitignore
│ │ misc.xml
│ │ modules.xml
│ └─ workspace.xml
│
└─src
 └─edu
 └─jiangxuan
 └─up
 └─spi
 Logger.java
 LoggerService.java
 Main.class
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>Logger接口，即SPI 服务提供者接口，后面的服务提供者要针对这个接口进行实现&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> edu.jiangxuan.up.spi;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Logger&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">info&lt;/span>(String msg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">debug&lt;/span>(String msg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>LoggerService类，主要是为服务使用者（调用方）提供特定功能，这个类是实现JavaSPI机制的关键所在&lt;/p></description></item><item><title>unsafe类</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0009lyunsafe_class/</link><pubDate>Mon, 10 Oct 2022 17:10:27 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0009lyunsafe_class/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>sun.misc.Unsafe&lt;/code>&lt;/p>
&lt;p>提供&lt;strong>执行低级别&lt;/strong>、&lt;strong>不安全操作&lt;/strong>的方法，如&lt;strong>直接访问系统内存资源&lt;/strong>、&lt;strong>自主管理内存资源&lt;/strong>等，效率快，但由于有了操作内存空间的能力，会&lt;strong>增加指针问题风险&lt;/strong>。且这些功能的实现依赖于本地方法，Java代码中只是声明方法头，具体实现规则交给本地代码
&lt;img src="img/ly-20241212141925562.png" alt="ly-20241212141925562" />&lt;/p>
&lt;h3 id="为什么要使用本地方法">
 为什么要使用本地方法
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>需要用到Java中不具备的&lt;strong>依赖于操作系统&lt;/strong>的特性，跨平台的同时要实现&lt;strong>对底层控制&lt;/strong>&lt;/li>
&lt;li>对于其他语言已经完成的现成功能，可以使用Java调用&lt;/li>
&lt;li>对&lt;strong>时间敏感/性能要求&lt;/strong>非常高，有必要使用更为底层的语言&lt;/li>
&lt;/ul>
&lt;p>对于同一本地方法，不同的操作系统可能通过不同的方式来实现的&lt;/p>
&lt;h3 id="unsafe创建">
 Unsafe创建
 &lt;a class="anchor" href="#unsafe%e5%88%9b%e5%bb%ba">#&lt;/a>
&lt;/h3>
&lt;p>sun.misc.Unsafe部分源码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Unsafe&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 单例对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Unsafe theUnsafe;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">Unsafe&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//Sensitive : 敏感的 英[ˈsensətɪv]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@CallerSensitive&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Unsafe &lt;span style="color:#a6e22e">getUnsafe&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class var0 &lt;span style="color:#f92672">=&lt;/span> Reflection.&lt;span style="color:#a6e22e">getCallerClass&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 仅在引导类加载器`BootstrapClassLoader`加载时才合法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>VM.&lt;span style="color:#a6e22e">isSystemDomainLoader&lt;/span>(var0.&lt;span style="color:#a6e22e">getClassLoader&lt;/span>())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SecurityException(&lt;span style="color:#e6db74">&amp;#34;Unsafe&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> theUnsafe;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>会先判断当前类是否由&lt;strong>Bootstrap classloader&lt;/strong>加载。即只有&lt;strong>启动类加载器加载的类&lt;/strong>才能够调用Unsafe类中的方法&lt;/p>
&lt;p>如何使用&lt;code>Unsafe&lt;/code>这个类&lt;/p>
&lt;ol>
&lt;li>
&lt;p>利用反射获得Unsafe类中已经实例化完成的单例对象&lt;code>theUnsafe&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Unsafe &lt;span style="color:#a6e22e">reflectGetUnsafe&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Field field &lt;span style="color:#f92672">=&lt;/span> Unsafe.&lt;span style="color:#a6e22e">class&lt;/span>.&lt;span style="color:#a6e22e">getDeclaredField&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;theUnsafe&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> field.&lt;span style="color:#a6e22e">setAccessible&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (Unsafe) field.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">error&lt;/span>(e.&lt;span style="color:#a6e22e">getMessage&lt;/span>(), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>通过Java命令行命令&lt;code>-Xbootclasspath/a&lt;/code>把&lt;strong>调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中&lt;/strong>，使得&lt;strong>A被引导类加载器加载&lt;/strong>&lt;/p></description></item><item><title>big_decimal</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0008lybig_decimal/</link><pubDate>Mon, 10 Oct 2022 14:56:26 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0008lybig_decimal/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h3 id="精度的丢失">
 精度的丢失
 &lt;a class="anchor" href="#%e7%b2%be%e5%ba%a6%e7%9a%84%e4%b8%a2%e5%a4%b1">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> 2.&lt;span style="color:#a6e22e">0f&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1.&lt;span style="color:#a6e22e">9f&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> 1.&lt;span style="color:#a6e22e">8f&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1.&lt;span style="color:#a6e22e">7f&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a);&lt;span style="color:#75715e">// 0.100000024&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(b);&lt;span style="color:#75715e">// 0.099999905&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a &lt;span style="color:#f92672">==&lt;/span> b);&lt;span style="color:#75715e">// false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>为什么会有精度丢失的风险&lt;/p>
&lt;p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是&lt;strong>二进制&lt;/strong>的，而且计算机在&lt;strong>表示一个数字时，宽度是有限&lt;/strong>的，无限循环的小数存储在计算机时，&lt;strong>只能被截断&lt;/strong>，所以就会导致&lt;strong>小数精度发生损失&lt;/strong>的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示&lt;/p>
&lt;/blockquote>
&lt;p>使用BigDecimal来定义浮点数的值，然后再进行浮点数的运算操作即可&lt;/p>
&lt;h3 id="bigdecimal常见方法">
 BigDecimal常见方法
 &lt;a class="anchor" href="#bigdecimal%e5%b8%b8%e8%a7%81%e6%96%b9%e6%b3%95">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>我们在使用 &lt;code>BigDecimal&lt;/code> 时，为了防止精度丢失，推荐使用它的&lt;code>BigDecimal(String val)&lt;/code>构造方法或者 &lt;code>BigDecimal.valueOf(double val)&lt;/code> 静态方法来创建对象&lt;/p>
&lt;/li>
&lt;li>
&lt;p>加减乘除&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>BigDecimal a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BigDecimal(&lt;span style="color:#e6db74">&amp;#34;1.0&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>BigDecimal b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BigDecimal(&lt;span style="color:#e6db74">&amp;#34;0.9&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a.&lt;span style="color:#a6e22e">add&lt;/span>(b));&lt;span style="color:#75715e">// 1.9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a.&lt;span style="color:#a6e22e">subtract&lt;/span>(b));&lt;span style="color:#75715e">// 0.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a.&lt;span style="color:#a6e22e">multiply&lt;/span>(b));&lt;span style="color:#75715e">// 0.90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a.&lt;span style="color:#a6e22e">divide&lt;/span>(b));&lt;span style="color:#75715e">// 无法除尽，抛出 ArithmeticException 异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a.&lt;span style="color:#a6e22e">divide&lt;/span>(b, 2, RoundingMode.&lt;span style="color:#a6e22e">HALF_UP&lt;/span>));&lt;span style="color:#75715e">// 1.11&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用divide方法的时候，尽量使用3个参数版本（roundingMode.oldMode)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>保留规则&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> RoundingMode {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2.5 -&amp;gt; 3 , 1.6 -&amp;gt; 2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// -1.6 -&amp;gt; -2 , -2.5 -&amp;gt; -3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			 UP(BigDecimal.&lt;span style="color:#a6e22e">ROUND_UP&lt;/span>), &lt;span style="color:#75715e">//数轴上靠近哪个取哪个&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2.5 -&amp;gt; 2 , 1.6 -&amp;gt; 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// -1.6 -&amp;gt; -1 , -2.5 -&amp;gt; -2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			 DOWN(BigDecimal.&lt;span style="color:#a6e22e">ROUND_DOWN&lt;/span>), &lt;span style="color:#75715e">//数轴上离哪个远取哪个&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			 &lt;span style="color:#75715e">// 2.5 -&amp;gt; 3 , 1.6 -&amp;gt; 2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// -1.6 -&amp;gt; -1 , -2.5 -&amp;gt; -2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			 CEILING(BigDecimal.&lt;span style="color:#a6e22e">ROUND_CEILING&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			 &lt;span style="color:#75715e">// 2.5 -&amp;gt; 2 , 1.6 -&amp;gt; 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// -1.6 -&amp;gt; -2 , -2.5 -&amp;gt; -3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			 FLOOR(BigDecimal.&lt;span style="color:#a6e22e">ROUND_FLOOR&lt;/span>), &lt;span style="color:#75715e">////数轴上 正数：远离哪个取哪个 负数：靠近哪个取哪个&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 	&lt;span style="color:#75715e">// 2.5 -&amp;gt; 3 , 1.6 -&amp;gt; 2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// -1.6 -&amp;gt; -2 , -2.5 -&amp;gt; -3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			 HALF_UP(BigDecimal.&lt;span style="color:#a6e22e">ROUND_HALF_UP&lt;/span>),&lt;span style="color:#75715e">// 数轴上 正数：靠近哪个取哪个 负数：远离哪个取哪个&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//......&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>大小比较&lt;br>
使用compareTo&lt;/p></description></item><item><title>Java代理模式</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0007lyproxy_pattern/</link><pubDate>Mon, 10 Oct 2022 14:30:02 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0007lyproxy_pattern/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h3 id="代理模式">
 代理模式
 &lt;a class="anchor" href="#%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h3>
&lt;p>使用代理对象来代替对真实对象的访问，就可以在&lt;strong>不修改原目标对象的前提下提供额外的功能操作&lt;/strong>，&lt;strong>扩展目标对象的功能&lt;/strong>，即在目标对象的&lt;strong>某个方法执行前后可以增加一些自定义的操作&lt;/strong>&lt;/p>
&lt;h3 id="静态代理">
 静态代理
 &lt;a class="anchor" href="#%e9%9d%99%e6%80%81%e4%bb%a3%e7%90%86">#&lt;/a>
&lt;/h3>
&lt;blockquote>
&lt;p>&lt;strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（*后面会具体演示代码*），非常不灵活（*比如接口一旦新增加方法，目标对象和代理对象都要进行修改*）且麻烦(*需要对每个目标类都单独写一个代理类*）。&lt;/strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。&lt;/p>
&lt;p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， &lt;strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>定义一个接口及其实现类；&lt;/li>
&lt;li>创建一个代理类同样实现这个接口&lt;/li>
&lt;li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。&lt;/li>
&lt;/ol>
&lt;p>代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//定义发送短信的接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">SmsService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#a6e22e">send&lt;/span>(String message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//实现发送短信的接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SmsServiceImpl&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> SmsService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">send&lt;/span>(String message) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;send message:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> message;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//创建代理类并同样实现发送短信的接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SmsProxy&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> SmsService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> SmsService smsService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">SmsProxy&lt;/span>(SmsService smsService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">smsService&lt;/span> &lt;span style="color:#f92672">=&lt;/span> smsService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">send&lt;/span>(String message) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//调用方法之前，我们可以添加自己的操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;before method send()&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> smsService.&lt;span style="color:#a6e22e">send&lt;/span>(message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//调用方法之后，我们同样可以添加自己的操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;after method send()&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//实际使用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Main&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SmsService smsService &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SmsServiceImpl();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SmsProxy smsProxy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> SmsProxy(smsService);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> smsProxy.&lt;span style="color:#a6e22e">send&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;java&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//打印结果&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>before method &lt;span style="color:#a6e22e">send&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>send message:java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>after method &lt;span style="color:#a6e22e">send&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="动态代理">
 动态代理
 &lt;a class="anchor" href="#%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86">#&lt;/a>
&lt;/h3>
&lt;p>从JVM角度来说，动态代理是在&lt;strong>运行时动态生成类字节码&lt;/strong>，并&lt;strong>加载到JVM中的&lt;/strong>。 SpringAOP和RPC等框架都实现了动态代理&lt;/p></description></item><item><title>java-reflex</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0006lyreflex/</link><pubDate>Mon, 10 Oct 2022 11:27:04 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0006lyreflex/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h3 id="何为反射">
 何为反射
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba%e5%8f%8d%e5%b0%84">#&lt;/a>
&lt;/h3>
&lt;p>赋予了我们在&lt;strong>运行时分析类&lt;/strong>以及&lt;strong>执行类中方法&lt;/strong>的能力；运行中&lt;strong>获取任意一个类的所有属性&lt;/strong>和&lt;strong>方法&lt;/strong>，以及&lt;strong>调用这些方法&lt;/strong>和&lt;strong>属性&lt;/strong>&lt;/p>
&lt;h3 id="应用场景">
 应用场景
 &lt;a class="anchor" href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af">#&lt;/a>
&lt;/h3>
&lt;p>Spring/Spring Boot 、MyBatis等框架都用了大量反射机制，以下为&lt;/p>
&lt;ul>
&lt;li>
&lt;p>JDK动态代理&lt;/p>
&lt;ul>
&lt;li>
&lt;p>接口及实现类&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">package&lt;/span> proxy;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Car&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//实现类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">package&lt;/span> proxy;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CarImpl&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Car{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;car running&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>代理类 及main方法使用
&lt;code>[ˌɪnvəˈkeɪʃn] 祈祷&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> proxy;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">import&lt;/span> java.lang.reflect.InvocationHandler;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">import&lt;/span> java.lang.reflect.Method;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//JDK动态代理代理类 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CarHandler&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> InvocationHandler{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//真实类的对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Object car;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//构造方法赋值给真实的类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">CarHandler&lt;/span>(Object obj){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">car&lt;/span> &lt;span style="color:#f92672">=&lt;/span> obj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//代理类执行方法时，调用的是这个方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">invoke&lt;/span>(Object proxy, Method method, Object&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> Throwable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;before&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object res &lt;span style="color:#f92672">=&lt;/span> method.&lt;span style="color:#a6e22e">invoke&lt;/span>(car, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;after&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> res;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//main方法使用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> proxy;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.lang.reflect.Proxy;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CarImpl carImpl &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CarImpl();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CarHandler carHandler &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> CarHandler(carImpl);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Car proxy &lt;span style="color:#f92672">=&lt;/span> (Car)Proxy.&lt;span style="color:#a6e22e">newProxyInstance&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> main.&lt;span style="color:#a6e22e">class&lt;/span>.&lt;span style="color:#a6e22e">getClassLoader&lt;/span>(), &lt;span style="color:#75715e">//第一个参数，获取ClassLoader&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> carImpl.&lt;span style="color:#a6e22e">getClass&lt;/span>().&lt;span style="color:#a6e22e">getInterfaces&lt;/span>(), &lt;span style="color:#75715e">//第二个参数，获取被代理类的接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> carHandler);&lt;span style="color:#75715e">//第三个参数，一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proxy.&lt;span style="color:#a6e22e">run&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>before
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>car running
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>after
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Cglib动态代理（没有实现接口的Car&lt;/p></description></item><item><title>Java序列化详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0005lyserialize/</link><pubDate>Mon, 10 Oct 2022 10:39:01 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0005lyserialize/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h3 id="什么是序列化什么是反序列化">
 什么是序列化？什么是反序列化
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%ba%8f%e5%88%97%e5%8c%96%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96">#&lt;/a>
&lt;/h3>
&lt;p>当需要&lt;strong>持久化Java对象&lt;/strong>，比如&lt;strong>将Java对象保存在文件&lt;/strong>中、或者&lt;strong>在网络中传输Java对象&lt;/strong>，这些场景都需要用到序列化&lt;/p>
&lt;p>即：&lt;/p>
&lt;ul>
&lt;li>序列化：将&lt;strong>数据结构/对象&lt;/strong>，&lt;strong>转换成二进制字节流&lt;/strong>&lt;/li>
&lt;li>反序列化：将在&lt;strong>序列化过程中所生成的二进制字节流&lt;/strong>，&lt;strong>转换成数据结构或者对象&lt;/strong>的过程&lt;/li>
&lt;/ul>
&lt;p>对于Java，序列化的是对象(Object)，也就是实例化后的类(Class)&lt;/p>
&lt;p>序列化的目的，是通过网络传输对象，或者说是将对象存储到文件系统、数据库、内存中，如图：
&lt;img src="img/ly-20241212141924954.png" alt="ly-20241212141924954" />&lt;/p>
&lt;h3 id="实际场景">
 实际场景
 &lt;a class="anchor" href="#%e5%ae%9e%e9%99%85%e5%9c%ba%e6%99%af">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>对象在&lt;strong>进行网络传输（比如远程方法调用 RPC 的时候）之前&lt;/strong>需要先被序列化，&lt;strong>接收到&lt;/strong>序列化的对象&lt;strong>之后&lt;/strong>需要再进行&lt;strong>反序列化&lt;/strong>；&lt;/li>
&lt;li>将对象&lt;strong>存储到文件中&lt;/strong>的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化。&lt;/li>
&lt;li>将&lt;strong>对象存储到缓存数据库（如 Redis）时需要用到序列化&lt;/strong>，将对象&lt;strong>从缓存数据库中读取&lt;/strong>出来需要反序列化&lt;/li>
&lt;/ul>
&lt;h3 id="序列化协议对于tcpip-4层模型的哪一层">
 序列化协议对于TCP/IP 4层模型的哪一层
 &lt;a class="anchor" href="#%e5%ba%8f%e5%88%97%e5%8c%96%e5%8d%8f%e8%ae%ae%e5%af%b9%e4%ba%8etcpip-4%e5%b1%82%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%93%aa%e4%b8%80%e5%b1%82">#&lt;/a>
&lt;/h3>
&lt;p>4层包括，网络接口层，网络层，传输层，应用层
如下图所示：&lt;br>
&lt;img src="img/ly-20241212141925161.png" alt="ly-20241212141925161" />&lt;/p>
&lt;p>OSI七层协议模型中，表示层就是&lt;strong>对应用层的用户数据，进行处理转换成二进制流&lt;/strong>；反过来的话，就是&lt;strong>将二进制流转换成应用层的用户数据&lt;/strong>，即序列化和反序列化，&lt;br>
因为，OSI 七层协议模型中的&lt;strong>应用层、表示层和会话层&lt;/strong>对应的都是 &lt;strong>TCP/IP 四层模型&lt;/strong>中的&lt;strong>应用层&lt;/strong>，所以&lt;strong>序列化协议&lt;/strong>属于 &lt;strong>TCP/IP 协议应用层&lt;/strong>的一部分&lt;/p>
&lt;h3 id="常见序列化协议对比">
 常见序列化协议对比
 &lt;a class="anchor" href="#%e5%b8%b8%e8%a7%81%e5%ba%8f%e5%88%97%e5%8c%96%e5%8d%8f%e8%ae%ae%e5%af%b9%e6%af%94">#&lt;/a>
&lt;/h3>
&lt;p>kryo 英音 [k&amp;rsquo;rɪəʊ] ，除了JDK自带的序列化，还有&lt;strong>hessian&lt;/strong>、&lt;strong>kryo&lt;/strong>、&lt;strong>protostuff&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>JDK自带的序列化，只需要实现java.io.Serializable接口即可&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@AllArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@NoArgsConstructor&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Getter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Builder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ToString&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RpcRequest&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Serializable {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> serialVersionUID &lt;span style="color:#f92672">=&lt;/span> 1905122041950251207L;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String requestId;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String interfaceName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String methodName;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Object&lt;span style="color:#f92672">[]&lt;/span> parameters;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;[]&lt;/span> paramTypes;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> RpcMessageTypeEnum rpcMessageTypeEnum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>serialVersionUID用于版本控制，会被写入二进制序列，反序列化如果发现和当前类不一致则会抛出InvalidClassException异常。一般不使用JDK自带序列化，1 不支持跨语言调用 2 性能差，序列化之后字节数组体积过大&lt;/p></description></item><item><title>为什么Java中只有值传递</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0004lypassbyvalue/</link><pubDate>Sun, 09 Oct 2022 11:30:05 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0004lypassbyvalue/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>形参&amp;amp;&amp;amp;实参&lt;/p>
&lt;ul>
&lt;li>
&lt;p>实参(&lt;strong>实际参数，Arguments&lt;/strong>)，用于传递给函数/方法的参数，必须有确定的值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>形参(&lt;strong>形式参数，Parameters&lt;/strong>)，用于定义函数/方法，接收实参，不需要有确定的值&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String hello &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello!&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// hello 为实参&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sayHello(hello);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// str 为形参&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sayHello&lt;/span>(String str) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(str);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>值传递&amp;amp;&amp;amp;引用传递&lt;/p>
&lt;ul>
&lt;li>程序设计将实参传递给方法的方式分为两种，值传递：方法&lt;strong>接收实参值的拷&lt;/strong>贝，会&lt;strong>创建副本&lt;/strong>；引用传递：&lt;strong>方法接受的是实参所引用的对象在堆中的地址&lt;/strong>，不会创建副本，对形参的修改将影响到实参&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Java中只有值传递&lt;/strong>，原因：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>传递基本类型参数&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num1 &lt;span style="color:#f92672">=&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num2 &lt;span style="color:#f92672">=&lt;/span> 20;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(num1, num2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;num1 = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> num1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;num2 = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> num2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">swap&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">=&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;b = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">=&lt;/span> 20
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#f92672">=&lt;/span> 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>num1 &lt;span style="color:#f92672">=&lt;/span> 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>num2 &lt;span style="color:#f92672">=&lt;/span> 20
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>传递引用类型参数 1&lt;/p></description></item><item><title>javaGuide基础3</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0003lyjava_guide_basic_3/</link><pubDate>Sat, 08 Oct 2022 15:23:15 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0003lyjava_guide_basic_3/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="异常">
 异常
 &lt;a class="anchor" href="#%e5%bc%82%e5%b8%b8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>unchecked exceptions (运行时异常)&lt;br>
checked exceptions (非运行时异常，编译异常）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Java异常类层次结构图
&lt;img src="img/ly-20241212141923567.png" alt="ly-20241212141923567" />&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141923848.png" alt="ly-20241212141923848" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Exception和Error有什么区别&lt;/p>
&lt;ul>
&lt;li>
&lt;p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Exception : 程序本身可以处理的异常（可通过catch捕获）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Checked Exception ，受检查异常，必须处理(&lt;strong>catch 或者 throws ，否则编译器通过不了&lt;/strong>)
IOException，ClassNotFoundException，SQLException，FileNotFoundException&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Unchecked Exception ， 不受检查异常 ， 可以不处理&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>（算数异常，类型转换异常，不合法的线程状态异常，下标超出异常，空指针异常，参数类型异常，数字格式异常，不支持操作异常）
ArithmeticException，ClassCastException，IllegalThreadStateException，IndexOutOfBoundsException&lt;/p>
&lt;pre>&lt;code> NullPointerException，IllegalArgumentException，NumberFormatException，SecurityException，UnsupportedOperationException 


 ```illegal 英[ɪˈliːɡl] 非法的``` 
 ```Arithmetic 英[əˈrɪθmətɪk] 算术```
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>Error： &lt;strong>程序无法处理&lt;/strong>的错误 ，不建议通过catch 捕获，已办错误发生时JVM会选择线程终止&lt;br>
OutOfMemoryError （堆，Java heap space），VirtualMachineError，StackOverFlowError，AssertionError （断言），IOError&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Throwable类常用方法&lt;/p>
&lt;ul>
&lt;li>String getMessage() //简要描述&lt;/li>
&lt;li>String toString() //详细&lt;/li>
&lt;li>String getLocalizedMessage() //本地化信息，如果子类(Throwable的子类)没有覆盖该方法，则与gtMessage() 结果一样&lt;/li>
&lt;li>void printStackTrace() //打印Throwable对象封装的异常信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>try-catch-finally如何使用
try后面必须要有catch或者finally；无论是否捕获异常，finally都会执行；当在 &lt;code>try&lt;/code> 块或 &lt;code>catch&lt;/code> 块中遇到 &lt;code>return&lt;/code> 语句时，&lt;code>finally&lt;/code> 语句块将在方法返回之前被执行。&lt;/p></description></item><item><title>javaGuide基础2</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0002lyjava_guide_basic_2/</link><pubDate>Thu, 29 Sep 2022 10:16:13 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0002lyjava_guide_basic_2/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="面向对象基础">
 面向对象基础
 &lt;a class="anchor" href="#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>区别&lt;/p>
&lt;ul>
&lt;li>面向&lt;strong>过程&lt;/strong>把解决问题的&lt;strong>过程拆成一个个方法&lt;/strong>，通过一个个方法的执行解决问题。&lt;/li>
&lt;li>面向对象会&lt;strong>先抽象出对象&lt;/strong>，然后&lt;strong>用对象执行方法&lt;/strong>的方式解决问题。&lt;/li>
&lt;li>面向对象编程 &lt;strong>易维护&lt;/strong>、&lt;strong>易复用&lt;/strong>、&lt;strong>易扩展&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>对象实例与对象引用的不同&lt;br>
new 运算符，new 创建对象实例（&lt;strong>对象实例在堆&lt;/strong>内存中），对象引用指向对象实例（&lt;strong>对象引用存放在栈&lt;/strong>内存中）。&lt;/p>
&lt;p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对象的相等一般比较的是&lt;strong>内存中存放的内容&lt;/strong>是否相等；引用相等一般比较的是他们指向的&lt;strong>内存地址是否相等&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果一个类没有声明构造方法，该程序能正确执行吗?
如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了&lt;/p>
&lt;ul>
&lt;li>构造方法特点：名字与类名相同；没有返回值但不能用void声明构造函数；生成类的对象时自动执行&lt;/li>
&lt;li>构造方法&lt;strong>不能重写&lt;/strong>(override)，但&lt;strong>能重载&lt;/strong> (overload)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>面向对象三大特征&lt;/p>
&lt;ul>
&lt;li>
&lt;p>封装&lt;br>
把一个对象的状态信息(属性)&lt;strong>隐藏在对象内部&lt;/strong>，&lt;strong>不允许直接访问&lt;/strong>，但提供可以被外界访问的方法来操作属性&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Student&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> id;&lt;span style="color:#75715e">//id属性私有化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String name;&lt;span style="color:#75715e">//name属性私有化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//获取id的方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">getId&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> id;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//设置id的方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setId&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> id) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#f92672">=&lt;/span> id;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//获取name的方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getName&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//设置name的方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setName&lt;/span>(String name) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>继承&lt;br>
不通类型的对象，相互之间有一定数量的共同点，同时每个对象定义了额外的特性使得他们与众不同。继承是&lt;strong>使用已存在的类的定义作为基础&lt;/strong>建立新类的技术&lt;/p></description></item><item><title>javaGuide基础1</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0001lyjava_guide_basic_1/</link><pubDate>Wed, 28 Sep 2022 10:51:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/java_guide/java/Basic/ly0001lyjava_guide_basic_1/</guid><description>&lt;blockquote>
&lt;p>转载自https://github.com/Snailclimb/JavaGuide （添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h2 id="基础概念及常识">
 基础概念及常识
 &lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5%e5%8f%8a%e5%b8%b8%e8%af%86">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Java语言特点&lt;/p>
&lt;ul>
&lt;li>面向对象（封装、继承、多态）&lt;/li>
&lt;li>平台无关性（Java虚拟机）&lt;/li>
&lt;li>等等&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>JVM并非只有一种，只要满足JVM规范，可以开发自己专属JVM&lt;/p>
&lt;/li>
&lt;li>
&lt;p>JDK与JRE&lt;/p>
&lt;ul>
&lt;li>JDK，JavaDevelopmentKit，包含JRE，还有编译器（javac）和工具（如javadoc、jdb）。能够创建和编译程序&lt;/li>
&lt;li>JRE，Java运行时环境，包括Java虚拟机、Java类库，及Java命令等。但是不能创建新程序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>字节码，采用字节码的好处&lt;/p>
&lt;ul>
&lt;li>Java中，JVM可以理解的代码称为字节码（.class文件)，不面向任何处理器，只面向虚拟机&lt;/li>
&lt;li>Java程序从源代码到运行的过程
&lt;img src="img/ly-20241212141922068.png" alt="ly-20241212141922068" />
&lt;ul>
&lt;li>java代码必须先编译为字节码，之后呢，.class&amp;ndash;&amp;gt;机器码，这里JVM类加载器先加载字节码文件，然后通过解释器进行解释执行（也就是字节码需要由Java解释器来解释执行）&lt;/li>
&lt;li>Java解释器是JVM的一部分&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>编译与解释并存&lt;/p>
&lt;ul>
&lt;li>编译型：通过编译器将源代码一次性翻译成可被该平台执行的机器码，执行快、开发效率低&lt;/li>
&lt;li>解释型：通过解释器一句一句的将代码解释成机器代码后执行，执行慢，开发效率高&lt;/li>
&lt;li>如图
&lt;img src="img/ly-20241212141922280.png" alt="ly-20241212141922280" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>为什么说 Java 语言“编译与解释并存”？&lt;/strong>&lt;/p>
&lt;p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过&lt;strong>先编译，后解释&lt;/strong>两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（&lt;code>.class&lt;/code> 文件），&lt;strong>这种字节码必须由 Java 解释器来解释执行&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Java与C++区别&lt;/p>
&lt;ul>
&lt;li>没学过C++，Java不提供指针直接访问内存&lt;/li>
&lt;li>Java为单继承；但是Java支持继承多接口&lt;/li>
&lt;li>Java有自动内存管理垃圾回收机制（GC），不需要程序员手动释放无用内存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>注释分为 单行注释、多行注释、文档注释
&lt;img src="img/ly-20241212141922440.png" alt="ly-20241212141922440" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>标识符与关键字
标识符即名字，关键字则是被赋予特殊含义的标识符&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自增自减运算符
当 &lt;code>b = ++a&lt;/code> 时，先自增（自己增加 1），再赋值（赋值给 b）；当 &lt;code>b = a++&lt;/code> 时，先赋值(赋值给 b)，再自增（自己增加 1）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>continue/break/return&lt;/p>
&lt;ul>
&lt;li>&lt;code>continue&lt;/code> ：指跳出当前的这一次循环，继续下一次循环。&lt;/li>
&lt;li>&lt;code>break&lt;/code> ：指跳出整个循环体，继续执行循环下面的语句。&lt;/li>
&lt;li>&lt;code>return&lt;/code> 用于跳出所在方法，结束该方法的运行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>变量&lt;/p>
&lt;ul>
&lt;li>成员变量和局部变量
&lt;ul>
&lt;li>成员变量可以被 &lt;code>public&lt;/code>,&lt;code>private&lt;/code>,&lt;code>static&lt;/code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 &lt;code>static&lt;/code> 所修饰；但是，成员变量和局部变量都能被 &lt;code>final&lt;/code> 所修饰&lt;/li>
&lt;li>从变量在内存中的存储方式来看,如果成员变量是使用 &lt;code>static&lt;/code> 修饰的，那么这个成员变量是属于类的，如果没有使用 &lt;code>static&lt;/code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。&lt;/li>
&lt;li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡（即方法栈弹出后消亡）。&lt;/li>
&lt;li>final必须显示赋初始值，其他都自动以类型默认值赋值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>静态变量：被类所有实例共享&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>字符型常量与字符串常量区别&lt;/p></description></item><item><title>作用域及事务</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/ssm/scope_transaction/</link><pubDate>Fri, 23 Sep 2022 13:37:38 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/ssm/scope_transaction/</guid><description>&lt;h2 id="四种作用域">
 四种作用域
 &lt;a class="anchor" href="#%e5%9b%9b%e7%a7%8d%e4%bd%9c%e7%94%a8%e5%9f%9f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>singleton：默认值，当IOC容器一创建就会创建bean实例，而且是单例的，每次得到的是同一个&lt;/li>
&lt;li>prototype：原型的，IOC容器创建时不再创建bean实例。每次调用getBean方法时再实例化该bean（每次都会进行实例化）&lt;/li>
&lt;li>request：每次请求会实例化一个bean&lt;/li>
&lt;li>session：在一次会话中共享一个bean&lt;/li>
&lt;/ul>
&lt;h2 id="事务">
 事务
 &lt;a class="anchor" href="#%e4%ba%8b%e5%8a%a1">#&lt;/a>
&lt;/h2>
&lt;h3 id="事务是什么">
 事务是什么
 &lt;a class="anchor" href="#%e4%ba%8b%e5%8a%a1%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>逻辑上的一组操作，要么都执行，要么都不执行&lt;/p>
&lt;h3 id="事务的特性">
 事务的特性
 &lt;a class="anchor" href="#%e4%ba%8b%e5%8a%a1%e7%9a%84%e7%89%b9%e6%80%a7">#&lt;/a>
&lt;/h3>
&lt;p>ACID&lt;/p>
&lt;ul>
&lt;li>Atomicity &lt;code>/ˌætəˈmɪsəti/&lt;/code>原子性 , 要么全部成功，要么全部失败&lt;/li>
&lt;li>Consistency &lt;code>/kənˈsɪstənsi/&lt;/code> 一致性 , 数据库的完整性&lt;/li>
&lt;li>Isolation &lt;code>/ˌaɪsəˈleɪʃn/&lt;/code> 隔离性 , 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致 , 这里涉及到事务隔离级别&lt;/li>
&lt;li>Durability &lt;code>/ˌdjʊərəˈbɪləti/&lt;/code> 持久性 , 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失&lt;/li>
&lt;/ul>
&lt;h3 id="spring支持两种方式的事务管理">
 Spring支持两种方式的事务管理
 &lt;a class="anchor" href="#spring%e6%94%af%e6%8c%81%e4%b8%a4%e7%a7%8d%e6%96%b9%e5%bc%8f%e7%9a%84%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>编程式事务管理
&lt;code>/ˈeksɪkjuːt/&lt;/code> execute&lt;br>
使用transactionTemplate&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> TransactionTemplate transactionTemplate;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">testTransaction&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> transactionTemplate.&lt;span style="color:#a6e22e">execute&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> TransactionCallbackWithoutResult() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doInTransactionWithoutResult&lt;/span>(TransactionStatus transactionStatus) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// .... 业务代码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (Exception e){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//回滚&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> transactionStatus.&lt;span style="color:#a6e22e">setRollbackOnly&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用transactionManager&lt;/p></description></item><item><title>成员变量与局部变量</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/basics/member_variables_and_local_variables/</link><pubDate>Fri, 23 Sep 2022 10:31:44 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/basics/member_variables_and_local_variables/</guid><description>&lt;h2 id="代码">
 代码
 &lt;a class="anchor" href="#%e4%bb%a3%e7%a0%81">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> s;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> j;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Exam5 obj1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Exam5();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Exam5 obj2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Exam5();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> obj1.&lt;span style="color:#a6e22e">test&lt;/span>(10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> obj1.&lt;span style="color:#a6e22e">test&lt;/span>(20);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> obj2.&lt;span style="color:#a6e22e">test&lt;/span>(30);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(obj1.&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;,&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> obj1.&lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;,&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> obj1.&lt;span style="color:#a6e22e">s&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(obj2.&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;,&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> obj2.&lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;,&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> obj2.&lt;span style="color:#a6e22e">s&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="运行结果">
 运行结果
 &lt;a class="anchor" href="#%e8%bf%90%e8%a1%8c%e7%bb%93%e6%9e%9c">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>2,1,5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1,1,5
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="分析">
 分析
 &lt;a class="anchor" href="#%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h2>
&lt;h3 id="就近原则">
 就近原则
 &lt;a class="anchor" href="#%e5%b0%b1%e8%bf%91%e5%8e%9f%e5%88%99">#&lt;/a>
&lt;/h3>
&lt;p>代码中有很多修改变量的语句，下面是用就近原则+作用域分析的图
&lt;img src="img/ly-20241212141838186.png" alt="ly-20241212141838186" />&lt;/p></description></item><item><title>递归与迭代</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/basics/recursion_and_iteration/</link><pubDate>Thu, 22 Sep 2022 21:20:07 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/basics/recursion_and_iteration/</guid><description>&lt;h2 id="编程题">
 编程题
 &lt;a class="anchor" href="#%e7%bc%96%e7%a8%8b%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;p>有n步台阶，一次只能上1步或2步，共有多少种走法&lt;/p>
&lt;h3 id="分析">
 分析
 &lt;a class="anchor" href="#%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>分析&lt;br>
n = 1，1步 f(1) = 1&lt;br>
n = 2, 两个1步,2步 f(2) = 2&lt;br>
n = 3, 分两种情况： 最后1步是2级台阶/最后1步是1级台阶，
即 f(3) = f(1)+f(2)
n = 4, 分两种情况： 最后1步是2级台阶/最后1步是1级台阶，
即f(4) = f(2)+f(3)&lt;/p>
&lt;p>也就是说，不管有几(n)个台阶，总要分成两种情况：最后1步是2级台阶/最后1步是1级台阶，即 f(n)= f(n-2) + f(n-1)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="递归">
 递归
 &lt;a class="anchor" href="#%e9%80%92%e5%bd%92">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(n&lt;span style="color:#f92672">==&lt;/span>1 &lt;span style="color:#f92672">||&lt;/span> n&lt;span style="color:#f92672">==&lt;/span>2){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> f(n&lt;span style="color:#f92672">-&lt;/span>2)&lt;span style="color:#f92672">+&lt;/span>f(n&lt;span style="color:#f92672">-&lt;/span>1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(f(1)); &lt;span style="color:#75715e">//1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(f(2)); &lt;span style="color:#75715e">//2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(f(3)); &lt;span style="color:#75715e">//3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(f(4)); &lt;span style="color:#75715e">//5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(f(5)); &lt;span style="color:#75715e">//8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>debug调试
方法栈
f(4)&amp;mdash;-&amp;gt;分解成f(2)+f(3)
f(2)&amp;mdash;返回-
f(3)&amp;mdash;f(2)返回&amp;mdash;f(1)返回 【f(3)分解成f(2)和f(1)】
方法栈的个数：
&lt;img src="img/ly-20241212141840077.png" alt="ly-20241212141840077" />&lt;/li>
&lt;/ul>
&lt;h3 id="使用循环">
 使用循环
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8%e5%be%aa%e7%8e%af">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">loop&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">&amp;lt;&lt;/span> 1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalArgumentException(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;不能小于1&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">==&lt;/span> 1 &lt;span style="color:#f92672">||&lt;/span> n &lt;span style="color:#f92672">==&lt;/span> 2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> one&lt;span style="color:#f92672">=&lt;/span>2;&lt;span style="color:#75715e">//最后只走1步，会有2种走法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> two&lt;span style="color:#f92672">=&lt;/span>1;&lt;span style="color:#75715e">//最后走2步，会有1种走法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sum&lt;span style="color:#f92672">=&lt;/span>0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>3;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//最后跨两级台阶+最后跨一级台阶的走法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sum&lt;span style="color:#f92672">=&lt;/span>two&lt;span style="color:#f92672">+&lt;/span>one;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> two&lt;span style="color:#f92672">=&lt;/span>one;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> one&lt;span style="color:#f92672">=&lt;/span>sum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sum;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="img/ly-20241212141840386.png" alt="ly-20241212141840386" />&lt;/p></description></item><item><title>方法的参数传递机制</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/basics/method_parameter_passing_mechanism/</link><pubDate>Thu, 22 Sep 2022 10:24:36 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/basics/method_parameter_passing_mechanism/</guid><description>&lt;h2 id="代码">
 代码
 &lt;a class="anchor" href="#%e4%bb%a3%e7%a0%81">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Exam4&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String str &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Integer num &lt;span style="color:#f92672">=&lt;/span> 2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> arr &lt;span style="color:#f92672">=&lt;/span> {1, 2, 3, 4, 5};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyData my &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> MyData();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> change(i, str, num, arr, my);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;i = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;str = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> str);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;num = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;arr = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Arrays.&lt;span style="color:#a6e22e">toString&lt;/span>(arr));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;my.a = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> my.&lt;span style="color:#a6e22e">a&lt;/span>); 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">change&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j, String s, Integer n, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyData m) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j&lt;span style="color:#f92672">+=&lt;/span>1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s&lt;span style="color:#f92672">+=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n&lt;span style="color:#f92672">+=&lt;/span>1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]+=&lt;/span>1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m.&lt;span style="color:#a6e22e">a&lt;/span>&lt;span style="color:#f92672">+=&lt;/span>1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果&lt;/p></description></item><item><title>类、实例初始化</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/basics/class_and_instance_initialization/</link><pubDate>Thu, 22 Sep 2022 08:50:23 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/basics/class_and_instance_initialization/</guid><description>&lt;h2 id="代码">
 代码
 &lt;a class="anchor" href="#%e4%bb%a3%e7%a0%81">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Son&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Father{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>test();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>method();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">static&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;(6)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Son(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;(7)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;(8)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;(9)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;(10)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		Son s1&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> Son();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		Son s2&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> Son();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Father&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>test();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>method();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">static&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;(1)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Father(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;(2)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;(3)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;(4)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;(5)&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出：&lt;/p></description></item><item><title>单例设计模式</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/basics/singleton_design_pattern/</link><pubDate>Wed, 21 Sep 2022 14:22:44 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/basics/singleton_design_pattern/</guid><description>&lt;h2 id="特点">
 特点
 &lt;a class="anchor" href="#%e7%89%b9%e7%82%b9">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>该类只有一个实例
&lt;ul>
&lt;li>构造器私有化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>该类内部自行创建该实例
&lt;ul>
&lt;li>使用静态变量保存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>能向外部提供这个实例
&lt;ul>
&lt;li>直接暴露&lt;/li>
&lt;li>使用静态变量的get方法获取&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="几大方法">
 几大方法
 &lt;a class="anchor" href="#%e5%87%a0%e5%a4%a7%e6%96%b9%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;h3 id="饿汉式">
 饿汉式
 &lt;a class="anchor" href="#%e9%a5%bf%e6%b1%89%e5%bc%8f">#&lt;/a>
&lt;/h3>
&lt;p>随着类的加载进行初始化，不管是否需要都会直接创建实例对象&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Singleton1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Singleton1 INSTANCE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> Singleton1();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">Singleton1&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="枚举">
 枚举
 &lt;a class="anchor" href="#%e6%9e%9a%e4%b8%be">#&lt;/a>
&lt;/h3>
&lt;p>枚举类表示该类型的对象是有限的几个&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> Singleton2 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	 INSTANCE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="使用静态代码块">
 使用静态代码块
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8%e9%9d%99%e6%80%81%e4%bb%a3%e7%a0%81%e5%9d%97">#&lt;/a>
&lt;/h3>
&lt;p>随着类的加载进行初始化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Singleton2&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Singleton2 INSTANCE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">static&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		INSTANCE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Singleton2();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">Singleton2&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如图，当初始化实例时需要进行复杂取值操作时，可以取代第一种方法
&lt;img src="img/ly-20241212141841430.png" alt="ly-20241212141841430" />&lt;/p>
&lt;h3 id="懒汉式">
 懒汉式
 &lt;a class="anchor" href="#%e6%87%92%e6%b1%89%e5%bc%8f">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>延迟创建对象&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Singleton4&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">//为了防止重排序，需要添加volatile关键字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">volatile&lt;/span> Singleton4 INSTANCE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">Singleton4&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">	 * double check
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">	 * @return
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">	 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Singleton4 &lt;span style="color:#a6e22e">getInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">//2 先判断一次,对于后面的操作(此时已经创建了对象)能减少加锁次数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">if&lt;/span> (INSTANCE &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">//如果这里不加锁会导致线程安全问题，可能刚进了判断语句之后，执行权被剥夺了又创建好了对象，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">//所以判断及创建对象必须是原子操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">synchronized&lt;/span> (Singleton4.&lt;span style="color:#a6e22e">class&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#66d9ef">if&lt;/span> (INSTANCE &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					&lt;span style="color:#75715e">//用来模拟多线程被剥夺执行权&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>						Thread.&lt;span style="color:#a6e22e">sleep&lt;/span>(1000);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					} &lt;span style="color:#66d9ef">catch&lt;/span> (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>						e.&lt;span style="color:#a6e22e">printStackTrace&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					&lt;span style="color:#75715e">//如果这个地方不加volatile,会出现的问题是,指令重排 1,2,3是正常的,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					&lt;span style="color:#75715e">//会重排成1,3,2 然后别的线程去拿的时候，判断为非空，但是实际上运行的时候，发现里面的数据是空的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					&lt;span style="color:#75715e">//1 memory = allocate();//分配对象空间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					&lt;span style="color:#75715e">//2 instance(memory); //初始化对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					&lt;span style="color:#75715e">//3 instance = memory; //设置instance指向刚刚分配的位置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					INSTANCE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Singleton4();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> INSTANCE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="使用静态内部类">
 使用静态内部类
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8%e9%9d%99%e6%80%81%e5%86%85%e9%83%a8%e7%b1%bb">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Singleton6&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#a6e22e">Singleton6&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Inner&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Singleton6 INSTANCE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> Singleton6();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Singleton6 &lt;span style="color:#a6e22e">getInstance&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Inner.&lt;span style="color:#a6e22e">INSTANCE&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>只有当内部类被加载和初始化的时候，才会创建INSTANCE实例对象&lt;/li>
&lt;li>静态内部类不会自动随着外部类的加载和初始化而初始化，他需要单独去加载和初始化&lt;/li>
&lt;li>又由于他是在内部类加载和初始化时，创建的，属于类加载器处理的，所以是线程安全的&lt;/li>
&lt;/ul></description></item><item><title>自增变量</title><link>https://lwmfjc.github.io/zh/docs/technology/Review/basics/self_incrementing_variable/</link><pubDate>Wed, 21 Sep 2022 10:04:34 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Review/basics/self_incrementing_variable/</guid><description>&lt;h2 id="题目">
 题目
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%ae">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		i&lt;span style="color:#f92672">=&lt;/span>i&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>i&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#f92672">++&lt;/span>i &lt;span style="color:#f92672">*&lt;/span> i&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;i=&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;j=&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>j);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;k=&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>k);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="讲解">
 讲解
 &lt;a class="anchor" href="#%e8%ae%b2%e8%a7%a3">#&lt;/a>
&lt;/h2>
&lt;h3 id="对于操作数栈和局部变量表的理解">
 对于操作数栈和局部变量表的理解
 &lt;a class="anchor" href="#%e5%af%b9%e4%ba%8e%e6%93%8d%e4%bd%9c%e6%95%b0%e6%a0%88%e5%92%8c%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e8%a1%a8%e7%9a%84%e7%90%86%e8%a7%a3">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>对于下面的代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>9;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		j&lt;span style="color:#f92672">=&lt;/span>i;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>反编译之后，查看字节码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>0 bipush 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2 istore_1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3 bipush 9
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5 istore_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>6 iload_1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>7 istore_2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>8 &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如下图，这三行代码，是依次把10，9先放到局部变量表的1，2位置。&lt;br>
之后呢，再把局部变量表中1位置的值，放入操作数栈中&lt;br>
最后，将操作数栈弹出一个数(10)，将数值赋给局部变量表中的位置2&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141840576.png" alt="ly-20241212141840576" />
&lt;img src="img/ly-20241212141840888.png" alt="ly-20241212141840888" />
如上图，当方法为静态方法时，局部变量表0位置存储的是实参第1个数&lt;/p>
&lt;p>(当方法为非静态方法时，局部变量表0位置存储的是this引用)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于下面这段代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>20;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		i&lt;span style="color:#f92672">=&lt;/span>i&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		j&lt;span style="color:#f92672">=++&lt;/span>j;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(j);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编译后的字节码&lt;/p></description></item><item><title>19-26_git_尚硅谷</title><link>https://lwmfjc.github.io/zh/docs/technology/Git/git_sgg/19-26/</link><pubDate>Sun, 24 Jul 2022 16:46:04 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Git/git_sgg/19-26/</guid><description>&lt;h1 id="介绍">
 介绍
 &lt;a class="anchor" href="#%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h1>
&lt;p>使用代码托管中心（远程服务器）
&lt;img src="img/ly-20241212142124425.png" alt="ly-20241212142124425" />&lt;/p>
&lt;ul>
&lt;li>团队内写作
push&amp;ndash;clone&amp;ndash;push&amp;mdash;
&amp;ndash;pull
&lt;img src="img/ly-20241212142124625.png" alt="ly-20241212142124625" />&lt;/li>
&lt;li>跨团队写作
fork（到自己的远程库）&amp;mdash;clone
&lt;img src="img/ly-20241212142124707.png" alt="ly-20241212142124707" />&lt;/li>
&lt;/ul>
&lt;h1 id="创建远程库创建别名">
 创建远程库&amp;amp;创建别名
 &lt;a class="anchor" href="#%e5%88%9b%e5%bb%ba%e8%bf%9c%e7%a8%8b%e5%ba%93%e5%88%9b%e5%bb%ba%e5%88%ab%e5%90%8d">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>官网：https://github.com&lt;/li>
&lt;li>现在yuebuqun注册一个账号
创建一个远程库git-demo，创建成功
&lt;img src="img/ly-20241212142124787.png" alt="ly-20241212142124787" />&lt;/li>
&lt;li>创建远程库别名
git remote -v （查看别名）
为远程库创建别名
&lt;code>git remote add git-demo https://github.com/lwmfjc/git-demo.git&lt;/code>
别名创建成功 fetch和push都可以使用别名
&lt;img src="img/ly-20241212142124868.png" alt="ly-20241212142124868" />&lt;/li>
&lt;/ul>
&lt;h1 id="推送本地库到远程库">
 推送本地库到远程库
 &lt;a class="anchor" href="#%e6%8e%a8%e9%80%81%e6%9c%ac%e5%9c%b0%e5%ba%93%e5%88%b0%e8%bf%9c%e7%a8%8b%e5%ba%93">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>推送master分支
切换&lt;code>git checkout master&lt;/code>&lt;/li>
&lt;li>推送
git push git-demo master
&lt;img src="img/ly-20241212142124947.png" alt="ly-20241212142124947" />&lt;/li>
&lt;/ul>
&lt;h1 id="拉取远程库到本地库">
 拉取远程库到本地库
 &lt;a class="anchor" href="#%e6%8b%89%e5%8f%96%e8%bf%9c%e7%a8%8b%e5%ba%93%e5%88%b0%e6%9c%ac%e5%9c%b0%e5%ba%93">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>&lt;code>git pull git-demo master&lt;/code>
结果
&lt;img src="img/ly-20241212142125028.png" alt="ly-20241212142125028" />&lt;/li>
&lt;/ul>
&lt;h1 id="克隆远程库到本地">
 克隆远程库到本地
 &lt;a class="anchor" href="#%e5%85%8b%e9%9a%86%e8%bf%9c%e7%a8%8b%e5%ba%93%e5%88%b0%e6%9c%ac%e5%9c%b0">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>git clone xxxxxxx/git-demo.git
&lt;img src="img/ly-20241212142125111.png" alt="ly-20241212142125111" />
clone之后有默认的别名，且已经初始化了本地库&lt;/li>
&lt;/ul>
&lt;h1 id="团队内写作">
 团队内写作
 &lt;a class="anchor" href="#%e5%9b%a2%e9%98%9f%e5%86%85%e5%86%99%e4%bd%9c">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>lhc修改了git-demo下的hello.txt&lt;/li>
&lt;li>之后进行git add hello.txt&lt;/li>
&lt;li>git commit -m &amp;ldquo;lhc-commit &amp;quot; hello.txt&lt;/li>
&lt;li>现在进行push
git push origin master
出错了
&lt;img src="img/ly-20241212142125194.png" alt="ly-20241212142125194" />&lt;/li>
&lt;li>使用ybq，对库进行设置，管理成员
&lt;img src="img/ly-20241212142125275.png" alt="ly-20241212142125275" />&lt;/li>
&lt;li>添加成员即可
输入账号名
&lt;img src="img/ly-20241212142125354.png" alt="ly-20241212142125354" />&lt;/li>
&lt;li>将邀请函
&lt;img src="img/ly-20241212142125433.png" alt="ly-20241212142125433" />
发送给lhc
&lt;img src="img/ly-20241212142125516.png" alt="ly-20241212142125516" />&lt;/li>
&lt;li>现在再次推送，则推送成功
&lt;img src="img/ly-20241212142125598.png" alt="ly-20241212142125598" />&lt;/li>
&lt;/ul>
&lt;h1 id="团队外合作">
 团队外合作
 &lt;a class="anchor" href="#%e5%9b%a2%e9%98%9f%e5%a4%96%e5%90%88%e4%bd%9c">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>先把别人的项目fork下来
&lt;img src="img/ly-20241212142125682.png" alt="ly-20241212142125682" />&lt;/p></description></item><item><title>人为什么要结婚(找对象)</title><link>https://lwmfjc.github.io/zh/docs/life/archive/20220724/</link><pubDate>Sun, 24 Jul 2022 10:53:29 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/life/archive/20220724/</guid><description>&lt;p>其实这是我在六七年前思考的一个问题，我觉得结婚，并不能单纯的作为一个世俗任务。很多人，是因为年纪到了结婚，因为父母催结婚，因为看到别人结婚而结婚，总之，是为别人而活。但我觉得，结婚的本质，应该是两个人生活的结合，包括了很多，比如生活中的喜怒哀乐互享，这是最基础的，开心了有人替你高兴，生气难过了有人安慰你、心疼你。如果连这个都做不到而各活各的，那我实在想不明白这种婚姻的意义在哪，而现在很多情况正是这样，有为了家庭而工作辛苦而没有交集的，也有单纯的相处腻了、懒了。&lt;/p>
&lt;p>而说到腻，这就在于一点，就是有些婚姻是很仓促的，压根就没看清楚对方的样子(性格、三观)，或者是不清楚自己喜欢的是什么样的人，就已经在一起了，之后才发现对方很多问题不是自己能接受的，但是这个时候已经晚了。所以“内在”，才能持久吸引一个人，因为这是不轻易随时光变迁而改变的。&lt;/p>
&lt;p>分享也并非简单的分享，如果分享的东西对方没有啥感觉，那这种关系也是很难持久的。因此，最佳的婚姻，应该是异性知己，你的一些心理，不用向对方解释太多，当然 这里并不是说一开始就是这种状态，更多是通过后面不断了解、不断磨合而达成这种状态，当你被别人误会了有人理解，这是世间最好的良药。理解一个人，就是拯救一个世界，一花一世界，一树一菩提。&lt;/p>
&lt;p>&lt;strong>婚姻，就是找个互相理解的爱人，共享世间冷暖，白首不相离。&lt;/strong>&lt;/p></description></item><item><title>09-18_git_尚硅谷</title><link>https://lwmfjc.github.io/zh/docs/technology/Git/git_sgg/09-18/</link><pubDate>Sat, 23 Jul 2022 09:39:11 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Git/git_sgg/09-18/</guid><description>&lt;h1 id="命令">
 命令
 &lt;a class="anchor" href="#%e5%91%bd%e4%bb%a4">#&lt;/a>
&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>命令-设置用户签名&lt;/p>
&lt;ul>
&lt;li>查看
&lt;code>git config user.name&lt;/code>
&lt;code>git config user.email&lt;/code>&lt;/li>
&lt;li>设置
&lt;code>git config --global user.name ly001&lt;/code>
&lt;code>git config --global user.email xxx@xx.com&lt;/code>&lt;/li>
&lt;li>git的配置文件查看
&lt;img src="img/ly-20241212142119718.png" alt="ly-20241212142119718" />&lt;/li>
&lt;li>作用：区分不同操作者身份，跟后面登陆的账号没有关系&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>初始化本地库&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>git init &lt;/code>&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142119957.png" alt="ly-20241212142119957" />
多出一个文件夹
&lt;img src="img/ly-20241212142120049.png" alt="ly-20241212142120049" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>查看本地库状态&lt;/p>
&lt;ul>
&lt;li>&lt;code>git status&lt;/code>
&lt;img src="img/ly-20241212142120138.png" alt="ly-20241212142120138" />
默认在master分支&lt;/li>
&lt;li>新增一个文件
&lt;code>vim hello.txt&lt;/code>
&lt;img src="img/ly-20241212142120222.png" alt="ly-20241212142120222" />&lt;/li>
&lt;li>此时查看本地库的状态
&lt;img src="img/ly-20241212142120310.png" alt="ly-20241212142120310" />
untracketd files 未被追踪的文件，也就是这个文件还在工作区&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>添加暂存区&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>git add hello.txt&lt;/code>
&lt;img src="img/ly-20241212142120403.png" alt="ly-20241212142120403" />
LF 将会被替换成 CRLF，windows里面是CRLF，也就是说&lt;/p>
&lt;blockquote>
&lt;p>这个&lt;code>换行符自动转换&lt;/code>会把自动把你代码里 与你当前操作系统不相同的换行的方式 转换成当前系统的换行方式（即&lt;code>LF&lt;/code>和&lt;code>CRLF&lt;/code> 之间的转换）&lt;/p>
&lt;/blockquote>
&lt;p>这是因为这个hello.txt是使用&lt;code>vm hello.txt&lt;/code>在git bash里面添加的，如果直接在windows文件管理器添加一个文件（hello2.txt)，就会发现没有这个警告，因为他已经是CRLF了 （为了和视频保持一致，git rm &amp;ndash;cached hello2.txt 后删除这个文件）
&lt;img src="img/ly-20241212142120487.png" alt="ly-20241212142120487" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看当前状态，绿色表示git已经追踪到了这个文件&lt;/p>
&lt;p>文件已经存在于暂存区
&lt;img src="img/ly-20241212142120577.png" alt="ly-20241212142120577" />&lt;/p></description></item><item><title>01-08_git_尚硅谷</title><link>https://lwmfjc.github.io/zh/docs/technology/Git/git_sgg/01-08/</link><pubDate>Wed, 20 Jul 2022 21:57:18 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Git/git_sgg/01-08/</guid><description>&lt;h1 id="概述">
 概述
 &lt;a class="anchor" href="#%e6%a6%82%e8%bf%b0">#&lt;/a>
&lt;/h1>
&lt;h2 id="课程介绍">
 课程介绍
 &lt;a class="anchor" href="#%e8%af%be%e7%a8%8b%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>Git
- git介绍&amp;ndash;分布式版本控制+集中式版本控制
- git安装&amp;ndash;基于官网，2.31.1 windows
- 基于开发案例 详细讲解常用命令
- git分支&amp;mdash;特性、创建、转换、合并、代码合并冲突解决
- idea集成git&lt;/li>
&lt;li>Github
&lt;ul>
&lt;li>如何创建远程库&lt;/li>
&lt;li>推送 push&lt;/li>
&lt;li>拉取 pull&lt;/li>
&lt;li>克隆 clone&lt;/li>
&lt;li>ssh免密登录&lt;/li>
&lt;li>idea github集成&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Gitee码云
&lt;ul>
&lt;li>码云创建远程库&lt;/li>
&lt;li>Idea集成Gitee&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Gitlab
&lt;ul>
&lt;li>gitlab服务器的搭建和部署&lt;/li>
&lt;li>idea集成gitlab&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>课程目标：五个小时，熟练掌握git、github、gitee&lt;/li>
&lt;/ol>
&lt;h2 id="官网介绍">
 官网介绍
 &lt;a class="anchor" href="#%e5%ae%98%e7%bd%91%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>git是免费的开源的分布式版本控制系统&lt;/li>
&lt;li>廉价的本地库&lt;/li>
&lt;li>分支功能
&lt;img src="img/ly-20241212142118069.png" alt="ly-20241212142118069" />&lt;/li>
&lt;li>Everything is local&lt;/li>
&lt;/ol>
&lt;h2 id="版本控制介绍">
 版本控制介绍
 &lt;a class="anchor" href="#%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>记录文件内容变化，以便将来查阅特定版本修订记录的系统&lt;/li>
&lt;li>如果没有git
&lt;img src="img/ly-20241212142118196.png" alt="ly-20241212142118196" />&lt;/li>
&lt;li>为什么需要版本控制（从个人开发过渡到团队合作）
&lt;img src="img/ly-20241212142118292.png" alt="ly-20241212142118292" />&lt;/li>
&lt;/ol>
&lt;h2 id="分布式版本控制vs集中式版本控制">
 分布式版本控制VS集中式版本控制
 &lt;a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6vs%e9%9b%86%e4%b8%ad%e5%bc%8f%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>SVN，单一的集中管理的服务器，保存所有文件的修订版本。其他人都先连到这个中央服务器上获取最新处理是否冲突
&lt;img src="img/ly-20241212142118383.png" alt="ly-20241212142118383" />&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>缺点，单点故障，如果某段时间内故障了，那么就没法提交&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>Git，每台电脑都是代码库
&lt;img src="img/ly-20241212142118467.png" alt="ly-20241212142118467" />
&lt;ul>
&lt;li>如果远程库挂了，本地还是可以做版本控制的，只不过不能做代码推送而已&lt;/li>
&lt;li>每个客户端保存的都是完整的项目（包括历史记录）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="发展历史">
 发展历史
 &lt;a class="anchor" href="#%e5%8f%91%e5%b1%95%e5%8e%86%e5%8f%b2">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>linux系统版本控制历史
&lt;ul>
&lt;li>1991-2002 手动合并&lt;/li>
&lt;li>2002 BitKeeper授权Linux社区免费使用（版本控制系统）
&lt;ul>
&lt;li>社区将其破解&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>2005 用C语言开发了一个分布式版本控制系统：Git
两周开发时间&lt;/li>
&lt;li>2008年 GitHub上线&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="工作机制和代码托管中心">
 工作机制和代码托管中心
 &lt;a class="anchor" href="#%e5%b7%a5%e4%bd%9c%e6%9c%ba%e5%88%b6%e5%92%8c%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e4%b8%ad%e5%bf%83">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142118560.png" alt="ly-20241212142118560" />&lt;/p></description></item><item><title>01-21 maven多模块管理_动力节点</title><link>https://lwmfjc.github.io/zh/docs/technology/Maven/advance_dljd/01-21/</link><pubDate>Sun, 17 Jul 2022 09:49:30 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Maven/advance_dljd/01-21/</guid><description>&lt;h2 id="场景介绍">
 场景介绍
 &lt;a class="anchor" href="#%e5%9c%ba%e6%99%af%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>业务依赖
&lt;img src="img/ly-20241212142142250.png" alt="ly-20241212142142250" />&lt;/li>
&lt;li>多模块管理
版本管理
&lt;img src="img/ly-20241212142142435.png" alt="ly-20241212142142435" />&lt;/li>
&lt;/ul>
&lt;h2 id="第1种方式">
 第1种方式
 &lt;a class="anchor" href="#%e7%ac%ac1%e7%a7%8d%e6%96%b9%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;h3 id="创建父工程">
 创建父工程
 &lt;a class="anchor" href="#%e5%88%9b%e5%bb%ba%e7%88%b6%e5%b7%a5%e7%a8%8b">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>先创建一个空项目
&lt;img src="img/ly-20241212142142506.png" alt="ly-20241212142142506" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在这个空项目下，创建一个module当作maven父工程
&lt;img src="img/ly-20241212142142569.png" alt="ly-20241212142142569" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>结构
&lt;img src="img/ly-20241212142142631.png" alt="ly-20241212142142631" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>pom文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;project&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span style="color:#f92672">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.bjpowernode.maven&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>001-maven-parent&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0.0&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!--
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> packaging 标签指定打包方式，默认为jar
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!--
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> maven父工程必须遵守以下两点要求
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 1、packaging标签的文本内容必须设置为pom
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> 2、把src删除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="介绍pom文件">
 介绍pom文件
 &lt;a class="anchor" href="#%e4%bb%8b%e7%bb%8dpom%e6%96%87%e4%bb%b6">#&lt;/a>
&lt;/h3>
&lt;p>pom 项目对象模型，project object model，该文件可以子工程被继承
maven多模块管理，其实就是让它的子模块的pom文件来继承父工程的pom&lt;/p>
&lt;h3 id="创建maven-java子工程">
 创建maven java子工程
 &lt;a class="anchor" href="#%e5%88%9b%e5%bb%bamaven-java%e5%ad%90%e5%b7%a5%e7%a8%8b">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>新建一个module&lt;/p>
&lt;p>注意路径，002在IDEA-maven的目录下
&lt;img src="img/ly-20241212142142693.png" alt="ly-20241212142142693" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看pom文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;project&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!--指向父工程的gav坐标--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;parent&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>001-maven-parent&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.bjpowernode.maven&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0.0&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!--相对路径--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;relativePath&amp;gt;&lt;/span>../001-maven-parent/pom.xml&lt;span style="color:#f92672">&amp;lt;/relativePath&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/parent&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span style="color:#f92672">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>002-maven-java&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="创建maven-web子工程">
 创建maven web子工程
 &lt;a class="anchor" href="#%e5%88%9b%e5%bb%bamaven-web%e5%ad%90%e5%b7%a5%e7%a8%8b">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>创建新模块
&lt;img src="img/ly-20241212142142754.png" alt="ly-20241212142142754" />&lt;/p></description></item><item><title>31-43 maven基础_动力节点</title><link>https://lwmfjc.github.io/zh/docs/technology/Maven/base_dljd/31-43/</link><pubDate>Sat, 09 Jul 2022 18:24:30 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Maven/base_dljd/31-43/</guid><description>&lt;h2 id="idea中设置maven">
 idea中设置maven
 &lt;a class="anchor" href="#idea%e4%b8%ad%e8%ae%be%e7%bd%aemaven">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>和idea集成maven
&lt;img src="img/ly-20241212142146614.png" alt="ly-20241212142146614" />&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="创建普通的j2se项目">
 创建普通的j2se项目
 &lt;a class="anchor" href="#%e5%88%9b%e5%bb%ba%e6%99%ae%e9%80%9a%e7%9a%84j2se%e9%a1%b9%e7%9b%ae">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>使用idea创建空白项目
&lt;img src="img/ly-20241212142146810.png" alt="ly-20241212142146810" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新建一个module
&lt;img src="img/ly-20241212142146873.png" alt="ly-20241212142146873" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用模板创建普通java项目
&lt;img src="img/ly-20241212142146930.png" alt="ly-20241212142146930" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>输入gav
&lt;img src="img/ly-20241212142146987.png" alt="ly-20241212142146987" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>设置maven信息
&lt;img src="img/ly-20241212142147048.png" alt="ly-20241212142147048" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>标准的maven工程
&lt;img src="img/ly-20241212142147103.png" alt="ly-20241212142147103" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>与创建网站有关，删掉即可&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;project&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span style="color:#f92672">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.bjpowernode&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>ch01-maven-j2se&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!--设置网站，注释掉即可--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!-- &amp;lt;name&amp;gt;ch01-maven-j2se&amp;lt;/name&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> &amp;lt;!– FIXME change it to the project&amp;#39;s website –&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> &amp;lt;url&amp;gt;http://www.example.com&amp;lt;/url&amp;gt;--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;properties&amp;gt;&lt;/span> &lt;span style="color:#75715e">&amp;lt;!--maven常用设置--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;project.build.sourceEncoding&amp;gt;&lt;/span>UTF-8&lt;span style="color:#f92672">&amp;lt;/project.build.sourceEncoding&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;maven.compiler.source&amp;gt;&lt;/span>1.8&lt;span style="color:#f92672">&amp;lt;/maven.compiler.source&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;maven.compiler.target&amp;gt;&lt;/span>1.8&lt;span style="color:#f92672">&amp;lt;/maven.compiler.target&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/properties&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>&lt;span style="color:#75715e">&amp;lt;!--单元测试--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>junit&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>junit&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.11&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>test&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;build&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!--插件版本的配置，无特殊指定则删除--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;pluginManagement&amp;gt;&lt;/span>&lt;span style="color:#75715e">&amp;lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugins&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>maven-clean-plugin&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>3.1.0&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>maven-resources-plugin&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>3.0.2&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>maven-compiler-plugin&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>3.8.0&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>maven-surefire-plugin&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>2.22.1&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>maven-jar-plugin&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>3.0.2&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>maven-install-plugin&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>2.5.2&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>maven-deploy-plugin&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>2.8.2&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>maven-site-plugin&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>3.7.1&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>maven-project-info-reports-plugin&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>3.0.0&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugins&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/pluginManagement&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/build&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="单元测试">
 单元测试
 &lt;a class="anchor" href="#%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>关于idea颜色
&lt;img src="img/ly-20241212142147158.png" alt="ly-20241212142147158" />&lt;/p></description></item><item><title>17-30 maven基础_动力节点</title><link>https://lwmfjc.github.io/zh/docs/technology/Maven/base_dljd/17-30/</link><pubDate>Sun, 03 Jul 2022 18:24:26 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Maven/base_dljd/17-30/</guid><description>&lt;h2 id="本地仓库的设置">
 本地仓库的设置
 &lt;a class="anchor" href="#%e6%9c%ac%e5%9c%b0%e4%bb%93%e5%ba%93%e7%9a%84%e8%ae%be%e7%bd%ae">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>远程仓库&amp;ndash;&amp;gt;本地仓库&lt;/p>
&lt;/li>
&lt;li>
&lt;p>maven仓库&lt;/p>
&lt;ul>
&lt;li>存放maven工具自己的jar包&lt;/li>
&lt;li>第三方jar，比如mysql驱动&lt;/li>
&lt;li>自己写的程序，可以打包为jar，存放到仓库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>分类&lt;/p>
&lt;ul>
&lt;li>
&lt;p>本地仓库（本机）：位于自己计算机中，磁盘中某个目录&lt;/p>
&lt;ul>
&lt;li>
&lt;p>默认位置 登录操作系统的账号目录/.m2/repository
C:\Users\ly.m2\repository&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可修改
比如放在d盘中&lt;/p>
&lt;p>英[rɪˈpɒzətri]
D:\software\apache-maven-3.8.6\repository
备份并编辑
&lt;img src="img/ly-20241212142145669.png" alt="ly-20241212142145669" />
改成左斜杠的方式&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;settings&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/SETTINGS/1.2.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- localRepository
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> | The path to the local repository maven will use to store artifacts.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> |
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> | Default: ${user.home}/.m2/repository
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> &amp;lt;localRepository&amp;gt;/path/to/local/repo&amp;lt;/localRepository&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;localRepository&amp;gt;&lt;/span>D:/software/apache-maven-3.8.6/repository&lt;span style="color:#f92672">&amp;lt;/localRepository&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>把之前user下的repository的文件都拷贝到 D:/software/apache-maven-3.8.6/repository 下
然后再对Hello项目进行编译
&lt;code>mvn compile&lt;/code>
发现不会下载任何文件，且user下的repository也不会再进行下载&lt;/p>
&lt;/li>
&lt;li>
&lt;p>下面的资源是从maven中下载，或者用maven打包的
&lt;img src="img/ly-20241212142145849.png" alt="ly-20241212142145849" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>pom.xml来说明某个项目需要怎么处理代码、项目结构&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; ?&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;project&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span style="color:#f92672">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.bjpowernode&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>ch01-maven&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0-SNAPSHOT&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;packaging&amp;gt;&lt;/span>jar&lt;span style="color:#f92672">&amp;lt;/packaging&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;properties&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 		&lt;span style="color:#f92672">&amp;lt;java.version&amp;gt;&lt;/span>1.8&lt;span style="color:#f92672">&amp;lt;/java.version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 		&lt;span style="color:#f92672">&amp;lt;maven.compiler.source&amp;gt;&lt;/span>1.8&lt;span style="color:#f92672">&amp;lt;/maven.compiler.source&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 		&lt;span style="color:#f92672">&amp;lt;maven.compiler.target&amp;gt;&lt;/span>1.8&lt;span style="color:#f92672">&amp;lt;/maven.compiler.target&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/properties&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 		&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 				&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>mysql&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 				&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>mysql-connector-java&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 				&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>5.1.9&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 		&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/project&amp;gt;&lt;/span> 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>mvn命令需要在pom.xml所在的目录下执行
&lt;img src="img/ly-20241212142145908.png" alt="ly-20241212142145908" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="仓库的工作方式">
 仓库的工作方式
 &lt;a class="anchor" href="#%e4%bb%93%e5%ba%93%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%96%b9%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142145966.png" alt="ly-20241212142145966" />&lt;/p></description></item><item><title>01-16 maven基础_动力节点</title><link>https://lwmfjc.github.io/zh/docs/technology/Maven/base_dljd/01-16/</link><pubDate>Sat, 02 Jul 2022 18:58:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Maven/base_dljd/01-16/</guid><description>&lt;h2 id="课程介绍">
 课程介绍
 &lt;a class="anchor" href="#%e8%af%be%e7%a8%8b%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>maven 自动化构建&amp;ndash;&amp;gt;开发&amp;ndash;编译&amp;ndash;运行-测试&amp;ndash;打包&amp;ndash;部署 （m ei &amp;rsquo; ven）&lt;/li>
&lt;/ul>
&lt;h2 id="maven的作用">
 maven的作用
 &lt;a class="anchor" href="#maven%e7%9a%84%e4%bd%9c%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>软件是一个&lt;strong>工程&lt;/strong>&lt;/li>
&lt;li>软件中重复的操作（开发阶段）
&lt;ul>
&lt;li>需求分析&lt;/li>
&lt;li>设计阶段&lt;/li>
&lt;li>开发阶段（编码），编译，测试&lt;/li>
&lt;li>测试阶段（专业测试），测试报告&lt;/li>
&lt;li>项目打包，发布，给客户安装项目&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>maven
&lt;ul>
&lt;li>项目自动构建，清理、编译、测试、打包、安装、部署&lt;/li>
&lt;li>管理依赖：项目中需要使用的其他资源&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="maven中的概念">
 Maven中的概念
 &lt;a class="anchor" href="#maven%e4%b8%ad%e7%9a%84%e6%a6%82%e5%bf%b5">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>没有使用maven，管理jar，手动处理jar，以及jar之间的依赖&lt;/li>
&lt;li>maven是apache 【əˈpætʃi】基金会的开源项目，使用java语法开发&lt;/li>
&lt;li>maven是项目的自动化构建工具，管理项目依赖&lt;/li>
&lt;li>maven中的概念
&lt;ul>
&lt;li>POM&lt;/li>
&lt;li>约定的目录&lt;/li>
&lt;li>坐标&lt;/li>
&lt;li>依赖管理&lt;/li>
&lt;li>仓库管理&lt;/li>
&lt;li>生命周期&lt;/li>
&lt;li>插件和目标&lt;/li>
&lt;li>继承 （高级内容）&lt;/li>
&lt;li>聚合 （高级内容）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="maven资源的获取与安装测试">
 Maven资源的获取与安装，测试
 &lt;a class="anchor" href="#maven%e8%b5%84%e6%ba%90%e7%9a%84%e8%8e%b7%e5%8f%96%e4%b8%8e%e5%ae%89%e8%a3%85%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://maven.apache.org/index.html">https://maven.apache.org/index.html&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>各种内容
&lt;img src="img/ly-20241212142144318.png" alt="ly-20241212142144318" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>要求
&lt;img src="img/ly-20241212142144503.png" alt="ly-20241212142144503" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>视频用的3.6.3 ，这里下载3.8.6 （最新的，不要和电脑原配置冲突，方便学习，后续改回3.8.4）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>检查java home
&lt;img src="img/ly-20241212142144566.png" alt="ly-20241212142144566" />&lt;/p>
&lt;ul>
&lt;li>如果没有需要进行配置
&lt;img src="img/ly-20241212142144629.png" alt="ly-20241212142144629" />&lt;/li>
&lt;li>&lt;img src="img/ly-20241212142144689.png" alt="ly-20241212142144689" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>将maven的bin目录配置到path环境变量下（这里使用的是下一节的方法，视频中没有用MAVEN_HOME，而是直接将maven的bin目录路径加到path中）
&lt;img src="img/ly-20241212142144751.png" alt="ly-20241212142144751" />&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142144812.png" alt="ly-20241212142144812" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>maven解压后的目录结构
&lt;img src="img/ly-20241212142144869.png" alt="ly-20241212142144869" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="另一种安装方式">
 另一种安装方式
 &lt;a class="anchor" href="#%e5%8f%a6%e4%b8%80%e7%a7%8d%e5%ae%89%e8%a3%85%e6%96%b9%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>确定JAVA_HOME是否有效&lt;/li>
&lt;li>创建M2_HOME(MAVEN_HOME)，值为maven的安装目录&lt;/li>
&lt;li>在path环境中，加入%M2_HOME%\bin&lt;/li>
&lt;li>测试maven安装 mvn -v&lt;/li>
&lt;/ul>
&lt;h2 id="约定的目录结构">
 约定的目录结构
 &lt;a class="anchor" href="#%e7%ba%a6%e5%ae%9a%e7%9a%84%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>大多数人遵守的目录结构&lt;/p></description></item><item><title>52-X</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/52-x/</link><pubDate>Sun, 26 Jun 2022 14:16:17 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/52-x/</guid><description>&lt;h2 id="crond快速入门">
 crond快速入门
 &lt;a class="anchor" href="#crond%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>使用命令
crontab -e 创建一个定时任务&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>*/1 * * * * ls -l /etc/ &amp;gt; /tmp/to.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>特殊符号
，代表不连续
-破折号 表示连续
&lt;img src="img/ly-20241212142139460.png" alt="ly-20241212142139460" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其他
&lt;img src="img/ly-20241212142139656.png" alt="ly-20241212142139656" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>定时调用脚本&lt;/p>
&lt;ul>
&lt;li>
&lt;p>编辑脚本
my.sh&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>date &amp;gt;&amp;gt; /home/mycal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date &amp;gt;&amp;gt; /home/mycal
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>给脚本赋予x权限&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>chmod u+x my.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>crontab -e&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>*/1 * * * * my.sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>数据库备份
&lt;img src="img/ly-20241212142139724.png" alt="ly-20241212142139724" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>crontab -r 删除&lt;/p>
&lt;/li>
&lt;li>
&lt;p>crontab -l 列出&lt;/p>
&lt;/li>
&lt;li>
&lt;p>crontab -e 编辑任务&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>atd 是否在运行
yum install -y atd
systemctl start atd&lt;/p>
&lt;/li>
&lt;li>
&lt;p>job队列
&lt;img src="img/ly-20241212142139792.png" alt="ly-20241212142139792" />&lt;/p></description></item><item><title>linux_韩老师_40-51</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/40-51/</link><pubDate>Sat, 25 Jun 2022 17:56:21 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/40-51/</guid><description>&lt;h2 id="组介绍">
 组介绍
 &lt;a class="anchor" href="#%e7%bb%84%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>每个用户必定属于某个组&lt;/li>
&lt;li>每个文件有几个概念：所有者、所在组、其他组
tom创建了hello.txt，则所有者为tom，默认所在组为tom组
除了所在组，就是其他组&lt;/li>
&lt;li>ls -ahl （h更友好，a隐藏，l列表）&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="所有者">
 所有者
 &lt;a class="anchor" href="#%e6%89%80%e6%9c%89%e8%80%85">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>使用chown root helo.java 修改，效果如下
&lt;img src="img/ly-20241212142138913.png" alt="ly-20241212142138913" />&lt;/li>
&lt;/ul>
&lt;h2 id="所在组修改">
 所在组修改
 &lt;a class="anchor" href="#%e6%89%80%e5%9c%a8%e7%bb%84%e4%bf%ae%e6%94%b9">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>组的创建
groupadd monster&lt;/li>
&lt;li>创建一个用户并让他属于该组
useradd -g monster fox&lt;/li>
&lt;li>注意逻辑，此时使用fox创建文件
passwd fox 给fox创建密码&lt;/li>
&lt;li>如图，创建一个文件
&lt;img src="img/ly-20241212142139110.png" alt="ly-20241212142139110" />&lt;/li>
&lt;li>使用chgrp fruit orange.txt
修改文件的所在组
&lt;img src="img/ly-20241212142139179.png" alt="ly-20241212142139179" />&lt;/li>
&lt;li>改变某个用户所在组
usermod -g fruit fox
&lt;img src="img/ly-20241212142139244.png" alt="ly-20241212142139244" />&lt;/li>
&lt;li>使用 cat /etc/group 查看所有的组&lt;/li>
&lt;li>当一个用户属于多个组的时候，groups会出现多个组名&lt;/li>
&lt;/ul>
&lt;h2 id="rwx权限">
 rwx权限
 &lt;a class="anchor" href="#rwx%e6%9d%83%e9%99%90">#&lt;/a>
&lt;/h2>
&lt;p>rwxrwxrwx
第一列有十位，第0位确认文件类型
-普通文件，l是链接；d是目录；c是字符设备文件、鼠标、键盘；b块设备
1-3表示文件所有者拥有的权限；4-6是文件所在组所拥有的权限，7-9 其他组所拥有的权限&lt;/p>
&lt;ul>
&lt;li>rwx作用到文件，r代表可读可查看，w代表可修改（如果是删除权限，则必须在该文件所在的目录有写权限，才能删除），x代表可执行&lt;/li>
&lt;li>rwx作用到目录，r表示可以读取(ls可查看目录内容)，w表示可写（可以在目录内创建、删除、重命名目录），x表示可以进入该目录&lt;/li>
&lt;li>rwx分别用数字表示，4，2，1。当拥有所有权限，则为7&lt;/li>
&lt;li>&lt;img src="img/ly-20241212142139311.png" alt="ly-20241212142139311" />
&lt;ul>
&lt;li>最后面的数字，代表连接数（或者子目录数）&lt;/li>
&lt;li>1213 文件大小（字节），如果是文件夹则显示4096&lt;/li>
&lt;li>最后abc表示文件名，蓝色表示是目录&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="修改权限">
 修改权限
 &lt;a class="anchor" href="#%e4%bf%ae%e6%94%b9%e6%9d%83%e9%99%90">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>chmod 修改权限，u：所有者，g：所有组，o：其他人，a 所有（ugo总和）&lt;/li>
&lt;li>chmod u=rwx,g=rw,o=x 文件/目录名
这里等号表示直接给权限&lt;/li>
&lt;li>chmod o+w 文件/目录名
这里加表示+权限&lt;/li>
&lt;li>chmod a-x 文件/目录名&lt;/li>
&lt;li>chmod u=rwx,g=rx,o=rx abc 给文件添加执行权限（会变成绿色的）&lt;/li>
&lt;li>使用数字
&lt;ul>
&lt;li>将abc.txt文件权限修改成rwxr-xr-x使用数字实现
chmod 755 abc&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="修改所有者和所在组">
 修改所有者和所在组
 &lt;a class="anchor" href="#%e4%bf%ae%e6%94%b9%e6%89%80%e6%9c%89%e8%80%85%e5%92%8c%e6%89%80%e5%9c%a8%e7%bb%84">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>chown tom abc #修改文件所有者为tom&lt;/li>
&lt;li>chown -R tom abc #修改文件夹及其所有子目录所有者为tom&lt;/li>
&lt;li>chgrp -R fruit kkk #修改文件夹所在组为fruit&lt;/li>
&lt;/ul>
&lt;h2 id="权限管理应用实例">
 权限管理应用实例
 &lt;a class="anchor" href="#%e6%9d%83%e9%99%90%e7%ae%a1%e7%90%86%e5%ba%94%e7%94%a8%e5%ae%9e%e4%be%8b">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>警察和土匪的游戏&lt;/p></description></item><item><title>mysql高阶_sgg 96-00</title><link>https://lwmfjc.github.io/zh/docs/technology/MySQL/bl_sgg/96-00/</link><pubDate>Wed, 15 Jun 2022 21:13:03 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/MySQL/bl_sgg/96-00/</guid><description>&lt;h1 id="章节概述">
 章节概述
 &lt;a class="anchor" href="#%e7%ab%a0%e8%8a%82%e6%a6%82%e8%bf%b0">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>架构篇&lt;/p>
&lt;ul>
&lt;li>1-3
&lt;img src="img/ly-20241212142152374.png" alt="ly-20241212142152374" />&lt;/li>
&lt;li>4
&lt;img src="img/ly-20241212142152554.png" alt="ly-20241212142152554" />&lt;/li>
&lt;li>5
&lt;img src="img/ly-20241212142152607.png" alt="ly-20241212142152607" />&lt;/li>
&lt;li>6
&lt;img src="img/ly-20241212142152666.png" alt="ly-20241212142152666" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>索引及调优篇&lt;/p>
&lt;ul>
&lt;li>
&lt;p>01
&lt;img src="img/ly-20241212142152801.png" alt="ly-20241212142152801" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>02-03&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142152853.png" alt="ly-20241212142152853" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>04-05&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142152904.png" alt="ly-20241212142152904" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>06
&lt;img src="img/ly-20241212142152953.png" alt="ly-20241212142152953" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>事务篇&lt;/p>
&lt;ul>
&lt;li>01-02
&lt;img src="img/ly-20241212142153001.png" alt="ly-20241212142153001" />&lt;/li>
&lt;li>03
&lt;img src="img/ly-20241212142153044.png" alt="ly-20241212142153044" />&lt;/li>
&lt;li>04
&lt;img src="img/ly-20241212142153090.png" alt="ly-20241212142153090" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>日志与备份篇&lt;/p>
&lt;ul>
&lt;li>01
&lt;img src="img/ly-20241212142153137.png" alt="ly-20241212142153137" />&lt;/li>
&lt;li>02
&lt;img src="img/ly-20241212142153183.png" alt="ly-20241212142153183" />&lt;/li>
&lt;li>03
&lt;img src="img/ly-20241212142153231.png" alt="ly-20241212142153231" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="centos环境准备">
 CentOS环境准备
 &lt;a class="anchor" href="#centos%e7%8e%af%e5%a2%83%e5%87%86%e5%a4%87">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>这里主要是做了克隆，并没有讲到CentOS的安装，所以笔记不记录了&lt;/li>
&lt;/ul>
&lt;h1 id="mysql的卸载">
 MySQL的卸载
 &lt;a class="anchor" href="#mysql%e7%9a%84%e5%8d%b8%e8%bd%bd">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>查找当前系统已经装了哪些
&lt;code>rpm -qa |grep mysql&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查找mysql服务运行状态
&lt;code>systemctl status mysql&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>停止mysql服务
&lt;code>systemctl stop mysql&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>删除&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>yum remove mysql-community-client-plugins-8.0.29-1.el7.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum remove mysql-community-common-8.0.29-1.el7.x86_64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>查找带mysql名字的文件夹
&lt;code>find / -name mysql&lt;/code>&lt;/p></description></item><item><title>算法红皮书 3.2.1</title><link>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/3.2.1/</link><pubDate>Sun, 12 Jun 2022 22:09:27 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/3.2.1/</guid><description>&lt;h2 id="二叉查找树">
 二叉查找树
 &lt;a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>使用每个结点含有两个链接（链表中每个结点只含有一个链接）的二叉查找树来高效地实现符号表&lt;/p>
&lt;/li>
&lt;li>
&lt;p>该数据结构由结点组成，结点包含的链接可以为空(null)或者指向其他结点&lt;/p>
&lt;/li>
&lt;li>
&lt;blockquote>
&lt;p>一棵二叉查找树（BST）是一棵二叉树，其中每个结点都含有一个Comparable 的键（以
及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;img src="img/ly-20241212142101353.png" alt="ly-20241212142101353" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="基本实现">
 基本实现
 &lt;a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e5%ae%9e%e7%8e%b0">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>数据表示&lt;/p>
&lt;ul>
&lt;li>每个结点都含有一个键、一个值、一条左链接、一条右链接和一个结点计数器
左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该节点的所有键组成的二叉查找树，变量N给出了以该结点为根的子树的结点总数&lt;/li>
&lt;li>对于任意节点总是成立
size(x)=size(x.left)+size(x.right)+1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>多棵二叉查找树表示同一组有序的键来实现构建和使用二叉查找树的高校算法
&lt;img src="img/ly-20241212142101579.png" alt="ly-20241212142101579" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查找&lt;/p>
&lt;ul>
&lt;li>在符号表中查找一个键可能得到两种结果：如果含有该键的结点存在表中，我们的查找就命中了，然后返回值；否则查找未命中（返回null)&lt;/li>
&lt;li>递归：如果树是空的，则查找未命中；如果被查找的键和根节点的键相等，查找命中，否则在适当的子树中查找：如果被查找的键较小就选择左子树，否则选择右子树&lt;/li>
&lt;li>下面的get()方法，第一个参数是一个结点（子树根节点），第二个参数是被查找的键，代码会保证只有该结点所表示的子树才会含有和被查找的键相等的结点&lt;/li>
&lt;li>从根结点开始，在每个结点中查找的进程都会递归地在它的一个子结点上展开，因此一次查找也就定义了树的一条路径。对于命中的查找，路径在含有被查找的键的结点处结束。对于未命中的查找，路径的终点是一个空链接
&lt;img src="img/ly-20241212142101684.png" alt="ly-20241212142101684" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>基于二叉查找树的符号表&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BST&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Key &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;lt;&lt;/span>Key&lt;span style="color:#f92672">&amp;gt;&lt;/span>, Value&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> Node root;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// 二叉查找树的根结点&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">private&lt;/span> Key key;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 键&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">private&lt;/span> Value val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">private&lt;/span> Node left, right;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 指向子树的链接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> N;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 以该结点为根的子树中的结点总数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Node&lt;/span>(Key key, Value val, &lt;span style="color:#66d9ef">int&lt;/span> N)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">key&lt;/span> &lt;span style="color:#f92672">=&lt;/span> key;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">val&lt;/span> &lt;span style="color:#f92672">=&lt;/span> val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">N&lt;/span> &lt;span style="color:#f92672">=&lt;/span> N;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">size&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> size(root);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">size&lt;/span>(Node x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">if&lt;/span> (x &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> 0; &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> x.&lt;span style="color:#a6e22e">N&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> Value &lt;span style="color:#a6e22e">get&lt;/span>(Key key)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// 请见算法3.3（续1）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">put&lt;/span>(Key key, Value val)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// 请见算法3.3（续1）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// max()、min()、floor()、ceiling()方法请见算法3.3（续2）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// select()、rank()方法请见算法3.3（续3）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// delete()、deleteMin()、deleteMax()方法请见算法3.3（续4）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// keys()方法请见算法3.3（续5）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>每个Node 对象都是一棵含有N 个结点的子树的根结点，它的左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找
树。root 变量指向二叉查找树的根结点Node 对象（这棵树包含了符号表中的所有键值对）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>二叉查找树的查找和排序方法的实现&lt;/p></description></item><item><title>mybatis-plus-sgg-40-57</title><link>https://lwmfjc.github.io/zh/docs/technology/MyBatis-Plus/bl_sgg/40-57/</link><pubDate>Sat, 04 Jun 2022 11:49:54 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/MyBatis-Plus/bl_sgg/40-57/</guid><description>&lt;h2 id="lambdaxxxwrapper">
 LambdaXxxWrapper
 &lt;a class="anchor" href="#lambdaxxxwrapper">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>LambdaQueryWrapper主要是为了防止字段名写错&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">test11&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String username&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;abc&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Integer ageBegin&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Integer ageEnd&lt;span style="color:#f92672">=&lt;/span>30;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LambdaQueryWrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>User&lt;span style="color:#f92672">&amp;gt;&lt;/span> queryWrapper&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> LambdaQueryWrapper&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queryWrapper.&lt;span style="color:#a6e22e">like&lt;/span>(StringUtils.&lt;span style="color:#a6e22e">isNotBlank&lt;/span>(username),User::getUserName,username)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">ge&lt;/span>(ageBegin&lt;span style="color:#f92672">!=&lt;/span>&lt;span style="color:#66d9ef">null&lt;/span>,User::getAge,ageBegin);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> userMapper.&lt;span style="color:#a6e22e">selectList&lt;/span>(queryWrapper);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>sql日志打印&lt;/p>
&lt;pre tabindex="0">&lt;code>==&amp;gt; Preparing: SELECT uid AS id,name AS userName,age,email,is_deleted_ly FROM t_user WHERE is_deleted_ly=0 AND (name LIKE ?)
==&amp;gt; Parameters: %abc%(String)
&amp;lt;== Total: 0
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>LambdaUpdateWrapper&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">test12&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//(age&amp;gt;23且用户名包含a) 或 (邮箱为null)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LambdaUpdateWrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>User&lt;span style="color:#f92672">&amp;gt;&lt;/span> updateWrapper &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LambdaUpdateWrapper&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updateWrapper.&lt;span style="color:#a6e22e">like&lt;/span>(User::getUserName, &lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">and&lt;/span>(userUpdateWrapper &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> userUpdateWrapper.&lt;span style="color:#a6e22e">gt&lt;/span>(User::getAge, 23).&lt;span style="color:#a6e22e">or&lt;/span>().&lt;span style="color:#a6e22e">isNotNull&lt;/span>(User::getEmail));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updateWrapper.&lt;span style="color:#a6e22e">set&lt;/span>(User::getUserName, &lt;span style="color:#e6db74">&amp;#34;小黑&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">set&lt;/span>(User::getEmail, &lt;span style="color:#e6db74">&amp;#34;abc@ly.com&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> userMapper.&lt;span style="color:#a6e22e">update&lt;/span>(&lt;span style="color:#66d9ef">null&lt;/span>, updateWrapper);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>sql日志打印&lt;/p></description></item><item><title>mybatis-plus-sgg-19-39</title><link>https://lwmfjc.github.io/zh/docs/technology/MyBatis-Plus/bl_sgg/19-39/</link><pubDate>Fri, 03 Jun 2022 11:54:42 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/MyBatis-Plus/bl_sgg/19-39/</guid><description>&lt;h2 id="通用service应用">
 通用Service应用
 &lt;a class="anchor" href="#%e9%80%9a%e7%94%a8service%e5%ba%94%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>这里会出现 publicKey is now allowed ，在数据库连接语句后面加上这句话即可
allowPublicKeyRetrieval=true&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spring&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#配置数据源&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">datasource&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#配置数据源类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">com.zaxxer.hikari.HikariDataSource&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#配置数据源各个信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">driver-class-name&lt;/span>: &lt;span style="color:#ae81ff">com.mysql.cj.jdbc.Driver&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;amp;&amp;amp;useSSL=false&amp;amp;&amp;amp;allowPublicKeyRetrieval=true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">username&lt;/span>: &lt;span style="color:#ae81ff">root&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">password&lt;/span>: &lt;span style="color:#ae81ff">123456&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>查询&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">testList&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//List&amp;lt;User&amp;gt; list = userService.list();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> userService.&lt;span style="color:#a6e22e">count&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;总条数：&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>count);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SQL执行语句&lt;/p>
&lt;pre tabindex="0">&lt;code>==&amp;gt; Preparing: SELECT COUNT( * ) FROM user
==&amp;gt; Parameters: 
&amp;lt;== Columns: COUNT( * )
&amp;lt;== Row: 5
&amp;lt;== Total: 1
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>批量添加&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">batchInsert&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>User&lt;span style="color:#f92672">&amp;gt;&lt;/span> users&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>0;i&lt;span style="color:#f92672">&amp;lt;&lt;/span>10;i&lt;span style="color:#f92672">++&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> User user&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> User();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.&lt;span style="color:#a6e22e">setName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> user.&lt;span style="color:#a6e22e">setEmail&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;email&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> users.&lt;span style="color:#a6e22e">add&lt;/span>(user);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> userService.&lt;span style="color:#a6e22e">saveBatch&lt;/span>(users);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;result:&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>sql日志输出&lt;/p></description></item><item><title>mybatis-plus-sgg-12-18</title><link>https://lwmfjc.github.io/zh/docs/technology/MyBatis-Plus/bl_sgg/12-18/</link><pubDate>Fri, 03 Jun 2022 08:15:52 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/MyBatis-Plus/bl_sgg/12-18/</guid><description>&lt;h2 id="basemapper">
 BaseMapper
 &lt;a class="anchor" href="#basemapper">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>注：使用 &lt;code>mvn dependency:resolve -Dclassifier=sources&lt;/code> 来获得mapper源码&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一些接口介绍&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 插入一条记录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param entity 实体对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">insert&lt;/span>(T entity);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 ID 删除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param id 主键ID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">deleteById&lt;/span>(Serializable id);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据实体(ID)删除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param entity 实体对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @since 3.4.4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">deleteById&lt;/span>(T entity);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 columnMap 条件，删除记录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param columnMap 表字段 map 对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">deleteByMap&lt;/span>(&lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">COLUMN_MAP&lt;/span>) Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> columnMap);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 entity 条件，删除记录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param queryWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">delete&lt;/span>(&lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">WRAPPER&lt;/span>) Wrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> queryWrapper);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 删除（根据ID或实体 批量删除）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param idList 主键ID列表或实体列表(不能为 null 以及 empty)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">deleteBatchIds&lt;/span>(&lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">COLLECTION&lt;/span>) Collection&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> idList);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 ID 修改
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param entity 实体对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">updateById&lt;/span>(&lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">ENTITY&lt;/span>) T entity);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 whereEntity 条件，更新记录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param entity 实体对象 (set 条件值,可以为 null)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">update&lt;/span>(&lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">ENTITY&lt;/span>) T entity, &lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">WRAPPER&lt;/span>) Wrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> updateWrapper);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 ID 查询
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param id 主键ID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T &lt;span style="color:#a6e22e">selectById&lt;/span>(Serializable id);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 查询（根据ID 批量查询）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param idList 主键ID列表(不能为 null 以及 empty)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">selectBatchIds&lt;/span>(&lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">COLLECTION&lt;/span>) Collection&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Serializable&lt;span style="color:#f92672">&amp;gt;&lt;/span> idList);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 查询（根据 columnMap 条件）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param columnMap 表字段 map 对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">selectByMap&lt;/span>(&lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">COLUMN_MAP&lt;/span>) Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> columnMap);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 entity 条件，查询一条记录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;查询一条记录，例如 qw.last(&amp;#34;limit 1&amp;#34;) 限制取一条记录, 注意：多条数据会报异常&amp;lt;/p&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param queryWrapper 实体对象封装操作类（可以为 null）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> T &lt;span style="color:#a6e22e">selectOne&lt;/span>(&lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">WRAPPER&lt;/span>) Wrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> queryWrapper) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> ts &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">selectList&lt;/span>(queryWrapper);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (CollectionUtils.&lt;span style="color:#a6e22e">isNotEmpty&lt;/span>(ts)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (ts.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">!=&lt;/span> 1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> ExceptionUtils.&lt;span style="color:#a6e22e">mpe&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;One record is expected, but the query result is multiple records&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ts.&lt;span style="color:#a6e22e">get&lt;/span>(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 Wrapper 条件，判断是否存在记录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param queryWrapper 实体对象封装操作类
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @return
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">exists&lt;/span>(Wrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> queryWrapper) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Long count &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">selectCount&lt;/span>(queryWrapper);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> count &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> count &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 Wrapper 条件，查询总记录数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param queryWrapper 实体对象封装操作类（可以为 null）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Long &lt;span style="color:#a6e22e">selectCount&lt;/span>(&lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">WRAPPER&lt;/span>) Wrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> queryWrapper);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 entity 条件，查询全部记录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param queryWrapper 实体对象封装操作类（可以为 null）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">selectList&lt;/span>(&lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">WRAPPER&lt;/span>) Wrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> queryWrapper);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 Wrapper 条件，查询全部记录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param queryWrapper 实体对象封装操作类（可以为 null）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">selectMaps&lt;/span>(&lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">WRAPPER&lt;/span>) Wrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> queryWrapper);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 Wrapper 条件，查询全部记录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;注意： 只返回第一个字段的值&amp;lt;/p&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param queryWrapper 实体对象封装操作类（可以为 null）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">selectObjs&lt;/span>(&lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">WRAPPER&lt;/span>) Wrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> queryWrapper);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 entity 条件，查询全部记录（并翻页）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param page 分页查询条件（可以为 RowBounds.DEFAULT）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param queryWrapper 实体对象封装操作类（可以为 null）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>P &lt;span style="color:#66d9ef">extends&lt;/span> IPage&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> P &lt;span style="color:#a6e22e">selectPage&lt;/span>(P page, &lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">WRAPPER&lt;/span>) Wrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> queryWrapper);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 根据 Wrapper 条件，查询全部记录（并翻页）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param page 分页查询条件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param queryWrapper 实体对象封装操作类
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>P &lt;span style="color:#66d9ef">extends&lt;/span> IPage&lt;span style="color:#f92672">&amp;lt;&lt;/span>Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, Object&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> P &lt;span style="color:#a6e22e">selectMapsPage&lt;/span>(P page, &lt;span style="color:#a6e22e">@Param&lt;/span>(Constants.&lt;span style="color:#a6e22e">WRAPPER&lt;/span>) Wrapper&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> queryWrapper);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>BaseMapper测试&lt;/p></description></item><item><title>mybatis-plus-sgg-01-11</title><link>https://lwmfjc.github.io/zh/docs/technology/MyBatis-Plus/bl_sgg/01-11/</link><pubDate>Fri, 03 Jun 2022 06:47:06 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/MyBatis-Plus/bl_sgg/01-11/</guid><description>&lt;h2 id="简介">
 简介
 &lt;a class="anchor" href="#%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>MyBatis-Plus是一个MyBatis的&lt;strong>增强工具&lt;/strong>，在MyBatis的基础上&lt;strong>只做增强不做改变&lt;/strong>，为&lt;strong>简化开发、提高效率&lt;/strong>而生&lt;/li>
&lt;li>这里以MySQL数据库为案例，以Idea作为IDE，使用Maven作为构建工具，使用SpringBoot完成各种功能&lt;/li>
&lt;li>课程主要内容
&lt;img src="img/ly-20241212142149716.png" alt="ly-20241212142149716" />&lt;/li>
&lt;li>特性 润物无声、效率至上、丰富功能&lt;/li>
&lt;li>支持的数据库
&lt;img src="img/ly-20241212142149893.png" alt="ly-20241212142149893" />&lt;/li>
&lt;li>框架结构
&lt;img src="img/ly-20241212142149948.png" alt="ly-20241212142149948" />
&lt;ul>
&lt;li>左边：扫描实体，从实体抽取属性猜测数据库字段&lt;/li>
&lt;li>通过默认提供的方法使用sql语句，然后注入mybatis容器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="开发环境">
 开发环境
 &lt;a class="anchor" href="#%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142150006.png" alt="ly-20241212142150006" />&lt;/p>
&lt;h2 id="测试数据库和表">
 测试数据库和表
 &lt;a class="anchor" href="#%e6%b5%8b%e8%af%95%e6%95%b0%e6%8d%ae%e5%ba%93%e5%92%8c%e8%a1%a8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>这里创建数据库mybatis_plus&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后创建表user&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id &lt;span style="color:#66d9ef">BIGINT&lt;/span>(&lt;span style="color:#ae81ff">20&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> COMMENT &lt;span style="color:#e6db74">&amp;#39;主键ID&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name &lt;span style="color:#66d9ef">VARCHAR&lt;/span>(&lt;span style="color:#ae81ff">30&lt;/span>) &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> COMMENT &lt;span style="color:#e6db74">&amp;#39;姓名&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> age &lt;span style="color:#66d9ef">INT&lt;/span>(&lt;span style="color:#ae81ff">11&lt;/span>) &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> COMMENT &lt;span style="color:#e6db74">&amp;#39;年龄&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> email &lt;span style="color:#66d9ef">VARCHAR&lt;/span>(&lt;span style="color:#ae81ff">50&lt;/span>) &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> COMMENT &lt;span style="color:#e6db74">&amp;#39;邮箱&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> (id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>插入默认数据&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">DELETE&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span> (id, name, age, email) &lt;span style="color:#66d9ef">VALUES&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;Jone&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">18&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test1@baomidou.com&amp;#39;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;Jack&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test2@baomidou.com&amp;#39;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;Tom&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">28&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test3@baomidou.com&amp;#39;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;Sandy&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">21&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test4@baomidou.com&amp;#39;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;Billie&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">24&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test5@baomidou.com&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="spring-boot工程">
 Spring Boot工程
 &lt;a class="anchor" href="#spring-boot%e5%b7%a5%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;p>添加依赖，并install Lombok 插件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;parent&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.boot&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-boot-starter-parent&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>2.7.0&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;relativePath/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/parent&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.boot&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-boot-starter&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.boot&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-boot-starter-test&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>test&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.baomidou&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>mybatis-plus-boot-starter&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>3.5.1&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>mysql&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>mysql-connector-java&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>8.0.29&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.projectlombok&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>lombok&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.18.24&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>provided&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-generator --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.baomidou&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>mybatis-plus-generator&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>3.5.2&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="基础配置">
 基础配置
 &lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80%e9%85%8d%e7%bd%ae">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>创建spring boot启动类&lt;/p></description></item><item><title>算法红皮书 3.1.1-3.1.7</title><link>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/3.1.1-3.1.7/</link><pubDate>Tue, 31 May 2022 23:52:57 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/3.1.1-3.1.7/</guid><description>&lt;h1 id="查找">
 查找
 &lt;a class="anchor" href="#%e6%9f%a5%e6%89%be">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>经典查找算法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用&lt;strong>符号表&lt;/strong>这个词来描述抽象的表格，将信息（值）存储在其中，然后按照指定的&lt;strong>键&lt;/strong>来获取这些信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>符号表也被称为&lt;strong>字典&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在英语字典里，键就是单词，值就是单词对应的定义、发音和词源&lt;/li>
&lt;li>符号表有时又叫索引&lt;/li>
&lt;li>在一本书的索引中，键就是术语，而值就是书中该术语出现的所有页码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>下面学习三种经典的数据类型：二叉查找树、红黑树和散列表&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="符号表">
 符号表
 &lt;a class="anchor" href="#%e7%ac%a6%e5%8f%b7%e8%a1%a8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>符号表最主要的目的是将&lt;strong>键&lt;/strong>和&lt;strong>值&lt;/strong>联系起来&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用例能够将一个键值对插入符号表并希望在之后能够从符号表的所有键值对中按照键直接找到相对应的值&lt;/p>
&lt;/li>
&lt;li>
&lt;blockquote>
&lt;p>符号表是一种存储键值对的数据结构，支持两种操作：&lt;strong>插入&lt;/strong>(put)，即将一组新的键值对存入表中；查找(get)，即根据给定的键得到相应的值&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>典型的符号表应用
&lt;img src="img/ly-20241212142100034.png" alt="ly-20241212142100034" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="api">
 API
 &lt;a class="anchor" href="#api">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>符号表是一种&lt;strong>典型的数据类型&lt;/strong> ：代表着一组定义清晰的值及相应的操作。使用应用程序编程接口（API）来精确地定义这些操作
一种简单的泛型符号表API ST(Symbol Table)
&lt;img src="img/ly-20241212142100261.png" alt="ly-20241212142100261" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>泛型
对于符号表，我们通过明确地指定查找时键和值的类型来区分它们的不同角色【key和value】&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重复的键&lt;/p>
&lt;ul>
&lt;li>这里假设每个键只对应着一个值（表中不允许重复值）&lt;/li>
&lt;li>当用例代码向表中存入的键值对和表中已有的键（及关联的值）冲突时，新的值会替代旧的值&lt;/li>
&lt;li>上述定义了关联数组的抽象形式，可以将符号表想象成数组，键即索引，值即数组中的值&lt;/li>
&lt;li>在一个关联数组中，键可以是任意类型，但我们仍然可以用它来快速访问数组的值&lt;/li>
&lt;li>非Java使用st[key]来替代st.get(key)，用st[key]=val来替代st.put(key,val)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>键不能为空&lt;/p>
&lt;/li>
&lt;li>
&lt;p>值不能为空（因为规定当键不存在时get()返回空）
当值为空表示删除&lt;/p>
&lt;/li>
&lt;li>
&lt;p>删除操作&lt;/p>
&lt;ul>
&lt;li>
&lt;p>延时删除，先将键对应的值置空，之后在某个时刻删除所有值为空的键&lt;/p>
&lt;/li>
&lt;li>
&lt;p>即时删除，立即从表中删除指定的键
put实现的开头：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span>(val &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delete(key);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>便捷方法
&lt;img src="img/ly-20241212142100362.png" alt="ly-20241212142100362" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>迭代
在API第一行加上&lt;code>implements Iterable&amp;lt;Key&amp;gt;&lt;/code> ，所有实现都包含iterator()方法来实现hasNext()和next()方法的迭代器；这里采用另一种方式：定义keys返回一个&lt;code>Iterable&amp;lt;Key&amp;gt;&lt;/code>对象以方便便利所有的键，且允许遍历一部分&lt;/p>
&lt;/li>
&lt;li>
&lt;p>键的等价性
自定义的键需要重写equals()方法；且最好使用不可变数据类型作为键&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="有序符号表">
 有序符号表
 &lt;a class="anchor" href="#%e6%9c%89%e5%ba%8f%e7%ac%a6%e5%8f%b7%e8%a1%a8">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>一种有序的泛型符号表的API
&lt;img src="img/ly-20241212142100464.png" alt="ly-20241212142100464" />&lt;/li>
&lt;li>最大值和最小值、向下取整和向上取整、排名和选择&lt;/li>
&lt;li>对于0到size()-1的所有i都有i==rank(select(i))，且所有的键都满足key == select(rank(key))&lt;/li>
&lt;li>范围查找&lt;/li>
&lt;li>例外情况
当一个方法需要返回一个键但表中没有合适的键可以返回时，我们约定抛出一个异常&lt;/li>
&lt;li>有序符号表中冗余有序性方法的默认实现
&lt;img src="img/ly-20241212142100610.png" alt="ly-20241212142100610" />&lt;/li>
&lt;li>所有Comparable类型中compareTo()方法和equals()方法的一致性&lt;/li>
&lt;li>★★成本模型
在学习符号表的实现时，我们会统计&lt;strong>比较的次数&lt;/strong>（等价性测试或是键的相互比较），在内循环**不进行比较（极少）**的情况下，我们会统计数组的访问次数&lt;/li>
&lt;/ul>
&lt;h3 id="用例举例">
 用例举例
 &lt;a class="anchor" href="#%e7%94%a8%e4%be%8b%e4%b8%be%e4%be%8b">#&lt;/a>
&lt;/h3>
&lt;p>如何使用&lt;/p></description></item><item><title>算法红皮书 2.5</title><link>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/2.5/</link><pubDate>Sun, 29 May 2022 22:20:39 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/2.5/</guid><description>&lt;ul>
&lt;li>排序如此有用的原因是，在有序的数组中查找一个元素，要比在一个无序的数组中查找简单得多&lt;/li>
&lt;li>通用排序算法是最重要的&lt;/li>
&lt;li>算法思想虽然简单，但是适用领域广泛&lt;/li>
&lt;/ul>
&lt;h2 id="将各种数据排序">
 将各种数据排序
 &lt;a class="anchor" href="#%e5%b0%86%e5%90%84%e7%a7%8d%e6%95%b0%e6%8d%ae%e6%8e%92%e5%ba%8f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Java的约定使得我们能够利用Java的回调机制将任意实现Comparable接口的数据类型排序&lt;/p>
&lt;ul>
&lt;li>我们的代码直接能够将String、Integer、Double 和一些其他例如File 和URL 类型的数组排序，因为它们都实现了Comparable 接口&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>交易事务
商业数据的处理，设想一家互联网商业公司为每笔交易记录都保存了所有的相关信息&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">compareTo&lt;/span>(Transaction that)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">when&lt;/span>.&lt;span style="color:#a6e22e">compareTo&lt;/span>(that.&lt;span style="color:#a6e22e">when&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>指针排序
我们使用的方法在经典教材中被称为&lt;strong>指针排序&lt;/strong>，因为我们只处理元素的引用而不移动数据本身&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不可变的键
用不可变的数据类型作为键，比如String、Integer、Double和File等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>廉价的交换&lt;/p>
&lt;ul>
&lt;li>
&lt;p>使用引用的另一个好处是不必移动整个元素对于几乎任意大小的元素，使用引用使得在一般情况下交换的成本和比较的成本几乎相同（代价是需要额外的空间存储这些引用）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>研究将数字排序的算法性能的一种方法就是观察其所需的比较和交换总数，因为这里隐式地假设了比较和交换的成本是相同的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>多种排序方法&lt;/p>
&lt;ul>
&lt;li>根据情况将一组对象按照不同的方式排序。Java 的Comparator 接口允许我们在一个类之中实现多种排序方法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>多键数组&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一个元素的多种属性都可能被用作排序的键&lt;/p>
&lt;ul>
&lt;li>我们可以定义多种比较器，要将Transaction 对象的数组按照时间排序可以调用：
Insertion.sort(a, new Transaction.WhenOrder())
或者这样来按照金额排序：
Insertion.sort(a, new Transaction.HowMuchOrder())&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>使用Comparator的插入排序&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sort&lt;/span>(Object&lt;span style="color:#f92672">[]&lt;/span> a, Comparator c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">int&lt;/span> N &lt;span style="color:#f92672">=&lt;/span> a.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> N; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> i; j &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> less(Comparator, a&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span>, a&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>); j&lt;span style="color:#f92672">--&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	exch(a, j, j&lt;span style="color:#f92672">-&lt;/span>1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Boolean &lt;span style="color:#a6e22e">less&lt;/span>(Comparator c, Object v, Object w)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">return&lt;/span> c.&lt;span style="color:#a6e22e">compare&lt;/span>(v, w) &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">exch&lt;/span>(Object&lt;span style="color:#f92672">[]&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> i, &lt;span style="color:#66d9ef">int&lt;/span> j)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Object t &lt;span style="color:#f92672">=&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	a&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用比较器实现优先队列&lt;/p></description></item><item><title>算法红皮书 2.4</title><link>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/2.4/</link><pubDate>Fri, 27 May 2022 22:43:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/2.4/</guid><description>&lt;h1 id="优先队列">
 优先队列
 &lt;a class="anchor" href="#%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97">#&lt;/a>
&lt;/h1>
&lt;ul>
&lt;li>有些情况下，不需要要求处理的元素全部有序，只要求每次都处理键值最大的元素，然后再收集更多的元素，然后再处理键值最大的元素&lt;/li>
&lt;li>需要一种数据结构，支持操作：删除最大元素和插入元素，这种数据类型叫做优先队列&lt;/li>
&lt;li>优先队列的基本表现形式：其一或两种操作都能在线性时间内完成&lt;/li>
&lt;li>基于&lt;strong>二叉堆数据结构&lt;/strong>的优先队列，用数组保存元素并按照一定条件排序，以实现高效的删除最大元素和插入元素&lt;/li>
&lt;/ul>
&lt;h2 id="api">
 API
 &lt;a class="anchor" href="#api">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>抽象数据类型，最重要的操作是删除最大元素和插入元素 delMax()和insert()&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用“最大元素”代替“最大键值”或是“键值最大的元素”&lt;/p>
&lt;/li>
&lt;li>
&lt;p>泛型优先队列的API
&lt;img src="img/ly-20241212142058095.png" alt="ly-20241212142058095" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>优先队列的调用示例
从N各输入中找到最大的M各元素所需成本
&lt;img src="img/ly-20241212142058324.png" alt="ly-20241212142058324" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>优先队列的用例
pq里面最多放5个，当大于5个的时候，就从中剔除1个&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TopM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 打印输入流中最大的M行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">int&lt;/span> M &lt;span style="color:#f92672">=&lt;/span> Integer.&lt;span style="color:#a6e22e">parseint&lt;/span>(args&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		MinPQ&lt;span style="color:#f92672">&amp;lt;&lt;/span>Transaction&lt;span style="color:#f92672">&amp;gt;&lt;/span> pq &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> MinPQ&lt;span style="color:#f92672">&amp;lt;&lt;/span>Transaction&lt;span style="color:#f92672">&amp;gt;&lt;/span>(M&lt;span style="color:#f92672">+&lt;/span>1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">while&lt;/span> (StdIn.&lt;span style="color:#a6e22e">hasNextLine&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">// 为下一行输入创建一个元素并放入优先队列中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			pq.&lt;span style="color:#a6e22e">insert&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> Transaction(StdIn.&lt;span style="color:#a6e22e">readLine&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">if&lt;/span> (pq.&lt;span style="color:#a6e22e">size&lt;/span>() &lt;span style="color:#f92672">&amp;gt;&lt;/span> M)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			 pq.&lt;span style="color:#a6e22e">delMin&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">// 如果优先队列中存在M+1个元素则删除其中最小的元素&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 最大的M个元素都在优先队列中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		Stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>Transaction&lt;span style="color:#f92672">&amp;gt;&lt;/span> stack &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>Transaction&lt;span style="color:#f92672">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>pq.&lt;span style="color:#a6e22e">isEmpty&lt;/span>()) stack.&lt;span style="color:#a6e22e">push&lt;/span>(pq.&lt;span style="color:#a6e22e">delMin&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">for&lt;/span> (Transaction t : stack) StdOut.&lt;span style="color:#a6e22e">println&lt;/span>(t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>应用
&lt;img src="img/ly-20241212142058429.png" alt="ly-20241212142058429" />&lt;/p></description></item><item><title>zsx_flowable_design01</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/zsx_design/01/</link><pubDate>Mon, 23 May 2022 17:17:04 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/zsx_design/01/</guid><description>&lt;ul>
&lt;li>
&lt;p>模型设计完后，下面三个表有变化&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142116933.png" alt="ly-20241212142116933" />&lt;/p>
&lt;ul>
&lt;li>act_cio_model
&lt;img src="img/ly-20241212142117063.png" alt="ly-20241212142117063" />&lt;/li>
&lt;li>act_cio_model_module_rel
&lt;img src="img/ly-20241212142117162.png" alt="ly-20241212142117162" />&lt;/li>
&lt;li>act_ge_bytearray
&lt;img src="img/ly-20241212142117254.png" alt="ly-20241212142117254" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>部署之后，四个表有变化
&lt;img src="img/ly-20241212142117340.png" alt="ly-20241212142117340" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>act_cio_deployment
多了39条记录
&lt;img src="img/ly-20241212142117428.png" alt="ly-20241212142117428" />&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142117516.png" alt="ly-20241212142117516" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>act_ge_bytearray
多了两条记录
&lt;img src="img/ly-20241212142117610.png" alt="ly-20241212142117610" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>act_re_deployment
多了一条记录
&lt;img src="img/ly-20241212142117704.png" alt="ly-20241212142117704" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>act_re_procdef
多了一条记录
&lt;img src="img/ly-20241212142117795.png" alt="ly-20241212142117795" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>流程开始运行&lt;/p>
&lt;ul>
&lt;li>下面只写上主要的几个表&lt;/li>
&lt;li>送审时这个结点只能选一个
&lt;img src="img/ly-20241212142117883.png" alt="ly-20241212142117883" />&lt;/li>
&lt;li>流程运行时变量表
&lt;img src="img/ly-20241212142117970.png" alt="ly-20241212142117970" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>linux_韩老师_28-39</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/28-39/</link><pubDate>Sun, 22 May 2022 22:14:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/28-39/</guid><description>&lt;h2 id="文件目录">
 文件目录
 &lt;a class="anchor" href="#%e6%96%87%e4%bb%b6%e7%9b%ae%e5%bd%95">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>用来定位绝对路径或相对路径
cd ~ 用来定位家目录
cd .. 返回上一级
cd - 返回上一次目录&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mkdir 用于创建目录
mkdir -p hello/l1/l2 多级目录创建&lt;/p>
&lt;/li>
&lt;li>
&lt;p>recursion 递归
rm -rf 要删除的目录 #递归删除&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用cp进行复制，加上 -r 进行递归复制&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rm 删除某个文件（带提示）&lt;/p>
&lt;ul>
&lt;li>rm -f 删除文件（不带提示）&lt;/li>
&lt;li>rm -rf 强制删除递归文件（夹）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>mv 用来重命名（移动到同一目录下）、（或者移动文件）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注意，下面的命令，是将hello移动到hello2下，并改名为a（而不是hello2下的a目录）
&lt;code>mv Hello.java hello2/a&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>mv Hello.java hello2/a/&lt;/code> 移动到hello2下的a目录下(最后有一个斜杠)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>移动目录&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>mv hello2 hello1/AB&lt;/code>
或者
&lt;code>mv hello2/ hello1/AB&lt;/code>&lt;/p>
&lt;p>或者
&lt;code>mv hello2/ hello1/AB/&lt;/code>&lt;/p>
&lt;p>会把整个hello2文件夹（包括hello2）移动到AB下&lt;/p>
&lt;/li>
&lt;li>
&lt;p>同样是上面的指令，如果AB不存在，那么就会将hello2移动到hello1下，并将hello2文件夹，改名为AB&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>cat 指令&lt;/p>
&lt;ul>
&lt;li>cat -p /etc/profile 浏览并显示文件&lt;/li>
&lt;li>管道命令
cat -p /etc/profile | more
把前面的结果再交给more处理
（输入enter查看下一行，空格查看下一页）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>less指令&lt;/p></description></item><item><title>linux_韩老师_21-33</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/21-27/</link><pubDate>Sun, 22 May 2022 13:04:55 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/21-27/</guid><description>&lt;h2 id="用户管理">
 用户管理
 &lt;a class="anchor" href="#%e7%94%a8%e6%88%b7%e7%ae%a1%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>使用&lt;code>ssh root@192.168.200.201&lt;/code>进行服务器连接
&lt;img src="img/ly-20241212142135612.png" alt="ly-20241212142135612" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>xshell中 ctr+shift+r 用来重新连接&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户解释图
&lt;img src="img/ly-20241212142135812.png" alt="ly-20241212142135812" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加一个用户milan，会自动创建该用户的家目录milan&lt;/p>
&lt;ul>
&lt;li>当登录该用户时，会自动切换到家目录下
&lt;img src="img/ly-20241212142135882.png" alt="ly-20241212142135882" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>指定家目录
&lt;img src="img/ly-20241212142135954.png" alt="ly-20241212142135954" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指定密码
&lt;img src="img/ly-20241212142136024.png" alt="ly-20241212142136024" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用milan登录，自动切换到/home/milan
pwd:显示当前用户所在的目录&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142136094.png" alt="ly-20241212142136094" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户删除&lt;/p>
&lt;ul>
&lt;li>删除用户但保留家目录
&lt;ul>
&lt;li>需要用超级管理员才能删除
&lt;img src="img/ly-20241212142136163.png" alt="ly-20241212142136163" />
使用&lt;code>su -u root&lt;/code>切换到超级管理员&lt;/li>
&lt;li>先logout然后再删除
&lt;img src="img/ly-20241212142136235.png" alt="ly-20241212142136235" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>删除用户及家目录
&lt;code>userdel -r milan&lt;/code>&lt;/li>
&lt;li>建议保留家目录&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>查询root用户信息&lt;/p>
&lt;ul>
&lt;li>使用&lt;code>id xx&lt;/code> 查询
&lt;img src="img/ly-20241212142136305.png" alt="ly-20241212142136305" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>切换用户 &lt;code>su - xx&lt;/code>&lt;/p>
&lt;ul>
&lt;li>从权限高切换到权限低的用户不需要密码；反之需要
&lt;img src="img/ly-20241212142136377.png" alt="ly-20241212142136377" />&lt;/li>
&lt;li>使用logout（exit也行），从root用户回到jack&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>查看当前用户
&lt;code>who am i &lt;/code>
&lt;img src="img/ly-20241212142136445.png" alt="ly-20241212142136445" />
即使切换了用户，返回的还是root（第一次登录时的用户)
&lt;img src="img/ly-20241212142136517.png" alt="ly-20241212142136517" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户组（角色）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>增加、删除组&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>groupadd wudang
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>groupdel wudang
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果添加用户的时候没有指定组，那么会创建一个跟用户名一样的名字的组
&lt;img src="img/ly-20241212142136586.png" alt="ly-20241212142136586" />
id是1002，组为king&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142136655.png" alt="ly-20241212142136655" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加用户zwj，添加组wudang，并将zwj添加到wudang组里面&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>groupadd wudang
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>useradd -g wudang zwj
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="img/ly-20241212142136719.png" alt="ly-20241212142136719" />&lt;/p></description></item><item><title>官方的hello-world</title><link>https://lwmfjc.github.io/zh/docs/technology/MyBatis-Plus/official/hello/</link><pubDate>Fri, 20 May 2022 17:16:29 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/MyBatis-Plus/official/hello/</guid><description>&lt;h2 id="简介">
 简介
 &lt;a class="anchor" href="#%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new window)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。&lt;/li>
&lt;/ul>
&lt;h2 id="快速开始">
 快速开始
 &lt;a class="anchor" href="#%e5%bf%ab%e9%80%9f%e5%bc%80%e5%a7%8b">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>数据库的Schema脚本 resources/db/schema-mysql.sql&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id &lt;span style="color:#66d9ef">BIGINT&lt;/span>(&lt;span style="color:#ae81ff">20&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> COMMENT &lt;span style="color:#e6db74">&amp;#39;主键ID&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name &lt;span style="color:#66d9ef">VARCHAR&lt;/span>(&lt;span style="color:#ae81ff">30&lt;/span>) &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> COMMENT &lt;span style="color:#e6db74">&amp;#39;姓名&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> age &lt;span style="color:#66d9ef">INT&lt;/span>(&lt;span style="color:#ae81ff">11&lt;/span>) &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> COMMENT &lt;span style="color:#e6db74">&amp;#39;年龄&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> email &lt;span style="color:#66d9ef">VARCHAR&lt;/span>(&lt;span style="color:#ae81ff">50&lt;/span>) &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> COMMENT &lt;span style="color:#e6db74">&amp;#39;邮箱&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> (id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>数据库Data脚本 resources/db/data-mysql.sql&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-mysql" data-lang="mysql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">DELETE&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> &lt;span style="color:#66d9ef">user&lt;/span> (id, name, age, email) &lt;span style="color:#66d9ef">VALUES&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;Jone&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">18&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test1@baomidou.com&amp;#39;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;Jack&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test2@baomidou.com&amp;#39;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;Tom&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">28&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test3@baomidou.com&amp;#39;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#ae81ff">4&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;Sandy&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">21&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test4@baomidou.com&amp;#39;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;Billie&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">24&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;test5@baomidou.com&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>创建一个spring boot工程（使用maven）&lt;/p>
&lt;ul>
&lt;li>
&lt;p>父工程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;parent&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.boot&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-boot-starter-parent&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>2.7.0&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;relativePath/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/parent&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>springboot 相关仓库及mybatis-plus、mysql、Lombok相关仓库引入&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.boot&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-boot-starter&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.boot&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-boot-starter-test&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>test&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.baomidou&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>mybatis-plus-boot-starter&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>3.5.1&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.boot&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-boot-starter-web&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.h2database&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>h2&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>runtime&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>mysql&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>mysql-connector-java&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>8.0.29&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.projectlombok&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>lombok&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.18.24&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>provided&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>配置resources/application.yml文件&lt;/p></description></item><item><title>boge-03-其他</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/03-others/</link><pubDate>Thu, 19 May 2022 16:13:44 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/03-others/</guid><description>&lt;h2 id="会签">
 会签
 &lt;a class="anchor" href="#%e4%bc%9a%e7%ad%be">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>流程图绘制
&lt;img src="img/ly-20241212142115466.png" alt="ly-20241212142115466" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>注意上面几个参数&lt;/p>
&lt;ul>
&lt;li>多实例类型用来判断串行并行&lt;/li>
&lt;li>基数（有几个用户处理）&lt;/li>
&lt;li>元素变量&lt;/li>
&lt;li>集合（集合变量）&lt;/li>
&lt;li>完成条件&amp;ndash;这里填的是 ${nrOfCompletedInstances &amp;gt; 1 }&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>在任务监听器
&lt;img src="img/ly-20241212142115672.png" alt="ly-20241212142115672" />&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> org.flowable.listener;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.flowable.engine.ProcessEngine;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.flowable.engine.ProcessEngines;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.flowable.engine.TaskService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.flowable.engine.delegate.TaskListener;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.flowable.task.api.Task;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.flowable.task.service.delegate.DelegateTask;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MultiInstanceTaskListener&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> TaskListener {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">notify&lt;/span>(DelegateTask delegateTask) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;处理aaaa&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(delegateTask.&lt;span style="color:#a6e22e">getEventName&lt;/span>().&lt;span style="color:#a6e22e">equals&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;create&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;任务id&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> delegateTask.&lt;span style="color:#a6e22e">getId&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;哪些人需要会签&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> delegateTask.&lt;span style="color:#a6e22e">getVariable&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;persons&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;任务处理人&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> delegateTask.&lt;span style="color:#a6e22e">getVariable&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;person&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ProcessEngine engine &lt;span style="color:#f92672">=&lt;/span> ProcessEngines.&lt;span style="color:#a6e22e">getDefaultProcessEngine&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TaskService taskService &lt;span style="color:#f92672">=&lt;/span> engine.&lt;span style="color:#a6e22e">getTaskService&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Task task &lt;span style="color:#f92672">=&lt;/span> taskService.&lt;span style="color:#a6e22e">createTaskQuery&lt;/span>().&lt;span style="color:#a6e22e">taskId&lt;/span>(delegateTask.&lt;span style="color:#a6e22e">getId&lt;/span>()).&lt;span style="color:#a6e22e">singleResult&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task.&lt;span style="color:#a6e22e">setAssignee&lt;/span>(delegateTask.&lt;span style="color:#a6e22e">getVariable&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;person&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> taskService.&lt;span style="color:#a6e22e">saveTask&lt;/span>(task);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>
&lt;p>xml&lt;/p></description></item><item><title>boge-02-flowable进阶_6</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/02-advance_6/</link><pubDate>Sun, 15 May 2022 16:57:08 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/02-advance_6/</guid><description>&lt;h2 id="任务回退-串行回退">
 任务回退-串行回退
 &lt;a class="anchor" href="#%e4%bb%bb%e5%8a%a1%e5%9b%9e%e9%80%80-%e4%b8%b2%e8%a1%8c%e5%9b%9e%e9%80%80">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>流程图绘制
&lt;img src="img/ly-20241212142114607.png" alt="ly-20241212142114607" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>xml&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;?&lt;/span>xml version&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;1.0&amp;#34;&lt;/span> encoding&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UTF-8&amp;#34;&lt;/span>&lt;span style="color:#f92672">?&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>definitions xmlns&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.omg.org/spec/BPMN/20100524/MODEL&amp;#34;&lt;/span> xmlns:xsi&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span> xmlns:xsd&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema&amp;#34;&lt;/span> xmlns:flowable&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/bpmn&amp;#34;&lt;/span> xmlns:bpmndi&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.omg.org/spec/BPMN/20100524/DI&amp;#34;&lt;/span> xmlns:omgdc&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.omg.org/spec/DD/20100524/DC&amp;#34;&lt;/span> xmlns:omgdi&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.omg.org/spec/DD/20100524/DI&amp;#34;&lt;/span> typeLanguage&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema&amp;#34;&lt;/span> expressionLanguage&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/1999/XPath&amp;#34;&lt;/span> targetNamespace&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.flowable.org/processdef&amp;#34;&lt;/span> exporter&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Flowable Open Source Modeler&amp;#34;&lt;/span> exporterVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;6.7.2&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>process id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;reback-key&amp;#34;&lt;/span> name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;回退处理&amp;#34;&lt;/span> isExecutable&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>documentation&lt;span style="color:#f92672">&amp;gt;&lt;/span>reback&lt;span style="color:#f92672">-&lt;/span>desc&lt;span style="color:#f92672">&amp;lt;/&lt;/span>documentation&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>startEvent id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;startEvent1&amp;#34;&lt;/span> flowable:formFieldValidation&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>startEvent&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>userTask id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-D380E41A-48EE-4C08-AD01-1D509C512543&amp;#34;&lt;/span> name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;用户1&amp;#34;&lt;/span> flowable:assignee&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;user1&amp;#34;&lt;/span> flowable:formFieldValidation&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>extensionElements&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>modeler:initiator&lt;span style="color:#f92672">-&lt;/span>can&lt;span style="color:#f92672">-&lt;/span>complete xmlns:modeler&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/modeler&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;![&lt;/span>CDATA&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">]]&amp;gt;&amp;lt;/&lt;/span>modeler:initiator&lt;span style="color:#f92672">-&lt;/span>can&lt;span style="color:#f92672">-&lt;/span>complete&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>extensionElements&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>userTask&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>sequenceFlow id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-E2423FC5-F954-43D3-B57C-8460057CB7D6&amp;#34;&lt;/span> sourceRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;startEvent1&amp;#34;&lt;/span> targetRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-D380E41A-48EE-4C08-AD01-1D509C512543&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>sequenceFlow&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>userTask id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-AF50E3D0-2014-4308-A717-D76586837D70&amp;#34;&lt;/span> name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;用户2&amp;#34;&lt;/span> flowable:assignee&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;user2&amp;#34;&lt;/span> flowable:formFieldValidation&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>extensionElements&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>modeler:initiator&lt;span style="color:#f92672">-&lt;/span>can&lt;span style="color:#f92672">-&lt;/span>complete xmlns:modeler&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/modeler&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;![&lt;/span>CDATA&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">]]&amp;gt;&amp;lt;/&lt;/span>modeler:initiator&lt;span style="color:#f92672">-&lt;/span>can&lt;span style="color:#f92672">-&lt;/span>complete&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>extensionElements&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>userTask&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>sequenceFlow id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-7C8750DC-E1C1-4AB2-B18C-2C103B61A5E5&amp;#34;&lt;/span> sourceRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-D380E41A-48EE-4C08-AD01-1D509C512543&amp;#34;&lt;/span> targetRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-AF50E3D0-2014-4308-A717-D76586837D70&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>sequenceFlow&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>userTask id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-F4CE7565-5977-4B9C-A603-AB3B817B8C8C&amp;#34;&lt;/span> name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;用户3&amp;#34;&lt;/span> flowable:assignee&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;user3&amp;#34;&lt;/span> flowable:formFieldValidation&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>extensionElements&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>modeler:initiator&lt;span style="color:#f92672">-&lt;/span>can&lt;span style="color:#f92672">-&lt;/span>complete xmlns:modeler&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/modeler&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;![&lt;/span>CDATA&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">]]&amp;gt;&amp;lt;/&lt;/span>modeler:initiator&lt;span style="color:#f92672">-&lt;/span>can&lt;span style="color:#f92672">-&lt;/span>complete&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>extensionElements&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>userTask&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>sequenceFlow id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-F91582FE-D110-48C9-9407-605E503E42B2&amp;#34;&lt;/span> sourceRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-AF50E3D0-2014-4308-A717-D76586837D70&amp;#34;&lt;/span> targetRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-F4CE7565-5977-4B9C-A603-AB3B817B8C8C&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>sequenceFlow&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>userTask id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-727C1235-F9C1-4CC5-BC6C-E56ABCA105B0&amp;#34;&lt;/span> name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;用户4&amp;#34;&lt;/span> flowable:assignee&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;user4&amp;#34;&lt;/span> flowable:formFieldValidation&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>extensionElements&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>modeler:initiator&lt;span style="color:#f92672">-&lt;/span>can&lt;span style="color:#f92672">-&lt;/span>complete xmlns:modeler&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/modeler&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;![&lt;/span>CDATA&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">]]&amp;gt;&amp;lt;/&lt;/span>modeler:initiator&lt;span style="color:#f92672">-&lt;/span>can&lt;span style="color:#f92672">-&lt;/span>complete&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>extensionElements&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>userTask&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>sequenceFlow id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-6D998C20-2A97-44B5-92D0-118E5CB05795&amp;#34;&lt;/span> sourceRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-F4CE7565-5977-4B9C-A603-AB3B817B8C8C&amp;#34;&lt;/span> targetRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-727C1235-F9C1-4CC5-BC6C-E56ABCA105B0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>sequenceFlow&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>endEvent id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-6E5F5037-1979-4150-8408-D0BFD0315BCA&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>endEvent&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>sequenceFlow id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-3ECF3E34-6C07-4AE6-997B-583BF8868AC8&amp;#34;&lt;/span> sourceRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-727C1235-F9C1-4CC5-BC6C-E56ABCA105B0&amp;#34;&lt;/span> targetRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-6E5F5037-1979-4150-8408-D0BFD0315BCA&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>sequenceFlow&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>process&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNDiagram id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNDiagram_reback-key&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNPlane bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;reback-key&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNPlane_reback-key&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNShape bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;startEvent1&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_startEvent1&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdc:Bounds height&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;30.0&amp;#34;&lt;/span> width&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;30.0&amp;#34;&lt;/span> x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;100.0&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;163.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdc:Bounds&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNShape&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNShape bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-D380E41A-48EE-4C08-AD01-1D509C512543&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_sid-D380E41A-48EE-4C08-AD01-1D509C512543&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdc:Bounds height&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;80.0&amp;#34;&lt;/span> width&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;100.0&amp;#34;&lt;/span> x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;165.0&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;135.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdc:Bounds&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNShape&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNShape bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-AF50E3D0-2014-4308-A717-D76586837D70&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_sid-AF50E3D0-2014-4308-A717-D76586837D70&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdc:Bounds height&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;80.0&amp;#34;&lt;/span> width&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;100.0&amp;#34;&lt;/span> x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;320.0&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;138.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdc:Bounds&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNShape&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNShape bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-F4CE7565-5977-4B9C-A603-AB3B817B8C8C&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_sid-F4CE7565-5977-4B9C-A603-AB3B817B8C8C&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdc:Bounds height&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;80.0&amp;#34;&lt;/span> width&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;100.0&amp;#34;&lt;/span> x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;465.0&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;138.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdc:Bounds&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNShape&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNShape bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-727C1235-F9C1-4CC5-BC6C-E56ABCA105B0&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_sid-727C1235-F9C1-4CC5-BC6C-E56ABCA105B0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdc:Bounds height&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;80.0&amp;#34;&lt;/span> width&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;100.0&amp;#34;&lt;/span> x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;610.0&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;138.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdc:Bounds&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNShape&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNShape bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-6E5F5037-1979-4150-8408-D0BFD0315BCA&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_sid-6E5F5037-1979-4150-8408-D0BFD0315BCA&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdc:Bounds height&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;28.0&amp;#34;&lt;/span> width&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;28.0&amp;#34;&lt;/span> x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;755.0&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;164.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdc:Bounds&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNShape&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNEdge bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-6D998C20-2A97-44B5-92D0-118E5CB05795&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-6D998C20-2A97-44B5-92D0-118E5CB05795&amp;#34;&lt;/span> flowable:sourceDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> flowable:sourceDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span> flowable:targetDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> flowable:targetDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;564.9499999999907&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;178.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;609.9999999999807&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;178.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNEdge&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNEdge bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-7C8750DC-E1C1-4AB2-B18C-2C103B61A5E5&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-7C8750DC-E1C1-4AB2-B18C-2C103B61A5E5&amp;#34;&lt;/span> flowable:sourceDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> flowable:sourceDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span> flowable:targetDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> flowable:targetDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;264.9499999999882&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;175.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;292.5&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;175.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;292.5&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;178.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;319.9999999999603&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;178.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNEdge&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNEdge bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-3ECF3E34-6C07-4AE6-997B-583BF8868AC8&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-3ECF3E34-6C07-4AE6-997B-583BF8868AC8&amp;#34;&lt;/span> flowable:sourceDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> flowable:sourceDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span> flowable:targetDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;14.0&amp;#34;&lt;/span> flowable:targetDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;14.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;709.9499999999999&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;178.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;755.0&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;178.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNEdge&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNEdge bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-E2423FC5-F954-43D3-B57C-8460057CB7D6&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-E2423FC5-F954-43D3-B57C-8460057CB7D6&amp;#34;&lt;/span> flowable:sourceDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;15.0&amp;#34;&lt;/span> flowable:sourceDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;15.0&amp;#34;&lt;/span> flowable:targetDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> flowable:targetDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;129.94340692927761&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;177.55019845363262&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;164.99999999999906&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;176.4985&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNEdge&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNEdge bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-F91582FE-D110-48C9-9407-605E503E42B2&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-F91582FE-D110-48C9-9407-605E503E42B2&amp;#34;&lt;/span> flowable:sourceDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> flowable:sourceDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span> flowable:targetDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> flowable:targetDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;419.94999999999067&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;178.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;464.9999999999807&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;178.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNEdge&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNPlane&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNDiagram&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/&lt;/span>definitions&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>部署并运行&lt;/p></description></item><item><title>boge-02-flowable进阶_5</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/02-advance_5/</link><pubDate>Sun, 15 May 2022 15:51:40 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/02-advance_5/</guid><description>&lt;h2 id="网关">
 网关
 &lt;a class="anchor" href="#%e7%bd%91%e5%85%b3">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142112823.png" alt="ly-20241212142112823" />&lt;/p>
&lt;h3 id="排他网关">
 排他网关
 &lt;a class="anchor" href="#%e6%8e%92%e4%bb%96%e7%bd%91%e5%85%b3">#&lt;/a>
&lt;/h3>
&lt;p>会按照所有出口顺序流定义的顺序对它们进行计算，选择第一个条件计算为true的顺序流（&lt;strong>当没有设置条件时，认为顺序流为true&lt;/strong>）继续流程&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142113034.png" alt="ly-20241212142113034" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>排他网关的绘制
&lt;img src="img/ly-20241212142113127.png" alt="ly-20241212142113127" />
xml文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;definitions&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.omg.org/spec/BPMN/20100524/MODEL&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns:xsd=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns:flowable=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/bpmn&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns:bpmndi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.omg.org/spec/BPMN/20100524/DI&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns:omgdc=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.omg.org/spec/DD/20100524/DC&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns:omgdi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.omg.org/spec/DD/20100524/DI&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">typeLanguage=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">expressionLanguage=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/1999/XPath&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">targetNamespace=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.flowable.org/processdef&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">exporter=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Flowable Open Source Modeler&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">exporterVersion=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;6.7.2&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;process&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;holiday-exclusive&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;请假流程-排他网关&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">isExecutable=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;startEvent&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;startEvent1&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:formFieldValidation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/startEvent&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;userTask&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-3D5ED4D4-97F5-4FFD-B160-F00566ECC55E&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;创建请假单&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:assignee=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;zhangsan&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:formFieldValidation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;extensionElements&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;modeler:initiator-can-complete&lt;/span> &lt;span style="color:#a6e22e">xmlns:modeler=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/modeler&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#75715e">&amp;lt;![CDATA[false]]&amp;gt;&lt;/span>&lt;span style="color:#f92672">&amp;lt;/modeler:initiator-can-complete&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/extensionElements&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/userTask&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;sequenceFlow&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-33A73370-751D-413F-9306-39DEAA674DB6&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">sourceRef=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;startEvent1&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">targetRef=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-3D5ED4D4-97F5-4FFD-B160-F00566ECC55E&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/sequenceFlow&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;exclusiveGateway&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-5B2117E6-D341-49F2-85B2-336CA836C7D8&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/exclusiveGateway&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;sequenceFlow&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-D1B1F6E0-EA7F-4FF7-AD0C-5D43DBCEBFD2&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">sourceRef=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-3D5ED4D4-97F5-4FFD-B160-F00566ECC55E&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">targetRef=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-5B2117E6-D341-49F2-85B2-336CA836C7D8&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/sequenceFlow&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;userTask&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-08A6CB64-C9BB-4342-852D-444A75315BDE&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;总经理审批&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:assignee=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;wangwu&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:formFieldValidation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;extensionElements&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;modeler:initiator-can-complete&lt;/span> &lt;span style="color:#a6e22e">xmlns:modeler=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/modeler&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#75715e">&amp;lt;![CDATA[false]]&amp;gt;&lt;/span>&lt;span style="color:#f92672">&amp;lt;/modeler:initiator-can-complete&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/extensionElements&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/userTask&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;userTask&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-EA98D0C3-E41D-4DEB-8933-91A1B7301ABE&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;部门经理审批&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:assignee=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;lisi&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:formFieldValidation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;extensionElements&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;modeler:initiator-can-complete&lt;/span> &lt;span style="color:#a6e22e">xmlns:modeler=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/modeler&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#75715e">&amp;lt;![CDATA[false]]&amp;gt;&lt;/span>&lt;span style="color:#f92672">&amp;lt;/modeler:initiator-can-complete&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/extensionElements&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/userTask&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;userTask&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-24F73F7F-EB61-484F-A494-686E194D0118&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;人事审批&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:assignee=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;zhaoliu&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:formFieldValidation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;extensionElements&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;modeler:initiator-can-complete&lt;/span> &lt;span style="color:#a6e22e">xmlns:modeler=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/modeler&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#75715e">&amp;lt;![CDATA[false]]&amp;gt;&lt;/span>&lt;span style="color:#f92672">&amp;lt;/modeler:initiator-can-complete&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/extensionElements&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/userTask&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;sequenceFlow&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-8BA0B88C-BA4F-446D-B5E7-6BF0830B1DC8&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">sourceRef=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-EA98D0C3-E41D-4DEB-8933-91A1B7301ABE&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">targetRef=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-24F73F7F-EB61-484F-A494-686E194D0118&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/sequenceFlow&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;sequenceFlow&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-E748F81F-B0B2-4C34-B993-FBAA2BCD0995&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">sourceRef=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-08A6CB64-C9BB-4342-852D-444A75315BDE&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">targetRef=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-24F73F7F-EB61-484F-A494-686E194D0118&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/sequenceFlow&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;sequenceFlow&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-928C6C6F-57F1-40F2-BE0F-1A9FF3E6E9E4&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">sourceRef=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-5B2117E6-D341-49F2-85B2-336CA836C7D8&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">targetRef=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-08A6CB64-C9BB-4342-852D-444A75315BDE&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;conditionExpression&lt;/span> &lt;span style="color:#a6e22e">xsi:type=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;tFormalExpression&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#75715e">&amp;lt;![CDATA[${num&amp;gt;3}]]&amp;gt;&lt;/span>&lt;span style="color:#f92672">&amp;lt;/conditionExpression&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/sequenceFlow&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;sequenceFlow&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-4DB25720-11C8-401E-BB4C-83BB25510B2E&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">sourceRef=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-5B2117E6-D341-49F2-85B2-336CA836C7D8&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">targetRef=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-EA98D0C3-E41D-4DEB-8933-91A1B7301ABE&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;conditionExpression&lt;/span> &lt;span style="color:#a6e22e">xsi:type=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;tFormalExpression&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#75715e">&amp;lt;![CDATA[${num&amp;lt;3}]]&amp;gt;&lt;/span>&lt;span style="color:#f92672">&amp;lt;/conditionExpression&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/sequenceFlow&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/process&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNDiagram&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNDiagram_holiday-exclusive&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNPlane&lt;/span> &lt;span style="color:#a6e22e">bpmnElement=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;holiday-exclusive&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNPlane_holiday-exclusive&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNShape&lt;/span> &lt;span style="color:#a6e22e">bpmnElement=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;startEvent1&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_startEvent1&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdc:Bounds&lt;/span> &lt;span style="color:#a6e22e">height=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;30.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">width=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;30.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;30.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;163.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdc:Bounds&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNShape&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNShape&lt;/span> &lt;span style="color:#a6e22e">bpmnElement=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-3D5ED4D4-97F5-4FFD-B160-F00566ECC55E&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_sid-3D5ED4D4-97F5-4FFD-B160-F00566ECC55E&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdc:Bounds&lt;/span> &lt;span style="color:#a6e22e">height=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;80.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">width=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;100.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;150.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;135.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdc:Bounds&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNShape&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNShape&lt;/span> &lt;span style="color:#a6e22e">bpmnElement=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-5B2117E6-D341-49F2-85B2-336CA836C7D8&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_sid-5B2117E6-D341-49F2-85B2-336CA836C7D8&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdc:Bounds&lt;/span> &lt;span style="color:#a6e22e">height=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">width=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;315.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;155.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdc:Bounds&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNShape&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNShape&lt;/span> &lt;span style="color:#a6e22e">bpmnElement=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-08A6CB64-C9BB-4342-852D-444A75315BDE&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_sid-08A6CB64-C9BB-4342-852D-444A75315BDE&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdc:Bounds&lt;/span> &lt;span style="color:#a6e22e">height=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;80.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">width=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;100.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;420.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;225.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdc:Bounds&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNShape&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNShape&lt;/span> &lt;span style="color:#a6e22e">bpmnElement=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-EA98D0C3-E41D-4DEB-8933-91A1B7301ABE&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_sid-EA98D0C3-E41D-4DEB-8933-91A1B7301ABE&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdc:Bounds&lt;/span> &lt;span style="color:#a6e22e">height=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;80.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">width=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;100.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;405.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;30.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdc:Bounds&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNShape&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNShape&lt;/span> &lt;span style="color:#a6e22e">bpmnElement=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-24F73F7F-EB61-484F-A494-686E194D0118&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_sid-24F73F7F-EB61-484F-A494-686E194D0118&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdc:Bounds&lt;/span> &lt;span style="color:#a6e22e">height=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;80.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">width=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;100.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;630.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;225.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdc:Bounds&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNShape&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNEdge&lt;/span> &lt;span style="color:#a6e22e">bpmnElement=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-8BA0B88C-BA4F-446D-B5E7-6BF0830B1DC8&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-8BA0B88C-BA4F-446D-B5E7-6BF0830B1DC8&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:sourceDockerX=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:sourceDockerY=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:targetDockerX=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:targetDockerY=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;504.95000000000005&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;70.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;680.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;70.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;680.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;225.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNEdge&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNEdge&lt;/span> &lt;span style="color:#a6e22e">bpmnElement=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-4DB25720-11C8-401E-BB4C-83BB25510B2E&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-4DB25720-11C8-401E-BB4C-83BB25510B2E&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:sourceDockerX=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;20.5&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:sourceDockerY=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;20.5&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:targetDockerX=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:targetDockerY=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;335.5&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;155.5&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;335.5&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;70.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;404.99999999996083&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;70.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNEdge&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNEdge&lt;/span> &lt;span style="color:#a6e22e">bpmnElement=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-33A73370-751D-413F-9306-39DEAA674DB6&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-33A73370-751D-413F-9306-39DEAA674DB6&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:sourceDockerX=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;15.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:sourceDockerY=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;15.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:targetDockerX=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:targetDockerY=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;59.94725673598754&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;177.70973069236373&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;150.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;175.96677419354836&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNEdge&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNEdge&lt;/span> &lt;span style="color:#a6e22e">bpmnElement=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-D1B1F6E0-EA7F-4FF7-AD0C-5D43DBCEBFD2&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-D1B1F6E0-EA7F-4FF7-AD0C-5D43DBCEBFD2&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:sourceDockerX=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:sourceDockerY=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:targetDockerX=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;20.5&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:targetDockerY=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;20.5&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;249.95000000000002&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;175.18431734317343&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;315.42592592592536&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;175.42592592592592&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNEdge&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNEdge&lt;/span> &lt;span style="color:#a6e22e">bpmnElement=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-E748F81F-B0B2-4C34-B993-FBAA2BCD0995&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-E748F81F-B0B2-4C34-B993-FBAA2BCD0995&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:sourceDockerX=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:sourceDockerY=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:targetDockerX=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:targetDockerY=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;519.95&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;265.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;629.9999999998776&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;265.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNEdge&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bpmndi:BPMNEdge&lt;/span> &lt;span style="color:#a6e22e">bpmnElement=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-928C6C6F-57F1-40F2-BE0F-1A9FF3E6E9E4&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-928C6C6F-57F1-40F2-BE0F-1A9FF3E6E9E4&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:sourceDockerX=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;20.5&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:sourceDockerY=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;20.5&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:targetDockerX=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">flowable:targetDockerY=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;335.5&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;194.43942522321433&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;335.5&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;265.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;omgdi:waypoint&lt;/span> &lt;span style="color:#a6e22e">x=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;420.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">y=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;265.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/omgdi:waypoint&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNEdge&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNPlane&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bpmndi:BPMNDiagram&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/definitions&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>部署&lt;/p></description></item><item><title>boge-02-flowable进阶_4</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/02-advance_4/</link><pubDate>Sun, 15 May 2022 13:10:43 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/02-advance_4/</guid><description>&lt;h2 id="候选人">
 候选人
 &lt;a class="anchor" href="#%e5%80%99%e9%80%89%e4%ba%ba">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>流程图设计&lt;/p>
&lt;ul>
&lt;li>总体
&lt;img src="img/ly-20241212142111000.png" alt="ly-20241212142111000" />&lt;/li>
&lt;li>具体
&lt;img src="img/ly-20241212142111216.png" alt="ly-20241212142111216" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>部署并启动流程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">deploy&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ProcessEngine processEngine&lt;span style="color:#f92672">=&lt;/span> ProcessEngines.&lt;span style="color:#a6e22e">getDefaultProcessEngine&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RepositoryService repositoryService &lt;span style="color:#f92672">=&lt;/span> processEngine.&lt;span style="color:#a6e22e">getRepositoryService&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Deployment deploy &lt;span style="color:#f92672">=&lt;/span> repositoryService.&lt;span style="color:#a6e22e">createDeployment&lt;/span>().&lt;span style="color:#a6e22e">name&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ly画的请假流程-候选人&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">addClasspathResource&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;请假流程-候选人.bpmn20.xml&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">deploy&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">runProcess&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//设置候选人&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String,Object&lt;span style="color:#f92672">&amp;gt;&lt;/span> variables&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variables.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;candidate1&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;张三&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variables.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;candidate2&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;李四&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variables.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;candidate3&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;王五&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ProcessEngine engine&lt;span style="color:#f92672">=&lt;/span>ProcessEngines.&lt;span style="color:#a6e22e">getDefaultProcessEngine&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//获取流程运行服务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RuntimeService runtimeService &lt;span style="color:#f92672">=&lt;/span> engine.&lt;span style="color:#a6e22e">getRuntimeService&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//运行流程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ProcessInstance processInstance &lt;span style="color:#f92672">=&lt;/span> runtimeService.&lt;span style="color:#a6e22e">startProcessInstanceById&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;holiday-candidate:1:4&amp;#34;&lt;/span>,variables);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;processInstance--&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>processInstance);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>查看数据库表数据&lt;/p>
&lt;ul>
&lt;li>处理人为空
&lt;img src="img/ly-20241212142111312.png" alt="ly-20241212142111312" />&lt;/li>
&lt;li>变量
&lt;img src="img/ly-20241212142111408.png" alt="ly-20241212142111408" />&lt;/li>
&lt;li>图解
&lt;img src="img/ly-20241212142111504.png" alt="ly-20241212142111504" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>实际，作为登录用户如果是张三/李四或者王五，那它可以查看它自己是候选人的任务&lt;/p></description></item><item><title>boge-02-flowable进阶_3</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/02-advance_3/</link><pubDate>Sun, 15 May 2022 10:04:08 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/02-advance_3/</guid><description>&lt;h2 id="任务分配-uel表达式">
 任务分配-uel表达式
 &lt;a class="anchor" href="#%e4%bb%bb%e5%8a%a1%e5%88%86%e9%85%8d-uel%e8%a1%a8%e8%be%be%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>通过变量指定来进行分配&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先绘制流程图（定义）
&lt;img src="img/ly-20241212142108250.png" alt="ly-20241212142108250" />&lt;/p>
&lt;ul>
&lt;li>变量处理
&lt;img src="img/ly-20241212142108471.png" alt="ly-20241212142108471" />
&lt;img src="img/ly-20241212142108572.png" alt="ly-20241212142108572" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>之后将xml文件导出&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;?&lt;/span>xml version&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;1.0&amp;#34;&lt;/span> encoding&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UTF-8&amp;#34;&lt;/span>&lt;span style="color:#f92672">?&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>definitions xmlns&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.omg.org/spec/BPMN/20100524/MODEL&amp;#34;&lt;/span> xmlns:xsi&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span> xmlns:xsd&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema&amp;#34;&lt;/span> xmlns:flowable&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/bpmn&amp;#34;&lt;/span> xmlns:bpmndi&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.omg.org/spec/BPMN/20100524/DI&amp;#34;&lt;/span> xmlns:omgdc&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.omg.org/spec/DD/20100524/DC&amp;#34;&lt;/span> xmlns:omgdi&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.omg.org/spec/DD/20100524/DI&amp;#34;&lt;/span> typeLanguage&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema&amp;#34;&lt;/span> expressionLanguage&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/1999/XPath&amp;#34;&lt;/span> targetNamespace&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.flowable.org/processdef&amp;#34;&lt;/span> exporter&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Flowable Open Source Modeler&amp;#34;&lt;/span> exporterVersion&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;6.7.2&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>process id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;holiday-new&amp;#34;&lt;/span> name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;新请假流程&amp;#34;&lt;/span> isExecutable&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>documentation&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span>&lt;span style="color:#f92672">-&lt;/span>description&lt;span style="color:#f92672">&amp;lt;/&lt;/span>documentation&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>startEvent id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;startEvent1&amp;#34;&lt;/span> flowable:formFieldValidation&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>startEvent&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>userTask id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-8D901410-5BD7-4EED-B988-5E40D12298C7&amp;#34;&lt;/span> name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;创建请假流程&amp;#34;&lt;/span> flowable:assignee&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;${assignee0}&amp;#34;&lt;/span> flowable:formFieldValidation&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>extensionElements&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>modeler:initiator&lt;span style="color:#f92672">-&lt;/span>can&lt;span style="color:#f92672">-&lt;/span>complete xmlns:modeler&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/modeler&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;![&lt;/span>CDATA&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">]]&amp;gt;&amp;lt;/&lt;/span>modeler:initiator&lt;span style="color:#f92672">-&lt;/span>can&lt;span style="color:#f92672">-&lt;/span>complete&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>extensionElements&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>userTask&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>userTask id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&amp;#34;&lt;/span> name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;审批请假流程&amp;#34;&lt;/span> flowable:assignee&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;${assignee1}&amp;#34;&lt;/span> flowable:formFieldValidation&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>extensionElements&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>modeler:initiator&lt;span style="color:#f92672">-&lt;/span>can&lt;span style="color:#f92672">-&lt;/span>complete xmlns:modeler&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/modeler&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;![&lt;/span>CDATA&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">]]&amp;gt;&amp;lt;/&lt;/span>modeler:initiator&lt;span style="color:#f92672">-&lt;/span>can&lt;span style="color:#f92672">-&lt;/span>complete&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>extensionElements&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>userTask&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>sequenceFlow id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-631EFFB0-795A-4777-B49E-CF7D015BFF15&amp;#34;&lt;/span> sourceRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-8D901410-5BD7-4EED-B988-5E40D12298C7&amp;#34;&lt;/span> targetRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>sequenceFlow&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>endEvent id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-15CAD0D3-7F8B-404C-9346-A8D2A456D47B&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>endEvent&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>sequenceFlow id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-001CA567-6169-4F8A-A0E5-010721D52508&amp;#34;&lt;/span> sourceRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&amp;#34;&lt;/span> targetRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-15CAD0D3-7F8B-404C-9346-A8D2A456D47B&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>sequenceFlow&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>sequenceFlow id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-0A4A52F2-ECF6-44B2-AA41-F926AA7F5932&amp;#34;&lt;/span> sourceRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;startEvent1&amp;#34;&lt;/span> targetRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-8D901410-5BD7-4EED-B988-5E40D12298C7&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>sequenceFlow&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>process&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNDiagram id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNDiagram_holiday-new&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNPlane bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;holiday-new&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNPlane_holiday-new&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNShape bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;startEvent1&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_startEvent1&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdc:Bounds height&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;30.0&amp;#34;&lt;/span> width&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;30.0&amp;#34;&lt;/span> x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;100.0&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;145.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdc:Bounds&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNShape&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNShape bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-8D901410-5BD7-4EED-B988-5E40D12298C7&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_sid-8D901410-5BD7-4EED-B988-5E40D12298C7&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdc:Bounds height&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;80.0&amp;#34;&lt;/span> width&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;100.0&amp;#34;&lt;/span> x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;225.0&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;120.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdc:Bounds&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNShape&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNShape bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdc:Bounds height&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;80.0&amp;#34;&lt;/span> width&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;100.0&amp;#34;&lt;/span> x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;370.0&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;120.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdc:Bounds&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNShape&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNShape bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-15CAD0D3-7F8B-404C-9346-A8D2A456D47B&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNShape_sid-15CAD0D3-7F8B-404C-9346-A8D2A456D47B&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdc:Bounds height&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;28.0&amp;#34;&lt;/span> width&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;28.0&amp;#34;&lt;/span> x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;555.0&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;146.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdc:Bounds&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNShape&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNEdge bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-001CA567-6169-4F8A-A0E5-010721D52508&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-001CA567-6169-4F8A-A0E5-010721D52508&amp;#34;&lt;/span> flowable:sourceDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> flowable:sourceDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span> flowable:targetDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;14.0&amp;#34;&lt;/span> flowable:targetDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;14.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;469.94999999997356&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;160.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;555.0&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;160.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNEdge&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNEdge bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-0A4A52F2-ECF6-44B2-AA41-F926AA7F5932&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-0A4A52F2-ECF6-44B2-AA41-F926AA7F5932&amp;#34;&lt;/span> flowable:sourceDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;15.0&amp;#34;&lt;/span> flowable:sourceDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;15.0&amp;#34;&lt;/span> flowable:targetDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> flowable:targetDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;129.94999928606217&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;160.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;224.99999999995185&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;160.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNEdge&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bpmndi:BPMNEdge bpmnElement&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sid-631EFFB0-795A-4777-B49E-CF7D015BFF15&amp;#34;&lt;/span> id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;BPMNEdge_sid-631EFFB0-795A-4777-B49E-CF7D015BFF15&amp;#34;&lt;/span> flowable:sourceDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> flowable:sourceDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span> flowable:targetDockerX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;50.0&amp;#34;&lt;/span> flowable:targetDockerY&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;40.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;324.9499999999907&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;160.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>omgdi:waypoint x&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;369.9999999999807&amp;#34;&lt;/span> y&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;160.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;lt;/&lt;/span>omgdi:waypoint&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNEdge&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNPlane&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>bpmndi:BPMNDiagram&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/&lt;/span>definitions&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>流程定义的部署&lt;/p></description></item><item><title>boge-02-flowable进阶_2</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/02-advance_2/</link><pubDate>Sat, 14 May 2022 23:31:13 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/02-advance_2/</guid><description>&lt;h2 id="service服务接口">
 Service服务接口
 &lt;a class="anchor" href="#service%e6%9c%8d%e5%8a%a1%e6%8e%a5%e5%8f%a3">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142104630.png" alt="ly-20241212142104630" />&lt;/p>
&lt;ul>
&lt;li>各个Service类
RepositoryService 资源管理类，流程定义、部署、文件
RuntimeService 流程运行管理类，运行过程中（执行）
TaskService 任务管理类
HistoryService 历史管理类
ManagerService 引擎管理类&lt;/li>
&lt;/ul>
&lt;h2 id="flowable图标">
 Flowable图标
 &lt;a class="anchor" href="#flowable%e5%9b%be%e6%a0%87">#&lt;/a>
&lt;/h2>
&lt;p>BPMN2.0定义的一些图标&lt;/p>
&lt;ul>
&lt;li>时间&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="img/ly-20241212142104849.png" alt="ly-20241212142104849" />&lt;/p>
&lt;ul>
&lt;li>活动
&lt;img src="img/ly-20241212142104949.png" alt="ly-20241212142104949" />&lt;/li>
&lt;li>网关
&lt;img src="img/ly-20241212142105051.png" alt="ly-20241212142105051" />&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;h2 id="流程部署深入解析">
 流程部署深入解析
 &lt;a class="anchor" href="#%e6%b5%81%e7%a8%8b%e9%83%a8%e7%bd%b2%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>使用eclipse打包部署(没有eclipse环境，所以这里只有截图)
将两个流程，打包为bar文件，然后放到项目resources文件夹中
&lt;img src="img/ly-20241212142105247.png" alt="ly-20241212142105247" />
&lt;img src="img/ly-20241212142105148.png" alt="ly-20241212142105148" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这里是为了测试一次部署多个流程（定义，图）
代码如下
&lt;img src="img/ly-20241212142105345.png" alt="ly-20241212142105345" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>部署完成后查看表结构&lt;/p>
&lt;ul>
&lt;li>
&lt;p>act_re_procdef&lt;/p>
&lt;p>部署id一样
&lt;img src="img/ly-20241212142105443.png" alt="ly-20241212142105443" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>act_re_deployment
&lt;img src="img/ly-20241212142105547.png" alt="ly-20241212142105547" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>结论：部署和定义是1对多的关系&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>每次部署所涉及到的资源文件
&lt;img src="img/ly-20241212142105649.png" alt="ly-20241212142105649" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>涉及到的三张表&lt;/p>
&lt;ul>
&lt;li>
&lt;p>act_ge_bytearray
&lt;img src="img/ly-20241212142105747.png" alt="ly-20241212142105747" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>act_re_procdef
category&amp;ndash;&amp;gt;xml中的namespace
name&amp;ndash;&amp;gt;定义时起的名称
key_&amp;mdash;&amp;gt;xml中定义的id
resource_name&amp;mdash;&amp;gt;xml文件名称
dgrm_resource_name&amp;ndash;&amp;gt;生成图片名称
suspension_state &amp;ndash;&amp;gt; 是否被挂起&lt;/p>
&lt;p>tenant_id &amp;ndash; &amp;gt;谁部署的流程&lt;/p>
&lt;/li>
&lt;li>
&lt;p>act_re_deployment
name_部署名&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>代码
&lt;img src="img/ly-20241212142105845.png" alt="ly-20241212142105845" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>主要源码
DeployCmd.class
&lt;img src="img/ly-20241212142105941.png" alt="ly-20241212142105941" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DeploymentEntityManagerImpl.java
&lt;img src="img/ly-20241212142106041.png" alt="ly-20241212142106041" />&lt;/p></description></item><item><title>问题01</title><link>https://lwmfjc.github.io/zh/docs/problem/Idea/01/</link><pubDate>Sat, 14 May 2022 22:30:18 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/Idea/01/</guid><description>&lt;h2 id="cannot-download-sources">
 Cannot download sources
 &lt;a class="anchor" href="#cannot-download-sources">#&lt;/a>
&lt;/h2>
&lt;p>在maven项目(根目录)下执行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>mvn dependency:resolve -Dclassifier&lt;span style="color:#f92672">=&lt;/span>sources
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>会开始下载，有控制台输出，结束后再点即可&lt;/p>
&lt;h2 id="预留">
 预留
 &lt;a class="anchor" href="#%e9%a2%84%e7%95%99">#&lt;/a>
&lt;/h2></description></item><item><title>boge-02-flowable进阶_1</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/02-advance_1/</link><pubDate>Sat, 14 May 2022 21:59:40 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/02-advance_1/</guid><description>&lt;h2 id="表结构">
 表结构
 &lt;a class="anchor" href="#%e8%a1%a8%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>尽量通过API动数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ACT_RE：repository，包含流程定义和流程静态资源&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ACT_RU: runtime，包含流程实例、任务、变量等，流程结束会删除&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ACT_HI: history，包含历史数据，比如历史流程实例、变量、任务等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ACT_GE: general，通用数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ACT_ID: identity，组织机构。包含标识的信息，如用户、用户组等等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>具体的&lt;/p>
&lt;ul>
&lt;li>
&lt;p>流程历史记录&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142103886.png" alt="ly-20241212142103886" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>流程定义表
&lt;img src="img/ly-20241212142104111.png" alt="ly-20241212142104111" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>运行实例表
&lt;img src="img/ly-20241212142104209.png" alt="ly-20241212142104209" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用户用户组表&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142104309.png" alt="ly-20241212142104309" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>源码中的体现
&lt;img src="img/ly-20241212142104410.png" alt="ly-20241212142104410" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="默认的配置文件加载">
 默认的配置文件加载
 &lt;a class="anchor" href="#%e9%bb%98%e8%ae%a4%e7%9a%84%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e5%8a%a0%e8%bd%bd">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>对于&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ProcessEngine defaultProcessEngine &lt;span style="color:#f92672">=&lt;/span> ProcessEngines.&lt;span style="color:#a6e22e">getDefaultProcessEngine&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ProcessEngine &lt;span style="color:#a6e22e">getDefaultProcessEngine&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> getProcessEngine(NAME_DEFAULT); &lt;span style="color:#75715e">//NAME_DEFAULT = &amp;#34;default&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ProcessEngine &lt;span style="color:#a6e22e">getProcessEngine&lt;/span>(String processEngineName) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>isInitialized()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> init();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> processEngines.&lt;span style="color:#a6e22e">get&lt;/span>(processEngineName);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//--&amp;gt;部分&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Initializes all process engines that can be found on the classpath for resources &amp;lt;code&amp;gt;flowable.cfg.xml&amp;lt;/code&amp;gt; (plain Flowable style configuration) and for resources
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * &amp;lt;code&amp;gt;flowable-context.xml&amp;lt;/code&amp;gt; (Spring style configuration).
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">synchronized&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>isInitialized()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (processEngines &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Create new map to store process-engines if current map is null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> processEngines &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ClassLoader classLoader &lt;span style="color:#f92672">=&lt;/span> ReflectUtil.&lt;span style="color:#a6e22e">getClassLoader&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Enumeration&lt;span style="color:#f92672">&amp;lt;&lt;/span>URL&lt;span style="color:#f92672">&amp;gt;&lt;/span> resources &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources &lt;span style="color:#f92672">=&lt;/span> classLoader.&lt;span style="color:#a6e22e">getResources&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;flowable.cfg.xml&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (IOException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> FlowableIllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;problem retrieving flowable.cfg.xml resources on the classpath: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> System.&lt;span style="color:#a6e22e">getProperty&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;java.class.path&amp;#34;&lt;/span>), e);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//后面还有，每帖出来&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>注意这行&lt;code>classLoader.getResources(&amp;quot;flowable.cfg.xml&amp;quot;);&lt;/code>
需要在resources根目录下放这么一个文件&lt;/p></description></item><item><title>boge-01-flowable基础</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/01-base/</link><pubDate>Sat, 14 May 2022 07:29:14 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/boge_blbl/01-base/</guid><description>&lt;h2 id="flowable介绍">
 Flowable介绍
 &lt;a class="anchor" href="#flowable%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>flowable的历史&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142101999.png" alt="ly-20241212142101999" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>flowable是BPNM的一个基于java的软件实现，不仅包括BPMN，还有DMN决策表和CMMNCase管理引擎，并且有自己的用户管理、微服务API等&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="获取engine对象">
 获取Engine对象
 &lt;a class="anchor" href="#%e8%8e%b7%e5%8f%96engine%e5%af%b9%e8%b1%a1">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>maven依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>mysql&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>mysql-connector-java&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>8.0.29&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- https://mvnrepository.com/artifact/org.flowable/flowable-engine --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.flowable&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>flowable-engine&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>6.7.2&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- https://mvnrepository.com/artifact/junit/junit --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>junit&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>junit&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.13.2&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>test&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>配置并获取ProcessEngine&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ProcessEngineConfiguration configuration&lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> StandaloneProcessEngineConfiguration();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//配置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configuration.&lt;span style="color:#a6e22e">setJdbcDriver&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;com.mysql.cj.jdbc.Driver&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configuration.&lt;span style="color:#a6e22e">setJdbcUsername&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configuration.&lt;span style="color:#a6e22e">setJdbcPassword&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;123456&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//nullCatalogMeansCurrent=true 设置为只查当前连接的schema库&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configuration.&lt;span style="color:#a6e22e">setJdbcUrl&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;jdbc:mysql://localhost:3306/flowable-learn?&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;useUnicode=true&amp;amp;characterEncoding=utf-8&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;amp;allowMultiQueries=true&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;amp;nullCatalogMeansCurrent=true&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果数据库中表结构不存在则新建&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> configuration.&lt;span style="color:#a6e22e">setDatabaseSchemaUpdate&lt;/span>(ProcessEngineConfiguration.&lt;span style="color:#a6e22e">DB_SCHEMA_UPDATE_TRUE&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//构建ProcessEngine&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ProcessEngine processEngine&lt;span style="color:#f92672">=&lt;/span>configuration.&lt;span style="color:#a6e22e">buildProcessEngine&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="日志和表结构介绍">
 日志和表结构介绍
 &lt;a class="anchor" href="#%e6%97%a5%e5%bf%97%e5%92%8c%e8%a1%a8%e7%bb%93%e6%9e%84%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>添加slf4j依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-reload4j --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.slf4j&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>slf4j-reload4j&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.7.36&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>test&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-api --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.apache.logging.log4j&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>log4j-api&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>2.17.2&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>添加log配置文件&lt;/p></description></item><item><title>linux_韩老师_12-20</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/12-20/</link><pubDate>Tue, 10 May 2022 21:18:22 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/12-20/</guid><description>&lt;h2 id="目录结构">
 目录结构
 &lt;a class="anchor" href="#%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>目录结构很重要&lt;/p>
&lt;ul>
&lt;li>
&lt;p>windows下
&lt;img src="img/ly-20241212142133607.png" alt="ly-20241212142133607" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>linux下，从根目录开始分支
/，/root （root用户），/home （创建的用户的目录），/bin（常用的指令），/etc（环境配置）&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142133807.png" alt="ly-20241212142133807" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在linux世界里，一切皆文件&lt;/p>
&lt;ul>
&lt;li>
&lt;p>cpu被映射成文件&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142133880.png" alt="ly-20241212142133880" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>硬盘
&lt;img src="img/ly-20241212142133952.png" alt="ly-20241212142133952" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>具体的目录结构&lt;/p>
&lt;ul>
&lt;li>
&lt;p>/bin 常用，binary的缩写，存放常用的命令
(/usr/bin、/usr/local/bin)
&lt;img src="img/ly-20241212142134025.png" alt="ly-20241212142134025" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/sbin （/usr/sbin、/usr/local/sbin）
SuperUser，存放的是系统管理员使用的系统管理程序&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/home 存放普通用户的主目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>useradd jack
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>之后看该目录
&lt;img src="img/ly-20241212142134097.png" alt="ly-20241212142134097" />&lt;/li>
&lt;li>删掉 &lt;code>userdel -r jack&lt;/code>
目录消失&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>/root 该目录为系统管理员，也称超级管理员的用户的主目录&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/lib 系统开机所需要的最基本的动态连接共享库，其作用类似于windows里的DLL，几乎所有的应用程序都需要用到这些共享库&lt;/p>
&lt;/li>
&lt;li>
&lt;p>lost+found 一般为空，非法关机后会存放文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/etc 系统管理所需要的配置文件和子目录，比如mysql的my.conf&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/usr 用户的应用程序和文件，类似windows的program files&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/boot 启动Linux时使用的核心文件（破坏则无法启动）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>/proc （不能动）&lt;/strong> 虚拟目录，系统内存的映射，访问这个目录获取系统信息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>/srv （不能动）&lt;/strong> service的缩写，存放服务启动之后需要提取的数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>/sys （不能动）&lt;/strong> 安装了2.6内核中新出现的文件系统 sysfs&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/tmp 这个目录用来存放一些临时文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/dev 类似windows设备管理器，将硬件映射成文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/media linux系统会自动识别一些设备，u盘、光驱，将识别的设备映射到该目录下&lt;/p>
&lt;/li>
&lt;li>
&lt;p>/mnt 为了让用户挂载别的文件系统，比如将外部的存储&lt;em>挂载&lt;/em>到该目录
&lt;img src="img/ly-20241212142134167.png" alt="ly-20241212142134167" />
&lt;img src="img/ly-20241212142134238.png" alt="ly-20241212142134238" />&lt;/p></description></item><item><title>linux_韩老师_07-11</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/07-11/</link><pubDate>Tue, 10 May 2022 20:42:32 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/07-11/</guid><description>&lt;h2 id="网络连接">
 网络连接
 &lt;a class="anchor" href="#%e7%bd%91%e7%bb%9c%e8%bf%9e%e6%8e%a5">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>网络连接的三种模式
同一个教室的三个主机
&lt;img src="img/ly-20241212142132441.png" alt="ly-20241212142132441" />
此时三个同学可以正常通讯
&lt;ul>
&lt;li>桥接模式
&lt;img src="img/ly-20241212142132642.png" alt="ly-20241212142132642" />
这是张三的虚拟机和外部互通；但是如果这样设置，ip会不够用；&lt;/li>
&lt;li>NAT模式
&lt;img src="img/ly-20241212142132718.png" alt="ly-20241212142132718" />
如图，虚拟机可以跟虚拟的网卡(192.168.100.99)互通，且通过这个虚拟网卡，及（192.168.0.50代理），与外界(192.168.0.X)互通
&lt;strong>NAT模式，网络地址转换模式&lt;/strong>，虚拟系统和外部系统通讯，不造成IP冲突
&lt;img src="img/ly-20241212142132796.png" alt="ly-20241212142132796" />
注意，这里外部其他主机(除0.50和100.99)是访问不到100.88的&lt;/li>
&lt;li>主机模式：独立的系统&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="虚拟机克隆">
 虚拟机克隆
 &lt;a class="anchor" href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%85%8b%e9%9a%86">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>方式1，直接拷贝整个文件夹
&lt;img src="img/ly-20241212142132865.png" alt="ly-20241212142132865" />&lt;/li>
&lt;li>方式2，使用VMWare
克隆前先把克隆目标关闭
克隆虚拟机当前状态&amp;ndash;创建完整克隆&lt;/li>
&lt;/ul>
&lt;h2 id="虚拟机快照">
 虚拟机快照
 &lt;a class="anchor" href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%bf%ab%e7%85%a7">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>为什么需要虚拟机快照
&lt;img src="img/ly-20241212142132937.png" alt="ly-20241212142132937" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>快照a
&lt;img src="img/ly-20241212142133013.png" alt="ly-20241212142133013" />
之后创建了文件夹hello
然后拍摄快照b
之后创建了文件夹hello2
然后拍摄快照c&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目前
&lt;img src="img/ly-20241212142133086.png" alt="" />&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142133161.png" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>回到快照A
&lt;img src="img/ly-20241212142133231.png" alt="ly-20241212142133231" />
之后会重启，效果（两个文件夹都没有了)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果恢复到B，然后再创建一个快照，就会变成
&lt;img src="img/ly-20241212142133305.png" alt="ly-20241212142133305" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="虚拟机迁移">
 虚拟机迁移
 &lt;a class="anchor" href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e8%bf%81%e7%a7%bb">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>直接剪切、删除，即可
&lt;img src="img/ly-20241212142133375.png" alt="ly-20241212142133375" />&lt;/li>
&lt;/ul>
&lt;h2 id="vmtools工具">
 vmtools工具
 &lt;a class="anchor" href="#vmtools%e5%b7%a5%e5%85%b7">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>如下步骤，注意，这里只是在有界面的情况下进行安装
&lt;img src="img/ly-20241212142133446.png" alt="ly-20241212142133446" />&lt;/li>
&lt;li>安装完毕后
&lt;ul>
&lt;li>在vm上面设置
&lt;img src="img/ly-20241212142133522.png" alt="ly-20241212142133522" />&lt;/li>
&lt;li>共享文件夹在linux中的路径 /mnt/hgfs/myshare&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Flowable-05-spring-boot</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/offical/05/</link><pubDate>Fri, 29 Apr 2022 15:31:15 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/offical/05/</guid><description>&lt;h3 id="入门">
 入门
 &lt;a class="anchor" href="#%e5%85%a5%e9%97%a8">#&lt;/a>
&lt;/h3>
&lt;p>需要两个依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;properties&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;flowable.version&amp;gt;&lt;/span>6.7.2&lt;span style="color:#f92672">&amp;lt;/flowable.version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/properties&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.flowable&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>flowable-spring-boot-starter&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>${flowable.version}&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">&amp;lt;!-- https://mvnrepository.com/artifact/com.h2database/h2 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.h2database&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>h2&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>2.1.212&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结合Spring：&lt;/p>
&lt;p>只需将依赖项添加到类路径并使用*@SpringBootApplication*注释，幕后就会发生很多事情：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>自动创建内存数据源（因为 H2 驱动程序位于类路径中）并传递给 Flowable 流程引擎配置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>已创建并公开了 Flowable ProcessEngine、CmmnEngine、DmnEngine、FormEngine、ContentEngine 和 IdmEngine bean&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有 Flowable 服务都暴露为 Spring bean&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring Job Executor 已创建&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将自动部署&lt;em>流程&lt;/em>文件夹中的任何 BPMN 2.0 流程定义。创建一个文件夹&lt;em>processes&lt;/em>并将一个虚拟进程定义（名为&lt;em>one-task-process.bpmn20.xml&lt;/em>）添加到此文件夹。该文件的内容如下所示。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;?&lt;/span>xml version&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;1.0&amp;#34;&lt;/span> encoding&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;UTF-8&amp;#34;&lt;/span>&lt;span style="color:#f92672">?&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>definitions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xmlns&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.omg.org/spec/BPMN/20100524/MODEL&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> xmlns:flowable&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://flowable.org/bpmn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> targetNamespace&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Examples&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>process id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;oneTaskProcess&amp;#34;&lt;/span> name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;The One Task Process&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>startEvent id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;theStart&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>sequenceFlow id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;flow1&amp;#34;&lt;/span> sourceRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;theStart&amp;#34;&lt;/span> targetRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;theTask&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>userTask id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;theTask&amp;#34;&lt;/span> name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;my task&amp;#34;&lt;/span> flowable:assignee&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;kermit&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>sequenceFlow id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;flow2&amp;#34;&lt;/span> sourceRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;theTask&amp;#34;&lt;/span> targetRef&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;theEnd&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>endEvent id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;theEnd&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/&lt;/span>process&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/&lt;/span>definitions&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;em>案例&lt;/em>文件夹中的任何 CMMN 1.1 案例定义都将自动部署。&lt;/p></description></item><item><title>Flowable-04-spring</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/offical/04/</link><pubDate>Fri, 29 Apr 2022 14:57:32 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/offical/04/</guid><description>&lt;h3 id="processenginefactorybean">
 ProcessEngineFactoryBean
 &lt;a class="anchor" href="#processenginefactorybean">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>将ProcessEngine配置为常规的SpringBean&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngineConfiguration&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">class=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.flowable.spring.SpringProcessEngineConfiguration&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/bean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngine&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">class=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.flowable.spring.ProcessEngineFactoryBean&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngineConfiguration&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">ref=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngineConfiguration&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/bean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用transaction&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;beans&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xmlns:context=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.springframework.org/schema/context&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xmlns:tx=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.springframework.org/schema/tx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.springframework.org/schema/beans
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> http://www.springframework.org/schema/beans/spring-beans.xsd
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> http://www.springframework.org/schema/context
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> http://www.springframework.org/schema/context/spring-context-2.5.xsd
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> http://www.springframework.org/schema/tx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;dataSource&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">class=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.springframework.jdbc.datasource.SimpleDriverDataSource&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;driverClass&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.h2.Driver&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;url&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;jdbc:h2:mem:flowable;DB_CLOSE_DELAY=1000&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;username&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sa&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;password&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;transactionManager&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">class=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.springframework.jdbc.datasource.DataSourceTransactionManager&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;dataSource&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">ref=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;dataSource&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngineConfiguration&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">class=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.flowable.spring.SpringProcessEngineConfiguration&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;dataSource&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">ref=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;dataSource&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;transactionManager&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">ref=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;transactionManager&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;databaseSchemaUpdate&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;asyncExecutorActivate&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;false&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngine&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">class=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.flowable.spring.ProcessEngineFactoryBean&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngineConfiguration&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">ref=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngineConfiguration&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;repositoryService&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">factory-bean=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngine&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">factory-method=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;getRepositoryService&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;runtimeService&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">factory-bean=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngine&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">factory-method=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;getRuntimeService&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;taskService&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">factory-bean=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngine&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">factory-method=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;getTaskService&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;historyService&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">factory-bean=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngine&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">factory-method=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;getHistoryService&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;managementService&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">factory-bean=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngine&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">factory-method=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;getManagementService&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>还包括了其他的一些bean&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>beans&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>tx:annotation&lt;span style="color:#f92672">-&lt;/span>driven transaction&lt;span style="color:#f92672">-&lt;/span>manager&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;transactionManager&amp;#34;&lt;/span>&lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>bean id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;userBean&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">=&amp;#34;&lt;/span>&lt;span style="color:#a6e22e">org&lt;/span>.&lt;span style="color:#a6e22e">flowable&lt;/span>.&lt;span style="color:#a6e22e">spring&lt;/span>.&lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">UserBean&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;property name=&amp;#34;&lt;/span>runtimeService&lt;span style="color:#e6db74">&amp;#34; ref=&amp;#34;&lt;/span>runtimeService&lt;span style="color:#e6db74">&amp;#34; /&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;/bean&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;bean id=&amp;#34;&lt;/span>printer&lt;span style="color:#e6db74">&amp;#34; class=&amp;#34;&lt;/span>org.&lt;span style="color:#a6e22e">flowable&lt;/span>.&lt;span style="color:#a6e22e">spring&lt;/span>.&lt;span style="color:#a6e22e">test&lt;/span>.&lt;span style="color:#a6e22e">Printer&lt;/span>&lt;span style="color:#e6db74">&amp;#34; /&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;lt;/beans&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用&lt;/p></description></item><item><title>Flowable-03-api</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/offical/03/</link><pubDate>Fri, 29 Apr 2022 09:57:47 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/offical/03/</guid><description>&lt;h3 id="流程引擎api和服务">
 流程引擎API和服务
 &lt;a class="anchor" href="#%e6%b5%81%e7%a8%8b%e5%bc%95%e6%93%8eapi%e5%92%8c%e6%9c%8d%e5%8a%a1">#&lt;/a>
&lt;/h3>
&lt;p>引擎API是与Flowable交互的常见方式，主要起点是ProcessEngine，可以通过配置（Configuration章节）中描述的多种方式创建。&lt;/p>
&lt;p>从ProcessEngine获取包含工作流/BPM方法的各种服务。ProcessEngine和服务对象是线程安全的&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142116684.png" alt="ly-20241212142116684" />&lt;/p>
&lt;p>下面是通过processEngine获取各种服务的方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ProcessEngine processEngine &lt;span style="color:#f92672">=&lt;/span> ProcessEngines.&lt;span style="color:#a6e22e">getDefaultProcessEngine&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RuntimeService runtimeService &lt;span style="color:#f92672">=&lt;/span> processEngine.&lt;span style="color:#a6e22e">getRuntimeService&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RepositoryService repositoryService &lt;span style="color:#f92672">=&lt;/span> processEngine.&lt;span style="color:#a6e22e">getRepositoryService&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TaskService taskService &lt;span style="color:#f92672">=&lt;/span> processEngine.&lt;span style="color:#a6e22e">getTaskService&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ManagementService managementService &lt;span style="color:#f92672">=&lt;/span> processEngine.&lt;span style="color:#a6e22e">getManagementService&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IdentityService identityService &lt;span style="color:#f92672">=&lt;/span> processEngine.&lt;span style="color:#a6e22e">getIdentityService&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HistoryService historyService &lt;span style="color:#f92672">=&lt;/span> processEngine.&lt;span style="color:#a6e22e">getHistoryService&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>FormService formService &lt;span style="color:#f92672">=&lt;/span> processEngine.&lt;span style="color:#a6e22e">getFormService&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DynamicBpmnService dynamicBpmnService &lt;span style="color:#f92672">=&lt;/span> processEngine.&lt;span style="color:#a6e22e">getDynamicBpmnService&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ProcessEngines.getDefaultProcessEngine()在第一次调用时初始化并构建流程引擎，然后返回相同的流程引擎&lt;/p>
&lt;p>ProcessEngines类将扫描所有flowable.cfg.xml和flowable-context.xml文件。&lt;/p>
&lt;blockquote>
&lt;p>对于所有 flowable.cfg.xml 文件，流程引擎将以典型的 Flowable 方式构建：ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream).buildProcessEngine()。&lt;/p>
&lt;p>对于所有 flowable-context.xml 文件，流程引擎将以 Spring 方式构建：首先创建 Spring 应用程序上下文，然后从该应用程序上下文中获取流程引擎。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>The &lt;strong>RepositoryService&lt;/strong> is probably the first service needed when working with the Flowable engine.&lt;/p>
&lt;/blockquote>
&lt;p>该服务**(RepositoryService)&lt;strong>提供用于管理和操作部署&lt;/strong>deployments**和流程定义的操作&lt;/p>
&lt;ul>
&lt;li>查询引擎已知的部署和流程定义&lt;/li>
&lt;li>暂停和激活作为一个整体或特定流程定义的部署。挂起意味着不能对它们执行进一步的操作，而激活则相反并再次启用操作&lt;/li>
&lt;li>检索各种资源，例如引擎自动生成的部署或流程图中包含的文件&lt;/li>
&lt;li>检索流程定义的 POJO 版本，该版本可用于使用 Java 而不是 XML 来内省流程&lt;/li>
&lt;/ul>
&lt;p>RepositoryService主要是关于静态信息（不会改变的数据，或者至少不会改变太多），而RuntimeService处理启动流程定义的&lt;em>新流程实例&lt;/em>&lt;/p></description></item><item><title>Flowable-02-Configuration</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/offical/02/</link><pubDate>Fri, 29 Apr 2022 09:37:24 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/offical/02/</guid><description>&lt;h3 id="创建流程引擎">
 创建流程引擎
 &lt;a class="anchor" href="#%e5%88%9b%e5%bb%ba%e6%b5%81%e7%a8%8b%e5%bc%95%e6%93%8e">#&lt;/a>
&lt;/h3>
&lt;p>Flowable 流程引擎通过一个名为 flowable.cfg.xml 的 XML 文件进行配置&lt;/p>
&lt;ul>
&lt;li>
&lt;p>现在类路径下放置floable.cfg.xml文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;beans&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;bean&lt;/span> &lt;span style="color:#a6e22e">id=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;processEngineConfiguration&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">class=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;jdbcUrl&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;jdbc:h2:mem:flowable;DB_CLOSE_DELAY=1000&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;jdbcDriver&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.h2.Driver&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;jdbcUsername&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;sa&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;jdbcPassword&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;databaseSchemaUpdate&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;asyncExecutorActivate&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;false&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;mailServerHost&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;mail.my-corp.com&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;property&lt;/span> &lt;span style="color:#a6e22e">name=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;mailServerPort&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">value=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;5025&amp;#34;&lt;/span> &lt;span style="color:#f92672">/&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/bean&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/beans&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>然后使用静态方法进行获取ProcessEngine&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ProcessEngine processEngine &lt;span style="color:#f92672">=&lt;/span> ProcessEngines.&lt;span style="color:#a6e22e">getDefaultProcessEngine&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>还有其他配置，这里不一一列举，详见文档地址
&lt;a href="https://www.flowable.com/open-source/docs/bpmn/ch03-Configuration">https://www.flowable.com/open-source/docs/bpmn/ch03-Configuration&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>大致目录如下
&lt;img src="img/ly-20241212142116369.png" alt="ly-20241212142116369" />
&lt;img src="img/ly-20241212142116576.png" alt="ly-20241212142116576" />&lt;/p>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul></description></item><item><title>Flowable-01-GettingStarted</title><link>https://lwmfjc.github.io/zh/docs/technology/Flowable/offical/01/</link><pubDate>Wed, 27 Apr 2022 22:32:24 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Flowable/offical/01/</guid><description>&lt;h2 id="入门">
 入门
 &lt;a class="anchor" href="#%e5%85%a5%e9%97%a8">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是流动性">
 什么是流动性
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%b5%81%e5%8a%a8%e6%80%a7">#&lt;/a>
&lt;/h3>
&lt;blockquote>
&lt;p>Flowable 是一个用 Java 编写的轻量级业务流程引擎。Flowable 流程引擎允许您部署 BPMN 2.0 流程定义（用于定义流程的行业 XML 标准）、创建这些流程定义的流程实例、运行查询、访问活动或历史流程实例和相关数据等等。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>可以使用 Flowable REST API 通过 HTTP 进行通信。还有几个 Flowable 应用程序（Flowable Modeler、Flowable Admin、Flowable IDM 和 Flowable Task）提供开箱即用的示例 UI，用于处理流程和任务。&lt;/p>
&lt;/blockquote>
&lt;h3 id="flowable和activiti">
 Flowable和Activiti
 &lt;a class="anchor" href="#flowable%e5%92%8cactiviti">#&lt;/a>
&lt;/h3>
&lt;p>Flowable是Activiti的一个分支&lt;/p>
&lt;h3 id="构建命令行命令">
 构建命令行命令
 &lt;a class="anchor" href="#%e6%9e%84%e5%bb%ba%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%91%bd%e4%bb%a4">#&lt;/a>
&lt;/h3>
&lt;h4 id="创建流程引擎">
 创建流程引擎
 &lt;a class="anchor" href="#%e5%88%9b%e5%bb%ba%e6%b5%81%e7%a8%8b%e5%bc%95%e6%93%8e">#&lt;/a>
&lt;/h4>
&lt;p>请假流程如下&lt;/p>
&lt;ul>
&lt;li>员工要求休假数次&lt;/li>
&lt;li>经理批准或拒绝请求&lt;/li>
&lt;li>之后将模拟再某个外部系统中注册请求，并向员工发送一封包含结果的邮件&lt;/li>
&lt;/ul>
&lt;p>创建一个空的Mave项目，并添加依赖&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.flowable&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>flowable-engine&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>6.6.0&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.h2database&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>h2&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.3.176&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>mysql&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>mysql-connector-java&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>8.0.29&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span> &lt;span style="color:#75715e">&amp;lt;!--当版本号&amp;gt;=8.0.22时会报date转字符串的错误--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>添加一个带有Main方法的类&lt;/p>
&lt;p>这里实例化一个&lt;strong>ProcessEngine&lt;/strong>实例，一般只需要实例化一次，是通过&lt;strong>ProcessEngineConfiguration&lt;/strong>创建的，用来配置和调整流程引擎的配置&lt;/p>
&lt;ul>
&lt;li>&lt;em>ProcessEngineConfiguration&lt;/em>也可以使用配置 XML 文件创建&lt;/li>
&lt;li>&lt;em>ProcessEngineConfiguration&lt;/em>需要的最低配置是与数据库的 JDBC 连接&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> org.flowable;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.flowable.engine.ProcessEngine;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.flowable.engine.ProcessEngineConfiguration;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">HolidayRequest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//这里改用mysql，注意后面的nullCatalogMeansCurrent=true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//注意，pom需要添加mysql驱动依赖&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ProcessEngineConfiguration cfg &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StandaloneProcessEngineConfiguration()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">setJdbcUrl&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;jdbc:mysql://localhost:3306/flowable_official?useUnicode=true&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;allowMultiQueries=true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;amp;nullCatalogMeansCurrent=true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">setJdbcUsername&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">setJdbcPassword&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;123456&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">setJdbcDriver&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;com.mysql.cj.jdbc.Driver&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">setDatabaseSchemaUpdate&lt;/span>(ProcessEngineConfiguration.&lt;span style="color:#a6e22e">DB_SCHEMA_UPDATE_TRUE&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* //这是官网，用的h2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> ProcessEngineConfiguration cfg = new StandaloneProcessEngineConfiguration()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> .setJdbcUrl(&amp;#34;jdbc:h2:mem:flowable;DB_CLOSE_DELAY=-1&amp;#34;)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> .setJdbcUsername(&amp;#34;sa&amp;#34;)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> .setJdbcPassword(&amp;#34;&amp;#34;)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> .setJdbcDriver(&amp;#34;org.h2.Driver&amp;#34;)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ProcessEngine processEngine &lt;span style="color:#f92672">=&lt;/span> cfg.&lt;span style="color:#a6e22e">buildProcessEngine&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行后会出现slf4j的警告，添加依赖并编写配置文件即可&lt;/p></description></item><item><title>算法红皮书 2.1.2-2.1.3</title><link>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/2.1.2-2.1.3/</link><pubDate>Sat, 23 Apr 2022 15:54:21 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/2.1.2-2.1.3/</guid><description>&lt;h1 id="排序">
 排序
 &lt;a class="anchor" href="#%e6%8e%92%e5%ba%8f">#&lt;/a>
&lt;/h1>
&lt;h2 id="初级排序算法">
 初级排序算法
 &lt;a class="anchor" href="#%e5%88%9d%e7%ba%a7%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;h3 id="选择排序">
 选择排序
 &lt;a class="anchor" href="#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>命题A。对于长度为N 的数组，选择排序需要大约 N^2/2 次比较和N 次交换。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Selection&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sort&lt;/span>(Comparable&lt;span style="color:#f92672">[]&lt;/span> a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 将a[]按升序排列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">int&lt;/span> N &lt;span style="color:#f92672">=&lt;/span> a.&lt;span style="color:#a6e22e">length&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 数组长度&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> N; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">// 将a[i]和a[i+1..N]中最小的元素交换&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">int&lt;/span> min &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">// 最小元素的索引&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">+&lt;/span>1; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> N; j&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">if&lt;/span> (less(a&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span>, a&lt;span style="color:#f92672">[&lt;/span>min&lt;span style="color:#f92672">]&lt;/span>)) min &lt;span style="color:#f92672">=&lt;/span> j;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			exch(a, i, min);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// less()、exch()、isSorted()和main()方法见“排序算法类模板”&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>特点&lt;/p>
&lt;ul>
&lt;li>运行时间与输入无关，即输入数据的初始状态（比如是否已排序好等等）不影响排序时间&lt;/li>
&lt;li>数据移动是最少的（只使用了N次交换，交换次数和数组的大小是线性关系&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="插入排序">
 插入排序
 &lt;a class="anchor" href="#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>命题B。对于随机排列的长度为N 且主键不重复的数组，平均情况下插入排序需要～ N^2/4 次比较以及～ N^2/4 次交换。最坏情况下需要～ N^2/2 次比较和～ N^2/2 次交换，最好情况下需要N-1次比较和0 次交换。&lt;/p></description></item><item><title>git使用ssh连不上</title><link>https://lwmfjc.github.io/zh/docs/problem/Git/01/</link><pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/Git/01/</guid><description>&lt;ul>
&lt;li>
&lt;p>处理方式
在系统的host文件中，添加ip指定&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-tex" data-lang="tex">&lt;span style="display:flex;">&lt;span>199.232.69.194 github.global.ssl.fastly.net
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>140.82.114.4 github.com
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;/li>
&lt;/ul></description></item><item><title>《作酒》有感</title><link>https://lwmfjc.github.io/zh/docs/life/archive/20220416/</link><pubDate>Sat, 16 Apr 2022 17:11:46 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/life/archive/20220416/</guid><description>&lt;p>最近几天吃饭，经常听到一首很嗨的歌。旋律很轻快，其实本来也就一听而过，可能是耳闻目染次数多了，好奇心上来了，查了下歌词。&lt;/p>
&lt;p>听这首歌期间我居然联想了很多，果然是老emo了。不知道怎么回事，我这种与世无争的心态，听完后居然也让我幻想了一下这歌描述的爱情模样。我又突然想到，如今社会上离婚率居高不下，也许与网络信息的传输有密切关联。如果是古代，嫁错人或者娶错人，大家也都都认了，有什么小打小闹都互相包含。而如今，生活压力不断增大，加上网络上爆炸式（至少效果是）的宣传爱情，对比显著，很让人一着魔就陷进去，就摒弃几年甚至十几年的夫妻之情，去追求所谓的真爱、自由。&lt;/p>
&lt;p>每个人对自己的过往，或多或少都会不甘。如果这种不甘自己没有办法化解，那么就会在某一刻爆发。每个人都应该，也必定会为自己曾经的所作所为负责。不要懵懵懂懂地进入(现代)婚姻，这样对自己和它人都极其不负责。 爆炸式的信息接收会激发你所有的冲动与不甘。&lt;/p>
&lt;iframe style="height: 60vh;width: 100%;" src="//player.bilibili.com/player.html?aid=211411097&amp;amp;bvid=BV1aa411y7u9&amp;amp;cid=505755578&amp;amp;page=1" scrolling="no" border="0"
 frameborder="no" framespacing="0" allowfullscreen="true">&lt;/iframe></description></item><item><title>算法红皮书 2.1.1</title><link>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/2.1.1/</link><pubDate>Wed, 13 Apr 2022 22:43:21 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/2.1.1/</guid><description>&lt;h1 id="排序">
 排序
 &lt;a class="anchor" href="#%e6%8e%92%e5%ba%8f">#&lt;/a>
&lt;/h1>
&lt;p>排序就是将一组对象按照某种逻辑顺序重新排序的过程&lt;/p>
&lt;ul>
&lt;li>对排序算法的分析有助于理解本书中比较算法性能的方法&lt;/li>
&lt;li>类似技术能解决其他类型问题&lt;/li>
&lt;li>排序算法常常是我们解决其他问题的第一步&lt;/li>
&lt;/ul>
&lt;h2 id="初级排序算法">
 初级排序算法
 &lt;a class="anchor" href="#%e5%88%9d%e7%ba%a7%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>熟悉术语及技巧&lt;/li>
&lt;li>某些情况下初级算法更有效&lt;/li>
&lt;li>有助于改进复杂算法的效率&lt;/li>
&lt;/ul>
&lt;h3 id="游戏规则">
 游戏规则
 &lt;a class="anchor" href="#%e6%b8%b8%e6%88%8f%e8%a7%84%e5%88%99">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>主要关注重新排序&lt;strong>数组元素&lt;/strong>的算法，每个元素都会有一个&lt;strong>主键&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>排序后索引较大的主键大于索引较小的主键&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一般情况下排序算法通过两个方法操作数据，less()进行比较，exch()进行交换&lt;/p>
&lt;/li>
&lt;li>
&lt;p>排序算法类的模板&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Example&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sort&lt;/span>(Comparable&lt;span style="color:#f92672">[]&lt;/span> a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/* 请见算法2.1、算法2.2、算法2.3、算法2.4、算法2.5或算法2.7*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Boolean &lt;span style="color:#a6e22e">less&lt;/span>(Comparable v, Comparable w)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> v.&lt;span style="color:#a6e22e">compareTo&lt;/span>(w) &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">exch&lt;/span>(Comparable&lt;span style="color:#f92672">[]&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> i, &lt;span style="color:#66d9ef">int&lt;/span> j)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		Comparable t &lt;span style="color:#f92672">=&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		a&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">show&lt;/span>(Comparable&lt;span style="color:#f92672">[]&lt;/span> a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 在单行中打印数组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> a.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		StdOut.&lt;span style="color:#a6e22e">print&lt;/span>(a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		StdOut.&lt;span style="color:#a6e22e">println&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Boolean &lt;span style="color:#a6e22e">isSorted&lt;/span>(Comparable&lt;span style="color:#f92672">[]&lt;/span> a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 测试数组元素是否有序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> a.&lt;span style="color:#a6e22e">length&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">if&lt;/span> (less(a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span>, a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>)) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 从标准输入读取字符串，将它们排序并输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		String&lt;span style="color:#f92672">[]&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> In.&lt;span style="color:#a6e22e">readStrings&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		sort(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">assert&lt;/span> isSorted(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		show(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>使用&lt;/p></description></item><item><title>05高级功能</title><link>https://lwmfjc.github.io/zh/docs/technology/RocketMQ/heima/05advance/</link><pubDate>Sat, 09 Apr 2022 09:20:04 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/RocketMQ/heima/05advance/</guid><description>&lt;blockquote>
&lt;p>学习来源 &lt;a href="https://www.bilibili.com/video/BV1L4411y7mn">https://www.bilibili.com/video/BV1L4411y7mn&lt;/a>（添加小部分笔记）感谢作者！&lt;/p>
&lt;/blockquote>
&lt;h1 id="消息存储">
 消息存储
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e5%ad%98%e5%82%a8">#&lt;/a>
&lt;/h1>
&lt;h2 id="流程">
 流程
 &lt;a class="anchor" href="#%e6%b5%81%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142201154.png" alt="ly-20241212142201154" />&lt;/p>
&lt;h2 id="存储介质">
 存储介质
 &lt;a class="anchor" href="#%e5%ad%98%e5%82%a8%e4%bb%8b%e8%b4%a8">#&lt;/a>
&lt;/h2>
&lt;h3 id="关系型数据库db">
 关系型数据库DB
 &lt;a class="anchor" href="#%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93db">#&lt;/a>
&lt;/h3>
&lt;p>适合数据量不够大，比如&lt;strong>ActiveMQ&lt;/strong>可选用JDBC方式作为消息持久化&lt;/p>
&lt;h3 id="文件系统">
 文件系统
 &lt;a class="anchor" href="#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>关系型数据库最终也是要存到文件系统中的，不如直接存到文件系统，绕过关系型数据库&lt;/li>
&lt;li>常见的RocketMQ/RabbitMQ/Kafka都是采用消息刷盘到计算机的文件系统来做持久化(&lt;strong>同步刷盘&lt;/strong>/&lt;strong>异步刷盘&lt;/strong>)&lt;/li>
&lt;/ol>
&lt;h2 id="消息发送">
 消息发送
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e5%8f%91%e9%80%81">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>顺序写：600MB/s，随机写：100KB/s&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>
&lt;p>系统运行一段时间后，我们对文件的增删改会导致磁盘上数据无法连续，非常的分散。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>顺序读也只是逻辑上的顺序，也就是按照当前文件的相对偏移量顺序读取，并非磁盘上连续空间读取&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于磁盘的读写分为两种模式，&lt;strong>顺序IO&lt;/strong>和&lt;strong>随机IO&lt;/strong>。 随机IO存在一个寻址的过程，所以效率比较低。而顺序IO，相当于有一个&lt;strong>物理索引&lt;/strong>，在读取的时候不需要寻找地址，效率很高。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>来源： &lt;a href="https://www.cnblogs.com/liuche/p/15455808.html">https://www.cnblogs.com/liuche/p/15455808.html&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>数据网络传输&lt;/p>
&lt;p>零拷贝技术&lt;strong>MappedByteBuffer&lt;/strong>，省去了用户态，由&lt;strong>内核态&lt;/strong>直接拷贝到&lt;strong>网络驱动内核&lt;/strong>。 &lt;br>
RocketMQ默认设置单个CommitLog日志数据文件为1G&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142201208.png" alt="ly-20241212142201208" />&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="消息存储-1">
 消息存储
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e5%ad%98%e5%82%a8-1">#&lt;/a>
&lt;/h2>
&lt;p>三个概念：commitLog、ConsumerQueue、index&lt;/p>
&lt;h3 id="commitlog">
 CommitLog
 &lt;a class="anchor" href="#commitlog">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>默认大小1G&lt;br>
&lt;img src="img/ly-20241212142201240.png" alt="ly-20241212142201240" />&lt;/li>
&lt;li>存储消息的元数据，包括了Topic、QueueId、Message&lt;/li>
&lt;li>还存储了ConsumerQueue相关信息，所以ConsumerQueue丢了也没事&lt;/li>
&lt;/ol>
&lt;h3 id="consumerqueue">
 ConsumerQueue
 &lt;a class="anchor" href="#consumerqueue">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>存储了消息在CommitLog的索引（几百K，Linux会事先加载到内存中）&lt;/li>
&lt;li>包括最小/最大偏移量、已经消费的偏移量&lt;/li>
&lt;li>一个Topic多个队列，每个队列对应一个ConsumerQueue&lt;br>
&lt;img src="img/ly-20241212142201276.png" alt="ly-20241212142201276" />&lt;/li>
&lt;/ol>
&lt;h3 id="index">
 Index
 &lt;a class="anchor" href="#index">#&lt;/a>
&lt;/h3>
&lt;p>也是索引文件，为消息查询服务，通过key或时间区间查询消息&lt;/p>
&lt;h3 id="总结">
 总结
 &lt;a class="anchor" href="#%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="img/ly-20241212142201312.png" alt="ly-20241212142201312" />&lt;/p>
&lt;h2 id="刷盘机制">
 刷盘机制
 &lt;a class="anchor" href="#%e5%88%b7%e7%9b%98%e6%9c%ba%e5%88%b6">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142201340.png" alt="ly-20241212142201340" />&lt;/p>
&lt;ol>
&lt;li>同步刷盘&lt;/li>
&lt;li>异步刷盘&lt;/li>
&lt;/ol>
&lt;h1 id="高可用性机制">
 高可用性机制
 &lt;a class="anchor" href="#%e9%ab%98%e5%8f%af%e7%94%a8%e6%80%a7%e6%9c%ba%e5%88%b6">#&lt;/a>
&lt;/h1>
&lt;h2 id="消费高可用及发送高可用">
 消费高可用及发送高可用
 &lt;a class="anchor" href="#%e6%b6%88%e8%b4%b9%e9%ab%98%e5%8f%af%e7%94%a8%e5%8f%8a%e5%8f%91%e9%80%81%e9%ab%98%e5%8f%af%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142201372.png" alt="ly-20241212142201372" />&lt;/p></description></item><item><title>算法红皮书 1.5.1-1.5.3</title><link>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.5.1-1.5.3/</link><pubDate>Sat, 09 Apr 2022 08:01:47 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.5.1-1.5.3/</guid><description>&lt;h2 id="案例研究union-find-算法">
 案例研究：union-find 算法
 &lt;a class="anchor" href="#%e6%a1%88%e4%be%8b%e7%a0%94%e7%a9%b6union-find-%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>设计和分析算法的基本方法
&lt;ul>
&lt;li>优秀的算法能解决实际问题&lt;/li>
&lt;li>高效的算法也可以很简单&lt;/li>
&lt;li>理解某个实现的性能特点是一项有趣的挑战&lt;/li>
&lt;li>在解决同一个问题的多种算法间选择，科学方法是一种重要工具&lt;/li>
&lt;li>迭代式改进能让算法效率越来越高&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="动态连通性">
 动态连通性
 &lt;a class="anchor" href="#%e5%8a%a8%e6%80%81%e8%bf%9e%e9%80%9a%e6%80%a7">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>从输入中读取整数对p q，如果已知的所有整数对都不能说明p,q相连，就打印出pq&lt;/li>
&lt;li>网络：整个程序能够判定是否需要在pq之间架设一条新的连接才能进行通信&lt;/li>
&lt;li>变量名等价性（即指向同一个对象的多个引用）&lt;/li>
&lt;li>数学集合：在处理一个整数对pq时，我们是在判断它们是否属于相同的集合&lt;/li>
&lt;li>本节中，将对象称为&lt;strong>触点&lt;/strong>，整数对称为&lt;strong>连接&lt;/strong>，等价类称为&lt;strong>连通分量&lt;/strong>或是&lt;strong>简称分量&lt;/strong>&lt;/li>
&lt;li>连通性 问题只要求我们的程序能够判别给定的整数对pq是否相连，并没有要求给两者之间的通路上的所有连接&lt;/li>
&lt;li>union-find算法的API&lt;br>
&lt;img src="img/ly-20241212142056628.png" alt="ly-20241212142056628" />&lt;/li>
&lt;li>数据结构和算法的设计影响到算法的效率&lt;/li>
&lt;/ul>
&lt;h3 id="实现">
 实现
 &lt;a class="anchor" href="#%e5%ae%9e%e7%8e%b0">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">UF&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span>	id;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/* 分量id（以触点作为索引） */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>	count;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/* 分量数量 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">UF&lt;/span>( &lt;span style="color:#66d9ef">int&lt;/span> N )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/* 初始化分量id数组 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		count	&lt;span style="color:#f92672">=&lt;/span> N;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		id	&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>N&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">for&lt;/span> ( &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> N; i&lt;span style="color:#f92672">++&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					id&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">count&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span>(count);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> Boolean &lt;span style="color:#a6e22e">connected&lt;/span>( &lt;span style="color:#66d9ef">int&lt;/span> p, &lt;span style="color:#66d9ef">int&lt;/span> q )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span>(find( p ) &lt;span style="color:#f92672">==&lt;/span> find( q ) );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">find&lt;/span>( &lt;span style="color:#66d9ef">int&lt;/span> p )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">union&lt;/span>( &lt;span style="color:#66d9ef">int&lt;/span> p, &lt;span style="color:#66d9ef">int&lt;/span> q )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/* 请见1.5.2.1节用例（quick-find）、1.5.2.3节用例（quick-union）和算法1.5（加权quick-union） */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>( String&lt;span style="color:#f92672">[]&lt;/span> args )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/* 解决由StdIn得到的动态连通性问题 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">int&lt;/span>	N	&lt;span style="color:#f92672">=&lt;/span> StdIn.&lt;span style="color:#a6e22e">readint&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/* 读取触点数量 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		UF	uf	&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> UF( N );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/* 初始化N个分量 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">while&lt;/span> ( &lt;span style="color:#f92672">!&lt;/span>StdIn.&lt;span style="color:#a6e22e">isEmpty&lt;/span>() )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">int&lt;/span>	p	&lt;span style="color:#f92672">=&lt;/span> StdIn.&lt;span style="color:#a6e22e">readint&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">int&lt;/span>	q	&lt;span style="color:#f92672">=&lt;/span> StdIn.&lt;span style="color:#a6e22e">readint&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">/* 读取整数对 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">if&lt;/span> ( uf.&lt;span style="color:#a6e22e">connected&lt;/span>( p, q ) )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>							&lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">/* 如果已经连通则忽略 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			uf.&lt;span style="color:#a6e22e">union&lt;/span>( p, q );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">/* 归并分量 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			StdOut.&lt;span style="color:#a6e22e">println&lt;/span>( p &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> q );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">/* 打印连接 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		StdOut.&lt;span style="color:#a6e22e">println&lt;/span>( uf.&lt;span style="color:#a6e22e">count&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;components&amp;#34;&lt;/span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>union-find的成本模型：union-find API的各种算法，统计的是&lt;strong>数组的访问次数&lt;/strong>，不论读写&lt;/p></description></item><item><title>04案例</title><link>https://lwmfjc.github.io/zh/docs/technology/RocketMQ/heima/04case/</link><pubDate>Fri, 08 Apr 2022 11:00:03 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/RocketMQ/heima/04case/</guid><description>&lt;blockquote>
&lt;p>学习来源 &lt;a href="https://www.bilibili.com/video/BV1L4411y7mn">https://www.bilibili.com/video/BV1L4411y7mn&lt;/a>（添加小部分笔记）感谢作者!基本架构&lt;/p>
&lt;/blockquote>
&lt;h2 id="架构">
 架构
 &lt;a class="anchor" href="#%e6%9e%b6%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212142200977.png" alt="ly-20241212142200977" />&lt;/p>
&lt;h2 id="流程图">
 流程图
 &lt;a class="anchor" href="#%e6%b5%81%e7%a8%8b%e5%9b%be">#&lt;/a>
&lt;/h2>
&lt;h3 id="下单流程">
 下单流程
 &lt;a class="anchor" href="#%e4%b8%8b%e5%8d%95%e6%b5%81%e7%a8%8b">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="img/ly-20241212142201029.png" alt="ly-20241212142201029" />&lt;/p>
&lt;h3 id="支付流程">
 支付流程
 &lt;a class="anchor" href="#%e6%94%af%e4%bb%98%e6%b5%81%e7%a8%8b">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="img/ly-20241212142201068.png" alt="ly-20241212142201068" />&lt;/p>
&lt;h1 id="springboot整合rocketmq">
 SpringBoot整合RocketMQ
 &lt;a class="anchor" href="#springboot%e6%95%b4%e5%90%88rocketmq">#&lt;/a>
&lt;/h1>
&lt;h2 id="依赖包">
 依赖包
 &lt;a class="anchor" href="#%e4%be%9d%e8%b5%96%e5%8c%85">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>	 &lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.apache.rocketmq&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>rocketmq-spring-boot-starter&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="生产者">
 生产者
 &lt;a class="anchor" href="#%e7%94%9f%e4%ba%a7%e8%80%85">#&lt;/a>
&lt;/h2>
&lt;h3 id="yaml">
 yaml
 &lt;a class="anchor" href="#yaml">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rocketmq&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name-server&lt;/span>: &lt;span style="color:#ae81ff">192.168.1.135&lt;/span>:&lt;span style="color:#ae81ff">9876&lt;/span>&lt;span style="color:#ae81ff">;192.168.1.138:9876&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">producer&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group&lt;/span>: &lt;span style="color:#ae81ff">my-group&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="使用">
 使用
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> RocketMQTemplate template;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@RequestMapping&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;rocketmq&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">rocketmq&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;我被调用了-rocketmq&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//主题+内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> template.&lt;span style="color:#a6e22e">convertAndSend&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;mytopic-ly&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;hello1231&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>serverPort;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="消费者">
 消费者
 &lt;a class="anchor" href="#%e6%b6%88%e8%b4%b9%e8%80%85">#&lt;/a>
&lt;/h2>
&lt;h3 id="yaml-1">
 yaml
 &lt;a class="anchor" href="#yaml-1">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">rocketmq&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name-server&lt;/span>: &lt;span style="color:#ae81ff">192.168.1.135&lt;/span>:&lt;span style="color:#ae81ff">9876&lt;/span>&lt;span style="color:#ae81ff">;192.168.1.138:9876&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">consumer&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">group&lt;/span>: &lt;span style="color:#ae81ff">my-group2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="使用-1">
 使用
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8-1">#&lt;/a>
&lt;/h3>
&lt;p>创建监听器&lt;/p></description></item><item><title>03收发消息</title><link>https://lwmfjc.github.io/zh/docs/technology/RocketMQ/heima/03messagetype/</link><pubDate>Thu, 07 Apr 2022 14:31:59 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/RocketMQ/heima/03messagetype/</guid><description>&lt;blockquote>
&lt;p>学习来源 &lt;a href="https://www.bilibili.com/video/BV1L4411y7mn">https://www.bilibili.com/video/BV1L4411y7mn&lt;/a>（添加小部分笔记）感谢作者!前提&lt;/p>
&lt;/blockquote>
&lt;h2 id="依赖包">
 依赖包
 &lt;a class="anchor" href="#%e4%be%9d%e8%b5%96%e5%8c%85">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.apache.rocketmq&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>rocketmq-client&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.4.0&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="消息生产者步骤">
 消息生产者步骤
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e7%94%9f%e4%ba%a7%e8%80%85%e6%ad%a5%e9%aa%a4">#&lt;/a>
&lt;/h2>
&lt;p>创建生产者，生产者组名&amp;ndash;&amp;gt;指定nameserver地址&amp;ndash;&amp;gt;启动producer&amp;ndash;&amp;gt;&lt;/p>
&lt;p>创建消息对象(Topic、Tag、消息体)&lt;/p>
&lt;p>发送消息、关闭生产者producer&lt;/p>
&lt;h2 id="消息消费者步骤">
 消息消费者步骤
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e6%b6%88%e8%b4%b9%e8%80%85%e6%ad%a5%e9%aa%a4">#&lt;/a>
&lt;/h2>
&lt;p>创建消费者，制定消费者组名&amp;ndash;&amp;gt;指定nameserver地址&lt;/p>
&lt;p>订阅Topic和Tag，设置回调函数处理消息&lt;/p>
&lt;p>启动消费者consumer&lt;/p>
&lt;h1 id="消息发送">
 消息发送
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e5%8f%91%e9%80%81">#&lt;/a>
&lt;/h1>
&lt;h2 id="同步消息">
 同步消息
 &lt;a class="anchor" href="#%e5%90%8c%e6%ad%a5%e6%b6%88%e6%81%af">#&lt;/a>
&lt;/h2>
&lt;p>发送消息后客户端会进行阻塞，直到得到结果后，客户端才会继续执行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> MQClientException, MQBrokerException, RemotingException, InterruptedException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//创建Producer，并指定生产者组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DefaultMQProducer producer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> DefaultMQProducer(&lt;span style="color:#e6db74">&amp;#34;group1&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> producer.&lt;span style="color:#a6e22e">setNamesrvAddr&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;192.168.1.135:9876;192.168.1.138:9876&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> producer.&lt;span style="color:#a6e22e">start&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Message msg &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Message();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg.&lt;span style="color:#a6e22e">setTopic&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;base&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg.&lt;span style="color:#a6e22e">setTags&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Tag1&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg.&lt;span style="color:#a6e22e">setBody&lt;/span>((&lt;span style="color:#e6db74">&amp;#34;hello world&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i).&lt;span style="color:#a6e22e">getBytes&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//发送消息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SendResult result &lt;span style="color:#f92672">=&lt;/span> producer.&lt;span style="color:#a6e22e">send&lt;/span>(msg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//发送状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SendStatus sendStatus &lt;span style="color:#f92672">=&lt;/span> result.&lt;span style="color:#a6e22e">getSendStatus&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//消息id&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String msgId &lt;span style="color:#f92672">=&lt;/span> result.&lt;span style="color:#a6e22e">getMsgId&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//消息接收队列id&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MessageQueue messageQueue &lt;span style="color:#f92672">=&lt;/span> result.&lt;span style="color:#a6e22e">getMessageQueue&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> queueId &lt;span style="color:#f92672">=&lt;/span> messageQueue.&lt;span style="color:#a6e22e">getQueueId&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">info&lt;/span>(result.&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">info&lt;/span>(messageQueue.&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;status:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> sendStatus &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;msgId:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> msgId &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;queueId&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> queueId);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TimeUnit.&lt;span style="color:#a6e22e">SECONDS&lt;/span>.&lt;span style="color:#a6e22e">sleep&lt;/span>(1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;发送结束===================&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> producer.&lt;span style="color:#a6e22e">shutdown&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="异步消息">
 异步消息
 &lt;a class="anchor" href="#%e5%bc%82%e6%ad%a5%e6%b6%88%e6%81%af">#&lt;/a>
&lt;/h2>
&lt;p>发送消息后不会导致阻塞，当broker返回结果时，会调用回调函数进行处理&lt;/p></description></item><item><title>算法红皮书 1.4.1-1.4.10</title><link>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.4.1-1.4.10/</link><pubDate>Thu, 07 Apr 2022 11:00:21 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.4.1-1.4.10/</guid><description>&lt;h2 id="算法分析">
 算法分析
 &lt;a class="anchor" href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h2>
&lt;p>使用&lt;strong>数学分析&lt;/strong>为算法成本建立简洁的模型，并使用实验数据验证这些模型&lt;/p>
&lt;h3 id="科学方法">
 科学方法
 &lt;a class="anchor" href="#%e7%a7%91%e5%ad%a6%e6%96%b9%e6%b3%95">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>观察、假设、预测、观察并核实预测、反复确认预测和观察&lt;/li>
&lt;li>原则：实验可重现&lt;/li>
&lt;/ul>
&lt;h3 id="观察">
 观察
 &lt;a class="anchor" href="#%e8%a7%82%e5%af%9f">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>计算性任务的困难程度可以用&lt;strong>问题的规模&lt;/strong>来衡量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>问题规模可以是输入的大小或某个命令行参数的值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>研究问题规模和运行时间的关系&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用计时器得到大概的运行时间
&lt;img src="img/ly-20241212142054451.png" alt="ly-20241212142054451" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>典型用例&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> N &lt;span style="color:#f92672">=&lt;/span> Integer.&lt;span style="color:#a6e22e">parseInt&lt;/span>(args&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>N&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> N; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> StdRandom.&lt;span style="color:#a6e22e">uniform&lt;/span>(&lt;span style="color:#f92672">-&lt;/span>1000000, 1000000);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Stopwatch timer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Stopwatch();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> ThreeSum.&lt;span style="color:#a6e22e">count&lt;/span>(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> time &lt;span style="color:#f92672">=&lt;/span> timer.&lt;span style="color:#a6e22e">elapsedTime&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StdOut.&lt;span style="color:#a6e22e">println&lt;/span>(cnt &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; triples &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> time &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; seconds&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用方法
&lt;img src="img/ly-20241212142054686.png" alt="ly-20241212142054686" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据类型的实现&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Stopwatch&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> start;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Stopwatch&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> start &lt;span style="color:#f92672">=&lt;/span> System.&lt;span style="color:#a6e22e">currentTimeMillis&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">elapsedTime&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> now &lt;span style="color:#f92672">=&lt;/span> System.&lt;span style="color:#a6e22e">currentTimeMillis&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (now &lt;span style="color:#f92672">-&lt;/span> start) &lt;span style="color:#f92672">/&lt;/span> 1000.&lt;span style="color:#a6e22e">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="数学模型">
 数学模型
 &lt;a class="anchor" href="#%e6%95%b0%e5%ad%a6%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>程序运行的总时间主要和两点有关：执行每条语句的耗时；执行每条语句的频率&lt;/p></description></item><item><title>算法红皮书1.3.3.1-1.3.4</title><link>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.3.3.1-1.3.4/</link><pubDate>Wed, 06 Apr 2022 23:00:44 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.3.3.1-1.3.4/</guid><description>&lt;h2 id="背包队列和栈">
 背包、队列和栈
 &lt;a class="anchor" href="#%e8%83%8c%e5%8c%85%e9%98%9f%e5%88%97%e5%92%8c%e6%a0%88">#&lt;/a>
&lt;/h2>
&lt;h3 id="链表">
 链表
 &lt;a class="anchor" href="#%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>链表是一种递归的数据结构，它或者为空(null)，或者是一个指向一个结点（node）的引用，该节点含有一个泛型的元素和一个指向另一条链表的引用。&lt;/li>
&lt;/ul>
&lt;h4 id="结点记录">
 结点记录
 &lt;a class="anchor" href="#%e7%bb%93%e7%82%b9%e8%ae%b0%e5%bd%95">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>使用嵌套类定义结点的抽象数据类型&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Node&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Item item;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Node next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>该类没有其它任何方法，且会在代码中直接引用实例变量，这种类型的变量称为记录&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="构造链表">
 构造链表
 &lt;a class="anchor" href="#%e6%9e%84%e9%80%a0%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>需要一个Node类型的变量，保证它的值是null或者指向另一个Node对象的next域指向了另一个链表&lt;/li>
&lt;li>如下图
&lt;img src="img/ly-20241212142053630.png" alt="ly-20241212142053630" />&lt;/li>
&lt;li>链表表示的是一列元素&lt;/li>
&lt;li>链式结构在本书中的可视化表示
长方形表示对象；实例变量的值写在长方形中；用指向被引用对象的箭头表示引用关系&lt;/li>
&lt;li>术语&lt;strong>链接&lt;/strong>表示对结点的引用&lt;/li>
&lt;/ul>
&lt;h4 id="在表头插入结点">
 在表头插入结点
 &lt;a class="anchor" href="#%e5%9c%a8%e8%a1%a8%e5%a4%b4%e6%8f%92%e5%85%a5%e7%bb%93%e7%82%b9">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>在首结点为first 的给定链表开头插入字符串not，我们先将first 保存在oldfirst 中，
然后将一个新结点赋予first，并将它的item 域设为not，next 域设为oldfirst&lt;/p>
&lt;/li>
&lt;li>
&lt;p>时间复杂度为O(1)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如图
&lt;img src="img/ly-20241212142053870.png" alt="ly-20241212142053870" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="从表头删除结点">
 从表头删除结点
 &lt;a class="anchor" href="#%e4%bb%8e%e8%a1%a8%e5%a4%b4%e5%88%a0%e9%99%a4%e7%bb%93%e7%82%b9">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>将first指向first.next&lt;/p>
&lt;/li>
&lt;li>
&lt;p>原先的结点称为孤儿，Java的内存管理系统最终将回收它所占用的内存&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如图
&lt;img src="img/ly-20241212142053982.png" alt="ly-20241212142053982" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="在表尾插入结点">
 在表尾插入结点
 &lt;a class="anchor" href="#%e5%9c%a8%e8%a1%a8%e5%b0%be%e6%8f%92%e5%85%a5%e7%bb%93%e7%82%b9">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>每个修改链表的操作都需要增加检查是否要修改该变量（以及做出相应修改）的代码&lt;/p>
&lt;/li>
&lt;li>
&lt;p>例如，当删除链表首结点时可能改变指向链表的尾结点的引用，因为链表中只有一个结点时它既是首结点又是尾结点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如图
&lt;img src="img/ly-20241212142054097.png" alt="ly-20241212142054097" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="其他位置的插入和删除操作">
 其他位置的插入和删除操作
 &lt;a class="anchor" href="#%e5%85%b6%e4%bb%96%e4%bd%8d%e7%bd%ae%e7%9a%84%e6%8f%92%e5%85%a5%e5%92%8c%e5%88%a0%e9%99%a4%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h4>
&lt;p>删除指定结点；在指定节点插入新结点&lt;/p>
&lt;ul>
&lt;li>需要将链表尾结点的前一个节点中的链接（它指向的是last）值改为null&lt;/li>
&lt;li>为了找到指向last的结点，需要遍历链表，时间复杂度为O(n)&lt;/li>
&lt;li>实现任意插入和删除操作的标准解决方案是&lt;strong>双向链表&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h4 id="遍历">
 遍历
 &lt;a class="anchor" href="#%e9%81%8d%e5%8e%86">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>将x初始化为链表首结点，然后通过x.item访问和x相关联的元素，并将x设为x.next来访问链表中的下一个结点，知道x=null(没有下一个结点了，到达链表结尾)&lt;/p></description></item><item><title>02双主双从集群搭建</title><link>https://lwmfjc.github.io/zh/docs/technology/RocketMQ/heima/02buildcluster/</link><pubDate>Wed, 06 Apr 2022 10:55:23 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/RocketMQ/heima/02buildcluster/</guid><description>&lt;blockquote>
&lt;p>学习来源 &lt;a href="https://www.bilibili.com/video/BV1L4411y7mn">https://www.bilibili.com/video/BV1L4411y7mn&lt;/a>（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="服务器信息修改">
 服务器信息修改
 &lt;a class="anchor" href="#%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%bf%a1%e6%81%af%e4%bf%ae%e6%94%b9">#&lt;/a>
&lt;/h1>
&lt;p>在.135和.138均进行下面的操作&lt;/p>
&lt;h2 id="解压">
 解压
 &lt;a class="anchor" href="#%e8%a7%a3%e5%8e%8b">#&lt;/a>
&lt;/h2>
&lt;p>rocketmq解压到/usr/local/rocketmq目录下&lt;/p>
&lt;h2 id="host添加">
 host添加
 &lt;a class="anchor" href="#host%e6%b7%bb%e5%8a%a0">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#添加host&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vim /etc/hosts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">##添加内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.1.135 rocketmq-nameserver1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.1.138 rocketmq-nameserver2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.1.135 rocketmq-master1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.1.135 rocketmq-slave2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.1.138 rocketmq-master2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>192.168.1.138 rocketmq-slave1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 保存后&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl restart network
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="防火墙">
 防火墙
 &lt;a class="anchor" href="#%e9%98%b2%e7%81%ab%e5%a2%99">#&lt;/a>
&lt;/h2>
&lt;h3 id="直接关闭">
 直接关闭
 &lt;a class="anchor" href="#%e7%9b%b4%e6%8e%a5%e5%85%b3%e9%97%ad">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 防火墙关闭&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl stop firewalld.service
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 防火墙状态查看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>firewall-cmd --state
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">##禁止开机启动&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>systemctl disable firewalld.service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="或者直接关闭对应端口即可">
 或者直接关闭对应端口即可
 &lt;a class="anchor" href="#%e6%88%96%e8%80%85%e7%9b%b4%e6%8e%a5%e5%85%b3%e9%97%ad%e5%af%b9%e5%ba%94%e7%ab%af%e5%8f%a3%e5%8d%b3%e5%8f%af">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="img/ly-20241212142200796.png" alt="ly-20241212142200796" />&lt;/p>
&lt;h2 id="环境变量配置">
 环境变量配置
 &lt;a class="anchor" href="#%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e9%85%8d%e7%bd%ae">#&lt;/a>
&lt;/h2>
&lt;p>为了执行rocketmq命令方便&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#添加环境变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vim /etc/profile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#添加&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ROCKETMQ_HOME&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/rocketmq-all-4.4.0-bin-release
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:$ROCKETMQ_HOME/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export ROCKETMQ_HOME PATH
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#使配置生效&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source /etc/profile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="消息存储路径创建">
 消息存储路径创建
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e5%ad%98%e5%82%a8%e8%b7%af%e5%be%84%e5%88%9b%e5%bb%ba">#&lt;/a>
&lt;/h2>
&lt;h3 id="a">
 a
 &lt;a class="anchor" href="#a">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>mkdir /usr/local/rocketmq/store-a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir /usr/local/rocketmq/store-a/commitlog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir /usr/local/rocketmq/store-a/consumequeue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir /usr/local/rocketmq/store-a/index
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="b">
 b
 &lt;a class="anchor" href="#b">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>mkdir /usr/local/rocketmq/store-b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir /usr/local/rocketmq/store-b/commitlog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir /usr/local/rocketmq/store-b/consumequeue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir /usr/local/rocketmq/store-b/index
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="双主双从配置文件的修改">
 双主双从配置文件的修改
 &lt;a class="anchor" href="#%e5%8f%8c%e4%b8%bb%e5%8f%8c%e4%bb%8e%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e7%9a%84%e4%bf%ae%e6%94%b9">#&lt;/a>
&lt;/h1>
&lt;h2 id="master-a">
 master-a
 &lt;a class="anchor" href="#master-a">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#所属集群名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerClusterName&lt;span style="color:#f92672">=&lt;/span>rocketmq-cluster
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#broker名字，注意此处不同的配置文件填写的不一样&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerName&lt;span style="color:#f92672">=&lt;/span>broker-a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#0 表示 Master，&amp;gt;0 表示 Slave&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerId&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#nameServer地址，分号分割&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>namesrvAddr&lt;span style="color:#f92672">=&lt;/span>rocketmq-nameserver1:9876;rocketmq-nameserver2:9876
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>defaultTopicQueueNums&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>autoCreateTopicEnable&lt;span style="color:#f92672">=&lt;/span>true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>autoCreateSubscriptionGroup&lt;span style="color:#f92672">=&lt;/span>true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Broker 对外服务的监听端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>listenPort&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10911&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#删除文件时间点，默认凌晨 4点&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deleteWhen&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">04&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#文件保留时间，默认 48 小时&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fileReservedTime&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">120&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#commitLog每个文件的大小默认1G&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mapedFileSizeCommitLog&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1073741824&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ConsumeQueue每个文件默认存30W条，根据业务情况调整&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mapedFileSizeConsumeQueue&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">300000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#destroyMapedFileIntervalForcibly=120000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#redeleteHangedFileInterval=120000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#检测物理文件磁盘空间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>diskMaxUsedSpaceRatio&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">88&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathRootDir&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#commitLog 存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathCommitLog&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-a/commitlog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#消费队列存储路径存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathConsumeQueue&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-a/consumequeue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#消息索引存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathIndex&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-a/index
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#checkpoint 文件存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storeCheckpoint&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-a/checkpoint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#abort 文件存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>abortFile&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-a/abort
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#限制的消息大小&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>maxMessageSize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">65536&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushCommitLogLeastPages=4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushConsumeQueueLeastPages=2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushCommitLogThoroughInterval=10000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushConsumeQueueThoroughInterval=60000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Broker 的角色&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- ASYNC_MASTER 异步复制Master&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- SYNC_MASTER 同步双写Master&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- SLAVE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerRole&lt;span style="color:#f92672">=&lt;/span>SYNC_MASTER
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#刷盘方式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- ASYNC_FLUSH 异步刷盘&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- SYNC_FLUSH 同步刷盘&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flushDiskType&lt;span style="color:#f92672">=&lt;/span>SYNC_FLUSH
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#checkTransactionMessageEnable=false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#发消息线程池数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sendMessageThreadPoolNums=128&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#拉消息线程池数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#pullMessageThreadPoolNums=128&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="slave-b">
 slave-b
 &lt;a class="anchor" href="#slave-b">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#所属集群名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerClusterName&lt;span style="color:#f92672">=&lt;/span>rocketmq-cluster
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#broker名字，注意此处不同的配置文件填写的不一样&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerName&lt;span style="color:#f92672">=&lt;/span>broker-b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#0 表示 Master，&amp;gt;0 表示 Slave&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerId&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#nameServer地址，分号分割&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>namesrvAddr&lt;span style="color:#f92672">=&lt;/span>rocketmq-nameserver1:9876;rocketmq-nameserver2:9876
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>defaultTopicQueueNums&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>autoCreateTopicEnable&lt;span style="color:#f92672">=&lt;/span>true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>autoCreateSubscriptionGroup&lt;span style="color:#f92672">=&lt;/span>true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Broker 对外服务的监听端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>listenPort&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">11011&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#删除文件时间点，默认凌晨 4点&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deleteWhen&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">04&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#文件保留时间，默认 48 小时&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fileReservedTime&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">120&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#commitLog每个文件的大小默认1G&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mapedFileSizeCommitLog&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1073741824&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ConsumeQueue每个文件默认存30W条，根据业务情况调整&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mapedFileSizeConsumeQueue&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">300000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#destroyMapedFileIntervalForcibly=120000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#redeleteHangedFileInterval=120000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#检测物理文件磁盘空间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>diskMaxUsedSpaceRatio&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">88&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathRootDir&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#commitLog 存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathCommitLog&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-b/commitlog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#消费队列存储路径存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathConsumeQueue&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-b/consumequeue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#消息索引存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathIndex&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-b/index
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#checkpoint 文件存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storeCheckpoint&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-b/checkpoint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#abort 文件存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>abortFile&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-b/abort
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#限制的消息大小&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>maxMessageSize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">65536&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushCommitLogLeastPages=4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushConsumeQueueLeastPages=2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushCommitLogThoroughInterval=10000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushConsumeQueueThoroughInterval=60000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Broker 的角色&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- ASYNC_MASTER 异步复制Master&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- SYNC_MASTER 同步双写Master&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- SLAVE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerRole&lt;span style="color:#f92672">=&lt;/span>SLAVE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#刷盘方式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- ASYNC_FLUSH 异步刷盘&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- SYNC_FLUSH 同步刷盘&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flushDiskType&lt;span style="color:#f92672">=&lt;/span>ASYNC_FLUSH
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#checkTransactionMessageEnable=false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#发消息线程池数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sendMessageThreadPoolNums=128&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#拉消息线程池数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#pullMessageThreadPoolNums=128&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="master-b">
 master-b
 &lt;a class="anchor" href="#master-b">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#所属集群名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerClusterName&lt;span style="color:#f92672">=&lt;/span>rocketmq-cluster
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#broker名字，注意此处不同的配置文件填写的不一样&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerName&lt;span style="color:#f92672">=&lt;/span>broker-b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#0 表示 Master，&amp;gt;0 表示 Slave&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerId&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#nameServer地址，分号分割&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>namesrvAddr&lt;span style="color:#f92672">=&lt;/span>rocketmq-nameserver1:9876;rocketmq-nameserver2:9876
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>defaultTopicQueueNums&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>autoCreateTopicEnable&lt;span style="color:#f92672">=&lt;/span>true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>autoCreateSubscriptionGroup&lt;span style="color:#f92672">=&lt;/span>true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Broker 对外服务的监听端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>listenPort&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10911&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#删除文件时间点，默认凌晨 4点&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deleteWhen&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">04&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#文件保留时间，默认 48 小时&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fileReservedTime&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">120&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#commitLog每个文件的大小默认1G&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mapedFileSizeCommitLog&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1073741824&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ConsumeQueue每个文件默认存30W条，根据业务情况调整&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mapedFileSizeConsumeQueue&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">300000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#destroyMapedFileIntervalForcibly=120000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#redeleteHangedFileInterval=120000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#检测物理文件磁盘空间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>diskMaxUsedSpaceRatio&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">88&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathRootDir&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#commitLog 存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathCommitLog&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-b/commitlog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#消费队列存储路径存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathConsumeQueue&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-b/consumequeue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#消息索引存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathIndex&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-b/index
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#checkpoint 文件存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storeCheckpoint&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-b/checkpoint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#abort 文件存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>abortFile&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-b/abort
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#限制的消息大小&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>maxMessageSize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">65536&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushCommitLogLeastPages=4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushConsumeQueueLeastPages=2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushCommitLogThoroughInterval=10000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushConsumeQueueThoroughInterval=60000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Broker 的角色&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- ASYNC_MASTER 异步复制Master&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- SYNC_MASTER 同步双写Master&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- SLAVE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerRole&lt;span style="color:#f92672">=&lt;/span>SYNC_MASTER
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#刷盘方式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- ASYNC_FLUSH 异步刷盘&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- SYNC_FLUSH 同步刷盘&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flushDiskType&lt;span style="color:#f92672">=&lt;/span>SYNC_FLUSH
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#checkTransactionMessageEnable=false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#发消息线程池数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sendMessageThreadPoolNums=128&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#拉消息线程池数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#pullMessageThreadPoolNums=128&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="slave-a">
 slave-a
 &lt;a class="anchor" href="#slave-a">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#所属集群名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerClusterName&lt;span style="color:#f92672">=&lt;/span>rocketmq-cluster
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#broker名字，注意此处不同的配置文件填写的不一样&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerName&lt;span style="color:#f92672">=&lt;/span>broker-a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#0 表示 Master，&amp;gt;0 表示 Slave&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerId&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#nameServer地址，分号分割&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>namesrvAddr&lt;span style="color:#f92672">=&lt;/span>rocketmq-nameserver1:9876;rocketmq-nameserver2:9876
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>defaultTopicQueueNums&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>autoCreateTopicEnable&lt;span style="color:#f92672">=&lt;/span>true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>autoCreateSubscriptionGroup&lt;span style="color:#f92672">=&lt;/span>true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Broker 对外服务的监听端口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>listenPort&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">11011&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#删除文件时间点，默认凌晨 4点&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deleteWhen&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">04&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#文件保留时间，默认 48 小时&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fileReservedTime&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">120&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#commitLog每个文件的大小默认1G&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mapedFileSizeCommitLog&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1073741824&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ConsumeQueue每个文件默认存30W条，根据业务情况调整&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mapedFileSizeConsumeQueue&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">300000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#destroyMapedFileIntervalForcibly=120000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#redeleteHangedFileInterval=120000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#检测物理文件磁盘空间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>diskMaxUsedSpaceRatio&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">88&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathRootDir&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#commitLog 存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathCommitLog&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-a/commitlog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#消费队列存储路径存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathConsumeQueue&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-a/consumequeue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#消息索引存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storePathIndex&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-a/index
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#checkpoint 文件存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>storeCheckpoint&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-a/checkpoint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#abort 文件存储路径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>abortFile&lt;span style="color:#f92672">=&lt;/span>/usr/local/rocketmq/store-a/abort
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#限制的消息大小&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>maxMessageSize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">65536&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushCommitLogLeastPages=4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushConsumeQueueLeastPages=2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushCommitLogThoroughInterval=10000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#flushConsumeQueueThoroughInterval=60000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#Broker 的角色&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- ASYNC_MASTER 异步复制Master&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- SYNC_MASTER 同步双写Master&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- SLAVE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brokerRole&lt;span style="color:#f92672">=&lt;/span>SLAVE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#刷盘方式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- ASYNC_FLUSH 异步刷盘&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#- SYNC_FLUSH 同步刷盘&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flushDiskType&lt;span style="color:#f92672">=&lt;/span>ASYNC_FLUSH
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#checkTransactionMessageEnable=false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#发消息线程池数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sendMessageThreadPoolNums=128&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#拉消息线程池数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#pullMessageThreadPoolNums=128&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="修改两台主机的runserversh及runbrokersh修改">
 修改两台主机的runserver.sh及runbroker.sh修改
 &lt;a class="anchor" href="#%e4%bf%ae%e6%94%b9%e4%b8%a4%e5%8f%b0%e4%b8%bb%e6%9c%ba%e7%9a%84runserversh%e5%8f%8arunbrokersh%e4%bf%ae%e6%94%b9">#&lt;/a>
&lt;/h1>
&lt;h2 id="修改runbrokersh">
 修改runbroker.sh
 &lt;a class="anchor" href="#%e4%bf%ae%e6%94%b9runbrokersh">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>JAVA_OPT&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>JAVA_OPT&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> -server -Xms256m -Xmx256m -Xmn128m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="修改runserversh">
 修改runserver.sh
 &lt;a class="anchor" href="#%e4%bf%ae%e6%94%b9runserversh">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>JAVA_OPT&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>JAVA_OPT&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="两台主机分别启动nameserver和brocker">
 两台主机分别启动nameserver和Brocker
 &lt;a class="anchor" href="#%e4%b8%a4%e5%8f%b0%e4%b8%bb%e6%9c%ba%e5%88%86%e5%88%ab%e5%90%af%e5%8a%a8nameserver%e5%92%8cbrocker">#&lt;/a>
&lt;/h1>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 在两台主机分别启动nameserver &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nohup sh mqnamesrv &amp;amp;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#135启动master1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nohup sh mqbroker -c /usr/local/rocketmq/rocketmq-all-4.4.0-bin-release/conf/2m-2s-sync/broker-a.properties &amp;amp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#135启动slave2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nohup sh mqbroker -c /usr/local/rocketmq/rocketmq-all-4.4.0-bin-release/conf/2m-2s-sync/broker-b-s.properties &amp;amp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#查看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3478&lt;/span> Jps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3366&lt;/span> BrokerStartup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3446&lt;/span> BrokerStartup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3334&lt;/span> NamesrvStartup
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#138启动master2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nohup sh mqbroker -c /usr/local/rocketmq/rocketmq-all-4.4.0-bin-release/conf/2m-2s-sync/broker-b.properties &amp;amp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#135启动slave1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nohup sh mqbroker -c /usr/local/rocketmq/rocketmq-all-4.4.0-bin-release/conf/2m-2s-sync/broker-a-s.properties &amp;amp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#查看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>jps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3376&lt;/span> Jps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3360&lt;/span> BrokerStartup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3251&lt;/span> NamesrvStartup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3295&lt;/span> BrokerStartup
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>双主双从集群搭建完毕！&lt;/strong>&lt;/p></description></item><item><title>01rocketmq学习</title><link>https://lwmfjc.github.io/zh/docs/technology/RocketMQ/heima/01base/</link><pubDate>Wed, 06 Apr 2022 00:11:58 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/RocketMQ/heima/01base/</guid><description>&lt;blockquote>
&lt;p>学习来源 &lt;a href="https://www.bilibili.com/video/BV1L4411y7mn">https://www.bilibili.com/video/BV1L4411y7mn&lt;/a>（添加小部分笔记）感谢作者!&lt;/p>
&lt;/blockquote>
&lt;h1 id="基本操作">
 基本操作
 &lt;a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h1>
&lt;h2 id="下载">
 下载
 &lt;a class="anchor" href="#%e4%b8%8b%e8%bd%bd">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://rocketmq.apache.org/download/">https://rocketmq.apache.org/download/&lt;/a> 选择Binary下载即可，放到Linux主机中&lt;/p>
&lt;h2 id="前提java运行环境">
 前提java运行环境
 &lt;a class="anchor" href="#%e5%89%8d%e6%8f%90java%e8%bf%90%e8%a1%8c%e7%8e%af%e5%a2%83">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>yum search java | grep jdk
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install -y java-1.8.0-openjdk-devel.x86_64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># java -version 正常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># javac -version 正常&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="启动">
 启动
 &lt;a class="anchor" href="#%e5%90%af%e5%8a%a8">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#nameserver启动&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nohup sh bin/mqnamesrv &amp;amp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#nameserver日志查看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tail -f ~/logs/rocketmqlogs/namesrv.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2023-04-06 00:08:34 INFO main - tls.client.certPath &lt;span style="color:#f92672">=&lt;/span> null
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2023-04-06 00:08:34 INFO main - tls.client.authServer &lt;span style="color:#f92672">=&lt;/span> false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2023-04-06 00:08:34 INFO main - tls.client.trustCertPath &lt;span style="color:#f92672">=&lt;/span> null
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2023-04-06 00:08:35 INFO main - Using OpenSSL provider
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2023-04-06 00:08:35 INFO main - SSLContext created &lt;span style="color:#66d9ef">for&lt;/span> server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2023-04-06 00:08:36 INFO NettyEventExecutor - NettyEventExecutor service started
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2023-04-06 00:08:36 INFO main - The Name Server boot success. serializeType&lt;span style="color:#f92672">=&lt;/span>JSON
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2023-04-06 00:08:36 INFO FileWatchService - FileWatchService service started
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2023-04-06 00:09:35 INFO NSScheduledThread1 - --------------------------------------------------------
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2023-04-06 00:09:35 INFO NSScheduledThread1 - configTable SIZE: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#broker启动&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nohup sh bin/mqbroker -n localhost:9876 &amp;amp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#查看broker日志&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tail -f ~/logs/rocketmqlogs/broker.log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#日志如下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tail: 无法打开&lt;span style="color:#e6db74">&amp;#34;/root/logs/rocketmqlogs/broker.log&amp;#34;&lt;/span> 读取数据: 没有那个文件或目录
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tail: 没有剩余文件
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>👇
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#jps查看&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2465&lt;/span> Jps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2430&lt;/span> NamesrvStartup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#说明没有启动成功,因为默认配置的虚拟机内存较大&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vim bin/runbroker.sh 以及 vim runserver.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#修改 &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>JAVA_OPT&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>JAVA_OPT&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> -server -Xms8g -Xmx8g -Xmn4g&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#修改为&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>JAVA_OPT&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>JAVA_OPT&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#修改完毕后启动&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#先关闭namesrv后&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#按上述启动namesrv以及broker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sh bin/mqshutdown namesrv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># jsp命令查看进程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2612&lt;/span> Jps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2551&lt;/span> BrokerStartup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2524&lt;/span> NamesrvStartup
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="测试">
 测试
 &lt;a class="anchor" href="#%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h2>
&lt;p>同一台机器上，两个cmd窗口&lt;/p></description></item><item><title>算法红皮书 1.3.1.1-1.3.2.5</title><link>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.3.1.1-1.3.2.5/</link><pubDate>Tue, 22 Mar 2022 13:51:26 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.3.1.1-1.3.2.5/</guid><description>&lt;h2 id="背包队列和栈">
 背包、队列和栈
 &lt;a class="anchor" href="#%e8%83%8c%e5%8c%85%e9%98%9f%e5%88%97%e5%92%8c%e6%a0%88">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>数据类型的值就是一组对象的集合，所有操作都是关于添加、删除或是访问集合中的对象&lt;/li>
&lt;li>本章将学习三种数据类型：背包Bag、队列Queue、栈Stack
&lt;ul>
&lt;li>对集合中的对象的表示方式直接影响各种操作的效率&lt;/li>
&lt;li>介绍泛型和迭代&lt;/li>
&lt;li>介绍并说明链式数据结构的重要性(链表)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="api">
 API
 &lt;a class="anchor" href="#api">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>泛型可迭代的基础集合数据类型的API&lt;/p>
&lt;ul>
&lt;li>背包&lt;br>
&lt;img src="img/ly-20241212142051025.png" alt="ly-20241212142051025" />&lt;/li>
&lt;li>队列(先进先出FIFO)&lt;br>
&lt;img src="img/ly-20241212142051259.png" alt="ly-20241212142051259" />&lt;/li>
&lt;li>下压(后进先出,LIFO)栈
&lt;img src="img/ly-20241212142051367.png" alt="ly-20241212142051367" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>泛型&lt;/p>
&lt;ul>
&lt;li>泛型，参数化类型&lt;/li>
&lt;li>在每份API 中，类名后的&lt;code>&amp;lt;Item&amp;gt; &lt;/code>记号将Item 定义为一个类型参数，它是一个象征性的占位符，表示的是用例将会使用的某种具体数据类型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>自动装箱&lt;/p>
&lt;ul>
&lt;li>用来处理原始类型&lt;/li>
&lt;li>Boolean、Byte、Character、Double、Float、Integer、Long 和Short 分别对应着boolean、byte、char、double、float、int、long 和short&lt;/li>
&lt;li>自动将一个原始数据类型转换为一个封装类型称为自动装箱，自动将一个封装类型转换为一个原始数据类型被称为自动拆箱&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>可迭代的集合类型&lt;/p>
&lt;ul>
&lt;li>迭代访问集合中的所有元素&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>背包是一种不支持从中删除元素的集合数据类型&amp;ndash;帮助用例收集元素并迭代遍历所有收集到的元素（&lt;strong>无序遍历&lt;/strong>）&lt;/p>
&lt;ul>
&lt;li>典型用例，计算标准差&lt;br>
&lt;img src="./1.3.1.1-1.3.2.5/1648014765406.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>先进先出队列&lt;/p>
&lt;ul>
&lt;li>是一种基于先进先出(FIFO)策略的集合类型&lt;/li>
&lt;li>使用队列的主要原因：集合保存元素的同时保存它们的相对顺序&lt;/li>
&lt;li>如图&lt;br>
&lt;img src="img/ly-20241212142051478.png" alt="ly-20241212142051478" />&lt;/li>
&lt;li>Queue用例(先进先出) &lt;br>
&lt;img src="img/ly-20241212142051591.png" alt="ly-20241212142051591" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>下压栈&lt;/p>
&lt;ul>
&lt;li>简称栈，是一种基于后进先出LIFO策略的集合类型&lt;/li>
&lt;li>比如，收邮件等，如图&lt;br>
&lt;img src="img/ly-20241212142051703.png" alt="ly-20241212142051703" />&lt;/li>
&lt;li>Stack的用例&lt;br>
&lt;img src="img/ly-20241212142051815.png" alt="ly-20241212142051815" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>用栈解决算数表达式的问题&lt;br>
（双栈算数表达式求值算法）&lt;br>
&lt;img src="img/ly-20241212142051919.png" alt="ly-20241212142051919" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="集合类数据类型的实现">
 集合类数据类型的实现
 &lt;a class="anchor" href="#%e9%9b%86%e5%90%88%e7%b1%bb%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%ae%9e%e7%8e%b0">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>定容栈，表示容量固定的字符串栈的抽象数据类型&lt;/p>
&lt;ul>
&lt;li>
&lt;p>只能处理String值，支持push和pop&lt;/p>
&lt;/li>
&lt;li>
&lt;p>抽象数据类型&lt;br>
&lt;img src="img/ly-20241212142052029.png" alt="ly-20241212142052029" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>测试用例&lt;/p>
&lt;p>&lt;img src="img/ly-20241212142052135.png" alt="ly-20241212142052135" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用方法&lt;br>
&lt;img src="img/ly-20241212142052243.png" alt="ly-20241212142052243" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据类型的实现&lt;br>
&lt;img src="img/ly-20241212142052353.png" alt="ly-20241212142052353" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>泛型&lt;/p>
&lt;ul>
&lt;li>&lt;code>public class FixedCapacityStack&amp;lt;Item&amp;gt;&lt;/code>&lt;/li>
&lt;li>由于不允许直接创建泛型数组，所以 &lt;del>a =new Item[cap]&lt;/del> 不允许，应该改为&lt;br>
a=(Item[])new Object[cap];&lt;/li>
&lt;li>泛型定容栈的抽象数据类型&lt;br>
&lt;img src="img/ly-20241212142052474.png" alt="ly-20241212142052474" />&lt;/li>
&lt;li>测试用例&lt;br>
&lt;img src="img/ly-20241212142052593.png" alt="ly-20241212142052593" />&lt;/li>
&lt;li>使用方法&lt;br>
&lt;img src="img/ly-20241212142052746.png" alt="ly-20241212142052746" />&lt;/li>
&lt;li>数据类型的实现&lt;br>
&lt;img src="img/ly-20241212142052865.png" alt="ly-20241212142052865" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>调整数组大小&lt;/p></description></item><item><title>算法红皮书 1.2.1-1.2.5</title><link>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.2.1-1.2.5/</link><pubDate>Tue, 22 Feb 2022 13:49:50 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.2.1-1.2.5/</guid><description>&lt;h2 id="数据抽象">
 数据抽象
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e6%8a%bd%e8%b1%a1">#&lt;/a>
&lt;/h2>
&lt;p>&lt;em>&lt;strong>数据类型&lt;/strong>&lt;/em>指的是一组值和一组对这些值的操作的集合&lt;/p>
&lt;ul>
&lt;li>定义和使用数据类型的过程，也被称为数据抽象&lt;/li>
&lt;li>Java编程的基础是使用class关键字构造被称为&lt;em>&lt;strong>引用类型&lt;/strong>&lt;/em>的数据类型，也称面向对象编程&lt;/li>
&lt;li>定义自己的数据类型来抽象任意对象&lt;/li>
&lt;li>抽象数据类型（ADT）是一种能够对使用者隐藏数据表示的数据类型&lt;/li>
&lt;li>抽象数据类型将数据和函数的实现相关联，将数据的表示方式隐藏起来&lt;/li>
&lt;li>抽象数据类型使用时，关注API描述的操作上而不会去关心数据的表示；实现抽象数据类型时，关注数据本身并将实现对数据的各种操作&lt;/li>
&lt;li>研究同一个问题的不同算法的主要原因是他们的性能不同&lt;/li>
&lt;/ul>
&lt;h3 id="使用抽象数据类型">
 使用抽象数据类型
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8%e6%8a%bd%e8%b1%a1%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>使用一种数据类型并不一定非得知道它是如何实现的&lt;/li>
&lt;li>使用Counter(计数器)的简单数据类型的程序，操作有
&lt;ul>
&lt;li>创建对象并初始化为0&lt;/li>
&lt;li>当前值加1&lt;/li>
&lt;li>获取当前值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>场景，用于电子计票&lt;/li>
&lt;li>抽象数据类型的API(应用程序编程接口)
&lt;ul>
&lt;li>API用来说明抽象数据类型的行为&lt;/li>
&lt;li>将列出所有构造函数和实例方法(即操作)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>计算器的API&lt;br>
&lt;img src="img/ly-20241212142048962.png" alt="" />&lt;/li>
&lt;li>继承的方法
&lt;ul>
&lt;li>所有数据类型都会继承toString()方法&lt;/li>
&lt;li>Java会在用+运算符将任意数据类型的值和String值连接时调用toString()&lt;/li>
&lt;li>默认实现：返回该数据类型值的内存地址&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>用例代码
&lt;ul>
&lt;li>可以在用例代码中，声明变量、创建对象来保存数据类型的值并允许通过实例方法来操作它们&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对象
&lt;ul>
&lt;li>对象是能够承载数据类型的值的实体&lt;/li>
&lt;li>对象三大特性：状态、标识和行为
&lt;ul>
&lt;li>状态：数据类型中的值&lt;/li>
&lt;li>标识：在内存中的地址&lt;/li>
&lt;li>行为：数据类型的操作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Java使用&amp;quot;引用类型&amp;quot;和原始数据类型区别&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>创建对象
&lt;ul>
&lt;li>每种数据类型中的值都存储于一个对象中&lt;/li>
&lt;li>构造函数总是返回他的数据类型的对象的引用&lt;/li>
&lt;li>使用new()，会为新的对象分配内存空间，调用构造函数初始化对象中的值，返回该对象的一个引用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>抽象数据类型向用例隐藏了值的表示细节&lt;/li>
&lt;li>实例方法：参数按值传递&lt;/li>
&lt;li>方法每次触发都和一个对象相关&lt;/li>
&lt;li>静态方法的主要作用是实现函数；非静态(实例)方法的主要作用是实现数据类型的操作&lt;/li>
&lt;li>使用对象&lt;br>
开发某种数据类型的用例
&lt;ul>
&lt;li>声明该类型的变量，以引用对象&lt;/li>
&lt;li>使用new触发能够创建该类型的对象的一个构造函数&lt;/li>
&lt;li>使用变量名调用实例方法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>赋值语句(对象赋值)
&lt;ul>
&lt;li>别名：两个变量同时指向同一个对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将对象作为参数
&lt;ul>
&lt;li>Java将参数值的一个副本从调用端传递给了方法，这种方式称为按值传递&lt;/li>
&lt;li>当使用引用类型作为参数时我们创建的都是别名，这种约定会传递引用的值(复制引用)，也就是传递对象的引用&lt;/li>
&lt;li>虽然无法改变原始的引用(将原变量指向另一个Counter对象)，但能够改变该对象的值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将对象作为返回值
&lt;ul>
&lt;li>由于Java只由一个返回值，有了对象实际上就能返回多个值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>数组也是对象
&lt;ul>
&lt;li>将数组传递给一个方法或是将一个数组变量放在赋值语句的右侧时，我们都是在创建数组引用的一个副本，而非数组的副本&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对象的数组&lt;br>
创建一个对象的数组
&lt;ul>
&lt;li>使用方括号语法调用数组的构造函数创建数组&lt;/li>
&lt;li>对于每个数组元素调用它的构造函数创建相应的对象&lt;br>
如下图&lt;br>
&lt;img src="img/ly-20241212142049192.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>运用数据抽象的思想编写代码(定义和使用数据类型，将数据类型的值封装在对象中)的方式称为面向对象编程&lt;/li>
&lt;li>总结
&lt;ul>
&lt;li>数据类型指的是一组值和一组对值的操作的集合&lt;/li>
&lt;li>我们会在数据类型的Java类中编写用理&lt;/li>
&lt;li>对象是能够存储任意该数据类型的值的实体&lt;/li>
&lt;li>对象有三个关键性质：状态、标识和行为&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="抽象数据类型举例">
 抽象数据类型举例
 &lt;a class="anchor" href="#%e6%8a%bd%e8%b1%a1%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e4%b8%be%e4%be%8b">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>本书中将会用到或开发的所有数据类型
&lt;ul>
&lt;li>java.lang.*&lt;/li>
&lt;li>Java标准库中的抽象数据类型，需要import，比如java.io、java.net等&lt;/li>
&lt;li>I/O处理嘞抽象数据类型,StdIn和StdOut&lt;/li>
&lt;li>面向数据类抽象数据类型，计算机和和信息处理&lt;/li>
&lt;li>集合类抽象数据类型，主要是为了简化对同一类型的一组数据的操作，包括Bag、Stack和Queue，PQ(优先队列)、ST(符号表)、SET(集合)&lt;/li>
&lt;li>面向操作的抽象数据类型(用来分析各种算法)&lt;/li>
&lt;li>图算法相关的抽象数据类型，用来封装各种图的表示的面向数据的抽象数据类型，和一些提供图的处理算法的面向操作的抽象数据类型&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>几何对象(画图(图形)的)[跳过]&lt;/li>
&lt;li>信息处理
&lt;ul>
&lt;li>抽象数据类型是组织信息的一种自然方式&lt;/li>
&lt;li>定义和真实世界中的物体相对应的对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>字符串
&lt;ul>
&lt;li>java的String&lt;/li>
&lt;li>一个String值是一串可以由索引访问的char值&lt;/li>
&lt;li>有了String类型可以写出清晰干净的用例代码而无需关心字符串的表示方式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="抽象数据类型的实现">
 抽象数据类型的实现
 &lt;a class="anchor" href="#%e6%8a%bd%e8%b1%a1%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%ae%9e%e7%8e%b0">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>使用Java的类(class)实现抽象数据类型并将所有代码放入一个和类名相同并带有.java扩展名的文件&lt;/li>
&lt;li>如下图&lt;br>
&lt;img src="img/ly-20241212142049302.png" alt="" />&lt;/li>
&lt;li>实例变量&lt;br>
用来定义数据类型的值(每个对象的状态)&lt;/li>
&lt;li>构造函数
&lt;ul>
&lt;li>每个Java类都至少有一个构造函数以创建一个对象的标识&lt;/li>
&lt;li>每个构造函数将创建一个对象并向调用者返回一个该对象的引用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>实例方法
&lt;ul>
&lt;li>如图&lt;br>
&lt;img src="img/ly-20241212142049410.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>作用域
&lt;ul>
&lt;li>参数变量、局部变量、实例变量&lt;/li>
&lt;li>范围(如图)&lt;br>
&lt;img src="img/ly-20241212142049527.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>API、用例与实现
&lt;ul>
&lt;li>我们要学习的每个抽象数据类型的实现，都会是一个含有若干私有实例变量、构造函数、实例方法和一个测试用例的Java类&lt;/li>
&lt;li>用例和实现分离(一般将用例独立成含有静态方法main()的类)&lt;/li>
&lt;li>做法如下
&lt;ul>
&lt;li>定义一份API，APi的作用是将使用和实现分离，以实现模块化编程&lt;/li>
&lt;li>用一个Java类&lt;strong>实现&lt;/strong>API的定义&lt;/li>
&lt;li>实现多个测试用例来验证前两步做出的设计决定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>例子如下
&lt;ul>
&lt;li>API&lt;br>
&lt;img src="img/ly-20241212142049645.png" alt="" />&lt;/li>
&lt;li>典型用例&lt;br>
&lt;img src="img/ly-20241212142049754.png" alt="" />&lt;/li>
&lt;li>数据类型的实现&lt;br>
&lt;img src="img/ly-20241212142049860.png" alt="" />&lt;/li>
&lt;li>使用方法(执行程序)&lt;br>
&lt;img src="img/ly-20241212142049969.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="更多抽象数据类型的实现">
 更多抽象数据类型的实现
 &lt;a class="anchor" href="#%e6%9b%b4%e5%a4%9a%e6%8a%bd%e8%b1%a1%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%ae%9e%e7%8e%b0">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>日期
&lt;ul>
&lt;li>两种实现方式&lt;br>
&lt;img src="img/ly-20241212142050078.png" alt="" />&lt;/li>
&lt;li>本书反复出现的主题，即理解各种实现对空间和时间的需求&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>维护多个实现
&lt;ul>
&lt;li>比较同一份API的两种实现在同一个用例中的性能表现，需要下面非正式的命名约定
&lt;ul>
&lt;li>使用前缀的描述性修饰符，比如BasicDate和SmallDate,以及是否合法的SmartDate&lt;/li>
&lt;li>适合大多数用力的需求的实现，比如Date&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>累加器&lt;/li>
&lt;/ul>
&lt;h3 id="数据类型的设计">
 数据类型的设计
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e8%ae%be%e8%ae%a1">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>抽象数据类型是一种向用例隐藏内部表示的数据类型
&lt;ul>
&lt;li>封装(数据封装)&lt;/li>
&lt;li>设计APi&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>算法与抽象数据类型
&lt;ul>
&lt;li>能够准确地说明一个算法的目的及其他程序应该如何使用该算法&lt;/li>
&lt;li>每个Java程序都是一组静态方法和(或)一种数据类型的实现的集合&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>本书中关注的是抽象数据类型的实现中的操作和向用例隐藏其中的数据表示&lt;/li>
&lt;li>例子，将二分法封装
&lt;ul>
&lt;li>API&lt;br>
&lt;img src="img/ly-20241212142050191.png" alt="" />&lt;/li>
&lt;li>典型的用例&lt;br>
&lt;img src="img/ly-20241212142050300.png" alt="" />&lt;/li>
&lt;li>数据类型的实现&lt;br>
&lt;img src="img/ly-20241212142050413.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>接口继承
&lt;ul>
&lt;li>Java语言为定义对象之间的关系提供了支持，称为接口&lt;/li>
&lt;li>接口继承使得我们的程序能够通过调用接口中的方法操作实现该接口的任意类型的对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>本书中使用到的接口&lt;br>
&lt;img src="img/ly-20241212142050528.png" alt="" />&lt;/li>
&lt;li>继承
&lt;ul>
&lt;li>由Object类继承得到的方法&lt;br>
&lt;img src="img/ly-20241212142050645.png" alt="" />&lt;/li>
&lt;li>继承toString()并自定义&lt;/li>
&lt;li>封装类型(内置的引用类型，包括Boolean、Byte、Character、Double、Float、Integer、Long和Short)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>等价性
&lt;ul>
&lt;li>如图&lt;br>
&lt;img src="img/ly-20241212142050756.png" alt="" />&lt;/li>
&lt;li>例子，在Date中重写equals&lt;br>
&lt;img src="img/ly-20241212142050900.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>内存管理&lt;br>
Java具有自动内存管理，通过记录孤儿对象并将它们的内存释放到内存池中&lt;/li>
&lt;li>不可变性&lt;br>
使用final保证数据不可变&lt;br>
使用final修饰的引用类型，不能再引用(指向)其他对象，但对象本身的值可改变&lt;/li>
&lt;li>契约式设计
&lt;ul>
&lt;li>Java语言能够在程序运行时检测程序状态&lt;/li>
&lt;li>异常(Exception)+断言(Assertion)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>异常与错误&lt;br>
允许抛出异常或抛出错误&lt;/li>
&lt;li>断言&lt;br>
程序不应该依赖断言&lt;/li>
&lt;/ul>
&lt;h3 id="end">
 End
 &lt;a class="anchor" href="#end">#&lt;/a>
&lt;/h3></description></item><item><title>算法红皮书 1.1.6-1.1.11</title><link>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.1.6-1.1.11/</link><pubDate>Tue, 22 Feb 2022 09:55:11 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.1.6-1.1.11/</guid><description>&lt;h2 id="基础编程模型">
 基础编程模型
 &lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="静态方法">
 静态方法
 &lt;a class="anchor" href="#%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>本书中所有的Java程序要么是数据类型的定义，要么是一个静态方法库&lt;/li>
&lt;li>当讨论静态方法和实体方法共有的属性时，我们会使用不加定语的方法一词&lt;/li>
&lt;li>方法需要参数(某种数据类型的值)并根据参数计算出某种数据类型的返回值(例如数学函数的结果)或者产生某种副作用(例如打印一个值)&lt;/li>
&lt;li>静态方法由签名(public static 以及函数的返回值,方法名及一串参数)和函数体组成&lt;/li>
&lt;li>调用静态方法(写出方法名并在后面的括号中列出数值)&lt;/li>
&lt;li>方法的性质
&lt;ul>
&lt;li>方法的参数按值传递，方法中使用的参数变量能够引用调用者的参数并改变其内容(只是不能改变&lt;em>&lt;strong>原数组变量&lt;/strong>&lt;/em>本身)&lt;/li>
&lt;li>方法名可以被重载&lt;/li>
&lt;li>方法只能返回一个值，但能包含多个返回语句&lt;/li>
&lt;li>方法可以产生副作用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>递归：方法可以调用自己
可以使用数学归纳法证明所解释算法的正确性,编写递归重要的三点
&lt;ul>
&lt;li>递归总有一个最简单的情况(方法第一条总包含return的条件语句)&lt;/li>
&lt;li>递归调用总是去尝试解决一个规模更小的子问题&lt;/li>
&lt;li>递归调用的父问题和尝试解决的子问题之间不应该由交集
如下图中，两个子问题各自操作的数组部分是不同的&lt;br>
&lt;img src="img/ly-20241212142047263.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基础编程模型
&lt;ul>
&lt;li>静态方法库是定义在一个Java类中的一组静态方法&lt;/li>
&lt;li>Java开发的基本模式是编写一个静态方法库(包含一个main()方法)类完成一个任务&lt;/li>
&lt;li>在本书中，当我们提到用于执行一项人物的Java程序时，我们指的就是用这种模式开发的代码(还包括对数据类型的定义)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>模块化编程
&lt;ul>
&lt;li>通过静态方法库实现了模块化编程&lt;/li>
&lt;li>一个库中的静态方法也能够调用另一个库中定义的静态方法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>单元测试
&lt;ul>
&lt;li>Java编程最佳实践之一就是每个静态方法库中都包含一个main()函数来测试库中所有的方法&lt;/li>
&lt;li>本书中使用main()来说明模块的功能并将测试用例留作练习&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>外部库
&lt;ul>
&lt;li>系统标准库 java.lang.*:包括Math库;String和StringBuilder库&lt;/li>
&lt;li>导入的系统库 java.util.Arrays&lt;/li>
&lt;li>本书中其他库&lt;/li>
&lt;li>本书使用了作者开发的标准库Std*&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="api">
 API
 &lt;a class="anchor" href="#api">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>模块化编程重要组成部分，记录库方法的用法并供其他人参考的文档&lt;/li>
&lt;li>会统一使用应用程序编程接口API的方法列出每个库方法、签名及简述&lt;/li>
&lt;li>用例(调用另一个库中的方法的程序)，实现(实现了某个API方法的Java代码)&lt;/li>
&lt;li>作者自己的两个库，一个扩展Math.random(),一个支持各种统计
&lt;ul>
&lt;li>随机静态方法库(StdRandom)的API&lt;br>
&lt;img src="img/ly-20241212142047502.png" alt="" />&lt;/li>
&lt;li>数据分析方法库(StdStats)的API&lt;br>
&lt;img src="img/ly-20241212142047617.png" alt="" />&lt;/li>
&lt;li>StdRandom库中的静态方法的实现
&lt;img src="img/ly-20241212142047730.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>编写自己的库
&lt;ul>
&lt;li>编写用例，实现中将计算过程分解&lt;/li>
&lt;li>明确静态方法库和与之对应的API&lt;/li>
&lt;li>实现API和一个能够对方法进行独立测试的main()函数&lt;/li>
&lt;li>API的目的是将调用和实现分离&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="字符串">
 字符串
 &lt;a class="anchor" href="#%e5%ad%97%e7%ac%a6%e4%b8%b2">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>字符串拼接，使用 +&lt;/li>
&lt;li>类型转换(将用户从键盘输入的内容转换成相应数据类型的值以及将各种数据类型的值转换成能够在屏幕上显示的值)&lt;br>
&lt;img src="img/ly-20241212142047840.png" alt="" />&lt;/li>
&lt;li>如果数字跟在+后面，那么会将数据类型的值自动转换为字符串&lt;/li>
&lt;li>命令行参数
&lt;ul>
&lt;li>Java中字符串的存在，使程序能够接收到从命令行传递来的信息&lt;/li>
&lt;li>当输入命令java和一个库名及一系列字符串后，Java系统会调用库的main()方法并将后面的一系列字符串变成一个数组作为参数传递给它&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="输入输出">
 输入输出
 &lt;a class="anchor" href="#%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>Java程序可以从&lt;em>&lt;strong>命令行参数&lt;/strong>&lt;/em>或者一个名为&lt;em>&lt;strong>标准输入流&lt;/strong>&lt;/em>的抽象字符流中获得输入，并将输出写入另一个名为标准输出流的字符流中&lt;/li>
&lt;li>默认情况下，命令行参数、标准输入和标准输出是和应用程序绑定的，而应用程序是由能够接受命令输入的操作系统或是开发环境所支持&lt;/li>
&lt;li>使用终端来指代这个应用程序提供的供输入和显示的窗口,如图&lt;br>
&lt;img src="img/ly-20241212142047952.png" alt="" />&lt;/li>
&lt;li>命令和参数
&lt;ul>
&lt;li>终端窗口包含一个提示符，通过它我们能够向操作系统输入命令和参数&lt;/li>
&lt;li>操作系统常用命令&lt;br>
&lt;img src="img/ly-20241212142048067.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>标准输出
&lt;ul>
&lt;li>StdOut库的作用是支持标准输出&lt;/li>
&lt;li>标准输出库的静态方法的API&lt;br>
&lt;img src="img/ly-20241212142048178.png" alt="" />&lt;/li>
&lt;li>格式化输出 字符%并紧跟一个字符表示的转换代码(包括d,f和s)。%和转换代码之间可以插入证书表示值的宽度，且转换后会在字符串左边添加空格以达到需要的宽度。负数表示空格从右边加&lt;/li>
&lt;li>宽度后用小数点及数值可以指定精度(或String字符串所截取的长度)&lt;/li>
&lt;li>格式中转换代码和对应参数的数据类型必须匹配
&lt;img src="img/ly-20241212142048287.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>标准输入
&lt;ul>
&lt;li>StdIn库从标准输入流中获取数据，然后将标准输出定向到终端窗口&lt;/li>
&lt;li>标准输入流最重要的特点，这些值会在程序读取后消失&lt;/li>
&lt;li>例子&lt;br>
&lt;img src="img/ly-20241212142048398.png" alt="" />&lt;/li>
&lt;li>标准输入库中的静态方法API&lt;br>
&lt;img src="img/ly-20241212142048512.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>重定向和管道
&lt;ul>
&lt;li>将标准输出重定向到一个文件
&lt;pre tabindex="0">&lt;code>java RandomSeq 1000 100.0 200.0 &amp;gt; data.txt
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>从文件而不是终端应用程序中读取数据
&lt;pre tabindex="0">&lt;code>java Average &amp;lt; data.txt
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>将一个程序的输出重定向为另一个程序的输入，叫做管道
&lt;pre tabindex="0">&lt;code>java RandomSeq 1000 100.0 200.0 | java Average
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>突破了我们能够处理的输入输出流的长度限制&lt;/li>
&lt;li>即使计算机没有足够的空间来存储十亿个数，&lt;/li>
&lt;li>我们仍然可以将例子中的1000 换成1 000 000 000 （当然我们还是需要一些时间来处理它们）。当RandomSeq 调用StdOut.println() 时，它就向输出流的末尾添加了一个字符串；当Average 调用StdIn.readInt() 时，它就从输入流的开头删除了一个字符串。这些动作发生的实际顺序取决于操作系统&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>命令行的重定向及管道&lt;br>
&lt;img src="img/ly-20241212142048626.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基于文件的输入输出&lt;/li>
&lt;li>In和Out库提供了一些静态方法,来实现向文件中写入或从文件中读取一个原始数据类型的数组的抽象&lt;/li>
&lt;li>用于读取和写入数组的静态方法的API&lt;br>
&lt;img src="img/ly-20241212142048736.png" alt="" />&lt;/li>
&lt;li>标准绘图库(基本方法和控制方法)&amp;ndash;这里跳过&lt;/li>
&lt;/ul>
&lt;h3 id="二分查找">
 二分查找
 &lt;a class="anchor" href="#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>如图，在终端接收需要判断的数字，如果不存在于白名单(文件中的int数组)中则输出&lt;/li>
&lt;li>开发用例以及使用测试文件(数组长度很大的白名单)&lt;/li>
&lt;li>模拟实际情况来展示当前算法的必要性，比如
&lt;ul>
&lt;li>将客户的账号保存在一个文件中，我们称它为白名单；&lt;/li>
&lt;li>从标准输入中得到每笔交易的账号；&lt;/li>
&lt;li>使用这个测试用例在标准输出中打印所有与任何客户无关的账号，公司很可能拒绝此类交易。
&lt;img src="img/ly-20241212142048842.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用顺序查找
&lt;pre tabindex="0">&lt;code>public static int rank(int key, int[] a)
{
 for (int i = 0; i &amp;lt; a.length; i++)
 if (a[i] == key) return i;
 return -1;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>当处理大量输入的时候，顺序查找的效率极其低&lt;/li>
&lt;/ul>
&lt;h3 id="展望">
 展望
 &lt;a class="anchor" href="#%e5%b1%95%e6%9c%9b">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>下一节，鼓励使用数据抽象，或称面向对象编程，而不是操作预定义的数据类型的静态方法&lt;/li>
&lt;li>使用数据抽象的好处
&lt;ul>
&lt;li>复用性&lt;/li>
&lt;li>链式数据结构比数组更灵活&lt;/li>
&lt;li>可以准确地定义锁面对的算法问题&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="11-end">
 1.1 End
 &lt;a class="anchor" href="#11-end">#&lt;/a>
&lt;/h3></description></item><item><title>电脑基础操作</title><link>https://lwmfjc.github.io/zh/docs/technology/Other/pc_base/</link><pubDate>Mon, 21 Feb 2022 16:53:04 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Other/pc_base/</guid><description>&lt;p>&lt;img src="img/ly-20241212141829107.png" alt="ly-20241212141829107" />&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141829358.png" alt="ly-20241212141829358" />&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141829580.png" alt="ly-20241212141829580" />&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141829793.png" alt="ly-20241212141829793" />&lt;/p></description></item><item><title>算法红皮书 1.1.1-1.1.5</title><link>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.1.1-1.1.5/</link><pubDate>Mon, 21 Feb 2022 16:53:04 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Algorithm/algorithhms_4th/1.1.1-1.1.5/</guid><description>&lt;h2 id="基础编程模型">
 基础编程模型
 &lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="java程序的基本结构">
 Java程序的基本结构
 &lt;a class="anchor" href="#java%e7%a8%8b%e5%ba%8f%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>本书学习算法的方法：用Java编程语言编写的程序来实现算法(相比用自然语言有很多优势)&lt;/li>
&lt;li>劣势：编程语言特定，使算法的思想和实现细节变得困难(所以本书尽量使用大部分语言都必须的语法)&lt;/li>
&lt;li>把描述和实现算法所用到的语言特性、软件库和操作系统特定总称为基础编程模型&lt;/li>
&lt;li>Java程序的基本结构
&lt;ul>
&lt;li>
&lt;p>一段Java程序或者是一个静态方法库，或者定义了一个数据类型，需要用到的语法&lt;/p>
&lt;ul>
&lt;li>原始数据类型(在计算机中精确地定义整数浮点数布尔值等)&lt;/li>
&lt;li>语句(创建变量并赋值，控制运行流程或引发副作用来进行计算，包括声明、赋值、条件、循环、调用和返回)&lt;/li>
&lt;li>数组(多个同种数据类型值的集合)&lt;/li>
&lt;li>静态方法(封装并重用代码)&lt;/li>
&lt;li>字符串(一连串的字符，内置一些对他们的操作)&lt;/li>
&lt;li>标准输入/输出(是程序与外界联系的桥梁)&lt;/li>
&lt;li>数据抽象(数据抽象封装和重用代码，可以定义非原始数据类型，进而面向对象编程)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>把这种输入命令执行程序的环境称为 虚拟终端&lt;/p>
&lt;/li>
&lt;li>
&lt;p>要执行一条Java程序，需要先用javac命令编译，然后用java命令运行，比如下面的文件，需要使用命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>javac BinarySearch.java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>java BinarySearch 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="img/ly-20241212142046412.png" alt="" />&lt;br>
&lt;img src="img/ly-20241212142046572.png" alt="" />&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="原始数据类型与表达式">
 原始数据类型与表达式
 &lt;a class="anchor" href="#%e5%8e%9f%e5%a7%8b%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e4%b8%8e%e8%a1%a8%e8%be%be%e5%bc%8f">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>数据类型就是一组数据和其所能进行的操作的集合&lt;/li>
&lt;li>Java中最基础的数据类型(整型int，双精度实数类型double,布尔值boolean,字符型char)&lt;/li>
&lt;li>Java程序控制用标识符命名的变量&lt;/li>
&lt;li>对于原始类型，用标识符引用变量，+-*/指定操作，用字面量来表示值(如1或3.14),用表达式表示对值的操作( 表达式:(x+2.334)/2 )&lt;/li>
&lt;li>只要能够指定值域和在此值域上的操作，就能定义一个数据类型(很像数学上函数的定义)&lt;/li>
&lt;li>+-*/是被重载过的&lt;/li>
&lt;li>运算产生的数据的数据类型和参与运算的数据的数据类型是相同的(5/3=1,5.0/3.0=1.6667等)&lt;/li>
&lt;li>如下图(图歪了亿点点..)
&lt;img src="img/ly-20241212142046692.png" alt="" />&lt;/li>
&lt;li>表达式&lt;/li>
&lt;li>表达式具有优先级，Java使用的是中缀表达式(一个字面量紧接运算符，然后是另一个字面量)。逻辑运算中优先级 ! &amp;amp;&amp;amp; || ,运算符中 * / % 高于+ - 。括号能改变这些规则。代码中尽量使用括号消除对优先级的依赖&lt;/li>
&lt;li>类型转换
&lt;ul>
&lt;li>数值会自动提升为高级数据类型，如1+2.5 1会被先转为double 1.0，值也为double的3.5&lt;/li>
&lt;li>强转(把类型名放在括号里讲其转换为括号中的类型) 讲高级数据类型转为低级可能会导致精度的缺失，尽量少使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>比较
&lt;ul>
&lt;li>==、!=、&amp;lt;、&amp;lt;=、&amp;gt;、&amp;gt;=，这些运算符称为 混合类型运算符，因为结果是布尔型而不是参与比较的数据类型&lt;/li>
&lt;li>结果是布尔型的表达式称为布尔表达式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>其他原始类型(int为32位，double为64位)
&lt;ul>
&lt;li>long,64位整数&lt;/li>
&lt;li>short,16位整数&lt;/li>
&lt;li>char,16位字符&lt;/li>
&lt;li>byte,8位整数&lt;/li>
&lt;li>32位单精度实数,float&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="语句">
 语句
 &lt;a class="anchor" href="#%e8%af%ad%e5%8f%a5">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>语句用来创建和操作变量、对变量赋值并控制操作的执行流程&lt;/li>
&lt;li>包括声明语句、赋值语句、条件语句、循环语句、调用和返回语句&lt;/li>
&lt;li>声明：让一个变量名和一个类型在编译时关联起来&lt;/li>
&lt;li>赋值：将(由一个表达式定义的)某个数据类型额值和一个变量关联起来&lt;/li>
&lt;li>条件语句：
&lt;pre tabindex="0">&lt;code>if (&amp;lt;boolean expression&amp;gt;) { &amp;lt;block statement&amp;gt; }
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>循环语句
&lt;pre tabindex="0">&lt;code>while(&amp;lt;boolean expression&amp;gt;) { &amp;lt;block statement&amp;gt; }
&lt;/code>&lt;/pre>其中循环语句中的代码段称为循环体&lt;/li>
&lt;li>break与continue语句
&lt;ul>
&lt;li>break，立即退出循环&lt;/li>
&lt;li>continue，立即开始下一轮循环&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="简便记法">
 简便记法
 &lt;a class="anchor" href="#%e7%ae%80%e4%be%bf%e8%ae%b0%e6%b3%95">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>声明并初始化&lt;/li>
&lt;li>隐式赋值
&lt;ul>
&lt;li>++i;&amp;ndash;i&lt;/li>
&lt;li>i/=2;i+=1&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>单语句代码段(省略if/while代码段的花括号)&lt;/li>
&lt;li>for语句
&lt;pre tabindex="0">&lt;code>for(&amp;lt;initialize&amp;gt;;&amp;lt;boolean expression&amp;gt;;&amp;lt;increment&amp;gt;)
{
 &amp;lt;block statements&amp;gt;
}
&lt;/code>&lt;/pre>这段代码等价于后面的
&lt;pre tabindex="0">&lt;code>&amp;lt;initialize&amp;gt;;
while(&amp;lt;boolean expression&amp;gt;)
{
 &amp;lt;block statments&amp;gt;
 &amp;lt;increment&amp;gt;;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>java语句总结&lt;br>
&lt;img src="img/ly-20241212142046803.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h3 id="数组">
 数组
 &lt;a class="anchor" href="#%e6%95%b0%e7%bb%84">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>数组能够存储相同类型的多个数据&lt;/li>
&lt;li>N个数组的数组编号为0至N-1；这种数组在Java中称为一维数组&lt;/li>
&lt;li>创建并初始化数组
&lt;ul>
&lt;li>需要三个步骤，声明数组名字和类型，创建数组，初始化数组元素&lt;/li>
&lt;li>声明并初始化一个数组&lt;br>
&lt;img src="img/ly-20241212142046916.png" alt="" />&lt;/li>
&lt;li>简化写法&lt;br>
double[] a = new double[N];&lt;/li>
&lt;li>使用数组(访问的索引小于0或者大于N-1时会抛出ArrayIndexOutOfBoundsException)&lt;/li>
&lt;li>典型的数组处理代码&lt;br>
&lt;img src="img/ly-20241212142047031.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>起别名
&lt;ul>
&lt;li>下面的情况并没有将数组新复制一份，而是a，b指向了同一个数组&lt;br>
&lt;img src="img/ly-20241212142047141.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>二维数组
&lt;ul>
&lt;li>Java中二维数组就是一堆数组的数组&lt;/li>
&lt;li>二维数组可以是参差不齐，比如a[0]=new double[5],a[1]=new double[6]之类&lt;/li>
&lt;li>二维数组的创建及初始化
&lt;pre tabindex="0">&lt;code>double[][] a;
a = new double[M][N];
for (int i = 0; i &amp;lt; M; i++)
 for (int j = 0; j &amp;lt; N; j++)
 a[i][j] = 0.0;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>精简后的代码
double[][] a=new double[M][N];&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>linux_韩老师_01-06</title><link>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/01-06/</link><pubDate>Tue, 25 Jan 2022 14:43:19 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Linux/hanshunping/01-06/</guid><description>&lt;h2 id="基础介绍">
 基础介绍
 &lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>本套课程内容&lt;br>
&lt;img src="img/ly-20241212142131562.png" alt="" />
&lt;ul>
&lt;li>基础篇: linux入门、vm和Linux的安装、linux目录结构&lt;/li>
&lt;li>实操篇
&lt;ul>
&lt;li>远程登录（xshell，xftp）、实用指令、进程管理、用户管理&lt;/li>
&lt;li>vi和vim编辑器、定时任务调度、RPM和YUM&lt;/li>
&lt;li>开机、重启和用户登录注销、磁盘分区及挂载、网络配置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>linux使用的地方
&lt;ul>
&lt;li>在linux下开发项目(需要把javaee项目部署到linux下运行)&lt;/li>
&lt;li>linux运维工程师(服务器规划、优化、监控等)&lt;/li>
&lt;li>linux嵌入式工程师(linux下驱动开发[c,c++])&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>linux应用领域
&lt;ul>
&lt;li>个人桌面&lt;/li>
&lt;li>服务器(免费稳定高效)&lt;/li>
&lt;li>嵌入式领域(对软件裁剪，内核最小可达几百kb等)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="linux介绍">
 linux介绍
 &lt;a class="anchor" href="#linux%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>linux是一个开源免费操作系统&lt;/li>
&lt;li>linux吉祥物&lt;br>
tux(/tu&amp;rsquo;ks/唾可si)，没找到音标，将就一下&lt;br>
&lt;img src="img/ly-20241212142131760.png" alt="" />&lt;/li>
&lt;li>linux之父，linus，也是git的创作者&lt;br>
主要发行版：&lt;strong>Ubuntu、RedHat，Centos&lt;/strong>，Debian等&lt;br>
RedHat和Centos使用同样的源码，但是RedHat收费&lt;/li>
&lt;li>Linux和Unix的关系&lt;br>
unix也是一个操作系统，贝尔实验室。做一个多用户分时操作系统，
multics，但是没完成。其中一个后来在这基础上，完成的操作系统为unix
（原本是B语言写的），后面和另一个人用unix用c语言改写了。&lt;br>
unix源码是公开的，后面商业公司拿来包装做成自己的系统，
后面有个人提倡自由时代用户应该对源码享有读写权利而非垄断&lt;br>
后面RichardStallman发起GNU计划（开源计划），Linus参加该计划，并共享出linux内核，于是大家在此基础上开发出各种软件。linux又称GNU/linux&lt;/li>
&lt;li>Linux和Unix关系&lt;br>
&lt;img src="img/ly-20241212142131836.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h2 id="vmware安装centos76">
 VMWare安装Centos7.6
 &lt;a class="anchor" href="#vmware%e5%ae%89%e8%a3%85centos76">#&lt;/a>
&lt;/h2>
&lt;p>在windows中安装Linux系统&lt;/p>
&lt;ul>
&lt;li>
&lt;p>VM和Linux系统在pc中的关系&lt;br>
&lt;img src="img/ly-20241212142131913.png" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安装过程中，网络模式使用NAT模式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>选择最小安装，且选择CompatibilityLibraries和DevelopmentTools&lt;br>
&lt;img src="img/ly-20241212142131988.png" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>linux分区&lt;br>
一般分为三个&lt;br>
&lt;img src="img/ly-20241212142132065.png" alt="" />&lt;br>
一般boot1G,swap分区一般跟内存大小一致，这里是2G，所以根分区就是剩下的，也就是20-1-2=17G&lt;br>
如图，boot，/，swap都是标准分区。且boot和/是ext4的文件格式，swap是swap的文件格式&lt;br>
&lt;img src="img/ly-20241212142132139.png" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改主机名&lt;br>
&lt;img src="img/ly-20241212142132210.png" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改密码及增加除root外的普通用户&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改网络为固定ip(NAT模式下)&lt;/p>
&lt;ul>
&lt;li>先在VM里面把子网ip改了，这里改成
192.168.200.0&lt;br>
&lt;img src="img/ly-20241212142132285.png" alt="" />&lt;/li>
&lt;li>然后改网关为192.168.200.200&lt;br>
&lt;img src="img/ly-20241212142132357.png" alt="" />&lt;/li>
&lt;li>使用yum install -y vim 安装文本编辑工具&lt;/li>
&lt;li>最后在linux中改配置文件
&lt;pre tabindex="0">&lt;code>vim /etc/sysconfig/network-scripts/ifcfg-ens33
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>其中先修改BOOTPROTO=&amp;ldquo;static&amp;rdquo;&lt;/li>
&lt;li>然后设置ip地址、网关和DNS，
下面是添加到上面的ifcfg-ens33后面，不是直接执行代码
&lt;pre tabindex="0">&lt;code>IPADDR=192.168.200.200
GATEWAY=192.168.200.2
DNS1=192.168.200.2
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>使用命令重启网络
&lt;pre tabindex="0">&lt;code>service network restart 
# 或者直接重启电脑 reboot
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>这里顺便装一下zsx&lt;/p></description></item><item><title>redis_尚硅谷_19-A</title><link>https://lwmfjc.github.io/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/19-A/</link><pubDate>Wed, 19 Jan 2022 16:52:19 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/19-A/</guid><description>&lt;h2 id="验证码模拟">
 验证码模拟
 &lt;a class="anchor" href="#%e9%aa%8c%e8%af%81%e7%a0%81%e6%a8%a1%e6%8b%9f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>首先需要一个MyRedis单例类&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * MyRedis单例类
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyJedis&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Jedis myJedis;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Jedis &lt;span style="color:#a6e22e">getInstance&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果是空则进行初始化&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (myJedis &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//由于synchronized同步是在条件判断内，所以同步&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//并不会一直都执行，增加了效率&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (MyJedis.&lt;span style="color:#a6e22e">class&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (myJedis &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//设置密码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DefaultJedisClientConfig.&lt;span style="color:#a6e22e">Builder&lt;/span> builder &lt;span style="color:#f92672">=&lt;/span> DefaultJedisClientConfig.&lt;span style="color:#a6e22e">builder&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">password&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello.lwm&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DefaultJedisClientConfig config &lt;span style="color:#f92672">=&lt;/span> builder.&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Jedis jedis &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> redis.&lt;span style="color:#a6e22e">clients&lt;/span>.&lt;span style="color:#a6e22e">jedis&lt;/span>.&lt;span style="color:#a6e22e">Jedis&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;192.168.200.200&amp;#34;&lt;/span>, 6379, config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> jedis;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> myJedis;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>redis_尚硅谷_18</title><link>https://lwmfjc.github.io/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/18/</link><pubDate>Wed, 19 Jan 2022 14:07:52 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/18/</guid><description>&lt;h2 id="jedis操作redis6">
 Jedis操作Redis6
 &lt;a class="anchor" href="#jedis%e6%93%8d%e4%bd%9credis6">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>插曲:本地项目关联github远程库
&lt;pre tabindex="0">&lt;code> git init
 git add README.md
 git commit -m &amp;#34;first commit&amp;#34;
 #-m表示强制重命名
 git branch -M main
 #使用别名
 git remote add origin git@github.com:lwmfjc/jedis_demo.git
 #用了-u之后以后可以直接用git push替代整行 
 git push -u origin main 
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>jedis pom依赖
&lt;pre tabindex="0">&lt;code class="language-pom" data-lang="pom">&amp;lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&amp;gt;
&amp;lt;dependency&amp;gt;
 &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;4.0.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>jedis使用
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Main&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//设置密码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DefaultJedisClientConfig.&lt;span style="color:#a6e22e">Builder&lt;/span> builder &lt;span style="color:#f92672">=&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DefaultJedisClientConfig.&lt;span style="color:#a6e22e">builder&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">password&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;hello.lwm&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> DefaultJedisClientConfig config &lt;span style="color:#f92672">=&lt;/span> builder.&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Jedis jedis &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Jedis(&lt;span style="color:#e6db74">&amp;#34;192.168.200.200&amp;#34;&lt;/span>, 6379, config);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//ping&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String value &lt;span style="color:#f92672">=&lt;/span> jedis.&lt;span style="color:#a6e22e">ping&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//返回所有key&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> keys &lt;span style="color:#f92672">=&lt;/span> jedis.&lt;span style="color:#a6e22e">keys&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;*&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;key count: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keys.&lt;span style="color:#a6e22e">size&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String key : keys) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;key--:%s---value:%s\n&amp;#34;&lt;/span>, 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key, jedis.&lt;span style="color:#a6e22e">get&lt;/span>(key));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;操作list&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//操作list&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jedis.&lt;span style="color:#a6e22e">lpush&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ly-list&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;java&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c++&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;css&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> lrange &lt;span style="color:#f92672">=&lt;/span> jedis.&lt;span style="color:#a6e22e">lrange&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ly-list&amp;#34;&lt;/span>, 0, &lt;span style="color:#f92672">-&lt;/span>1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String v : lrange) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;value:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//操作set&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;操作set&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jedis.&lt;span style="color:#a6e22e">sadd&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ly-set&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;5&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Set&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> smembers &lt;span style="color:#f92672">=&lt;/span> jedis.&lt;span style="color:#a6e22e">smembers&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ly-set&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String v : smembers) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;value:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//操作hash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;操作hash&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jedis.&lt;span style="color:#a6e22e">hset&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ly-hash&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;lidian&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jedis.&lt;span style="color:#a6e22e">hset&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ly-hash&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;age&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;30&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jedis.&lt;span style="color:#a6e22e">hset&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ly-hash&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;sex&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;man&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> lyHash &lt;span style="color:#f92672">=&lt;/span> jedis.&lt;span style="color:#a6e22e">hgetAll&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ly-hash&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String key : lyHash.&lt;span style="color:#a6e22e">keySet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(key &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> lyHash.&lt;span style="color:#a6e22e">get&lt;/span>(key));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//操作zset&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;操作zset&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jedis.&lt;span style="color:#a6e22e">zadd&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;person&amp;#34;&lt;/span>, 100, &lt;span style="color:#e6db74">&amp;#34;xiaohong&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jedis.&lt;span style="color:#a6e22e">zadd&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;person&amp;#34;&lt;/span>, 80, &lt;span style="color:#e6db74">&amp;#34;xiaoli&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jedis.&lt;span style="color:#a6e22e">zadd&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;person&amp;#34;&lt;/span>, 90, &lt;span style="color:#e6db74">&amp;#34;xiaochen&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> person &lt;span style="color:#f92672">=&lt;/span> jedis.&lt;span style="color:#a6e22e">zrange&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;person&amp;#34;&lt;/span>, 0, &lt;span style="color:#f92672">-&lt;/span>1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (String name : person) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(name);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//结束操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jedis.&lt;span style="color:#a6e22e">flushDB&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jedis.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul></description></item><item><title>redis_尚硅谷_12-17</title><link>https://lwmfjc.github.io/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/12-17/</link><pubDate>Tue, 18 Jan 2022 08:48:54 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/12-17/</guid><description>&lt;h2 id="redis配置文件">
 Redis配置文件
 &lt;a class="anchor" href="#redis%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>redis中单位的设置，支持k,kb,m,mb,g,gb，且不区分大小写&lt;br>
&lt;img src="img/ly-20241212142200403.png" alt="" />&lt;/li>
&lt;li>include (包含其他文件，比如公共部分)&lt;br>
&lt;img src="img/ly-20241212142200557.png" alt="" />&lt;/li>
&lt;li>bind
&lt;pre tabindex="0">&lt;code>bind 127.0.0.1 ::1 #listens on loopback IPv4 and IPv6 
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>后面这个::1，相当于ipv6版的127.0.0.1。在redis配置文件中，整句表示只允许本地网卡的某个ip连接(但是它并不能指定某个主机连接到redis中。比如本机有两个网卡，两个ip，可以限定只有其中一个ip可以连接)&lt;/li>
&lt;li>如果注释掉了/或者bind 0.0.0.0，表示允许所有主机连接&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>protected-mode
&lt;pre tabindex="0">&lt;code>protected-mode yes 
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>设置保护模式为yes，protected是redis本身的一个安全层，这个安全层在同时满足下面三个条件的时候会开启，开启后只有本机可以访问redis
&lt;ul>
&lt;li>protected-mode yes&lt;/li>
&lt;li>没有bind指令(bind 0.0.0.0不属于这个条件)&lt;/li>
&lt;li>没有设置密码 (没有设置requirepass password)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>只要上面一个条件不满足，就不会开启保护模式。换言之，只要设置了bind 0.0.0.0或者没有设置bind，且不满足上面三个条件之一，就能够进行远程访问(当然，linux/windows的6379端口要开放)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>tcp-backlog 表示未连接队列总和&lt;/li>
&lt;li>timeout 秒为单位，时间内没操作则断开连接&lt;/li>
&lt;li>tcp-keepalive 300 心跳检测，每隔300s检测连接是否存在&lt;/li>
&lt;li>pidfile /var/run/redis_6379.pid 将进程号保存到文件中&lt;/li>
&lt;li>loglevel 表示日志的级别/debug/verbose/&lt;strong>notice&lt;/strong>/warning&lt;/li>
&lt;li>logfile &amp;quot;&amp;quot; 设置日志的路径&lt;/li>
&lt;li>database 16 默认有16个库&lt;/li>
&lt;li>requirepass password 设置密码&lt;/li>
&lt;li>maxclients 设置最大连接数&lt;/li>
&lt;li>maxmemory 设置最大内存量，达到则会根据移除策略进行移除操作&lt;/li>
&lt;/ul>
&lt;h2 id="redis的发布和订阅">
 Redis的发布和订阅
 &lt;a class="anchor" href="#redis%e7%9a%84%e5%8f%91%e5%b8%83%e5%92%8c%e8%ae%a2%e9%98%85">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>发布订阅，pub/sub，是一种消息通信模式：发送者pub发送消息，订阅器sub接收消息&lt;/li>
&lt;li>发布者能发布消息，订阅者可以订阅/接收消息&lt;br>
&lt;img src="img/ly-20241212142200586.png" alt="" />&lt;/li>
&lt;li>操作
&lt;pre tabindex="0">&lt;code class="language-redis" data-lang="redis">subscribe channel1 #客户端A订阅频道 
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code class="language-redis" data-lang="redis">publish channel1 helloly #向频道发送消息
&lt;/code>&lt;/pre>此时订阅channel1频道的客户端就会接收到消息&lt;br>
&lt;img src="img/ly-20241212142200619.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h2 id="redis新数据类型">
 redis新数据类型
 &lt;a class="anchor" href="#redis%e6%96%b0%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="bitmaps">
 Bitmaps
 &lt;a class="anchor" href="#bitmaps">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>进行二进制操作&lt;/p></description></item><item><title>redis_尚硅谷_06-11</title><link>https://lwmfjc.github.io/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/06-11/</link><pubDate>Tue, 04 Jan 2022 16:22:12 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/06-11/</guid><description>&lt;h2 id="redis针对key的基本操作">
 Redis针对key的基本操作
 &lt;a class="anchor" href="#redis%e9%92%88%e5%af%b9key%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>常用命令
&lt;pre tabindex="0">&lt;code>keys * #查找当前库所有库
exists key1 #key1是否存在 1存在；0不存在
type key2 #key2的类型
del key3 #删除key3
unlink key3 #删除key3(选择非阻塞删除。会先从元数据删除，而真正删除是异步删除)
expire key1 10 #设置key1的过期时间，单位秒
ttl key1 #获取key1的剩余存活时间，-2表示key已过期或不存在，-1表示永不过期
select 1 #切换到1号库(redis中有15个库，默认在库1)
dbsize #查找当前redis库中有多少个key
flushdb #清空当前库
flushall #清空所有库
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="redis中常用数据类型">
 Redis中常用数据类型
 &lt;a class="anchor" href="#redis%e4%b8%ad%e5%b8%b8%e7%94%a8%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="字符串string">
 字符串（String）
 &lt;a class="anchor" href="#%e5%ad%97%e7%ac%a6%e4%b8%b2string">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>String是二进制安全的，可以包含jpg图片或序列化的对象&lt;/li>
&lt;li>一个Redis中字符串value最多可以只能是512M&lt;/li>
&lt;li>常用命令
&lt;pre tabindex="0">&lt;code>set key1 value1
get key1 
set key1 value11 #将覆盖上一个值
append key1 abc #在key1的值追加&amp;#34;abc&amp;#34;
strlen key1 #key值的长度
setnx key1 value #当key不存在时才设置key
incr n1 #将n1的值加一,,如果n1不存在则会创建key n1 并改为1(0+1)
decr n1 #将n1的值减一,如果n1不存在则会创建key n1 并改为-1(0-1)
incrby n1 20 #将n1的值加20，其他同上
decrby n1 20 #将n1的值减20，其他同上
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>redis原子性&lt;br>
incr具有原子性操作&lt;br>
java中的i++不是原子操作&lt;/li>
&lt;li>其他命令
&lt;pre tabindex="0">&lt;code>mset k1 v1 k2 v2
mget k1 k2 
msetnx k1 v1 k2 v2 #仅当所有的key都不存在时才会进行设置
getrange name 0 3 #截断字符串[0,3]
setrange name 3 123 #从下标[3]开始替换字符串（换成123）
setex k1 20 v1 #设置过期时间为20s
expire k1 30 #设置过期时间为30s
getset k1 123 #获取旧值，并设置一个新值
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>数据结构，SimpleDynamicString，SDS，简单动态字符串，内部结构类似Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配&lt;br>
&lt;img src="img/ly-20241212142200067.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h3 id="列表-list">
 列表 (List)
 &lt;a class="anchor" href="#%e5%88%97%e8%a1%a8-list">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>单键多值&lt;/li>
&lt;li>底层是双向链表&lt;/li>
&lt;li>从左放
&lt;pre tabindex="0">&lt;code>lpush k1 v1 v2 v3 #从左边放(从左往右推)
lrange k1 0 -1 #从左边取(v3 v2 v1)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>lpush:&lt;br>
&lt;img src="img/ly-20241212142200123.png" alt="" />&lt;/li>
&lt;li>从右放
&lt;pre tabindex="0">&lt;code>rpush k2 v1 v2 v3 
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>brpush:&lt;br>
&lt;img src="img/ly-20241212142200156.png" alt="" />&lt;/li>
&lt;li>lpop/rpop
&lt;pre tabindex="0">&lt;code>lpop k2 #从左边弹出一个值
lpop k2 2 #从左边弹出两个值，当键没有包含值时，键被删除
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>rpoplpush
&lt;pre tabindex="0">&lt;code>lpush a a1 a2 a3
rpush b b1 b2 b3
rpoplpush a b #此时a:a1 a2，b:a3 b1 b2 b3
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>lrange
&lt;pre tabindex="0">&lt;code>lrange b 1 2 #获取b中下标[1,2]的所有值
lrange b 1 -1 #获取所有值[1,最大下标]的所有值
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>lindex,llen
&lt;pre tabindex="0">&lt;code>lindex b 1 #直接取第一个下标的元素
llen b #获取列表的长度
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>linsert
&lt;pre tabindex="0">&lt;code>linsert b before b2 myinsert
linsert b after b2 myinsert
#在某个列表的值(如果重复取第一个)的位置之前/之后插入值
&lt;/code>&lt;/pre>&lt;img src="img/ly-20241212142200200.png" alt="" />&lt;/li>
&lt;li>lrem,lset
&lt;pre tabindex="0">&lt;code>lrem b 2 a #从b列表中，删除两个a（从左往右）
lset b 2 AA #把下标2的值设置为AA
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>list数据结构是一个快速列表，quicklist&lt;br>
当元素较少的时候，会使用连续的内存存储，结构时ziplist，即压缩列表；当数据多的时候会有多个压缩列表，然后会链接到一起(使用双向指针)&lt;br>
&lt;img src="img/ly-20241212142200233.png" alt="" />&lt;/li>
&lt;/ul>
&lt;h3 id="集合set">
 集合(Set)
 &lt;a class="anchor" href="#%e9%9b%86%e5%90%88set">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>特点：无序，不重复&lt;/li>
&lt;li>Set:string类型的无序集合，底层是一个value为null的hash表；添加/删除时间复杂度为O(1)&lt;/li>
&lt;li>常用命令
&lt;pre tabindex="0">&lt;code>sadd k1 v1 v2 v3 v2 v2 v1 #设置集合中的值
smembers k1 #取出集合中的值
sismember k1 v3 #k1是否存在v3，存在返回1，不存在返回0
scard k1 #返回集合中元素的个数
srem k1 v2 v3 #删除集合中的v2和v3
spop k1 #从k1中随机取出一个值
srandmember k1 2 #从k1中随机取出2个值
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>smove a k a1 #从a中将a1移动到k中
sinter a k #取a，k的交集
sunion a k #取a，k的并集
sdiff a k #返回两个集合的差集（从集合a中，去除存在集合k中的元素，即a-k）
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>Set数据结构时dict字典，字典使用哈希表实现的&lt;/li>
&lt;/ul>
&lt;h3 id="哈希hash">
 哈希（Hash)
 &lt;a class="anchor" href="#%e5%93%88%e5%b8%8chash">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>是String类型的field和value的映射表，用来存储对象,类似java中的Map&amp;lt;String,Object&amp;gt; &lt;br>
&lt;img src="img/ly-20241212142200266.png" alt="" />&lt;/li>
&lt;li>常用命令
&lt;pre tabindex="0">&lt;code>hset user:1001 id 1 #设置(对象)user:1001的id属性值
hset user:1001 name zhangsan 
hget user:1001 name #取出user:1001的name
hmset user:1001 id 1 name zhangsan #批量设置（现在hset也可以批量设置了，hmset已弃用）
hexists user:1001 id 1 #判断属性id是否存在
hkeys user:1001 #查看hash结构中的所有filed
hvals user:1001 #查看hash结构中所有value
hincrby user:1001 age 2 #给hash结构的age属性值加2
hsetnx user:1001 age 10 #给hash结构的age属性设置值为10（如果age属性不存在）
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>hash类型数据结构，当field-value长度较短时用的是ziplist，否则使用的是hashtable&lt;/li>
&lt;/ul>
&lt;h3 id="有序集合zset">
 有序集合(ZSet)
 &lt;a class="anchor" href="#%e6%9c%89%e5%ba%8f%e9%9b%86%e5%90%88zset">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>与set很相似，但是是有序的&lt;/li>
&lt;li>有序集合的所有元素（成员）都关联一个评分(score)，score用来从最低到最高方式进行排序，成员唯一但评分是重复的&lt;/li>
&lt;li>常用命令
&lt;pre tabindex="0">&lt;code>zadd topn 100 xiaoming 120 xiaohong 60 xiaochen #添加key并为每个成员添加评分
zadd topn xiaoli 200 
zrange topn 0 -1 #查找出所有成员(按排名由小到大)
zrange topn 0 -1 withscores #从小到大查找所有成员并显示分数
zrangebyscore topn 130 200 #查找所有在130-200的成员
zrevrangebyscore topn 200 130 #从大到小查找所有成员（注意，从大到小时第一个值必须大于等于第二个）
zincrby topn 15 xiaohong #给小红添加15分
zrem topn xiaohong #删除元素
zcount topn 10 200 #统计该集合，分数区间内的元素个数
zrank topn xiaohong #xiaohong的排名，从0开始
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>zset底层数据结构
&lt;ul>
&lt;li>hash结构&lt;br>
&lt;img src="img/ly-20241212142200298.png" alt="" />&lt;/li>
&lt;li>跳跃表
给元素value排序，根据score的范围获取元素列表&lt;/li>
&lt;li>对比有序链表和跳跃表
&lt;ul>
&lt;li>查找51元素&lt;br>
&lt;img src="img/ly-20241212142200328.png" alt="" />&lt;/li>
&lt;li>跳跃表&lt;br>
按图中的顺序查找，查找四次就能找到&lt;br>
&lt;img src="img/ly-20241212142200360.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>End&lt;/li>
&lt;/ul></description></item><item><title>hugo踩坑</title><link>https://lwmfjc.github.io/zh/docs/problem/Hugo/p1/</link><pubDate>Mon, 27 Dec 2021 09:31:50 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/Hugo/p1/</guid><description>&lt;ul>
&lt;li>
&lt;p>对于访问文件资源&lt;/p>
&lt;ul>
&lt;li>hugo的文件夹名不能以-结尾。&lt;/li>
&lt;li>一个文件夹(比如这里是hugo文件夹)中，其中的index.md文件中引用图片时，是以index.md所在文件夹(也就是hugo文件夹)为根目录访问图片；而其中的01a.md文件中引用图片时，是以和该文件同级的01a文件夹(也就是hugo/01a/)为根目录，访问图片&lt;br>
&lt;img src="img/ly-20241212141832633.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>当一个文件夹下存在index.md文件时，其他文件(代表的文章)不显示在网站的文章列表&lt;br>
&lt;img src="img/ly-20241212141832862.png" alt="" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为了某些文件预览功能，我建议使用下面的文件夹结构处理文章及资源&lt;br>
&lt;img src="img/ly-20241212141833048.png" alt="" />&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>图片测试(hugo踩坑)</title><link>https://lwmfjc.github.io/zh/docs/problem/Hugo/01a/</link><pubDate>Mon, 27 Dec 2021 09:31:50 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/problem/Hugo/01a/</guid><description>&lt;h2 id="图片测试">
 图片测试
 &lt;a class="anchor" href="#%e5%9b%be%e7%89%87%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="img/ly-20241212141831580.png" alt="yutyutyu" />&lt;br>
&lt;img src="img/ly-20241212141831894.png" alt="grwerweer" />&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141832073.png" alt="" />&lt;/p>
&lt;p>&lt;img src="img/ly-20241212141832254.png" alt="" />&lt;br>
&lt;img src="img/ly-20241212141832439.png" alt="" />&lt;/p></description></item><item><title>redis_尚硅谷_01-05</title><link>https://lwmfjc.github.io/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/01-05/</link><pubDate>Mon, 27 Dec 2021 09:09:03 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Redis/shangguigu_BV1Rv41177Af/01-05/</guid><description>&lt;h2 id="课程简介">
 课程简介
 &lt;a class="anchor" href="#%e8%af%be%e7%a8%8b%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;p>NoSQL数据库简介、Redis概述与安装、常用五大数据结构、配置文件详解、发布与订阅、Redis6新数据类型、Redis与spring boot整合、事务操作、持久化之RDB、持久化之AOF、主从复制及集群、Redis6应用问题(缓存穿透、击穿、雪崩以及分布式锁)、Redis6新增功能&lt;/p>
&lt;h2 id="nosql数据库简介">
 NoSQL数据库简介
 &lt;a class="anchor" href="#nosql%e6%95%b0%e6%8d%ae%e5%ba%93%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>Redis属于NoSQL数据库&lt;/li>
&lt;li>技术分为三大类
&lt;ul>
&lt;li>解决功能性问题：Java、Jsp、RDBMS、Tomcat、Linux、JDBC、SVN&lt;/li>
&lt;li>解决扩展性问题：Struts、Spring、SpringMVC、Hibernate、Mybatis&lt;/li>
&lt;li>解决性能问题：NoSQL、Java线程、Nginx、MQ、ElasticSearch&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缓存数据库的好处
&lt;ul>
&lt;li>完全在内存中，速度快，结构简单&lt;/li>
&lt;li>作为缓存数据库：减少io的读操作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>NoSQL＝Not Only SQL,不仅仅是SQL，泛指&lt;strong>非泛型数据库&lt;/strong>
&lt;ul>
&lt;li>不支持ACID(但是NoSQL支持事务)&lt;/li>
&lt;li>选超于SQL的性能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>NoSQL适用场景
&lt;ul>
&lt;li>对数据高并发的读写&lt;/li>
&lt;li>海量数据的读写&lt;/li>
&lt;li>对数据高可扩展性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>NoSQL不适用的场景
&lt;ul>
&lt;li>需要事务支持&lt;/li>
&lt;li>基于sql的结构化查询存储&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>多种NoSQL数据库介绍
&lt;ul>
&lt;li>Memcache 不支持持久化，数据类型单一，一般作为辅助持久化的数据库&lt;/li>
&lt;li>Redis 支持持久化，除了k-v模式还有其他多种数据结构，一般作为辅助持久化的数据库&lt;/li>
&lt;li>MongoDB，是文档型数据类型；k-v模型，但是对value提供了丰富的查询功能；支持二进制数据及大型对象；替代RDBMS，成为独立数据库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>大数据时代（行式数据库、列式数据库）
&lt;ul>
&lt;li>行式数据库&lt;br>
查询某一块数据的时候效率高&lt;br>
&lt;img src="img/ly-20241212142159687.png" alt="" />&lt;/li>
&lt;li>列式数据库&lt;br>
查询某一列统计信息快&lt;br>
&lt;img src="img/ly-20241212142159845.png" alt="" />&lt;/li>
&lt;li>其他&lt;br>
Hbase，Cassandra，图关系数据库(比如社会关系，公共交通网等)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>小计&lt;br>
NoSQL数据库是为提高性能而产生的非关系型数据库&lt;/li>
&lt;/ul>
&lt;h2 id="redis概述与安装">
 Redis概述与安装
 &lt;a class="anchor" href="#redis%e6%a6%82%e8%bf%b0%e4%b8%8e%e5%ae%89%e8%a3%85">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>简单概述
&lt;ul>
&lt;li>Redis是一个开源的kv存储系统&lt;/li>
&lt;li>相比Mencached，支持存储的数据类型更多，包括string，list，set，zset以及hash，这些类型都支持(pop、add/remove及取交并集和差集等)，操作都是原子性的&lt;/li>
&lt;li>Redis数据都是缓存在内存中&lt;/li>
&lt;li>Redis会周期性地把数据写入磁盘或修改操作写入追加的记录文件&lt;/li>
&lt;li>能在此基础上实现master-slave(主从)同步&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Redis功能
&lt;ul>
&lt;li>配合关系型数据库做高速缓存&lt;/li>
&lt;li>Redis具有多样的数据结构存储持久化数据&lt;/li>
&lt;li>其他部分功能&lt;br>
&lt;img src="img/ly-20241212142159875.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Redis安装
&lt;ul>
&lt;li>从官网中下载redis-6.xx.tar.gz包(该教程在linux中使用redis6教学)&lt;/li>
&lt;li>编译redis需要gcc环境
&lt;ul>
&lt;li>使用gcc &amp;ndash;version查看服务器是否有gcc环境&lt;/li>
&lt;li>如果没有需要进行安装
&lt;pre tabindex="0">&lt;code class="language-l" data-lang="l">apt install -y gcc
或者
yum install -y gcc
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将redis压缩文件进行解压
&lt;pre tabindex="0">&lt;code>tar -zxvf redis-6xx.tar.gz
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>进入解压后的文件夹，并使用make命令进行编译
&lt;pre tabindex="0">&lt;code>make
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>如果报错了，需要先用下面命令清理，之后再进行编译
&lt;pre tabindex="0">&lt;code>make distclean
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>安装redis
&lt;pre tabindex="0">&lt;code>make install
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>进入/usr/local/bin目录，查看目录&lt;br>
&lt;img src="img/ly-20241212142159913.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Redis启动
&lt;ul>
&lt;li>前台启动
&lt;pre tabindex="0">&lt;code>redis-server 
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>后台启动
&lt;ul>
&lt;li>在刚才解压的文件夹中，拷贝出redis.conf文件(这里拷贝到/etc/目录下)
&lt;pre tabindex="0">&lt;code>cp redis.conf /etc/redis.conf
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>到etc中修改redis.conf文件
&lt;pre tabindex="0">&lt;code>vim /etc/redis.conf
# 进入编辑器后使用下面命令进行搜索并回车
/daemonize no
&lt;/code>&lt;/pre>将no改为yes并保存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>进入/usr/local/bin目录启动redis
&lt;pre tabindex="0">&lt;code>redis-server /etc/redis.conf 
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>查看进程，发现redis已经启动
&lt;pre tabindex="0">&lt;code>ps -ef | grep redis
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>使用redis-cli 客户端连接redis
&lt;pre tabindex="0">&lt;code>redis-cli
keys * 
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="相关知识">
 相关知识
 &lt;a class="anchor" href="#%e7%9b%b8%e5%85%b3%e7%9f%a5%e8%af%86">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>Redis6379的由来
&lt;ul>
&lt;li>人名Merz 在九宫格对应的数字就是6379&lt;br>
&lt;img src="img/ly-20241212142159946.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Redis默认有15个库，默认数据都在数据库0中，所有库的密码都是相同的&lt;/li>
&lt;li>Redis是单线程+多路复用技术
&lt;ul>
&lt;li>Redis是串行操作&lt;br>
&lt;img src="img/ly-20241212142159981.png" alt="" />&lt;/li>
&lt;li>火车站的例子&lt;br>
当1，2，3没有票的时候，不用一直等待买票，可以继续做自己的事情，黄牛买到票就会通知123进行取票&lt;br>
&lt;img src="img/ly-20241212142200015.png" alt="" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Memcached和Redis区别
&lt;ul>
&lt;li>Memcached支持单一数据类型，Redis支持多数据类型&lt;/li>
&lt;li>Memcached不支持持久化&lt;/li>
&lt;li>Memcached用的多线程+锁的机制，Redis用的是单线程+多路复用程序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="end">
 End
 &lt;a class="anchor" href="#end">#&lt;/a>
&lt;/h2></description></item><item><title>2021年最后一个周日</title><link>https://lwmfjc.github.io/zh/docs/life/archive/20121226/</link><pubDate>Sun, 26 Dec 2021 23:14:07 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/life/archive/20121226/</guid><description>&lt;h2 id="装宽带">
 装宽带
 &lt;a class="anchor" href="#%e8%a3%85%e5%ae%bd%e5%b8%a6">#&lt;/a>
&lt;/h2>
&lt;p>太晚了，不想写了- -。简单写几个字吧，满心期待的装了宽带，但是并没有我想像的那么快乐。反而打了两把游戏更难过了，难过的是浪费了时间也什么都没得到&lt;/p>
&lt;h2 id="图书馆">
 图书馆
 &lt;a class="anchor" href="#%e5%9b%be%e4%b9%a6%e9%a6%86">#&lt;/a>
&lt;/h2>
&lt;p>下午跑去图书馆收获倒是挺多，可能是我不太熟悉，对于书架上的书没有太大的感触。但是环境真的太棒了，很安静，感觉多发出点声音我都会觉得不好意思，大家都很自觉。也许对经常网上都能找到电子书看(程序员的事怎么能是盗呢)的人帮助不会特别大，但对于很大一部分人绝对帮助特别大，包括学生、老年人、还有一些文学类书籍阅读者等等(我一直认为文学类的一定要纸质的看起来才有味道~)&lt;br>
当然，从图书馆回来我又打了两把游戏 o_O，dota2 yyds!! 打完日常卸载，哈哈&lt;/p>
&lt;p>每次去图书馆我都会想起那句话，&lt;code>&amp;quot;一个国家为其年轻人所提供的教育，决定了这个国家未来的样子&amp;quot;&lt;/code>。&lt;br>
希望能多办点这样的图书馆，大家都能少点浮躁，多点沉淀；虽然我并不是热心公益人士，但我还是希望咱们国家的人民都生活的越来越好。不要辜负我们曾经受过的苦难。&lt;/p></description></item><item><title>沉沦</title><link>https://lwmfjc.github.io/zh/docs/life/archive/20231021/</link><pubDate>Mon, 21 Oct 2013 17:47:42 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/life/archive/20231021/</guid><description>&lt;p>玩物丧志并非是错的，如果你命里是的话。可惜我不是，我明显有其他更为重要的事等着我去做。我应该是骨子里的老实人。如果顺利的话我应该属于研究所那种老干部，至少现在思维已经老化得跟他们差不多了。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/data-structure/heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/data-structure/heap/</guid><description>&lt;h1 id="堆">
 堆
 &lt;a class="anchor" href="#%e5%a0%86">#&lt;/a>
&lt;/h1>
&lt;h2 id="什么是堆">
 什么是堆
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%a0%86">#&lt;/a>
&lt;/h2>
&lt;p>堆是一种满足以下条件的树：&lt;/p>
&lt;p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。&lt;/p>
&lt;blockquote>
&lt;p>大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>!!!特别提示：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>很多博客说堆是完全二叉树，其实并非如此，&lt;strong>堆不一定是完全二叉树&lt;/strong>，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。&lt;/li>
&lt;li>（&lt;strong>二叉&lt;/strong>）堆是一个数组，它可以被看成是一个 &lt;strong>近似的完全二叉树&lt;/strong>。——《算法导论》第三版&lt;/li>
&lt;/ul>
&lt;p>大家可以尝试判断下面给出的图是否是堆？&lt;/p>
&lt;p>&lt;img src="./pictures/%e5%a0%86/%e5%a0%861.png" alt="" />&lt;/p>
&lt;p>第 1 个和第 2 个是堆。第 1 个是最大堆，每个节点都比子树中所有节点大。第 2 个是最小堆，每个节点都比子树中所有节点小。&lt;/p>
&lt;p>第 3 个不是，第三个中，根结点 1 比 2 和 15 小，而 15 却比 3 大，19 比 5 大，不满足堆的性质。&lt;/p>
&lt;h2 id="堆的用途">
 堆的用途
 &lt;a class="anchor" href="#%e5%a0%86%e7%9a%84%e7%94%a8%e9%80%94">#&lt;/a>
&lt;/h2>
&lt;p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。&lt;/p>
&lt;p>有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 &lt;code>O(nlog(n))&lt;/code>，查找最大值或者最小值时间复杂度都是 &lt;code>O(1)&lt;/code>，但是，涉及到更新（插入或删除）数据时，时间复杂度为 &lt;code>O(n)&lt;/code>，即使是使用复杂度为 &lt;code>O(log(n))&lt;/code> 的二分法找到要插入或者删除的数据，在移动数据时也需要 &lt;code>O(n)&lt;/code> 的时间复杂度。&lt;/p>
&lt;p>&lt;strong>相对于有序数组而言，堆的主要优势在于插入和删除数据效率较高。&lt;/strong> 因为堆是基于完全二叉树实现的，所以在插入和删除数据时，只需要在二叉树中上下移动节点，时间复杂度为 &lt;code>O(log(n))&lt;/code>，相比有序数组的 &lt;code>O(n)&lt;/code>，效率更高。&lt;/p>
&lt;p>不过，需要注意的是：Heap 初始化的时间复杂度为 &lt;code>O(n)&lt;/code>，而非&lt;code>O(nlogn)&lt;/code>。&lt;/p>
&lt;h2 id="堆的分类">
 堆的分类
 &lt;a class="anchor" href="#%e5%a0%86%e7%9a%84%e5%88%86%e7%b1%bb">#&lt;/a>
&lt;/h2>
&lt;p>堆分为 &lt;strong>最大堆&lt;/strong> 和 &lt;strong>最小堆&lt;/strong>。二者的区别在于节点的排序方式。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>最大堆&lt;/strong>：堆中的每一个节点的值都大于等于子树中所有节点的值&lt;/li>
&lt;li>&lt;strong>最小堆&lt;/strong>：堆中的每一个节点的值都小于等于子树中所有节点的值&lt;/li>
&lt;/ul>
&lt;p>如下图所示，图 1 是最大堆，图 2 是最小堆&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/readme/</guid><description>&lt;h1 id="程序人生">
 程序人生
 &lt;a class="anchor" href="#%e7%a8%8b%e5%ba%8f%e4%ba%ba%e7%94%9f">#&lt;/a>
&lt;/h1>
&lt;p>这里主要会收录一些我看到的或者我自己写的和程序员密切相关的非技术类的优质文章，每一篇都值得你阅读 3 遍以上！常看常新！&lt;/p>
&lt;h2 id="练级攻略">
 练级攻略
 &lt;a class="anchor" href="#%e7%bb%83%e7%ba%a7%e6%94%bb%e7%95%a5">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="./advanced-programmer/programmer-quickly-learn-new-technology.md">程序员如何快速学习新技术&lt;/a>&lt;/li>
&lt;li>&lt;a href="./advanced-programmer/the-growth-strategy-of-the-technological-giant.md">程序员的技术成长战略&lt;/a>&lt;/li>
&lt;li>&lt;a href="./advanced-programmer/ten-years-of-dachang-growth-road.md">十年大厂成长之路&lt;/a>&lt;/li>
&lt;li>&lt;a href="./advanced-programmer/meituan-three-year-summary-lesson-10.md">美团三年，总结的 10 条血泪教训&lt;/a>&lt;/li>
&lt;li>&lt;a href="./advanced-programmer/seven-tips-for-becoming-an-advanced-programmer.md">给想成长为高级别开发同学的七条建议&lt;/a>&lt;/li>
&lt;li>&lt;a href="./advanced-programmer/20-bad-habits-of-bad-programmers.md">糟糕程序员的 20 个坏习惯&lt;/a>&lt;/li>
&lt;li>&lt;a href="./advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work.md">工作五年之后，对技术和业务的思考&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="个人经历">
 个人经历
 &lt;a class="anchor" href="#%e4%b8%aa%e4%ba%ba%e7%bb%8f%e5%8e%86">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="./personal-experience/four-year-work-in-tencent-summary.md">从校招入职腾讯的四年工作总结&lt;/a>&lt;/li>
&lt;li>&lt;a href="./personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao.md">我在滴滴和头条的两年后端研发工作经验分享&lt;/a>&lt;/li>
&lt;li>&lt;a href="./personal-experience/8-years-programmer-work-summary.md">一个中科大差生的 8 年程序员工作总结&lt;/a>&lt;/li>
&lt;li>&lt;a href="./personal-experience/huawei-od-275-days.md">华为 OD 275 天后，我进了腾讯！&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="程序员">
 程序员
 &lt;a class="anchor" href="#%e7%a8%8b%e5%ba%8f%e5%91%98">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="./programmer/high-value-certifications-for-programmers.md">程序员最该拿的几种高含金量证书&lt;/a>&lt;/li>
&lt;li>&lt;a href="./programmer/how-do-programmers-publish-a-technical-book.md">程序员怎样出版一本技术书&lt;/a>&lt;/li>
&lt;li>&lt;a href="./programmer/efficient-book-publishing-and-practice-guide.md">程序员高效出书避坑和实践指南&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="面试">
 面试
 &lt;a class="anchor" href="#%e9%9d%a2%e8%af%95">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="./interview/the-experience-of-get-offer-from-over-20-big-companies.md">斩获 20+ 大厂 offer 的面试经验分享&lt;/a>&lt;/li>
&lt;li>&lt;a href="./interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer.md">一位大龄程序员所经历的面试的历炼和思考&lt;/a>&lt;/li>
&lt;li>&lt;a href="./interview/technical-preliminary-preparation.md">从面试官和候选者的角度谈如何准备技术初试&lt;/a>&lt;/li>
&lt;li>&lt;a href="./interview/screen-candidates-for-packaging.md">包装严重的 IT 行业，作为面试官，我是如何甄别应聘者的包装程度&lt;/a>&lt;/li>
&lt;li>&lt;a href="./interview/summary-of-spring-recruitment.md">普通人的春招总结（阿里、腾讯 offer）&lt;/a>&lt;/li>
&lt;li>&lt;a href="./interview/my-personal-experience-in-2021.md">2021 校招我的个人经历和经验&lt;/a>&lt;/li>
&lt;li>&lt;a href="./interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology.md">如何在技术初试中考察程序员的技术能力&lt;/a>&lt;/li>
&lt;li>&lt;a href="./interview/some-secrets-about-alibaba-interview.md">阿里技术面试的一些秘密&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="工作">
 工作
 &lt;a class="anchor" href="#%e5%b7%a5%e4%bd%9c">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="./work/get-into-work-mode-quickly-when-you-join-a-company.md">新入职一家公司如何快速进入工作状态&lt;/a>&lt;/li>
&lt;li>&lt;a href="./work/32-tips-improving-career.md">32 条总结教你提升职场经验&lt;/a>&lt;/li>
&lt;li>&lt;a href="./work/employee-performance.md">聊聊大厂的绩效考核&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-keyword-summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-keyword-summary/</guid><description>&lt;h1 id="finalstaticthissuper-关键字总结">
 final,static,this,super 关键字总结
 &lt;a class="anchor" href="#finalstaticthissuper-%e5%85%b3%e9%94%ae%e5%ad%97%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h1>
&lt;h2 id="final-关键字">
 final 关键字
 &lt;a class="anchor" href="#final-%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>final 关键字，意思是最终的、不可修改的，最见不得变化 ，用来修饰类、方法和变量，具有以下特点：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>final 修饰的方法不能被重写；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>说明：使用 final 方法的原因有两个：&lt;/p>
&lt;ol>
&lt;li>把方法锁定，以防任何继承类修改它的含义；&lt;/li>
&lt;li>效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。&lt;/li>
&lt;/ol>
&lt;h2 id="static-关键字">
 static 关键字
 &lt;a class="anchor" href="#static-%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>static 关键字主要有以下四种使用场景：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>修饰成员变量和成员方法:&lt;/strong> 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：&lt;code>类名.静态变量名&lt;/code> &lt;code>类名.静态方法名()&lt;/code>&lt;/li>
&lt;li>&lt;strong>静态代码块:&lt;/strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&amp;gt;非静态代码块—&amp;gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.&lt;/li>
&lt;li>&lt;strong>静态内部类（static 修饰类的话只能修饰内部类）：&lt;/strong> 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。&lt;/li>
&lt;li>&lt;strong>静态导包(用来导入类中的静态资源，1.5 之后的新特性):&lt;/strong> 格式为：&lt;code>import static&lt;/code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。&lt;/li>
&lt;/ol>
&lt;h2 id="this-关键字">
 this 关键字
 &lt;a class="anchor" href="#this-%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>
&lt;/h2>
&lt;p>this 关键字用于引用类的当前实例。 例如：&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java8-tutorial-translate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java8-tutorial-translate/</guid><description>&lt;h1 id="java8-指南中文翻译">
 《Java8 指南》中文翻译
 &lt;a class="anchor" href="#java8-%e6%8c%87%e5%8d%97%e4%b8%ad%e6%96%87%e7%bf%bb%e8%af%91">#&lt;/a>
&lt;/h1>
&lt;p>随着 Java 8 的普及度越来越高，很多人都提到面试中关于 Java 8 也是非常常问的知识点。应各位要求和需要，我打算对这部分知识做一个总结。本来准备自己总结的，后面看到 GitHub 上有一个相关的仓库，地址：
&lt;a href="https://github.com/winterbe/java8-tutorial">https://github.com/winterbe/java8-tutorial&lt;/a>。这个仓库是英文的，我对其进行了翻译并添加和修改了部分内容，下面是正文。&lt;/p>
&lt;hr>
&lt;p>欢迎阅读我对 Java 8 的介绍。本教程将逐步指导您完成所有新语言功能。 在简短的代码示例的基础上，您将学习如何使用默认接口方法，lambda 表达式，方法引用和可重复注释。 在本文的最后，您将熟悉最新的 API 更改，如流，函数式接口(Functional Interfaces)，Map 类的扩展和新的 Date API。 没有大段枯燥的文字，只有一堆注释的代码片段。&lt;/p>
&lt;h2 id="接口的默认方法default-methods-for-interfaces">
 接口的默认方法(Default Methods for Interfaces)
 &lt;a class="anchor" href="#%e6%8e%a5%e5%8f%a3%e7%9a%84%e9%bb%98%e8%ae%a4%e6%96%b9%e6%b3%95default-methods-for-interfaces">#&lt;/a>
&lt;/h2>
&lt;p>Java 8 使我们能够通过使用 &lt;code>default&lt;/code> 关键字向接口添加非抽象方法实现。 此功能也称为&lt;a href="http://stackoverflow.com/a/24102730">虚拟扩展方法&lt;/a>。&lt;/p>
&lt;p>第一个例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Formula&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">sqrt&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Math.&lt;span style="color:#a6e22e">sqrt&lt;/span>(a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Formula 接口中除了抽象方法计算接口公式还定义了默认方法 &lt;code>sqrt&lt;/code>。 实现该接口的类只需要实现抽象方法 &lt;code>calculate&lt;/code>。 默认方法&lt;code>sqrt&lt;/code> 可以直接使用。当然你也可以直接通过接口创建对象，然后实现接口中的默认方法就可以了，我们通过代码演示一下这种方式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Main&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通过匿名内部类方式访问接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Formula formula &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Formula() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sqrt(a &lt;span style="color:#f92672">*&lt;/span> 100);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(formula.&lt;span style="color:#a6e22e">calculate&lt;/span>(100)); &lt;span style="color:#75715e">// 100.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(formula.&lt;span style="color:#a6e22e">sqrt&lt;/span>(16)); &lt;span style="color:#75715e">// 4.0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>formula 是作为匿名对象实现的。该代码非常容易理解，6 行代码实现了计算 &lt;code>sqrt(a * 100)&lt;/code>。在下一节中，我们将会看到在 Java 8 中实现单个方法对象有一种更好更方便的方法。&lt;/p></description></item><item><title/><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>&lt;h1 id="servlet-总结">
 Servlet 总结
 &lt;a class="anchor" href="#servlet-%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h1>
&lt;p>在 Java Web 程序中，&lt;strong>Servlet&lt;/strong>主要负责接收用户请求 &lt;code>HttpServletRequest&lt;/code>,在&lt;code>doGet()&lt;/code>,&lt;code>doPost()&lt;/code>中做相应的处理，并将回应&lt;code>HttpServletResponse&lt;/code>反馈给用户。&lt;strong>Servlet&lt;/strong> 可以设置初始化参数，供 Servlet 内部使用。一个 Servlet 类只会有一个实例，在它初始化时调用&lt;code>init()&lt;/code>方法，销毁时调用&lt;code>destroy()&lt;/code>方法**。**Servlet 需要在 web.xml 中配置（MyEclipse 中创建 Servlet 会自动配置），&lt;strong>一个 Servlet 可以设置多个 URL 访问&lt;/strong>。&lt;strong>Servlet 不是线程安全&lt;/strong>，因此要谨慎使用类变量。&lt;/p>
&lt;h2 id="阐述-servlet-和-cgi-的区别">
 阐述 Servlet 和 CGI 的区别?
 &lt;a class="anchor" href="#%e9%98%90%e8%bf%b0-servlet-%e5%92%8c-cgi-%e7%9a%84%e5%8c%ba%e5%88%ab">#&lt;/a>
&lt;/h2>
&lt;h3 id="cgi-的不足之处">
 CGI 的不足之处
 &lt;a class="anchor" href="#cgi-%e7%9a%84%e4%b8%8d%e8%b6%b3%e4%b9%8b%e5%a4%84">#&lt;/a>
&lt;/h3>
&lt;p>1，需要为每个请求启动一个操作 CGI 程序的系统进程。如果请求频繁，这将会带来很大的开销。&lt;/p>
&lt;p>2，需要为每个请求加载和运行一个 CGI 程序，这将带来很大的开销&lt;/p>
&lt;p>3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。&lt;/p>
&lt;h3 id="servlet-的优点">
 Servlet 的优点
 &lt;a class="anchor" href="#servlet-%e7%9a%84%e4%bc%98%e7%82%b9">#&lt;/a>
&lt;/h3>
&lt;p>1，只需要启动一个操作系统进程以及加载一个 JVM，大大降低了系统的开销&lt;/p>
&lt;p>2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销&lt;/p>
&lt;p>3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。&lt;/p>
&lt;p>4，Servlet 能直接和 Web 服务器交互，而普通的 CGI 程序不能。Servlet 还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。&lt;/p>
&lt;p>补充：Sun Microsystems 公司在 1996 年发布 Servlet 技术就是为了和 CGI 进行竞争，Servlet 是一个特殊的 Java 程序，一个基于 Java 的 Web 应用通常包含一个或多个 Servlet 类。Servlet 不能够自行创建并执行，它是在 Servlet 容器中运行的，容器将用户的请求传递给 Servlet 程序，并将 Servlet 的响应回传给用户。通常一个 Servlet 会关联一个或多个 JSP 页面。以前 CGI 经常因为性能开销上的问题被诟病，然而 Fast CGI 早就已经解决了 CGI 效率上的问题，所以面试的时候大可不必信口开河的诟病 CGI，事实上有很多你熟悉的网站都使用了 CGI 技术。&lt;/p></description></item><item><title>《计算机网络》（谢希仁）内容总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/computer-network-xiexiren-summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/computer-network-xiexiren-summary/</guid><description>&lt;p>本文是我在大二学习计算机网络期间整理， 大部分内容都来自于谢希仁老师的&lt;a href="https://www.elias.ltd/usr/local/etc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%AC7%E7%89%88%EF%BC%89%E8%B0%A2%E5%B8%8C%E4%BB%81.pdf">《计算机网络》第七版&lt;/a>这本书。为了内容更容易理解，我对之前的整理进行了一波重构，并配上了一些相关的示意图便于理解。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/fb5d8645cd55484ab0177f25a13e97db~tplv-k3u1fbpfcp-zoom-1.png" alt="" />&lt;/p>
&lt;p>相关问题：&lt;a href="https://www.zhihu.com/question/327872966">如何评价谢希仁的计算机网络（第七版）？ - 知乎&lt;/a> 。&lt;/p>
&lt;h2 id="1-计算机网络概述">
 1. 计算机网络概述
 &lt;a class="anchor" href="#1-%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e6%a6%82%e8%bf%b0">#&lt;/a>
&lt;/h2>
&lt;h3 id="11-基本术语">
 1.1. 基本术语
 &lt;a class="anchor" href="#11-%e5%9f%ba%e6%9c%ac%e6%9c%af%e8%af%ad">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>结点 （node）&lt;/strong>：网络中的结点可以是计算机，集线器，交换机或路由器等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>链路（link ）&lt;/strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>主机（host）&lt;/strong>：连接在因特网上的计算机。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ISP（Internet Service Provider）&lt;/strong>：因特网服务提供者（提供商）。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/e77e26123d404d438d0c5943e3c65893~tplv-k3u1fbpfcp-zoom-1.png" alt="ISP (Internet Service Provider) Definition" />&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>IXP（Internet eXchange Point）&lt;/strong>：互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/7f9a6ddaa09441ceac11cb77f7a69d8f~tplv-k3u1fbpfcp-zoom-1.png" alt="IXP Traffic Levels During the Stratos Skydive — RIPE Labs" />&lt;/p>
&lt;p style="text-align:center;font-size:13px;color:gray">https://labs.ripe.net/Members/fergalc/ixp-traffic-during-stratos-skydive&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>RFC(Request For Comments)&lt;/strong>：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>广域网 WAN（Wide Area Network）&lt;/strong>：任务是通过长距离运送主机发送的数据。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>城域网 MAN（Metropolitan Area Network）&lt;/strong>：用来将多个局域网进行互连。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>局域网 LAN（Local Area Network）&lt;/strong>：学校或企业大多拥有多个互连的局域网。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/eb48d21b2e984a63a26250010d7adac4~tplv-k3u1fbpfcp-zoom-1.png" alt="MAN &amp;amp; WMAN | Red de área metropolitana, Redes informaticas, Par trenzado" />&lt;/p></description></item><item><title>32条总结教你提升职场经验</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/work/32-tips-improving-career/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/work/32-tips-improving-career/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：阿里开发者的一篇职场经验的分享。&lt;/p>
&lt;p>&lt;strong>原文地址：&lt;/strong> &lt;a href="https://mp.weixin.qq.com/s/6BkbGekSRTadm9j7XUL13g">https://mp.weixin.qq.com/s/6BkbGekSRTadm9j7XUL13g&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="成长的捷径">
 成长的捷径
 &lt;a class="anchor" href="#%e6%88%90%e9%95%bf%e7%9a%84%e6%8d%b7%e5%be%84">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>入职伊始谦逊的态度是好的，但不要把“我是新人”作为心理安全线；&lt;/li>
&lt;li>写一篇技术博客大概需要两周左右，但可能是最快的成长方式；&lt;/li>
&lt;li>一定要读两本书：金字塔原理、高效能人士的七个习惯（这本书名字像成功学，实际讲的是如何塑造性格）；&lt;/li>
&lt;li>多问是什么、为什么，追本溯源把问题解决掉，试图绕过的问题永远会在下个路口等着你；&lt;/li>
&lt;li>不要沉迷于忙碌带来的虚假安全感中，目标的确定和追逐才是最真实的安全；&lt;/li>
&lt;li>不用过于计较一时的得失，在公平的环境中，吃亏是福不是鸡汤；&lt;/li>
&lt;li>思维和技能不要受限于前端、后端、测试等角色，把自己定位成业务域问题的终结者；&lt;/li>
&lt;li>好奇和热爱是成长最大的捷径，长期主义者会认同自己的工作价值，甚至要高于组织当下给的认同（KPI）。&lt;/li>
&lt;/ul>
&lt;h2 id="功夫在日常">
 功夫在日常
 &lt;a class="anchor" href="#%e5%8a%9f%e5%a4%ab%e5%9c%a8%e6%97%a5%e5%b8%b8">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>每行代码要代表自己当下的最高水平，你觉得无所谓的小细节，有可能就是在晋升场上伤害你的暗箭；&lt;/li>
&lt;li>双周报不是工作日志流水账，不要被时间推着走，最起码要知道下次双周报里会有什么（小目标驱动）；&lt;/li>
&lt;li>觉得日常都是琐碎工作、不技术、给师兄打杂等，可以尝试对手头事情做一下分类，想象成每个分类都是个小格子，这些格子连起来的终点就是自己的目标，这样每天不再是机械的做需求，而是有规划的填格子、为目标努力，甚至会给自己加需求，因为自己看清楚了要去哪里；&lt;/li>
&lt;li>日常的言行举止是能力的显微镜，大部分人可能意识不到，自己的强大和虚弱是那么的明显，不要无谓的试图掩盖，更不存在蒙混过关。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>最后一条大概意思就是有时候我们会在意自己在聚光灯下（述职、晋升、周报、汇报等）的表现，以为大家会根据这个评价自己。实际上日常是怎么完成业务需求、帮助身边同学、创造价值的，才是大家评价自己的依据，而且每个人是什么样的特质，合作过三次的伙伴就可以精准评价，在聚光灯下的表演只能骗自己。&lt;/p>
&lt;/blockquote>
&lt;h2 id="学会被管理">
 学会被管理
 &lt;a class="anchor" href="#%e5%ad%a6%e4%bc%9a%e8%a2%ab%e7%ae%a1%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>上级、主管是泛指，开发对口的 PD 主管等也在范围内。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>不要传播负面情绪，不要总是抱怨；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对上级不卑不亢更容易获得尊重，但不要当众反驳对方观点，分歧私下沟通；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>好好做向上管理，尤其是对齐预期，沟通绩效出现 Surprise 双方其实都有责任，但倒霉的是自己；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>尽量站在主管角度想问题：&lt;/p>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>这样能理解很多过去感觉匪夷所思的决策；&lt;/li>
&lt;li>不要在意谁执行、功劳是谁的等，为团队分忧赢得主管信任的重要性远远高于这些；&lt;/li>
&lt;li>不要把这个原则理解为唯上，这种最让人不齿。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="思维转换">
 思维转换
 &lt;a class="anchor" href="#%e6%80%9d%e7%bb%b4%e8%bd%ac%e6%8d%a2">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>定义问题是个高阶能力，尽早形成 发现问题-&amp;gt;定义问题-&amp;gt;解决问题-&amp;gt;消灭问题 的思维闭环；&lt;/li>
&lt;li>定事情价值导向，做事情结果导向，讲事情问题导向；&lt;/li>
&lt;li>讲不清楚，大概率不是因为自己是实干型，而是没想清楚，在晋升场更加明显；&lt;/li>
&lt;li>当一个人擅长解决某一场景的问题的时候，时间越久也许越离不开这个场景（被人贴上一个标签很难，撕掉一个标签更难）。&lt;/li>
&lt;/ul>
&lt;h2 id="要栓住情绪">
 要栓住情绪
 &lt;a class="anchor" href="#%e8%a6%81%e6%a0%93%e4%bd%8f%e6%83%85%e7%bb%aa">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>学会控制情绪，没人会认真听一个愤怒的人在说什么；&lt;/li>
&lt;li>再委屈、再愤怒也要保持理智，不要让自己成为需要被哄着的那种人；&lt;/li>
&lt;li>足够自信的人才会坦率的承认自己的问题，很多时候我们被激怒了，只是因为对方指出了自己藏在深处的自卑；&lt;/li>
&lt;li>伤害我们最深的既不是别人的所作所为，也不是自己犯的错误，而是我们对错误的回应。&lt;/li>
&lt;/ul>
&lt;h2 id="成为-leader">
 成为 Leader
 &lt;a class="anchor" href="#%e6%88%90%e4%b8%ba-leader">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>Manager 有下属，Leader 有追随者，管理者不需要很多，但人人都可以是 Leader。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>让你信服、愿意追随的人不是职务上的 Manager，而是在帮助自己的那个人，自己想服众的话道理一样；&lt;/li>
&lt;li>不要轻易对人做负面评价，片面认知下的评价可能不准确，不经意的传播更是会给对方带来极大的困扰；&lt;/li>
&lt;li>Leader 如果不认同公司的使命、愿景、价值观，会过的特别痛苦；&lt;/li>
&lt;li>困难时候不要否定自己的队友，多给及时、正向的反馈；&lt;/li>
&lt;li>船长最重要的事情不是造船，而是激发水手对大海的向往；&lt;/li>
&lt;li>Leader 的天然职责是让团队活下去，唯一的途径是实现上级、老板、公司经营者的目标，越是艰难的时候越明显；&lt;/li>
&lt;li>Leader 的重要职责是识别团队需要被做的事情，并坚定信念，使众人行，越是艰难的时候越要坚定；&lt;/li>
&lt;li>Leader 应该让自己遇到的每个人都感觉自己很重要、被需要。&lt;/li>
&lt;/ul></description></item><item><title>3种常用的缓存读写策略详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/3-commonly-used-cache-read-and-write-strategies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/3-commonly-used-cache-read-and-write-strategies/</guid><description>&lt;p>看到很多小伙伴简历上写了“&lt;strong>熟练使用缓存&lt;/strong>”，但是被我问到“&lt;strong>缓存常用的 3 种读写策略&lt;/strong>”的时候却一脸懵逼。&lt;/p>
&lt;p>在我看来，造成这个问题的原因是我们在学习 Redis 的时候，可能只是简单写了一些 Demo，并没有去关注缓存的读写策略，或者说压根不知道这回事。&lt;/p>
&lt;p>但是，搞懂 3 种常见的缓存读写策略对于实际工作中使用缓存以及面试中被问到缓存都是非常有帮助的！&lt;/p>
&lt;p>&lt;strong>下面介绍到的三种模式各有优劣，不存在最佳模式，根据具体的业务场景选择适合自己的缓存读写模式。&lt;/strong>&lt;/p>
&lt;h3 id="cache-aside-pattern旁路缓存模式">
 Cache Aside Pattern（旁路缓存模式）
 &lt;a class="anchor" href="#cache-aside-pattern%e6%97%81%e8%b7%af%e7%bc%93%e5%ad%98%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。&lt;/strong>&lt;/p>
&lt;p>Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。&lt;/p>
&lt;p>下面我们来看一下这个策略模式下的缓存读写步骤。&lt;/p>
&lt;p>&lt;strong>写&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>先更新 db&lt;/li>
&lt;li>然后直接删除 cache 。&lt;/li>
&lt;/ul>
&lt;p>简单画了一张图帮助大家理解写的步骤。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/database/redis/cache-aside-write.png" alt="" />&lt;/p>
&lt;p>&lt;strong>读&lt;/strong> :&lt;/p>
&lt;ul>
&lt;li>从 cache 中读取数据，读取到就直接返回&lt;/li>
&lt;li>cache 中读取不到的话，就从 db 中读取数据返回&lt;/li>
&lt;li>再把数据放到 cache 中。&lt;/li>
&lt;/ul>
&lt;p>简单画了一张图帮助大家理解读的步骤。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/database/redis/cache-aside-read.png" alt="" />&lt;/p>
&lt;p>你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。&lt;/p>
&lt;p>比如说面试官很可能会追问：“&lt;strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？&lt;/strong>”&lt;/p>
&lt;p>&lt;strong>答案：&lt;/strong> 那肯定是不行的！因为这样可能会造成 &lt;strong>数据库（db）和缓存（Cache）数据不一致&lt;/strong>的问题。&lt;/p>
&lt;p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。&lt;/p></description></item><item><title>API网关基础知识总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/api-gateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/api-gateway/</guid><description>&lt;h2 id="什么是网关">
 什么是网关？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%bd%91%e5%85%b3">#&lt;/a>
&lt;/h2>
&lt;p>微服务背景下，一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway-overview.png" alt="网关示意图" />&lt;/p>
&lt;p>一般情况下，网关可以为我们提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、降级熔断、日志、监控、参数校验、协议转换等功能。&lt;/p>
&lt;p>上面介绍了这么多功能，实际上，网关主要做了两件事情：&lt;strong>请求转发&lt;/strong> + &lt;strong>请求过滤&lt;/strong>。&lt;/p>
&lt;p>由于引入网关之后，会多一步网络转发，因此性能会有一点影响（几乎可以忽略不计，尤其是内网访问的情况下）。 另外，我们需要保障网关服务的高可用，避免单点风险。&lt;/p>
&lt;p>如下图所示，网关服务外层通过 Nginx（其他负载均衡设备/软件也行） 进⾏负载转发以达到⾼可⽤。Nginx 在部署的时候，尽量也要考虑高可用，避免单点风险。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/load-balancing/server-load-balancing.png" alt="基于 Nginx 的服务端负载均衡" />&lt;/p>
&lt;h2 id="网关能提供哪些功能">
 网关能提供哪些功能？
 &lt;a class="anchor" href="#%e7%bd%91%e5%85%b3%e8%83%bd%e6%8f%90%e4%be%9b%e5%93%aa%e4%ba%9b%e5%8a%9f%e8%83%bd">#&lt;/a>
&lt;/h2>
&lt;p>绝大部分网关可以提供下面这些功能（有一些功能需要借助其他框架或者中间件）：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>请求转发&lt;/strong>：将请求转发到目标微服务。&lt;/li>
&lt;li>&lt;strong>负载均衡&lt;/strong>：根据各个微服务实例的负载情况或者具体的负载均衡策略配置对请求实现动态的负载均衡。&lt;/li>
&lt;li>&lt;strong>安全认证&lt;/strong>：对用户请求进行身份验证并仅允许可信客户端访问 API，并且还能够使用类似 RBAC 等方式来授权。&lt;/li>
&lt;li>&lt;strong>参数校验&lt;/strong>：支持参数映射与校验逻辑。&lt;/li>
&lt;li>&lt;strong>日志记录&lt;/strong>：记录所有请求的行为日志供后续使用。&lt;/li>
&lt;li>&lt;strong>监控告警&lt;/strong>：从业务指标、机器指标、JVM 指标等方面进行监控并提供配套的告警机制。&lt;/li>
&lt;li>&lt;strong>流量控制&lt;/strong>：对请求的流量进行控制，也就是限制某一时刻内的请求数。&lt;/li>
&lt;li>&lt;strong>熔断降级&lt;/strong>：实时监控请求的统计信息，达到配置的失败阈值后，自动熔断，返回默认值。&lt;/li>
&lt;li>&lt;strong>响应缓存&lt;/strong>：当用户请求获取的是一些静态的或更新不频繁的数据时，一段时间内多次请求获取到的数据很可能是一样的。对于这种情况可以将响应缓存起来。这样用户请求可以直接在网关层得到响应数据，无需再去访问业务服务，减轻业务服务的负担。&lt;/li>
&lt;li>&lt;strong>响应聚合&lt;/strong>：某些情况下用户请求要获取的响应内容可能会来自于多个业务服务。网关作为业务服务的调用方，可以把多个服务的响应整合起来，再一并返回给用户。&lt;/li>
&lt;li>&lt;strong>灰度发布&lt;/strong>：将请求动态分流到不同的服务版本（最基本的一种灰度发布）。&lt;/li>
&lt;li>&lt;strong>异常处理&lt;/strong>：对于业务服务返回的异常响应，可以在网关层在返回给用户之前做转换处理。这样可以把一些业务侧返回的异常细节隐藏，转换成用户友好的错误提示返回。&lt;/li>
&lt;li>&lt;strong>API 文档：&lt;/strong> 如果计划将 API 暴露给组织以外的开发人员，那么必须考虑使用 API 文档，例如 Swagger 或 OpenAPI。&lt;/li>
&lt;li>&lt;strong>协议转换&lt;/strong>：通过协议转换整合后台基于 REST、AMQP、Dubbo 等不同风格和实现技术的微服务，面向 Web Mobile、开放平台等特定客户端提供统一服务。&lt;/li>
&lt;li>&lt;strong>证书管理&lt;/strong>：将 SSL 证书部署到 API 网关，由一个统一的入口管理接口，降低了证书更换时的复杂度。&lt;/li>
&lt;/ul>
&lt;p>下图来源于&lt;a href="https://mp.weixin.qq.com/s/iITqdIiHi3XGKq6u6FRVdg">百亿规模 API 网关服务 Shepherd 的设计与实现 - 美团技术团队 - 2021&lt;/a>这篇文章。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/distributed-system/api-gateway/up-35e102c633bbe8e0dea1e075ea3fee5dcfb.png" alt="" />&lt;/p></description></item><item><title>AQS 详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/aqs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/aqs/</guid><description>&lt;h2 id="aqs-介绍">
 AQS 介绍
 &lt;a class="anchor" href="#aqs-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>AQS 的全称为 &lt;code>AbstractQueuedSynchronizer&lt;/code> ，翻译过来的意思就是抽象队列同步器。这个类在 &lt;code>java.util.concurrent.locks&lt;/code> 包下面。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/AQS.png" alt="" />&lt;/p>
&lt;p>AQS 就是一个抽象类，主要用来构建锁和同步器。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AbstractQueuedSynchronizer&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> AbstractOwnableSynchronizer &lt;span style="color:#66d9ef">implements&lt;/span> java.&lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Serializable&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AQS 为构建锁和同步器提供了一些通用功能的实现。因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 &lt;code>ReentrantLock&lt;/code>，&lt;code>Semaphore&lt;/code>，其他的诸如 &lt;code>ReentrantReadWriteLock&lt;/code>，&lt;code>SynchronousQueue&lt;/code>等等皆是基于 AQS 的。&lt;/p>
&lt;h2 id="aqs-原理">
 AQS 原理
 &lt;a class="anchor" href="#aqs-%e5%8e%9f%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参考，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。&lt;/p>
&lt;h3 id="aqs-快速了解">
 AQS 快速了解
 &lt;a class="anchor" href="#aqs-%e5%bf%ab%e9%80%9f%e4%ba%86%e8%a7%a3">#&lt;/a>
&lt;/h3>
&lt;p>在真正讲解 AQS 源码之前，需要对 AQS 有一个整体层面的认识。这里会先通过几个问题，从整体层面上认识 AQS，了解 AQS 在整个 Java 并发中所位于的层面，之后在学习 AQS 源码的过程中，才能更加了解同步器和 AQS 之间的关系。&lt;/p>
&lt;h4 id="aqs-的作用是什么">
 AQS 的作用是什么？
 &lt;a class="anchor" href="#aqs-%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h4>
&lt;p>AQS 解决了开发者在实现同步器时的复杂性问题。它提供了一个通用框架，用于实现各种同步器，例如 &lt;strong>可重入锁&lt;/strong>（&lt;code>ReentrantLock&lt;/code>）、&lt;strong>信号量&lt;/strong>（&lt;code>Semaphore&lt;/code>）和 &lt;strong>倒计时器&lt;/strong>（&lt;code>CountDownLatch&lt;/code>）。通过封装底层的线程同步机制，AQS 将复杂的线程管理逻辑隐藏起来，使开发者只需专注于具体的同步逻辑。&lt;/p>
&lt;p>简单来说，AQS 是一个抽象类，为同步器提供了通用的 &lt;strong>执行框架&lt;/strong>。它定义了 &lt;strong>资源获取和释放的通用流程&lt;/strong>，而具体的资源获取逻辑则由具体同步器通过重写模板方法来实现。 因此，可以将 AQS 看作是同步器的 &lt;strong>基础“底座”&lt;/strong>，而同步器则是基于 AQS 实现的 &lt;strong>具体“应用”&lt;/strong>。&lt;/p></description></item><item><title>ARP 协议详解(网络层)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/arp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/arp/</guid><description>&lt;p>每当我们学习一个新的网络协议的时候，都要把他结合到 OSI 七层模型中，或者是 TCP/IP 协议栈中来学习，一是要学习该协议在整个网络协议栈中的位置，二是要学习该协议解决了什么问题，地位如何？三是要学习该协议的工作原理，以及一些更深入的细节。&lt;/p>
&lt;p>&lt;strong>ARP 协议&lt;/strong>，可以说是在协议栈中属于一个&lt;strong>偏底层的、非常重要的、又非常简单的&lt;/strong>通信协议。&lt;/p>
&lt;p>开始阅读这篇文章之前，你可以先看看下面几个问题：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>ARP 协议在协议栈中的位置？&lt;/strong> ARP 协议在协议栈中的位置非常重要，在理解了它的工作原理之后，也很难说它到底是网络层协议，还是链路层协议，因为它恰恰串联起了网络层和链路层。国外的大部分教程通常将 ARP 协议放在网络层。&lt;/li>
&lt;li>&lt;strong>ARP 协议解决了什么问题，地位如何？&lt;/strong> ARP 协议，全称 &lt;strong>地址解析协议（Address Resolution Protocol）&lt;/strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。&lt;/li>
&lt;li>&lt;strong>ARP 工作原理？&lt;/strong> 只希望大家记住几个关键词：&lt;strong>ARP 表、广播问询、单播响应&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;h2 id="mac-地址">
 MAC 地址
 &lt;a class="anchor" href="#mac-%e5%9c%b0%e5%9d%80">#&lt;/a>
&lt;/h2>
&lt;p>在介绍 ARP 协议之前，有必要介绍一下 MAC 地址。&lt;/p>
&lt;p>MAC 地址的全称是 &lt;strong>媒体访问控制地址（Media Access Control Address）&lt;/strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。&lt;/p>
&lt;p>&lt;img src="./images/arp/2008410143049281.png" alt="路由器的背面就会注明 MAC 位址" />&lt;/p>
&lt;p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。&lt;/p></description></item><item><title>ArrayBlockingQueue 源码分析</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/arrayblockingqueue-source-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/arrayblockingqueue-source-code/</guid><description>&lt;h2 id="阻塞队列简介">
 阻塞队列简介
 &lt;a class="anchor" href="#%e9%98%bb%e5%a1%9e%e9%98%9f%e5%88%97%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="阻塞队列的历史">
 阻塞队列的历史
 &lt;a class="anchor" href="#%e9%98%bb%e5%a1%9e%e9%98%9f%e5%88%97%e7%9a%84%e5%8e%86%e5%8f%b2">#&lt;/a>
&lt;/h3>
&lt;p>Java 阻塞队列的历史可以追溯到 JDK1.5 版本，当时 Java 平台增加了 &lt;code>java.util.concurrent&lt;/code>，即我们常说的 JUC 包，其中包含了各种并发流程控制工具、并发容器、原子类等。这其中自然也包含了我们这篇文章所讨论的阻塞队列。&lt;/p>
&lt;p>为了解决高并发场景下多线程之间数据共享的问题，JDK1.5 版本中出现了 &lt;code>ArrayBlockingQueue&lt;/code> 和 &lt;code>LinkedBlockingQueue&lt;/code>，它们是带有生产者-消费者模式实现的并发容器。其中，&lt;code>ArrayBlockingQueue&lt;/code> 是有界队列，即添加的元素达到上限之后，再次添加就会被阻塞或者抛出异常。而 &lt;code>LinkedBlockingQueue&lt;/code> 则由链表构成的队列，正是因为链表的特性，所以 &lt;code>LinkedBlockingQueue&lt;/code> 在添加元素上并不会向 &lt;code>ArrayBlockingQueue&lt;/code> 那样有着较多的约束，所以 &lt;code>LinkedBlockingQueue&lt;/code> 设置队列是否有界是可选的(注意这里的无界并不是指可以添加任务数量的元素，而是说队列的大小默认为 &lt;code>Integer.MAX_VALUE&lt;/code>，近乎于无限大)。&lt;/p>
&lt;p>随着 Java 的不断发展，JDK 后续的几个版本又对阻塞队列进行了不少的更新和完善:&lt;/p>
&lt;ol>
&lt;li>JDK1.6 版本:增加 &lt;code>SynchronousQueue&lt;/code>，一个不存储元素的阻塞队列。&lt;/li>
&lt;li>JDK1.7 版本:增加 &lt;code>TransferQueue&lt;/code>，一个支持更多操作的阻塞队列。&lt;/li>
&lt;li>JDK1.8 版本:增加 &lt;code>DelayQueue&lt;/code>，一个支持延迟获取元素的阻塞队列。&lt;/li>
&lt;/ol>
&lt;h3 id="阻塞队列的思想">
 阻塞队列的思想
 &lt;a class="anchor" href="#%e9%98%bb%e5%a1%9e%e9%98%9f%e5%88%97%e7%9a%84%e6%80%9d%e6%83%b3">#&lt;/a>
&lt;/h3>
&lt;p>阻塞队列就是典型的生产者-消费者模型，它可以做到以下几点:&lt;/p>
&lt;ol>
&lt;li>当阻塞队列数据为空时，所有的消费者线程都会被阻塞，等待队列非空。&lt;/li>
&lt;li>当生产者往队列里填充数据后，队列就会通知消费者队列非空，消费者此时就可以进来消费。&lt;/li>
&lt;li>当阻塞队列因为消费者消费过慢或者生产者存放元素过快导致队列填满时无法容纳新元素时，生产者就会被阻塞，等待队列非满时继续存放元素。&lt;/li>
&lt;li>当消费者从队列中消费一个元素之后，队列就会通知生产者队列非满，生产者可以继续填充数据了。&lt;/li>
&lt;/ol>
&lt;p>总结一下：阻塞队列就说基于非空和非满两个条件实现生产者和消费者之间的交互，尽管这些交互流程和等待通知的机制实现非常复杂，好在 Doug Lea 的操刀之下已将阻塞队列的细节屏蔽，我们只需调用 &lt;code>put&lt;/code>、&lt;code>take&lt;/code>、&lt;code>offer&lt;/code>、&lt;code>poll&lt;/code> 等 API 即可实现多线程之间的生产和消费。&lt;/p>
&lt;p>这也使得阻塞队列在多线程开发中有着广泛的运用，最常见的例子无非是我们的线程池,从源码中我们就能看出当核心线程无法及时处理任务时，这些任务都会扔到 &lt;code>workQueue&lt;/code> 中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">ThreadPoolExecutor&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> corePoolSize,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> maximumPoolSize,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> keepAliveTime,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TimeUnit unit,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BlockingQueue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Runnable&lt;span style="color:#f92672">&amp;gt;&lt;/span> workQueue,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadFactory threadFactory,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RejectedExecutionHandler handler) {&lt;span style="color:#75715e">// ...}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="arrayblockingqueue-常见方法及测试">
 ArrayBlockingQueue 常见方法及测试
 &lt;a class="anchor" href="#arrayblockingqueue-%e5%b8%b8%e8%a7%81%e6%96%b9%e6%b3%95%e5%8f%8a%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h2>
&lt;p>简单了解了阻塞队列的历史之后，我们就开始重点讨论本篇文章所要介绍的并发容器——&lt;code>ArrayBlockingQueue&lt;/code>。为了后续更加深入的了解 &lt;code>ArrayBlockingQueue&lt;/code>，我们不妨基于下面几个实例了解以下 &lt;code>ArrayBlockingQueue&lt;/code> 的使用。&lt;/p></description></item><item><title>ArrayList 源码分析</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/arraylist-source-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/arraylist-source-code/</guid><description>&lt;h2 id="arraylist-简介">
 ArrayList 简介
 &lt;a class="anchor" href="#arraylist-%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>ArrayList&lt;/code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用&lt;code>ensureCapacity&lt;/code>操作来增加 &lt;code>ArrayList&lt;/code> 实例的容量。这可以减少递增式再分配的数量。&lt;/p>
&lt;p>&lt;code>ArrayList&lt;/code> 继承于 &lt;code>AbstractList&lt;/code> ，实现了 &lt;code>List&lt;/code>, &lt;code>RandomAccess&lt;/code>, &lt;code>Cloneable&lt;/code>, &lt;code>java.io.Serializable&lt;/code> 这些接口。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ArrayList&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> AbstractList&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">implements&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span>, RandomAccess, Cloneable, java.&lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Serializable&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>List&lt;/code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。&lt;/li>
&lt;li>&lt;code>RandomAccess&lt;/code> ：这是一个标志接口，表明实现这个接口的 &lt;code>List&lt;/code> 集合是支持 &lt;strong>快速随机访问&lt;/strong> 的。在 &lt;code>ArrayList&lt;/code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。&lt;/li>
&lt;li>&lt;code>Cloneable&lt;/code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。&lt;/li>
&lt;li>&lt;code>Serializable&lt;/code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/collection/arraylist-class-diagram.png" alt="ArrayList 类图" />&lt;/p>
&lt;h3 id="arraylist-和-vector-的区别了解即可">
 ArrayList 和 Vector 的区别?（了解即可）
 &lt;a class="anchor" href="#arraylist-%e5%92%8c-vector-%e7%9a%84%e5%8c%ba%e5%88%ab%e4%ba%86%e8%a7%a3%e5%8d%b3%e5%8f%af">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;code>ArrayList&lt;/code> 是 &lt;code>List&lt;/code> 的主要实现类，底层使用 &lt;code>Object[]&lt;/code>存储，适用于频繁的查找工作，线程不安全 。&lt;/li>
&lt;li>&lt;code>Vector&lt;/code> 是 &lt;code>List&lt;/code> 的古老实现类，底层使用&lt;code>Object[]&lt;/code> 存储，线程安全。&lt;/li>
&lt;/ul>
&lt;h3 id="arraylist-可以添加-null-值吗">
 ArrayList 可以添加 null 值吗？
 &lt;a class="anchor" href="#arraylist-%e5%8f%af%e4%bb%a5%e6%b7%bb%e5%8a%a0-null-%e5%80%bc%e5%90%97">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>ArrayList&lt;/code> 中可以存储任何类型的对象，包括 &lt;code>null&lt;/code> 值。不过，不建议向&lt;code>ArrayList&lt;/code> 中添加 &lt;code>null&lt;/code> 值， &lt;code>null&lt;/code> 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。&lt;/p></description></item><item><title>Async 注解原理分析</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/async1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/async1/</guid><description>&lt;p>&lt;code>@Async&lt;/code> 注解由 Spring 框架提供，被该注解标注的类或方法会在 &lt;strong>异步线程&lt;/strong> 中执行。这意味着当方法被调用时，调用者将不会等待该方法执行完成，而是可以继续执行后续的代码。&lt;/p>
&lt;p>&lt;code>@Async&lt;/code> 注解的使用非常简单，需要两个步骤：&lt;/p>
&lt;ol>
&lt;li>在启动类上添加注解 &lt;code>@EnableAsync&lt;/code> ，开启异步任务。&lt;/li>
&lt;li>在需要异步执行的方法或类上添加注解 &lt;code>@Async&lt;/code> 。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SpringBootApplication&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 开启异步任务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@EnableAsync&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">YourApplication&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SpringApplication.&lt;span style="color:#a6e22e">run&lt;/span>(YourApplication.&lt;span style="color:#a6e22e">class&lt;/span>, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 异步服务类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 推荐使用自定义线程池，这里只是演示基本用法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Async&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CompletableFuture&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">doSomethingAsync&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 这里会有一些业务耗时操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用 CompletableFuture 可以更方便地处理异步任务的结果，避免阻塞主线程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> CompletableFuture.&lt;span style="color:#a6e22e">completedFuture&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Async Task Completed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，我们一起来看看 &lt;code>@Async&lt;/code> 的底层原理。&lt;/p>
&lt;h2 id="async-原理分析">
 @Async 原理分析
 &lt;a class="anchor" href="#async-%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>@Async&lt;/code> 可以异步执行任务，本质上是使用 &lt;strong>动态代理&lt;/strong> 来实现的。通过 Spring 中的后置处理器 &lt;code>BeanPostProcessor&lt;/code> 为使用 &lt;code>@Async&lt;/code> 注解的类创建动态代理，之后 &lt;code>@Async&lt;/code> 注解方法的调用会被动态代理拦截，在拦截器中将方法的执行封装为异步任务提交给线程池处理。&lt;/p></description></item><item><title>Async 注解原理分析</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/Async/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/Async/</guid><description>&lt;p>&lt;code>@Async&lt;/code> 注解由 Spring 框架提供，被该注解标注的类或方法会在 &lt;strong>异步线程&lt;/strong> 中执行。这意味着当方法被调用时，调用者将不会等待该方法执行完成，而是可以继续执行后续的代码。&lt;/p>
&lt;p>&lt;code>@Async&lt;/code> 注解的使用非常简单，需要两个步骤：&lt;/p>
&lt;ol>
&lt;li>在启动类上添加注解 &lt;code>@EnableAsync&lt;/code> ，开启异步任务。&lt;/li>
&lt;li>在需要异步执行的方法或类上添加注解 &lt;code>@Async&lt;/code> 。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SpringBootApplication&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 开启异步任务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@EnableAsync&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">YourApplication&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SpringApplication.&lt;span style="color:#a6e22e">run&lt;/span>(YourApplication.&lt;span style="color:#a6e22e">class&lt;/span>, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 异步服务类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 推荐使用自定义线程池，这里只是演示基本用法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Async&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CompletableFuture&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">doSomethingAsync&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 这里会有一些业务耗时操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用 CompletableFuture 可以更方便地处理异步任务的结果，避免阻塞主线程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> CompletableFuture.&lt;span style="color:#a6e22e">completedFuture&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Async Task Completed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来，我们一起来看看 &lt;code>@Async&lt;/code> 的底层原理。&lt;/p>
&lt;h2 id="async-原理分析">
 @Async 原理分析
 &lt;a class="anchor" href="#async-%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>@Async&lt;/code> 可以异步执行任务，本质上是使用 &lt;strong>动态代理&lt;/strong> 来实现的。通过 Spring 中的后置处理器 &lt;code>BeanPostProcessor&lt;/code> 为使用 &lt;code>@Async&lt;/code> 注解的类创建动态代理，之后 &lt;code>@Async&lt;/code> 注解方法的调用会被动态代理拦截，在拦截器中将方法的执行封装为异步任务提交给线程池处理。&lt;/p></description></item><item><title>Atomic 原子类总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/atomic-classes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/atomic-classes/</guid><description>&lt;h2 id="atomic-原子类介绍">
 Atomic 原子类介绍
 &lt;a class="anchor" href="#atomic-%e5%8e%9f%e5%ad%90%e7%b1%bb%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>Atomic&lt;/code> 翻译成中文是“原子”的意思。在化学上，原子是构成物质的最小单位，在化学反应中不可分割。在编程中，&lt;code>Atomic&lt;/code> 指的是一个操作具有原子性，即该操作不可分割、不可中断。即使在多个线程同时执行时，该操作要么全部执行完成，要么不执行，不会被其他线程看到部分完成的状态。&lt;/p>
&lt;p>原子类简单来说就是具有原子性操作特征的类。&lt;/p>
&lt;p>&lt;code>java.util.concurrent.atomic&lt;/code> 包中的 &lt;code>Atomic&lt;/code> 原子类提供了一种线程安全的方式来操作单个变量。&lt;/p>
&lt;p>&lt;code>Atomic&lt;/code> 类依赖于 CAS（Compare-And-Swap，比较并交换）乐观锁来保证其方法的原子性，而不需要使用传统的锁机制（如 &lt;code>synchronized&lt;/code> 块或 &lt;code>ReentrantLock&lt;/code>）。&lt;/p>
&lt;p>这篇文章我们只介绍 Atomic 原子类的概念，具体实现原理可以阅读笔者写的这篇文章：&lt;a href="./cas.md">CAS 详解&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%A6%82%E8%A7%88.png" alt="JUC原子类概览" />&lt;/p>
&lt;p>根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类：&lt;/p>
&lt;p>&lt;strong>1、基本类型&lt;/strong>&lt;/p>
&lt;p>使用原子的方式更新基本类型&lt;/p>
&lt;ul>
&lt;li>&lt;code>AtomicInteger&lt;/code>：整型原子类&lt;/li>
&lt;li>&lt;code>AtomicLong&lt;/code>：长整型原子类&lt;/li>
&lt;li>&lt;code>AtomicBoolean&lt;/code>：布尔型原子类&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2、数组类型&lt;/strong>&lt;/p>
&lt;p>使用原子的方式更新数组里的某个元素&lt;/p>
&lt;ul>
&lt;li>&lt;code>AtomicIntegerArray&lt;/code>：整型数组原子类&lt;/li>
&lt;li>&lt;code>AtomicLongArray&lt;/code>：长整型数组原子类&lt;/li>
&lt;li>&lt;code>AtomicReferenceArray&lt;/code>：引用类型数组原子类&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>3、引用类型&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>AtomicReference&lt;/code>：引用类型原子类&lt;/li>
&lt;li>&lt;code>AtomicMarkableReference&lt;/code>：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，&lt;del>也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题&lt;/del>。&lt;/li>
&lt;li>&lt;code>AtomicStampedReference&lt;/code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>🐛 修正（参见：&lt;a href="https://github.com/Snailclimb/JavaGuide/issues/626">issue#626&lt;/a>）&lt;/strong> : &lt;code>AtomicMarkableReference&lt;/code> 不能解决 ABA 问题。&lt;/p>
&lt;p>&lt;strong>4、对象的属性修改类型&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>AtomicIntegerFieldUpdater&lt;/code>:原子更新整型字段的更新器&lt;/li>
&lt;li>&lt;code>AtomicLongFieldUpdater&lt;/code>：原子更新长整型字段的更新器&lt;/li>
&lt;li>&lt;code>AtomicReferenceFieldUpdater&lt;/code>：原子更新引用类型里的字段&lt;/li>
&lt;/ul>
&lt;h2 id="基本类型原子类">
 基本类型原子类
 &lt;a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e5%8e%9f%e5%ad%90%e7%b1%bb">#&lt;/a>
&lt;/h2>
&lt;p>使用原子的方式更新基本类型&lt;/p>
&lt;ul>
&lt;li>&lt;code>AtomicInteger&lt;/code>：整型原子类&lt;/li>
&lt;li>&lt;code>AtomicLong&lt;/code>：长整型原子类&lt;/li>
&lt;li>&lt;code>AtomicBoolean&lt;/code>：布尔型原子类&lt;/li>
&lt;/ul>
&lt;p>上面三个类提供的方法几乎相同，所以我们这里以 &lt;code>AtomicInteger&lt;/code> 为例子来介绍。&lt;/p></description></item><item><title>BigDecimal 详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/bigdecimal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/bigdecimal/</guid><description>&lt;p>《阿里巴巴 Java 开发手册》中提到：“为了避免精度丢失，可以使用 &lt;code>BigDecimal&lt;/code> 来进行浮点数的运算”。&lt;/p>
&lt;p>浮点数的运算竟然还会有精度丢失的风险吗？确实会！&lt;/p>
&lt;p>示例代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> 2.&lt;span style="color:#a6e22e">0f&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1.&lt;span style="color:#a6e22e">9f&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">float&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> 1.&lt;span style="color:#a6e22e">8f&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1.&lt;span style="color:#a6e22e">7f&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a);&lt;span style="color:#75715e">// 0.100000024&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(b);&lt;span style="color:#75715e">// 0.099999905&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(a &lt;span style="color:#f92672">==&lt;/span> b);&lt;span style="color:#75715e">// false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>为什么浮点数 &lt;code>float&lt;/code> 或 &lt;code>double&lt;/code> 运算的时候会有精度丢失的风险呢？&lt;/strong>&lt;/p>
&lt;p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。&lt;/p>
&lt;p>就比如说十进制下的 0.2 就没办法精确转换成二进制小数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0.&lt;span style="color:#a6e22e">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> 2 &lt;span style="color:#f92672">=&lt;/span> 0.&lt;span style="color:#a6e22e">4&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0.&lt;span style="color:#a6e22e">4&lt;/span> &lt;span style="color:#f92672">*&lt;/span> 2 &lt;span style="color:#f92672">=&lt;/span> 0.&lt;span style="color:#a6e22e">8&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0.&lt;span style="color:#a6e22e">8&lt;/span> &lt;span style="color:#f92672">*&lt;/span> 2 &lt;span style="color:#f92672">=&lt;/span> 1.&lt;span style="color:#a6e22e">6&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0.&lt;span style="color:#a6e22e">6&lt;/span> &lt;span style="color:#f92672">*&lt;/span> 2 &lt;span style="color:#f92672">=&lt;/span> 1.&lt;span style="color:#a6e22e">2&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>0.&lt;span style="color:#a6e22e">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> 2 &lt;span style="color:#f92672">=&lt;/span> 0.&lt;span style="color:#a6e22e">4&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 0&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>发生循环&lt;span style="color:#960050;background-color:#1e0010">）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>关于浮点数的更多内容，建议看一下&lt;a href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">计算机系统基础（四）浮点数&lt;/a>这篇文章。&lt;/p>
&lt;h2 id="bigdecimal-介绍">
 BigDecimal 介绍
 &lt;a class="anchor" href="#bigdecimal-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>BigDecimal&lt;/code> 可以实现对浮点数的运算，不会造成精度丢失。&lt;/p>
&lt;p>通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 &lt;code>BigDecimal&lt;/code> 来做的。&lt;/p>
&lt;p>《阿里巴巴 Java 开发手册》中提到：&lt;strong>浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断。&lt;/strong>&lt;/p></description></item><item><title>CAP &amp; BASE理论详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/protocol/cap-and-base-theorem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/protocol/cap-and-base-theorem/</guid><description>&lt;p>经历过技术面试的小伙伴想必对 CAP &amp;amp; BASE 这个两个理论已经再熟悉不过了！&lt;/p>
&lt;p>我当年参加面试的时候，不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个分布式相关的理论。一是因为这两个分布式基础理论是学习分布式知识的必备前置基础，二是因为很多面试官自己比较熟悉这两个理论（方便提问）。&lt;/p>
&lt;p>我们非常有必要将这两个理论搞懂，并且能够用自己的理解给别人讲出来。&lt;/p>
&lt;h2 id="cap-理论">
 CAP 理论
 &lt;a class="anchor" href="#cap-%e7%90%86%e8%ae%ba">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86">CAP 理论/定理&lt;/a>起源于 2000 年，由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 &lt;strong>布鲁尔定理（Brewer’s theorem）&lt;/strong>&lt;/p>
&lt;p>2 年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 发表了布鲁尔猜想的证明，CAP 理论正式成为分布式领域的定理。&lt;/p>
&lt;h3 id="简介">
 简介
 &lt;a class="anchor" href="#%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>CAP&lt;/strong> 也就是 &lt;strong>Consistency（一致性）&lt;/strong>、&lt;strong>Availability（可用性）&lt;/strong>、&lt;strong>Partition Tolerance（分区容错性）&lt;/strong> 这三个单词首字母组合。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/2020-11/cap.png" alt="" />&lt;/p>
&lt;p>CAP 理论的提出者布鲁尔在提出 CAP 猜想的时候，并没有详细定义 &lt;strong>Consistency&lt;/strong>、&lt;strong>Availability&lt;/strong>、&lt;strong>Partition Tolerance&lt;/strong> 三个单词的明确定义。&lt;/p>
&lt;p>因此，对于 CAP 的民间解读有很多，一般比较被大家推荐的是下面 👇 这种版本的解读。&lt;/p>
&lt;p>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>一致性（Consistency）&lt;/strong> : 所有节点访问同一份最新的数据副本&lt;/li>
&lt;li>&lt;strong>可用性（Availability）&lt;/strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。&lt;/li>
&lt;li>&lt;strong>分区容错性（Partition Tolerance）&lt;/strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>什么是网络分区？&lt;/strong>&lt;/p>
&lt;p>分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 &lt;strong>网络分区&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/2020-11/partition-tolerance.png" alt="partition-tolerance" />&lt;/p></description></item><item><title>CAS 详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/cas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/cas/</guid><description>&lt;p>乐观锁和悲观锁的介绍以及乐观锁常见实现方式可以阅读笔者写的这篇文章：&lt;a href="https://javaguide.cn/java/concurrent/optimistic-lock-and-pessimistic-lock.html">乐观锁和悲观锁详解&lt;/a>。&lt;/p>
&lt;p>这篇文章主要介绍 ：Java 中 CAS 的实现以及 CAS 存在的一些问题。&lt;/p>
&lt;h2 id="java-中-cas-是如何实现的">
 Java 中 CAS 是如何实现的？
 &lt;a class="anchor" href="#java-%e4%b8%ad-cas-%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%9a%84">#&lt;/a>
&lt;/h2>
&lt;p>在 Java 中，实现 CAS（Compare-And-Swap, 比较并交换）操作的一个关键类是&lt;code>Unsafe&lt;/code>。&lt;/p>
&lt;p>&lt;code>Unsafe&lt;/code>类位于&lt;code>sun.misc&lt;/code>包下，是一个提供低级别、不安全操作的类。由于其强大的功能和潜在的危险性，它通常用于 JVM 内部或一些需要极高性能和底层访问的库中，而不推荐普通开发者在应用程序中使用。关于 &lt;code>Unsafe&lt;/code>类的详细介绍，可以阅读这篇文章：📌&lt;a href="https://javaguide.cn/java/basis/unsafe.html">Java 魔法类 Unsafe 详解&lt;/a>。&lt;/p>
&lt;p>&lt;code>sun.misc&lt;/code>包下的&lt;code>Unsafe&lt;/code>类提供了&lt;code>compareAndSwapObject&lt;/code>、&lt;code>compareAndSwapInt&lt;/code>、&lt;code>compareAndSwapLong&lt;/code>方法来实现的对&lt;code>Object&lt;/code>、&lt;code>int&lt;/code>、&lt;code>long&lt;/code>类型的 CAS 操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 以原子方式更新对象字段的值。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param o 要操作的对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param offset 对象字段的内存偏移量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param expected 期望的旧值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param x 要设置的新值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @return 如果值被成功更新，则返回 true；否则返回 false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">compareAndSwapObject&lt;/span>(Object o, &lt;span style="color:#66d9ef">long&lt;/span> offset, Object expected, Object x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 以原子方式更新 int 类型的对象字段的值。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">compareAndSwapInt&lt;/span>(Object o, &lt;span style="color:#66d9ef">long&lt;/span> offset, &lt;span style="color:#66d9ef">int&lt;/span> expected, &lt;span style="color:#66d9ef">int&lt;/span> x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 以原子方式更新 long 类型的对象字段的值。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">compareAndSwapLong&lt;/span>(Object o, &lt;span style="color:#66d9ef">long&lt;/span> offset, &lt;span style="color:#66d9ef">long&lt;/span> expected, &lt;span style="color:#66d9ef">long&lt;/span> x);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Unsafe&lt;/code>类中的 CAS 方法是&lt;code>native&lt;/code>方法。&lt;code>native&lt;/code>关键字表明这些方法是用本地代码（通常是 C 或 C++）实现的，而不是用 Java 实现的。这些方法直接调用底层的硬件指令来实现原子操作。也就是说，Java 语言并没有直接用 Java 实现 CAS。&lt;/p></description></item><item><title>CDN工作原理详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/cdn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/cdn/</guid><description>&lt;h2 id="什么是-cdn-">
 什么是 CDN ？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-cdn-">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>CDN&lt;/strong> 全称是 Content Delivery Network/Content Distribution Network，翻译过的意思是 &lt;strong>内容分发网络&lt;/strong> 。&lt;/p>
&lt;p>我们可以将内容分发网络拆开来看：&lt;/p>
&lt;ul>
&lt;li>内容：指的是静态资源比如图片、视频、文档、JS、CSS、HTML。&lt;/li>
&lt;li>分发网络：指的是将这些静态资源分发到位于多个不同的地理位置机房中的服务器上，这样，就可以实现静态资源的就近访问比如北京的用户直接访问北京机房的数据。&lt;/li>
&lt;/ul>
&lt;p>所以，简单来说，&lt;strong>CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。&lt;/strong>&lt;/p>
&lt;p>类似于京东建立的庞大的仓储运输体系，京东物流在全国拥有非常多的仓库，仓储网络几乎覆盖全国所有区县。这样的话，用户下单的第一时间，商品就从距离用户最近的仓库，直接发往对应的配送站，再由京东小哥送到你家。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/cdn/jingdong-wuliu-cangpei.png" alt="京东仓配系统" />&lt;/p>
&lt;p>你可以将 CDN 看作是服务上一层的特殊缓存服务，分布在全国各地，主要用来处理静态资源的请求。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cdn-101.png" alt="CDN 简易示意图" />&lt;/p>
&lt;p>我们经常拿全站加速和内容分发网络做对比，不要把两者搞混了！全站加速（不同云服务商叫法不同，腾讯云叫 ECDN、阿里云叫 DCDN）既可以加速静态资源又可以加速动态资源，内容分发网络（CDN）主要针对的是 &lt;strong>静态资源&lt;/strong> 。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/cdn/cdn-aliyun-dcdn.png" alt="阿里云文档：https://help.aliyun.com/document_detail/64836.html" />&lt;/p>
&lt;p>绝大部分公司都会在项目开发中使用 CDN 服务，但很少会有自建 CDN 服务的公司。基于成本、稳定性和易用性考虑，建议直接选择专业的云厂商（比如阿里云、腾讯云、华为云、青云）或者 CDN 厂商（比如网宿、蓝汛）提供的开箱即用的 CDN 服务。&lt;/p>
&lt;p>很多朋友可能要问了：&lt;strong>既然是就近访问，为什么不直接将服务部署在多个不同的地方呢？&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>成本太高，需要部署多份相同的服务。&lt;/li>
&lt;li>静态资源通常占用空间比较大且经常会被访问到，如果直接使用服务器或者缓存来处理静态资源请求的话，对系统资源消耗非常大，可能会影响到系统其他服务的正常运行。&lt;/li>
&lt;/ul>
&lt;p>同一个服务在在多个不同的地方部署多份（比如同城灾备、异地灾备、同城多活、异地多活）是为了实现系统的高可用而不是就近访问。&lt;/p>
&lt;h2 id="cdn-工作原理是什么">
 CDN 工作原理是什么？
 &lt;a class="anchor" href="#cdn-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>搞懂下面 3 个问题也就搞懂了 CDN 的工作原理：&lt;/p>
&lt;ol>
&lt;li>静态资源是如何被缓存到 CDN 节点中的？&lt;/li>
&lt;li>如何找到最合适的 CDN 节点？&lt;/li>
&lt;li>如何防止静态资源被盗用？&lt;/li>
&lt;/ol>
&lt;h3 id="静态资源是如何被缓存到-cdn-节点中的">
 静态资源是如何被缓存到 CDN 节点中的？
 &lt;a class="anchor" href="#%e9%9d%99%e6%80%81%e8%b5%84%e6%ba%90%e6%98%af%e5%a6%82%e4%bd%95%e8%a2%ab%e7%bc%93%e5%ad%98%e5%88%b0-cdn-%e8%8a%82%e7%82%b9%e4%b8%ad%e7%9a%84">#&lt;/a>
&lt;/h3>
&lt;p>你可以通过 &lt;strong>预热&lt;/strong> 的方式将源站的资源同步到 CDN 的节点中。这样的话，用户首次请求资源可以直接从 CDN 节点中取，无需回源。这样可以降低源站压力，提升用户体验。&lt;/p></description></item><item><title>CompletableFuture 详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/completablefuture-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/completablefuture-intro/</guid><description>&lt;p>实际项目中，一个接口可能需要同时获取多种不同的数据，然后再汇总返回，这种场景还是挺常见的。举个例子：用户请求获取订单信息，可能需要同时获取用户信息、商品详情、物流信息、商品推荐等数据。&lt;/p>
&lt;p>如果是串行（按顺序依次执行每个任务）执行的话，接口的响应速度会非常慢。考虑到这些任务之间有大部分都是 &lt;strong>无前后顺序关联&lt;/strong> 的，可以 &lt;strong>并行执行&lt;/strong> ，就比如说调用获取商品详情的时候，可以同时调用获取物流信息。通过并行执行多个任务的方式，接口的响应速度会得到大幅优化。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/serial-to-parallel.png" alt="" />&lt;/p>
&lt;p>对于存在前后调用顺序关系的任务，可以进行任务编排。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/serial-to-parallel2.png" alt="" />&lt;/p>
&lt;ol>
&lt;li>获取用户信息之后，才能调用商品详情和物流信息接口。&lt;/li>
&lt;li>成功获取商品详情和物流信息之后，才能调用商品推荐接口。&lt;/li>
&lt;/ol>
&lt;p>可能会用到多线程异步任务编排的场景（这里只是举例，数据不一定是一次返回，可能会对接口进行拆分）：&lt;/p>
&lt;ol>
&lt;li>首页：例如技术社区的首页可能需要同时获取文章推荐列表、广告栏、文章排行榜、热门话题等信息。&lt;/li>
&lt;li>详情页：例如技术社区的文章详情页可能需要同时获取作者信息、文章详情、文章评论等信息。&lt;/li>
&lt;li>统计模块：例如技术社区的后台统计模块可能需要同时获取粉丝数汇总、文章数据（阅读量、评论量、收藏量）汇总等信息。&lt;/li>
&lt;/ol>
&lt;p>对于 Java 程序来说，Java 8 才被引入的 &lt;code>CompletableFuture&lt;/code> 可以帮助我们来做多个任务的编排，功能非常强大。&lt;/p>
&lt;p>这篇文章是 &lt;code>CompletableFuture&lt;/code> 的简单入门，带大家看看 &lt;code>CompletableFuture&lt;/code> 常用的 API。&lt;/p>
&lt;h2 id="future-介绍">
 Future 介绍
 &lt;a class="anchor" href="#future-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>Future&lt;/code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。具体来说是这样的：当我们执行某一耗时的任务时，可以将这个耗时任务交给一个子线程去异步执行，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们再通过 &lt;code>Future&lt;/code> 类获取到耗时任务的执行结果。这样一来，程序的执行效率就明显提高了。&lt;/p>
&lt;p>这其实就是多线程中经典的 &lt;strong>Future 模式&lt;/strong>，你可以将其看作是一种设计模式，核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有。&lt;/p>
&lt;p>在 Java 中，&lt;code>Future&lt;/code> 类只是一个泛型接口，位于 &lt;code>java.util.concurrent&lt;/code> 包下，其中定义了 5 个方法，主要包括下面这 4 个功能：&lt;/p>
&lt;ul>
&lt;li>取消任务；&lt;/li>
&lt;li>判断任务是否被取消;&lt;/li>
&lt;li>判断任务是否已经执行完成;&lt;/li>
&lt;li>获取任务执行结果。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// V 代表了Future执行的任务返回值的类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Future&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>V&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 取消任务执行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 成功取消返回 true，否则返回 false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">cancel&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> mayInterruptIfRunning);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 判断任务是否被取消&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isCancelled&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 判断任务是否已经执行完成&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isDone&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取任务执行结果&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> V &lt;span style="color:#a6e22e">get&lt;/span>() &lt;span style="color:#66d9ef">throws&lt;/span> InterruptedException, ExecutionException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 指定时间内没有返回计算结果就抛出 TimeOutException 异常&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> V &lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> timeout, TimeUnit unit)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throws&lt;/span> InterruptedException, ExecutionException, TimeoutExceptio
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>简单理解就是：我有一个任务，提交给了 &lt;code>Future&lt;/code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 &lt;code>Future&lt;/code> 那里直接取出任务执行结果。&lt;/p></description></item><item><title>ConcurrentHashMap 源码分析</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/concurrent-hash-map-source-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/concurrent-hash-map-source-code/</guid><description>&lt;blockquote>
&lt;p>本文来自公众号：末读代码的投稿，原文地址：&lt;a href="https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw">https://mp.weixin.qq.com/s/AHWzboztt53ZfFZmsSnMSw&lt;/a> 。&lt;/p>
&lt;/blockquote>
&lt;p>上一篇文章介绍了 HashMap 源码，反响不错，也有很多同学发表了自己的观点，这次又来了，这次是 &lt;code>ConcurrentHashMap&lt;/code> 了，作为线程安全的 HashMap ，它的使用频率也是很高。那么它的存储结构和实现原理是怎么样的呢？&lt;/p>
&lt;h2 id="1-concurrenthashmap-17">
 1. ConcurrentHashMap 1.7
 &lt;a class="anchor" href="#1-concurrenthashmap-17">#&lt;/a>
&lt;/h2>
&lt;h3 id="1-存储结构">
 1. 存储结构
 &lt;a class="anchor" href="#1-%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png" alt="Java 7 ConcurrentHashMap 存储结构" />&lt;/p>
&lt;p>Java 7 中 &lt;code>ConcurrentHashMap&lt;/code> 的存储结构如上图，&lt;code>ConcurrnetHashMap&lt;/code> 由很多个 &lt;code>Segment&lt;/code> 组合，而每一个 &lt;code>Segment&lt;/code> 是一个类似于 &lt;code>HashMap&lt;/code> 的结构，所以每一个 &lt;code>HashMap&lt;/code> 的内部可以进行扩容。但是 &lt;code>Segment&lt;/code> 的个数一旦&lt;strong>初始化就不能改变&lt;/strong>，默认 &lt;code>Segment&lt;/code> 的个数是 16 个，你也可以认为 &lt;code>ConcurrentHashMap&lt;/code> 默认支持最多 16 个线程并发。&lt;/p>
&lt;h3 id="2-初始化">
 2. 初始化
 &lt;a class="anchor" href="#2-%e5%88%9d%e5%a7%8b%e5%8c%96">#&lt;/a>
&lt;/h3>
&lt;p>通过 &lt;code>ConcurrentHashMap&lt;/code> 的无参构造探寻 &lt;code>ConcurrentHashMap&lt;/code> 的初始化流程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Creates a new, empty map with a default initial capacity (16),
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * load factor (0.75) and concurrencyLevel (16).
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">ConcurrentHashMap&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>无参构造中调用了有参构造，传入了三个参数的默认值，他们的值是。&lt;/p></description></item><item><title>CopyOnWriteArrayList 源码分析</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/copyonwritearraylist-source-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/copyonwritearraylist-source-code/</guid><description>&lt;h2 id="copyonwritearraylist-简介">
 CopyOnWriteArrayList 简介
 &lt;a class="anchor" href="#copyonwritearraylist-%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;p>在 JDK1.5 之前，如果想要使用并发安全的 &lt;code>List&lt;/code> 只能选择 &lt;code>Vector&lt;/code>。而 &lt;code>Vector&lt;/code> 是一种老旧的集合，已经被淘汰。&lt;code>Vector&lt;/code> 对于增删改查等方法基本都加了 &lt;code>synchronized&lt;/code>，这种方式虽然能够保证同步，但这相当于对整个 &lt;code>Vector&lt;/code> 加上了一把大锁，使得每个方法执行的时候都要去获得锁，导致性能非常低下。&lt;/p>
&lt;p>JDK1.5 引入了 &lt;code>Java.util.concurrent&lt;/code>（JUC）包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全 &lt;code>List&lt;/code> 实现就是 &lt;code>CopyOnWriteArrayList&lt;/code> 。关于&lt;code>java.util.concurrent&lt;/code> 包下常见并发容器的总结，可以看我写的这篇文章：&lt;a href="https://javaguide.cn/java/concurrent/java-concurrent-collections.html">Java 常见并发容器总结&lt;/a> 。&lt;/p>
&lt;h3 id="copyonwritearraylist-到底有什么厉害之处">
 CopyOnWriteArrayList 到底有什么厉害之处？
 &lt;a class="anchor" href="#copyonwritearraylist-%e5%88%b0%e5%ba%95%e6%9c%89%e4%bb%80%e4%b9%88%e5%8e%89%e5%ae%b3%e4%b9%8b%e5%a4%84">#&lt;/a>
&lt;/h3>
&lt;p>对于大部分业务场景来说，读取操作往往是远大于写入操作的。由于读取操作不会对原有数据进行修改，因此，对于每次读取都进行加锁其实是一种资源浪费。相比之下，我们应该允许多个线程同时访问 &lt;code>List&lt;/code> 的内部数据，毕竟对于读取操作来说是安全的。&lt;/p>
&lt;p>这种思路与 &lt;code>ReentrantReadWriteLock&lt;/code> 读写锁的设计思想非常类似，即读读不互斥、读写互斥、写写互斥（只有读读不互斥）。&lt;code>CopyOnWriteArrayList&lt;/code> 更进一步地实现了这一思想。为了将读操作性能发挥到极致，&lt;code>CopyOnWriteArrayList&lt;/code> 中的读取操作是完全无需加锁的。更加厉害的是，写入操作也不会阻塞读取操作，只有写写才会互斥。这样一来，读操作的性能就可以大幅度提升。&lt;/p>
&lt;p>&lt;code>CopyOnWriteArrayList&lt;/code> 线程安全的核心在于其采用了 &lt;strong>写时复制（Copy-On-Write）&lt;/strong> 的策略，从 &lt;code>CopyOnWriteArrayList&lt;/code> 的名字就能看出了。&lt;/p>
&lt;h3 id="copy-on-write-的思想是什么">
 Copy-On-Write 的思想是什么？
 &lt;a class="anchor" href="#copy-on-write-%e7%9a%84%e6%80%9d%e6%83%b3%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>CopyOnWriteArrayList&lt;/code>名字中的“Copy-On-Write”即写时复制，简称 COW。&lt;/p>
&lt;p>下面是维基百科对 Copy-On-Write 的介绍，介绍的挺不错：&lt;/p>
&lt;blockquote>
&lt;p>写入时复制（英语：Copy-on-write，简称 COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。&lt;/p>
&lt;/blockquote>
&lt;p>这里再以 &lt;code>CopyOnWriteArrayList&lt;/code>为例介绍：当需要修改（ &lt;code>add&lt;/code>，&lt;code>set&lt;/code>、&lt;code>remove&lt;/code> 等操作） &lt;code>CopyOnWriteArrayList&lt;/code> 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。&lt;/p>
&lt;p>可以看出，写时复制机制非常适合读多写少的并发场景，能够极大地提高系统的并发性能。&lt;/p>
&lt;p>不过，写时复制机制并不是银弹，其依然存在一些缺点，下面列举几点：&lt;/p>
&lt;ol>
&lt;li>内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。&lt;/li>
&lt;li>写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以写操作的开销相对较大，在写入比较频繁的场景下，性能可能会受到影响。&lt;/li>
&lt;li>数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ol>
&lt;h2 id="copyonwritearraylist-源码分析">
 CopyOnWriteArrayList 源码分析
 &lt;a class="anchor" href="#copyonwritearraylist-%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h2>
&lt;p>这里以 JDK1.8 为例，分析一下 &lt;code>CopyOnWriteArrayList&lt;/code> 的底层核心源码。&lt;/p></description></item><item><title>DelayQueue 源码分析</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/delayqueue-source-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/delayqueue-source-code/</guid><description>&lt;h2 id="delayqueue-简介">
 DelayQueue 简介
 &lt;a class="anchor" href="#delayqueue-%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>DelayQueue&lt;/code> 是 JUC 包(&lt;code>java.util.concurrent)&lt;/code>为我们提供的延迟队列，用于实现延时任务比如订单下单 15 分钟未支付直接取消。它是 &lt;code>BlockingQueue&lt;/code> 的一种，底层是一个基于 &lt;code>PriorityQueue&lt;/code> 实现的一个无界队列，是线程安全的。关于&lt;code>PriorityQueue&lt;/code>可以参考笔者编写的这篇文章：&lt;a href="./priorityqueue-source-code.md">PriorityQueue 源码分析&lt;/a> 。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/collection/blocking-queue-hierarchy.png" alt="BlockingQueue 的实现类" />&lt;/p>
&lt;p>&lt;code>DelayQueue&lt;/code> 中存放的元素必须实现 &lt;code>Delayed&lt;/code> 接口，并且需要重写 &lt;code>getDelay()&lt;/code>方法（计算是否到期）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Delayed&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;lt;&lt;/span>Delayed&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">getDelay&lt;/span>(TimeUnit unit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>默认情况下, &lt;code>DelayQueue&lt;/code> 会按照到期时间升序编排任务。只有当元素过期时（&lt;code>getDelay()&lt;/code>方法返回值小于等于 0），才能从队列中取出。&lt;/p>
&lt;h2 id="delayqueue-发展史">
 DelayQueue 发展史
 &lt;a class="anchor" href="#delayqueue-%e5%8f%91%e5%b1%95%e5%8f%b2">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;code>DelayQueue&lt;/code> 最早是在 Java 5 中引入的，作为 &lt;code>java.util.concurrent&lt;/code> 包中的一部分，用于支持基于时间的任务调度和缓存过期删除等场景，该版本仅仅支持延迟功能的实现，还未解决线程安全问题。&lt;/li>
&lt;li>在 Java 6 中，&lt;code>DelayQueue&lt;/code> 的实现进行了优化，通过使用 &lt;code>ReentrantLock&lt;/code> 和 &lt;code>Condition&lt;/code> 解决线程安全及线程间交互的效率，提高了其性能和可靠性。&lt;/li>
&lt;li>在 Java 7 中，&lt;code>DelayQueue&lt;/code> 的实现进行了进一步的优化，通过使用 CAS 操作实现元素的添加和移除操作，提高了其并发操作性能。&lt;/li>
&lt;li>在 Java 8 中，&lt;code>DelayQueue&lt;/code> 的实现没有进行重大变化，但是在 &lt;code>java.time&lt;/code> 包中引入了新的时间类，如 &lt;code>Duration&lt;/code> 和 &lt;code>Instant&lt;/code>，使得使用 &lt;code>DelayQueue&lt;/code> 进行基于时间的调度更加方便和灵活。&lt;/li>
&lt;li>在 Java 9 中，&lt;code>DelayQueue&lt;/code> 的实现进行了一些微小的改进，主要是对代码进行了一些优化和精简。&lt;/li>
&lt;/ul>
&lt;p>总的来说，&lt;code>DelayQueue&lt;/code> 的发展史主要是通过优化其实现方式和提高其性能和可靠性，使其更加适用于基于时间的调度和缓存过期删除等场景。&lt;/p></description></item><item><title>Disruptor常见问题总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/message-queue/disruptor-questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/message-queue/disruptor-questions/</guid><description>&lt;p>Disruptor 是一个相对冷门一些的知识点，不过，如果你的项目经历中用到了 Disruptor 的话，那面试中就很可能会被问到。&lt;/p>
&lt;p>一位球友之前投稿的面经（社招）中就涉及一些 Disruptor 的问题，文章传送门：&lt;a href="https://mp.weixin.qq.com/s/C5QMjwEb6pzXACqZsyqC4A">圆梦！顺利拿到字节、淘宝、拼多多等大厂 offer！&lt;/a> 。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/disruptor-interview-questions.png" alt="" />&lt;/p>
&lt;p>这篇文章可以看作是对 Disruptor 做的一个简单总结，每个问题都不会扯太深入，主要针对面试或者速览 Disruptor。&lt;/p>
&lt;h2 id="disruptor-是什么">
 Disruptor 是什么？
 &lt;a class="anchor" href="#disruptor-%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>Disruptor 是一个开源的高性能内存队列，诞生初衷是为了解决内存队列的性能和内存安全问题，由英国外汇交易公司 LMAX 开发。&lt;/p>
&lt;p>根据 Disruptor 官方介绍，基于 Disruptor 开发的系统 LMAX（新的零售金融交易平台），单线程就能支撑每秒 600 万订单。Martin Fowler 在 2011 年写的一篇文章 &lt;a href="https://martinfowler.com/articles/lmax.html">The LMAX Architecture&lt;/a> 中专门介绍过这个 LMAX 系统的架构，感兴趣的可以看看这篇文章。。&lt;/p>
&lt;p>LMAX 公司 2010 年在 QCon 演讲后，Disruptor 获得了业界关注，并获得了 2011 年的 Oracle 官方的 Duke&amp;rsquo;s Choice Awards(Duke 选择大奖)。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/640.png" alt="" />&lt;/p>
&lt;blockquote>
&lt;p>“Duke 选择大奖”旨在表彰过去一年里全球个人或公司开发的、最具影响力的 Java 技术应用，由甲骨文公司主办。含金量非常高！&lt;/p>
&lt;/blockquote>
&lt;p>我专门找到了 Oracle 官方当年颁布获得 Duke&amp;rsquo;s Choice Awards 项目的那篇文章（文章地址：&lt;a href="https://blogs.oracle.com/java/post/and-the-winners-arethe-dukes-choice-award%ef%bc%89">https://blogs.oracle.com/java/post/and-the-winners-arethe-dukes-choice-award）&lt;/a> 。从文中可以看出，同年获得此大奖荣誉的还有大名鼎鼎的 Netty、JRebel 等项目。&lt;/p></description></item><item><title>DNS 域名系统详解（应用层）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/dns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/dns/</guid><description>&lt;p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是&lt;strong>域名和 IP 地址的映射问题&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/dns-overview.png" alt="DNS:域名系统" />&lt;/p>
&lt;p>在实际使用中，有一种情况下，浏览器是可以不必动用 DNS 就可以获知域名和 IP 地址的映射的。浏览器在本地会维护一个&lt;code>hosts&lt;/code>列表，一般来说浏览器要先查看要访问的域名是否在&lt;code>hosts&lt;/code>列表中，如果有的话，直接提取对应的 IP 地址记录，就好了。如果本地&lt;code>hosts&lt;/code>列表内没有域名-IP 对应记录的话，那么 DNS 就闪亮登场了。&lt;/p>
&lt;p>目前 DNS 的设计采用的是分布式、层次数据库结构，&lt;strong>DNS 是应用层协议，基于 UDP 协议之上，端口为 53&lt;/strong> 。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/network-protocol-overview.png" alt="TCP/IP 各层协议概览" />&lt;/p>
&lt;h2 id="dns-服务器">
 DNS 服务器
 &lt;a class="anchor" href="#dns-%e6%9c%8d%e5%8a%a1%e5%99%a8">#&lt;/a>
&lt;/h2>
&lt;p>DNS 服务器自底向上可以依次分为以下几个层级(所有 DNS 服务器都属于以下四个类别之一):&lt;/p>
&lt;ul>
&lt;li>根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。&lt;/li>
&lt;li>顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如&lt;code>com&lt;/code>、&lt;code>org&lt;/code>、&lt;code>net&lt;/code>和&lt;code>edu&lt;/code>等。国家也有自己的顶级域，如&lt;code>uk&lt;/code>、&lt;code>fr&lt;/code>和&lt;code>ca&lt;/code>。TLD 服务器提供了权威 DNS 服务器的 IP 地址。&lt;/li>
&lt;li>权威 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。&lt;/li>
&lt;li>本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构。&lt;/li>
&lt;/ul>
&lt;p>世界上并不是只有 13 台根服务器，这是很多人普遍的误解，网上很多文章也是这么写的。实际上，现在根服务器数量远远超过这个数量。最初确实是为 DNS 根服务器分配了 13 个 IP 地址，每个 IP 地址对应一个不同的根 DNS 服务器。然而，由于互联网的快速发展和增长，这个原始的架构变得不太适应当前的需求。为了提高 DNS 的可靠性、安全性和性能，目前这 13 个 IP 地址中的每一个都有多个服务器，截止到 2023 年底，所有根服务器之和达到了 600 多台，未来还会继续增加。&lt;/p></description></item><item><title>Docker核心概念总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/docker/docker-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/docker/docker-intro/</guid><description>&lt;p>本文只是对 Docker 的概念做了较为详细的介绍，并不涉及一些像 Docker 环境的安装以及 Docker 的一些常见操作和命令。&lt;/p>
&lt;h2 id="容器介绍">
 容器介绍
 &lt;a class="anchor" href="#%e5%ae%b9%e5%99%a8%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>Docker 是世界领先的软件容器平台&lt;/strong>，所以想要搞懂 Docker 的概念我们必须先从容器开始说起。&lt;/p>
&lt;h3 id="什么是容器">
 什么是容器?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%ae%b9%e5%99%a8">#&lt;/a>
&lt;/h3>
&lt;h4 id="先来看看容器较为官方的解释">
 先来看看容器较为官方的解释
 &lt;a class="anchor" href="#%e5%85%88%e6%9d%a5%e7%9c%8b%e7%9c%8b%e5%ae%b9%e5%99%a8%e8%be%83%e4%b8%ba%e5%ae%98%e6%96%b9%e7%9a%84%e8%a7%a3%e9%87%8a">#&lt;/a>
&lt;/h4>
&lt;p>&lt;strong>一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>容器镜像是轻量的、可执行的独立软件包&lt;/strong> ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。&lt;/li>
&lt;li>&lt;strong>容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>容器赋予了软件独立性&lt;/strong>，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。&lt;/li>
&lt;/ul>
&lt;h4 id="再来看看容器较为通俗的解释">
 再来看看容器较为通俗的解释
 &lt;a class="anchor" href="#%e5%86%8d%e6%9d%a5%e7%9c%8b%e7%9c%8b%e5%ae%b9%e5%99%a8%e8%be%83%e4%b8%ba%e9%80%9a%e4%bf%97%e7%9a%84%e8%a7%a3%e9%87%8a">#&lt;/a>
&lt;/h4>
&lt;p>如果需要通俗地描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/tools/docker/container.png" alt="认识容器" />&lt;/p>
&lt;h3 id="图解物理机虚拟机与容器">
 图解物理机,虚拟机与容器
 &lt;a class="anchor" href="#%e5%9b%be%e8%a7%a3%e7%89%a9%e7%90%86%e6%9c%ba%e8%99%9a%e6%8b%9f%e6%9c%ba%e4%b8%8e%e5%ae%b9%e5%99%a8">#&lt;/a>
&lt;/h3>
&lt;p>关于虚拟机与容器的对比在后面会详细介绍到，这里只是通过网上的图片加深大家对于物理机、虚拟机与容器这三者的理解(下面的图片来源于网络)。&lt;/p>
&lt;p>&lt;strong>物理机：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/tools/docker/%E7%89%A9%E7%90%86%E6%9C%BA%E5%9B%BE%E8%A7%A3.jpeg" alt="物理机" />&lt;/p>
&lt;p>&lt;strong>虚拟机：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/tools/docker/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%BE%E8%A7%A3.jpeg" alt="虚拟机" />&lt;/p>
&lt;p>&lt;strong>容器：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/javaguide/image-20211110104003678.png" alt="" />&lt;/p>
&lt;p>通过上面这三张抽象图，我们可以大概通过类比概括出：&lt;strong>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。&lt;/strong>&lt;/p>
&lt;h3 id="容器-vs-虚拟机">
 容器 VS 虚拟机
 &lt;a class="anchor" href="#%e5%ae%b9%e5%99%a8-vs-%e8%99%9a%e6%8b%9f%e6%9c%ba">#&lt;/a>
&lt;/h3>
&lt;p>每当说起容器，我们不得不将其与虚拟机做一个比较。就我而言，对于两者无所谓谁会取代谁，而是两者可以和谐共存。&lt;/p>
&lt;p>简单来说：&lt;strong>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。&lt;/strong>&lt;/p>
&lt;p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/javaguide/2e2b95eebf60b6d03f6c1476f4d7c697.png" alt="" />&lt;/p>
&lt;p>&lt;strong>容器和虚拟机的对比&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/javaguide/4ef8691d67eb1eb53217099d0a691eb5.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行 。与虚拟机相比， &lt;strong>容器占用的空间较少&lt;/strong>（容器镜像大小通常只有几十兆），&lt;strong>瞬间就能完成启动&lt;/strong> 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 &lt;strong>占用大量空间&lt;/strong> 。而且 VM &lt;strong>启动也十分缓慢&lt;/strong> 。&lt;/p></description></item><item><title>Docker实战</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/docker/docker-in-action/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/docker/docker-in-action/</guid><description>&lt;h2 id="docker-介绍">
 Docker 介绍
 &lt;a class="anchor" href="#docker-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>开始之前，还是简单介绍一下 Docker，更多 Docker 概念介绍可以看前一篇文章&lt;a href="./docker-intro.md">Docker 核心概念总结&lt;/a>。&lt;/p>
&lt;h3 id="什么是-docker">
 什么是 Docker？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-docker">#&lt;/a>
&lt;/h3>
&lt;p>说实话关于 Docker 是什么并不太好说，下面我通过四点向你说明 Docker 到底是个什么东西。&lt;/p>
&lt;ul>
&lt;li>Docker 是世界领先的软件容器平台，基于 &lt;strong>Go 语言&lt;/strong> 进行开发实现。&lt;/li>
&lt;li>Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放开发人员。&lt;/li>
&lt;li>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。&lt;/li>
&lt;li>Docker 可以&lt;strong>对进程进行封装隔离，属于操作系统层面的虚拟化技术。&lt;/strong> 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。&lt;/li>
&lt;/ul>
&lt;p>官网地址：&lt;a href="https://www.docker.com/">https://www.docker.com/&lt;/a> 。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/tools/docker/container.png" alt="认识容器" />&lt;/p>
&lt;h3 id="为什么要用-docker">
 为什么要用 Docker?
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-docker">#&lt;/a>
&lt;/h3>
&lt;p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&lt;/p>
&lt;p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app），更重要的是容器性能开销极低。&lt;/p>
&lt;p>传统的开发流程中，我们的项目通常需要使用 MySQL、Redis、FastDFS 等等环境，这些环境都是需要我们手动去进行下载并配置的，安装配置流程极其复杂，而且不同系统下的操作也不一样。&lt;/p>
&lt;p>Docker 的出现完美地解决了这一问题，我们可以在容器中安装 MySQL、Redis 等软件环境，使得应用和环境架构分开，它的优势在于：&lt;/p>
&lt;ol>
&lt;li>一致的运行环境，能够更轻松地迁移&lt;/li>
&lt;li>对进程进行封装隔离，容器与容器之间互不影响，更高效地利用系统资源&lt;/li>
&lt;li>可以通过镜像复制多个一致的容器&lt;/li>
&lt;/ol>
&lt;p>另外，&lt;a href="https://yeasy.gitbook.io/docker_practice/introduction/why">《Docker 从入门到实践》&lt;/a> 这本开源书籍中也已经给出了使用 Docker 的原因。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/tools/docker/20210412220015698.png" alt="" />&lt;/p>
&lt;h2 id="docker-的安装">
 Docker 的安装
 &lt;a class="anchor" href="#docker-%e7%9a%84%e5%ae%89%e8%a3%85">#&lt;/a>
&lt;/h2>
&lt;h3 id="windows">
 Windows
 &lt;a class="anchor" href="#windows">#&lt;/a>
&lt;/h3>
&lt;p>接下来对 Docker 进行安装，以 Windows 系统为例，访问 Docker 的官网：&lt;/p></description></item><item><title>Dubbo常见问题总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/rpc/dubbo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/rpc/dubbo/</guid><description>&lt;p>::: tip&lt;/p>
&lt;ul>
&lt;li>Dubbo3 已经发布，这篇文章是基于 Dubbo2 写的。Dubbo3 基于 Dubbo2 演进而来，在保持原有核心功能特性的同时， Dubbo3 在易用性、超大规模微服务实践、云原生基础设施适配、安全设计等几大方向上进行了全面升级。&lt;/li>
&lt;li>本文中的很多链接已经失效，主要原因是因为 Dubbo 官方文档进行了修改导致 URL 失效。&lt;/li>
&lt;/ul>
&lt;p>:::&lt;/p>
&lt;p>这篇文章是我根据官方文档以及自己平时的使用情况，对 Dubbo 所做的一个总结。欢迎补充！&lt;/p>
&lt;h2 id="dubbo-基础">
 Dubbo 基础
 &lt;a class="anchor" href="#dubbo-%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是-dubbo">
 什么是 Dubbo?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-dubbo">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/rpc/dubbo.org-overview.png" alt="Dubbo 官网" />&lt;/p>
&lt;p>&lt;a href="https://github.com/apache/dubbo">Apache Dubbo&lt;/a> |ˈdʌbəʊ| 是一款高性能、轻量级的开源 WEB 和 RPC 框架。&lt;/p>
&lt;p>根据 &lt;a href="https://dubbo.apache.org/zh/">Dubbo 官方文档&lt;/a>的介绍，Dubbo 提供了六大核心能力&lt;/p>
&lt;ol>
&lt;li>面向接口代理的高性能 RPC 调用。&lt;/li>
&lt;li>智能容错和负载均衡。&lt;/li>
&lt;li>服务自动注册和发现。&lt;/li>
&lt;li>高度可扩展能力。&lt;/li>
&lt;li>运行期流量调度。&lt;/li>
&lt;li>可视化的服务治理与运维。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://oss.javaguide.cn/%E6%BA%90%E7%A0%81/dubbo/dubbo%E6%8F%90%E4%BE%9B%E7%9A%84%E5%85%AD%E5%A4%A7%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B.png" alt="Dubbo提供的六大核心能力" />&lt;/p>
&lt;p>简单来说就是：&lt;strong>Dubbo 不光可以帮助我们调用远程服务，还提供了一些其他开箱即用的功能比如智能负载均衡。&lt;/strong>&lt;/p>
&lt;p>Dubbo 目前已经有接近 34.4 k 的 Star 。&lt;/p>
&lt;p>在 &lt;strong>2020 年度 OSC 中国开源项目&lt;/strong> 评选活动中，Dubbo 位列开发框架和基础组件类项目的第 7 名。相比几年前来说，热度和排名有所下降。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/%E6%BA%90%E7%A0%81/dubbo/image-20210107153159545.png" alt="" />&lt;/p></description></item><item><title>Elasticsearch常见面试题总结(付费)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/elasticsearch/elasticsearch-questions-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/elasticsearch/elasticsearch-questions-01/</guid><description>&lt;p>&lt;strong>Elasticsearch&lt;/strong> 相关的面试题为我的&lt;a href="../../about-the-author/zhishixingqiu-two-years.md">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了&lt;a href="../../zhuanlan/java-mian-shi-zhi-bei.md">《Java 面试指北》&lt;/a>中。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/javamianshizhibei/elasticsearch-questions.png" alt="" />&lt;/p></description></item><item><title>Github实用小技巧总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/git/github-tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/git/github-tips/</guid><description>&lt;p>我使用 Github 已经有 6 年多了，今天毫无保留地把自己觉得比较有用的 Github 小技巧送给关注 JavaGuide 的各位小伙伴。&lt;/p>
&lt;h2 id="一键生成-github-简历--github-年报">
 一键生成 Github 简历 &amp;amp; Github 年报
 &lt;a class="anchor" href="#%e4%b8%80%e9%94%ae%e7%94%9f%e6%88%90-github-%e7%ae%80%e5%8e%86--github-%e5%b9%b4%e6%8a%a5">#&lt;/a>
&lt;/h2>
&lt;p>通过 &lt;a href="https://resume.github.io/">https://resume.github.io/&lt;/a> 这个网站你可以一键生成一个在线的 Github 简历。&lt;/p>
&lt;p>当时我参加的校招的时候，个人信息那里就放了一个在线的 Github 简历。我觉得这样会让面试官感觉你是一个内行，会提高一些印象分。&lt;/p>
&lt;p>但是，如果你的 Github 没有什么项目的话还是不要放在简历里面了。生成后的效果如下图所示。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/2020-11/image-20201108192205620.png" alt="Github简历" />&lt;/p>
&lt;p>通过 &lt;a href="https://www.githubtrends.io/wrapped">https://www.githubtrends.io/wrapped&lt;/a> 这个网站，你可以生成一份 Github 个人年报，这个年报会列举出你在这一年的项目贡献情况、最常使用的编程语言、详细的贡献信息。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/dootask/image-20211226144607457.png" alt="" />&lt;/p>
&lt;h2 id="个性化-github-首页">
 个性化 Github 首页
 &lt;a class="anchor" href="#%e4%b8%aa%e6%80%a7%e5%8c%96-github-%e9%a6%96%e9%a1%b5">#&lt;/a>
&lt;/h2>
&lt;p>Github 目前支持在个人主页自定义展示一些内容。展示效果如下图所示。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/java-guide-blog/image-20210616221212259.png" alt="个性化首页展示效果" />&lt;/p>
&lt;p>想要做到这样非常简单，你只需要创建一个和你的 Github 账户同名的仓库，然后自定义&lt;code>README.md&lt;/code>的内容即可。&lt;/p>
&lt;p>展示在你主页的自定义内容就是&lt;code>README.md&lt;/code>的内容（&lt;em>不会 Markdown 语法的小伙伴自行面壁 5 分钟&lt;/em>）。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/java-guide-blog/image-20201107110309341.png" alt="创建一个和你的Github账户同名的仓库" />&lt;/p>
&lt;p>这个也是可以玩出花来的！比如说：通过 &lt;a href="https://hellogithub.com/periodical/statistics/click/?target=https://github.com/anuraghazra/github-readme-stats">github-readme-stats&lt;/a> 这个开源项目，你可以 README 中展示动态生成的 GitHub 统计信息。展示效果如下图所示。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/java-guide-blog/image-20210616221312426.png" alt="通过github-readme-stats动态生成GitHub统计信息 " />&lt;/p>
&lt;p>关于个性化首页这个就不多提了，感兴趣的小伙伴自行研究一下。&lt;/p>
&lt;h2 id="自定义项目徽章">
 自定义项目徽章
 &lt;a class="anchor" href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e9%a1%b9%e7%9b%ae%e5%be%bd%e7%ab%a0">#&lt;/a>
&lt;/h2>
&lt;p>你在 Github 上看到的项目徽章都是通过 &lt;a href="https://shields.io/">https://shields.io/&lt;/a> 这个网站生成的。我的 JavaGuide 这个项目的徽章如下图所示。&lt;/p></description></item><item><title>Git核心概念总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/git/git-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/git/git-intro/</guid><description>&lt;h2 id="版本控制">
 版本控制
 &lt;a class="anchor" href="#%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是版本控制">
 什么是版本控制
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6">#&lt;/a>
&lt;/h3>
&lt;p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。&lt;/p>
&lt;h3 id="为什么要版本控制">
 为什么要版本控制
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6">#&lt;/a>
&lt;/h3>
&lt;p>有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。&lt;/p>
&lt;h3 id="本地版本控制系统">
 本地版本控制系统
 &lt;a class="anchor" href="#%e6%9c%ac%e5%9c%b0%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e7%b3%bb%e7%bb%9f">#&lt;/a>
&lt;/h3>
&lt;p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。&lt;/p>
&lt;p>为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/tools/git/%E6%9C%AC%E5%9C%B0%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.png" alt="本地版本控制系统" />&lt;/p>
&lt;h3 id="集中化的版本控制系统">
 集中化的版本控制系统
 &lt;a class="anchor" href="#%e9%9b%86%e4%b8%ad%e5%8c%96%e7%9a%84%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e7%b3%bb%e7%bb%9f">#&lt;/a>
&lt;/h3>
&lt;p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。&lt;/p>
&lt;p>集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/tools/git/%E9%9B%86%E4%B8%AD%E5%8C%96%E7%9A%84%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.png" alt="集中化的版本控制系统" />&lt;/p>
&lt;p>这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>单点故障：&lt;/strong> 中央服务器宕机，则其他人无法使用；如果中心数据库磁盘损坏又没有进行备份，你将丢失所有数据。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。&lt;/li>
&lt;li>&lt;strong>必须联网才能工作：&lt;/strong> 受网络状况、带宽影响。&lt;/li>
&lt;/ul>
&lt;h3 id="分布式版本控制系统">
 分布式版本控制系统
 &lt;a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e7%b3%bb%e7%bb%9f">#&lt;/a>
&lt;/h3>
&lt;p>于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 Git 就是一个典型的分布式版本控制系统。&lt;/p>
&lt;p>这类系统，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/tools/git/%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F.png" alt="分布式版本控制系统" />&lt;/p>
&lt;p>分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。&lt;/p>
&lt;p>分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。&lt;/p>
&lt;h2 id="认识-git">
 认识 Git
 &lt;a class="anchor" href="#%e8%ae%a4%e8%af%86-git">#&lt;/a>
&lt;/h2>
&lt;h3 id="git-简史">
 Git 简史
 &lt;a class="anchor" href="#git-%e7%ae%80%e5%8f%b2">#&lt;/a>
&lt;/h3>
&lt;p>Linux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。&lt;/p></description></item><item><title>Gossip 协议详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/protocol/gossip-protocl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/protocol/gossip-protocl/</guid><description>&lt;h2 id="背景">
 背景
 &lt;a class="anchor" href="#%e8%83%8c%e6%99%af">#&lt;/a>
&lt;/h2>
&lt;p>在分布式系统中，不同的节点进行数据/信息共享是一个基本的需求。&lt;/p>
&lt;p>一种比较简单粗暴的方法就是 &lt;strong>集中式发散消息&lt;/strong>，简单来说就是一个主节点同时共享最新信息给其他所有节点，比较适合中心化系统。这种方法的缺陷也很明显，节点多的时候不光同步消息的效率低，还太依赖与中心节点，存在单点风险问题。&lt;/p>
&lt;p>于是，&lt;strong>分散式发散消息&lt;/strong> 的 &lt;strong>Gossip 协议&lt;/strong> 就诞生了。&lt;/p>
&lt;h2 id="gossip-协议介绍">
 Gossip 协议介绍
 &lt;a class="anchor" href="#gossip-%e5%8d%8f%e8%ae%ae%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>Gossip 直译过来就是闲话、流言蜚语的意思。流言蜚语有什么特点呢？容易被传播且传播速度还快，你传我我传他，然后大家都知道了。&lt;/p>
&lt;p>&lt;img src="./images/gossip/gossip.png" alt="" />&lt;/p>
&lt;p>&lt;strong>Gossip 协议&lt;/strong> 也叫 Epidemic 协议（流行病协议）或者 Epidemic propagation 算法（疫情传播算法），别名很多。不过，这些名字的特点都具有 &lt;strong>随机传播特性&lt;/strong> （联想一下病毒传播、癌细胞扩散等生活中常见的情景），这也正是 Gossip 协议最主要的特点。&lt;/p>
&lt;p>Gossip 协议最早是在 ACM 上的一篇 1987 年发表的论文 &lt;a href="https://dl.acm.org/doi/10.1145/41840.41841">《Epidemic Algorithms for Replicated Database Maintenance》&lt;/a>中被提出的。根据论文标题，我们大概就能知道 Gossip 协议当时提出的主要应用是在分布式数据库系统中各个副本节点同步数据。&lt;/p>
&lt;p>正如 Gossip 协议其名一样，这是一种随机且带有传染性的方式将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。&lt;/p>
&lt;p>在 Gossip 协议下，没有所谓的中心节点，每个节点周期性地随机找一个节点互相同步彼此的信息，理论上来说，各个节点的状态最终会保持一致。&lt;/p>
&lt;p>下面我们来对 Gossip 协议的定义做一个总结：&lt;strong>Gossip 协议是一种允许在分布式系统中共享状态的去中心化通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。&lt;/strong>&lt;/p>
&lt;h2 id="gossip-协议应用">
 Gossip 协议应用
 &lt;a class="anchor" href="#gossip-%e5%8d%8f%e8%ae%ae%e5%ba%94%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;p>NoSQL 数据库 Redis 和 Apache Cassandra、服务网格解决方案 Consul 等知名项目都用到了 Gossip 协议，学习 Gossip 协议有助于我们搞清很多技术的底层原理。&lt;/p></description></item><item><title>Gradle核心概念总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/gradle/gradle-core-concepts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/gradle/gradle-core-concepts/</guid><description>&lt;blockquote>
&lt;p>这部分内容主要根据 Gradle 官方文档整理，做了对应的删减，主要保留比较重要的部分，不涉及实战，主要是一些重要概念的介绍。&lt;/p>
&lt;/blockquote>
&lt;p>Gradle 这部分内容属于可选内容，可以根据自身需求决定是否学习，目前国内还是使用 Maven 普遍一些。&lt;/p>
&lt;h2 id="gradle-介绍">
 Gradle 介绍
 &lt;a class="anchor" href="#gradle-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>Gradle 官方文档是这样介绍的 Gradle 的：&lt;/p>
&lt;blockquote>
&lt;p>Gradle is an open-source &lt;a href="https://en.wikipedia.org/wiki/Build_automation">build automation&lt;/a> tool flexible enough to build almost any type of software. Gradle makes few assumptions about what you’re trying to build or how to build it. This makes Gradle particularly flexible.&lt;/p>
&lt;p>Gradle 是一个开源的构建自动化工具，它足够灵活，可以构建几乎任何类型的软件。Gradle 对你要构建什么或者如何构建它做了很少的假设。这使得 Gradle 特别灵活。&lt;/p>
&lt;/blockquote>
&lt;p>简单来说，Gradle 就是一个运行在 JVM 上的自动化的项目构建工具，用来帮助我们自动构建项目。&lt;/p>
&lt;p>对于开发者来说，Gradle 的主要作用主要有 3 个：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>项目构建&lt;/strong>：提供标准的、跨平台的自动化项目构建方式。&lt;/li>
&lt;li>&lt;strong>依赖管理&lt;/strong>：方便快捷的管理项目依赖的资源（jar 包），避免资源间的版本冲突问题。&lt;/li>
&lt;li>&lt;strong>统一开发结构&lt;/strong>：提供标准的、统一的项目结构。&lt;/li>
&lt;/ol>
&lt;p>Gradle 构建脚本是使用 Groovy 或 Kotlin 语言编写的，表达能力非常强，也足够灵活。&lt;/p></description></item><item><title>HashMap 源码分析</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/hashmap-source-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/hashmap-source-code/</guid><description>&lt;blockquote>
&lt;p>感谢 &lt;a href="https://github.com/changfubai">changfubai&lt;/a> 对本文的改进做出的贡献！&lt;/p>
&lt;/blockquote>
&lt;h2 id="hashmap-简介">
 HashMap 简介
 &lt;a class="anchor" href="#hashmap-%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。&lt;/p>
&lt;p>&lt;code>HashMap&lt;/code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个&lt;/p>
&lt;p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 &lt;code>HashMap&lt;/code> 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。&lt;/p>
&lt;p>&lt;code>HashMap&lt;/code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， &lt;code>HashMap&lt;/code> 总是使用 2 的幂作为哈希表的大小。&lt;/p>
&lt;h2 id="底层数据结构分析">
 底层数据结构分析
 &lt;a class="anchor" href="#%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h2>
&lt;h3 id="jdk18-之前">
 JDK1.8 之前
 &lt;a class="anchor" href="#jdk18-%e4%b9%8b%e5%89%8d">#&lt;/a>
&lt;/h3>
&lt;p>JDK1.8 之前 HashMap 底层是 &lt;strong>数组和链表&lt;/strong> 结合在一起使用也就是 &lt;strong>链表散列&lt;/strong>。&lt;/p>
&lt;p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 &lt;code>(n - 1) &amp;amp; hash&lt;/code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。&lt;/p></description></item><item><title>HTTP 1.0 vs HTTP 1.1（应用层）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/http1.0-vs-http1.1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/http1.0-vs-http1.1/</guid><description>&lt;p>这篇文章会从下面几个维度来对比 HTTP 1.0 和 HTTP 1.1：&lt;/p>
&lt;ul>
&lt;li>响应状态码&lt;/li>
&lt;li>缓存处理&lt;/li>
&lt;li>连接方式&lt;/li>
&lt;li>Host 头处理&lt;/li>
&lt;li>带宽优化&lt;/li>
&lt;/ul>
&lt;h2 id="响应状态码">
 响应状态码
 &lt;a class="anchor" href="#%e5%93%8d%e5%ba%94%e7%8a%b6%e6%80%81%e7%a0%81">#&lt;/a>
&lt;/h2>
&lt;p>HTTP/1.0 仅定义了 16 种状态码。HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，&lt;code>100 (Continue)&lt;/code>——在请求大资源前的预热请求，&lt;code>206 (Partial Content)&lt;/code>——范围请求的标识码，&lt;code>409 (Conflict)&lt;/code>——请求与当前资源的规定冲突，&lt;code>410 (Gone)&lt;/code>——资源已被永久转移，而且没有任何已知的转发地址。&lt;/p>
&lt;h2 id="缓存处理">
 缓存处理
 &lt;a class="anchor" href="#%e7%bc%93%e5%ad%98%e5%a4%84%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;p>缓存技术通过避免用户与源服务器的频繁交互，节约了大量的网络带宽，降低了用户接收信息的延迟。&lt;/p>
&lt;h3 id="http10">
 HTTP/1.0
 &lt;a class="anchor" href="#http10">#&lt;/a>
&lt;/h3>
&lt;p>HTTP/1.0 提供的缓存机制非常简单。服务器端使用&lt;code>Expires&lt;/code>标签来标志（时间）一个响应体，在&lt;code>Expires&lt;/code>标志时间内的请求，都会获得该响应体缓存。服务器端在初次返回给客户端的响应体中，有一个&lt;code>Last-Modified&lt;/code>标签，该标签标记了被请求资源在服务器端的最后一次修改。在请求头中，使用&lt;code>If-Modified-Since&lt;/code>标签，该标签标志一个时间，意为客户端向服务器进行问询：“该时间之后，我要请求的资源是否有被修改过？”通常情况下，请求头中的&lt;code>If-Modified-Since&lt;/code>的值即为上一次获得该资源时，响应体中的&lt;code>Last-Modified&lt;/code>的值。&lt;/p>
&lt;p>如果服务器接收到了请求头，并判断&lt;code>If-Modified-Since&lt;/code>时间后，资源确实没有修改过，则返回给客户端一个&lt;code>304 not modified&lt;/code>响应头，表示”缓冲可用，你从浏览器里拿吧！”。&lt;/p>
&lt;p>如果服务器判断&lt;code>If-Modified-Since&lt;/code>时间后，资源被修改过，则返回给客户端一个&lt;code>200 OK&lt;/code>的响应体，并附带全新的资源内容，表示”你要的我已经改过的，给你一份新的”。&lt;/p>
&lt;p>&lt;img src="./images/http-vs-https/HTTP1.0cache1.png" alt="HTTP1.0cache1" />&lt;/p>
&lt;p>&lt;img src="./images/http-vs-https/HTTP1.0cache2.png" alt="HTTP1.0cache2" />&lt;/p>
&lt;h3 id="http11">
 HTTP/1.1
 &lt;a class="anchor" href="#http11">#&lt;/a>
&lt;/h3>
&lt;p>HTTP/1.1 的缓存机制在 HTTP/1.0 的基础上，大大增加了灵活性和扩展性。基本工作原理和 HTTP/1.0 保持不变，而是增加了更多细致的特性。其中，请求头中最常见的特性就是&lt;code>Cache-Control&lt;/code>，详见 MDN Web 文档 &lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control&lt;/a>.&lt;/p>
&lt;h2 id="连接方式">
 连接方式
 &lt;a class="anchor" href="#%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>HTTP/1.0 默认使用短连接&lt;/strong> ，也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 TCP 连接，这样就会导致有大量的“握手报文”和“挥手报文”占用了带宽。&lt;/p></description></item><item><title>HTTP vs HTTPS（应用层）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/http-vs-https/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/http-vs-https/</guid><description>&lt;h2 id="http-协议">
 HTTP 协议
 &lt;a class="anchor" href="#http-%e5%8d%8f%e8%ae%ae">#&lt;/a>
&lt;/h2>
&lt;h3 id="http-协议介绍">
 HTTP 协议介绍
 &lt;a class="anchor" href="#http-%e5%8d%8f%e8%ae%ae%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h3>
&lt;p>HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。&lt;/p>
&lt;p>并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。&lt;/p>
&lt;h3 id="http-协议通信过程">
 HTTP 协议通信过程
 &lt;a class="anchor" href="#http-%e5%8d%8f%e8%ae%ae%e9%80%9a%e4%bf%a1%e8%bf%87%e7%a8%8b">#&lt;/a>
&lt;/h3>
&lt;p>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：&lt;/p>
&lt;ol>
&lt;li>服务器在 80 端口等待客户的请求。&lt;/li>
&lt;li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。&lt;/li>
&lt;li>服务器接收来自浏览器的 TCP 连接。&lt;/li>
&lt;li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。&lt;/li>
&lt;li>关闭 TCP 连接。&lt;/li>
&lt;/ol>
&lt;h3 id="http-协议优点">
 HTTP 协议优点
 &lt;a class="anchor" href="#http-%e5%8d%8f%e8%ae%ae%e4%bc%98%e7%82%b9">#&lt;/a>
&lt;/h3>
&lt;p>扩展性强、速度快、跨平台支持性好。&lt;/p>
&lt;h2 id="https-协议">
 HTTPS 协议
 &lt;a class="anchor" href="#https-%e5%8d%8f%e8%ae%ae">#&lt;/a>
&lt;/h2>
&lt;h3 id="https-协议介绍">
 HTTPS 协议介绍
 &lt;a class="anchor" href="#https-%e5%8d%8f%e8%ae%ae%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h3>
&lt;p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.&lt;/p></description></item><item><title>HTTP 常见状态码总结（应用层）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/http-status-codes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/http-status-codes/</guid><description>&lt;p>HTTP 状态码用于描述 HTTP 请求的结果，比如 2xx 就代表请求被成功处理。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png" alt="常见 HTTP 状态码" />&lt;/p>
&lt;h3 id="1xx-informational信息性状态码">
 1xx Informational（信息性状态码）
 &lt;a class="anchor" href="#1xx-informational%e4%bf%a1%e6%81%af%e6%80%a7%e7%8a%b6%e6%80%81%e7%a0%81">#&lt;/a>
&lt;/h3>
&lt;p>相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。&lt;/p>
&lt;h3 id="2xx-success成功状态码">
 2xx Success（成功状态码）
 &lt;a class="anchor" href="#2xx-success%e6%88%90%e5%8a%9f%e7%8a%b6%e6%80%81%e7%a0%81">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>200 OK&lt;/strong>：请求被成功处理。例如，发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。&lt;/li>
&lt;li>&lt;strong>201 Created&lt;/strong>：请求被成功处理并且在服务端创建了&lt;del>一个新的资源&lt;/del>。例如，通过 POST 请求创建一个新的用户。&lt;/li>
&lt;li>&lt;strong>202 Accepted&lt;/strong>：服务端已经接收到了请求，但是还未处理。例如，发送一个需要服务端花费较长时间处理的请求（如报告生成、Excel 导出），服务端接收了请求但尚未处理完毕。&lt;/li>
&lt;li>&lt;strong>204 No Content&lt;/strong>：服务端已经成功处理了请求，但是没有返回任何内容。例如，发送请求删除一个用户，服务器成功处理了删除操作但没有返回任何内容。&lt;/li>
&lt;/ul>
&lt;p>🐛 修正（参见：&lt;a href="https://github.com/Snailclimb/JavaGuide/issues/2458">issue#2458&lt;/a>）：201 Created 状态码更准确点来说是创建一个或多个新的资源，可以参考：&lt;a href="https://httpwg.org/specs/rfc9110.html#status.201">https://httpwg.org/specs/rfc9110.html#status.201&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/rfc9110-201-created.png" alt="" />&lt;/p>
&lt;p>这里格外提一下 204 状态码，平时学习/工作中见到的次数并不多。&lt;/p>
&lt;p>&lt;a href="https://tools.ietf.org/html/rfc2616#section-10.2.5">HTTP RFC 2616 对 204 状态码的描述&lt;/a>如下：&lt;/p>
&lt;blockquote>
&lt;p>The server has fulfilled the request but does not need to return an
entity-body, and might want to return updated metainformation. The
response MAY include new or updated metainformation in the form of
entity-headers, which if present SHOULD be associated with the
requested variant.&lt;/p></description></item><item><title>InnoDB存储引擎对MVCC的实现</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/innodb-implementation-of-mvcc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/innodb-implementation-of-mvcc/</guid><description>&lt;h2 id="多版本并发控制-multi-version-concurrency-control">
 多版本并发控制 (Multi-Version Concurrency Control)
 &lt;a class="anchor" href="#%e5%a4%9a%e7%89%88%e6%9c%ac%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6-multi-version-concurrency-control">#&lt;/a>
&lt;/h2>
&lt;p>MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。&lt;/p>
&lt;p>1、读操作（SELECT）：&lt;/p>
&lt;p>当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体工作情况如下：&lt;/p>
&lt;ul>
&lt;li>对于读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。&lt;/li>
&lt;li>如果某个数据行有多个版本，事务会选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。&lt;/li>
&lt;li>事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。&lt;/li>
&lt;/ul>
&lt;p>2、写操作（INSERT、UPDATE、DELETE）：&lt;/p>
&lt;p>当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库。具体工作情况如下：&lt;/p>
&lt;ul>
&lt;li>对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。&lt;/li>
&lt;li>新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。&lt;/li>
&lt;li>原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。&lt;/li>
&lt;/ul>
&lt;p>3、事务提交和回滚：&lt;/p>
&lt;ul>
&lt;li>当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。&lt;/li>
&lt;li>当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。&lt;/li>
&lt;/ul>
&lt;p>4、版本的回收：&lt;/p>
&lt;p>为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。&lt;/p>
&lt;p>MVCC 通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。&lt;/p>
&lt;h2 id="一致性非锁定读和锁定读">
 一致性非锁定读和锁定读
 &lt;a class="anchor" href="#%e4%b8%80%e8%87%b4%e6%80%a7%e9%9d%9e%e9%94%81%e5%ae%9a%e8%af%bb%e5%92%8c%e9%94%81%e5%ae%9a%e8%af%bb">#&lt;/a>
&lt;/h2>
&lt;h3 id="一致性非锁定读">
 一致性非锁定读
 &lt;a class="anchor" href="#%e4%b8%80%e8%87%b4%e6%80%a7%e9%9d%9e%e9%94%81%e5%ae%9a%e8%af%bb">#&lt;/a>
&lt;/h3>
&lt;p>对于 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html">&lt;strong>一致性非锁定读（Consistent Nonlocking Reads）&lt;/strong>&lt;/a>的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见&lt;/p>
&lt;p>在 &lt;code>InnoDB&lt;/code> 存储引擎中，&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">多版本控制 (multi versioning)&lt;/a> 就是对非锁定读的实现。如果读取的行正在执行 &lt;code>DELETE&lt;/code> 或 &lt;code>UPDATE&lt;/code> 操作，这时读取操作不会去等待行上锁的释放。相反地，&lt;code>InnoDB&lt;/code> 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)&lt;/p>
&lt;p>在 &lt;code>Repeatable Read&lt;/code> 和 &lt;code>Read Committed&lt;/code> 两个隔离级别下，如果是执行普通的 &lt;code>select&lt;/code> 语句（不包括 &lt;code>select ... lock in share mode&lt;/code> ,&lt;code>select ... for update&lt;/code>）则会使用 &lt;code>一致性非锁定读（MVCC）&lt;/code>。并且在 &lt;code>Repeatable Read&lt;/code> 下 &lt;code>MVCC&lt;/code> 实现了可重复读和防止部分幻读&lt;/p></description></item><item><title>IoC &amp; AOP详解（快速搞懂）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/ioc-and-aop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/ioc-and-aop/</guid><description>&lt;p>这篇文章会从下面从以下几个问题展开对 IoC &amp;amp; AOP 的解释&lt;/p>
&lt;ul>
&lt;li>什么是 IoC？&lt;/li>
&lt;li>IoC 解决了什么问题？&lt;/li>
&lt;li>IoC 和 DI 的区别？&lt;/li>
&lt;li>什么是 AOP？&lt;/li>
&lt;li>AOP 解决了什么问题？&lt;/li>
&lt;li>AOP 的应用场景有哪些？&lt;/li>
&lt;li>AOP 为什么叫做切面编程？&lt;/li>
&lt;li>AOP 实现方式有哪些？&lt;/li>
&lt;/ul>
&lt;p>首先声明：IoC &amp;amp; AOP 不是 Spring 提出来的，它们在 Spring 之前其实已经存在了，只不过当时更加偏向于理论。Spring 在技术层次将这两个思想进行了很好的实现。&lt;/p>
&lt;h2 id="ioc-inversion-of-control-">
 IoC （Inversion of control ）
 &lt;a class="anchor" href="#ioc-inversion-of-control-">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是-ioc">
 什么是 IoC?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-ioc">#&lt;/a>
&lt;/h3>
&lt;p>IoC （Inversion of Control ）即控制反转/反转控制。它是一种思想不是一个技术实现。描述的是：Java 开发领域对象的创建以及管理的问题。&lt;/p>
&lt;p>例如：现有类 A 依赖于类 B&lt;/p>
&lt;ul>
&lt;li>&lt;strong>传统的开发方式&lt;/strong> ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来&lt;/li>
&lt;li>&lt;strong>使用 IoC 思想的开发方式&lt;/strong> ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面去取即可。&lt;/li>
&lt;/ul>
&lt;p>从以上两种开发方式的对比来看：我们 “丧失了一个权力” (创建、管理对象的权力)，从而也得到了一个好处（不用再考虑对象的创建、管理等一系列的事情）&lt;/p></description></item><item><title>Java 10 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java10/</guid><description>&lt;p>&lt;strong>Java 10&lt;/strong> 发布于 2018 年 3 月 20 日，最知名的特性应该是 &lt;code>var&lt;/code> 关键字（局部变量类型推断）的引入了，其他还有垃圾收集器改善、GC 改进、性能提升、线程管控等一批新特性。&lt;/p>
&lt;p>&lt;strong>概览（精选了一部分）&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/286">JEP 286：局部变量类型推断&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/304">JEP 304：垃圾回收器接口&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/307">JEP 307：G1 并行 Full GC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/310">JEP 310：应用程序类数据共享(扩展 CDS 功能)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/317">JEP 317：实验性的基于 Java 的 JIT 编译器&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="局部变量类型推断var">
 局部变量类型推断(var)
 &lt;a class="anchor" href="#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e7%b1%bb%e5%9e%8b%e6%8e%a8%e6%96%advar">#&lt;/a>
&lt;/h2>
&lt;p>由于太多 Java 开发者希望 Java 中引入局部变量推断，于是 Java 10 的时候它来了，也算是众望所归了！&lt;/p>
&lt;p>Java 10 提供了 &lt;code>var&lt;/code> 关键字声明局部变量。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> codefx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> URL(&lt;span style="color:#e6db74">&amp;#34;https://mp.weixin.qq.com/&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(1, 2, 3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> p &lt;span style="color:#f92672">=&lt;/span> Paths.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;src/test/java/Java9FeaturesTest.java&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> numbers &lt;span style="color:#f92672">=&lt;/span> List.&lt;span style="color:#a6e22e">of&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;b&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;c&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> n : list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>(n&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>var 关键字只能用于带有构造器的局部变量和 for 循环中。&lt;/p></description></item><item><title>Java 11 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java11/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java11/</guid><description>&lt;p>&lt;strong>Java 11&lt;/strong> 于 2018 年 9 月 25 日正式发布，这是很重要的一个版本！Java 11 和 2017 年 9 月份发布的 Java 9 以及 2018 年 3 月份发布的 Java 10 相比，其最大的区别就是：在长期支持(Long-Term-Support)方面，&lt;strong>Oracle 表示会对 Java 11 提供大力支持，这一支持将会持续至 2026 年 9 月。这是据 Java 8 以后支持的首个长期版本。&lt;/strong>&lt;/p>
&lt;p>下面这张图是 Oracle 官方给出的 Oracle JDK 支持的时间线。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/new-features/4c1611fad59449edbbd6e233690e9fa7.png" alt="" />&lt;/p>
&lt;p>&lt;strong>概览（精选了一部分）&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/321">JEP 321：HTTP Client 标准化&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/333">JEP 333：ZGC(可伸缩低延迟垃圾收集器)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/323">JEP 323：Lambda 参数的局部变量语法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/330">JEP 330：启动单文件源代码程序&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="http-client-标准化">
 HTTP Client 标准化
 &lt;a class="anchor" href="#http-client-%e6%a0%87%e5%87%86%e5%8c%96">#&lt;/a>
&lt;/h2>
&lt;p>Java 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化，在前两个版本中进行孵化的同时，Http Client 几乎被完全重写，并且现在完全支持异步非阻塞。&lt;/p></description></item><item><title>Java 12 &amp; 13 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java12-13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java12-13/</guid><description>&lt;h2 id="java12">
 Java12
 &lt;a class="anchor" href="#java12">#&lt;/a>
&lt;/h2>
&lt;h3 id="string-增强">
 String 增强
 &lt;a class="anchor" href="#string-%e5%a2%9e%e5%bc%ba">#&lt;/a>
&lt;/h3>
&lt;p>Java 12 增加了两个的字符串处理方法，如以下所示。&lt;/p>
&lt;p>&lt;code>indent()&lt;/code> 方法可以实现字符串缩进。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String text &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Java&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 缩进 4 格&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>text &lt;span style="color:#f92672">=&lt;/span> text.&lt;span style="color:#a6e22e">indent&lt;/span>(4);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(text);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>text &lt;span style="color:#f92672">=&lt;/span> text.&lt;span style="color:#a6e22e">indent&lt;/span>(&lt;span style="color:#f92672">-&lt;/span>10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(text);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span> Java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Java
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>transform()&lt;/code> 方法可以用来转变指定字符串。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;foo&amp;#34;&lt;/span>.&lt;span style="color:#a6e22e">transform&lt;/span>(input &lt;span style="color:#f92672">-&amp;gt;&lt;/span> input &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; bar&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(result); &lt;span style="color:#75715e">// foo bar&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="files-增强文件比较">
 Files 增强（文件比较）
 &lt;a class="anchor" href="#files-%e5%a2%9e%e5%bc%ba%e6%96%87%e4%bb%b6%e6%af%94%e8%be%83">#&lt;/a>
&lt;/h3>
&lt;p>Java 12 添加了以下方法来比较两个文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">mismatch&lt;/span>(Path path, Path path2) &lt;span style="color:#66d9ef">throws&lt;/span> IOException
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>mismatch()&lt;/code> 方法用于比较两个文件，并返回第一个不匹配字符的位置，如果文件相同则返回 -1L。&lt;/p>
&lt;p>代码示例（两个文件内容相同的情况）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Path filePath1 &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">createTempFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;file1&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;.txt&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Path filePath2 &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">createTempFile&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;file2&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;.txt&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">writeString&lt;/span>(filePath1, &lt;span style="color:#e6db74">&amp;#34;Java 12 Article&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Files.&lt;span style="color:#a6e22e">writeString&lt;/span>(filePath2, &lt;span style="color:#e6db74">&amp;#34;Java 12 Article&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> mismatch &lt;span style="color:#f92672">=&lt;/span> Files.&lt;span style="color:#a6e22e">mismatch&lt;/span>(filePath1, filePath2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>assertEquals(&lt;span style="color:#f92672">-&lt;/span>1, mismatch);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码示例（两个文件内容不相同的情况）：&lt;/p></description></item><item><title>Java 14 &amp; 15 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java14-15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java14-15/</guid><description>&lt;h2 id="java14">
 Java14
 &lt;a class="anchor" href="#java14">#&lt;/a>
&lt;/h2>
&lt;h3 id="空指针异常精准提示">
 空指针异常精准提示
 &lt;a class="anchor" href="#%e7%a9%ba%e6%8c%87%e9%92%88%e5%bc%82%e5%b8%b8%e7%b2%be%e5%87%86%e6%8f%90%e7%a4%ba">#&lt;/a>
&lt;/h3>
&lt;p>通过 JVM 参数中添加&lt;code>-XX:+ShowCodeDetailsInExceptionMessages&lt;/code>，可以在空指针异常中获取更为详细的调用信息，更快的定位和解决问题。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>a.&lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> 99; &lt;span style="color:#75715e">// 假设这段代码会发生空指针&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java 14 之前：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Exception in thread &lt;span style="color:#e6db74">&amp;#34;main&amp;#34;&lt;/span> java.&lt;span style="color:#a6e22e">lang&lt;/span>.&lt;span style="color:#a6e22e">NullPointerException&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at NullPointerExample.&lt;span style="color:#a6e22e">main&lt;/span>(NullPointerExample.&lt;span style="color:#a6e22e">java&lt;/span>:5)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Java 14 之后：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 增加参数后提示的异常中很明确的告知了哪里为空导致&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Exception in thread &lt;span style="color:#e6db74">&amp;#34;main&amp;#34;&lt;/span> java.&lt;span style="color:#a6e22e">lang&lt;/span>.&lt;span style="color:#a6e22e">NullPointerException&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Cannot read field &lt;span style="color:#e6db74">&amp;#39;c&amp;#39;&lt;/span> because &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>a.&lt;span style="color:#a6e22e">b&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span> is &lt;span style="color:#66d9ef">null&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> at Prog.&lt;span style="color:#a6e22e">main&lt;/span>(Prog.&lt;span style="color:#a6e22e">java&lt;/span>:5)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="switch-的增强转正">
 switch 的增强(转正)
 &lt;a class="anchor" href="#switch-%e7%9a%84%e5%a2%9e%e5%bc%ba%e8%bd%ac%e6%ad%a3">#&lt;/a>
&lt;/h3>
&lt;p>Java12 引入的 switch（预览特性）在 Java14 变为正式版本，不需要增加参数来启用，直接在 JDK14 中就能使用。&lt;/p>
&lt;p>Java12 为 switch 表达式引入了类似 lambda 语法条件匹配成功后的执行块，不需要多写 break ，Java13 提供了 &lt;code>yield&lt;/code> 来在 block 中返回值。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">switch&lt;/span> (day) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;M&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;W&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;F&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;MWF&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;T&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;TH&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;S&amp;#34;&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;TTS&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(day.&lt;span style="color:#a6e22e">isEmpty&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">yield&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Please insert a valid day.&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">yield&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Looks like a Sunday.&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(result);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="预览新特性">
 预览新特性
 &lt;a class="anchor" href="#%e9%a2%84%e8%a7%88%e6%96%b0%e7%89%b9%e6%80%a7">#&lt;/a>
&lt;/h3>
&lt;h4 id="record-关键字">
 record 关键字
 &lt;a class="anchor" href="#record-%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>
&lt;/h4>
&lt;p>&lt;code>record&lt;/code> 关键字可以简化 &lt;strong>数据类&lt;/strong>（一个 Java 类一旦实例化就不能再修改）的定义方式，使用 &lt;code>record&lt;/code> 代替 &lt;code>class&lt;/code> 定义的类，只需要声明属性，就可以在获得属性的访问方法，以及 &lt;code>toString()&lt;/code>，&lt;code>hashCode()&lt;/code>, &lt;code>equals()&lt;/code>方法。&lt;/p></description></item><item><title>Java 16 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java16/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java16/</guid><description>&lt;p>Java 16 在 2021 年 3 月 16 日正式发布，非长期支持（LTS）版本。&lt;/p>
&lt;p>相关阅读：&lt;a href="https://openjdk.java.net/projects/jdk/16/">OpenJDK Java 16 文档&lt;/a> 。&lt;/p>
&lt;h2 id="jep-338向量-api第一次孵化">
 JEP 338:向量 API(第一次孵化)
 &lt;a class="anchor" href="#jep-338%e5%90%91%e9%87%8f-api%e7%ac%ac%e4%b8%80%e6%ac%a1%e5%ad%b5%e5%8c%96">#&lt;/a>
&lt;/h2>
&lt;p>向量（Vector） API 最初由 &lt;a href="https://openjdk.java.net/jeps/338">JEP 338&lt;/a> 提出，并作为&lt;a href="http://openjdk.java.net/jeps/11">孵化 API&lt;/a>集成到 Java 16 中。第二轮孵化由 &lt;a href="https://openjdk.java.net/jeps/414">JEP 414&lt;/a> 提出并集成到 Java 17 中，第三轮孵化由 &lt;a href="https://openjdk.java.net/jeps/417">JEP 417&lt;/a> 提出并集成到 Java 18 中，第四轮由 &lt;a href="https://openjdk.java.net/jeps/426">JEP 426&lt;/a> 提出并集成到了 Java 19 中。&lt;/p>
&lt;p>该孵化器 API 提供了一个 API 的初始迭代以表达一些向量计算，这些计算在运行时可靠地编译为支持的 CPU 架构上的最佳向量硬件指令，从而获得优于同等标量计算的性能，充分利用单指令多数据（SIMD）技术（大多数现代 CPU 上都可以使用的一种指令）。尽管 HotSpot 支持自动向量化，但是可转换的标量操作集有限且易受代码更改的影响。该 API 将使开发人员能够轻松地用 Java 编写可移植的高性能向量算法。&lt;/p>
&lt;p>在 &lt;a href="./java18.md">Java 18 新特性概览&lt;/a> 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。&lt;/p>
&lt;h2 id="jep-347启用-c-14-语言特性">
 JEP 347:启用 C++ 14 语言特性
 &lt;a class="anchor" href="#jep-347%e5%90%af%e7%94%a8-c-14-%e8%af%ad%e8%a8%80%e7%89%b9%e6%80%a7">#&lt;/a>
&lt;/h2>
&lt;p>Java 16 允许在 JDK 的 C++ 源代码中使用 C++14 语言特性，并提供在 HotSpot 代码中可以使用哪些特性的具体指导。&lt;/p></description></item><item><title>Java 17 新特性概览（重要）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java17/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java17/</guid><description>&lt;p>Java 17 在 2021 年 9 月 14 日正式发布，是一个长期支持（LTS）版本。&lt;/p>
&lt;p>下面这张图是 Oracle 官方给出的 Oracle JDK 支持的时间线。可以看得到，Java&lt;/p>
&lt;p>17 最多可以支持到 2029 年 9 月份。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/new-features/4c1611fad59449edbbd6e233690e9fa7.png" alt="" />&lt;/p>
&lt;p>Java 17 将是继 Java 8 以来最重要的长期支持（LTS）版本，是 Java 社区八年努力的成果。Spring 6.x 和 Spring Boot 3.x 最低支持的就是 Java 17。&lt;/p>
&lt;p>这次更新共带来 14 个新特性：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/306">JEP 306:Restore Always-Strict Floating-Point Semantics（恢复始终严格的浮点语义）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/356">JEP 356:Enhanced Pseudo-Random Number Generators（增强的伪随机数生成器）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/382">JEP 382:New macOS Rendering Pipeline（新的 macOS 渲染管道）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/391">JEP 391:macOS/AArch64 Port（支持 macOS AArch64）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/398">JEP 398:Deprecate the Applet API for Removal（删除已弃用的 Applet API）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/403">JEP 403:Strongly Encapsulate JDK Internals（更强大的封装 JDK 内部元素）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/406">JEP 406:Pattern Matching for switch (switch 的类型匹配)&lt;/a>（预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/407">JEP 407:Remove RMI Activation（删除远程方法调用激活机制）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/409">JEP 409:Sealed Classes（密封类）&lt;/a>（转正）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/410">JEP 410:Remove the Experimental AOT and JIT Compiler（删除实验性的 AOT 和 JIT 编译器）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/411">JEP 411:Deprecate the Security Manager for Removal（弃用安全管理器以进行删除）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/412">JEP 412:Foreign Function &amp;amp; Memory API (外部函数和内存 API)&lt;/a>（孵化）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/417">JEP 414:Vector（向量） API&lt;/a>（第二次孵化）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/415">JEP 415:Context-Specific Deserialization Filters&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这里只对 356、398、413、406、407、409、410、411、412、414 这几个我觉得比较重要的新特性进行详细介绍。&lt;/p></description></item><item><title>Java 18 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java18/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java18/</guid><description>&lt;p>Java 18 在 2022 年 3 月 22 日正式发布，非长期支持版本。&lt;/p>
&lt;p>Java 18 带来了 9 个新特性：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/400">JEP 400:UTF-8 by Default（默认字符集为 UTF-8）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/408">JEP 408:Simple Web Server（简易的 Web 服务器）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/413">JEP 413:Code Snippets in Java API Documentation（Java API 文档中的代码片段）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/416">JEP 416:Reimplement Core Reflection with Method Handles（使用方法句柄重新实现反射核心）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/417">JEP 417:Vector（向量） API&lt;/a>（第三次孵化）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/418">JEP 418:Internet-Address Resolution（互联网地址解析）SPI&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/419">JEP 419:Foreign Function &amp;amp; Memory API（外部函数和内存 API）&lt;/a>（第二次孵化）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/420">JEP 420:Pattern Matching for switch（switch 模式匹配）&lt;/a>（第二次预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/421">JEP 421:Deprecate Finalization for Removal&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>Java 17 中包含 14 个特性，Java 16 中包含 17 个特性，Java 15 中包含 14 个特性，Java 14 中包含 16 个特性。相比于前面发布的版本来说，Java 18 的新特性少了很多。&lt;/p></description></item><item><title>Java 19 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java19/</guid><description>&lt;p>JDK 19 定于 2022 年 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。&lt;/p>
&lt;p>JDK 19 只有 7 个新特性：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.org/jeps/405">JEP 405: Record Patterns（记录模式）&lt;/a>（预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/422">JEP 422: Linux/RISC-V Port&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/424">JEP 424: Foreign Function &amp;amp; Memory API（外部函数和内存 API）&lt;/a>（预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/425">JEP 425: Virtual Threads（虚拟线程）&lt;/a>（预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/426">JEP 426: Vector（向量）API&lt;/a>（第四次孵化）&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/427">JEP 427: Pattern Matching for switch（switch 模式匹配）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/428">JEP 428: Structured Concurrency（结构化并发）&lt;/a>（孵化）&lt;/li>
&lt;/ul>
&lt;p>这里只对 424、425、426、428 这 4 个我觉得比较重要的新特性进行详细介绍。&lt;/p>
&lt;p>相关阅读：&lt;a href="https://openjdk.org/projects/jdk/19/">OpenJDK Java 19 文档&lt;/a>&lt;/p>
&lt;h2 id="jep-424-外部函数和内存-api预览">
 JEP 424: 外部函数和内存 API（预览）
 &lt;a class="anchor" href="#jep-424-%e5%a4%96%e9%83%a8%e5%87%bd%e6%95%b0%e5%92%8c%e5%86%85%e5%ad%98-api%e9%a2%84%e8%a7%88">#&lt;/a>
&lt;/h2>
&lt;p>Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。&lt;/p></description></item><item><title>Java 20 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java20/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java20/</guid><description>&lt;p>JDK 20 于 2023 年 3 月 21 日发布，非长期支持版本。&lt;/p>
&lt;p>根据开发计划，下一个 LTS 版本就是将于 2023 年 9 月发布的 JDK 21。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/new-features/640.png" alt="" />&lt;/p>
&lt;p>JDK 20 只有 7 个新特性：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.org/jeps/429">JEP 429：Scoped Values（作用域值）&lt;/a>（第一次孵化）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/432">JEP 432：Record Patterns（记录模式）&lt;/a>（第二次预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/433">JEP 433：switch 模式匹配&lt;/a>（第四次预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/434">JEP 434: Foreign Function &amp;amp; Memory API（外部函数和内存 API）&lt;/a>（第二次预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/436">JEP 436: Virtual Threads（虚拟线程）&lt;/a>（第二次预览）&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/437">JEP 437:Structured Concurrency（结构化并发）&lt;/a>(第二次孵化)&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/438">JEP 432:向量 API（&lt;/a>第五次孵化）&lt;/li>
&lt;/ul>
&lt;h2 id="jep-429作用域值第一次孵化">
 JEP 429：作用域值（第一次孵化）
 &lt;a class="anchor" href="#jep-429%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%80%bc%e7%ac%ac%e4%b8%80%e6%ac%a1%e5%ad%b5%e5%8c%96">#&lt;/a>
&lt;/h2>
&lt;p>作用域值（Scoped Values）它可以在线程内和线程间共享不可变的数据，优于线程局部变量，尤其是在使用大量虚拟线程时。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ScopedValue&lt;span style="color:#f92672">&amp;lt;&lt;/span>...&lt;span style="color:#f92672">&amp;gt;&lt;/span> V &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ScopedValue&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// In some method&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ScopedValue.&lt;span style="color:#a6e22e">where&lt;/span>(V, &lt;span style="color:#f92672">&amp;lt;&lt;/span>value&lt;span style="color:#f92672">&amp;gt;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">run&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> { ... V.&lt;span style="color:#a6e22e">get&lt;/span>() ... call methods ... });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// In a method called directly or indirectly from the lambda expression&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>... V.&lt;span style="color:#a6e22e">get&lt;/span>() ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>作用域值允许在大型程序中的组件之间安全有效地共享数据，而无需求助于方法参数。&lt;/p></description></item><item><title>Java 21 新特性概览(重要)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java21/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java21/</guid><description>&lt;p>JDK 21 于 2023 年 9 月 19 日 发布，这是一个非常重要的版本，里程碑式。&lt;/p>
&lt;p>JDK21 是 LTS（长期支持版），至此为止，目前有 JDK8、JDK11、JDK17 和 JDK21 这四个长期支持版了。&lt;/p>
&lt;p>JDK 21 共有 15 个新特性，这篇文章会挑选其中较为重要的一些新特性进行详细介绍：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/430">JEP 430：String Templates（字符串模板）&lt;/a>（预览）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/431">JEP 431：Sequenced Collections（序列化集合）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/439">JEP 439：Generational ZGC（分代 ZGC）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/440">JEP 440：Record Patterns（记录模式）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/442">JEP 441：Pattern Matching for switch（switch 的模式匹配）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/442">JEP 442：Foreign Function &amp;amp; Memory API（外部函数和内存 API）&lt;/a>（第三次预览）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/443">JEP 443：Unnamed Patterns and Variables（未命名模式和变量&lt;/a>（预览）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/444">JEP 444：Virtual Threads（虚拟线程）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://openjdk.org/jeps/445">JEP 445：Unnamed Classes and Instance Main Methods（未命名类和实例 main 方法 ）&lt;/a>（预览）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="jep-430字符串模板预览">
 JEP 430：字符串模板（预览）
 &lt;a class="anchor" href="#jep-430%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%a8%a1%e6%9d%bf%e9%a2%84%e8%a7%88">#&lt;/a>
&lt;/h2>
&lt;p>String Templates(字符串模板) 目前仍然是 JDK 21 中的一个预览功能。&lt;/p></description></item><item><title>Java 22 &amp; 23 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java22-23/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java22-23/</guid><description>&lt;p>JDK 23 和 JDK 22 一样，这也是一个非 LTS（长期支持）版本，Oracle 仅提供六个月的支持。下一个长期支持版是 JDK 25，预计明年 9 月份发布。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/new-features/jdk8~jdk24.png" alt="" />&lt;/p>
&lt;p>由于 JDK 22 和 JDK 23 重合的新特性较多，这里主要以 JDK 23 为主介绍，会补充 JDK 22 独有的一些特性。&lt;/p>
&lt;p>JDK 23 一共有 12 个新特性：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.org/jeps/455">JEP 455: 模式中的原始类型、instanceof 和 switch（预览）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/466">JEP 456: 类文件 API（第二次预览）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/467">JEP 467：Markdown 文档注释&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/469">JEP 469：向量 API（第八次孵化）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/473">JEP 473：流收集器（第二次预览）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/471">JEP 471：弃用 sun.misc.Unsafe 中的内存访问方法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/474">JEP 474：ZGC：默认的分代模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/476">JEP 476：模块导入声明 (预览)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/477">JEP 477：未命名类和实例 main 方法 （第三次预览）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/480">JEP 480：结构化并发 （第三次预览）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/481">JEP 481： 作用域值 （第三次预览）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.org/jeps/482">JEP 482：灵活的构造函数体（第二次预览）&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>JDK 22 的新特性如下：&lt;/p></description></item><item><title>Java 9 新特性概览</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java9/</guid><description>&lt;p>&lt;strong>Java 9&lt;/strong> 发布于 2017 年 9 月 21 日 。作为 Java 8 之后 3 年半才发布的新版本，Java 9 带来了很多重大的变化其中最重要的改动是 Java 平台模块系统的引入，其他还有诸如集合、&lt;code>Stream&lt;/code> 流……。&lt;/p>
&lt;p>你可以在 &lt;a href="http://jdk.java.net/archive/">Archived OpenJDK General-Availability Releases&lt;/a> 上下载自己需要的 JDK 版本！官方的新特性说明文档地址：&lt;a href="https://openjdk.java.net/projects/jdk/">https://openjdk.java.net/projects/jdk/&lt;/a> 。&lt;/p>
&lt;p>&lt;strong>概览（精选了一部分）&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/222">JEP 222: Java 命令行工具&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/261">JEP 261: 模块化系统&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/248">JEP 248：G1 成为默认垃圾回收器&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/193">JEP 193: 变量句柄&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openjdk.java.net/jeps/254">JEP 254：字符串存储结构优化&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="jshell">
 JShell
 &lt;a class="anchor" href="#jshell">#&lt;/a>
&lt;/h2>
&lt;p>JShell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。&lt;/p>
&lt;p>在 JShell 中可以直接输入表达式并查看其执行结果。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/java-guide-blog/image-20210816083417616.png" alt="" />&lt;/p>
&lt;p>&lt;strong>JShell 为我们带来了哪些好处呢？&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>降低了输出第一行 Java 版&amp;quot;Hello World！&amp;ldquo;的门槛，能够提高新手的学习热情。&lt;/li>
&lt;li>在处理简单的小逻辑，验证简单的小问题时，比 IDE 更有效率（并不是为了取代 IDE，对于复杂逻辑的验证，IDE 更合适，两者互补）。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>JShell 的代码和普通的可编译代码，有什么不一样？&lt;/strong>&lt;/p></description></item><item><title>Java IO 基础知识总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/io/io-basis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/io/io-basis/</guid><description>&lt;h2 id="io-流简介">
 IO 流简介
 &lt;a class="anchor" href="#io-%e6%b5%81%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;p>IO 即 &lt;code>Input/Output&lt;/code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。&lt;/p>
&lt;p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。&lt;/p>
&lt;ul>
&lt;li>&lt;code>InputStream&lt;/code>/&lt;code>Reader&lt;/code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。&lt;/li>
&lt;li>&lt;code>OutputStream&lt;/code>/&lt;code>Writer&lt;/code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。&lt;/li>
&lt;/ul>
&lt;h2 id="字节流">
 字节流
 &lt;a class="anchor" href="#%e5%ad%97%e8%8a%82%e6%b5%81">#&lt;/a>
&lt;/h2>
&lt;h3 id="inputstream字节输入流">
 InputStream（字节输入流）
 &lt;a class="anchor" href="#inputstream%e5%ad%97%e8%8a%82%e8%be%93%e5%85%a5%e6%b5%81">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>InputStream&lt;/code>用于从源头（通常是文件）读取数据（字节信息）到内存中，&lt;code>java.io.InputStream&lt;/code>抽象类是所有字节输入流的父类。&lt;/p>
&lt;p>&lt;code>InputStream&lt;/code> 常用方法：&lt;/p>
&lt;ul>
&lt;li>&lt;code>read()&lt;/code>：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 &lt;code>-1&lt;/code> ，表示文件结束。&lt;/li>
&lt;li>&lt;code>read(byte b[ ])&lt;/code> : 从输入流中读取一些字节存储到数组 &lt;code>b&lt;/code> 中。如果数组 &lt;code>b&lt;/code> 的长度为零，则不读取。如果没有可用字节读取，返回 &lt;code>-1&lt;/code>。如果有可用字节读取，则最多读取的字节数最多等于 &lt;code>b.length&lt;/code> ， 返回读取的字节数。这个方法等价于 &lt;code>read(b, 0, b.length)&lt;/code>。&lt;/li>
&lt;li>&lt;code>read(byte b[], int off, int len)&lt;/code>：在&lt;code>read(byte b[ ])&lt;/code> 方法的基础上增加了 &lt;code>off&lt;/code> 参数（偏移量）和 &lt;code>len&lt;/code> 参数（要读取的最大字节数）。&lt;/li>
&lt;li>&lt;code>skip(long n)&lt;/code>：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。&lt;/li>
&lt;li>&lt;code>available()&lt;/code>：返回输入流中可以读取的字节数。&lt;/li>
&lt;li>&lt;code>close()&lt;/code>：关闭输入流释放相关的系统资源。&lt;/li>
&lt;/ul>
&lt;p>从 Java 9 开始，&lt;code>InputStream&lt;/code> 新增加了多个实用的方法：&lt;/p></description></item><item><title>Java IO 模型详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/io/io-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/io/io-model/</guid><description>&lt;p>IO 模型这块确实挺难理解的，需要太多计算机底层知识。写这篇文章用了挺久，就非常希望能把我所知道的讲出来吧!希望朋友们能有收获！为了写这篇文章，还翻看了一下《UNIX 网络编程》这本书，太难了，我滴乖乖！心痛~&lt;/p>
&lt;p>&lt;em>个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！&lt;/em>&lt;/p>
&lt;h2 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>I/O 一直是很多小伙伴难以理解的一个知识点，这篇文章我会将我所理解的 I/O 讲给你听，希望可以对你有所帮助。&lt;/p>
&lt;h2 id="io">
 I/O
 &lt;a class="anchor" href="#io">#&lt;/a>
&lt;/h2>
&lt;h3 id="何为-io">
 何为 I/O?
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba-io">#&lt;/a>
&lt;/h3>
&lt;p>I/O（&lt;strong>I&lt;/strong>nput/&lt;strong>O&lt;/strong>utput） 即&lt;strong>输入／输出&lt;/strong> 。&lt;/p>
&lt;p>&lt;strong>我们先从计算机结构的角度来解读一下 I/O。&lt;/strong>&lt;/p>
&lt;p>根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/io/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9pcy1jbG91ZC5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70.jpeg" alt="冯诺依曼体系结构" />&lt;/p>
&lt;p>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。&lt;/p>
&lt;p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。&lt;/p>
&lt;p>&lt;strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>我们再先从应用程序的角度来解读一下 I/O。&lt;/strong>&lt;/p>
&lt;p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 &lt;strong>用户空间（User space）&lt;/strong> 和 &lt;strong>内核空间（Kernel space ）&lt;/strong> 。&lt;/p>
&lt;p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。&lt;/p>
&lt;p>并且，用户空间的程序不能直接访问内核空间。&lt;/p>
&lt;p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。&lt;/p>
&lt;p>因此，用户进程想要执行 IO 操作的话，必须通过 &lt;strong>系统调用&lt;/strong> 来间接访问内核空间&lt;/p>
&lt;p>我们在平常开发过程中接触最多的就是 &lt;strong>磁盘 IO（读写文件）&lt;/strong> 和 &lt;strong>网络 IO（网络请求和响应）&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。&lt;/strong>&lt;/p>
&lt;p>当应用程序发起 I/O 调用后，会经历两个步骤：&lt;/p></description></item><item><title>Java IO 设计模式总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/io/io-design-patterns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/io/io-design-patterns/</guid><description>&lt;p>这篇文章我们简单来看看我们从 IO 中能够学习到哪些设计模式的应用。&lt;/p>
&lt;h2 id="装饰器模式">
 装饰器模式
 &lt;a class="anchor" href="#%e8%a3%85%e9%a5%b0%e5%99%a8%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>装饰器（Decorator）模式&lt;/strong> 可以在不改变原有对象的情况下拓展其功能。&lt;/p>
&lt;p>装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。&lt;/p>
&lt;p>对于字节流来说， &lt;code>FilterInputStream&lt;/code> （对应输入流）和&lt;code>FilterOutputStream&lt;/code>（对应输出流）是装饰器模式的核心，分别用于增强 &lt;code>InputStream&lt;/code> 和&lt;code>OutputStream&lt;/code>子类对象的功能。&lt;/p>
&lt;p>我们常见的&lt;code>BufferedInputStream&lt;/code>(字节缓冲输入流)、&lt;code>DataInputStream&lt;/code> 等等都是&lt;code>FilterInputStream&lt;/code> 的子类，&lt;code>BufferedOutputStream&lt;/code>（字节缓冲输出流）、&lt;code>DataOutputStream&lt;/code>等等都是&lt;code>FilterOutputStream&lt;/code>的子类。&lt;/p>
&lt;p>举个例子，我们可以通过 &lt;code>BufferedInputStream&lt;/code>（字节缓冲输入流）来增强 &lt;code>FileInputStream&lt;/code> 的功能。&lt;/p>
&lt;p>&lt;code>BufferedInputStream&lt;/code> 构造函数如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">BufferedInputStream&lt;/span>(InputStream in) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>(in, DEFAULT_BUFFER_SIZE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">BufferedInputStream&lt;/span>(InputStream in, &lt;span style="color:#66d9ef">int&lt;/span> size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">super&lt;/span>(in);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (size &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> IllegalArgumentException(&lt;span style="color:#e6db74">&amp;#34;Buffer size &amp;lt;= 0&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[&lt;/span>size&lt;span style="color:#f92672">]&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看出，&lt;code>BufferedInputStream&lt;/code> 的构造函数其中的一个参数就是 &lt;code>InputStream&lt;/code> 。&lt;/p>
&lt;p>&lt;code>BufferedInputStream&lt;/code> 代码示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> (BufferedInputStream bis &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedInputStream(&lt;span style="color:#66d9ef">new&lt;/span> FileInputStream(&lt;span style="color:#e6db74">&amp;#34;input.txt&amp;#34;&lt;/span>))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> content;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> skip &lt;span style="color:#f92672">=&lt;/span> bis.&lt;span style="color:#a6e22e">skip&lt;/span>(2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> ((content &lt;span style="color:#f92672">=&lt;/span> bis.&lt;span style="color:#a6e22e">read&lt;/span>()) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">print&lt;/span>((&lt;span style="color:#66d9ef">char&lt;/span>) content);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">catch&lt;/span> (IOException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e.&lt;span style="color:#a6e22e">printStackTrace&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个时候，你可以会想了：&lt;strong>为啥我们直接不弄一个&lt;code>BufferedFileInputStream&lt;/code>（字符缓冲文件输入流）呢？&lt;/strong>&lt;/p></description></item><item><title>Java NIO 核心知识总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/io/nio-basis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/io/nio-basis/</guid><description>&lt;p>在学习 NIO 之前，需要先了解一下计算机 I/O 模型的基础理论知识。还不了解的话，可以参考我写的这篇文章：&lt;a href="https://javaguide.cn/java/io/io-model.html">Java IO 模型详解&lt;/a>。&lt;/p>
&lt;h2 id="nio-简介">
 NIO 简介
 &lt;a class="anchor" href="#nio-%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;p>在传统的 Java I/O 模型（BIO）中，I/O 操作是以阻塞的方式进行的。也就是说，当一个线程执行一个 I/O 操作时，它会被阻塞直到操作完成。这种阻塞模型在处理多个并发连接时可能会导致性能瓶颈，因为需要为每个连接创建一个线程，而线程的创建和切换都是有开销的。&lt;/p>
&lt;p>为了解决这个问题，在 Java1.4 版本引入了一种新的 I/O 模型 — &lt;strong>NIO&lt;/strong> （New IO，也称为 Non-blocking IO） 。NIO 弥补了同步阻塞 I/O 的不足，它在标准 Java 代码中提供了非阻塞、面向缓冲、基于通道的 I/O，可以使用少量的线程来处理多个连接，大大提高了 I/O 效率和并发。&lt;/p>
&lt;p>下图是 BIO、NIO 和 AIO 处理客户端请求的简单对比图（关于 AIO 的介绍，可以看我写的这篇文章：&lt;a href="https://javaguide.cn/java/io/io-model.html">Java IO 模型详解&lt;/a>，不是重点，了解即可）。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/nio/bio-aio-nio.png" alt="BIO、NIO 和 AIO 对比" />&lt;/p>
&lt;p>⚠️需要注意：使用 NIO 并不一定意味着高性能，它的性能优势主要体现在高并发和高延迟的网络环境下。当连接数较少、并发程度较低或者网络传输速度较快时，NIO 的性能并不一定优于传统的 BIO 。&lt;/p>
&lt;h2 id="nio-核心组件">
 NIO 核心组件
 &lt;a class="anchor" href="#nio-%e6%a0%b8%e5%bf%83%e7%bb%84%e4%bb%b6">#&lt;/a>
&lt;/h2>
&lt;p>NIO 主要包括以下三个核心组件：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Buffer（缓冲区）&lt;/strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。&lt;/li>
&lt;li>&lt;strong>Channel（通道）&lt;/strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。&lt;/li>
&lt;li>&lt;strong>Selector（选择器）&lt;/strong>：允许一个线程处理多个 Channel，基于事件驱动的 I/O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。&lt;/li>
&lt;/ul>
&lt;p>三者的关系如下图所示（暂时不理解没关系，后文会详细介绍）：&lt;/p></description></item><item><title>Java SPI 机制详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/spi/</guid><description>&lt;blockquote>
&lt;p>本文来自 &lt;a href="https://github.com/jjx0708">Kingshion&lt;/a> 投稿。欢迎更多朋友参与到 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：&lt;a href="https://javaguide.cn/javaguide/contribution-guideline.html">JavaGuide 贡献指南&lt;/a> 。&lt;/p>
&lt;/blockquote>
&lt;p>面向对象设计鼓励模块间基于接口而非具体实现编程，以降低模块间的耦合，遵循依赖倒置原则，并支持开闭原则（对扩展开放，对修改封闭）。然而，直接依赖具体实现会导致在替换实现时需要修改代码，违背了开闭原则。为了解决这个问题，SPI 应运而生，它提供了一种服务发现机制，允许在程序外部动态指定具体实现。这与控制反转（IoC）的思想相似，将组件装配的控制权移交给了程序之外。&lt;/p>
&lt;p>SPI 机制也解决了 Java 类加载体系中双亲委派模型带来的限制。&lt;a href="https://javaguide.cn/java/jvm/classloader.html">双亲委派模型&lt;/a>虽然保证了核心库的安全性和一致性，但也限制了核心库或扩展库加载应用程序类路径上的类（通常由第三方实现）。SPI 允许核心或扩展库定义服务接口，第三方开发者提供并部署实现，SPI 服务加载机制则在运行时动态发现并加载这些实现。例如，JDBC 4.0 及之后版本利用 SPI 自动发现和加载数据库驱动，开发者只需将驱动 JAR 包放置在类路径下即可，无需使用&lt;code>Class.forName()&lt;/code>显式加载驱动类。&lt;/p>
&lt;h2 id="spi-介绍">
 SPI 介绍
 &lt;a class="anchor" href="#spi-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;h3 id="何谓-spi">
 何谓 SPI?
 &lt;a class="anchor" href="#%e4%bd%95%e8%b0%93-spi">#&lt;/a>
&lt;/h3>
&lt;p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。&lt;/p>
&lt;p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。&lt;/p>
&lt;p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。
&lt;img src="https://oss.javaguide.cn/github/javaguide/java/basis/spi/22e1830e0b0e4115a882751f6c417857tplv-k3u1fbpfcp-zoom-1.jpeg" alt="SPI VS API" />&lt;/p>
&lt;h3 id="spi-和-api-有什么区别">
 SPI 和 API 有什么区别？
 &lt;a class="anchor" href="#spi-%e5%92%8c-api-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>那 SPI 和 API 有啥区别？&lt;/strong>&lt;/p>
&lt;p>说到 SPI 就不得不说一下 API（Application Programming Interface） 了，从广义上来说它们都属于接口，而且很容易混淆。下面先用一张图说明一下：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/basis/spi-vs-api.png" alt="SPI VS API" />&lt;/p>
&lt;p>一般模块之间都是通过接口进行通讯，因此我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。&lt;/p>
&lt;ul>
&lt;li>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 &lt;strong>API&lt;/strong>。这种情况下，接口和实现都是放在实现方的包中。调用方通过接口调用实现方的功能，而不需要关心具体的实现细节。&lt;/li>
&lt;li>当接口存在于调用方这边时，这就是 &lt;strong>SPI&lt;/strong> 。由接口调用方确定接口规则，然后由不同的厂商根据这个规则对这个接口进行实现，从而提供服务。&lt;/li>
&lt;/ul>
&lt;p>举个通俗易懂的例子：公司 H 是一家科技公司，新设计了一款芯片，然后现在需要量产了，而市面上有好几家芯片制造业公司，这个时候，只要 H 公司指定好了这芯片生产的标准（定义好了接口标准），那么这些合作的芯片公司（服务提供者）就按照标准交付自家特色的芯片（提供不同方案的实现，但是给出来的结果是一样的）。&lt;/p></description></item><item><title>Java 常见并发容器总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/java-concurrent-collections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/java-concurrent-collections/</guid><description>&lt;p>JDK 提供的这些容器大部分在 &lt;code>java.util.concurrent&lt;/code> 包中。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>ConcurrentHashMap&lt;/code>&lt;/strong> : 线程安全的 &lt;code>HashMap&lt;/code>&lt;/li>
&lt;li>&lt;strong>&lt;code>CopyOnWriteArrayList&lt;/code>&lt;/strong> : 线程安全的 &lt;code>List&lt;/code>，在读多写少的场合性能非常好，远远好于 &lt;code>Vector&lt;/code>。&lt;/li>
&lt;li>&lt;strong>&lt;code>ConcurrentLinkedQueue&lt;/code>&lt;/strong> : 高效的并发队列，使用链表实现。可以看做一个线程安全的 &lt;code>LinkedList&lt;/code>，这是一个非阻塞队列。&lt;/li>
&lt;li>&lt;strong>&lt;code>BlockingQueue&lt;/code>&lt;/strong> : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。&lt;/li>
&lt;li>&lt;strong>&lt;code>ConcurrentSkipListMap&lt;/code>&lt;/strong> : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。&lt;/li>
&lt;/ul>
&lt;h2 id="concurrenthashmap">
 ConcurrentHashMap
 &lt;a class="anchor" href="#concurrenthashmap">#&lt;/a>
&lt;/h2>
&lt;p>我们知道，&lt;code>HashMap&lt;/code> 是线程不安全的，如果在并发场景下使用，一种常见的解决方式是通过 &lt;code>Collections.synchronizedMap()&lt;/code> 方法对 &lt;code>HashMap&lt;/code> 进行包装，使其变为线程安全。不过，这种方式是通过一个全局锁来同步不同线程间的并发访问，会导致严重的性能瓶颈，尤其是在高并发场景下。&lt;/p>
&lt;p>为了解决这一问题，&lt;code>ConcurrentHashMap&lt;/code> 应运而生，作为 &lt;code>HashMap&lt;/code> 的线程安全版本，它提供了更高效的并发处理能力。&lt;/p>
&lt;p>在 JDK1.7 的时候，&lt;code>ConcurrentHashMap&lt;/code> 对整个桶数组进行了分割分段(&lt;code>Segment&lt;/code>，分段锁)，每一把锁只锁容器其中一部分数据（下面有示意图），多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png" alt="Java7 ConcurrentHashMap 存储结构" />&lt;/p>
&lt;p>到了 JDK1.8 的时候，&lt;code>ConcurrentHashMap&lt;/code> 取消了 &lt;code>Segment&lt;/code> 分段锁，采用 &lt;code>Node + CAS + synchronized&lt;/code> 来保证并发安全。数据结构跟 &lt;code>HashMap&lt;/code> 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。&lt;/p>
&lt;p>Java 8 中，锁粒度更细，&lt;code>synchronized&lt;/code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。&lt;/p></description></item><item><title>Java 代理模式详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/proxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/proxy/</guid><description>&lt;h2 id="1-代理模式">
 1. 代理模式
 &lt;a class="anchor" href="#1-%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>代理模式是一种比较好理解的设计模式。简单来说就是 &lt;strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。&lt;/strong>&lt;/p>
&lt;p>举个例子：新娘找来了自己的姨妈来代替自己处理新郎的提问，新娘收到的提问都是经过姨妈处理过滤之后的。姨妈在这里就可以看作是代理你的代理对象，代理的行为（方法）是接收和回复新郎的提问。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/2020-8/1*DjWCgTFm-xqbhbNQVsaWQw.png" alt="Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium" />&lt;/p>
&lt;p style="text-align:right;font-size:13px;color:gray">https://medium.com/@mithunsasidharan/understanding-the-proxy-design-pattern-5e63fe38052a&lt;/p> 
&lt;p>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。&lt;/p>
&lt;h2 id="2-静态代理">
 2. 静态代理
 &lt;a class="anchor" href="#2-%e9%9d%99%e6%80%81%e4%bb%a3%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（&lt;em>后面会具体演示代码&lt;/em>），非常不灵活（&lt;em>比如接口一旦新增加方法，目标对象和代理对象都要进行修改&lt;/em>）且麻烦(&lt;em>需要对每个目标类都单独写一个代理类&lt;/em>）。&lt;/strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。&lt;/p>
&lt;p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， &lt;strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。&lt;/strong>&lt;/p>
&lt;p>静态代理实现步骤:&lt;/p>
&lt;ol>
&lt;li>定义一个接口及其实现类；&lt;/li>
&lt;li>创建一个代理类同样实现这个接口&lt;/li>
&lt;li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。&lt;/li>
&lt;/ol>
&lt;p>下面通过代码展示！&lt;/p>
&lt;p>&lt;strong>1.定义发送短信的接口&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">SmsService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String &lt;span style="color:#a6e22e">send&lt;/span>(String message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>2.实现发送短信的接口&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SmsServiceImpl&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> SmsService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">send&lt;/span>(String message) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;send message:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> message;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>3.创建代理类并同样实现发送短信的接口&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SmsProxy&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> SmsService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> SmsService smsService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">SmsProxy&lt;/span>(SmsService smsService) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">smsService&lt;/span> &lt;span style="color:#f92672">=&lt;/span> smsService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">send&lt;/span>(String message) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//调用方法之前，我们可以添加自己的操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;before method send()&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> smsService.&lt;span style="color:#a6e22e">send&lt;/span>(message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//调用方法之后，我们同样可以添加自己的操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;after method send()&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>4.实际使用&lt;/strong>&lt;/p></description></item><item><title>Java 定时任务详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/schedule-task/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/schedule-task/</guid><description>&lt;h2 id="为什么需要定时任务">
 为什么需要定时任务？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1">#&lt;/a>
&lt;/h2>
&lt;p>我们来看一下几个非常常见的业务场景：&lt;/p>
&lt;ol>
&lt;li>某系统凌晨 1 点要进行数据备份。&lt;/li>
&lt;li>某电商平台，用户下单半个小时未支付的情况下需要自动取消订单。&lt;/li>
&lt;li>某媒体聚合平台，每 10 分钟动态抓取某某网站的数据为自己所用。&lt;/li>
&lt;li>某博客平台，支持定时发送文章。&lt;/li>
&lt;li>某基金平台，每晚定时计算用户当日收益情况并推送给用户最新的数据。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ol>
&lt;p>这些场景往往都要求我们在某个特定的时间去做某个事情，也就是定时或者延时去做某个事情。&lt;/p>
&lt;ul>
&lt;li>定时任务：在指定时间点执行特定的任务，例如每天早上 8 点，每周一下午 3 点等。定时任务可以用来做一些周期性的工作，如数据备份，日志清理，报表生成等。&lt;/li>
&lt;li>延时任务：一定的延迟时间后执行特定的任务，例如 10 分钟后，3 小时后等。延时任务可以用来做一些异步的工作，如订单取消，推送通知，红包撤回等。&lt;/li>
&lt;/ul>
&lt;p>尽管二者的适用场景有所区别，但它们的核心思想都是将任务的执行时间安排在未来的某个点上，以达到预期的调度效果。&lt;/p>
&lt;h2 id="单机定时任务">
 单机定时任务
 &lt;a class="anchor" href="#%e5%8d%95%e6%9c%ba%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1">#&lt;/a>
&lt;/h2>
&lt;h3 id="timer">
 Timer
 &lt;a class="anchor" href="#timer">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>java.util.Timer&lt;/code>是 JDK 1.3 开始就已经支持的一种定时任务的实现方式。&lt;/p>
&lt;p>&lt;code>Timer&lt;/code> 内部使用一个叫做 &lt;code>TaskQueue&lt;/code> 的类存放定时任务，它是一个基于最小堆实现的优先级队列。&lt;code>TaskQueue&lt;/code> 会按照任务距离下一次执行时间的大小将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次只需要取出堆顶的任务运行即可！&lt;/p>
&lt;p>&lt;code>Timer&lt;/code> 使用起来比较简单，通过下面的方式我们就能创建一个 1s 之后执行的定时任务。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 示例代码：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TimerTask task &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> TimerTask() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;当前时间: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Date() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;线程名称: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Thread.&lt;span style="color:#a6e22e">currentThread&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;当前时间: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Date() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;n&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;线程名称: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Thread.&lt;span style="color:#a6e22e">currentThread&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Timer timer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Timer(&lt;span style="color:#e6db74">&amp;#34;Timer&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> delay &lt;span style="color:#f92672">=&lt;/span> 1000L;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>timer.&lt;span style="color:#a6e22e">schedule&lt;/span>(task, delay);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//输出：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>当前时间: Fri May 28 15:18:47 CST 2021n线程名称: main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>当前时间: Fri May 28 15:18:48 CST 2021n线程名称: Timer
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不过其缺陷较多，比如一个 &lt;code>Timer&lt;/code> 一个线程，这就导致 &lt;code>Timer&lt;/code> 的任务的执行只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止（&lt;code>Timer&lt;/code> 只捕获了 &lt;code>InterruptedException&lt;/code> ）。&lt;/p></description></item><item><title>Java 反射机制详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/reflection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/reflection/</guid><description>&lt;h2 id="何为反射">
 何为反射？
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba%e5%8f%8d%e5%b0%84">#&lt;/a>
&lt;/h2>
&lt;p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。&lt;/p>
&lt;p>反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。&lt;/p>
&lt;p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。&lt;/p>
&lt;h2 id="反射的应用场景了解么">
 反射的应用场景了解么？
 &lt;a class="anchor" href="#%e5%8f%8d%e5%b0%84%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e4%ba%86%e8%a7%a3%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。&lt;/p>
&lt;p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。&lt;/p>
&lt;p>&lt;strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。&lt;/strong>&lt;/p>
&lt;p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 &lt;code>Method&lt;/code> 来调用指定的方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DebugInvocationHandler&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> InvocationHandler {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 代理类中的真实对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Object target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">DebugInvocationHandler&lt;/span>(Object target) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">target&lt;/span> &lt;span style="color:#f92672">=&lt;/span> target;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">invoke&lt;/span>(Object proxy, Method method, Object&lt;span style="color:#f92672">[]&lt;/span> args) &lt;span style="color:#66d9ef">throws&lt;/span> InvocationTargetException, IllegalAccessException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;before method &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> method.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object result &lt;span style="color:#f92672">=&lt;/span> method.&lt;span style="color:#a6e22e">invoke&lt;/span>(target, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;after method &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> method.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外，像 Java 中的一大利器 &lt;strong>注解&lt;/strong> 的实现也用到了反射。&lt;/p></description></item><item><title>Java 魔法类 Unsafe 详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/unsafe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/unsafe/</guid><description>&lt;blockquote>
&lt;p>本文整理完善自下面这两篇优秀的文章：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java 魔法类：Unsafe 应用解析 - 美团技术团队 -2019&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://xie.infoq.cn/article/8b6ed4195e475bfb32dacc5cb">Java 双刃剑之 Unsafe 类详解 - 码农参上 - 2021&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>阅读过 JUC 源码的同学，一定会发现很多并发工具类都调用了一个叫做 &lt;code>Unsafe&lt;/code> 的类。&lt;/p>
&lt;p>那这个类主要是用来干什么的呢？有什么使用场景呢？这篇文章就带你搞清楚！&lt;/p>
&lt;h2 id="unsafe-介绍">
 Unsafe 介绍
 &lt;a class="anchor" href="#unsafe-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>Unsafe&lt;/code> 是位于 &lt;code>sun.misc&lt;/code> 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 &lt;code>Unsafe&lt;/code> 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 &lt;code>Unsafe&lt;/code> 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 &lt;code>Unsafe&lt;/code> 的使用一定要慎重。&lt;/p>
&lt;p>另外，&lt;code>Unsafe&lt;/code> 提供的这些功能的实现需要依赖本地方法（Native Method）。你可以将本地方法看作是 Java 中使用其他编程语言编写的方法。本地方法使用 &lt;strong>&lt;code>native&lt;/code>&lt;/strong> 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 &lt;strong>本地代码&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717115231125.png" alt="" />&lt;/p>
&lt;p>&lt;strong>为什么要使用本地方法呢？&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>需要用到 Java 中不具备的依赖于操作系统的特性，Java 在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用。&lt;/li>
&lt;li>对于其他语言已经完成的一些现成功能，可以使用 Java 直接调用。&lt;/li>
&lt;li>程序对时间敏感或对性能要求非常高时，有必要使用更加底层的语言，例如 C/C++甚至是汇编。&lt;/li>
&lt;/ol>
&lt;p>在 JUC 包的很多并发工具类在实现并发机制时，都调用了本地方法，通过它们打破了 Java 运行时的界限，能够接触到操作系统底层的某些功能。对于同一本地方法，不同的操作系统可能会通过不同的方式来实现，但是对于使用者来说是透明的，最终都会得到相同的结果。&lt;/p></description></item><item><title>Java 线程池详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/java-thread-pool-summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/java-thread-pool-summary/</guid><description>&lt;p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。&lt;/p>
&lt;p>这篇文章我会详细介绍一下线程池的基本概念以及核心原理。&lt;/p>
&lt;h2 id="线程池介绍">
 线程池介绍
 &lt;a class="anchor" href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>顾名思义，线程池就是管理一系列线程的资源池，其提供了一种限制和管理线程资源的方式。每个线程池还维护一些基本统计信息，例如已完成任务的数量。&lt;/p>
&lt;p>这里借用《Java 并发编程的艺术》书中的部分内容来总结一下使用线程池的好处：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>降低资源消耗&lt;/strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li>
&lt;li>&lt;strong>提高响应速度&lt;/strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/li>
&lt;li>&lt;strong>提高线程的可管理性&lt;/strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行。&lt;/strong>&lt;/p>
&lt;h2 id="executor-框架介绍">
 Executor 框架介绍
 &lt;a class="anchor" href="#executor-%e6%a1%86%e6%9e%b6%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>Executor&lt;/code> 框架是 Java5 之后引进的，在 Java 5 之后，通过 &lt;code>Executor&lt;/code> 来启动线程比使用 &lt;code>Thread&lt;/code> 的 &lt;code>start&lt;/code> 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。&lt;/p>
&lt;blockquote>
&lt;p>this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>Executor&lt;/code> 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，&lt;code>Executor&lt;/code> 框架让并发编程变得更加简单。&lt;/p>
&lt;p>&lt;code>Executor&lt;/code> 框架结构主要由三大部分组成：&lt;/p>
&lt;p>&lt;strong>1、任务(&lt;code>Runnable&lt;/code> /&lt;code>Callable&lt;/code>)&lt;/strong>&lt;/p>
&lt;p>执行任务需要实现的 &lt;strong>&lt;code>Runnable&lt;/code> 接口&lt;/strong> 或 &lt;strong>&lt;code>Callable&lt;/code>接口&lt;/strong>。&lt;strong>&lt;code>Runnable&lt;/code> 接口&lt;/strong>或 &lt;strong>&lt;code>Callable&lt;/code> 接口&lt;/strong> 实现类都可以被 &lt;strong>&lt;code>ThreadPoolExecutor&lt;/code>&lt;/strong> 或 &lt;strong>&lt;code>ScheduledThreadPoolExecutor&lt;/code>&lt;/strong> 执行。&lt;/p>
&lt;p>&lt;strong>2、任务的执行(&lt;code>Executor&lt;/code>)&lt;/strong>&lt;/p>
&lt;p>如下图所示，包括任务执行机制的核心接口 &lt;strong>&lt;code>Executor&lt;/code>&lt;/strong> ，以及继承自 &lt;code>Executor&lt;/code> 接口的 &lt;strong>&lt;code>ExecutorService&lt;/code> 接口。&lt;code>ThreadPoolExecutor&lt;/code>&lt;/strong> 和 &lt;strong>&lt;code>ScheduledThreadPoolExecutor&lt;/code>&lt;/strong> 这两个关键类实现了 &lt;strong>&lt;code>ExecutorService&lt;/code>&lt;/strong> 接口。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/executor-class-diagram.png" alt="" />&lt;/p>
&lt;p>这里提了很多底层的类关系，但是，实际上我们需要更多关注的是 &lt;code>ThreadPoolExecutor&lt;/code> 这个类，这个类在我们实际使用线程池的过程中，使用频率还是非常高的。&lt;/p></description></item><item><title>Java 线程池最佳实践</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/java-thread-pool-best-practices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/java-thread-pool-best-practices/</guid><description>&lt;p>简单总结一下我了解的使用线程池的时候应该注意的东西，网上似乎还没有专门写这方面的文章。&lt;/p>
&lt;h2 id="1正确声明线程池">
 1、正确声明线程池
 &lt;a class="anchor" href="#1%e6%ad%a3%e7%a1%ae%e5%a3%b0%e6%98%8e%e7%ba%bf%e7%a8%8b%e6%b1%a0">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>线程池必须手动通过 &lt;code>ThreadPoolExecutor&lt;/code> 的构造函数来声明，避免使用&lt;code>Executors&lt;/code> 类创建线程池，会有 OOM 风险。&lt;/strong>&lt;/p>
&lt;p>&lt;code>Executors&lt;/code> 返回线程池对象的弊端如下(后文会详细介绍到)：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>FixedThreadPool&lt;/code> 和 &lt;code>SingleThreadExecutor&lt;/code>&lt;/strong>：使用的是有界阻塞队列 &lt;code>LinkedBlockingQueue&lt;/code>，任务队列的默认长度和最大长度为 &lt;code>Integer.MAX_VALUE&lt;/code>，可能堆积大量的请求，从而导致 OOM。&lt;/li>
&lt;li>&lt;strong>&lt;code>CachedThreadPool&lt;/code>&lt;/strong>：使用的是同步队列 &lt;code>SynchronousQueue&lt;/code>，允许创建的线程数量为 &lt;code>Integer.MAX_VALUE&lt;/code> ，可能会创建大量线程，从而导致 OOM。&lt;/li>
&lt;li>&lt;strong>&lt;code>ScheduledThreadPool&lt;/code> 和 &lt;code>SingleThreadScheduledExecutor&lt;/code>&lt;/strong> : 使用的无界的延迟阻塞队列&lt;code>DelayedWorkQueue&lt;/code>，任务队列最大长度为 &lt;code>Integer.MAX_VALUE&lt;/code>，可能堆积大量的请求，从而导致 OOM。&lt;/li>
&lt;/ul>
&lt;p>说白了就是：&lt;strong>使用有界队列，控制线程创建数量。&lt;/strong>&lt;/p>
&lt;p>除了避免 OOM 的原因之外，不推荐使用 &lt;code>Executors&lt;/code>提供的两种快捷的线程池的原因还有：&lt;/p>
&lt;ul>
&lt;li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。&lt;/li>
&lt;li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。&lt;/li>
&lt;/ul>
&lt;h2 id="2监测线程池运行状态">
 2、监测线程池运行状态
 &lt;a class="anchor" href="#2%e7%9b%91%e6%b5%8b%e7%ba%bf%e7%a8%8b%e6%b1%a0%e8%bf%90%e8%a1%8c%e7%8a%b6%e6%80%81">#&lt;/a>
&lt;/h2>
&lt;p>你可以通过一些手段来检测线程池的运行状态比如 SpringBoot 中的 Actuator 组件。&lt;/p>
&lt;p>除此之外，我们还可以利用 &lt;code>ThreadPoolExecutor&lt;/code> 的相关 API 做一个简陋的监控。从下图可以看出， &lt;code>ThreadPoolExecutor&lt;/code>提供了获取线程池当前的线程数和活跃线程数、已经执行完成的任务数、正在排队中的任务数等等。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/threadpool-methods-information.png" alt="" />&lt;/p>
&lt;p>下面是一个简单的 Demo。&lt;code>printThreadPoolStatus()&lt;/code>会每隔一秒打印出线程池的线程数、活跃线程数、完成的任务数、以及队列中的任务数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 打印线程池的状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @param threadPool 线程池对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">printThreadPoolStatus&lt;/span>(ThreadPoolExecutor threadPool) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ScheduledExecutorService scheduledExecutorService &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ScheduledThreadPoolExecutor(1, createThreadFactory(&lt;span style="color:#e6db74">&amp;#34;print-images/thread-pool-status&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scheduledExecutorService.&lt;span style="color:#a6e22e">scheduleAtFixedRate&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;=========================&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ThreadPool Size: [{}]&amp;#34;&lt;/span>, threadPool.&lt;span style="color:#a6e22e">getPoolSize&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Active Threads: {}&amp;#34;&lt;/span>, threadPool.&lt;span style="color:#a6e22e">getActiveCount&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Number of Tasks : {}&amp;#34;&lt;/span>, threadPool.&lt;span style="color:#a6e22e">getCompletedTaskCount&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Number of Tasks in Queue: {}&amp;#34;&lt;/span>, threadPool.&lt;span style="color:#a6e22e">getQueue&lt;/span>().&lt;span style="color:#a6e22e">size&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#a6e22e">info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;=========================&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, 0, 1, TimeUnit.&lt;span style="color:#a6e22e">SECONDS&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="3建议不同类别的业务用不同的线程池">
 3、建议不同类别的业务用不同的线程池
 &lt;a class="anchor" href="#3%e5%bb%ba%e8%ae%ae%e4%b8%8d%e5%90%8c%e7%b1%bb%e5%88%ab%e7%9a%84%e4%b8%9a%e5%8a%a1%e7%94%a8%e4%b8%8d%e5%90%8c%e7%9a%84%e7%ba%bf%e7%a8%8b%e6%b1%a0">#&lt;/a>
&lt;/h2>
&lt;p>很多人在实际项目中都会有类似这样的问题：&lt;strong>我的项目中多个业务需要用到线程池，是为每个线程池都定义一个还是说定义一个公共的线程池呢？&lt;/strong>&lt;/p></description></item><item><title>Java 序列化详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/serialization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/serialization/</guid><description>&lt;h2 id="什么是序列化和反序列化">
 什么是序列化和反序列化?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%ba%8f%e5%88%97%e5%8c%96%e5%92%8c%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96">#&lt;/a>
&lt;/h2>
&lt;p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。&lt;/p>
&lt;p>简单来说：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>序列化&lt;/strong>：将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式&lt;/li>
&lt;li>&lt;strong>反序列化&lt;/strong>：将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程&lt;/li>
&lt;/ul>
&lt;p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。&lt;/p>
&lt;p>下面是序列化和反序列化常见应用场景：&lt;/p>
&lt;ul>
&lt;li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；&lt;/li>
&lt;li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；&lt;/li>
&lt;li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；&lt;/li>
&lt;li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。&lt;/li>
&lt;/ul>
&lt;p>维基百科是如是介绍序列化的：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>序列化&lt;/strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。&lt;/p>
&lt;/blockquote>
&lt;p>综上：&lt;strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/a478c74d-2c48-40ae-9374-87aacf05188c.png" alt="" />&lt;/p>
&lt;p style="text-align:right;font-size:13px;color:gray">https://www.corejavaguru.com/java/serialization/interview-questions-1&lt;/p>
&lt;p>&lt;strong>序列化协议对应于 TCP/IP 4 层模型的哪一层？&lt;/strong>&lt;/p>
&lt;p>我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？&lt;/p>
&lt;ol>
&lt;li>应用层&lt;/li>
&lt;li>传输层&lt;/li>
&lt;li>网络层&lt;/li>
&lt;li>网络接口层&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png" alt="TCP/IP 四层模型" />&lt;/p>
&lt;p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？&lt;/p>
&lt;p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。&lt;/p>
&lt;h2 id="常见序列化协议有哪些">
 常见序列化协议有哪些？
 &lt;a class="anchor" href="#%e5%b8%b8%e8%a7%81%e5%ba%8f%e5%88%97%e5%8c%96%e5%8d%8f%e8%ae%ae%e6%9c%89%e5%93%aa%e4%ba%9b">#&lt;/a>
&lt;/h2>
&lt;p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。&lt;/p>
&lt;p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。&lt;/p>
&lt;h3 id="jdk-自带的序列化方式">
 JDK 自带的序列化方式
 &lt;a class="anchor" href="#jdk-%e8%87%aa%e5%b8%a6%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%e6%96%b9%e5%bc%8f">#&lt;/a>
&lt;/h3>
&lt;p>JDK 自带的序列化，只需实现 &lt;code>java.io.Serializable&lt;/code>接口即可。&lt;/p></description></item><item><title>Java 语法糖详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/syntactic-sugar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/syntactic-sugar/</guid><description>&lt;blockquote>
&lt;p>作者：Hollis&lt;/p>
&lt;p>原文：&lt;a href="https://mp.weixin.qq.com/s/o4XdEMq1DL-nBS-f8Za5Aw">https://mp.weixin.qq.com/s/o4XdEMq1DL-nBS-f8Za5Aw&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>语法糖是大厂 Java 面试常问的一个知识点。&lt;/p>
&lt;p>本文从 Java 编译原理角度，深入字节码及 class 文件，抽丝剥茧，了解 Java 中的语法糖原理及用法，帮助大家在学会如何使用 Java 语法糖的同时，了解这些语法糖背后的原理。&lt;/p>
&lt;h2 id="什么是语法糖">
 什么是语法糖？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%af%ad%e6%b3%95%e7%b3%96">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>语法糖（Syntactic Sugar）&lt;/strong> 也称糖衣语法，是英国计算机学家 Peter.J.Landin 发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/basis/syntactic-sugar/image-20220818175953954.png" alt="" />&lt;/p>
&lt;blockquote>
&lt;p>有意思的是，在编程领域，除了语法糖，还有语法盐和语法糖精的说法，篇幅有限这里不做扩展了。&lt;/p>
&lt;/blockquote>
&lt;p>我们所熟知的编程语言中几乎都有语法糖。作者认为，语法糖的多少是评判一个语言够不够牛逼的标准之一。很多人说 Java 是一个“低糖语言”，其实从 Java 7 开始 Java 语言层面上一直在添加各种糖，主要是在“Project Coin”项目下研发。尽管现在 Java 有人还是认为现在的 Java 是低糖，未来还会持续向着“高糖”的方向发展。&lt;/p>
&lt;h2 id="java-中有哪些常见的语法糖">
 Java 中有哪些常见的语法糖？
 &lt;a class="anchor" href="#java-%e4%b8%ad%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e8%af%ad%e6%b3%95%e7%b3%96">#&lt;/a>
&lt;/h2>
&lt;p>前面提到过，语法糖的存在主要是方便开发人员使用。但其实， &lt;strong>Java 虚拟机并不支持这些语法糖。这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖。&lt;/strong>&lt;/p>
&lt;p>说到编译，大家肯定都知道，Java 语言中，&lt;code>javac&lt;/code>命令可以将后缀名为&lt;code>.java&lt;/code>的源文件编译为后缀名为&lt;code>.class&lt;/code>的可以运行于 Java 虚拟机的字节码。如果你去看&lt;code>com.sun.tools.javac.main.JavaCompiler&lt;/code>的源码，你会发现在&lt;code>compile()&lt;/code>中有一个步骤就是调用&lt;code>desugar()&lt;/code>，这个方法就是负责解语法糖的实现的。&lt;/p>
&lt;p>Java 中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。本文主要来分析下这些语法糖背后的原理。一步一步剥去糖衣，看看其本质。&lt;/p>
&lt;p>我们这里会用到&lt;a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;amp;mid=2650120609&amp;amp;idx=1&amp;amp;sn=5659f96310963ad57d55b48cee63c788&amp;amp;chksm=f36bbc80c41c3596a1e4bf9501c6280481f1b9e06d07af354474e6f3ed366fef016df673a7ba&amp;amp;scene=21#wechat_redirect">反编译&lt;/a>，你可以通过 &lt;a href="http://www.javadecompilers.com/">Decompilers online&lt;/a> 对 Class 文件进行在线反编译。&lt;/p>
&lt;h3 id="switch-支持-string-与枚举">
 switch 支持 String 与枚举
 &lt;a class="anchor" href="#switch-%e6%94%af%e6%8c%81-string-%e4%b8%8e%e6%9e%9a%e4%b8%be">#&lt;/a>
&lt;/h3>
&lt;p>前面提到过，从 Java 7 开始，Java 语言中的语法糖在逐渐丰富，其中一个比较重要的就是 Java 7 中&lt;code>switch&lt;/code>开始支持&lt;code>String&lt;/code>。&lt;/p></description></item><item><title>Java 值传递详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/why-there-only-value-passing-in-java/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/why-there-only-value-passing-in-java/</guid><description>&lt;p>开始之前，我们先来搞懂下面这两个概念：&lt;/p>
&lt;ul>
&lt;li>形参&amp;amp;实参&lt;/li>
&lt;li>值传递&amp;amp;引用传递&lt;/li>
&lt;/ul>
&lt;h2 id="形参实参">
 形参&amp;amp;实参
 &lt;a class="anchor" href="#%e5%bd%a2%e5%8f%82%e5%ae%9e%e5%8f%82">#&lt;/a>
&lt;/h2>
&lt;p>方法的定义可能会用到 &lt;strong>参数&lt;/strong>（有参的方法），参数在程序语言中分为：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>实参（实际参数，Arguments）&lt;/strong>：用于传递给函数/方法的参数，必须有确定的值。&lt;/li>
&lt;li>&lt;strong>形参（形式参数，Parameters）&lt;/strong>：用于定义函数/方法，接收实参，不需要有确定的值。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>String hello &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello!&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// hello 为实参&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sayHello(hello);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// str 为形参&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sayHello&lt;/span>(String str) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(str);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="值传递引用传递">
 值传递&amp;amp;引用传递
 &lt;a class="anchor" href="#%e5%80%bc%e4%bc%a0%e9%80%92%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92">#&lt;/a>
&lt;/h2>
&lt;p>程序设计语言将实参传递给方法（或函数）的方式分为两种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>值传递&lt;/strong>：方法接收的是实参值的拷贝，会创建副本。&lt;/li>
&lt;li>&lt;strong>引用传递&lt;/strong>：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。&lt;/li>
&lt;/ul>
&lt;p>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。&lt;/p>
&lt;h2 id="为什么-java-只有值传递">
 为什么 Java 只有值传递？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88-java-%e5%8f%aa%e6%9c%89%e5%80%bc%e4%bc%a0%e9%80%92">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>为什么说 Java 只有值传递呢？&lt;/strong> 不需要太多废话，我通过 3 个例子来给大家证明。&lt;/p>
&lt;h3 id="案例-1传递基本类型参数">
 案例 1：传递基本类型参数
 &lt;a class="anchor" href="#%e6%a1%88%e4%be%8b-1%e4%bc%a0%e9%80%92%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e5%8f%82%e6%95%b0">#&lt;/a>
&lt;/h3>
&lt;p>代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num1 &lt;span style="color:#f92672">=&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> num2 &lt;span style="color:#f92672">=&lt;/span> 20;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> swap(num1, num2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;num1 = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> num1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;num2 = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> num2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">swap&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">=&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> a);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;b = &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出：&lt;/p></description></item><item><title>Java8 新特性实战</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java8-common-new-features/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/new-features/java8-common-new-features/</guid><description>&lt;blockquote>
&lt;p>本文来自&lt;a href="https://github.com/cowbi">cowbi&lt;/a>的投稿~&lt;/p>
&lt;/blockquote>
&lt;p>Oracle 于 2014 发布了 Java8（jdk1.8），诸多原因使它成为目前市场上使用最多的 jdk 版本。虽然发布距今已将近 7 年，但很多程序员对其新特性还是不够了解，尤其是用惯了 Java8 之前版本的老程序员，比如我。&lt;/p>
&lt;p>为了不脱离队伍太远，还是有必要对这些新特性做一些总结梳理。它较 jdk.7 有很多变化或者说是优化，比如 interface 里可以有静态方法，并且可以有方法体，这一点就颠覆了之前的认知；&lt;code>java.util.HashMap&lt;/code> 数据结构里增加了红黑树；还有众所周知的 Lambda 表达式等等。本文不能把所有的新特性都给大家一一分享，只列出比较常用的新特性给大家做详细讲解。更多相关内容请看&lt;a href="https://www.oracle.com/java/technologies/javase/8-whats-new.html">官网关于 Java8 的新特性的介绍&lt;/a>。&lt;/p>
&lt;h2 id="interface">
 Interface
 &lt;a class="anchor" href="#interface">#&lt;/a>
&lt;/h2>
&lt;p>interface 的设计初衷是面向抽象，提高扩展性。这也留有一点遗憾，Interface 修改的时候，实现它的类也必须跟着改。&lt;/p>
&lt;p>为了解决接口的修改与现有的实现不兼容的问题。新 interface 的方法可以用&lt;code>default&lt;/code> 或 &lt;code>static&lt;/code>修饰，这样就可以有方法体，实现类也不必重写此方法。&lt;/p>
&lt;p>一个 interface 中可以有多个方法被它们修饰，这 2 个修饰符的区别主要也是普通方法和静态方法的区别。&lt;/p>
&lt;ol>
&lt;li>&lt;code>default&lt;/code>修饰的方法，是普通实例方法，可以用&lt;code>this&lt;/code>调用，可以被子类继承、重写。&lt;/li>
&lt;li>&lt;code>static&lt;/code>修饰的方法，使用上和一般类静态方法一样。但它不能被子类继承，只能用&lt;code>Interface&lt;/code>调用。&lt;/li>
&lt;/ol>
&lt;p>我们来看一个实际的例子。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">InterfaceNew&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sm&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;interface提供的方式实现&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sm2&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;interface提供的方式实现&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">def&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;interface default方法&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">def2&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;interface default2方法&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//须要实现类重写&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">InterfaceNew1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">def&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;InterfaceNew1 default方法&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果有一个类既实现了 &lt;code>InterfaceNew&lt;/code> 接口又实现了 &lt;code>InterfaceNew1&lt;/code>接口，它们都有&lt;code>def()&lt;/code>，并且 &lt;code>InterfaceNew&lt;/code> 接口和 &lt;code>InterfaceNew1&lt;/code>接口没有继承关系的话，这时就必须重写&lt;code>def()&lt;/code>。不然的话，编译的时候就会报错。&lt;/p></description></item><item><title>Java并发常见面试题总结（上）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-01/</guid><description>&lt;h2 id="线程">
 线程
 &lt;a class="anchor" href="#%e7%ba%bf%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是线程和进程">
 ⭐️什么是线程和进程?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e5%92%8c%e8%bf%9b%e7%a8%8b">#&lt;/a>
&lt;/h3>
&lt;h4 id="何为进程">
 何为进程?
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba%e8%bf%9b%e7%a8%8b">#&lt;/a>
&lt;/h4>
&lt;p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。&lt;/p>
&lt;p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。&lt;/p>
&lt;p>如下图所示，在 Windows 中通过查看任务管理器的方式，我们就可以清楚看到 Windows 当前运行的进程（&lt;code>.exe&lt;/code> 文件的运行）。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/%E8%BF%9B%E7%A8%8B%E7%A4%BA%E4%BE%8B%E5%9B%BE%E7%89%87-Windows.png" alt="进程示例图片-Windows" />&lt;/p>
&lt;h4 id="何为线程">
 何为线程?
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba%e7%ba%bf%e7%a8%8b">#&lt;/a>
&lt;/h4>
&lt;p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的&lt;strong>堆&lt;/strong>和&lt;strong>方法区&lt;/strong>资源，但每个线程有自己的&lt;strong>程序计数器&lt;/strong>、&lt;strong>虚拟机栈&lt;/strong>和&lt;strong>本地方法栈&lt;/strong>，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。&lt;/p>
&lt;p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看看一个普通的 Java 程序有哪些线程，代码如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MultiThread&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 获取 Java 线程管理 MXBean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	ThreadMXBean threadMXBean &lt;span style="color:#f92672">=&lt;/span> ManagementFactory.&lt;span style="color:#a6e22e">getThreadMXBean&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		ThreadInfo&lt;span style="color:#f92672">[]&lt;/span> threadInfos &lt;span style="color:#f92672">=&lt;/span> threadMXBean.&lt;span style="color:#a6e22e">dumpAllThreads&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">// 遍历线程信息，仅打印线程 ID 和线程名称信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">for&lt;/span> (ThreadInfo threadInfo : threadInfos) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;[&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> threadInfo.&lt;span style="color:#a6e22e">getThreadId&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;] &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> threadInfo.&lt;span style="color:#a6e22e">getThreadName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：&lt;/p></description></item><item><title>Java并发常见面试题总结（下）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-03/</guid><description>&lt;h2 id="threadlocal">
 ThreadLocal
 &lt;a class="anchor" href="#threadlocal">#&lt;/a>
&lt;/h2>
&lt;h3 id="threadlocal-有什么用">
 ThreadLocal 有什么用？
 &lt;a class="anchor" href="#threadlocal-%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8">#&lt;/a>
&lt;/h3>
&lt;p>通常情况下，我们创建的变量可以被任何一个线程访问和修改。这在多线程环境中可能导致数据竞争和线程安全问题。那么，&lt;strong>如果想让每个线程都有自己的专属本地变量，该如何实现呢？&lt;/strong>&lt;/p>
&lt;p>JDK 中提供的 &lt;code>ThreadLocal&lt;/code> 类正是为了解决这个问题。&lt;strong>&lt;code>ThreadLocal&lt;/code> 类允许每个线程绑定自己的值&lt;/strong>，可以将其形象地比喻为一个“存放数据的盒子”。每个线程都有自己独立的盒子，用于存储私有数据，确保不同线程之间的数据互不干扰。&lt;/p>
&lt;p>当你创建一个 &lt;code>ThreadLocal&lt;/code> 变量时，每个访问该变量的线程都会拥有一个独立的副本。这也是 &lt;code>ThreadLocal&lt;/code> 名称的由来。线程可以通过 &lt;code>get()&lt;/code> 方法获取自己线程的本地副本，或通过 &lt;code>set()&lt;/code> 方法修改该副本的值，从而避免了线程安全问题。&lt;/p>
&lt;p>举个简单的例子：假设有两个人去宝屋收集宝物。如果他们共用一个袋子，必然会产生争执；但如果每个人都有一个独立的袋子，就不会有这个问题。如果将这两个人比作线程，那么 &lt;code>ThreadLocal&lt;/code> 就是用来避免这两个线程竞争同一个资源的方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ThreadLocalExample&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ThreadLocal&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> threadLocal &lt;span style="color:#f92672">=&lt;/span> ThreadLocal.&lt;span style="color:#a6e22e">withInitial&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Runnable task &lt;span style="color:#f92672">=&lt;/span> () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> value &lt;span style="color:#f92672">=&lt;/span> threadLocal.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value &lt;span style="color:#f92672">+=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> threadLocal.&lt;span style="color:#a6e22e">set&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(Thread.&lt;span style="color:#a6e22e">currentThread&lt;/span>().&lt;span style="color:#a6e22e">getName&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; Value: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> threadLocal.&lt;span style="color:#a6e22e">get&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread thread1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(task, &lt;span style="color:#e6db74">&amp;#34;Thread-1&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread thread2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Thread(task, &lt;span style="color:#e6db74">&amp;#34;Thread-2&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> thread1.&lt;span style="color:#a6e22e">start&lt;/span>(); &lt;span style="color:#75715e">// 输出: Thread-1 Value: 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> thread2.&lt;span style="color:#a6e22e">start&lt;/span>(); &lt;span style="color:#75715e">// 输出: Thread-2 Value: 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="threadlocal-原理了解吗">
 ⭐️ThreadLocal 原理了解吗？
 &lt;a class="anchor" href="#threadlocal-%e5%8e%9f%e7%90%86%e4%ba%86%e8%a7%a3%e5%90%97">#&lt;/a>
&lt;/h3>
&lt;p>从 &lt;code>Thread&lt;/code>类源代码入手。&lt;/p></description></item><item><title>Java并发常见面试题总结（中）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/java-concurrent-questions-02/</guid><description>&lt;h2 id="jmmjava-内存模型">
 ⭐️JMM(Java 内存模型)
 &lt;a class="anchor" href="#jmmjava-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;p>JMM（Java 内存模型）相关的问题比较多，也比较重要，于是我单独抽了一篇文章来总结 JMM 相关的知识点和问题：&lt;a href="./jmm.md">JMM（Java 内存模型）详解&lt;/a> 。&lt;/p>
&lt;h2 id="volatile-关键字">
 ⭐️volatile 关键字
 &lt;a class="anchor" href="#volatile-%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>
&lt;/h2>
&lt;h3 id="如何保证变量的可见性">
 如何保证变量的可见性？
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%98%e9%87%8f%e7%9a%84%e5%8f%af%e8%a7%81%e6%80%a7">#&lt;/a>
&lt;/h3>
&lt;p>在 Java 中，&lt;code>volatile&lt;/code> 关键字可以保证变量的可见性，如果我们将变量声明为 &lt;strong>&lt;code>volatile&lt;/code>&lt;/strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm.png" alt="JMM(Java 内存模型)" />&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/jmm2.png" alt="JMM(Java 内存模型)强制在主存中进行读取" />&lt;/p>
&lt;p>&lt;code>volatile&lt;/code> 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 &lt;code>volatile&lt;/code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。&lt;/p>
&lt;p>&lt;code>volatile&lt;/code> 关键字能保证数据的可见性，但不能保证数据的原子性。&lt;code>synchronized&lt;/code> 关键字两者都能保证。&lt;/p>
&lt;h3 id="如何禁止指令重排序">
 如何禁止指令重排序？
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e7%a6%81%e6%ad%a2%e6%8c%87%e4%bb%a4%e9%87%8d%e6%8e%92%e5%ba%8f">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>在 Java 中，&lt;code>volatile&lt;/code> 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。&lt;/strong> 如果我们将变量声明为 &lt;strong>&lt;code>volatile&lt;/code>&lt;/strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 &lt;strong>内存屏障&lt;/strong> 的方式来禁止指令重排序。&lt;/p>
&lt;p>在 Java 中，&lt;code>Unsafe&lt;/code> 类提供了三个开箱即用的内存屏障相关的方法，屏蔽了操作系统底层的差异：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">loadFence&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">storeFence&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">native&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">fullFence&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>理论上来说，你通过这个三个方法也可以实现和&lt;code>volatile&lt;/code>禁止重排序一样的效果，只是会麻烦一些。&lt;/p>
&lt;p>下面我以一个常见的面试题为例讲解一下 &lt;code>volatile&lt;/code> 关键字禁止指令重排序的效果。&lt;/p>
&lt;p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”&lt;/p>
&lt;p>&lt;strong>双重校验锁实现对象单例（线程安全）&lt;/strong>：&lt;/p></description></item><item><title>Java基础常见面试题总结(上)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-basic-questions-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-basic-questions-01/</guid><description>&lt;p>&lt;a href="">&lt;/a>&lt;/p>
&lt;h2 id="基础概念与常识">
 基础概念与常识
 &lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80%e6%a6%82%e5%bf%b5%e4%b8%8e%e5%b8%b8%e8%af%86">#&lt;/a>
&lt;/h2>
&lt;h3 id="java-语言有哪些特点">
 Java 语言有哪些特点?
 &lt;a class="anchor" href="#java-%e8%af%ad%e8%a8%80%e6%9c%89%e5%93%aa%e4%ba%9b%e7%89%b9%e7%82%b9">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>简单易学（语法简单，上手容易）；&lt;/li>
&lt;li>面向对象（&lt;strong>封装，继承，多态&lt;/strong>）；&lt;/li>
&lt;li>&lt;strong>平台无关&lt;/strong>性（ Java 虚拟机实现平台无关性）；&lt;/li>
&lt;li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；&lt;/li>
&lt;li>可靠性（具备异常处理和自动内存管理机制）；&lt;/li>
&lt;li>安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）；&lt;/li>
&lt;li>高效性（通过 Just In Time 编译器等技术的优化，Java 语言的运行效率还是非常不错的）；&lt;/li>
&lt;li>支持网络编程并且很方便；&lt;/li>
&lt;li>编译与解释并存；&lt;/li>
&lt;li>……&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;strong>🐛 修正（参见：&lt;a href="https://github.com/Snailclimb/JavaGuide/issues/544">issue#544&lt;/a>）&lt;/strong>：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用&lt;code>std::thread&lt;/code>和&lt;code>std::async&lt;/code>来创建线程。参考链接：&lt;a href="http://www.cplusplus.com/reference/thread/thread/?kw=thread">http://www.cplusplus.com/reference/thread/thread/?kw=thread&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>🌈 拓展一下：&lt;/p>
&lt;p>“Write Once, Run Anywhere（一次编写，随处运行）”这句宣传口号，真心经典，流传了好多年！以至于，直到今天，依然有很多人觉得跨平台是 Java 语言最大的优势。实际上，跨平台已经不是 Java 最大的卖点了，各种 JDK 新特性也不是。目前市面上虚拟化技术已经非常成熟，比如你&lt;strong>通过 Docker 就很容易实现跨平台&lt;/strong>了。在我看来，&lt;strong>Java 强大的生态&lt;/strong>才是！&lt;/p>
&lt;h3 id="java-se-vs-java-ee">
 Java SE vs Java EE
 &lt;a class="anchor" href="#java-se-vs-java-ee">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>Java &lt;strong>SE&lt;/strong>（Java Platform，Standard Edition）: &lt;strong>Java 平台标准版&lt;/strong>，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的&lt;strong>核心类库以及虚拟机&lt;/strong>等核心组件。Java SE 可以用于构建&lt;strong>桌面应用程序或简单的服务器&lt;/strong>应用程序。&lt;/li>
&lt;li>Java EE（Java Platform, Enterprise Edition ）：Java 平台企业版，建立在 Java SE 的基础上，包含了支持&lt;strong>企业级应用程序开发和部署的标准和规范&lt;/strong>（比如 &lt;strong>Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS&lt;/strong>）。 Java EE 可以用于构建&lt;strong>分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发&lt;strong>桌面应用程序或简单的服务器&lt;/strong>应用程序，Java EE 更适合开发&lt;strong>复杂的企业级应用程序或 Web 应用程序&lt;/strong>。&lt;/p></description></item><item><title>Java基础常见面试题总结(下)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-basic-questions-03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-basic-questions-03/</guid><description>&lt;h2 id="异常">
 异常
 &lt;a class="anchor" href="#%e5%bc%82%e5%b8%b8">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>Java 异常类层次结构图概览&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/basis/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图" />&lt;/p>
&lt;h3 id="exception-和-error-有什么区别">
 Exception 和 Error 有什么区别？
 &lt;a class="anchor" href="#exception-%e5%92%8c-error-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">#&lt;/a>
&lt;/h3>
&lt;p>在 Java 中，所有的异常都有一个共同的祖先 &lt;code>java.lang&lt;/code> 包中的 &lt;code>Throwable&lt;/code> 类。&lt;code>Throwable&lt;/code> 类有两个重要的子类:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>Exception&lt;/code>&lt;/strong> :程序本身可以处理的异常，可以通过 &lt;code>catch&lt;/code> 来进行捕获。&lt;code>Exception&lt;/code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。&lt;/li>
&lt;li>&lt;strong>&lt;code>Error&lt;/code>&lt;/strong>：&lt;code>Error&lt;/code> 属于程序无法处理的错误 ，&lt;del>我们没办法通过 &lt;code>catch&lt;/code> 来进行捕获&lt;/del>不建议通过&lt;code>catch&lt;/code>捕获 。例如 Java 虚拟机运行错误（&lt;code>Virtual MachineError&lt;/code>）、虚拟机内存不够错误(&lt;code>OutOfMemoryError&lt;/code>)、类定义错误（&lt;code>NoClassDefFoundError&lt;/code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。&lt;/li>
&lt;/ul>
&lt;h3 id="checked-exception-和-unchecked-exception-有什么区别">
 Checked Exception 和 Unchecked Exception 有什么区别？
 &lt;a class="anchor" href="#checked-exception-%e5%92%8c-unchecked-exception-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>Checked Exception&lt;/strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 &lt;code>catch&lt;/code>或者&lt;code>throws&lt;/code> 关键字处理的话，就没办法通过编译。&lt;/p>
&lt;p>比如下面这段 IO 操作的代码：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/basis/checked-exception.png" alt="" />&lt;/p>
&lt;p>除了&lt;code>RuntimeException&lt;/code>及其子类以外，其他的&lt;code>Exception&lt;/code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、&lt;code>ClassNotFoundException&lt;/code>、&lt;code>SQLException&lt;/code>&amp;hellip;。&lt;/p>
&lt;p>&lt;strong>Unchecked Exception&lt;/strong> 即 &lt;strong>不受检查异常&lt;/strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。&lt;/p></description></item><item><title>Java基础常见面试题总结(中)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-basic-questions-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/java-basic-questions-02/</guid><description>&lt;h2 id="面向对象基础">
 面向对象基础
 &lt;a class="anchor" href="#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;h3 id="面向对象和面向过程的区别">
 面向对象和面向过程的区别
 &lt;a class="anchor" href="#%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e5%92%8c%e9%9d%a2%e5%90%91%e8%bf%87%e7%a8%8b%e7%9a%84%e5%8c%ba%e5%88%ab">#&lt;/a>
&lt;/h3>
&lt;p>面向过程编程（Procedural-Oriented Programming，POP）和面向对象编程（Object-Oriented Programming，OOP）是两种常见的编程范式，两者的主要区别在于解决问题的方式不同：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>面向过程编程（POP）&lt;/strong>：面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。&lt;/li>
&lt;li>&lt;strong>面向对象编程（OOP）&lt;/strong>：面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。&lt;/li>
&lt;/ul>
&lt;p>相比较于 POP，OOP 开发的程序一般具有下面这些优点：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>易维护&lt;/strong>：由于良好的结构和封装性，OOP 程序通常更容易维护。&lt;/li>
&lt;li>&lt;strong>易复用&lt;/strong>：通过继承和多态，OOP 设计使得代码更具复用性，方便扩展功能。&lt;/li>
&lt;li>&lt;strong>易扩展&lt;/strong>：模块化设计使得系统扩展变得更加容易和灵活。&lt;/li>
&lt;/ul>
&lt;p>POP 的编程方式通常更为简单和直接，适合处理一些较简单的任务。&lt;/p>
&lt;p>POP 和 OOP 的性能差异主要取决于它们的运行机制，而不仅仅是编程范式本身。因此，简单地比较两者的性能是一个常见的误区（相关 issue : &lt;a href="https://github.com/Snailclimb/JavaGuide/issues/431">面向过程：面向过程性能比面向对象高？？&lt;/a> ）。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/basis/pop-vs-oop-performance.png" alt=" POP 和 OOP 性能比较不合适" />&lt;/p>
&lt;p>在选择编程范式时，性能并不是唯一的考虑因素。代码的可维护性、可扩展性和开发效率同样重要。&lt;/p>
&lt;p>现代编程语言基本都支持多种编程范式，既可以用来进行面向过程编程，也可以进行面向对象编程。&lt;/p>
&lt;p>下面是一个求圆的面积和周长的示例，简单分别展示了面向对象和面向过程两种不同的解决方案。&lt;/p>
&lt;p>&lt;strong>面向对象&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Circle&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 定义圆的半径&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> radius;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 构造函数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Circle&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> radius) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">radius&lt;/span> &lt;span style="color:#f92672">=&lt;/span> radius;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 计算圆的面积&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">getArea&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Math.&lt;span style="color:#a6e22e">PI&lt;/span> &lt;span style="color:#f92672">*&lt;/span> radius &lt;span style="color:#f92672">*&lt;/span> radius;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 计算圆的周长&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">getPerimeter&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> 2 &lt;span style="color:#f92672">*&lt;/span> Math.&lt;span style="color:#a6e22e">PI&lt;/span> &lt;span style="color:#f92672">*&lt;/span> radius;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建一个半径为3的圆&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Circle circle &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Circle(3.&lt;span style="color:#a6e22e">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 输出圆的面积和周长&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;圆的面积为：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> circle.&lt;span style="color:#a6e22e">getArea&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;圆的周长为：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> circle.&lt;span style="color:#a6e22e">getPerimeter&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们定义了一个 &lt;code>Circle&lt;/code> 类来表示圆，该类包含了圆的半径属性和计算面积、周长的方法。&lt;/p></description></item><item><title>Java集合常见面试题总结(上)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/java-collection-questions-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/java-collection-questions-01/</guid><description>&lt;h2 id="集合概述">
 集合概述
 &lt;a class="anchor" href="#%e9%9b%86%e5%90%88%e6%a6%82%e8%bf%b0">#&lt;/a>
&lt;/h2>
&lt;h3 id="java-集合概览">
 Java 集合概览
 &lt;a class="anchor" href="#java-%e9%9b%86%e5%90%88%e6%a6%82%e8%a7%88">#&lt;/a>
&lt;/h3>
&lt;p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 &lt;code>Collection&lt;/code>接口，主要用于存放单一元素；另一个是 &lt;code>Map&lt;/code> 接口，主要用于存放键值对。对于&lt;code>Collection&lt;/code> 接口，下面又有三个主要的子接口：&lt;code>List&lt;/code>、&lt;code>Set&lt;/code> 、 &lt;code>Queue&lt;/code>。&lt;/p>
&lt;p>Java 集合框架如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png" alt="Java 集合框架概览" />&lt;/p>
&lt;p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了&lt;code>AbstractList&lt;/code>, &lt;code>NavigableSet&lt;/code>等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。&lt;/p>
&lt;h3 id="说说-list-set-queue-map-四者的区别">
 说说 List, Set, Queue, Map 四者的区别？
 &lt;a class="anchor" href="#%e8%af%b4%e8%af%b4-list-set-queue-map-%e5%9b%9b%e8%80%85%e7%9a%84%e5%8c%ba%e5%88%ab">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;code>List&lt;/code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。&lt;/li>
&lt;li>&lt;code>Set&lt;/code>(注重独一无二的性质): 存储的元素不可重复的。&lt;/li>
&lt;li>&lt;code>Queue&lt;/code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。&lt;/li>
&lt;li>&lt;code>Map&lt;/code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，&amp;ldquo;x&amp;rdquo; 代表 key，&amp;ldquo;y&amp;rdquo; 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。&lt;/li>
&lt;/ul>
&lt;h3 id="集合框架底层数据结构总结">
 集合框架底层数据结构总结
 &lt;a class="anchor" href="#%e9%9b%86%e5%90%88%e6%a1%86%e6%9e%b6%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h3>
&lt;p>先来看一下 &lt;code>Collection&lt;/code> 接口下面的集合。&lt;/p>
&lt;h4 id="list">
 List
 &lt;a class="anchor" href="#list">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>&lt;code>ArrayList&lt;/code>：&lt;code>Object[]&lt;/code> 数组。详细可以查看：&lt;a href="./arraylist-source-code.md">ArrayList 源码分析&lt;/a>。&lt;/li>
&lt;li>&lt;code>Vector&lt;/code>：&lt;code>Object[]&lt;/code> 数组。&lt;/li>
&lt;li>&lt;code>LinkedList&lt;/code>：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。详细可以查看：&lt;a href="./linkedlist-source-code.md">LinkedList 源码分析&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h4 id="set">
 Set
 &lt;a class="anchor" href="#set">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>&lt;code>HashSet&lt;/code>(无序，唯一): 基于 &lt;code>HashMap&lt;/code> 实现的，底层采用 &lt;code>HashMap&lt;/code> 来保存元素。&lt;/li>
&lt;li>&lt;code>LinkedHashSet&lt;/code>: &lt;code>LinkedHashSet&lt;/code> 是 &lt;code>HashSet&lt;/code> 的子类，并且其内部是通过 &lt;code>LinkedHashMap&lt;/code> 来实现的。&lt;/li>
&lt;li>&lt;code>TreeSet&lt;/code>(有序，唯一): 红黑树(自平衡的排序二叉树)。&lt;/li>
&lt;/ul>
&lt;h4 id="queue">
 Queue
 &lt;a class="anchor" href="#queue">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>&lt;code>PriorityQueue&lt;/code>: &lt;code>Object[]&lt;/code> 数组来实现小顶堆。详细可以查看：&lt;a href="./priorityqueue-source-code.md">PriorityQueue 源码分析&lt;/a>。&lt;/li>
&lt;li>&lt;code>DelayQueue&lt;/code>:&lt;code>PriorityQueue&lt;/code>。详细可以查看：&lt;a href="./delayqueue-source-code.md">DelayQueue 源码分析&lt;/a>。&lt;/li>
&lt;li>&lt;code>ArrayDeque&lt;/code>: 可扩容动态双向数组。&lt;/li>
&lt;/ul>
&lt;p>再来看看 &lt;code>Map&lt;/code> 接口下面的集合。&lt;/p></description></item><item><title>Java集合常见面试题总结(下)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/java-collection-questions-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/java-collection-questions-02/</guid><description>&lt;h2 id="map重要">
 Map（重要）
 &lt;a class="anchor" href="#map%e9%87%8d%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;h3 id="hashmap-和-hashtable-的区别">
 HashMap 和 Hashtable 的区别
 &lt;a class="anchor" href="#hashmap-%e5%92%8c-hashtable-%e7%9a%84%e5%8c%ba%e5%88%ab">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>线程是否安全：&lt;/strong> &lt;code>HashMap&lt;/code> 是非线程安全的，&lt;code>Hashtable&lt;/code> 是线程安全的,因为 &lt;code>Hashtable&lt;/code> 内部的方法基本都经过&lt;code>synchronized&lt;/code> 修饰。（如果你要保证线程安全的话就使用 &lt;code>ConcurrentHashMap&lt;/code> 吧！）；&lt;/li>
&lt;li>&lt;strong>效率：&lt;/strong> 因为线程安全的问题，&lt;code>HashMap&lt;/code> 要比 &lt;code>Hashtable&lt;/code> 效率高一点。另外，&lt;code>Hashtable&lt;/code> 基本被淘汰，不要在代码中使用它；&lt;/li>
&lt;li>&lt;strong>对 Null key 和 Null value 的支持：&lt;/strong> &lt;code>HashMap&lt;/code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 &lt;code>NullPointerException&lt;/code>。&lt;/li>
&lt;li>&lt;strong>初始容量大小和每次扩充容量大小的不同：&lt;/strong> ① 创建时如果不指定容量初始值，&lt;code>Hashtable&lt;/code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。&lt;code>HashMap&lt;/code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 &lt;code>Hashtable&lt;/code> 会直接使用你给定的大小，而 &lt;code>HashMap&lt;/code> 会将其扩充为 2 的幂次方大小（&lt;code>HashMap&lt;/code> 中的&lt;code>tableSizeFor()&lt;/code>方法保证，下面给出了源代码）。也就是说 &lt;code>HashMap&lt;/code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。&lt;/li>
&lt;li>&lt;strong>底层数据结构：&lt;/strong> JDK1.8 以后的 &lt;code>HashMap&lt;/code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。&lt;code>Hashtable&lt;/code> 没有这样的机制。&lt;/li>
&lt;li>&lt;strong>哈希函数的实现&lt;/strong>：&lt;code>HashMap&lt;/code> 对哈希值进行了高位和低位的混合扰动处理以减少冲突，而 &lt;code>Hashtable&lt;/code> 直接使用键的 &lt;code>hashCode()&lt;/code> 值。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&lt;code>HashMap&lt;/code> 中带有初始容量的构造函数：&lt;/strong>&lt;/p></description></item><item><title>Java集合使用注意事项总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/java-collection-precautions-for-use/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/java-collection-precautions-for-use/</guid><description>&lt;p>这篇文章我根据《阿里巴巴 Java 开发手册》总结了关于集合使用常见的注意事项以及其具体原理。&lt;/p>
&lt;p>强烈建议小伙伴们多多阅读几遍，避免自己写代码的时候出现这些低级的问题。&lt;/p>
&lt;h2 id="集合判空">
 集合判空
 &lt;a class="anchor" href="#%e9%9b%86%e5%90%88%e5%88%a4%e7%a9%ba">#&lt;/a>
&lt;/h2>
&lt;p>《阿里巴巴 Java 开发手册》的描述如下：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>判断所有集合内部的元素是否为空，使用 &lt;code>isEmpty()&lt;/code> 方法，而不是 &lt;code>size()==0&lt;/code> 的方式。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>这是因为 &lt;code>isEmpty()&lt;/code> 方法的可读性更好，并且时间复杂度为 &lt;code>O(1)&lt;/code>。&lt;/p>
&lt;p>绝大部分我们使用的集合的 &lt;code>size()&lt;/code> 方法的时间复杂度也是 &lt;code>O(1)&lt;/code>，不过，也有很多复杂度不是 &lt;code>O(1)&lt;/code> 的，比如 &lt;code>java.util.concurrent&lt;/code> 包下的 &lt;code>ConcurrentLinkedQueue&lt;/code>。&lt;code>ConcurrentLinkedQueue&lt;/code> 的 &lt;code>isEmpty()&lt;/code> 方法通过 &lt;code>first()&lt;/code> 方法进行判断，其中 &lt;code>first()&lt;/code> 方法返回的是队列中第一个值不为 &lt;code>null&lt;/code> 的节点（节点值为&lt;code>null&lt;/code>的原因是在迭代器中使用的逻辑删除）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isEmpty&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> first() &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Node&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">first&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> restartFromHead:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (Node&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> h &lt;span style="color:#f92672">=&lt;/span> head, p &lt;span style="color:#f92672">=&lt;/span> h, q;;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> hasItem &lt;span style="color:#f92672">=&lt;/span> (p.&lt;span style="color:#a6e22e">item&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (hasItem &lt;span style="color:#f92672">||&lt;/span> (q &lt;span style="color:#f92672">=&lt;/span> p.&lt;span style="color:#a6e22e">next&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) { &lt;span style="color:#75715e">// 当前节点值不为空 或 到达队尾&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updateHead(h, p); &lt;span style="color:#75715e">// 将head设置为p&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> hasItem &lt;span style="color:#f92672">?&lt;/span> p : &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (p &lt;span style="color:#f92672">==&lt;/span> q) &lt;span style="color:#66d9ef">continue&lt;/span> restartFromHead;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> p &lt;span style="color:#f92672">=&lt;/span> q; &lt;span style="color:#75715e">// p = p.next&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于在插入与删除元素时，都会执行&lt;code>updateHead(h, p)&lt;/code>方法，所以该方法的执行的时间复杂度可以近似为&lt;code>O(1)&lt;/code>。而 &lt;code>size()&lt;/code> 方法需要遍历整个链表，时间复杂度为&lt;code>O(n)&lt;/code>&lt;/p></description></item><item><title>Java内存区域详解（重点）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/memory-area/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/memory-area/</guid><description>&lt;blockquote>
&lt;p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。&lt;/p>
&lt;p>本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。&lt;/p>
&lt;p>常见面试题：&lt;/p>
&lt;ul>
&lt;li>介绍下 Java 内存区域（运行时数据区）&lt;/li>
&lt;li>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）&lt;/li>
&lt;li>对象的访问定位的两种方式（句柄和直接指针两种方式）&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。&lt;/p>
&lt;h2 id="运行时数据区域">
 运行时数据区域
 &lt;a class="anchor" href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e6%95%b0%e6%8d%ae%e5%8c%ba%e5%9f%9f">#&lt;/a>
&lt;/h2>
&lt;p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。&lt;/p>
&lt;p>JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。&lt;/p>
&lt;p>&lt;strong>JDK 1.7&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png" alt="Java 运行时数据区域（JDK1.7）" />&lt;/p>
&lt;p>&lt;strong>JDK 1.8&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）" />&lt;/p>
&lt;p>&lt;strong>线程私有的：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>程序计数器&lt;/li>
&lt;li>虚拟机栈&lt;/li>
&lt;li>本地方法栈&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>线程共享的：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>堆&lt;/li>
&lt;li>方法区&lt;/li>
&lt;li>直接内存 (非运行时数据区的一部分)&lt;/li>
&lt;/ul>
&lt;p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。&lt;/p>
&lt;h3 id="程序计数器">
 程序计数器
 &lt;a class="anchor" href="#%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8">#&lt;/a>
&lt;/h3>
&lt;p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。&lt;/p></description></item><item><title>JDK监控和故障处理工具总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/jdk-monitoring-and-troubleshooting-tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/jdk-monitoring-and-troubleshooting-tools/</guid><description>&lt;h2 id="jdk-命令行工具">
 JDK 命令行工具
 &lt;a class="anchor" href="#jdk-%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%b7%a5%e5%85%b7">#&lt;/a>
&lt;/h2>
&lt;p>这些命令在 JDK 安装目录下的 bin 目录下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>jps&lt;/code>&lt;/strong> (JVM Process Status）: 类似 UNIX 的 &lt;code>ps&lt;/code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；&lt;/li>
&lt;li>&lt;strong>&lt;code>jstat&lt;/code>&lt;/strong>（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;&lt;/li>
&lt;li>&lt;strong>&lt;code>jinfo&lt;/code>&lt;/strong> (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;&lt;/li>
&lt;li>&lt;strong>&lt;code>jmap&lt;/code>&lt;/strong> (Memory Map for Java) : 生成堆转储快照;&lt;/li>
&lt;li>&lt;strong>&lt;code>jhat&lt;/code>&lt;/strong> (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。JDK9 移除了 jhat；&lt;/li>
&lt;li>&lt;strong>&lt;code>jstack&lt;/code>&lt;/strong> (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。&lt;/li>
&lt;/ul>
&lt;h3 id="jps查看所有-java-进程">
 &lt;code>jps&lt;/code>:查看所有 Java 进程
 &lt;a class="anchor" href="#jps%e6%9f%a5%e7%9c%8b%e6%89%80%e6%9c%89-java-%e8%bf%9b%e7%a8%8b">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>jps&lt;/code>(JVM Process Status) 命令类似 UNIX 的 &lt;code>ps&lt;/code> 命令。&lt;/p></description></item><item><title>JMM（Java 内存模型）详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/jmm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/jmm/</guid><description>&lt;p>JMM(Java 内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。&lt;/p>
&lt;p>要想理解透彻 JMM（Java 内存模型），我们先要从 &lt;strong>CPU 缓存模型和指令重排序&lt;/strong> 说起！&lt;/p>
&lt;h2 id="从-cpu-缓存模型说起">
 从 CPU 缓存模型说起
 &lt;a class="anchor" href="#%e4%bb%8e-cpu-%e7%bc%93%e5%ad%98%e6%a8%a1%e5%9e%8b%e8%af%b4%e8%b5%b7">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>为什么要弄一个 CPU 高速缓存呢？&lt;/strong> 类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 &lt;strong>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。&lt;/strong>&lt;/p>
&lt;p>我们甚至可以把 &lt;strong>内存看作外存的高速缓存&lt;/strong>，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。&lt;/p>
&lt;p>总结：&lt;strong>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。&lt;/strong>&lt;/p>
&lt;p>为了更好地理解，我画了一个简单的 CPU Cache 示意图如下所示。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>🐛 修正（参见：&lt;a href="https://github.com/Snailclimb/JavaGuide/issues/1848">issue#1848&lt;/a>）&lt;/strong>：对 CPU 缓存模型绘图不严谨的地方进行完善。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/concurrent/cpu-cache.png" alt="CPU 缓存模型示意图" />&lt;/p>
&lt;p>现代的 CPU Cache 通常分为三层，分别叫 L1,L2,L3 Cache。有些 CPU 可能还有 L4 Cache，这里不做讨论，并不常见&lt;/p>
&lt;p>&lt;strong>CPU Cache 的工作方式：&lt;/strong> 先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 &lt;strong>内存缓存不一致性的问题&lt;/strong> ！比如我执行一个 i++ 操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 i++ 运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。&lt;/p></description></item><item><title>JVM垃圾回收详解（重点）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/jvm-garbage-collection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/jvm-garbage-collection/</guid><description>&lt;blockquote>
&lt;p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。&lt;/p>
&lt;p>本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。&lt;/p>
&lt;p>常见面试题：&lt;/p>
&lt;ul>
&lt;li>如何判断对象是否死亡（两种方法）。&lt;/li>
&lt;li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。&lt;/li>
&lt;li>如何判断一个常量是废弃常量&lt;/li>
&lt;li>如何判断一个类是无用的类&lt;/li>
&lt;li>垃圾收集有哪些算法，各自的特点？&lt;/li>
&lt;li>HotSpot 为什么要分为新生代和老年代？&lt;/li>
&lt;li>常见的垃圾回收器有哪些？&lt;/li>
&lt;li>介绍一下 CMS,G1 收集器。&lt;/li>
&lt;li>Minor Gc 和 Full GC 有什么不同呢？&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。&lt;/p>
&lt;h2 id="堆空间的基本结构">
 堆空间的基本结构
 &lt;a class="anchor" href="#%e5%a0%86%e7%a9%ba%e9%97%b4%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 &lt;strong>堆&lt;/strong> 内存中对象的分配与回收。&lt;/p>
&lt;p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 &lt;strong>GC 堆（Garbage Collected Heap）&lt;/strong>。&lt;/p>
&lt;p>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。&lt;/p>
&lt;p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：&lt;/p>
&lt;ol>
&lt;li>新生代内存(Young Generation)&lt;/li>
&lt;li>老生代(Old Generation)&lt;/li>
&lt;li>永久代(Permanent Generation)&lt;/li>
&lt;/ol>
&lt;p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/jvm/hotspot-heap-structure.png" alt="堆内存结构" />&lt;/p></description></item><item><title>JVM线上问题排查和性能调优案例</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/jvm-in-action/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/jvm-in-action/</guid><description>&lt;p>JVM 线上问题排查和性能调优也是面试常问的一个问题，尤其是社招中大厂的面试。&lt;/p>
&lt;p>这篇文章，我会分享一些我看到的相关的案例。&lt;/p>
&lt;p>下面是正文。&lt;/p>
&lt;p>&lt;a href="https://juejin.cn/post/7205141492264976445">一次线上 OOM 问题分析 - 艾小仙 - 2023&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>现象&lt;/strong>：线上某个服务有接口非常慢，通过监控链路查看发现，中间的 GAP 时间非常大，实际接口并没有消耗很多时间，并且在那段时间里有很多这样的请求。&lt;/li>
&lt;li>&lt;strong>分析&lt;/strong>：使用 JDK 自带的&lt;code>jvisualvm&lt;/code>分析 dump 文件(MAT 也能分析)。&lt;/li>
&lt;li>&lt;strong>建议&lt;/strong>：对于 SQL 语句，如果监测到没有&lt;code>where&lt;/code>条件的全表查询应该默认增加一个合适的&lt;code>limit&lt;/code>作为限制，防止这种问题拖垮整个系统&lt;/li>
&lt;li>&lt;strong>资料&lt;/strong>：&lt;a href="https://heapdump.cn/article/3489050">实战案例：记一次 dump 文件分析历程转载 - HeapDump - 2022&lt;/a>。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.cnblogs.com/mylibs/p/production-accident-0002.html">生产事故-记一次特殊的 OOM 排查 - 程语有云 - 2023&lt;/a>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>现象&lt;/strong>：网络没有问题的情况下，系统某开放接口从 2023 年 3 月 10 日 14 时许开始无法访问和使用。&lt;/li>
&lt;li>&lt;strong>临时解决办法&lt;/strong>：紧急回滚至上一稳定版本。&lt;/li>
&lt;li>&lt;strong>分析&lt;/strong>：使用 MAT (Memory Analyzer Tool)工具分析 dump 文件。&lt;/li>
&lt;li>&lt;strong>建议&lt;/strong>：正常情况下，&lt;code>-Xmn&lt;/code>参数（控制 Young 区的大小）总是应当小于&lt;code>-Xmx&lt;/code>参数（控制堆内存的最大大小），否则就会触发 OOM 错误。&lt;/li>
&lt;li>&lt;strong>资料&lt;/strong>：&lt;a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html">最重要的 JVM 参数总结 - JavaGuide - 2023&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://juejin.cn/post/7078624931826794503">一次大量 JVM Native 内存泄露的排查分析（64M 问题） - 掘金 - 2022&lt;/a>&lt;/p></description></item><item><title>JWT 基础概念详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/jwt-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/jwt-intro/</guid><description>&lt;h2 id="什么是-jwt">
 什么是 JWT?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-jwt">#&lt;/a>
&lt;/h2>
&lt;p>JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，是一种基于 Token 的认证授权机制。 从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。&lt;/p>
&lt;p>JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。&lt;/p>
&lt;p>可以看出，&lt;strong>JWT 更符合设计 RESTful API 时的「Stateless（无状态）」原则&lt;/strong> 。&lt;/p>
&lt;p>并且， 使用 JWT 认证可以有效避免 CSRF 攻击，因为 JWT 一般是存在在 localStorage 中，使用 JWT 进行身份验证的过程中是不会涉及到 Cookie 的。&lt;/p>
&lt;p>我在 &lt;a href="./advantages-and-disadvantages-of-jwt.md">JWT 优缺点分析&lt;/a>这篇文章中有详细介绍到使用 JWT 做身份认证的优势和劣势。&lt;/p>
&lt;p>下面是 &lt;a href="https://tools.ietf.org/html/rfc7519">RFC 7519&lt;/a> 对 JWT 做的较为正式的定义。&lt;/p>
&lt;blockquote>
&lt;p>JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. ——&lt;a href="https://tools.ietf.org/html/rfc7519">JSON Web Token (JWT)&lt;/a>&lt;/p></description></item><item><title>JWT 身份认证优缺点分析</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/advantages-and-disadvantages-of-jwt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/advantages-and-disadvantages-of-jwt/</guid><description>&lt;p>校招面试中，遇到大部分的候选者认证登录这块用的都是 JWT。提问 JWT 的概念性问题以及使用 JWT 的原因，基本都能回答一些，但当问到 JWT 存在的一些问题和解决方案时，只有一小部分候选者回答的还可以。&lt;/p>
&lt;p>JWT 不是银弹，也有很多缺陷，很多时候并不是最优的选择。这篇文章，我们一起探讨一下 JWT 身份认证的优缺点以及常见问题的解决办法，来看看为什么很多人不再推荐使用 JWT 了。&lt;/p>
&lt;p>关于 JWT 的基本概念介绍请看我写的这篇文章： &lt;a href="https://javaguide.cn/system-design/security/jwt-intro.html">JWT 基本概念详解&lt;/a>。&lt;/p>
&lt;h2 id="jwt-的优势">
 JWT 的优势
 &lt;a class="anchor" href="#jwt-%e7%9a%84%e4%bc%98%e5%8a%bf">#&lt;/a>
&lt;/h2>
&lt;p>相比于 Session 认证的方式来说，使用 JWT 进行身份认证主要有下面 4 个优势。&lt;/p>
&lt;h3 id="无状态">
 无状态
 &lt;a class="anchor" href="#%e6%97%a0%e7%8a%b6%e6%80%81">#&lt;/a>
&lt;/h3>
&lt;p>JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 JWT 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。&lt;/p>
&lt;p>不过，也正是由于 JWT 的无状态，也导致了它最大的缺点：&lt;strong>不可控！&lt;/strong>&lt;/p>
&lt;p>就比如说，我们想要在 JWT 有效期内废弃一个 JWT 或者更改它的权限的话，并不会立即生效，通常需要等到有效期过后才可以。再比如说，当用户 Logout 的话，JWT 也还有效。除非，我们在后端增加额外的处理逻辑比如将失效的 JWT 存储起来，后端先验证 JWT 是否有效再进行处理。具体的解决办法，我们会在后面的内容中详细介绍到，这里只是简单提一下。&lt;/p>
&lt;h3 id="有效避免了-csrf-攻击">
 有效避免了 CSRF 攻击
 &lt;a class="anchor" href="#%e6%9c%89%e6%95%88%e9%81%bf%e5%85%8d%e4%ba%86-csrf-%e6%94%bb%e5%87%bb">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>CSRF（Cross Site Request Forgery）&lt;/strong> 一般被翻译为 &lt;strong>跨站请求伪造&lt;/strong>，属于网络攻击领域范围。相比于 SQL 脚本注入、XSS 等安全攻击方式，CSRF 的知名度并没有它们高。但是，它的确是我们开发系统时必须要考虑的安全隐患。就连业内技术标杆 Google 的产品 Gmail 也曾在 2007 年的时候爆出过 CSRF 漏洞，这给 Gmail 的用户造成了很大的损失。&lt;/p></description></item><item><title>Kafka常见问题总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/message-queue/kafka-questions-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/message-queue/kafka-questions-01/</guid><description>&lt;h2 id="kafka-基础">
 Kafka 基础
 &lt;a class="anchor" href="#kafka-%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;h3 id="kafka-是什么主要应用场景有哪些">
 Kafka 是什么？主要应用场景有哪些？
 &lt;a class="anchor" href="#kafka-%e6%98%af%e4%bb%80%e4%b9%88%e4%b8%bb%e8%a6%81%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e6%9c%89%e5%93%aa%e4%ba%9b">#&lt;/a>
&lt;/h3>
&lt;p>Kafka 是一个分布式流式处理平台。这到底是什么意思呢？&lt;/p>
&lt;p>流平台具有三个关键功能：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>消息队列&lt;/strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。&lt;/li>
&lt;li>&lt;strong>容错的持久方式存储记录消息流&lt;/strong>：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。&lt;/li>
&lt;li>&lt;strong>流式处理平台：&lt;/strong> 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。&lt;/li>
&lt;/ol>
&lt;p>Kafka 主要有两大应用场景：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>消息队列&lt;/strong>：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。&lt;/li>
&lt;li>&lt;strong>数据处理：&lt;/strong> 构建实时的流数据处理程序来转换或处理数据流。&lt;/li>
&lt;/ol>
&lt;h3 id="和其他消息队列相比kafka-的优势在哪里">
 和其他消息队列相比,Kafka 的优势在哪里？
 &lt;a class="anchor" href="#%e5%92%8c%e5%85%b6%e4%bb%96%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e7%9b%b8%e6%af%94kafka-%e7%9a%84%e4%bc%98%e5%8a%bf%e5%9c%a8%e5%93%aa%e9%87%8c">#&lt;/a>
&lt;/h3>
&lt;p>我们现在经常提到 Kafka 的时候就已经默认它是一个非常优秀的消息队列了，我们也会经常拿它跟 RocketMQ、RabbitMQ 对比。我觉得 Kafka 相比其他消息队列主要的优势如下：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>极致的性能&lt;/strong>：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。&lt;/li>
&lt;li>&lt;strong>生态系统兼容性无可匹敌&lt;/strong>：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。&lt;/li>
&lt;/ol>
&lt;p>实际上在早期的时候 Kafka 并不是一个合格的消息队列，早期的 Kafka 在消息队列领域就像是一个衣衫褴褛的孩子一样，功能不完备并且有一些小问题比如丢失消息、不保证消息可靠性等等。当然，这也和 LinkedIn 最早开发 Kafka 用于处理海量的日志有很大关系，哈哈哈，人家本来最开始就不是为了作为消息队列滴，谁知道后面误打误撞在消息队列领域占据了一席之地。&lt;/p>
&lt;p>随着后续的发展，这些短板都被 Kafka 逐步修复完善。所以，&lt;strong>Kafka 作为消息队列不可靠这个说法已经过时！&lt;/strong>&lt;/p>
&lt;h3 id="队列模型了解吗kafka-的消息模型知道吗">
 队列模型了解吗？Kafka 的消息模型知道吗？
 &lt;a class="anchor" href="#%e9%98%9f%e5%88%97%e6%a8%a1%e5%9e%8b%e4%ba%86%e8%a7%a3%e5%90%97kafka-%e7%9a%84%e6%b6%88%e6%81%af%e6%a8%a1%e5%9e%8b%e7%9f%a5%e9%81%93%e5%90%97">#&lt;/a>
&lt;/h3>
&lt;blockquote>
&lt;p>题外话：早期的 JMS 和 AMQP 属于消息服务领域权威组织所做的相关的标准，我在 &lt;a href="https://github.com/Snailclimb/JavaGuide">JavaGuide&lt;/a>的 &lt;a href="https://github.com/Snailclimb/JavaGuide#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E4%B8%AD%E9%97%B4%E4%BB%B6">《消息队列其实很简单》&lt;/a>这篇文章中介绍过。但是，这些标准的进化跟不上消息队列的演进速度，这些标准实际上已经属于废弃状态。所以，可能存在的情况是：不同的消息队列都有自己的一套消息模型。&lt;/p>
&lt;/blockquote>
&lt;h4 id="队列模型早期的消息模型">
 队列模型：早期的消息模型
 &lt;a class="anchor" href="#%e9%98%9f%e5%88%97%e6%a8%a1%e5%9e%8b%e6%97%a9%e6%9c%9f%e7%9a%84%e6%b6%88%e6%81%af%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h4>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B23.png" alt="队列模型" />&lt;/p>
&lt;p>&lt;strong>使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。&lt;/strong> 比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）&lt;/p></description></item><item><title>LinkedHashMap 源码分析</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/linkedhashmap-source-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/linkedhashmap-source-code/</guid><description>&lt;h2 id="linkedhashmap-简介">
 LinkedHashMap 简介
 &lt;a class="anchor" href="#linkedhashmap-%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>LinkedHashMap&lt;/code> 是 Java 提供的一个集合类，它继承自 &lt;code>HashMap&lt;/code>，并在 &lt;code>HashMap&lt;/code> 基础上维护一条双向链表，使得具备如下特性:&lt;/p>
&lt;ol>
&lt;li>支持遍历时会按照插入顺序有序进行迭代。&lt;/li>
&lt;li>支持按照元素访问顺序排序,适用于封装 LRU 缓存工具。&lt;/li>
&lt;li>因为内部使用双向链表维护各个节点，所以遍历时的效率和元素个数成正比，相较于和容量成正比的 HashMap 来说，迭代效率会高很多。&lt;/li>
&lt;/ol>
&lt;p>&lt;code>LinkedHashMap&lt;/code> 逻辑结构如下图所示，它是在 &lt;code>HashMap&lt;/code> 基础上在各个节点之间维护一条双向链表，使得原本散列在不同 bucket 上的节点、链表、红黑树有序关联起来。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/collection/linkhashmap-structure-overview.png" alt="LinkedHashMap 逻辑结构" />&lt;/p>
&lt;h2 id="linkedhashmap-使用示例">
 LinkedHashMap 使用示例
 &lt;a class="anchor" href="#linkedhashmap-%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="插入顺序遍历">
 插入顺序遍历
 &lt;a class="anchor" href="#%e6%8f%92%e5%85%a5%e9%a1%ba%e5%ba%8f%e9%81%8d%e5%8e%86">#&lt;/a>
&lt;/h3>
&lt;p>如下所示，我们按照顺序往 &lt;code>LinkedHashMap&lt;/code> 添加元素然后进行遍历。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>HashMap &lt;span style="color:#f92672">&amp;lt;&lt;/span> String, String &lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LinkedHashMap &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> ();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>map.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;a&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;2&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>map.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;g&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;3&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>map.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;r&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>map.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;e&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;23&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (Map.&lt;span style="color:#a6e22e">Entry&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> String, String &lt;span style="color:#f92672">&amp;gt;&lt;/span> entry: map.&lt;span style="color:#a6e22e">entrySet&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(entry.&lt;span style="color:#a6e22e">getKey&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> entry.&lt;span style="color:#a6e22e">getValue&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>a:2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>g:3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>r:1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>e:23
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看出，&lt;code>LinkedHashMap&lt;/code> 的迭代顺序是和插入顺序一致的,这一点是 &lt;code>HashMap&lt;/code> 所不具备的。&lt;/p>
&lt;h3 id="访问顺序遍历">
 访问顺序遍历
 &lt;a class="anchor" href="#%e8%ae%bf%e9%97%ae%e9%a1%ba%e5%ba%8f%e9%81%8d%e5%8e%86">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>LinkedHashMap&lt;/code> 定义了排序模式 &lt;code>accessOrder&lt;/code>(boolean 类型，默认为 false)，访问顺序则为 true，插入顺序则为 false。&lt;/p></description></item><item><title>LinkedList 源码分析</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/linkedlist-source-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/linkedlist-source-code/</guid><description>&lt;h2 id="linkedlist-简介">
 LinkedList 简介
 &lt;a class="anchor" href="#linkedlist-%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>LinkedList&lt;/code> 是一个基于双向链表实现的集合类，经常被拿来和 &lt;code>ArrayList&lt;/code> 做比较。关于 &lt;code>LinkedList&lt;/code> 和&lt;code>ArrayList&lt;/code>的详细对比，我们 &lt;a href="./java-collection-questions-01.md">Java 集合常见面试题总结(上)&lt;/a>有详细介绍到。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/bidirectional-linkedlist.png" alt="双向链表" />&lt;/p>
&lt;p>不过，我们在项目中一般是不会使用到 &lt;code>LinkedList&lt;/code> 的，需要用到 &lt;code>LinkedList&lt;/code> 的场景几乎都可以使用 &lt;code>ArrayList&lt;/code> 来代替，并且，性能通常会更好！就连 &lt;code>LinkedList&lt;/code> 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 &lt;code>LinkedList&lt;/code> 。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/redisimage-20220412110853807.png" alt="" />&lt;/p>
&lt;p>另外，不要下意识地认为 &lt;code>LinkedList&lt;/code> 作为链表就最适合元素增删的场景。我在上面也说了，&lt;code>LinkedList&lt;/code> 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n) 。&lt;/p>
&lt;h3 id="linkedlist-插入和删除元素的时间复杂度">
 LinkedList 插入和删除元素的时间复杂度？
 &lt;a class="anchor" href="#linkedlist-%e6%8f%92%e5%85%a5%e5%92%8c%e5%88%a0%e9%99%a4%e5%85%83%e7%b4%a0%e7%9a%84%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。&lt;/li>
&lt;li>尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。&lt;/li>
&lt;li>指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，不过由于有头尾指针，可以从较近的指针出发，因此需要遍历平均 n/4 个元素，时间复杂度为 O(n)。&lt;/li>
&lt;/ul>
&lt;h3 id="linkedlist-为什么不能实现-randomaccess-接口">
 LinkedList 为什么不能实现 RandomAccess 接口？
 &lt;a class="anchor" href="#linkedlist-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e5%ae%9e%e7%8e%b0-randomaccess-%e6%8e%a5%e5%8f%a3">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>RandomAccess&lt;/code> 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 &lt;code>LinkedList&lt;/code> 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 &lt;code>RandomAccess&lt;/code> 接口。&lt;/p>
&lt;h2 id="linkedlist-源码分析">
 LinkedList 源码分析
 &lt;a class="anchor" href="#linkedlist-%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h2>
&lt;p>这里以 JDK1.8 为例，分析一下 &lt;code>LinkedList&lt;/code> 的底层核心源码。&lt;/p>
&lt;p>&lt;code>LinkedList&lt;/code> 的类定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LinkedList&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">extends&lt;/span> AbstractSequentialList&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">implements&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span>, Deque&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span>, Cloneable, java.&lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Serializable&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>LinkedList&lt;/code> 继承了 &lt;code>AbstractSequentialList&lt;/code> ，而 &lt;code>AbstractSequentialList&lt;/code> 又继承于 &lt;code>AbstractList&lt;/code> 。&lt;/p></description></item><item><title>Linux 基础知识总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/linux-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/linux-intro/</guid><description>&lt;p>简单介绍一下 Java 程序员必知的 Linux 的一些概念以及常见命令。&lt;/p>
&lt;h2 id="初探-linux">
 初探 Linux
 &lt;a class="anchor" href="#%e5%88%9d%e6%8e%a2-linux">#&lt;/a>
&lt;/h2>
&lt;h3 id="linux-简介">
 Linux 简介
 &lt;a class="anchor" href="#linux-%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h3>
&lt;p>通过以下三点可以概括 Linux 到底是什么：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>类 Unix 系统&lt;/strong>：Linux 是一种自由、开放源码的类似 Unix 的操作系统&lt;/li>
&lt;li>&lt;strong>Linux 本质是指 Linux 内核&lt;/strong>：严格来讲，Linux 这个词本身只表示 Linux 内核，单独的 Linux 内核并不能成为一个可以正常工作的操作系统。所以，就有了各种 Linux 发行版。&lt;/li>
&lt;li>&lt;strong>Linux 之父(林纳斯·本纳第克特·托瓦兹 Linus Benedict Torvalds)&lt;/strong>：一个编程领域的传奇式人物，真大佬！我辈崇拜敬仰之楷模。他是 &lt;strong>Linux 内核&lt;/strong> 的最早作者，随后发起了这个开源项目，担任 Linux 内核的首要架构师。他还发起了 Git 这个开源项目，并为主要的开发者。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/linux/linux-father.png" alt="Linux 之父" />&lt;/p>
&lt;h3 id="linux-诞生">
 Linux 诞生
 &lt;a class="anchor" href="#linux-%e8%af%9e%e7%94%9f">#&lt;/a>
&lt;/h3>
&lt;p>1989 年，Linus Torvalds 进入芬兰陆军新地区旅，服 11 个月的国家义务兵役，军衔为少尉，主要服务于计算机部门，任务是弹道计算。服役期间，购买了安德鲁·斯图尔特·塔能鲍姆所著的教科书及 minix 源代码，开始研究操作系统。1990 年，他退伍后回到大学，开始接触 Unix。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Minix&lt;/strong> 是一个迷你版本的类 Unix 操作系统，由塔能鲍姆教授为了教学之用而创作，采用微核心设计。它启发了 Linux 内核的创作。&lt;/p>
&lt;/blockquote>
&lt;p>1991 年，Linus Torvalds 开源了 Linux 内核。Linux 以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。&lt;/p></description></item><item><title>Maven核心概念总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/maven/maven-core-concepts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/maven/maven-core-concepts/</guid><description>&lt;blockquote>
&lt;p>这部分内容主要根据 Maven 官方文档整理，做了对应的删减，主要保留比较重要的部分，不涉及实战，主要是一些重要概念的介绍。&lt;/p>
&lt;/blockquote>
&lt;h2 id="maven-介绍">
 Maven 介绍
 &lt;a class="anchor" href="#maven-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://github.com/apache/maven">Maven&lt;/a> 官方文档是这样介绍的 Maven 的：&lt;/p>
&lt;blockquote>
&lt;p>Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project&amp;rsquo;s build, reporting and documentation from a central piece of information.&lt;/p>
&lt;p>Apache Maven 的本质是一个软件项目管理和理解工具。基于项目对象模型 (Project Object Model，POM) 的概念，Maven 可以从一条中心信息管理项目的构建、报告和文档。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>什么是 POM？&lt;/strong> 每一个 Maven 工程都有一个 &lt;code>pom.xml&lt;/code> 文件，位于根目录中，包含项目构建生命周期的详细信息。通过 &lt;code>pom.xml&lt;/code> 文件，我们可以定义项目的坐标、项目依赖、项目信息、插件信息等等配置。&lt;/p>
&lt;p>对于开发者来说，Maven 的主要作用主要有 3 个：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>项目构建&lt;/strong>：提供标准的、跨平台的自动化项目构建方式。&lt;/li>
&lt;li>&lt;strong>依赖管理&lt;/strong>：方便快捷的管理项目依赖的资源（jar 包），避免资源间的版本冲突问题。&lt;/li>
&lt;li>&lt;strong>统一开发结构&lt;/strong>：提供标准的、统一的项目结构。&lt;/li>
&lt;/ol>
&lt;p>关于 Maven 的基本使用这里就不介绍了，建议看看官网的 5 分钟上手 Maven 的教程：&lt;a href="https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html">Maven in 5 Minutes&lt;/a> 。&lt;/p></description></item><item><title>Maven最佳实践</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/maven/maven-best-practices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/tools/maven/maven-best-practices/</guid><description>&lt;blockquote>
&lt;p>本文由 JavaGuide 翻译并完善，原文地址：&lt;a href="https://medium.com/@AlexanderObregon/maven-best-practices-tips-and-tricks-for-java-developers-438eca03f72b">https://medium.com/@AlexanderObregon/maven-best-practices-tips-and-tricks-for-java-developers-438eca03f72b&lt;/a> 。&lt;/p>
&lt;/blockquote>
&lt;p>Maven 是一种广泛使用的 Java 项目构建自动化工具。它简化了构建过程并帮助管理依赖关系，使开发人员的工作更轻松。Maven 详细介绍可以参考我写的这篇 &lt;a href="./maven-core-concepts.md">Maven 核心概念总结&lt;/a> 。&lt;/p>
&lt;p>这篇文章不会涉及到 Maven 概念的介绍，主要讨论一些最佳实践、建议和技巧，以优化我们在项目中对 Maven 的使用并改善我们的开发体验。&lt;/p>
&lt;h2 id="maven-标准目录结构">
 Maven 标准目录结构
 &lt;a class="anchor" href="#maven-%e6%a0%87%e5%87%86%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>Maven 遵循标准目录结构来保持项目之间的一致性。遵循这种结构可以让其他开发人员更轻松地理解我们的项目。&lt;/p>
&lt;p>Maven 项目的标准目录结构如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>src&lt;span style="color:#e6db74">/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> main/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> java&lt;span style="color:#e6db74">/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> resources/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> test&lt;span style="color:#e6db74">/
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> java/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resources&lt;span style="color:#f92672">/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pom&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">xml&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>src/main/java&lt;/code>：源代码目录&lt;/li>
&lt;li>&lt;code>src/main/resources&lt;/code>：资源文件目录&lt;/li>
&lt;li>&lt;code>src/test/java&lt;/code>：测试代码目录&lt;/li>
&lt;li>&lt;code>src/test/resources&lt;/code>：测试资源文件目录&lt;/li>
&lt;/ul>
&lt;p>这只是一个最简单的 Maven 项目目录示例。实际项目中，我们还会根据项目规范去做进一步的细分。&lt;/p>
&lt;h2 id="指定-maven-编译器插件">
 指定 Maven 编译器插件
 &lt;a class="anchor" href="#%e6%8c%87%e5%ae%9a-maven-%e7%bc%96%e8%af%91%e5%99%a8%e6%8f%92%e4%bb%b6">#&lt;/a>
&lt;/h2>
&lt;p>默认情况下，Maven 使用 Java5 编译我们的项目。要使用不同的 JDK 版本，请在 &lt;code>pom.xml&lt;/code> 文件中配置 Maven 编译器插件。&lt;/p>
&lt;p>例如，如果你想要使用 Java8 来编译你的项目，你可以在&lt;code>&amp;lt;build&amp;gt;&lt;/code>标签下添加以下的代码片段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;build&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugins&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.apache.maven.plugins&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>maven-compiler-plugin&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>3.8.1&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;configuration&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;source&amp;gt;&lt;/span>1.8&lt;span style="color:#f92672">&amp;lt;/source&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;target&amp;gt;&lt;/span>1.8&lt;span style="color:#f92672">&amp;lt;/target&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/configuration&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/plugins&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/build&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样，Maven 就会使用 Java8 的编译器来编译你的项目。如果你想要使用其他版本的 JDK，你只需要修改&lt;code>&amp;lt;source&amp;gt;&lt;/code>和&lt;code>&amp;lt;target&amp;gt;&lt;/code>标签的值即可。例如，如果你想要使用 Java11，你可以将它们的值改为 11。&lt;/p></description></item><item><title>MongoDB常见面试题总结（上）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mongodb/mongodb-questions-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mongodb/mongodb-questions-01/</guid><description>&lt;blockquote>
&lt;p>少部分内容参考了 MongoDB 官方文档的描述，在此说明一下。&lt;/p>
&lt;/blockquote>
&lt;h2 id="mongodb-基础">
 MongoDB 基础
 &lt;a class="anchor" href="#mongodb-%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;h3 id="mongodb-是什么">
 MongoDB 是什么？
 &lt;a class="anchor" href="#mongodb-%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>MongoDB 是一个基于 &lt;strong>分布式文件存储&lt;/strong> 的开源 NoSQL 数据库系统，由 &lt;strong>C++&lt;/strong> 编写的。MongoDB 提供了 &lt;strong>面向文档&lt;/strong> 的存储方式，操作起来比较简单和容易，支持“&lt;strong>无模式&lt;/strong>”的数据建模，可以存储比较复杂的数据类型，是一款非常流行的 &lt;strong>文档类型数据库&lt;/strong> 。&lt;/p>
&lt;p>在高负载的情况下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点/实例，以保证服务性能和可用性。在许多场景下，MongoDB 可以用于代替传统的关系型数据库或键/值存储方式，皆在为 Web 应用提供可扩展的高可用高性能数据存储解决方案。&lt;/p>
&lt;h3 id="mongodb-的存储结构是什么">
 MongoDB 的存储结构是什么？
 &lt;a class="anchor" href="#mongodb-%e7%9a%84%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>MongoDB 的存储结构区别于传统的关系型数据库，主要由如下三个单元组成：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>文档（Document）&lt;/strong>：MongoDB 中最基本的单元，由 BSON 键值对（key-value）组成，类似于关系型数据库中的行（Row）。&lt;/li>
&lt;li>&lt;strong>集合（Collection）&lt;/strong>：一个集合可以包含多个文档，类似于关系型数据库中的表（Table）。&lt;/li>
&lt;li>&lt;strong>数据库（Database）&lt;/strong>：一个数据库中可以包含多个集合，可以在 MongoDB 中创建多个数据库，类似于关系型数据库中的数据库（Database）。&lt;/li>
&lt;/ul>
&lt;p>也就是说，MongoDB 将数据记录存储为文档 （更具体来说是&lt;a href="https://www.mongodb.com/docs/manual/core/document/#std-label-bson-document-format">BSON 文档&lt;/a>），这些文档在集合中聚集在一起，数据库中存储一个或多个文档集合。&lt;/p>
&lt;p>&lt;strong>SQL 与 MongoDB 常见术语对比&lt;/strong>：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>SQL&lt;/th>
 &lt;th>MongoDB&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>表（Table）&lt;/td>
 &lt;td>集合（Collection）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>行（Row）&lt;/td>
 &lt;td>文档（Document）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>列（Col）&lt;/td>
 &lt;td>字段（Field）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>主键（Primary Key）&lt;/td>
 &lt;td>对象 ID（Objectid）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>索引（Index）&lt;/td>
 &lt;td>索引（Index）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>嵌套表（Embedded Table）&lt;/td>
 &lt;td>嵌入式文档（Embedded Document）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>数组（Array）&lt;/td>
 &lt;td>数组（Array）&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h4 id="文档">
 文档
 &lt;a class="anchor" href="#%e6%96%87%e6%a1%a3">#&lt;/a>
&lt;/h4>
&lt;p>MongoDB 中的记录就是一个 BSON 文档，它是由键值对组成的数据结构，类似于 JSON 对象，是 MongoDB 中的基本数据单元。字段的值可能包括其他文档、数组和文档数组。&lt;/p></description></item><item><title>MongoDB常见面试题总结（下）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mongodb/mongodb-questions-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mongodb/mongodb-questions-02/</guid><description>&lt;h2 id="mongodb-索引">
 MongoDB 索引
 &lt;a class="anchor" href="#mongodb-%e7%b4%a2%e5%bc%95">#&lt;/a>
&lt;/h2>
&lt;h3 id="mongodb-索引有什么用">
 MongoDB 索引有什么用?
 &lt;a class="anchor" href="#mongodb-%e7%b4%a2%e5%bc%95%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8">#&lt;/a>
&lt;/h3>
&lt;p>和关系型数据库类似，MongoDB 中也有索引。索引的目的主要是用来提高查询效率，如果没有索引的话，MongoDB 必须执行 &lt;strong>集合扫描&lt;/strong> ，即扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在合适的索引，MongoDB 可以使用该索引来限制它必须检查的文档数量。并且，MongoDB 可以使用索引中的排序返回排序后的结果。&lt;/p>
&lt;p>虽然索引可以显著缩短查询时间，但是使用索引、维护索引是有代价的。在执行写入操作时，除了要更新文档之外，还必须更新索引，这必然会影响写入的性能。因此，当有大量写操作而读操作少时，或者不考虑读操作的性能时，都不推荐建立索引。&lt;/p>
&lt;h3 id="mongodb-支持哪些类型的索引">
 MongoDB 支持哪些类型的索引？
 &lt;a class="anchor" href="#mongodb-%e6%94%af%e6%8c%81%e5%93%aa%e4%ba%9b%e7%b1%bb%e5%9e%8b%e7%9a%84%e7%b4%a2%e5%bc%95">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>单字段索引：&lt;/strong> 建立在单个字段上的索引，索引创建的排序顺序无所谓，MongoDB 可以头/尾开始遍历。&lt;/li>
&lt;li>&lt;strong>复合索引：&lt;/strong> 建立在多个字段上的索引，也可以称之为组合索引、联合索引。&lt;/li>
&lt;li>&lt;strong>多键索引&lt;/strong>：MongoDB 的一个字段可能是数组，在对这种字段创建索引时，就是多键索引。MongoDB 会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。&lt;/li>
&lt;li>&lt;strong>哈希索引&lt;/strong>：按数据的哈希值索引，用在哈希分片集群上。&lt;/li>
&lt;li>&lt;strong>文本索引：&lt;/strong> 支持对字符串内容的文本搜索查询。文本索引可以包含任何值为字符串或字符串元素数组的字段。一个集合只能有一个文本搜索索引，但该索引可以覆盖多个字段。MongoDB 虽然支持全文索引，但是性能低下，暂时不建议使用。&lt;/li>
&lt;li>&lt;strong>地理位置索引：&lt;/strong> 基于经纬度的索引，适合 2D 和 3D 的位置查询。&lt;/li>
&lt;li>&lt;strong>唯一索引&lt;/strong>：确保索引字段不会存储重复值。如果集合已经存在了违反索引的唯一约束的文档，则后台创建唯一索引会失败。&lt;/li>
&lt;li>&lt;strong>TTL 索引&lt;/strong>：TTL 索引提供了一个过期机制，允许为每一个文档设置一个过期时间，当一个文档达到预设的过期时间之后就会被删除。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;h3 id="复合索引中字段的顺序有影响吗">
 复合索引中字段的顺序有影响吗？
 &lt;a class="anchor" href="#%e5%a4%8d%e5%90%88%e7%b4%a2%e5%bc%95%e4%b8%ad%e5%ad%97%e6%ae%b5%e7%9a%84%e9%a1%ba%e5%ba%8f%e6%9c%89%e5%bd%b1%e5%93%8d%e5%90%97">#&lt;/a>
&lt;/h3>
&lt;p>复合索引中字段的顺序非常重要，例如下图中的复合索引由&lt;code>{userid:1, score:-1}&lt;/code>组成，则该复合索引首先按照&lt;code>userid&lt;/code>升序排序；然后再每个&lt;code>userid&lt;/code>的值内，再按照&lt;code>score&lt;/code>降序排序。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/database/mongodb/mongodb-composite-index.png" alt="复合索引" />&lt;/p>
&lt;p>在复合索引中，按照何种方式排序，决定了该索引在查询中是否能被应用到。&lt;/p>
&lt;p>走复合索引的排序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>db.s2.find().sort(&lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;userid&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;score&amp;#34;&lt;/span>: &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>db.s2.find().sort(&lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;userid&amp;#34;&lt;/span>: &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;score&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不走复合索引的排序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>db.s2.find().sort(&lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;userid&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;score&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>db.s2.find().sort(&lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;userid&amp;#34;&lt;/span>: &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;score&amp;#34;&lt;/span>: &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>db.s2.find().sort(&lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;score&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;userid&amp;#34;&lt;/span>: &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>db.s2.find().sort(&lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;score&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;userid&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>db.s2.find().sort(&lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;score&amp;#34;&lt;/span>: &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;userid&amp;#34;&lt;/span>: &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>db.s2.find().sort(&lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;score&amp;#34;&lt;/span>: &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;userid&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以通过 explain 进行分析：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>db.s2.find().sort(&lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;score&amp;#34;&lt;/span>: &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;userid&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>).&lt;span style="color:#66d9ef">explain&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="复合索引遵循左前缀原则吗">
 复合索引遵循左前缀原则吗？
 &lt;a class="anchor" href="#%e5%a4%8d%e5%90%88%e7%b4%a2%e5%bc%95%e9%81%b5%e5%be%aa%e5%b7%a6%e5%89%8d%e7%bc%80%e5%8e%9f%e5%88%99%e5%90%97">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>MongoDB 的复合索引遵循左前缀原则&lt;/strong>：拥有多个键的索引，可以同时得到所有这些键的前缀组成的索引，但不包括除左前缀之外的其他子集。比如说，有一个类似 &lt;code>{a: 1, b: 1, c: 1, ..., z: 1}&lt;/code> 这样的索引，那么实际上也等于有了 &lt;code>{a: 1}&lt;/code>、&lt;code>{a: 1, b: 1}&lt;/code>、&lt;code>{a: 1, b: 1, c: 1}&lt;/code> 等一系列索引，但是不会有 &lt;code>{b: 1}&lt;/code> 这样的非左前缀的索引。&lt;/p></description></item><item><title>MyBatis常见面试题总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/mybatis/mybatis-interview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/mybatis/mybatis-interview/</guid><description>&lt;blockquote>
&lt;p>本篇文章由 JavaGuide 收集自网络，原出处不明。&lt;/p>
&lt;p>比起这些枯燥的面试题，我更建议你看看文末推荐的 MyBatis 优质好文。&lt;/p>
&lt;/blockquote>
&lt;h3 id="-和--的区别是什么">
 #{} 和 ${} 的区别是什么？
 &lt;a class="anchor" href="#-%e5%92%8c--%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>注：这道题是面试官面试我同事的。&lt;/p>
&lt;p>答：&lt;/p>
&lt;ul>
&lt;li>&lt;code>${}&lt;/code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于原样文本替换，可以替换任意内容，比如${driver}会被原样替换为&lt;code>com.mysql.jdbc. Driver&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>一个示例：根据参数按任意字段排序：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> users &lt;span style="color:#66d9ef">order&lt;/span> &lt;span style="color:#66d9ef">by&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">${&lt;/span>orderCols&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>orderCols&lt;/code>可以是 &lt;code>name&lt;/code>、&lt;code>name desc&lt;/code>、&lt;code>name,sex asc&lt;/code>等，实现灵活的排序。&lt;/p>
&lt;ul>
&lt;li>&lt;code>#{}&lt;/code>是 sql 的参数占位符，MyBatis 会将 sql 中的&lt;code>#{}&lt;/code>替换为? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的? 号占位符设置参数值，比如 ps.setInt(0, parameterValue)，&lt;code>#{item.name}&lt;/code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 &lt;code>param.getItem().getName()&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h3 id="xml-映射文件中除了常见的-selectinsertupdatedelete-标签之外还有哪些标签">
 xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签？
 &lt;a class="anchor" href="#xml-%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6%e4%b8%ad%e9%99%a4%e4%ba%86%e5%b8%b8%e8%a7%81%e7%9a%84-selectinsertupdatedelete-%e6%a0%87%e7%ad%be%e4%b9%8b%e5%a4%96%e8%bf%98%e6%9c%89%e5%93%aa%e4%ba%9b%e6%a0%87%e7%ad%be">#&lt;/a>
&lt;/h3>
&lt;p>注：这道题是京东面试官面试我时问的。&lt;/p>
&lt;p>答：还有很多其他的标签， &lt;code>&amp;lt;resultMap&amp;gt;&lt;/code>、 &lt;code>&amp;lt;parameterMap&amp;gt;&lt;/code>、 &lt;code>&amp;lt;sql&amp;gt;&lt;/code>、 &lt;code>&amp;lt;include&amp;gt;&lt;/code>、 &lt;code>&amp;lt;selectKey&amp;gt;&lt;/code> ，加上动态 sql 的 9 个标签， &lt;code>trim|where|set|foreach|if|choose|when|otherwise|bind&lt;/code> 等，其中 &lt;code>&amp;lt;sql&amp;gt;&lt;/code> 为 sql 片段标签，通过 &lt;code>&amp;lt;include&amp;gt;&lt;/code> 标签引入 sql 片段， &lt;code>&amp;lt;selectKey&amp;gt;&lt;/code> 为不支持自增的主键生成策略标签。&lt;/p></description></item><item><title>MySQL查询缓存详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-query-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-query-cache/</guid><description>&lt;p>缓存是一个有效且实用的系统性能优化的手段，不论是操作系统还是各种软件和网站或多或少都用到了缓存。&lt;/p>
&lt;p>然而，有经验的 DBA 都建议生产环境中把 MySQL 自带的 Query Cache（查询缓存）给关掉。而且，从 MySQL 5.7.20 开始，就已经默认弃用查询缓存了。在 MySQL 8.0 及之后，更是直接删除了查询缓存的功能。&lt;/p>
&lt;p>这又是为什么呢？查询缓存真就这么鸡肋么?&lt;/p>
&lt;p>带着如下几个问题，我们正式进入本文。&lt;/p>
&lt;ul>
&lt;li>MySQL 查询缓存是什么？适用范围？&lt;/li>
&lt;li>MySQL 缓存规则是什么？&lt;/li>
&lt;li>MySQL 缓存的优缺点是什么？&lt;/li>
&lt;li>MySQL 缓存对性能有什么影响？&lt;/li>
&lt;/ul>
&lt;h2 id="mysql-查询缓存介绍">
 MySQL 查询缓存介绍
 &lt;a class="anchor" href="#mysql-%e6%9f%a5%e8%af%a2%e7%bc%93%e5%ad%98%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>MySQL 体系架构如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/mysql/mysql-architecture.png" alt="" />&lt;/p>
&lt;p>为了提高完全相同的查询语句的响应速度，MySQL Server 会对查询语句进行 Hash 计算得到一个 Hash 值。MySQL Server 不会对 SQL 做任何处理，SQL 必须完全一致 Hash 值才会一样。得到 Hash 值之后，通过该 Hash 值到查询缓存中匹配该查询的结果。&lt;/p>
&lt;ul>
&lt;li>如果匹配（命中），则将查询的结果集直接返回给客户端，不必再解析、执行查询。&lt;/li>
&lt;li>如果没有匹配（未命中），则将 Hash 值和结果集保存在查询缓存中，以便以后使用。&lt;/li>
&lt;/ul>
&lt;p>也就是说，&lt;strong>一个查询语句（select）到了 MySQL Server 之后，会先到查询缓存看看，如果曾经执行过的话，就直接返回结果集给客户端。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png" alt="" />&lt;/p>
&lt;h2 id="mysql-查询缓存管理和配置">
 MySQL 查询缓存管理和配置
 &lt;a class="anchor" href="#mysql-%e6%9f%a5%e8%af%a2%e7%bc%93%e5%ad%98%e7%ae%a1%e7%90%86%e5%92%8c%e9%85%8d%e7%bd%ae">#&lt;/a>
&lt;/h2>
&lt;p>通过 &lt;code>show variables like '%query_cache%'&lt;/code>命令可以查看查询缓存相关的信息。&lt;/p>
&lt;p>8.0 版本之前的话，打印的信息可能是下面这样的：&lt;/p></description></item><item><title>MySQL常见面试题总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-questions-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-questions-01/</guid><description>&lt;h2 id="mysql-基础">
 MySQL 基础
 &lt;a class="anchor" href="#mysql-%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是关系型数据库">
 什么是关系型数据库？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93">#&lt;/a>
&lt;/h3>
&lt;p>顾名思义，关系型数据库（RDB，Relational Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。&lt;/p>
&lt;p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png" alt="关系型数据库表关系" />&lt;/p>
&lt;p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。&lt;/p>
&lt;p>&lt;strong>有哪些常见的关系型数据库呢？&lt;/strong>&lt;/p>
&lt;p>MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ……。&lt;/p>
&lt;h3 id="什么是-sql">
 什么是 SQL？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-sql">#&lt;/a>
&lt;/h3>
&lt;p>SQL 是一种结构化查询语言(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。&lt;/p>
&lt;p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。&lt;/p>
&lt;p>SQL 可以帮助我们：&lt;/p>
&lt;ul>
&lt;li>新建数据库、数据表、字段；&lt;/li>
&lt;li>在数据库中增加，删除，修改，查询数据；&lt;/li>
&lt;li>新建视图、函数、存储过程；&lt;/li>
&lt;li>对数据库中的数据进行简单的数据分析；&lt;/li>
&lt;li>搭配 Hive，Spark SQL 做大数据；&lt;/li>
&lt;li>搭配 SQLFlow 做机器学习；&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;h3 id="什么是-mysql">
 什么是 MySQL？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-mysql">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/csdn/20210327143351823.png" alt="" />&lt;/p>
&lt;p>&lt;strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。&lt;/strong>&lt;/p>
&lt;p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是&lt;strong>3306&lt;/strong>。&lt;/p>
&lt;h3 id="mysql-有什么优点">
 MySQL 有什么优点？
 &lt;a class="anchor" href="#mysql-%e6%9c%89%e4%bb%80%e4%b9%88%e4%bc%98%e7%82%b9">#&lt;/a>
&lt;/h3>
&lt;p>这个问题本质上是在问 MySQL 如此流行的原因。&lt;/p></description></item><item><title>MySQL高性能优化规范建议总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-high-performance-optimization-specification-recommendations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-high-performance-optimization-specification-recommendations/</guid><description>&lt;blockquote>
&lt;p>作者: 听风 原文地址: &lt;a href="https://www.cnblogs.com/huchong/p/10219318.html">https://www.cnblogs.com/huchong/p/10219318.html&lt;/a>。&lt;/p>
&lt;p>JavaGuide 已获得作者授权，并对原文内容进行了完善补充。&lt;/p>
&lt;/blockquote>
&lt;h2 id="数据库命名规范">
 数据库命名规范
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%91%bd%e5%90%8d%e8%a7%84%e8%8c%83">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>所有数据库对象名称必须使用小写字母并用下划线分割&lt;/li>
&lt;li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）&lt;/li>
&lt;li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符&lt;/li>
&lt;li>临时库表必须以 &lt;code>tmp_&lt;/code> 为前缀并以日期为后缀，备份表必须以 &lt;code>bak_&lt;/code> 为前缀并以日期 (时间戳) 为后缀&lt;/li>
&lt;li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）&lt;/li>
&lt;/ul>
&lt;h2 id="数据库基本设计规范">
 数据库基本设计规范
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%9f%ba%e6%9c%ac%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83">#&lt;/a>
&lt;/h2>
&lt;h3 id="所有表必须使用-innodb-存储引擎">
 所有表必须使用 InnoDB 存储引擎
 &lt;a class="anchor" href="#%e6%89%80%e6%9c%89%e8%a1%a8%e5%bf%85%e9%a1%bb%e4%bd%bf%e7%94%a8-innodb-%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e">#&lt;/a>
&lt;/h3>
&lt;p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。&lt;/p>
&lt;p>InnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。&lt;/p>
&lt;h3 id="数据库和表的字符集统一使用-utf8">
 数据库和表的字符集统一使用 UTF8
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%92%8c%e8%a1%a8%e7%9a%84%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bb%9f%e4%b8%80%e4%bd%bf%e7%94%a8-utf8">#&lt;/a>
&lt;/h3>
&lt;p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。&lt;/p>
&lt;p>推荐阅读一下我写的这篇文章：&lt;a href="../character-set.md">MySQL 字符集详解&lt;/a> 。&lt;/p>
&lt;h3 id="所有表和字段都需要添加注释">
 所有表和字段都需要添加注释
 &lt;a class="anchor" href="#%e6%89%80%e6%9c%89%e8%a1%a8%e5%92%8c%e5%ad%97%e6%ae%b5%e9%83%bd%e9%9c%80%e8%a6%81%e6%b7%bb%e5%8a%a0%e6%b3%a8%e9%87%8a">#&lt;/a>
&lt;/h3>
&lt;p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护&lt;/p>
&lt;h3 id="尽量控制单表数据量的大小建议控制在-500-万以内">
 尽量控制单表数据量的大小，建议控制在 500 万以内
 &lt;a class="anchor" href="#%e5%b0%bd%e9%87%8f%e6%8e%a7%e5%88%b6%e5%8d%95%e8%a1%a8%e6%95%b0%e6%8d%ae%e9%87%8f%e7%9a%84%e5%a4%a7%e5%b0%8f%e5%bb%ba%e8%ae%ae%e6%8e%a7%e5%88%b6%e5%9c%a8-500-%e4%b8%87%e4%bb%a5%e5%86%85">#&lt;/a>
&lt;/h3>
&lt;p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。&lt;/p>
&lt;p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小&lt;/p>
&lt;h3 id="谨慎使用-mysql-分区表">
 谨慎使用 MySQL 分区表
 &lt;a class="anchor" href="#%e8%b0%a8%e6%85%8e%e4%bd%bf%e7%94%a8-mysql-%e5%88%86%e5%8c%ba%e8%a1%a8">#&lt;/a>
&lt;/h3>
&lt;p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；&lt;/p></description></item><item><title>MySQL日期类型选择建议</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/some-thoughts-on-database-storage-time/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/some-thoughts-on-database-storage-time/</guid><description>&lt;p>我们平时开发中不可避免的就是要存储时间，比如我们要记录操作表中这条记录的时间、记录转账的交易时间、记录出发时间、用户下单时间等等。你会发现时间这个东西与我们开发的联系还是非常紧密的，用的好与不好会给我们的业务甚至功能带来很大的影响。所以，我们有必要重新出发，好好认识一下这个东西。&lt;/p>
&lt;h2 id="不要用字符串存储日期">
 不要用字符串存储日期
 &lt;a class="anchor" href="#%e4%b8%8d%e8%a6%81%e7%94%a8%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ad%98%e5%82%a8%e6%97%a5%e6%9c%9f">#&lt;/a>
&lt;/h2>
&lt;p>和绝大部分对数据库不太了解的新手一样，我在大学的时候就这样干过，甚至认为这样是一个不错的表示日期的方法。毕竟简单直白，容易上手。&lt;/p>
&lt;p>但是，这是不正确的做法，主要会有下面两个问题：&lt;/p>
&lt;ol>
&lt;li>字符串占用的空间更大！&lt;/li>
&lt;li>字符串存储的日期效率比较低（逐个字符进行比对），无法用日期相关的 API 进行计算和比较。&lt;/li>
&lt;/ol>
&lt;h2 id="datetime-和-timestamp-之间的抉择">
 Datetime 和 Timestamp 之间的抉择
 &lt;a class="anchor" href="#datetime-%e5%92%8c-timestamp-%e4%b9%8b%e9%97%b4%e7%9a%84%e6%8a%89%e6%8b%a9">#&lt;/a>
&lt;/h2>
&lt;p>Datetime 和 Timestamp 是 MySQL 提供的两种比较相似的保存时间的数据类型，可以精确到秒。他们两者究竟该如何选择呢？&lt;/p>
&lt;p>下面我们来简单对比一下二者。&lt;/p>
&lt;h3 id="时区信息">
 时区信息
 &lt;a class="anchor" href="#%e6%97%b6%e5%8c%ba%e4%bf%a1%e6%81%af">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>DateTime 类型是没有时区信息的（时区无关）&lt;/strong> ，DateTime 类型保存的时间都是当前会话所设置的时区对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。&lt;/p>
&lt;p>&lt;strong>Timestamp 和时区有关&lt;/strong>。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。&lt;/p>
&lt;p>下面实际演示一下！&lt;/p>
&lt;p>建表 SQL 语句：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>time_zone_test&lt;span style="color:#f92672">`&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span> bigint(&lt;span style="color:#ae81ff">20&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> AUTO_INCREMENT,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>date_time&lt;span style="color:#f92672">`&lt;/span> datetime &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>time_stamp&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">timestamp&lt;/span> &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">CURRENT_TIMESTAMP&lt;/span> &lt;span style="color:#66d9ef">ON&lt;/span> &lt;span style="color:#66d9ef">UPDATE&lt;/span> &lt;span style="color:#66d9ef">CURRENT_TIMESTAMP&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) ENGINE&lt;span style="color:#f92672">=&lt;/span>InnoDB &lt;span style="color:#66d9ef">DEFAULT&lt;/span> CHARSET&lt;span style="color:#f92672">=&lt;/span>utf8;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>插入数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> time_zone_test(date_time,time_stamp) &lt;span style="color:#66d9ef">VALUES&lt;/span>(NOW(),NOW());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看数据：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> date_time,time_stamp &lt;span style="color:#66d9ef">from&lt;/span> time_zone_test;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>+---------------------+---------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| date_time | time_stamp |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+---------------------+---------------------+
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| 2020-01-11 09:53:32 | 2020-01-11 09:53:32 |
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>+---------------------+---------------------+
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在我们运行&lt;/p></description></item><item><title>MySQL三大日志(binlog、redo log和undo log)详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-logs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-logs/</guid><description>&lt;blockquote>
&lt;p>本文来自公号程序猿阿星投稿，JavaGuide 对其做了补充完善。&lt;/p>
&lt;/blockquote>
&lt;h2 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>MySQL 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 binlog（归档日志）和事务日志 redo log（重做日志）和 undo log（回滚日志）。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/01.png" alt="" />&lt;/p>
&lt;p>今天就来聊聊 redo log（重做日志）、binlog（归档日志）、两阶段提交、undo log（回滚日志）。&lt;/p>
&lt;h2 id="redo-log">
 redo log
 &lt;a class="anchor" href="#redo-log">#&lt;/a>
&lt;/h2>
&lt;p>redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。&lt;/p>
&lt;p>比如 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/02.png" alt="" />&lt;/p>
&lt;p>MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 &lt;code>Buffer Pool&lt;/code> 中。&lt;/p>
&lt;p>后续的查询都是先从 &lt;code>Buffer Pool&lt;/code> 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。&lt;/p>
&lt;p>更新表数据的时候，也是如此，发现 &lt;code>Buffer Pool&lt;/code> 里存在要更新的数据，就直接在 &lt;code>Buffer Pool&lt;/code> 里更新。&lt;/p>
&lt;p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（&lt;code>redo log buffer&lt;/code>）里，接着刷盘到 redo log 文件里。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/03.png" alt="" />&lt;/p>
&lt;blockquote>
&lt;p>图片笔误提示：第 4 步 “清空 redo log buffe 刷盘到 redo 日志中”这句话中的 buffe 应该是 buffer。&lt;/p></description></item><item><title>MySQL事务隔离级别详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/transaction-isolation-level/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/transaction-isolation-level/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="https://github.com/Snailclimb">SnailClimb&lt;/a> 和 &lt;a href="https://github.com/guang19">guang19&lt;/a> 共同完成。&lt;/p>
&lt;/blockquote>
&lt;p>关于事务基本概览的介绍，请看这篇文章的介绍：&lt;a href="./mysql-questions-01.md#MySQL-%e4%ba%8b%e5%8a%a1">MySQL 常见知识点&amp;amp;面试题总结&lt;/a>&lt;/p>
&lt;h2 id="事务隔离级别总结">
 事务隔离级别总结
 &lt;a class="anchor" href="#%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h2>
&lt;p>SQL 标准定义了四个隔离级别：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>READ-UNCOMMITTED(读取未提交)&lt;/strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。&lt;/li>
&lt;li>&lt;strong>READ-COMMITTED(读取已提交)&lt;/strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。&lt;/li>
&lt;li>&lt;strong>REPEATABLE-READ(可重复读)&lt;/strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。&lt;/li>
&lt;li>&lt;strong>SERIALIZABLE(可串行化)&lt;/strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: center">隔离级别&lt;/th>
 &lt;th style="text-align: center">脏读&lt;/th>
 &lt;th style="text-align: center">不可重复读&lt;/th>
 &lt;th style="text-align: center">幻读&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: center">READ-UNCOMMITTED&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">READ-COMMITTED&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">REPEATABLE-READ&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">√&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">SERIALIZABLE&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;td style="text-align: center">×&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 &lt;strong>REPEATABLE-READ（可重读）&lt;/strong>。我们可以通过&lt;code>SELECT @@tx_isolation;&lt;/code>命令来查看，MySQL 8.0 该命令改为&lt;code>SELECT @@transaction_isolation;&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>MySQL&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#f92672">@@&lt;/span>tx_isolation;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#75715e">-----------------+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#f92672">@@&lt;/span>tx_isolation &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#75715e">-----------------+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">REPEATABLE&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#66d9ef">READ&lt;/span> &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#75715e">-----------------+
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面对 SQL 标准定义了四个隔离级别的介绍可以看出，标准的 SQL 隔离级别定义里，REPEATABLE-READ(可重复读)是不可以防止幻读的。&lt;/p>
&lt;p>但是！InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>快照读&lt;/strong>：由 MVCC 机制来保证不出现幻读。&lt;/li>
&lt;li>&lt;strong>当前读&lt;/strong>：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。&lt;/li>
&lt;/ul>
&lt;p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 &lt;strong>READ-COMMITTED&lt;/strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 &lt;strong>REPEATABLE-READ&lt;/strong> 并不会有任何性能损失。&lt;/p></description></item><item><title>MySQL索引详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-index/</guid><description>&lt;blockquote>
&lt;p>感谢&lt;a href="https://github.com/WT-AHA">WT-AHA&lt;/a>对本文的完善，相关 PR：&lt;a href="https://github.com/Snailclimb/JavaGuide/pull/1648">https://github.com/Snailclimb/JavaGuide/pull/1648&lt;/a> 。&lt;/p>
&lt;/blockquote>
&lt;p>但凡经历过几场面试的小伙伴，应该都清楚，数据库索引这个知识点在面试中出现的频率高到离谱。&lt;/p>
&lt;p>除了对于准备面试来说非常重要之外，善用索引对 SQL 的性能提升非常明显，是一个性价比较高的 SQL 优化手段。&lt;/p>
&lt;h2 id="索引介绍">
 索引介绍
 &lt;a class="anchor" href="#%e7%b4%a2%e5%bc%95%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。&lt;/strong>&lt;/p>
&lt;p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。&lt;/p>
&lt;p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。&lt;/p>
&lt;h2 id="索引的优缺点">
 索引的优缺点
 &lt;a class="anchor" href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>优点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。&lt;/li>
&lt;li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。&lt;/li>
&lt;li>索引需要使用物理文件存储，也会耗费一定空间。&lt;/li>
&lt;/ul>
&lt;p>但是，&lt;strong>使用索引一定能提高查询性能吗?&lt;/strong>&lt;/p>
&lt;p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。&lt;/p>
&lt;h2 id="索引底层数据结构选型">
 索引底层数据结构选型
 &lt;a class="anchor" href="#%e7%b4%a2%e5%bc%95%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e9%80%89%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="hash-表">
 Hash 表
 &lt;a class="anchor" href="#hash-%e8%a1%a8">#&lt;/a>
&lt;/h3>
&lt;p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。&lt;/p>
&lt;p>&lt;strong>为何能够通过 key 快速取出 value 呢？&lt;/strong> 原因在于 &lt;strong>哈希算法&lt;/strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>hash &lt;span style="color:#f92672">=&lt;/span> hashfunc(key)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>index &lt;span style="color:#f92672">=&lt;/span> hash &lt;span style="color:#f92672">%&lt;/span> array_size
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/database/mysql20210513092328171.png" alt="" />&lt;/p></description></item><item><title>MySQL隐式转换造成索引失效</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/index-invalidation-caused-by-implicit-conversion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/index-invalidation-caused-by-implicit-conversion/</guid><description>&lt;blockquote>
&lt;p>本次测试使用的 MySQL 版本是 &lt;code>5.7.26&lt;/code>，随着 MySQL 版本的更新某些特性可能会发生改变，本文不代表所述观点和结论于 MySQL 所有版本均准确无误，版本差异请自行甄别。&lt;/p>
&lt;p>原文：&lt;a href="https://www.guitu18.com/post/2019/11/24/61.html">https://www.guitu18.com/post/2019/11/24/61.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>数据库优化是一个任重而道远的任务，想要做优化必须深入理解数据库的各种特性。在开发过程中我们经常会遇到一些原因很简单但造成的后果却很严重的疑难杂症，这类问题往往还不容易定位，排查费时费力最后发现是一个很小的疏忽造成的，又或者是因为不了解某个技术特性产生的。&lt;/p>
&lt;p>于数据库层面，最常见的恐怕就是索引失效了，且一开始因为数据量小还不易被发现。但随着业务的拓展数据量的提升，性能问题慢慢的就体现出来了，处理不及时还很容易造成雪球效应，最终导致数据库卡死甚至瘫痪。造成索引失效的原因可能有很多种，相关技术博客已经有太多了，今天我要记录的是&lt;strong>隐式转换造成的索引失效&lt;/strong>。&lt;/p>
&lt;h2 id="数据准备">
 数据准备
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%87%86%e5%a4%87">#&lt;/a>
&lt;/h2>
&lt;p>首先使用存储过程生成 1000 万条测试数据，
测试表一共建立了 7 个字段（包括主键），&lt;code>num1&lt;/code>和&lt;code>num2&lt;/code>保存的是和&lt;code>ID&lt;/code>一样的顺序数字，其中&lt;code>num2&lt;/code>是字符串类型。
&lt;code>type1&lt;/code>和&lt;code>type2&lt;/code>保存的都是主键对 5 的取模，目的是模拟实际应用中常用类似 type 类型的数据，但是&lt;code>type2&lt;/code>是没有建立索引的。
&lt;code>str1&lt;/code>和&lt;code>str2&lt;/code>都是保存了一个 20 位长度的随机字符串，&lt;code>str1&lt;/code>不能为&lt;code>NULL&lt;/code>，&lt;code>str2&lt;/code>允许为&lt;code>NULL&lt;/code>，相应的生成测试数据的时候我也会在&lt;code>str2&lt;/code>字段生产少量&lt;code>NULL&lt;/code>值（每 100 条数据产生一个&lt;code>NULL&lt;/code>值）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 创建测试数据表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span> test1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>test1&lt;span style="color:#f92672">`&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span> int(&lt;span style="color:#ae81ff">11&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>num1&lt;span style="color:#f92672">`&lt;/span> int(&lt;span style="color:#ae81ff">11&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>num2&lt;span style="color:#f92672">`&lt;/span> varchar(&lt;span style="color:#ae81ff">11&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>type1&lt;span style="color:#f92672">`&lt;/span> int(&lt;span style="color:#ae81ff">4&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>type2&lt;span style="color:#f92672">`&lt;/span> int(&lt;span style="color:#ae81ff">4&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;0&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>str1&lt;span style="color:#f92672">`&lt;/span> varchar(&lt;span style="color:#ae81ff">100&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>str2&lt;span style="color:#f92672">`&lt;/span> varchar(&lt;span style="color:#ae81ff">100&lt;/span>) &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>num1&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>num1&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>num2&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>num2&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>type1&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>type1&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>str1&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>str1&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>str2&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>str2&lt;span style="color:#f92672">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) ENGINE&lt;span style="color:#f92672">=&lt;/span>InnoDB &lt;span style="color:#66d9ef">DEFAULT&lt;/span> CHARSET&lt;span style="color:#f92672">=&lt;/span>utf8;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 创建存储过程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">PROCEDURE&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span> pre_test1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">DELIMITER&lt;/span> &lt;span style="color:#f92672">//&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">PROCEDURE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>pre_test1&lt;span style="color:#f92672">`&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">BEGIN&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">DECLARE&lt;/span> i INT &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> autocommit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WHILE i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">10000000&lt;/span> &lt;span style="color:#66d9ef">DO&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#f92672">@&lt;/span>str1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">SUBSTRING&lt;/span>(MD5(RAND()),&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">20&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 每100条数据str2产生一个null值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">THEN&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#f92672">@&lt;/span>str2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">ELSE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#f92672">@&lt;/span>str2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">@&lt;/span>str1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">END&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#66d9ef">INTO&lt;/span> test1 (&lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>num1&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>num2&lt;span style="color:#f92672">`&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>type1&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>type2&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>str1&lt;span style="color:#f92672">`&lt;/span>, &lt;span style="color:#f92672">`&lt;/span>str2&lt;span style="color:#f92672">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">VALUES&lt;/span> (CONCAT(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, i), CONCAT(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, i),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CONCAT(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>, i), i&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>, i&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#f92672">@&lt;/span>str1, &lt;span style="color:#f92672">@&lt;/span>str2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 事务优化，每一万条数据提交一次事务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span> i &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#66d9ef">THEN&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">COMMIT&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">END&lt;/span> &lt;span style="color:#66d9ef">IF&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">END&lt;/span> WHILE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">END&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">//&lt;/span> &lt;span style="color:#66d9ef">DELIMITER&lt;/span> ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 执行存储过程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CALL&lt;/span> pre_test1();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>数据量比较大，还涉及使用&lt;code>MD5&lt;/code>生成随机字符串，所以速度有点慢，稍安勿躁，耐心等待即可。&lt;/p></description></item><item><title>MySQL执行计划分析</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-query-execution-plan/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-query-execution-plan/</guid><description>&lt;blockquote>
&lt;p>本文来自公号 MySQL 技术，JavaGuide 对其做了补充完善。原文地址：&lt;a href="https://mp.weixin.qq.com/s/d5OowNLtXBGEAbT31sSH4g">https://mp.weixin.qq.com/s/d5OowNLtXBGEAbT31sSH4g&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>优化 SQL 的第一步应该是读懂 SQL 的执行计划。本篇文章，我们一起来学习下 MySQL &lt;code>EXPLAIN&lt;/code> 执行计划相关知识。&lt;/p>
&lt;h2 id="什么是执行计划">
 什么是执行计划？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>执行计划&lt;/strong> 是指一条 SQL 语句在经过 &lt;strong>MySQL 查询优化器&lt;/strong> 的优化后，具体的执行方式。&lt;/p>
&lt;p>执行计划通常用于 SQL 性能分析、优化等场景。通过 &lt;code>EXPLAIN&lt;/code> 的结果，可以了解到如数据表的查询顺序、数据查询操作的操作类型、哪些索引可以被命中、哪些索引实际会命中、每个数据表有多少行记录被查询等信息。&lt;/p>
&lt;h2 id="如何获取执行计划">
 如何获取执行计划？
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e8%8e%b7%e5%8f%96%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92">#&lt;/a>
&lt;/h2>
&lt;p>MySQL 为我们提供了 &lt;code>EXPLAIN&lt;/code> 命令，来获取执行计划的相关信息。&lt;/p>
&lt;p>需要注意的是，&lt;code>EXPLAIN&lt;/code> 语句并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息。&lt;/p>
&lt;p>&lt;code>EXPLAIN&lt;/code> 执行计划支持 &lt;code>SELECT&lt;/code>、&lt;code>DELETE&lt;/code>、&lt;code>INSERT&lt;/code>、&lt;code>REPLACE&lt;/code> 以及 &lt;code>UPDATE&lt;/code> 语句。我们一般多用于分析 &lt;code>SELECT&lt;/code> 查询语句，使用起来非常简单，语法如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">EXPLAIN&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">查询语句；&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们简单来看下一条查询语句的执行计划：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>mysql&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">explain&lt;/span> &lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> dept_emp &lt;span style="color:#66d9ef">WHERE&lt;/span> emp_no &lt;span style="color:#66d9ef">IN&lt;/span> (&lt;span style="color:#66d9ef">SELECT&lt;/span> emp_no &lt;span style="color:#66d9ef">FROM&lt;/span> dept_emp &lt;span style="color:#66d9ef">GROUP&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> emp_no &lt;span style="color:#66d9ef">HAVING&lt;/span> &lt;span style="color:#66d9ef">COUNT&lt;/span>(emp_no)&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#75715e">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">|&lt;/span> id &lt;span style="color:#f92672">|&lt;/span> select_type &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span> &lt;span style="color:#f92672">|&lt;/span> partitions &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#f92672">|&lt;/span> possible_keys &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">key&lt;/span> &lt;span style="color:#f92672">|&lt;/span> key_len &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">ref&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">rows&lt;/span> &lt;span style="color:#f92672">|&lt;/span> filtered &lt;span style="color:#f92672">|&lt;/span> Extra &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#75715e">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#f92672">|&lt;/span> dept_emp &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">ALL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#ae81ff">331143&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>.&lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">Using&lt;/span> &lt;span style="color:#66d9ef">where&lt;/span> &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">|&lt;/span> SUBQUERY &lt;span style="color:#f92672">|&lt;/span> dept_emp &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">index&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span>,dept_no &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#ae81ff">331143&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>.&lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">Using&lt;/span> &lt;span style="color:#66d9ef">index&lt;/span> &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#75715e">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，执行计划结果中共有 12 列，各列代表的含义总结如下表：&lt;/p></description></item><item><title>MySQL自增主键一定是连续的吗</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-auto-increment-primary-key-continuous/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/mysql-auto-increment-primary-key-continuous/</guid><description>&lt;blockquote>
&lt;p>作者：飞天小牛肉&lt;/p>
&lt;p>原文：&lt;a href="https://mp.weixin.qq.com/s/qci10h9rJx_COZbHV3aygQ">https://mp.weixin.qq.com/s/qci10h9rJx_COZbHV3aygQ&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>众所周知，自增主键可以让聚集索引尽量地保持递增顺序插入，避免了随机查询，从而提高了查询效率。&lt;/p>
&lt;p>但实际上，MySQL 的自增主键并不能保证一定是连续递增的。&lt;/p>
&lt;p>下面举个例子来看下，如下所示创建一张表：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/3e6b80ba50cb425386b80924e3da0d23~tplv-k3u1fbpfcp-zoom-1.png" alt="" />&lt;/p>
&lt;h2 id="自增值保存在哪里">
 自增值保存在哪里？
 &lt;a class="anchor" href="#%e8%87%aa%e5%a2%9e%e5%80%bc%e4%bf%9d%e5%ad%98%e5%9c%a8%e5%93%aa%e9%87%8c">#&lt;/a>
&lt;/h2>
&lt;p>使用 &lt;code>insert into test_pk values(null, 1, 1)&lt;/code> 插入一行数据，再执行 &lt;code>show create table&lt;/code> 命令来看一下表的结构定义：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/c17e46230bd34150966f0d86b2ad5e91~tplv-k3u1fbpfcp-zoom-1.png" alt="" />&lt;/p>
&lt;p>上述表的结构定义存放在后缀名为 &lt;code>.frm&lt;/code> 的本地文件中，在 MySQL 安装目录下的 data 文件夹下可以找到这个 &lt;code>.frm&lt;/code> 文件：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/3ec0514dd7be423d80b9e7f2d52f5902~tplv-k3u1fbpfcp-zoom-1.png" alt="" />&lt;/p>
&lt;p>从上述表结构可以看到，表定义里面出现了一个 &lt;code>AUTO_INCREMENT=2&lt;/code>，表示下一次插入数据时，如果需要自动生成自增值，会生成 id = 2。&lt;/p>
&lt;p>但需要注意的是，自增值并不会保存在这个表结构也就是 &lt;code>.frm&lt;/code> 文件中，不同的引擎对于自增值的保存策略不同：&lt;/p>
&lt;p>1）MyISAM 引擎的自增值保存在数据文件中&lt;/p>
&lt;p>2）InnoDB 引擎的自增值，其实是保存在了内存里，并没有持久化。第一次打开表的时候，都会去找自增值的最大值 &lt;code>max(id)&lt;/code>，然后将 &lt;code>max(id)+1&lt;/code> 作为这个表当前的自增值。&lt;/p>
&lt;p>举个例子：我们现在表里当前数据行里最大的 id 是 1，AUTO_INCREMENT=2，对吧。这时候，我们删除 id=1 的行，AUTO_INCREMENT 还是 2。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/61b8dc9155624044a86d91c368b20059~tplv-k3u1fbpfcp-zoom-1.png" alt="" />&lt;/p>
&lt;p>但如果马上重启 MySQL 实例，重启后这个表的 AUTO_INCREMENT 就会变成 1。﻿ 也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。&lt;/p></description></item><item><title>NAT 协议详解（网络层）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/nat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/nat/</guid><description>&lt;h2 id="应用场景">
 应用场景
 &lt;a class="anchor" href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>NAT 协议（Network Address Translation）&lt;/strong> 的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，Local Area Network，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（Wide Area Network，WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。&lt;/p>
&lt;p>这个场景其实不难理解。随着一个个小型办公室、家庭办公室（Small Office, Home Office, SOHO）的出现，为了管理这些 SOHO，一个个子网被设计出来，从而在整个 Internet 中的主机数量将非常庞大。如果每个主机都有一个“绝对唯一”的 IP 地址，那么 IPv4 地址的表达能力可能很快达到上限（$2^{32}$）。因此，实际上，SOHO 子网中的 IP 地址是“相对的”，这在一定程度上也缓解了 IPv4 地址的分配压力。&lt;/p>
&lt;p>SOHO 子网的“代理人”，也就是和外界的窗口，通常由路由器扮演。路由器的 LAN 一侧管理着一个小子网，而它的 WAN 接口才是真正参与到 Internet 中的接口，也就有一个“绝对唯一的地址”。NAT 协议，正是在 LAN 中的主机在与 LAN 外界通信时，起到了地址转换的关键作用。&lt;/p>
&lt;h2 id="细节">
 细节
 &lt;a class="anchor" href="#%e7%bb%86%e8%8a%82">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/nat-demo.png" alt="NAT 协议" />&lt;/p>
&lt;p>假设当前场景如上图。中间是一个路由器，它的右侧组织了一个 LAN，网络号为&lt;code>10.0.0/24&lt;/code>。LAN 侧接口的 IP 地址为&lt;code>10.0.0.4&lt;/code>，并且该子网内有至少三台主机，分别是&lt;code>10.0.0.1&lt;/code>，&lt;code>10.0.0.2&lt;/code>和&lt;code>10.0.0.3&lt;/code>。路由器的左侧连接的是 WAN，WAN 侧接口的 IP 地址为&lt;code>138.76.29.7&lt;/code>。&lt;/p>
&lt;p>首先，针对以上信息，我们有如下事实需要说明：&lt;/p></description></item><item><title>Netty常见面试题总结(付费)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/netty/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/netty/</guid><description>&lt;p>&lt;strong>Netty&lt;/strong> 相关的面试题为我的&lt;a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了&lt;a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》&lt;/a>中。&lt;/p></description></item><item><title>NoSQL基础知识总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/nosql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/nosql/</guid><description>&lt;h2 id="nosql-是什么">
 NoSQL 是什么？
 &lt;a class="anchor" href="#nosql-%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。&lt;/p>
&lt;p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。&lt;/p>
&lt;p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/database/mongodb/sql-nosql-tushi.png" alt="" />&lt;/p>
&lt;h2 id="sql-和-nosql-有什么区别">
 SQL 和 NoSQL 有什么区别？
 &lt;a class="anchor" href="#sql-%e5%92%8c-nosql-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab">#&lt;/a>
&lt;/h2>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">&lt;/th>
 &lt;th>SQL 数据库&lt;/th>
 &lt;th>NoSQL 数据库&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">数据存储模型&lt;/td>
 &lt;td>结构化存储，具有固定行和列的表格&lt;/td>
 &lt;td>非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">发展历程&lt;/td>
 &lt;td>开发于 1970 年代，重点是减少数据重复&lt;/td>
 &lt;td>开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">例子&lt;/td>
 &lt;td>Oracle、MySQL、Microsoft SQL Server、PostgreSQL&lt;/td>
 &lt;td>文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">ACID 属性&lt;/td>
 &lt;td>提供原子性、一致性、隔离性和持久性 (ACID) 属性&lt;/td>
 &lt;td>通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">性能&lt;/td>
 &lt;td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。&lt;/td>
 &lt;td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">扩展&lt;/td>
 &lt;td>垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表&lt;/td>
 &lt;td>横向（增加服务器的方式横向扩展，通常是基于分片机制）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">用途&lt;/td>
 &lt;td>普通企业级的项目的数据存储&lt;/td>
 &lt;td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">查询语法&lt;/td>
 &lt;td>结构化查询语言 (SQL)&lt;/td>
 &lt;td>数据访问语法可能因数据库而异&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="nosql-数据库有什么优势">
 NoSQL 数据库有什么优势？
 &lt;a class="anchor" href="#nosql-%e6%95%b0%e6%8d%ae%e5%ba%93%e6%9c%89%e4%bb%80%e4%b9%88%e4%bc%98%e5%8a%bf">#&lt;/a>
&lt;/h2>
&lt;p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。&lt;/p></description></item><item><title>OSI 和 TCP/IP 网络分层模型详解（基础）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/osi-and-tcp-ip-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/osi-and-tcp-ip-model/</guid><description>&lt;h2 id="osi-七层模型">
 OSI 七层模型
 &lt;a class="anchor" href="#osi-%e4%b8%83%e5%b1%82%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>OSI 七层模型&lt;/strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型" />&lt;/p>
&lt;p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。&lt;/p>
&lt;p>&lt;strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。&lt;/strong>&lt;/p>
&lt;p>上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/osi%e4%b8%83%e5%b1%82%e6%a8%a1%e5%9e%8b2.png" alt="osi七层模型2" />&lt;/p>
&lt;p>&lt;strong>既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四 层模型呢？&lt;/strong>&lt;/p>
&lt;p>的确，OSI 七层模型当时一直被一些大公司甚至一些国家政府支持。这样的背景下，为什么会失败呢？我觉得主要有下面几方面原因：&lt;/p>
&lt;ol>
&lt;li>OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力&lt;/li>
&lt;li>OSI 的协议实现起来过分复杂，而且运行效率很低&lt;/li>
&lt;li>OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP/IP 的互联网已经抢先在全球相当大的范围成功运行了）&lt;/li>
&lt;li>OSI 的层次划分不太合理，有些功能在多个层次中重复出现。&lt;/li>
&lt;/ol>
&lt;p>OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。&lt;/p>
&lt;p>最后再分享一个关于 OSI 七层模型非常不错的总结图片！&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-model-detail.png" alt="" />&lt;/p>
&lt;h2 id="tcpip-四层模型">
 TCP/IP 四层模型
 &lt;a class="anchor" href="#tcpip-%e5%9b%9b%e5%b1%82%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>TCP/IP 四层模型&lt;/strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：&lt;/p>
&lt;ol>
&lt;li>应用层&lt;/li>
&lt;li>传输层&lt;/li>
&lt;li>网络层&lt;/li>
&lt;li>网络接口层&lt;/li>
&lt;/ol>
&lt;p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：&lt;/p></description></item><item><title>Paxos 算法详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/protocol/paxos-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/protocol/paxos-algorithm/</guid><description>&lt;h2 id="背景">
 背景
 &lt;a class="anchor" href="#%e8%83%8c%e6%99%af">#&lt;/a>
&lt;/h2>
&lt;p>Paxos 算法是 Leslie Lamport（&lt;a href="https://zh.wikipedia.org/wiki/%e8%8e%b1%e6%96%af%e5%88%a9%c2%b7%e5%85%b0%e4%bc%af%e7%89%b9">莱斯利·兰伯特&lt;/a>）在 &lt;strong>1990&lt;/strong> 年提出了一种分布式系统 &lt;strong>共识&lt;/strong> 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。&lt;/p>
&lt;p>为了介绍 Paxos 算法，兰伯特专门写了一篇幽默风趣的论文。在这篇论文中，他虚拟了一个叫做 Paxos 的希腊城邦来更形象化地介绍 Paxos 算法。&lt;/p>
&lt;p>不过，审稿人并不认可这篇论文的幽默。于是，他们就给兰伯特说：“如果你想要成功发表这篇论文的话，必须删除所有 Paxos 相关的故事背景”。兰伯特一听就不开心了：“我凭什么修改啊，你们这些审稿人就是缺乏幽默细胞，发不了就不发了呗！”。&lt;/p>
&lt;p>于是乎，提出 Paxos 算法的那篇论文在当时并没有被成功发表。&lt;/p>
&lt;p>直到 1998 年，系统研究中心 (Systems Research Center，SRC）的两个技术研究员需要找一些合适的分布式算法来服务他们正在构建的分布式系统，Paxos 算法刚好可以解决他们的部分需求。因此，兰伯特就把论文发给了他们。在看了论文之后，这俩大佬觉得论文还是挺不错的。于是，兰伯特在 &lt;strong>1998&lt;/strong> 年重新发表论文 &lt;a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf">《The Part-Time Parliament》&lt;/a>。&lt;/p>
&lt;p>论文发表之后，各路学者直呼看不懂，言语中还略显调侃之意。这谁忍得了，在 &lt;strong>2001&lt;/strong> 年的时候，兰伯特专门又写了一篇 &lt;a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf">《Paxos Made Simple》&lt;/a> 的论文来简化对 Paxos 的介绍，主要讲述两阶段共识协议部分，顺便还不忘嘲讽一下这群学者。&lt;/p>
&lt;p>《Paxos Made Simple》这篇论文就 14 页，相比于 《The Part-Time Parliament》的 33 页精简了不少。最关键的是这篇论文的摘要就一句话：&lt;/p>
&lt;p>&lt;img src="./images/paxos/paxos-made-simple.png" alt="" />&lt;/p>
&lt;blockquote>
&lt;p>The Paxos algorithm, when presented in plain English, is very simple.&lt;/p>
&lt;/blockquote>
&lt;p>翻译过来的意思大概就是：当我用无修饰的英文来描述时，Paxos 算法真心简单！&lt;/p>
&lt;p>有没有感觉到来自兰伯特大佬满满地嘲讽的味道？&lt;/p>
&lt;h2 id="介绍">
 介绍
 &lt;a class="anchor" href="#%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>Paxos 算法是第一个被证明完备的分布式系统共识算法。共识算法的作用是让分布式系统中的多个节点之间对某个提案（Proposal）达成一致的看法。提案的含义在分布式系统中十分宽泛，像哪一个节点是 Leader 节点、多个事件发生的顺序等等都可以是一个提案。&lt;/p></description></item><item><title>PriorityQueue 源码分析（付费）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/priorityqueue-source-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/collection/priorityqueue-source-code/</guid><description>&lt;p>&lt;strong>PriorityQueue 源码分析&lt;/strong> 为我的&lt;a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了&lt;a href="https://javaguide.cn/zhuanlan/source-code-reading.html">《Java 必读源码系列》&lt;/a>中。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/xingqiu/image-20230727084055593.png" alt="PriorityQueue 源码分析" />&lt;/p></description></item><item><title>RabbitMQ常见问题总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/message-queue/rabbitmq-questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/message-queue/rabbitmq-questions/</guid><description>&lt;blockquote>
&lt;p>本篇文章由 JavaGuide 收集自网络，原出处不明。&lt;/p>
&lt;/blockquote>
&lt;h2 id="rabbitmq-是什么">
 RabbitMQ 是什么？
 &lt;a class="anchor" href="#rabbitmq-%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。&lt;/p>
&lt;p>RabbitMQ 是使用 Erlang 编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个 Broker 构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。&lt;/p>
&lt;p>PS:也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件。&lt;/p>
&lt;h2 id="rabbitmq-特点">
 RabbitMQ 特点?
 &lt;a class="anchor" href="#rabbitmq-%e7%89%b9%e7%82%b9">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>可靠性&lt;/strong>: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。&lt;/li>
&lt;li>&lt;strong>灵活的路由&lt;/strong> : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。&lt;/li>
&lt;li>&lt;strong>扩展性&lt;/strong>: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。&lt;/li>
&lt;li>&lt;strong>高可用性&lt;/strong> : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。&lt;/li>
&lt;li>&lt;strong>多种协议&lt;/strong>: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。&lt;/li>
&lt;li>&lt;strong>多语言客户端&lt;/strong> :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。&lt;/li>
&lt;li>&lt;strong>管理界面&lt;/strong> : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。&lt;/li>
&lt;li>&lt;strong>插件机制&lt;/strong> : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。&lt;/li>
&lt;/ul>
&lt;h2 id="rabbitmq-核心概念">
 RabbitMQ 核心概念？
 &lt;a class="anchor" href="#rabbitmq-%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5">#&lt;/a>
&lt;/h2>
&lt;p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ 就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。&lt;/p></description></item><item><title>Raft 算法详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/protocol/raft-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/protocol/raft-algorithm/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="https://github.com/Snailclimb">SnailClimb&lt;/a> 和 &lt;a href="https://github.com/jun0315">Xieqijun&lt;/a> 共同完成。&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-背景">
 1 背景
 &lt;a class="anchor" href="#1-%e8%83%8c%e6%99%af">#&lt;/a>
&lt;/h2>
&lt;p>当今的数据中心和应用程序在高度动态的环境中运行，为了应对高度动态的环境，它们通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩。同时，服务器和网络故障也很常见。&lt;/p>
&lt;p>因此，系统必须在正常操作期间处理服务器的上下线。它们必须对变故做出反应并在几秒钟内自动适应；对客户来说的话，明显的中断通常是不可接受的。&lt;/p>
&lt;p>幸运的是，分布式共识可以帮助应对这些挑战。&lt;/p>
&lt;h3 id="11-拜占庭将军">
 1.1 拜占庭将军
 &lt;a class="anchor" href="#11-%e6%8b%9c%e5%8d%a0%e5%ba%ad%e5%b0%86%e5%86%9b">#&lt;/a>
&lt;/h3>
&lt;p>在介绍共识算法之前，先介绍一个简化版拜占庭将军的例子来帮助理解共识算法。&lt;/p>
&lt;blockquote>
&lt;p>假设多位拜占庭将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成是否要进攻的一致性决定？&lt;/p>
&lt;/blockquote>
&lt;p>解决方案大致可以理解成：先在所有的将军中选出一个大将军，用来做出所有的决定。&lt;/p>
&lt;p>举例如下：假如现在一共有 3 个将军 A，B 和 C，每个将军都有一个随机时间的倒计时器，倒计时一结束，这个将军就把自己当成大将军候选人，然后派信使传递选举投票的信息给将军 B 和 C，如果将军 B 和 C 还没有把自己当作候选人（自己的倒计时还没有结束），并且没有把选举票投给其他人，它们就会把票投给将军 A，信使回到将军 A 时，将军 A 知道自己收到了足够的票数，成为大将军。在有了大将军之后，是否需要进攻就由大将军 A 决定，然后再去派信使通知另外两个将军，自己已经成为了大将军。如果一段时间还没收到将军 B 和 C 的回复（信使可能会被暗杀），那就再重派一个信使，直到收到回复。&lt;/p>
&lt;h3 id="12-共识算法">
 1.2 共识算法
 &lt;a class="anchor" href="#12-%e5%85%b1%e8%af%86%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h3>
&lt;p>共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。&lt;/p>
&lt;p>共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组&lt;code>Server&lt;/code>的状态机计算相同状态的副本，即使有一部分的&lt;code>Server&lt;/code>宕机了它们仍然能够继续运行。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/paxos-rsm-architecture.png" alt="rsm-architecture.png" />&lt;/p>
&lt;p>&lt;code>图-1 复制状态机架构&lt;/code>&lt;/p>
&lt;p>一般通过使用复制日志来实现复制状态机。每个&lt;code>Server&lt;/code>存储着一份包括命令序列的日志文件，状态机会按顺序执行这些命令。因为每个日志包含相同的命令，并且顺序也相同，所以每个状态机处理相同的命令序列。由于状态机是确定性的，所以处理相同的状态，得到相同的输出。&lt;/p>
&lt;p>因此共识算法的工作就是保持复制日志的一致性。服务器上的共识模块从客户端接收命令并将它们添加到日志中。它与其他服务器上的共识模块通信，以确保即使某些服务器发生故障。每个日志最终包含相同顺序的请求。一旦命令被正确地复制，它们就被称为已提交。每个服务器的状态机按照日志顺序处理已提交的命令，并将输出返回给客户端，因此，这些服务器形成了一个单一的、高度可靠的状态机。&lt;/p>
&lt;p>适用于实际系统的共识算法通常具有以下特性：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>安全。确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性，包括网络延迟、分区、包丢失、复制和重新排序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>高可用。只要大多数服务器都是可操作的，并且可以相互通信，也可以与客户端进行通信，那么这些服务器就可以看作完全功能可用的。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障。假设服务器因停止而发生故障；它们稍后可能会从稳定存储上的状态中恢复并重新加入集群。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一致性不依赖时序。错误的时钟和极端的消息延迟，在最坏的情况下也只会造成可用性问题，而不会产生一致性问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在集群中大多数服务器响应，命令就可以完成，不会被少数运行缓慢的服务器来影响整体系统性能。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="2-基础">
 2 基础
 &lt;a class="anchor" href="#2-%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;h3 id="21-节点类型">
 2.1 节点类型
 &lt;a class="anchor" href="#21-%e8%8a%82%e7%82%b9%e7%b1%bb%e5%9e%8b">#&lt;/a>
&lt;/h3>
&lt;p>一个 Raft 集群包括若干服务器，以典型的 5 服务器集群举例。在任意的时间，每个服务器一定会处于以下三个状态中的一个：&lt;/p></description></item><item><title>Redis 3 种特殊数据类型详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-data-structures-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-data-structures-02/</guid><description>&lt;p>除了 5 种基本的数据类型之外，Redis 还支持 3 种特殊的数据类型：Bitmap、HyperLogLog、GEO。&lt;/p>
&lt;h2 id="bitmap-位图">
 Bitmap （位图）
 &lt;a class="anchor" href="#bitmap-%e4%bd%8d%e5%9b%be">#&lt;/a>
&lt;/h2>
&lt;h3 id="介绍">
 介绍
 &lt;a class="anchor" href="#%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h3>
&lt;p>根据官网介绍：&lt;/p>
&lt;blockquote>
&lt;p>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type which is treated like a bit vector. Since strings are binary safe blobs and their maximum length is 512 MB, they are suitable to set up to 2^32 different bits.&lt;/p>
&lt;p>Bitmap 不是 Redis 中的实际数据类型，而是在 String 类型上定义的一组面向位的操作，将其视为位向量。由于字符串是二进制安全的块，且最大长度为 512 MB，它们适合用于设置最多 2^32 个不同的位。&lt;/p></description></item><item><title>Redis 5 种基本数据类型详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-data-structures-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-data-structures-01/</guid><description>&lt;p>Redis 共有 5 种基本数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。&lt;/p>
&lt;p>这 5 种数据类型是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Dict（哈希表/字典）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。&lt;/p>
&lt;p>Redis 5 种基本数据类型对应的底层数据结构实现如下表所示：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">String&lt;/th>
 &lt;th style="text-align: left">List&lt;/th>
 &lt;th style="text-align: left">Hash&lt;/th>
 &lt;th style="text-align: left">Set&lt;/th>
 &lt;th style="text-align: left">Zset&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">SDS&lt;/td>
 &lt;td style="text-align: left">LinkedList/ZipList/QuickList&lt;/td>
 &lt;td style="text-align: left">Dict、ZipList&lt;/td>
 &lt;td style="text-align: left">Dict、Intset&lt;/td>
 &lt;td style="text-align: left">ZipList、SkipList&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。从 Redis 7.0 开始， ZipList 被 ListPack 取代。&lt;/p>
&lt;p>你可以在 Redis 官网上找到 Redis 数据类型/结构非常详细的介绍：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://redis.com/redis-enterprise/data-structures/">Redis Data Structures&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://redis.io/docs/manual/data-types/data-types-tutorial/">Redis Data types tutorial&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>未来随着 Redis 新版本的发布，可能会有新的数据结构出现，通过查阅 Redis 官网对应的介绍，你总能获取到最靠谱的信息。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/database/redis/image-20220720181630203.png" alt="" />&lt;/p>
&lt;h2 id="string字符串">
 String（字符串）
 &lt;a class="anchor" href="#string%e5%ad%97%e7%ac%a6%e4%b8%b2">#&lt;/a>
&lt;/h2>
&lt;h3 id="介绍">
 介绍
 &lt;a class="anchor" href="#%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h3>
&lt;p>String 是 Redis 中最简单同时也是最常用的一个数据类型。&lt;/p></description></item><item><title>Redis常见面试题总结(上)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-questions-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-questions-01/</guid><description>&lt;h2 id="redis-基础">
 Redis 基础
 &lt;a class="anchor" href="#redis-%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是-redis">
 什么是 Redis？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-redis">#&lt;/a>
&lt;/h3>
&lt;p>&lt;a href="https://redis.io/">Redis&lt;/a> （&lt;strong>RE&lt;/strong>mote &lt;strong>DI&lt;/strong>ctionary &lt;strong>S&lt;/strong>erver）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。&lt;/p>
&lt;p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、发布订阅模型、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-overview-of-data-types-2023-09-28.jpg" alt="Redis 数据类型概览" />&lt;/p>
&lt;p>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。&lt;/p>
&lt;p>个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的&lt;a href="https://try.redis.io/">在线 Redis 环境&lt;/a>（少部分命令无法使用）来实际体验 Redis。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/database/redis/try.redis.io.png" alt="try-redis" />&lt;/p>
&lt;p>全世界有非常多的网站使用到了 Redis ，&lt;a href="https://techstacks.io/">techstacks.io&lt;/a> 专门维护了一个&lt;a href="https://techstacks.io/tech/redis">使用 Redis 的热门站点列表&lt;/a> ，感兴趣的话可以看看。&lt;/p>
&lt;h3 id="redis-为什么这么快">
 Redis 为什么这么快？
 &lt;a class="anchor" href="#redis-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%99%e4%b9%88%e5%bf%ab">#&lt;/a>
&lt;/h3>
&lt;p>Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：&lt;/p>
&lt;ol>
&lt;li>Redis 基于内存，内存的访问速度比磁盘快很多；&lt;/li>
&lt;li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；&lt;/li>
&lt;li>Redis 内置了多种优化过后的数据类型/结构实现，性能非常高。&lt;/li>
&lt;li>Redis 通信协议实现简单且解析高效。&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>下面这张图片总结的挺不错的，分享一下，出自 &lt;a href="https://twitter.com/alexxubyte/status/1498703822528544770">Why is Redis so fast?&lt;/a> 。&lt;/p></description></item><item><title>Redis常见面试题总结(下)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-questions-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-questions-02/</guid><description>&lt;h2 id="redis-事务">
 Redis 事务
 &lt;a class="anchor" href="#redis-%e4%ba%8b%e5%8a%a1">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是-redis-事务">
 什么是 Redis 事务？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-redis-%e4%ba%8b%e5%8a%a1">#&lt;/a>
&lt;/h3>
&lt;p>你可以将 Redis 中的事务理解为：&lt;strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。&lt;/strong>&lt;/p>
&lt;p>Redis 事务实际开发中使用的非常少，功能比较鸡肋，不要将其和我们平时理解的关系型数据库的事务混淆了。&lt;/p>
&lt;p>除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。&lt;/p>
&lt;p>因此，Redis 事务是不建议在日常开发中使用的。&lt;/p>
&lt;h3 id="如何使用-redis-事务">
 如何使用 Redis 事务？
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-redis-%e4%ba%8b%e5%8a%a1">#&lt;/a>
&lt;/h3>
&lt;p>Redis 可以通过 &lt;strong>&lt;code>MULTI&lt;/code>，&lt;code>EXEC&lt;/code>，&lt;code>DISCARD&lt;/code> 和 &lt;code>WATCH&lt;/code>&lt;/strong> 等命令来实现事务(Transaction)功能。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&amp;gt; MULTI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; SET PROJECT &lt;span style="color:#e6db74">&amp;#34;JavaGuide&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>QUEUED
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; GET PROJECT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>QUEUED
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; EXEC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1&lt;span style="color:#f92672">)&lt;/span> OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#e6db74">&amp;#34;JavaGuide&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://redis.io/commands/multi">&lt;code>MULTI&lt;/code>&lt;/a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 &lt;a href="https://redis.io/commands/exec">&lt;code>EXEC&lt;/code>&lt;/a> 命令后，再执行所有的命令。&lt;/p>
&lt;p>这个过程是这样的：&lt;/p>
&lt;ol>
&lt;li>开始事务（&lt;code>MULTI&lt;/code>）；&lt;/li>
&lt;li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；&lt;/li>
&lt;li>执行事务(&lt;code>EXEC&lt;/code>)。&lt;/li>
&lt;/ol>
&lt;p>你也可以通过 &lt;a href="https://redis.io/commands/discard">&lt;code>DISCARD&lt;/code>&lt;/a> 命令取消一个事务，它会清空事务队列中保存的所有命令。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&amp;gt; MULTI
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; SET PROJECT &lt;span style="color:#e6db74">&amp;#34;JavaGuide&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>QUEUED
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; GET PROJECT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>QUEUED
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; DISCARD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OK
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以通过&lt;a href="https://redis.io/commands/watch">&lt;code>WATCH&lt;/code>&lt;/a> 命令监听指定的 Key，当调用 &lt;code>EXEC&lt;/code> 命令执行事务时，如果一个被 &lt;code>WATCH&lt;/code> 命令监视的 Key 被 &lt;strong>其他客户端/Session&lt;/strong> 修改的话，整个事务都不会被执行。&lt;/p></description></item><item><title>Redis常见阻塞原因总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-common-blocking-problems-summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-common-blocking-problems-summary/</guid><description>&lt;blockquote>
&lt;p>本文整理完善自：&lt;a href="https://mp.weixin.qq.com/s/0Nqfq_eQrUb12QH6eBbHXA">https://mp.weixin.qq.com/s/0Nqfq_eQrUb12QH6eBbHXA&lt;/a> ，作者：阿 Q 说代码&lt;/p>
&lt;/blockquote>
&lt;p>这篇文章会详细总结一下可能导致 Redis 阻塞的情况，这些情况也是影响 Redis 性能的关键因素，使用 Redis 的时候应该格外注意！&lt;/p>
&lt;h2 id="on-命令">
 O(n) 命令
 &lt;a class="anchor" href="#on-%e5%91%bd%e4%bb%a4">#&lt;/a>
&lt;/h2>
&lt;p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：&lt;/p>
&lt;ul>
&lt;li>&lt;code>KEYS *&lt;/code>：会返回所有符合规则的 key。&lt;/li>
&lt;li>&lt;code>HGETALL&lt;/code>：会返回一个 Hash 中所有的键值对。&lt;/li>
&lt;li>&lt;code>LRANGE&lt;/code>：会返回 List 中指定范围内的元素。&lt;/li>
&lt;li>&lt;code>SMEMBERS&lt;/code>：返回 Set 中的所有元素。&lt;/li>
&lt;li>&lt;code>SINTER&lt;/code>/&lt;code>SUNION&lt;/code>/&lt;code>SDIFF&lt;/code>：计算多个 Set 的交集/并集/差集。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长，从而导致客户端阻塞。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 &lt;code>HSCAN&lt;/code>、&lt;code>SSCAN&lt;/code>、&lt;code>ZSCAN&lt;/code> 代替。&lt;/p>
&lt;p>除了这些 O(n)时间复杂度的命令可能会导致阻塞之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ZRANGE&lt;/code>/&lt;code>ZREVRANGE&lt;/code>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。&lt;/li>
&lt;li>&lt;code>ZREMRANGEBYRANK&lt;/code>/&lt;code>ZREMRANGEBYSCORE&lt;/code>：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;h2 id="save-创建-rdb-快照">
 SAVE 创建 RDB 快照
 &lt;a class="anchor" href="#save-%e5%88%9b%e5%bb%ba-rdb-%e5%bf%ab%e7%85%a7">#&lt;/a>
&lt;/h2>
&lt;p>Redis 提供了两个命令来生成 RDB 快照文件：&lt;/p></description></item><item><title>Redis持久化机制详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-persistence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-persistence/</guid><description>&lt;p>使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。&lt;/p>
&lt;p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:&lt;/p>
&lt;ul>
&lt;li>快照（snapshotting，RDB）&lt;/li>
&lt;li>只追加文件（append-only file, AOF）&lt;/li>
&lt;li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)&lt;/li>
&lt;/ul>
&lt;p>官方文档地址：&lt;a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence&lt;/a> 。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis4.0-persitence.png" alt="" />&lt;/p>
&lt;h2 id="rdb-持久化">
 RDB 持久化
 &lt;a class="anchor" href="#rdb-%e6%8c%81%e4%b9%85%e5%8c%96">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是-rdb-持久化">
 什么是 RDB 持久化？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-rdb-%e6%8c%81%e4%b9%85%e5%8c%96">#&lt;/a>
&lt;/h3>
&lt;p>Redis 可以通过创建快照来获得存储在内存里面的数据在 &lt;strong>某个时间点&lt;/strong> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。&lt;/p>
&lt;p>快照持久化是 Redis 默认采用的持久化方式，在 &lt;code>redis.conf&lt;/code> 配置文件中默认有此下配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-clojure" data-lang="clojure">&lt;span style="display:flex;">&lt;span>save &lt;span style="color:#ae81ff">900&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">#&lt;/span>在900秒(&lt;span style="color:#ae81ff">15&lt;/span>分钟)之后&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>如果至少有1个key发生变化&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>Redis就会自动触发bgsave命令创建快照&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>save &lt;span style="color:#ae81ff">300&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#f92672">#&lt;/span>在300秒(&lt;span style="color:#ae81ff">5&lt;/span>分钟)之后&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>如果至少有10个key发生变化&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>Redis就会自动触发bgsave命令创建快照&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>save &lt;span style="color:#ae81ff">60&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#f92672">#&lt;/span>在60秒(&lt;span style="color:#ae81ff">1&lt;/span>分钟)之后&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>如果至少有10000个key发生变化&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>Redis就会自动触发bgsave命令创建快照&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="rdb-创建快照时会阻塞主线程吗">
 RDB 创建快照时会阻塞主线程吗？
 &lt;a class="anchor" href="#rdb-%e5%88%9b%e5%bb%ba%e5%bf%ab%e7%85%a7%e6%97%b6%e4%bc%9a%e9%98%bb%e5%a1%9e%e4%b8%bb%e7%ba%bf%e7%a8%8b%e5%90%97">#&lt;/a>
&lt;/h3>
&lt;p>Redis 提供了两个命令来生成 RDB 快照文件：&lt;/p>
&lt;ul>
&lt;li>&lt;code>save&lt;/code> : 同步保存操作，会阻塞 Redis 主线程；&lt;/li>
&lt;li>&lt;code>bgsave&lt;/code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这里说 Redis 主线程而不是主进程的主要是因为 Redis 启动之后主要是通过单线程的方式完成主要的工作。如果你想将其描述为 Redis 主进程，也没毛病。&lt;/p></description></item><item><title>Redis集群详解(付费)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-cluster/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-cluster/</guid><description>&lt;p>&lt;strong>Redis 集群&lt;/strong> 相关的面试题为我的 &lt;a href="../../about-the-author/zhishixingqiu-two-years.md">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了&lt;a href="../../zhuanlan/java-mian-shi-zhi-bei.md">《Java 面试指北》&lt;/a>中。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-cluster-javamianshizhibei.png" alt="" />&lt;/p></description></item><item><title>Redis内存碎片详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-memory-fragmentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-memory-fragmentation/</guid><description>&lt;h2 id="什么是内存碎片">
 什么是内存碎片?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87">#&lt;/a>
&lt;/h2>
&lt;p>你可以将内存碎片简单地理解为那些不可用的空闲内存。&lt;/p>
&lt;p>举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/memory-fragmentation.png" alt="内存碎片" />&lt;/p>
&lt;p>Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。&lt;/p>
&lt;h2 id="为什么会有-redis-内存碎片">
 为什么会有 Redis 内存碎片?
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e6%9c%89-redis-%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87">#&lt;/a>
&lt;/h2>
&lt;p>Redis 内存碎片产生比较常见的 2 个原因：&lt;/p>
&lt;p>&lt;strong>1、Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。&lt;/strong>&lt;/p>
&lt;p>以下是这段 Redis 官方的原话：&lt;/p>
&lt;blockquote>
&lt;p>To store user keys, Redis allocates at most as much memory as the &lt;code>maxmemory&lt;/code> setting enables (however there are small extra allocations possible).&lt;/p>
&lt;/blockquote>
&lt;p>Redis 使用 &lt;code>zmalloc&lt;/code> 方法(Redis 自己实现的内存分配方法)进行内存分配的时候，除了要分配 &lt;code>size&lt;/code> 大小的内存之外，还会多分配 &lt;code>PREFIX_SIZE&lt;/code> 大小的内存。&lt;/p>
&lt;p>&lt;code>zmalloc&lt;/code> 方法源码如下（源码地址：&lt;a href="https://github.com/antirez/redis-tools/blob/master/zmalloc.c%ef%bc%89%ef%bc%9a">https://github.com/antirez/redis-tools/blob/master/zmalloc.c）：&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>zmalloc(size_t size) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 分配指定大小的内存&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr &lt;span style="color:#f92672">=&lt;/span> malloc(size&lt;span style="color:#f92672">+&lt;/span>PREFIX_SIZE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>ptr) zmalloc_oom_handler(size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>ifdef HAVE_MALLOC_SIZE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">update_zmalloc_stat_alloc&lt;/span>(zmalloc_size(ptr));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>((size_t&lt;span style="color:#f92672">*&lt;/span>)ptr) &lt;span style="color:#f92672">=&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> update_zmalloc_stat_alloc(size&lt;span style="color:#f92672">+&lt;/span>PREFIX_SIZE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)ptr&lt;span style="color:#f92672">+&lt;/span>PREFIX_SIZE;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>endif
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外，Redis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认使用 &lt;a href="https://github.com/jemalloc/jemalloc">jemalloc&lt;/a>，而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节……）来分配内存的。jemalloc 划分的内存单元如下图所示：&lt;/p></description></item><item><title>Redis为什么用跳表实现有序集合</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-skiplist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-skiplist/</guid><description>&lt;h2 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>近几年针对 Redis 面试时会涉及常见数据结构的底层设计，其中就有这么一道比较有意思的面试题：“Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+树？”。&lt;/p>
&lt;p>本文就以这道大厂常问的面试题为切入点，带大家详细了解一下跳表这个数据结构。&lt;/p>
&lt;p>本文整体脉络如下图所示，笔者会从有序集合的基本使用到跳表的源码分析和实现，让你会对 Redis 的有序集合底层实现的跳表有着更深刻的理解和掌握。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/javaguide/database/redis/skiplist/202401222005468.png" alt="" />&lt;/p>
&lt;h2 id="跳表在-redis-中的运用">
 跳表在 Redis 中的运用
 &lt;a class="anchor" href="#%e8%b7%b3%e8%a1%a8%e5%9c%a8-redis-%e4%b8%ad%e7%9a%84%e8%bf%90%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;p>这里我们需要先了解一下 Redis 用到跳表的数据结构有序集合的使用，Redis 有个比较常用的数据结构叫&lt;strong>有序集合(sorted set，简称 zset)&lt;/strong>，正如其名它是一个可以保证有序且元素唯一的集合，所以它经常用于排行榜等需要进行统计排列的场景。&lt;/p>
&lt;p>这里我们通过命令行的形式演示一下排行榜的实现，可以看到笔者分别输入 3 名用户：&lt;strong>xiaoming&lt;/strong>、&lt;strong>xiaohong&lt;/strong>、&lt;strong>xiaowang&lt;/strong>，它们的&lt;strong>score&lt;/strong>分别是 60、80、60，最终按照成绩升级降序排列。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; zadd rankList &lt;span style="color:#ae81ff">60&lt;/span> xiaoming
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>integer&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; zadd rankList &lt;span style="color:#ae81ff">80&lt;/span> xiaohong
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>integer&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; zadd rankList &lt;span style="color:#ae81ff">60&lt;/span> xiaowang
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>integer&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 返回有序集中指定区间内的成员，通过索引，分数从高到低&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; ZREVRANGE rankList &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span> WITHSCORES
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#e6db74">&amp;#34;xiaohong&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#e6db74">&amp;#34;80&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#e6db74">&amp;#34;xiaowang&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#e6db74">&amp;#34;60&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#e6db74">&amp;#34;xiaoming&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>6&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#e6db74">&amp;#34;60&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>此时我们通过 &lt;code>object&lt;/code> 指令查看 zset 的数据结构，可以看到当前有序集合存储的还是&lt;strong>ziplist(压缩列表)&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>127.0.0.1:6379&amp;gt; object encoding rankList
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;ziplist&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为设计者考虑到 Redis 数据存放于内存，为了节约宝贵的内存空间，在有序集合元素小于 64 字节且个数小于 128 的时候，会使用 ziplist，而这个阈值的默认值的设置就来自下面这两个配置项。&lt;/p></description></item><item><title>RestFul API 简明教程</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/basis/RESTfulAPI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/basis/RESTfulAPI/</guid><description>&lt;p>&lt;img src="https://oss.javaguide.cn/system-design/basis/2021050713553862.png" alt="" />&lt;/p>
&lt;p>这篇文章简单聊聊后端程序员必备的 RESTful API 相关的知识。&lt;/p>
&lt;p>开始正式介绍 RESTful API 之前，我们需要首先搞清：&lt;strong>API 到底是什么？&lt;/strong>&lt;/p>
&lt;h2 id="何为-api">
 何为 API？
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba-api">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="https://oss.javaguide.cn/system-design/basis/20210507153833945.png" alt="" />&lt;/p>
&lt;p>&lt;strong>API（Application Programming Interface）&lt;/strong> 翻译过来是应用程序编程接口的意思。&lt;/p>
&lt;p>我们在进行后端开发的时候，主要的工作就是为前端或者其他后端服务提供 API 比如查询用户数据的 API 。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/system-design/basis/20210507130629538.png" alt="" />&lt;/p>
&lt;p>但是， API 不仅仅代表后端系统暴露的接口，像框架中提供的方法也属于 API 的范畴。&lt;/p>
&lt;p>为了方便大家理解，我再列举几个例子 🌰：&lt;/p>
&lt;ol>
&lt;li>你通过某电商网站搜索某某商品，电商网站的前端就调用了后端提供了搜索商品相关的 API。&lt;/li>
&lt;li>你使用 JDK 开发 Java 程序，想要读取用户的输入的话，你就需要使用 JDK 提供的 IO 相关的 API。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ol>
&lt;p>你可以把 API 理解为程序与程序之间通信的桥梁，其本质就是一个函数而已。另外，API 的使用也不是没有章法的，它的规则由（比如数据输入和输出的格式）API 提供方制定。&lt;/p>
&lt;h2 id="何为-restful-api">
 何为 RESTful API？
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba-restful-api">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>RESTful API&lt;/strong> 经常也被叫做 &lt;strong>REST API&lt;/strong>，它是基于 REST 构建的 API。这个 REST 到底是什么，我们后文在讲，涉及到的概念比较多。&lt;/p>
&lt;p>如果你看 RESTful API 相关的文章的话一般都比较晦涩难懂，主要是因为 REST 涉及到的一些概念比较难以理解。但是，实际上，我们平时开发用到的 RESTful API 的知识非常简单也很容易概括！&lt;/p></description></item><item><title>RocketMQ常见问题总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/message-queue/rocketmq-questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/message-queue/rocketmq-questions/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;amp;mid=2247485969&amp;amp;idx=1&amp;amp;sn=6bd53abde30d42a778d5a35ec104428c&amp;amp;chksm=cea245daf9d5cccce631f93115f0c2c4a7634e55f5bef9009fd03f5a0ffa55b745b5ef4f0530&amp;amp;token=294077121&amp;amp;lang=zh_CN#rd">本文由 FrancisQ 投稿！&lt;/a> 相比原文主要进行了下面这些完善：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/Snailclimb/JavaGuide/pull/2133">分析了 RocketMQ 高性能读写的原因和顺序消费的具体实现&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/Snailclimb/JavaGuide/pull/2134">增加了消息类型、消费者类型、消费者组和生产者组的介绍&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="消息队列扫盲">
 消息队列扫盲
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e6%89%ab%e7%9b%b2">#&lt;/a>
&lt;/h2>
&lt;p>消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道是啥吧？&lt;/p>
&lt;p>所以问题并不是消息队列是什么，而是 &lt;strong>消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？&lt;/strong>&lt;/p>
&lt;h3 id="消息队列为什么会出现">
 消息队列为什么会出现？
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e5%87%ba%e7%8e%b0">#&lt;/a>
&lt;/h3>
&lt;p>消息队``列算是作为后端程序员的一个必备技能吧，因为&lt;strong>分布式应用必定涉及到各个系统之间的通信问题&lt;/strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。&lt;/p>
&lt;h3 id="消息队列能用来干什么">
 消息队列能用来干什么？
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e8%83%bd%e7%94%a8%e6%9d%a5%e5%b9%b2%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;h4 id="异步">
 异步
 &lt;a class="anchor" href="#%e5%bc%82%e6%ad%a5">#&lt;/a>
&lt;/h4>
&lt;p>你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？&lt;/p>
&lt;p>很好 👍，你又提出了一个概念，&lt;strong>同步通信&lt;/strong>。就比如现在业界使用比较多的 &lt;code>Dubbo&lt;/code> 就是一个适用于各个系统之间同步通信的 &lt;code>RPC&lt;/code> 框架。&lt;/p>
&lt;p>我来举个 🌰 吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef37fee7e09230.jpg" alt="" />&lt;/p>
&lt;p>我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。&lt;/p>
&lt;p>当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短信系统这玩意又不是很有必要，它仅仅是一个辅助功能增强用户体验感而已。我现在整个调用流程就有点 &lt;strong>头重脚轻&lt;/strong> 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/16ef380429cf373e.jpg" alt="" />&lt;/p>
&lt;p>这样整个系统的调用链又变长了，整个时间就变成了 550ms。&lt;/p>
&lt;p>当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。&lt;/p>
&lt;p>我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦 😋😋😋” 咦~~~ 为了多吃点，真恶心。&lt;/p>
&lt;p>然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。&lt;/p>
&lt;p>最终我们从大妈手中接过饭菜然后去寻找座位了&amp;hellip;&lt;/p>
&lt;p>回想一下，我们在给大妈发送需要的信息之后我们是 &lt;strong>同步等待大妈给我配好饭菜&lt;/strong> 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。&lt;/p>
&lt;p>那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 &lt;strong>(传达一个消息)&lt;/strong> ，然后我们就可以在饭桌上安心的玩手机了 &lt;strong>(干自己其他事情)&lt;/strong> ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以干其他事情了，这是一个 &lt;strong>异步&lt;/strong> 的概念。&lt;/p></description></item><item><title>RPC基础知识总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/rpc/rpc-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/rpc/rpc-intro/</guid><description>&lt;p>这篇文章会简单介绍一下 RPC 相关的基础概念。&lt;/p>
&lt;h2 id="rpc-是什么">
 RPC 是什么?
 &lt;a class="anchor" href="#rpc-%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>RPC（Remote Procedure Call）&lt;/strong> 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。&lt;/p>
&lt;p>&lt;strong>为什么要 RPC ？&lt;/strong> 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。&lt;/p>
&lt;p>&lt;strong>RPC 能帮助我们做什么呢？&lt;/strong> 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。&lt;/p>
&lt;p>举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。&lt;/p>
&lt;p>一言蔽之：&lt;strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。&lt;/strong>&lt;/p>
&lt;h2 id="rpc-的原理是什么">
 RPC 的原理是什么?
 &lt;a class="anchor" href="#rpc-%e7%9a%84%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC 的 核心功能看作是下面 👇 5 个部分实现的：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>客户端（服务消费端）&lt;/strong>：调用远程方法的一端。&lt;/li>
&lt;li>&lt;strong>客户端 Stub（桩）&lt;/strong>：这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。&lt;/li>
&lt;li>&lt;strong>网络传输&lt;/strong>：网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）。&lt;/li>
&lt;li>&lt;strong>服务端 Stub（桩）&lt;/strong>：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去执行对应的方法然后返回结果给客户端的类。&lt;/li>
&lt;li>&lt;strong>服务端（服务提供端）&lt;/strong>：提供远程方法的一端。&lt;/li>
&lt;/ol>
&lt;p>具体原理图如下，后面我会串起来将整个 RPC 的过程给大家说一下。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/37345851.jpg" alt="RPC原理图" />&lt;/p>
&lt;ol>
&lt;li>服务消费端（client）以本地调用的方式调用远程服务；&lt;/li>
&lt;li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：&lt;code>RpcRequest&lt;/code>；&lt;/li>
&lt;li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；&lt;/li>
&lt;li>服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: &lt;code>RpcRequest&lt;/code>；&lt;/li>
&lt;li>服务端 Stub（桩）根据&lt;code>RpcRequest&lt;/code>中的类、方法、方法参数等信息调用本地的方法；&lt;/li>
&lt;li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：&lt;code>RpcResponse&lt;/code>（序列化）发送至消费方；&lt;/li>
&lt;li>客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:&lt;code>RpcResponse&lt;/code> ，这样也就得到了最终结果。over!&lt;/li>
&lt;/ol>
&lt;p>相信小伙伴们看完上面的讲解之后，已经了解了 RPC 的原理。&lt;/p></description></item><item><title>Shell 编程基础知识总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/shell-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/shell-intro/</guid><description>&lt;p>Shell 编程在我们的日常开发工作中非常实用，目前 Linux 系统下最流行的运维自动化语言就是 Shell 和 Python 了。&lt;/p>
&lt;p>这篇文章我会简单总结一下 Shell 编程基础知识，带你入门 Shell 编程！&lt;/p>
&lt;h2 id="走进-shell-编程的大门">
 走进 Shell 编程的大门
 &lt;a class="anchor" href="#%e8%b5%b0%e8%bf%9b-shell-%e7%bc%96%e7%a8%8b%e7%9a%84%e5%a4%a7%e9%97%a8">#&lt;/a>
&lt;/h2>
&lt;h3 id="为什么要学-shell">
 为什么要学 Shell？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ad%a6-shell">#&lt;/a>
&lt;/h3>
&lt;p>学一个东西，我们大部分情况都是往实用性方向着想。从工作角度来讲，学习 Shell 是为了提高我们自己工作效率，提高产出，让我们在更少的时间完成更多的事情。&lt;/p>
&lt;p>很多人会说 Shell 编程属于运维方面的知识了，应该是运维人员来做，我们做后端开发的没必要学。我觉得这种说法大错特错，相比于专门做 Linux 运维的人员来说，我们对 Shell 编程掌握程度的要求要比他们低，但是 Shell 编程也是我们必须要掌握的！&lt;/p>
&lt;p>目前 Linux 系统下最流行的运维自动化语言就是 Shell 和 Python 了。&lt;/p>
&lt;p>两者之间，Shell 几乎是 IT 企业必须使用的运维自动化编程语言，特别是在运维工作中的服务监控、业务快速部署、服务启动停止、数据备份及处理、日志分析等环节里，shell 是不可缺的。Python 更适合处理复杂的业务逻辑，以及开发复杂的运维软件工具，实现通过 web 访问等。Shell 是一个命令解释器，解释执行用户所输入的命令和程序。一输入命令，就立即回应的交互的对话方式。&lt;/p>
&lt;p>另外，了解 shell 编程也是大部分互联网公司招聘后端开发人员的要求。下图是我截取的一些知名互联网公司对于 Shell 编程的要求。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/shell/60190220.jpg" alt="大型互联网公司对于shell编程技能的要求" />&lt;/p>
&lt;h3 id="什么是-shell">
 什么是 Shell？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-shell">#&lt;/a>
&lt;/h3>
&lt;p>简单来说“Shell 编程就是对一堆 Linux 命令的逻辑化处理”。&lt;/p>
&lt;p>W3Cschool 上的一篇文章是这样介绍 Shell 的，如下图所示。
&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/shell/19456505.jpg" alt="什么是 Shell？" />&lt;/p></description></item><item><title>Spring Boot核心源码解读（付费）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/springboot-source-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/springboot-source-code/</guid><description>&lt;p>&lt;strong>Spring Boot 核心源码解读&lt;/strong> 为我的&lt;a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了&lt;a href="https://javaguide.cn/zhuanlan/source-code-reading.html">《Java 必读源码系列》&lt;/a>中。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/xingqiu/springboot-source-code.png" alt="Spring Boot核心源码解读" />&lt;/p></description></item><item><title>Spring Cloud Gateway常见问题总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/spring-cloud-gateway-questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/spring-cloud-gateway-questions/</guid><description>&lt;blockquote>
&lt;p>本文重构完善自&lt;a href="https://mp.weixin.qq.com/s/XjFYsP1IUqNzWqXZdJn-Aw">6000 字 | 16 图 | 深入理解 Spring Cloud Gateway 的原理 - 悟空聊架构&lt;/a>这篇文章。&lt;/p>
&lt;/blockquote>
&lt;h2 id="什么是-spring-cloud-gateway">
 什么是 Spring Cloud Gateway？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-spring-cloud-gateway">#&lt;/a>
&lt;/h2>
&lt;p>Spring Cloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 &lt;strong>Zuul&lt;/strong>。准确点来说，应该是 Zuul 1.x。Spring Cloud Gateway 起步要比 Zuul 2.x 更早。&lt;/p>
&lt;p>为了提升网关的性能，Spring Cloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现同步非阻塞的 I/O。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/api-gateway/springcloud-gateway-%20demo.png" alt="" />&lt;/p>
&lt;p>Spring Cloud Gateway 不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，限流。&lt;/p>
&lt;p>Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。&lt;/p></description></item><item><title>Spring 事务详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/spring-transaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/spring-transaction/</guid><description>&lt;p>前段时间答应读者的 &lt;strong>Spring 事务&lt;/strong> 分析总结终于来了。这部分内容比较重要，不论是对于工作还是面试，但是网上比较好的参考资料比较少。&lt;/p>
&lt;h2 id="什么是事务">
 什么是事务？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%8b%e5%8a%a1">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。&lt;/strong>&lt;/p>
&lt;p>相信大家应该都能背上面这句话了，下面我结合我们日常的真实开发来谈一谈。&lt;/p>
&lt;p>我们系统的每个业务方法可能包括了多个原子性的数据库操作，比如下面的 &lt;code>savePerson()&lt;/code> 方法中就有两个原子性的数据库操作。这些原子性的数据库操作是有依赖的，它们要么都执行，要不就都不执行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">savePerson&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> personDao.&lt;span style="color:#a6e22e">save&lt;/span>(person);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> personDetailDao.&lt;span style="color:#a6e22e">save&lt;/span>(personDetail);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外，需要格外注意的是：&lt;strong>事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的 &lt;code>innodb&lt;/code>引擎。但是，如果把数据库引擎变为 &lt;code>myisam&lt;/code>，那么程序也就不再支持事务了！&lt;/strong>&lt;/p>
&lt;p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>将小明的余额减少 1000 元。&lt;/li>
&lt;li>将小红的余额增加 1000 元。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>万一在这两个操作之间突然出现错误比如银行系统崩溃或者网络故障，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/mysql/%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="事务示意图" />&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OrdersService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> AccountDao accountDao;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setOrdersDao&lt;/span>(AccountDao accountDao) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">accountDao&lt;/span> &lt;span style="color:#f92672">=&lt;/span> accountDao;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Transactional&lt;/span>(propagation &lt;span style="color:#f92672">=&lt;/span> Propagation.&lt;span style="color:#a6e22e">REQUIRED&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> isolation &lt;span style="color:#f92672">=&lt;/span> Isolation.&lt;span style="color:#a6e22e">DEFAULT&lt;/span>, readOnly &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>, timeout &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">accountMoney&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//小红账户多1000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> accountDao.&lt;span style="color:#a6e22e">addMoney&lt;/span>(1000,xiaohong);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//模拟突然出现的异常，比如银行中可能为突然停电等等&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//如果没有配置事务管理的话会造成，小红账户多了1000而小明账户没有少钱&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 10 &lt;span style="color:#f92672">/&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//小王账户少1000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> accountDao.&lt;span style="color:#a6e22e">reduceMoney&lt;/span>(1000,xiaoming);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外，数据库事务的 ACID 四大特性是事务的基础，下面简单来了解一下。&lt;/p></description></item><item><title>Spring 中的设计模式详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/spring-design-patterns-summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/spring-design-patterns-summary/</guid><description>&lt;p>“JDK 中用到了哪些设计模式? Spring 中用到了哪些设计模式? ”这两个问题，在面试中比较常见。&lt;/p>
&lt;p>我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下。&lt;/p>
&lt;p>由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的设计模式。&lt;/p>
&lt;h2 id="控制反转ioc和依赖注入di">
 控制反转(IoC)和依赖注入(DI)
 &lt;a class="anchor" href="#%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%acioc%e5%92%8c%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5di">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>IoC(Inversion of Control,控制反转)&lt;/strong> 是 Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。IoC 的主要目的是借助于“第三方”(Spring 中的 IoC 容器) 实现具有依赖关系的对象之间的解耦(IOC 容器管理对象，你只管使用即可)，从而降低代码之间的耦合度。&lt;/p>
&lt;p>&lt;strong>IoC 是一个原则，而不是一个模式，以下模式（但不限于）实现了 IoC 原则。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/ioc-patterns.png" alt="ioc-patterns" />&lt;/p>
&lt;p>&lt;strong>Spring IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。&lt;/strong> IoC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。&lt;/p>
&lt;p>在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。&lt;/p>
&lt;blockquote>
&lt;p>关于 Spring IOC 的理解，推荐看这一下知乎的一个回答：&lt;a href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662&lt;/a> ，非常不错。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>控制反转怎么理解呢?&lt;/strong> 举个例子：&amp;ldquo;对象 a 依赖了对象 b，当对象 a 需要使用 对象 b 的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象 a 和对象 b 之间就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b 的时候， 我们可以指定 IOC 容器去创建一个对象 b 注入到对象 a 中&amp;rdquo;。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权反转，这就是控制反转名字的由来。&lt;/p></description></item><item><title>Spring&amp;SpringBoot常用注解总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/spring-common-annotations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/spring-common-annotations/</guid><description>&lt;h3 id="0前言">
 0.前言
 &lt;a class="anchor" href="#0%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h3>
&lt;p>可以毫不夸张地说，这篇文章介绍的 Spring/SpringBoot 常用注解基本已经涵盖你工作中遇到的大部分常用的场景。对于每一个注解我都说了具体用法，掌握搞懂，使用 SpringBoot 来开发项目基本没啥大问题了！&lt;/p>
&lt;p>&lt;strong>为什么要写这篇文章？&lt;/strong>&lt;/p>
&lt;p>最近看到网上有一篇关于 SpringBoot 常用注解的文章被转载的比较多，我看了文章内容之后属实觉得质量有点低，并且有点会误导没有太多实际使用经验的人（这些人又占据了大多数）。所以，自己索性花了大概 两天时间简单总结一下了。&lt;/p>
&lt;p>&lt;strong>因为我个人的能力和精力有限，如果有任何不对或者需要完善的地方，请帮忙指出！Guide 感激不尽！&lt;/strong>&lt;/p>
&lt;h3 id="1-springbootapplication">
 1. &lt;code>@SpringBootApplication&lt;/code>
 &lt;a class="anchor" href="#1-springbootapplication">#&lt;/a>
&lt;/h3>
&lt;p>这里先单独拎出&lt;code>@SpringBootApplication&lt;/code> 注解说一下，虽然我们一般不会主动去使用它。&lt;/p>
&lt;p>&lt;em>Guide：这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。&lt;/em>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SpringBootApplication&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SpringSecurityJwtGuideApplication&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(java.&lt;span style="color:#a6e22e">lang&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SpringApplication.&lt;span style="color:#a6e22e">run&lt;/span>(SpringSecurityJwtGuideApplication.&lt;span style="color:#a6e22e">class&lt;/span>, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以把 &lt;code>@SpringBootApplication&lt;/code>看作是 &lt;code>@Configuration&lt;/code>、&lt;code>@EnableAutoConfiguration&lt;/code>、&lt;code>@ComponentScan&lt;/code> 注解的集合。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> org.springframework.boot.autoconfigure;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Target&lt;/span>(ElementType.&lt;span style="color:#a6e22e">TYPE&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Retention&lt;/span>(RetentionPolicy.&lt;span style="color:#a6e22e">RUNTIME&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Documented&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Inherited&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SpringBootConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@EnableAutoConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ComponentScan&lt;/span>(excludeFilters &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Filter&lt;/span>(type &lt;span style="color:#f92672">=&lt;/span> FilterType.&lt;span style="color:#a6e22e">CUSTOM&lt;/span>, classes &lt;span style="color:#f92672">=&lt;/span> TypeExcludeFilter.&lt;span style="color:#a6e22e">class&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Filter&lt;/span>(type &lt;span style="color:#f92672">=&lt;/span> FilterType.&lt;span style="color:#a6e22e">CUSTOM&lt;/span>, classes &lt;span style="color:#f92672">=&lt;/span> AutoConfigurationExcludeFilter.&lt;span style="color:#a6e22e">class&lt;/span>) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">@interface&lt;/span> SpringBootApplication {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ......
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> org.springframework.boot;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Target&lt;/span>(ElementType.&lt;span style="color:#a6e22e">TYPE&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Retention&lt;/span>(RetentionPolicy.&lt;span style="color:#a6e22e">RUNTIME&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Documented&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">@interface&lt;/span> SpringBootConfiguration {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据 SpringBoot 官网，这三个注解的作用分别是：&lt;/p></description></item><item><title>SpringBoot 自动装配原理详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/spring-boot-auto-assembly-principles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/spring-boot-auto-assembly-principles/</guid><description>&lt;blockquote>
&lt;p>作者：&lt;a href="https://github.com/Miki-byte-1024">Miki-byte-1024&lt;/a> &amp;amp; &lt;a href="https://github.com/Snailclimb">Snailclimb&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>每次问到 Spring Boot， 面试官非常喜欢问这个问题：“讲述一下 SpringBoot 自动装配原理？”。&lt;/p>
&lt;p>我觉得我们可以从以下几个方面回答：&lt;/p>
&lt;ol>
&lt;li>什么是 SpringBoot 自动装配？&lt;/li>
&lt;li>SpringBoot 是如何实现自动装配的？如何实现按需加载？&lt;/li>
&lt;li>如何实现一个 Starter？&lt;/li>
&lt;/ol>
&lt;p>篇幅问题，这篇文章并没有深入，小伙伴们也可以直接使用 debug 的方式去看看 SpringBoot 自动装配部分的源代码。&lt;/p>
&lt;h2 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>使用过 Spring 的小伙伴，一定有被 XML 配置统治的恐惧。即使 Spring 后面引入了基于注解的配置，我们在开启某些 Spring 特性或者引入第三方依赖的时候，还是需要用 XML 或 Java 进行显式配置。&lt;/p>
&lt;p>举个例子。没有 Spring Boot 的时候，我们写一个 RestFul Web 服务，还首先需要进行如下配置。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RESTConfiguration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> View &lt;span style="color:#a6e22e">jsonTemplate&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MappingJackson2JsonView view &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> MappingJackson2JsonView();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> view.&lt;span style="color:#a6e22e">setPrettyPrint&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> view;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> ViewResolver &lt;span style="color:#a6e22e">viewResolver&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BeanNameViewResolver();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>spring-servlet.xml&lt;/code>&lt;/p></description></item><item><title>SpringBoot常见面试题总结(付费)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/springboot-knowledge-and-questions-summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/springboot-knowledge-and-questions-summary/</guid><description>&lt;p>&lt;strong>Spring Boot&lt;/strong> 相关的面试题为我的&lt;a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了&lt;a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》&lt;/a>中。&lt;/p></description></item><item><title>Spring常见面试题总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/spring-knowledge-and-questions-summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/framework/spring/spring-knowledge-and-questions-summary/</guid><description>&lt;p>这篇文章主要是想通过一些问题，加深大家对于 Spring 的理解，所以不会涉及太多的代码！&lt;/p>
&lt;p>下面的很多问题我自己在使用 Spring 的过程中也并没有注意，自己也是临时查阅了很多资料和书籍补上的。网上也有一些很多关于 Spring 常见问题/面试题整理的文章，我感觉大部分都是互相 copy，而且很多问题也不是很好，有些回答也存在问题。所以，自己花了一周的业余时间整理了一下，希望对大家有帮助。&lt;/p>
&lt;h2 id="spring-基础">
 Spring 基础
 &lt;a class="anchor" href="#spring-%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是-spring-框架">
 什么是 Spring 框架?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-spring-%e6%a1%86%e6%9e%b6">#&lt;/a>
&lt;/h3>
&lt;p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。&lt;/p>
&lt;p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/38ef122122de4375abcd27c3de8f60b4.png" alt="" />&lt;/p>
&lt;p>Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。&lt;/p>
&lt;p>Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！&lt;/p>
&lt;p>🤐 多提一嘴：&lt;strong>语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。&lt;/strong>&lt;/p>
&lt;p>Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！&lt;/p>
&lt;ul>
&lt;li>Spring 官网：&lt;a href="https://spring.io/">https://spring.io/&lt;/a>&lt;/li>
&lt;li>GitHub 地址： &lt;a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="spring-包含的模块有哪些">
 Spring 包含的模块有哪些？
 &lt;a class="anchor" href="#spring-%e5%8c%85%e5%90%ab%e7%9a%84%e6%a8%a1%e5%9d%97%e6%9c%89%e5%93%aa%e4%ba%9b">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>Spring4.x 版本&lt;/strong>：&lt;/p></description></item><item><title>SQL常见面试题总结（1）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/sql/sql-questions-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/sql/sql-questions-01/</guid><description>&lt;blockquote>
&lt;p>题目来源于：&lt;a href="https://www.nowcoder.com/exam/oj?page=1&amp;amp;tab=SQL%E7%AF%87&amp;amp;topicId=298">牛客题霸 - SQL 必知必会&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="检索数据">
 检索数据
 &lt;a class="anchor" href="#%e6%a3%80%e7%b4%a2%e6%95%b0%e6%8d%ae">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>SELECT&lt;/code> 用于从数据库中查询数据。&lt;/p>
&lt;h3 id="从-customers-表中检索所有的-id">
 从 Customers 表中检索所有的 ID
 &lt;a class="anchor" href="#%e4%bb%8e-customers-%e8%a1%a8%e4%b8%ad%e6%a3%80%e7%b4%a2%e6%89%80%e6%9c%89%e7%9a%84-id">#&lt;/a>
&lt;/h3>
&lt;p>现有表 &lt;code>Customers&lt;/code> 如下：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>cust_id&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>A&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>B&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>C&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>编写 SQL 语句，从 &lt;code>Customers&lt;/code> 表中检索所有的 &lt;code>cust_id&lt;/code>。&lt;/p>
&lt;p>答案：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> cust_id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span> Customers
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="检索并列出已订购产品的清单">
 检索并列出已订购产品的清单
 &lt;a class="anchor" href="#%e6%a3%80%e7%b4%a2%e5%b9%b6%e5%88%97%e5%87%ba%e5%b7%b2%e8%ae%a2%e8%b4%ad%e4%ba%a7%e5%93%81%e7%9a%84%e6%b8%85%e5%8d%95">#&lt;/a>
&lt;/h3>
&lt;p>表 &lt;code>OrderItems&lt;/code> 含有非空的列 &lt;code>prod_id&lt;/code> 代表商品 id，包含了所有已订购的商品（有些已被订购多次）。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>prod_id&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>a1&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>a2&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>a3&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>a4&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>a5&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>a6&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>a7&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>编写 SQL 语句，检索并列出所有已订购商品（&lt;code>prod_id&lt;/code>）的去重后的清单。&lt;/p>
&lt;p>答案：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#66d9ef">DISTINCT&lt;/span> prod_id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span> OrderItems
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>知识点：&lt;code>DISTINCT&lt;/code> 用于返回列中的唯一不同值。&lt;/p>
&lt;h3 id="检索所有列">
 检索所有列
 &lt;a class="anchor" href="#%e6%a3%80%e7%b4%a2%e6%89%80%e6%9c%89%e5%88%97">#&lt;/a>
&lt;/h3>
&lt;p>现在有 &lt;code>Customers&lt;/code> 表（表中含有列 &lt;code>cust_id&lt;/code> 代表客户 id，&lt;code>cust_name&lt;/code> 代表客户姓名）&lt;/p></description></item><item><title>SQL常见面试题总结（2）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/sql/sql-questions-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/sql/sql-questions-02/</guid><description>&lt;blockquote>
&lt;p>题目来源于：&lt;a href="https://www.nowcoder.com/exam/oj?page=1&amp;amp;tab=SQL%E7%AF%87&amp;amp;topicId=240">牛客题霸 - SQL 进阶挑战&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="增删改操作">
 增删改操作
 &lt;a class="anchor" href="#%e5%a2%9e%e5%88%a0%e6%94%b9%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h2>
&lt;p>SQL 插入记录的方式汇总：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>普通插入（全字段）&lt;/strong> ：&lt;code>INSERT INTO table_name VALUES (value1, value2, ...)&lt;/code>&lt;/li>
&lt;li>&lt;strong>普通插入（限定字段）&lt;/strong> ：&lt;code>INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...)&lt;/code>&lt;/li>
&lt;li>&lt;strong>多条一次性插入&lt;/strong> ：&lt;code>INSERT INTO table_name (column1, column2, ...) VALUES (value1_1, value1_2, ...), (value2_1, value2_2, ...), ...&lt;/code>&lt;/li>
&lt;li>&lt;strong>从另一个表导入&lt;/strong> ：&lt;code>INSERT INTO table_name SELECT * FROM table_name2 [WHERE key=value]&lt;/code>&lt;/li>
&lt;li>&lt;strong>带更新的插入&lt;/strong> ：&lt;code>REPLACE INTO table_name VALUES (value1, value2, ...)&lt;/code>（注意这种原理是检测到主键或唯一性索引键重复就删除原记录后重新插入）&lt;/li>
&lt;/ul>
&lt;h3 id="插入记录一">
 插入记录（一）
 &lt;a class="anchor" href="#%e6%8f%92%e5%85%a5%e8%ae%b0%e5%bd%95%e4%b8%80">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>描述&lt;/strong>：牛客后台会记录每个用户的试卷作答记录到 &lt;code>exam_record&lt;/code> 表，现在有两个用户的作答记录详情如下：&lt;/p>
&lt;ul>
&lt;li>用户 1001 在 2021 年 9 月 1 日晚上 10 点 11 分 12 秒开始作答试卷 9001，并在 50 分钟后提交，得了 90 分；&lt;/li>
&lt;li>用户 1002 在 2021 年 9 月 4 日上午 7 点 1 分 2 秒开始作答试卷 9002，并在 10 分钟后退出了平台。&lt;/li>
&lt;/ul>
&lt;p>试卷作答记录表&lt;code>exam_record&lt;/code>中，表已建好，其结构如下，请用一条语句将这两条记录插入表中。&lt;/p></description></item><item><title>SQL常见面试题总结（3）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/sql/sql-questions-03/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/sql/sql-questions-03/</guid><description>&lt;blockquote>
&lt;p>题目来源于：&lt;a href="https://www.nowcoder.com/exam/oj?page=1&amp;amp;tab=SQL%E7%AF%87&amp;amp;topicId=240">牛客题霸 - SQL 进阶挑战&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。&lt;/p>
&lt;h2 id="聚合函数">
 聚合函数
 &lt;a class="anchor" href="#%e8%81%9a%e5%90%88%e5%87%bd%e6%95%b0">#&lt;/a>
&lt;/h2>
&lt;h3 id="sql-类别高难度试卷得分的截断平均值较难">
 SQL 类别高难度试卷得分的截断平均值（较难）
 &lt;a class="anchor" href="#sql-%e7%b1%bb%e5%88%ab%e9%ab%98%e9%9a%be%e5%ba%a6%e8%af%95%e5%8d%b7%e5%be%97%e5%88%86%e7%9a%84%e6%88%aa%e6%96%ad%e5%b9%b3%e5%9d%87%e5%80%bc%e8%be%83%e9%9a%be">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>描述&lt;/strong>： 牛客的运营同学想要查看大家在 SQL 类别中高难度试卷的得分情况。&lt;/p>
&lt;p>请你帮她从&lt;code>exam_record&lt;/code>数据表中计算所有用户完成 SQL 类别高难度试卷得分的截断平均值（去掉一个最大值和一个最小值后的平均值）。&lt;/p>
&lt;p>示例数据：&lt;code>examination_info&lt;/code>（&lt;code>exam_id&lt;/code> 试卷 ID, tag 试卷类别, &lt;code>difficulty&lt;/code> 试卷难度, &lt;code>duration&lt;/code> 考试时长, &lt;code>release_time&lt;/code> 发布时间）&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>id&lt;/th>
 &lt;th>exam_id&lt;/th>
 &lt;th>tag&lt;/th>
 &lt;th>difficulty&lt;/th>
 &lt;th>duration&lt;/th>
 &lt;th>release_time&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>1&lt;/td>
 &lt;td>9001&lt;/td>
 &lt;td>SQL&lt;/td>
 &lt;td>hard&lt;/td>
 &lt;td>60&lt;/td>
 &lt;td>2020-01-01 10:00:00&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>2&lt;/td>
 &lt;td>9002&lt;/td>
 &lt;td>算法&lt;/td>
 &lt;td>medium&lt;/td>
 &lt;td>80&lt;/td>
 &lt;td>2020-08-02 10:00:00&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>示例数据：&lt;code>exam_record&lt;/code>（uid 用户 ID, exam_id 试卷 ID, start_time 开始作答时间, submit_time 交卷时间, score 得分）&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>id&lt;/th>
 &lt;th>uid&lt;/th>
 &lt;th>exam_id&lt;/th>
 &lt;th>start_time&lt;/th>
 &lt;th>submit_time&lt;/th>
 &lt;th>score&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>1&lt;/td>
 &lt;td>1001&lt;/td>
 &lt;td>9001&lt;/td>
 &lt;td>2020-01-02 09:01:01&lt;/td>
 &lt;td>2020-01-02 09:21:01&lt;/td>
 &lt;td>80&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>2&lt;/td>
 &lt;td>1001&lt;/td>
 &lt;td>9001&lt;/td>
 &lt;td>2021-05-02 10:01:01&lt;/td>
 &lt;td>2021-05-02 10:30:01&lt;/td>
 &lt;td>81&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>3&lt;/td>
 &lt;td>1001&lt;/td>
 &lt;td>9001&lt;/td>
 &lt;td>2021-06-02 19:01:01&lt;/td>
 &lt;td>2021-06-02 19:31:01&lt;/td>
 &lt;td>84&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>4&lt;/td>
 &lt;td>1001&lt;/td>
 &lt;td>9002&lt;/td>
 &lt;td>2021-09-05 19:01:01&lt;/td>
 &lt;td>2021-09-05 19:40:01&lt;/td>
 &lt;td>89&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>5&lt;/td>
 &lt;td>1001&lt;/td>
 &lt;td>9001&lt;/td>
 &lt;td>2021-09-02 12:01:01&lt;/td>
 &lt;td>(NULL)&lt;/td>
 &lt;td>(NULL)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>6&lt;/td>
 &lt;td>1001&lt;/td>
 &lt;td>9002&lt;/td>
 &lt;td>2021-09-01 12:01:01&lt;/td>
 &lt;td>(NULL)&lt;/td>
 &lt;td>(NULL)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>7&lt;/td>
 &lt;td>1002&lt;/td>
 &lt;td>9002&lt;/td>
 &lt;td>2021-02-02 19:01:01&lt;/td>
 &lt;td>2021-02-02 19:30:01&lt;/td>
 &lt;td>87&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>8&lt;/td>
 &lt;td>1002&lt;/td>
 &lt;td>9001&lt;/td>
 &lt;td>2021-05-05 18:01:01&lt;/td>
 &lt;td>2021-05-05 18:59:02&lt;/td>
 &lt;td>90&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>9&lt;/td>
 &lt;td>1003&lt;/td>
 &lt;td>9001&lt;/td>
 &lt;td>2021-09-07 12:01:01&lt;/td>
 &lt;td>2021-09-07 10:31:01&lt;/td>
 &lt;td>50&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>10&lt;/td>
 &lt;td>1004&lt;/td>
 &lt;td>9001&lt;/td>
 &lt;td>2021-09-06 10:01:01&lt;/td>
 &lt;td>(NULL)&lt;/td>
 &lt;td>(NULL)&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>根据输入你的查询结果如下：&lt;/p></description></item><item><title>SQL常见面试题总结（4）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/sql/sql-questions-04/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/sql/sql-questions-04/</guid><description>&lt;blockquote>
&lt;p>题目来源于：&lt;a href="https://www.nowcoder.com/exam/oj?page=1&amp;amp;tab=SQL%E7%AF%87&amp;amp;topicId=240">牛客题霸 - SQL 进阶挑战&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。&lt;/p>
&lt;h2 id="专用窗口函数">
 专用窗口函数
 &lt;a class="anchor" href="#%e4%b8%93%e7%94%a8%e7%aa%97%e5%8f%a3%e5%87%bd%e6%95%b0">#&lt;/a>
&lt;/h2>
&lt;p>MySQL 8.0 版本引入了窗口函数的支持，下面是 MySQL 中常见的窗口函数及其用法：&lt;/p>
&lt;ol>
&lt;li>&lt;code>ROW_NUMBER()&lt;/code>: 为查询结果集中的每一行分配一个唯一的整数值。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> col1, col2, ROW_NUMBER() OVER (&lt;span style="color:#66d9ef">ORDER&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> col1) &lt;span style="color:#66d9ef">AS&lt;/span> row_num
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>&lt;code>RANK()&lt;/code>: 计算每一行在排序结果中的排名。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> col1, col2, RANK() OVER (&lt;span style="color:#66d9ef">ORDER&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> col1 &lt;span style="color:#66d9ef">DESC&lt;/span>) &lt;span style="color:#66d9ef">AS&lt;/span> ranking
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>&lt;code>DENSE_RANK()&lt;/code>: 计算每一行在排序结果中的排名，保留相同的排名。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> col1, col2, DENSE_RANK() OVER (&lt;span style="color:#66d9ef">ORDER&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> col1 &lt;span style="color:#66d9ef">DESC&lt;/span>) &lt;span style="color:#66d9ef">AS&lt;/span> ranking
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>&lt;code>NTILE(n)&lt;/code>: 将结果分成 n 个基本均匀的桶，并为每个桶分配一个标识号。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> col1, col2, NTILE(&lt;span style="color:#ae81ff">4&lt;/span>) OVER (&lt;span style="color:#66d9ef">ORDER&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> col1) &lt;span style="color:#66d9ef">AS&lt;/span> bucket
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>&lt;code>SUM()&lt;/code>, &lt;code>AVG()&lt;/code>,&lt;code>COUNT()&lt;/code>, &lt;code>MIN()&lt;/code>, &lt;code>MAX()&lt;/code>: 这些聚合函数也可以与窗口函数结合使用，计算窗口内指定列的汇总、平均值、计数、最小值和最大值。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> col1, col2, &lt;span style="color:#66d9ef">SUM&lt;/span>(col1) OVER () &lt;span style="color:#66d9ef">AS&lt;/span> sum_col
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="6">
&lt;li>&lt;code>LEAD()&lt;/code> 和 &lt;code>LAG()&lt;/code>: LEAD 函数用于获取当前行之后的某个偏移量的行的值，而 LAG 函数用于获取当前行之前的某个偏移量的行的值。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> col1, col2, LEAD(col1, &lt;span style="color:#ae81ff">1&lt;/span>) OVER (&lt;span style="color:#66d9ef">ORDER&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> col1) &lt;span style="color:#66d9ef">AS&lt;/span> next_col1,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LAG(col1, &lt;span style="color:#ae81ff">1&lt;/span>) OVER (&lt;span style="color:#66d9ef">ORDER&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> col1) &lt;span style="color:#66d9ef">AS&lt;/span> prev_col1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="7">
&lt;li>&lt;code>FIRST_VALUE()&lt;/code> 和 &lt;code>LAST_VALUE()&lt;/code>: FIRST_VALUE 函数用于获取窗口内指定列的第一个值，LAST_VALUE 函数用于获取窗口内指定列的最后一个值。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> col1, col2, FIRST_VALUE(col2) OVER (PARTITION &lt;span style="color:#66d9ef">BY&lt;/span> col1 &lt;span style="color:#66d9ef">ORDER&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> col2) &lt;span style="color:#66d9ef">AS&lt;/span> first_val,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LAST_VALUE(col2) OVER (PARTITION &lt;span style="color:#66d9ef">BY&lt;/span> col1 &lt;span style="color:#66d9ef">ORDER&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> col2) &lt;span style="color:#66d9ef">AS&lt;/span> last_val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>窗口函数通常需要配合 OVER 子句一起使用，用于定义窗口的大小、排序规则和分组方式。&lt;/p></description></item><item><title>SQL常见面试题总结（5）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/sql/sql-questions-05/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/sql/sql-questions-05/</guid><description>&lt;blockquote>
&lt;p>题目来源于：&lt;a href="https://www.nowcoder.com/exam/oj?page=1&amp;amp;tab=SQL%E7%AF%87&amp;amp;topicId=240">牛客题霸 - SQL 进阶挑战&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>较难或者困难的题目可以根据自身实际情况和面试需要来决定是否要跳过。&lt;/p>
&lt;h2 id="空值处理">
 空值处理
 &lt;a class="anchor" href="#%e7%a9%ba%e5%80%bc%e5%a4%84%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;h3 id="统计有未完成状态的试卷的未完成数和未完成率">
 统计有未完成状态的试卷的未完成数和未完成率
 &lt;a class="anchor" href="#%e7%bb%9f%e8%ae%a1%e6%9c%89%e6%9c%aa%e5%ae%8c%e6%88%90%e7%8a%b6%e6%80%81%e7%9a%84%e8%af%95%e5%8d%b7%e7%9a%84%e6%9c%aa%e5%ae%8c%e6%88%90%e6%95%b0%e5%92%8c%e6%9c%aa%e5%ae%8c%e6%88%90%e7%8e%87">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>描述&lt;/strong>：&lt;/p>
&lt;p>现有试卷作答记录表 &lt;code>exam_record&lt;/code>（&lt;code>uid&lt;/code> 用户 ID, &lt;code>exam_id&lt;/code> 试卷 ID, &lt;code>start_time&lt;/code> 开始作答时间, &lt;code>submit_time&lt;/code> 交卷时间, &lt;code>score&lt;/code> 得分），数据如下：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>id&lt;/th>
 &lt;th>uid&lt;/th>
 &lt;th>exam_id&lt;/th>
 &lt;th>start_time&lt;/th>
 &lt;th>submit_time&lt;/th>
 &lt;th>score&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>1&lt;/td>
 &lt;td>1001&lt;/td>
 &lt;td>9001&lt;/td>
 &lt;td>2020-01-02 09:01:01&lt;/td>
 &lt;td>2020-01-02 09:21:01&lt;/td>
 &lt;td>80&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>2&lt;/td>
 &lt;td>1001&lt;/td>
 &lt;td>9001&lt;/td>
 &lt;td>2021-05-02 10:01:01&lt;/td>
 &lt;td>2021-05-02 10:30:01&lt;/td>
 &lt;td>81&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>3&lt;/td>
 &lt;td>1001&lt;/td>
 &lt;td>9001&lt;/td>
 &lt;td>2021-09-02 12:01:01&lt;/td>
 &lt;td>(NULL)&lt;/td>
 &lt;td>(NULL)&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>请统计有未完成状态的试卷的未完成数 incomplete_cnt 和未完成率 incomplete_rate。由示例数据结果输出如下：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>exam_id&lt;/th>
 &lt;th>incomplete_cnt&lt;/th>
 &lt;th>complete_rate&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>9001&lt;/td>
 &lt;td>1&lt;/td>
 &lt;td>0.333&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>解释：试卷 9001 有 3 次被作答的记录，其中两次完成，1 次未完成，因此未完成数为 1，未完成率为 0.333（保留 3 位小数）&lt;/p></description></item><item><title>SQL语法基础知识总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/sql/sql-syntax-summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/sql/sql-syntax-summary/</guid><description>&lt;blockquote>
&lt;p>本文整理完善自下面这两份资料：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://juejin.cn/post/6844903790571700231">SQL 语法速成手册&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.begtut.com/mysql/mysql-tutorial.html">MySQL 超全教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="基本概念">
 基本概念
 &lt;a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">#&lt;/a>
&lt;/h2>
&lt;h3 id="数据库术语">
 数据库术语
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e6%9c%af%e8%af%ad">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;code>数据库（database）&lt;/code> - 保存有组织的数据的容器（通常是一个文件或一组文件）。&lt;/li>
&lt;li>&lt;code>数据表（table）&lt;/code> - 某种特定类型数据的结构化清单。&lt;/li>
&lt;li>&lt;code>模式（schema）&lt;/code> - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。&lt;/li>
&lt;li>&lt;code>列（column）&lt;/code> - 表中的一个字段。所有表都是由一个或多个列组成的。&lt;/li>
&lt;li>&lt;code>行（row）&lt;/code> - 表中的一个记录。&lt;/li>
&lt;li>&lt;code>主键（primary key）&lt;/code> - 一列（或一组列），其值能够唯一标识表中每一行。&lt;/li>
&lt;/ul>
&lt;h3 id="sql-语法">
 SQL 语法
 &lt;a class="anchor" href="#sql-%e8%af%ad%e6%b3%95">#&lt;/a>
&lt;/h3>
&lt;p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。&lt;/p>
&lt;h4 id="sql-语法结构">
 SQL 语法结构
 &lt;a class="anchor" href="#sql-%e8%af%ad%e6%b3%95%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h4>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/cb684d4c75fc430e92aaee226069c7da~tplv-k3u1fbpfcp-zoom-1.png" alt="" />&lt;/p>
&lt;p>SQL 语法结构包括：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>子句&lt;/code>&lt;/strong> - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）&lt;/li>
&lt;li>&lt;strong>&lt;code>表达式&lt;/code>&lt;/strong> - 可以产生任何标量值，或由列和行的数据库表&lt;/li>
&lt;li>&lt;strong>&lt;code>谓词&lt;/code>&lt;/strong> - 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。&lt;/li>
&lt;li>&lt;strong>&lt;code>查询&lt;/code>&lt;/strong> - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。&lt;/li>
&lt;li>&lt;strong>&lt;code>语句&lt;/code>&lt;/strong> - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。&lt;/li>
&lt;/ul>
&lt;h4 id="sql-语法要点">
 SQL 语法要点
 &lt;a class="anchor" href="#sql-%e8%af%ad%e6%b3%95%e8%a6%81%e7%82%b9">#&lt;/a>
&lt;/h4>
&lt;ul>
&lt;li>&lt;strong>SQL 语句不区分大小写&lt;/strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如：&lt;code>SELECT&lt;/code> 与 &lt;code>select&lt;/code>、&lt;code>Select&lt;/code> 是相同的。&lt;/li>
&lt;li>&lt;strong>多条 SQL 语句必须以分号（&lt;code>;&lt;/code>）分隔&lt;/strong>。&lt;/li>
&lt;li>处理 SQL 语句时，&lt;strong>所有空格都被忽略&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>SQL 语句可以写成一行，也可以分写为多行。&lt;/p></description></item><item><title>SQL语句在MySQL中的执行过程</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/how-sql-executed-in-mysql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/how-sql-executed-in-mysql/</guid><description>&lt;blockquote>
&lt;p>本文来自&lt;a href="https://github.com/kinglaw1204">木木匠&lt;/a>投稿。&lt;/p>
&lt;/blockquote>
&lt;p>本篇文章会分析下一个 SQL 语句在 MySQL 中的执行流程，包括 SQL 的查询在 MySQL 内部会怎么流转，SQL 语句的更新是怎么完成的。&lt;/p>
&lt;p>在分析之前我会先带着你看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。&lt;/p>
&lt;h2 id="一-mysql-基础架构分析">
 一 MySQL 基础架构分析
 &lt;a class="anchor" href="#%e4%b8%80-mysql-%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h2>
&lt;h3 id="11-mysql-基本架构概览">
 1.1 MySQL 基本架构概览
 &lt;a class="anchor" href="#11-mysql-%e5%9f%ba%e6%9c%ac%e6%9e%b6%e6%9e%84%e6%a6%82%e8%a7%88">#&lt;/a>
&lt;/h3>
&lt;p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。&lt;/p>
&lt;p>先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>连接器：&lt;/strong> 身份认证和权限相关(登录 MySQL 的时候)。&lt;/li>
&lt;li>&lt;strong>查询缓存：&lt;/strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。&lt;/li>
&lt;li>&lt;strong>分析器：&lt;/strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。&lt;/li>
&lt;li>&lt;strong>优化器：&lt;/strong> 按照 MySQL 认为最优的方案去执行。&lt;/li>
&lt;li>&lt;strong>执行器：&lt;/strong> 执行语句，然后从存储引擎返回数据。 -&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://oss.javaguide.cn/javaguide/13526879-3037b144ed09eb88.png" alt="" />&lt;/p>
&lt;p>简单来说 MySQL 主要分为 Server 层和存储引擎层：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Server 层&lt;/strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。&lt;/li>
&lt;li>&lt;strong>存储引擎&lt;/strong>：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。&lt;strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="12-server-层基本组件介绍">
 1.2 Server 层基本组件介绍
 &lt;a class="anchor" href="#12-server-%e5%b1%82%e5%9f%ba%e6%9c%ac%e7%bb%84%e4%bb%b6%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h3>
&lt;h4 id="1-连接器">
 1) 连接器
 &lt;a class="anchor" href="#1-%e8%bf%9e%e6%8e%a5%e5%99%a8">#&lt;/a>
&lt;/h4>
&lt;p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。&lt;/p></description></item><item><title>SSO 单点登录详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/sso-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/sso-intro/</guid><description>&lt;blockquote>
&lt;p>本文授权转载自：&lt;a href="https://ken.io/note/sso-design-implement">https://ken.io/note/sso-design-implement&lt;/a> 作者：ken.io&lt;/p>
&lt;/blockquote>
&lt;h2 id="sso-介绍">
 SSO 介绍
 &lt;a class="anchor" href="#sso-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是-sso">
 什么是 SSO？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-sso">#&lt;/a>
&lt;/h3>
&lt;p>SSO 英文全称 Single Sign On，单点登录。SSO 是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。&lt;/p>
&lt;p>例如你登录网易账号中心（&lt;a href="https://reg.163.com/">https://reg.163.com/&lt;/a> ）之后访问以下站点都是登录状态。&lt;/p>
&lt;ul>
&lt;li>网易直播 &lt;a href="https://v.163.com/">https://v.163.com&lt;/a>&lt;/li>
&lt;li>网易博客 &lt;a href="https://blog.163.com/">https://blog.163.com&lt;/a>&lt;/li>
&lt;li>网易花田 &lt;a href="https://love.163.com/">https://love.163.com&lt;/a>&lt;/li>
&lt;li>网易考拉 &lt;a href="https://www.kaola.com/">https://www.kaola.com&lt;/a>&lt;/li>
&lt;li>网易 Lofter &lt;a href="http://www.lofter.com/">http://www.lofter.com&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="sso-有什么好处">
 SSO 有什么好处？
 &lt;a class="anchor" href="#sso-%e6%9c%89%e4%bb%80%e4%b9%88%e5%a5%bd%e5%a4%84">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>用户角度&lt;/strong> :用户能够做到一次登录多次使用，无需记录多套用户名和密码，省心。&lt;/li>
&lt;li>&lt;strong>系统管理员角度&lt;/strong> : 管理员只需维护好一个统一的账号中心就可以了，方便。&lt;/li>
&lt;li>&lt;strong>新系统开发角度:&lt;/strong> 新系统开发时只需直接对接统一的账号中心即可，简化开发流程，省时。&lt;/li>
&lt;/ol>
&lt;h2 id="sso-设计与实现">
 SSO 设计与实现
 &lt;a class="anchor" href="#sso-%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0">#&lt;/a>
&lt;/h2>
&lt;p>本篇文章也主要是为了探讨如何设计&amp;amp;实现一个 SSO 系统&lt;/p>
&lt;p>以下为需要实现的核心功能：&lt;/p>
&lt;ul>
&lt;li>单点登录&lt;/li>
&lt;li>单点登出&lt;/li>
&lt;li>支持跨域单点登录&lt;/li>
&lt;li>支持跨域单点登出&lt;/li>
&lt;/ul>
&lt;h3 id="核心应用与依赖">
 核心应用与依赖
 &lt;a class="anchor" href="#%e6%a0%b8%e5%bf%83%e5%ba%94%e7%94%a8%e4%b8%8e%e4%be%9d%e8%b5%96">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sso/sso-system.png-kblb.png" alt="单点登录（SSO）设计" />&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>应用/模块/对象&lt;/th>
 &lt;th>说明&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>前台站点&lt;/td>
 &lt;td>需要登录的站点&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SSO 站点-登录&lt;/td>
 &lt;td>提供登录的页面&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SSO 站点-登出&lt;/td>
 &lt;td>提供注销登录的入口&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SSO 服务-登录&lt;/td>
 &lt;td>提供登录服务&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SSO 服务-登录状态&lt;/td>
 &lt;td>提供登录状态校验/登录信息查询的服务&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>SSO 服务-登出&lt;/td>
 &lt;td>提供用户注销登录的服务&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>数据库&lt;/td>
 &lt;td>存储用户账户信息&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>缓存&lt;/td>
 &lt;td>存储用户的登录信息，通常使用 Redis&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h3 id="用户登录状态的存储与校验">
 用户登录状态的存储与校验
 &lt;a class="anchor" href="#%e7%94%a8%e6%88%b7%e7%99%bb%e5%bd%95%e7%8a%b6%e6%80%81%e7%9a%84%e5%ad%98%e5%82%a8%e4%b8%8e%e6%a0%a1%e9%aa%8c">#&lt;/a>
&lt;/h3>
&lt;p>常见的 Web 框架对于 Session 的实现都是生成一个 SessionId 存储在浏览器 Cookie 中。然后将 Session 内容存储在服务器端内存中，这个 &lt;a href="https://ken.io/">ken.io&lt;/a> 在之前&lt;a href="https://ken.io/note/session-principle-skill">Session 工作原理&lt;/a>中也提到过。整体也是借鉴这个思路。&lt;/p></description></item><item><title>TCP 传输可靠性保障（传输层）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/tcp-reliability-guarantee/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/tcp-reliability-guarantee/</guid><description>&lt;h2 id="tcp-如何保证传输的可靠性">
 TCP 如何保证传输的可靠性？
 &lt;a class="anchor" href="#tcp-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e4%bc%a0%e8%be%93%e7%9a%84%e5%8f%af%e9%9d%a0%e6%80%a7">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>基于数据块传输&lt;/strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。&lt;/li>
&lt;li>&lt;strong>对失序数据包重新排序以及去重&lt;/strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。&lt;/li>
&lt;li>&lt;strong>校验和&lt;/strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。&lt;/li>
&lt;li>&lt;strong>重传机制&lt;/strong> : 在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。TCP 重传机制主要有：基于计时器的重传（也就是超时重传）、快速重传（基于接收端的反馈信息来引发重传）、SACK（在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了）、D-SACK（重复 SACK，在 SACK 的基础上，额外携带信息，告知发送方有哪些数据包自己重复接收了）。关于重传机制的详细介绍，可以查看&lt;a href="https://zhuanlan.zhihu.com/p/101702312">详解 TCP 超时与重传机制&lt;/a>这篇文章。&lt;/li>
&lt;li>&lt;strong>流量控制&lt;/strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。&lt;/li>
&lt;li>&lt;strong>拥塞控制&lt;/strong> : 当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。&lt;/li>
&lt;/ol>
&lt;h2 id="tcp-如何实现流量控制">
 TCP 如何实现流量控制？
 &lt;a class="anchor" href="#tcp-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。&lt;/strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。&lt;/p>
&lt;p>&lt;strong>为什么需要流量控制?&lt;/strong> 这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 &lt;strong>接收缓冲区(Receiving Buffers)&lt;/strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。&lt;/p>
&lt;p>这里需要注意的是（常见误区）：&lt;/p>
&lt;ul>
&lt;li>发送端不等同于客户端&lt;/li>
&lt;li>接收端不等同于服务端&lt;/li>
&lt;/ul>
&lt;p>TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP 传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同&lt;/p>
&lt;p>&lt;strong>TCP 发送窗口可以划分成四个部分&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>已经发送并且确认的 TCP 段（已经发送并确认）；&lt;/li>
&lt;li>已经发送但是没有确认的 TCP 段（已经发送未确认）；&lt;/li>
&lt;li>未发送但是接收方准备接收的 TCP 段（可以发送）；&lt;/li>
&lt;li>未发送并且接收方也并未准备接受的 TCP 段（不可发送）。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>TCP 发送窗口结构图示&lt;/strong>：&lt;/p></description></item><item><title>TCP 三次握手和四次挥手（传输层）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/tcp-connection-and-disconnection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/tcp-connection-and-disconnection/</guid><description>&lt;p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。&lt;/p>
&lt;h2 id="建立连接-tcp-三次握手">
 建立连接-TCP 三次握手
 &lt;a class="anchor" href="#%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5-tcp-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" alt="TCP 三次握手图解" />&lt;/p>
&lt;p>建立一个 TCP 连接需要“三次握手”，缺一不可：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>一次握手&lt;/strong>:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&amp;gt; 服务端，然后客户端进入 &lt;strong>SYN_SEND&lt;/strong> 状态，等待服务端的确认；&lt;/li>
&lt;li>&lt;strong>二次握手&lt;/strong>:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&amp;gt; 客户端,然后服务端进入 &lt;strong>SYN_RECV&lt;/strong> 状态；&lt;/li>
&lt;li>&lt;strong>三次握手&lt;/strong>:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –&amp;gt; 服务端，然后客户端和服务端都进入&lt;strong>ESTABLISHED&lt;/strong> 状态，完成 TCP 三次握手。&lt;/li>
&lt;/ul>
&lt;p>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！&lt;/p>
&lt;h3 id="什么是半连接队列和全连接队列">
 什么是半连接队列和全连接队列？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%8d%8a%e8%bf%9e%e6%8e%a5%e9%98%9f%e5%88%97%e5%92%8c%e5%85%a8%e8%bf%9e%e6%8e%a5%e9%98%9f%e5%88%97">#&lt;/a>
&lt;/h3>
&lt;p>在 TCP 三次握手过程中，Linux 内核会维护两个队列来管理连接请求：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>半连接队列&lt;/strong>（也称 SYN Queue）：当服务端收到客户端的 SYN 请求时，此时双方还没有完全建立连接，它会把半连接状态的连接放在半连接队列。&lt;/li>
&lt;li>&lt;strong>全连接队列&lt;/strong>（也称 Accept Queue）：当服务端收到客户端对 ACK 响应时，意味着三次握手成功完成，服务端会将该连接从半连接队列移动到全连接队列。如果未收到客户端的 ACK 响应，会进行重传，重传的等待时间通常是指数增长的。如果重传次数超过系统规定的最大重传次数，系统将从半连接队列中删除该连接信息。&lt;/li>
&lt;/ol>
&lt;p>这两个队列的存在是为了处理并发连接请求，确保服务端能够有效地管理新的连接请求。另外，新的连接请求被拒绝或忽略除了和每个队列的大小限制有关系之外，还和很多其他因素有关系，这里就不详细介绍了，整体逻辑比较复杂。&lt;/p>
&lt;h3 id="为什么要三次握手">
 为什么要三次握手?
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b">#&lt;/a>
&lt;/h3>
&lt;p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>第一次握手&lt;/strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常&lt;/li>
&lt;li>&lt;strong>第二次握手&lt;/strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常&lt;/li>
&lt;li>&lt;strong>第三次握手&lt;/strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常&lt;/li>
&lt;/ol>
&lt;p>三次握手就能确认双方收发功能都正常，缺一不可。&lt;/p></description></item><item><title>ThreadLocal 详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/threadlocal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/threadlocal/</guid><description>&lt;blockquote>
&lt;p>本文来自一枝花算不算浪漫投稿， 原文地址：&lt;a href="https://juejin.cn/post/6844904151567040519">https://juejin.cn/post/6844904151567040519&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h3 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="./images/thread-local/1.png" alt="" />&lt;/p>
&lt;p>&lt;strong>全文共 10000+字，31 张图，这篇文章同样耗费了不少的时间和精力才创作完成，原创不易，请大家点点关注+在看，感谢。&lt;/strong>&lt;/p>
&lt;p>对于&lt;code>ThreadLocal&lt;/code>，大家的第一反应可能是很简单呀，线程的变量副本，每个线程隔离。那这里有几个问题大家可以思考一下：&lt;/p>
&lt;ul>
&lt;li>&lt;code>ThreadLocal&lt;/code>的 key 是&lt;strong>弱引用&lt;/strong>，那么在 &lt;code>ThreadLocal.get()&lt;/code>的时候，发生&lt;strong>GC&lt;/strong>之后，key 是否为&lt;strong>null&lt;/strong>？&lt;/li>
&lt;li>&lt;code>ThreadLocal&lt;/code>中&lt;code>ThreadLocalMap&lt;/code>的&lt;strong>数据结构&lt;/strong>？&lt;/li>
&lt;li>&lt;code>ThreadLocalMap&lt;/code>的&lt;strong>Hash 算法&lt;/strong>？&lt;/li>
&lt;li>&lt;code>ThreadLocalMap&lt;/code>中&lt;strong>Hash 冲突&lt;/strong>如何解决？&lt;/li>
&lt;li>&lt;code>ThreadLocalMap&lt;/code>的&lt;strong>扩容机制&lt;/strong>？&lt;/li>
&lt;li>&lt;code>ThreadLocalMap&lt;/code>中&lt;strong>过期 key 的清理机制&lt;/strong>？&lt;strong>探测式清理&lt;/strong>和&lt;strong>启发式清理&lt;/strong>流程？&lt;/li>
&lt;li>&lt;code>ThreadLocalMap.set()&lt;/code>方法实现原理？&lt;/li>
&lt;li>&lt;code>ThreadLocalMap.get()&lt;/code>方法实现原理？&lt;/li>
&lt;li>项目中&lt;code>ThreadLocal&lt;/code>使用情况？遇到的坑？&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;p>上述的一些问题你是否都已经掌握的很清楚了呢？本文将围绕这些问题使用图文方式来剖析&lt;code>ThreadLocal&lt;/code>的&lt;strong>点点滴滴&lt;/strong>。&lt;/p>
&lt;h3 id="目录">
 目录
 &lt;a class="anchor" href="#%e7%9b%ae%e5%bd%95">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>注明：&lt;/strong> 本文源码基于&lt;code>JDK 1.8&lt;/code>&lt;/p>
&lt;h3 id="threadlocal代码演示">
 &lt;code>ThreadLocal&lt;/code>代码演示
 &lt;a class="anchor" href="#threadlocal%e4%bb%a3%e7%a0%81%e6%bc%94%e7%a4%ba">#&lt;/a>
&lt;/h3>
&lt;p>我们先看下&lt;code>ThreadLocal&lt;/code>使用示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">ThreadLocalTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> messages &lt;span style="color:#f92672">=&lt;/span> Lists.&lt;span style="color:#a6e22e">newArrayList&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> ThreadLocal&lt;span style="color:#f92672">&amp;lt;&lt;/span>ThreadLocalTest&lt;span style="color:#f92672">&amp;gt;&lt;/span> holder &lt;span style="color:#f92672">=&lt;/span> ThreadLocal.&lt;span style="color:#a6e22e">withInitial&lt;/span>(ThreadLocalTest::&lt;span style="color:#66d9ef">new&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(String message) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> holder.&lt;span style="color:#a6e22e">get&lt;/span>().&lt;span style="color:#a6e22e">messages&lt;/span>.&lt;span style="color:#a6e22e">add&lt;/span>(message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">clear&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> messages &lt;span style="color:#f92672">=&lt;/span> holder.&lt;span style="color:#a6e22e">get&lt;/span>().&lt;span style="color:#a6e22e">messages&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> holder.&lt;span style="color:#a6e22e">remove&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;size: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> holder.&lt;span style="color:#a6e22e">get&lt;/span>().&lt;span style="color:#a6e22e">messages&lt;/span>.&lt;span style="color:#a6e22e">size&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> messages;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadLocalTest.&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;一枝花算不算浪漫&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(holder.&lt;span style="color:#a6e22e">get&lt;/span>().&lt;span style="color:#a6e22e">messages&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ThreadLocalTest.&lt;span style="color:#a6e22e">clear&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>打印结果：&lt;/p></description></item><item><title>Web 实时消息推送详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/web-real-time-message-push/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/web-real-time-message-push/</guid><description>&lt;blockquote>
&lt;p>原文地址：&lt;a href="https://juejin.cn/post/7122014462181113887%ef%bc%8cJavaGuide">https://juejin.cn/post/7122014462181113887，JavaGuide&lt;/a> 对本文进行了完善总结。&lt;/p>
&lt;/blockquote>
&lt;p>我有一个朋友做了一个小破站，现在要实现一个站内信 Web 消息推送的功能，对，就是下图这个小红点，一个很常用的功能。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192380.png" alt="站内信 Web 消息推送" />&lt;/p>
&lt;p>不过他还没想好用什么方式做，这里我帮他整理了一下几种方案，并简单做了实现。&lt;/p>
&lt;h2 id="什么是消息推送">
 什么是消息推送？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%b6%88%e6%81%af%e6%8e%a8%e9%80%81">#&lt;/a>
&lt;/h2>
&lt;p>推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。&lt;/p>
&lt;p>消息推送通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备 APP 进行的主动消息推送。&lt;/p>
&lt;p>消息推送一般又分为 Web 端消息推送和移动端消息推送。&lt;/p>
&lt;p>移动端消息推送示例：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/IKleJ9auR1Ojdicyr0bH.png" alt="移动端消息推送示例" />&lt;/p>
&lt;p>Web 端消息推送示例：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/image-20220819100512941.png" alt="Web 端消息推送示例" />&lt;/p>
&lt;p>在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，只要触发某个事件（主动分享了资源或者后台主动推送消息），Web 页面的通知小红点就会实时的 &lt;code>+1&lt;/code> 就可以了。&lt;/p>
&lt;p>通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192384.png" alt="消息推送表" />&lt;/p>
&lt;p>消息推送无非是推（push）和拉（pull）两种形式，下边我们逐个了解下。&lt;/p>
&lt;h2 id="消息推送常见方案">
 消息推送常见方案
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e6%8e%a8%e9%80%81%e5%b8%b8%e8%a7%81%e6%96%b9%e6%a1%88">#&lt;/a>
&lt;/h2>
&lt;h3 id="短轮询">
 短轮询
 &lt;a class="anchor" href="#%e7%9f%ad%e8%bd%ae%e8%af%a2">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>轮询(polling)&lt;/strong> 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。&lt;/p>
&lt;p>短轮询很好理解，指定的时间间隔，由浏览器向服务器发出 HTTP 请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。&lt;/p>
&lt;p>一个简单的 JS 定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">setInterval&lt;/span>(() &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 方法请求
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">messageCount&lt;/span>().&lt;span style="color:#a6e22e">then&lt;/span>((&lt;span style="color:#a6e22e">res&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">code&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">messageCount&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">res&lt;/span>.&lt;span style="color:#a6e22e">data&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}, &lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。&lt;/p>
&lt;h3 id="长轮询">
 长轮询
 &lt;a class="anchor" href="#%e9%95%bf%e8%bd%ae%e8%af%a2">#&lt;/a>
&lt;/h3>
&lt;p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如 Nacos 和 Apollo 配置中心，消息队列 Kafka、RocketMQ 中都有用到长轮询。&lt;/p></description></item><item><title>ZooKeeper 实战</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-in-action/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-in-action/</guid><description>&lt;p>这篇文章简单给演示一下 ZooKeeper 常见命令的使用以及 ZooKeeper Java 客户端 Curator 的基本使用。介绍到的内容都是最基本的操作，能满足日常工作的基本需要。&lt;/p>
&lt;p>如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！&lt;/p>
&lt;h2 id="zookeeper-安装">
 ZooKeeper 安装
 &lt;a class="anchor" href="#zookeeper-%e5%ae%89%e8%a3%85">#&lt;/a>
&lt;/h2>
&lt;h3 id="使用-docker-安装-zookeeper">
 使用 Docker 安装 zookeeper
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8-docker-%e5%ae%89%e8%a3%85-zookeeper">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>a.使用 Docker 下载 ZooKeeper&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker pull zookeeper:3.5.8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>b.运行 ZooKeeper&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>docker run -d --name zookeeper -p 2181:2181 zookeeper:3.5.8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="连接-zookeeper-服务">
 连接 ZooKeeper 服务
 &lt;a class="anchor" href="#%e8%bf%9e%e6%8e%a5-zookeeper-%e6%9c%8d%e5%8a%a1">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>a.进入 ZooKeeper 容器中&lt;/strong>&lt;/p>
&lt;p>先使用 &lt;code>docker ps&lt;/code> 查看 ZooKeeper 的 ContainerID，然后使用 &lt;code>docker exec -it ContainerID /bin/bash&lt;/code> 命令进入容器中。&lt;/p>
&lt;p>&lt;strong>b.先进入 bin 目录,然后通过 &lt;code>./zkCli.sh -server 127.0.0.1:2181&lt;/code>命令连接 ZooKeeper 服务&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>root@eaf70fc620cb:/apache-zookeeper-3.5.8-bin# cd bin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果你看到控制台成功打印出如下信息的话，说明你已经成功连接 ZooKeeper 服务。&lt;/p></description></item><item><title>ZooKeeper相关概念总结(进阶)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus/</guid><description>&lt;blockquote>
&lt;p>&lt;a href="https://juejin.im/user/5c33853851882525ea106810">FrancisQ&lt;/a> 投稿。&lt;/p>
&lt;/blockquote>
&lt;h2 id="什么是-zookeeper">
 什么是 ZooKeeper
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-zookeeper">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>ZooKeeper&lt;/code> 由 &lt;code>Yahoo&lt;/code> 开发，后来捐赠给了 &lt;code>Apache&lt;/code> ，现已成为 &lt;code>Apache&lt;/code> 顶级项目。&lt;code>ZooKeeper&lt;/code> 是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于 &lt;code>Paxos&lt;/code> 算法的 &lt;code>ZAB&lt;/code> 协议完成的。其主要功能包括：配置维护、分布式同步、集群管理等。&lt;/p>
&lt;p>简单来说， &lt;code>ZooKeeper&lt;/code> 是一个 &lt;strong>分布式协调服务框架&lt;/strong> 。分布式？协调服务？这啥玩意？🤔🤔&lt;/p>
&lt;p>其实解释到分布式这个概念的时候，我发现有些同学并不是能把 &lt;strong>分布式和集群&lt;/strong> 这两个概念很好的理解透。前段时间有同学和我探讨起分布式的东西，他说分布式不就是加机器吗？一台机器不够用再加一台抗压呗。当然加机器这种说法也无可厚非，你一个分布式系统必定涉及到多个机器，但是你别忘了，计算机学科中还有一个相似的概念—— &lt;code>Cluster&lt;/code> ，集群不也是加机器吗？但是 集群 和 分布式 其实就是两个完全不同的概念。&lt;/p>
&lt;p>比如，我现在有一个秒杀服务，并发量太大单机系统承受不住，那我加几台服务器也 &lt;strong>一样&lt;/strong> 提供秒杀服务，这个时候就是 &lt;strong>&lt;code>Cluster&lt;/code> 集群&lt;/strong> 。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/60263e969b9e4a0f81724b1f4d5b3d58~tplv-k3u1fbpfcp-zoom-1.jpeg" alt="cluster" />&lt;/p>
&lt;p>但是，我现在换一种方式，我将一个秒杀服务 &lt;strong>拆分成多个子服务&lt;/strong> ，比如创建订单服务，增加积分服务，扣优惠券服务等等，&lt;strong>然后我将这些子服务都部署在不同的服务器上&lt;/strong> ，这个时候就是 &lt;strong>&lt;code>Distributed&lt;/code> 分布式&lt;/strong> 。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/0d42e7b4249144b3a77a0c519216ae3d~tplv-k3u1fbpfcp-zoom-1.jpeg" alt="distributed" />&lt;/p>
&lt;p>而我为什么反驳同学所说的分布式就是加机器呢？因为我认为加机器更加适用于构建集群，因为它真是只有加机器。而对于分布式来说，你首先需要将业务进行拆分，然后再加机器（不仅仅是加机器那么简单），同时你还要去解决分布式带来的一系列问题。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/e3662ca1a09c4444b07f15dbf85c6ba8~tplv-k3u1fbpfcp-zoom-1.jpeg" alt="" />&lt;/p>
&lt;p>比如各个分布式组件如何协调起来，如何减少各个系统之间的耦合度，分布式事务的处理，如何去配置整个分布式系统等等。&lt;code>ZooKeeper&lt;/code> 主要就是解决这些问题的。&lt;/p>
&lt;h2 id="一致性问题">
 一致性问题
 &lt;a class="anchor" href="#%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;p>设计一个分布式系统必定会遇到一个问题—— &lt;strong>因为分区容忍性（partition tolerance）的存在，就必定要求我们需要在系统可用性（availability）和数据一致性（consistency）中做出权衡&lt;/strong> 。这就是著名的 &lt;code>CAP&lt;/code> 定理。&lt;/p>
&lt;p>理解起来其实很简单，比如说把一个班级作为整个系统，而学生是系统中的一个个独立的子系统。这个时候班里的小红小明偷偷谈恋爱被班里的大嘴巴小花发现了，小花欣喜若狂告诉了周围的人，然后小红小明谈恋爱的消息在班级里传播起来了。当在消息的传播（散布）过程中，你抓到一个同学问他们的情况，如果回答你不知道，那么说明整个班级系统出现了数据不一致的问题（因为小花已经知道这个消息了）。而如果他直接不回答你，因为整个班级有消息在进行传播（为了保证一致性，需要所有人都知道才可提供服务），这个时候就出现了系统的可用性问题。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/38b9ff4b193e4487afe32c9710c6d644~tplv-k3u1fbpfcp-zoom-1-20230717160254318-20230717160259975.jpeg" alt="" />&lt;/p>
&lt;p>而上述前者就是 &lt;code>Eureka&lt;/code> 的处理方式，它保证了 AP（可用性），后者就是我们今天所要讲的 &lt;code>ZooKeeper&lt;/code> 的处理方式，它保证了 CP（数据一致性）。&lt;/p></description></item><item><title>ZooKeeper相关概念总结(入门)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro/</guid><description>&lt;p>相信大家对 ZooKeeper 应该不算陌生。但是你真的了解 ZooKeeper 到底有啥用不？如果别人/面试官让你给他讲讲对于 ZooKeeper 的认识，你能回答到什么地步呢？&lt;/p>
&lt;p>拿我自己来说吧！我本人在大学曾经使用 Dubbo 来做分布式项目的时候，使用了 ZooKeeper 作为注册中心。为了保证分布式系统能够同步访问某个资源，我还使用 ZooKeeper 做过分布式锁。另外，我在学习 Kafka 的时候，知道 Kafka 很多功能的实现依赖了 ZooKeeper。&lt;/p>
&lt;p>前几天，总结项目经验的时候，我突然问自己 ZooKeeper 到底是个什么东西？想了半天，脑海中只是简单的能浮现出几句话：&lt;/p>
&lt;ol>
&lt;li>ZooKeeper 可以被用作注册中心、分布式锁；&lt;/li>
&lt;li>ZooKeeper 是 Hadoop 生态系统的一员；&lt;/li>
&lt;li>构建 ZooKeeper 集群的时候，使用的服务器最好是奇数台。&lt;/li>
&lt;/ol>
&lt;p>由此可见，我对于 ZooKeeper 的理解仅仅是停留在了表面。&lt;/p>
&lt;p>所以，通过本文，希望带大家稍微详细的了解一下 ZooKeeper 。如果没有学过 ZooKeeper ，那么本文将会是你进入 ZooKeeper 大门的垫脚砖。如果你已经接触过 ZooKeeper ，那么本文将带你回顾一下 ZooKeeper 的一些基础概念。&lt;/p>
&lt;p>另外，本文不光会涉及到 ZooKeeper 的一些概念，后面的文章会介绍到 ZooKeeper 常见命令的使用以及使用 Apache Curator 作为 ZooKeeper 的客户端。&lt;/p>
&lt;p>&lt;em>如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！&lt;/em>&lt;/p>
&lt;h2 id="zookeeper-介绍">
 ZooKeeper 介绍
 &lt;a class="anchor" href="#zookeeper-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;h3 id="zookeeper-由来">
 ZooKeeper 由来
 &lt;a class="anchor" href="#zookeeper-%e7%94%b1%e6%9d%a5">#&lt;/a>
&lt;/h3>
&lt;p>正式介绍 ZooKeeper 之前，我们先来看看 ZooKeeper 的由来，还挺有意思的。&lt;/p>
&lt;p>下面这段内容摘自《从 Paxos 到 ZooKeeper》第四章第一节，推荐大家阅读一下：&lt;/p></description></item><item><title>阿里技术面试的一些秘密</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/some-secrets-about-alibaba-interview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/some-secrets-about-alibaba-interview/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：详细介绍了求职者在面试中应该具备哪些能力才会有更大概率脱颖而出。&lt;/p>
&lt;p>&lt;strong>原文地址：&lt;/strong> &lt;a href="https://mp.weixin.qq.com/s/M2M808PwQ2JcMqfLQfXQMw">https://mp.weixin.qq.com/s/M2M808PwQ2JcMqfLQfXQMw&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>最近我的工作稍微轻松些，就被安排去校招面试了&lt;/p>
&lt;p>当时还是有些&lt;strong>激动&lt;/strong>的，以前都是被面试的，现在我自己也成为一个面试别人的面试官&lt;/p>
&lt;p>接下来就谈谈我的面试心得(谈谈阿里面试的秘籍)&lt;/p>
&lt;h2 id="我是怎么筛选简历的">
 我是怎么筛选简历的？
 &lt;a class="anchor" href="#%e6%88%91%e6%98%af%e6%80%8e%e4%b9%88%e7%ad%9b%e9%80%89%e7%ae%80%e5%8e%86%e7%9a%84">#&lt;/a>
&lt;/h2>
&lt;p>面试之前都是要筛选简历，这个大家应该知道&lt;/p>
&lt;p>阿里对待招聘非常负责任，面试官必须对每位同学的简历进行查看和筛选，如果不合适还需要写清楚理由&lt;/p>
&lt;p>对于校招生来说，第一份工作非常重要，而且校招的面试机会也只有一次，一旦收到大家的简历意味着大家非常认可和喜爱阿里这家公司&lt;/p>
&lt;p>所以我们对每份简历都会认真看，大家可以非常放心，不会无缘无故挂掉大家的简历&lt;/p>
&lt;p>尽管我们报以非常负责任的态度，但有些同学们的简历实在是难以下看&lt;/p>
&lt;p>关于如何写简历，我之前写过类似的文章，这里就把之前的文章放这里让大家看看 &lt;a href="https://mp.weixin.qq.com/s?__biz=MzI4MDYzNDc1Mg==&amp;amp;mid=2247484010&amp;amp;idx=1&amp;amp;sn=afbe90c8446f5f21631cae750431d3ee&amp;amp;scene=21#wechat_redirect">一份好的简历应该有哪些内容&lt;/a>&lt;/p>
&lt;p>在筛选简历的时候会有以下信息非常重要，大家一定要认真写&lt;/p>
&lt;ul>
&lt;li>&lt;strong>项目经历&lt;/strong>，具体写法可以看上面提到的文章&lt;/li>
&lt;li>&lt;strong>个人含金量比较高的奖项&lt;/strong>，比如 ACM 奖牌、计算机竞赛等&lt;/li>
&lt;li>&lt;strong>个人技能&lt;/strong> 这块会看，但是大多数简历写法都差不多，尽量写得&lt;strong>言简意赅&lt;/strong>&lt;/li>
&lt;li>&lt;strong>重要期刊论文发表、开源项目&lt;/strong> 加分项&lt;/li>
&lt;/ul>
&lt;p>这些信息非常重要，我筛选简历的时候这些信息占整份简历的比重 4/5 左右&lt;/p>
&lt;h2 id="面试的时候我会注重哪些方面">
 面试的时候我会注重哪些方面？
 &lt;a class="anchor" href="#%e9%9d%a2%e8%af%95%e7%9a%84%e6%97%b6%e5%80%99%e6%88%91%e4%bc%9a%e6%b3%a8%e9%87%8d%e5%93%aa%e4%ba%9b%e6%96%b9%e9%9d%a2">#&lt;/a>
&lt;/h2>
&lt;h3 id="表达要清楚">
 &lt;strong>表达要清楚&lt;/strong>
 &lt;a class="anchor" href="#%e8%a1%a8%e8%be%be%e8%a6%81%e6%b8%85%e6%a5%9a">#&lt;/a>
&lt;/h3>
&lt;p>这点是硬伤，在面试的时候有些同学半天说不清楚自己做的项目，我都在替你着急&lt;/p>
&lt;p>描述项目有个简单的方法论，我自己总结的 大家看看适不适合自己&lt;/p>
&lt;ul>
&lt;li>最好言简意赅的描述一下你的项目背景，让面试官很快知道项目干了啥(让面试官很快对项目感兴趣)&lt;/li>
&lt;li>说下项目用了哪些技术，做技术的用了哪些技术得说清楚，面试官会对你的技术比较感兴趣&lt;/li>
&lt;li>解决了什么问题，做项目肯定是为了解决问题，总不能为了做项目而做项目吧(解决问题的能力非常重要)&lt;/li>
&lt;li>遇到哪些难题，如何突破这些难题，项目遇到困难问题很正常，突破困难才是一次好的成长&lt;/li>
&lt;li>项目还有哪些完善的地方，不可能设计出完美的执行方案，有待改进说明你对项目认识深刻，思考深入&lt;/li>
&lt;/ul>
&lt;p>一场面试时间一般 60—80 分钟，好的表达有助于彼此之间了解更多的问题&lt;/p>
&lt;h3 id="基础知识要扎实">
 &lt;strong>基础知识要扎实&lt;/strong>
 &lt;a class="anchor" href="#%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86%e8%a6%81%e6%89%8e%e5%ae%9e">#&lt;/a>
&lt;/h3>
&lt;p>校招非常注重基础知识，所以这块问的问题比较多，我一般会结合你项目去问，看看同学对技术是停留在用的阶段还是有自己的深入思考&lt;/p>
&lt;p>每个方向对基础知识要求不同，但有些基础知识是通用的&lt;/p>
&lt;p>比如&lt;strong>数据结构与算法&lt;/strong>、&lt;strong>操作系统&lt;/strong>、&lt;strong>计算机网络&lt;/strong> 等&lt;/p>
&lt;p>这些基础技术知识一定要掌握扎实，技术岗位都会或多或少去问这些基础&lt;/p>
&lt;h3 id="动手能力很重要">
 &lt;strong>动手能力很重要&lt;/strong>
 &lt;a class="anchor" href="#%e5%8a%a8%e6%89%8b%e8%83%bd%e5%8a%9b%e5%be%88%e9%87%8d%e8%a6%81">#&lt;/a>
&lt;/h3>
&lt;p>action，action，action ，重要的事情说三遍，做技术的不可能光靠一张嘴，能落地才是最重要的&lt;/p>
&lt;p>面试官除了问你基础知识和项目还会去考考你的动手能力，面试时间一般不会太长，根据岗位的不同一般会让同学们写一些算法题目&lt;/p>
&lt;p>阿里面试，不会给你出非常变态的算法题目&lt;/p>
&lt;p>主要还是考察大家的动手能力、思考问题的能力、数据结构的应用能力&lt;/p>
&lt;p>在写代码的过程中，我也总结了自己的方法论：&lt;/p>
&lt;ul>
&lt;li>上来不要先写，审题、问清楚题目意图，不要自以为是的去理解思路，工作中 沟通需求、明确需求、提出质疑和建议是非常好的习惯&lt;/li>
&lt;li>接下来说思路 思路错了写到一半再去改会非常浪费时间&lt;/li>
&lt;li>描述清楚之后，先写代码思路的步骤注释，一边写注释，脑子里迭代一遍自己的思路是否正确，是否是最优解&lt;/li>
&lt;li>最后，代码规范&lt;/li>
&lt;/ul>
&lt;h2 id="除了上面这些常规的方面">
 除了上面这些常规的方面
 &lt;a class="anchor" href="#%e9%99%a4%e4%ba%86%e4%b8%8a%e9%9d%a2%e8%bf%99%e4%ba%9b%e5%b8%b8%e8%a7%84%e7%9a%84%e6%96%b9%e9%9d%a2">#&lt;/a>
&lt;/h2>
&lt;p>其实，现在面试已经非常&lt;strong>卷&lt;/strong>了，上面说的这些很多都是 &lt;strong>八股文&lt;/strong>&lt;/p></description></item><item><title>布隆过滤器</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/data-structure/bloom-filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/data-structure/bloom-filter/</guid><description>&lt;p>布隆过滤器相信大家没用过的话，也已经听过了。&lt;/p>
&lt;p>布隆过滤器主要是为了解决海量数据的存在性问题。对于海量数据中判定某个数据是否存在且容忍轻微误差这一场景（比如缓存穿透、海量数据去重）来说，非常适合。&lt;/p>
&lt;p>文章内容概览：&lt;/p>
&lt;ol>
&lt;li>什么是布隆过滤器？&lt;/li>
&lt;li>布隆过滤器的原理介绍。&lt;/li>
&lt;li>布隆过滤器使用场景。&lt;/li>
&lt;li>通过 Java 编程手动实现布隆过滤器。&lt;/li>
&lt;li>利用 Google 开源的 Guava 中自带的布隆过滤器。&lt;/li>
&lt;li>Redis 中的布隆过滤器。&lt;/li>
&lt;/ol>
&lt;h2 id="什么是布隆过滤器">
 什么是布隆过滤器？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8">#&lt;/a>
&lt;/h2>
&lt;p>首先，我们需要了解布隆过滤器的概念。&lt;/p>
&lt;p>布隆过滤器（Bloom Filter，BF）是一个叫做 Bloom 的老哥于 1970 年提出的。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的 List、Map、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。&lt;/p>
&lt;p>Bloom Filter 会使用一个较大的 bit 数组来保存所有的数据，数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1（代表 false 或者 true），这也是 Bloom Filter 节省内存的核心所在。这样来算的话，申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 KB ≈ 122KB 的空间。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/bloom-filter-bit-table.png" alt="位数组" />&lt;/p>
&lt;p>总结：&lt;strong>一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。&lt;/strong>&lt;/p>
&lt;h2 id="布隆过滤器的原理介绍">
 布隆过滤器的原理介绍
 &lt;a class="anchor" href="#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8%e7%9a%84%e5%8e%9f%e7%90%86%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。&lt;/li>
&lt;li>根据得到的哈希值，在位数组中把对应下标的值置为 1。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：&lt;/strong>&lt;/p></description></item><item><title>操作系统常见面试题总结(上)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-01/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-01/</guid><description>&lt;p>很多读者抱怨计算操作系统的知识点比较繁杂，自己也没有多少耐心去看，但是面试的时候又经常会遇到。所以，我带着我整理好的操作系统的常见问题来啦！这篇文章总结了一些我觉得比较重要的操作系统相关的问题比如 &lt;strong>用户态和内核态、系统调用、进程和线程、死锁、内存管理、虚拟内存、文件系统&lt;/strong>等等。&lt;/p>
&lt;p>这篇文章只是对一些操作系统比较重要概念的一个概览，深入学习的话，建议大家还是老老实实地去看书。另外， 这篇文章的很多内容参考了《现代操作系统》第三版这本书，非常感谢。&lt;/p>
&lt;p>开始本文的内容之前，我们先聊聊为什么要学习操作系统。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>从对个人能力方面提升来说&lt;/strong>：操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。比如说我们开发的系统使用的缓存（比如 Redis）和操作系统的高速缓存就很像。CPU 中的高速缓存有很多种，不过大部分都是为了解决 CPU 处理速度和内存处理速度不对等的问题。我们还可以把内存看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。同样地，我们使用的 Redis 缓存就是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。高速缓存一般会按照局部性原理（2-8 原则）根据相应的淘汰算法保证缓存中的数据是经常会被访问的。我们平常使用的 Redis 缓存很多时候也会按照 2-8 原则去做，很多淘汰算法都和操作系统中的类似。既说了 2-8 原则，那就不得不提命中率了，这是所有缓存概念都通用的。简单来说也就是你要访问的数据有多少能直接在缓存中直接找到。命中率高的话，一般表明你的缓存设计比较合理，系统处理速度也相对较快。&lt;/li>
&lt;li>&lt;strong>从面试角度来说&lt;/strong>：尤其是校招，对于操作系统方面知识的考察是非常非常多的。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>简单来说，学习操作系统能够提高自己思考的深度以及对技术的理解力，并且，操作系统方面的知识也是面试必备。&lt;/strong>&lt;/p>
&lt;h2 id="操作系统基础">
 操作系统基础
 &lt;a class="anchor" href="#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="https://oss.javaguide.cn/2020-8/image-20200807161118901.png" alt="" />&lt;/p>
&lt;h3 id="什么是操作系统">
 什么是操作系统？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f">#&lt;/a>
&lt;/h3>
&lt;p>通过以下四点可以概括操作系统到底是什么：&lt;/p>
&lt;ol>
&lt;li>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。&lt;/li>
&lt;li>操作系统本质上是一个运行在计算机上的软件程序 ，主要用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。&lt;/li>
&lt;li>操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。&lt;/li>
&lt;li>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。&lt;/li>
&lt;/ol>
&lt;p>很多人容易把操作系统的内核（Kernel）和中央处理器（CPU，Central Processing Unit）弄混。你可以简单从下面两点来区别：&lt;/p>
&lt;ol>
&lt;li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。&lt;/li>
&lt;li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。&lt;/li>
&lt;/ol>
&lt;p>下图清晰说明了应用程序、内核、CPU 这三者的关系。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/2020-8/Kernel_Layout.png" alt="Kernel_Layout" />&lt;/p>
&lt;h3 id="操作系统主要有哪些功能">
 操作系统主要有哪些功能？
 &lt;a class="anchor" href="#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e4%b8%bb%e8%a6%81%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8a%9f%e8%83%bd">#&lt;/a>
&lt;/h3>
&lt;p>从资源管理的角度来看，操作系统有 6 大功能：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>进程和线程的管理&lt;/strong>：进程的创建、撤销、阻塞、唤醒，进程间的通信等。&lt;/li>
&lt;li>&lt;strong>存储管理&lt;/strong>：内存的分配和管理、外存（磁盘等）的分配和管理等。&lt;/li>
&lt;li>&lt;strong>文件管理&lt;/strong>：文件的读、写、创建及删除等。&lt;/li>
&lt;li>&lt;strong>设备管理&lt;/strong>：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。&lt;/li>
&lt;li>&lt;strong>网络管理&lt;/strong>：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。&lt;/li>
&lt;li>&lt;strong>安全管理&lt;/strong>：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。&lt;/li>
&lt;/ol>
&lt;h3 id="常见的操作系统有哪些">
 常见的操作系统有哪些？
 &lt;a class="anchor" href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%9c%89%e5%93%aa%e4%ba%9b">#&lt;/a>
&lt;/h3>
&lt;h4 id="windows">
 Windows
 &lt;a class="anchor" href="#windows">#&lt;/a>
&lt;/h4>
&lt;p>目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。界面简单易操作，软件生态非常好。&lt;/p></description></item><item><title>操作系统常见面试题总结(下)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/operating-system/operating-system-basic-questions-02/</guid><description>&lt;h2 id="内存管理">
 内存管理
 &lt;a class="anchor" href="#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86">#&lt;/a>
&lt;/h2>
&lt;h3 id="内存管理主要做了什么">
 内存管理主要做了什么？
 &lt;a class="anchor" href="#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e4%b8%bb%e8%a6%81%e5%81%9a%e4%ba%86%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/memory-management-roles.png" alt="内存管理主要做的事情" />&lt;/p>
&lt;p>操作系统的内存管理非常重要，主要负责下面这些事情：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>内存的分配与回收&lt;/strong>：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。&lt;/li>
&lt;li>&lt;strong>地址转换&lt;/strong>：将程序中的虚拟地址转换成内存中的物理地址。&lt;/li>
&lt;li>&lt;strong>内存扩充&lt;/strong>：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。&lt;/li>
&lt;li>&lt;strong>内存映射&lt;/strong>：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。&lt;/li>
&lt;li>&lt;strong>内存优化&lt;/strong>：通过调整内存分配策略和回收算法来优化内存使用效率。&lt;/li>
&lt;li>&lt;strong>内存安全&lt;/strong>：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;h3 id="什么是内存碎片">
 什么是内存碎片？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87">#&lt;/a>
&lt;/h3>
&lt;p>内存碎片是由内存的申请和释放产生的，通常分为下面两种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>内部内存碎片(Internal Memory Fragmentation，简称为内存碎片)&lt;/strong>：已经分配给进程使用但未被使用的内存。导致内部内存碎片的主要原因是，当采用固定比例比如 2 的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。举个例子，一个进程只需要 65 字节的内存，但为其分配了 128（2^7） 大小的内存，那 63 字节的内存就成为了内部内存碎片。&lt;/li>
&lt;li>&lt;strong>外部内存碎片(External Memory Fragmentation，简称为外部碎片)&lt;/strong>：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片。也就是说，外部内存碎片指的是那些并未分配给进程但又不能使用的内存。我们后面介绍的分段机制就会导致外部内存碎片。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/internal-and-external-fragmentation.png" alt="内存碎片" />&lt;/p>
&lt;p>内存碎片会导致内存利用率下降，如何减少内存碎片是内存管理要非常重视的一件事情。&lt;/p>
&lt;h3 id="常见的内存管理方式有哪些">
 常见的内存管理方式有哪些？
 &lt;a class="anchor" href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b">#&lt;/a>
&lt;/h3>
&lt;p>内存管理方式可以简单分为下面两种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>连续内存管理&lt;/strong>：为一个用户程序分配一个连续的内存空间，内存利用率一般不高。&lt;/li>
&lt;li>&lt;strong>非连续内存管理&lt;/strong>：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对更加灵活一些。&lt;/li>
&lt;/ul>
&lt;h4 id="连续内存管理">
 连续内存管理
 &lt;a class="anchor" href="#%e8%bf%9e%e7%bb%ad%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86">#&lt;/a>
&lt;/h4>
&lt;p>&lt;strong>块式管理&lt;/strong> 是早期计算机操作系统的一种连续内存管理方式，存在严重的内存碎片问题。块式管理会将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为内部内存碎片。除了内部内存碎片之外，由于两个内存块之间可能还会有外部内存碎片，这些不连续的外部内存碎片由于太小了无法再进行分配。&lt;/p>
&lt;p>在 Linux 系统中，连续内存管理采用了 &lt;strong>伙伴系统（Buddy System）算法&lt;/strong> 来实现，这是一种经典的连续内存分配算法，可以有效解决外部内存碎片的问题。伙伴系统的主要思想是将内存按 2 的幂次划分（每一块内存大小都是 2 的幂次比如 2^6=64 KB），并将相邻的内存块组合成一对伙伴（注意：&lt;strong>必须是相邻的才是伙伴&lt;/strong>）。&lt;/p>
&lt;p>当进行内存分配时，伙伴系统会尝试找到大小最合适的内存块。如果找到的内存块过大，就将其一分为二，分成两个大小相等的伙伴块。如果还是大的话，就继续切分，直到到达合适的大小为止。&lt;/p>
&lt;p>假设两块相邻的内存块都被释放，系统会将这两个内存块合并，进而形成一个更大的内存块，以便后续的内存分配。这样就可以减少内存碎片的问题，提高内存利用率。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/linux-buddy-system.png" alt="伙伴系统（Buddy System）内存管理" />&lt;/p>
&lt;p>虽然解决了外部内存碎片的问题，但伙伴系统仍然存在内存利用率不高的问题（内部内存碎片）。这主要是因为伙伴系统只能分配大小为 2^n 的内存块，因此当需要分配的内存大小不是 2^n 的整数倍时，会浪费一定的内存空间。举个例子：如果要分配 65 大小的内存快，依然需要分配 2^7=128 大小的内存块。&lt;/p></description></item><item><title>常见SQL优化手段总结（付费）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/sql-optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/sql-optimization/</guid><description>&lt;p>&lt;strong>常见 SQL 优化手段总结&lt;/strong> 相关的内容为我的&lt;a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了&lt;a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》&lt;/a>中。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/javamianshizhibei/sql-optimization.png" alt="" />&lt;/p></description></item><item><title>常见加密算法总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/encryption-algorithms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/encryption-algorithms/</guid><description>&lt;p>加密算法是一种用数学方法对数据进行变换的技术，目的是保护数据的安全，防止被未经授权的人读取或修改。加密算法可以分为三大类：对称加密算法、非对称加密算法和哈希算法（也叫摘要算法）。&lt;/p>
&lt;p>日常开发中常见的需要用到加密算法的场景：&lt;/p>
&lt;ol>
&lt;li>保存在数据库中的密码需要加盐之后使用哈希算法（比如 BCrypt）进行加密。&lt;/li>
&lt;li>保存在数据库中的银行卡号、身份号这类敏感数据需要使用对称加密算法（比如 AES）保存。&lt;/li>
&lt;li>网络传输的敏感数据比如银行卡号、身份号需要用 HTTPS + 非对称加密算法（如 RSA）来保证传输数据的安全性。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ol>
&lt;p>ps: 严格上来说，哈希算法其实不属于加密算法，只是可以用到某些加密场景中（例如密码加密），两者可以看作是并列关系。加密算法通常指的是可以将明文转换为密文，并且能够通过某种方式（如密钥）再将密文还原为明文的算法。而哈希算法是一种单向过程，它将输入信息转换成一个固定长度的、看似随机的哈希值，但这个过程是不可逆的，也就是说，不能从哈希值还原出原始信息。&lt;/p>
&lt;h2 id="哈希算法">
 哈希算法
 &lt;a class="anchor" href="#%e5%93%88%e5%b8%8c%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;p>哈希算法也叫散列函数或摘要算法，它的作用是对任意长度的数据生成一个固定长度的唯一标识，也叫哈希值、散列值或消息摘要（后文统称为哈希值）。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/security/encryption-algorithms/hash-function-effect-demonstration.png" alt="哈希算法效果演示" />&lt;/p>
&lt;p>哈希算法的是不可逆的，你无法通过哈希之后的值再得到原值。&lt;/p>
&lt;p>哈希值的作用是可以用来验证数据的完整性和一致性。&lt;/p>
&lt;p>举两个实际的例子：&lt;/p>
&lt;ul>
&lt;li>保存密码到数据库时使用哈希算法进行加密，可以通过比较用户输入密码的哈希值和数据库保存的哈希值是否一致，来判断密码是否正确。&lt;/li>
&lt;li>我们下载一个文件时，可以通过比较文件的哈希值和官方提供的哈希值是否一致，来判断文件是否被篡改或损坏；&lt;/li>
&lt;/ul>
&lt;p>这种算法的特点是不可逆：&lt;/p>
&lt;ul>
&lt;li>不能从哈希值还原出原始数据。&lt;/li>
&lt;li>原始数据的任何改变都会导致哈希值的巨大变化。&lt;/li>
&lt;/ul>
&lt;p>哈希算法可以简单分为两类：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>加密哈希算法&lt;/strong>：安全性较高的哈希算法，它可以提供一定的数据完整性保护和数据防篡改能力，能够抵御一定的攻击手段，安全性相对较高，但性能较差，适用于对安全性要求较高的场景。例如 SHA2、SHA3、SM3、RIPEMD-160、BLAKE2、SipHash 等等。&lt;/li>
&lt;li>&lt;strong>非加密哈希算法&lt;/strong>：安全性相对较低的哈希算法，易受到暴力破解、冲突攻击等攻击手段的影响，但性能较高，适用于对安全性没有要求的业务场景。例如 CRC32、MurMurHash3、SipHash 等等。&lt;/li>
&lt;/ol>
&lt;p>除了这两种之外，还有一些特殊的哈希算法，例如安全性更高的&lt;strong>慢哈希算法&lt;/strong>。&lt;/p>
&lt;p>常见的哈希算法有：&lt;/p>
&lt;ul>
&lt;li>MD（Message Digest，消息摘要算法）：MD2、MD4、MD5 等，已经不被推荐使用。&lt;/li>
&lt;li>SHA（Secure Hash Algorithm，安全哈希算法）：SHA-1 系列安全性低，SHA2，SHA3 系列安全性较高。&lt;/li>
&lt;li>国密算法：例如 SM2、SM3、SM4，其中 SM2 为非对称加密算法，SM4 为对称加密算法，SM3 为哈希算法（安全性及效率和 SHA-256 相当，但更适合国内的应用环境）。&lt;/li>
&lt;li>Bcrypt（密码哈希算法）：基于 Blowfish 加密算法的密码哈希算法，专门为密码加密而设计，安全性高，属于慢哈希算法。&lt;/li>
&lt;li>MAC（Message Authentication Code，消息认证码算法）：HMAC 是一种基于哈希的 MAC，可以与任何安全的哈希算法结合使用，例如 SHA-256。&lt;/li>
&lt;li>CRC：（Cyclic Redundancy Check，循环冗余校验）：CRC32 是一种 CRC 算法，它的特点是生成 32 位的校验值，通常用于数据完整性校验、文件校验等场景。&lt;/li>
&lt;li>SipHash：加密哈希算法，它的设计目的是在速度和安全性之间达到一个平衡，用于防御&lt;a href="https://aumasson.jp/siphash/siphashdos_29c3_slides.pdf">哈希泛洪 DoS 攻击&lt;/a>。Rust 默认使用 SipHash 作为哈希算法，从 Redis4.0 开始，哈希算法被替换为 SipHash。&lt;/li>
&lt;li>MurMurHash：经典快速的非加密哈希算法，目前最新的版本是 MurMurHash3，可以生成 32 位或者 128 位哈希值；&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;p>哈希算法一般是不需要密钥的，但也存在部分特殊哈希算法需要密钥。例如，MAC 和 SipHash 就是一种基于密钥的哈希算法，它在哈希算法的基础上增加了一个密钥，使得只有知道密钥的人才能验证数据的完整性和来源。&lt;/p></description></item><item><title>常见数据结构经典LeetCode题目推荐</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/common-data-structures-leetcode-recommendations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/common-data-structures-leetcode-recommendations/</guid><description>&lt;h2 id="数组">
 数组
 &lt;a class="anchor" href="#%e6%95%b0%e7%bb%84">#&lt;/a>
&lt;/h2>
&lt;p>704.二分查找：&lt;a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/&lt;/a>&lt;/p>
&lt;p>80.删除有序数组中的重复项 II：&lt;a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii">https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii&lt;/a>&lt;/p>
&lt;p>977.有序数组的平方：&lt;a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">https://leetcode.cn/problems/squares-of-a-sorted-array/&lt;/a>&lt;/p>
&lt;h2 id="链表">
 链表
 &lt;a class="anchor" href="#%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h2>
&lt;p>707.设计链表：&lt;a href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/&lt;/a>&lt;/p>
&lt;p>206.反转链表：&lt;a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/&lt;/a>&lt;/p>
&lt;p>92.反转链表 II：&lt;a href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/&lt;/a>&lt;/p>
&lt;p>61.旋转链表：&lt;a href="https://leetcode.cn/problems/rotate-list/">https://leetcode.cn/problems/rotate-list/&lt;/a>&lt;/p>
&lt;h2 id="栈与队列">
 栈与队列
 &lt;a class="anchor" href="#%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97">#&lt;/a>
&lt;/h2>
&lt;p>232.用栈实现队列：&lt;a href="https://leetcode.cn/problems/implement-queue-using-stacks/">https://leetcode.cn/problems/implement-queue-using-stacks/&lt;/a>&lt;/p>
&lt;p>225.用队列实现栈：&lt;a href="https://leetcode.cn/problems/implement-stack-using-queues/">https://leetcode.cn/problems/implement-stack-using-queues/&lt;/a>&lt;/p>
&lt;p>347.前 K 个高频元素：&lt;a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/&lt;/a>&lt;/p>
&lt;p>239.滑动窗口最大值：&lt;a href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/&lt;/a>&lt;/p>
&lt;h2 id="二叉树">
 二叉树
 &lt;a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91">#&lt;/a>
&lt;/h2>
&lt;p>105.从前序与中序遍历构造二叉树：&lt;a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&lt;/a>&lt;/p>
&lt;p>117.填充每个节点的下一个右侧节点指针 II：&lt;a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii&lt;/a>&lt;/p>
&lt;p>236.二叉树的最近公共祖先：&lt;a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/&lt;/a>&lt;/p>
&lt;p>129.求根节点到叶节点数字之和：&lt;a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">https://leetcode.cn/problems/sum-root-to-leaf-numbers/&lt;/a>&lt;/p>
&lt;p>102.二叉树的层序遍历：&lt;a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/&lt;/a>&lt;/p>
&lt;p>530.二叉搜索树的最小绝对差：&lt;a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">https://leetcode.cn/problems/minimum-absolute-difference-in-bst/&lt;/a>&lt;/p>
&lt;h2 id="图">
 图
 &lt;a class="anchor" href="#%e5%9b%be">#&lt;/a>
&lt;/h2>
&lt;p>200.岛屿数量：&lt;a href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/&lt;/a>&lt;/p>
&lt;p>207.课程表：&lt;a href="https://leetcode.cn/problems/course-schedule/">https://leetcode.cn/problems/course-schedule/&lt;/a>&lt;/p>
&lt;p>210.课程表 II：&lt;a href="https://leetcode.cn/problems/course-schedule-ii/">https://leetcode.cn/problems/course-schedule-ii/&lt;/a>&lt;/p>
&lt;h2 id="堆">
 堆
 &lt;a class="anchor" href="#%e5%a0%86">#&lt;/a>
&lt;/h2>
&lt;p>215.数组中的第 K 个最大元素:&lt;a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/&lt;/a>&lt;/p>
&lt;p>216.数据流的中位数:&lt;a href="https://leetcode.cn/problems/find-median-from-data-stream/">https://leetcode.cn/problems/find-median-from-data-stream/&lt;/a>&lt;/p>
&lt;p>217.前 K 个高频元素：&lt;a href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/&lt;/a>&lt;/p></description></item><item><title>超时&amp;重试详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-availability/timeout-and-retry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-availability/timeout-and-retry/</guid><description>&lt;p>由于网络问题、系统或者服务内部的 Bug、服务器宕机、操作系统崩溃等问题的不确定性，我们的系统或者服务永远不可能保证时刻都是可用的状态。&lt;/p>
&lt;p>为了最大限度的减小系统或者服务出现故障之后带来的影响，我们需要用到的 &lt;strong>超时（Timeout）&lt;/strong> 和 &lt;strong>重试（Retry）&lt;/strong> 机制。&lt;/p>
&lt;p>想要把超时和重试机制讲清楚其实很简单，因为它俩本身就不是什么高深的概念。&lt;/p>
&lt;p>虽然超时和重试机制的思想很简单，但是它俩是真的非常实用。你平时接触到的绝大部分涉及到远程调用的系统或者服务都会应用超时和重试机制。尤其是对于微服务系统来说，正确设置超时和重试非常重要。单体服务通常只涉及数据库、缓存、第三方 API、中间件等的网络调用，而微服务系统内部各个服务之间还存在着网络调用。&lt;/p>
&lt;h2 id="超时机制">
 超时机制
 &lt;a class="anchor" href="#%e8%b6%85%e6%97%b6%e6%9c%ba%e5%88%b6">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是超时机制">
 什么是超时机制？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%b6%85%e6%97%b6%e6%9c%ba%e5%88%b6">#&lt;/a>
&lt;/h3>
&lt;p>超时机制说的是当一个请求超过指定的时间（比如 1s）还没有被处理的话，这个请求就会直接被取消并抛出指定的异常或者错误（比如 &lt;code>504 Gateway Timeout&lt;/code>）。&lt;/p>
&lt;p>我们平时接触到的超时可以简单分为下面 2 种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>连接超时（ConnectTimeout）&lt;/strong>：客户端与服务端建立连接的最长等待时间。&lt;/li>
&lt;li>&lt;strong>读取超时（ReadTimeout）&lt;/strong>：客户端和服务端已经建立连接，客户端等待服务端处理完请求的最长时间。实际项目中，我们关注比较多的还是读取超时。&lt;/li>
&lt;/ul>
&lt;p>一些连接池客户端框架中可能还会有获取连接超时和空闲连接清理超时。&lt;/p>
&lt;p>如果没有设置超时的话，就可能会导致服务端连接数爆炸和大量请求堆积的问题。&lt;/p>
&lt;p>这些堆积的连接和请求会消耗系统资源，影响新收到的请求的处理。严重的情况下，甚至会拖垮整个系统或者服务。&lt;/p>
&lt;p>我之前在实际项目就遇到过类似的问题，整个网站无法正常处理请求，服务器负载直接快被拉满。后面发现原因是项目超时设置错误加上客户端请求处理异常，导致服务端连接数直接接近 40w+，这么多堆积的连接直接把系统干趴了。&lt;/p>
&lt;h3 id="超时时间应该如何设置">
 超时时间应该如何设置？
 &lt;a class="anchor" href="#%e8%b6%85%e6%97%b6%e6%97%b6%e9%97%b4%e5%ba%94%e8%af%a5%e5%a6%82%e4%bd%95%e8%ae%be%e7%bd%ae">#&lt;/a>
&lt;/h3>
&lt;p>超时到底设置多长时间是一个难题！超时值设置太高或者太低都有风险。如果设置太高的话，会降低超时机制的有效性，比如你设置超时为 10s 的话，那设置超时就没啥意义了，系统依然可能会出现大量慢请求堆积的问题。如果设置太低的话，就可能会导致在系统或者服务在某些处理请求速度变慢的情况下（比如请求突然增多），大量请求重试（超时通常会结合重试）继续加重系统或者服务的压力，进而导致整个系统或者服务被拖垮的问题。&lt;/p>
&lt;p>通常情况下，我们建议读取超时设置为 &lt;strong>1500ms&lt;/strong> ,这是一个比较普适的值。如果你的系统或者服务对于延迟比较敏感的话，那读取超时值可以适当在 &lt;strong>1500ms&lt;/strong> 的基础上进行缩短。反之，读取超时值也可以在 &lt;strong>1500ms&lt;/strong> 的基础上进行加长，不过，尽量还是不要超过 &lt;strong>1500ms&lt;/strong> 。连接超时可以适当设置长一些，建议在 &lt;strong>1000ms ~ 5000ms&lt;/strong> 之内。&lt;/p>
&lt;p>没有银弹！超时值具体该设置多大，还是要根据实际项目的需求和情况慢慢调整优化得到。&lt;/p>
&lt;p>更上一层，参考&lt;a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">美团的 Java 线程池参数动态配置&lt;/a>思想，我们也可以将超时弄成可配置化的参数而不是固定的，比较简单的一种办法就是将超时的值放在配置中心中。这样的话，我们就可以根据系统或者服务的状态动态调整超时值了。&lt;/p>
&lt;h2 id="重试机制">
 重试机制
 &lt;a class="anchor" href="#%e9%87%8d%e8%af%95%e6%9c%ba%e5%88%b6">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是重试机制">
 什么是重试机制？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e9%87%8d%e8%af%95%e6%9c%ba%e5%88%b6">#&lt;/a>
&lt;/h3>
&lt;p>重试机制一般配合超时机制一起使用，指的是多次发送相同的请求来避免瞬态故障和偶然性故障。&lt;/p>
&lt;p>瞬态故障可以简单理解为某一瞬间系统偶然出现的故障，并不会持久。偶然性故障可以理解为哪些在某些情况下偶尔出现的故障，频率通常较低。&lt;/p>
&lt;p>重试的核心思想是通过消耗服务器的资源来尽可能获得请求更大概率被成功处理。由于瞬态故障和偶然性故障是很少发生的，因此，重试对于服务器的资源消耗几乎是可以被忽略的。&lt;/p>
&lt;h3 id="常见的重试策略有哪些">
 常见的重试策略有哪些？
 &lt;a class="anchor" href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e9%87%8d%e8%af%95%e7%ad%96%e7%95%a5%e6%9c%89%e5%93%aa%e4%ba%9b">#&lt;/a>
&lt;/h3>
&lt;p>常见的重试策略有两种：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>固定间隔时间重试&lt;/strong>：每次重试之间都使用相同的时间间隔，比如每隔 1.5 秒进行一次重试。这种重试策略的优点是实现起来比较简单，不需要考虑重试次数和时间的关系，也不需要维护额外的状态信息。但是这种重试策略的缺点是可能会导致重试过于频繁或过于稀疏，从而影响系统的性能和效率。如果重试间隔太短，可能会对目标系统造成过大的压力，导致雪崩效应；如果重试间隔太长，可能会导致用户等待时间过长，影响用户体验。&lt;/li>
&lt;li>&lt;strong>梯度间隔重试&lt;/strong>：根据重试次数的增加去延长下次重试时间，比如第一次重试间隔为 1 秒，第二次为 2 秒，第三次为 4 秒，以此类推。这种重试策略的优点是能够有效提高重试成功的几率（随着重试次数增加，但是重试依然不成功，说明目标系统恢复时间比较长，因此可以根据重试次数延长下次重试时间），也能通过柔性化的重试避免对下游系统造成更大压力。但是这种重试策略的缺点是实现起来比较复杂，需要考虑重试次数和时间的关系，以及设置合理的上限和下限值。另外，这种重试策略也可能会导致用户等待时间过长，影响用户体验。&lt;/li>
&lt;/ol>
&lt;p>这两种适合的场景各不相同。固定间隔时间重试适用于目标系统恢复时间比较稳定和可预测的场景，比如网络波动或服务重启。梯度间隔重试适用于目标系统恢复时间比较长或不可预测的场景，比如网络故障和服务故障。&lt;/p></description></item><item><title>程序员的技术成长战略</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/the-growth-strategy-of-the-technological-giant/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：波波老师的一篇文章，写的非常好，不光是对技术成长有帮助，其他领域也是同样适用的！建议反复阅读，形成一套自己的技术成长策略。&lt;/p>
&lt;p>&lt;strong>原文地址：&lt;/strong> &lt;a href="https://mp.weixin.qq.com/s/YrN8T67s801-MRo01lCHXA">https://mp.weixin.qq.com/s/YrN8T67s801-MRo01lCHXA&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-前言">
 1. 前言
 &lt;a class="anchor" href="#1-%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>在波波的微信技术交流群里头，经常有学员问关于技术人该如何学习成长的问题，虽然是微信交流，但我依然可以感受到小伙伴们焦虑的心情。&lt;/p>
&lt;p>&lt;strong>技术人为啥焦虑？&lt;/strong> 恕我直言，说白了是胆识不足格局太小。胆就是胆量，焦虑的人一般对未来的不确定性怀有恐惧。识就是见识，焦虑的人一般看不清楚周围世界，也看不清自己和适合自己的道路。格局也称志向，容易焦虑的人通常视野窄志向小。如果从战略和管理的视角来看，就是对自己和周围世界的认知不足，没有一个清晰和长期的学习成长战略，也没有可执行的阶段性目标计划+严格的执行。&lt;/p>
&lt;p>因为问此类问题的学员很多，让我感觉有点烦了，为了避免重复回答，所以我专门总结梳理了这篇长文，试图统一来回答这类问题。如果后面还有学员问类似问题，我会引导他们来读这篇文章，然后让他们用三个月、一年甚至更长的时间，去思考和回答这样一个问题：&lt;strong>你的技术成长战略究竟是什么？&lt;/strong> 如果你想清楚了这个问题，有清晰和可落地的答案，那么恭喜你，你只需按部就班执行就好，根本无需焦虑，你实现自己的战略目标并做出成就只是一个时间问题；否则，你仍然需要通过不断磨炼+思考，务必去搞清楚这个人生的大问题！！！&lt;/p>
&lt;p>下面我们来看一些行业技术大牛是怎么做的。&lt;/p>
&lt;h2 id="二-跟技术大牛学成长战略">
 二. 跟技术大牛学成长战略
 &lt;a class="anchor" href="#%e4%ba%8c-%e8%b7%9f%e6%8a%80%e6%9c%af%e5%a4%a7%e7%89%9b%e5%ad%a6%e6%88%90%e9%95%bf%e6%88%98%e7%95%a5">#&lt;/a>
&lt;/h2>
&lt;p>我们知道软件设计是有设计模式(Design Pattern)的，其实技术人的成长也是有成长模式(Growth Pattern)的。波波经常在 Linkedin 上看一些技术大牛的成长履历，探究其中的成长模式，从而启发制定自己的技术成长战略。&lt;/p>
&lt;p>当然，很少有技术大牛会清晰地告诉你他们的技术成长战略，以及每一年的细分落地计划。但是，这并不妨碍我们通过他们的过往履历和产出成果，去溯源他们的技术成长战略。实际上， &lt;strong>越是牛逼的技术人，他们的技术成长战略和路径越是清晰，我们越容易从中探究出一些成功的模式。&lt;/strong>&lt;/p>
&lt;h3 id="21-系统性能专家案例">
 2.1 系统性能专家案例
 &lt;a class="anchor" href="#21-%e7%b3%bb%e7%bb%9f%e6%80%a7%e8%83%bd%e4%b8%93%e5%ae%b6%e6%a1%88%e4%be%8b">#&lt;/a>
&lt;/h3>
&lt;p>国内的开发者大都热衷于系统性能优化，有些人甚至三句话离不开高性能/高并发，但真正能深入这个领域，做到专家级水平的却寥寥无几。&lt;/p>
&lt;p>我这边要特别介绍的这个技术大牛叫 &lt;strong>Brendan Gregg&lt;/strong> ，他是系统性能领域经典书《System Performance: Enterprise and the Cloud》(中文版&lt;a href="https://www.amazon.cn/dp/B08GC261P9">《性能之巅：洞悉系统、企业和云计算》&lt;/a>)的作者，也是著名的&lt;a href="https://github.com/brendangregg/FlameGraph">性能分析利器火焰图(Flame Graph)&lt;/a>的作者。&lt;/p>
&lt;p>Brendan Gregg 之前是 Netflix 公司的高级性能架构师，在 Netflix 工作近 7 年。2022 年 4 月，他离开了 Netflix 去了 Intel，担任院士职位。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/cdb11ce2f1c3a69fd19e922a7f5f59bf.png" alt="" />&lt;/p>
&lt;p>总体上，他已经在系统性能领域深耕超过 10 年，&lt;a href="https://www.linkedin.com/in/brendangregg/">Brendan Gregg 的过往履历&lt;/a>可以在 linkedin 上看到。在这 10 年间，除了书籍以外，Brendan Gregg 还产出了超过上百份和系统性能相关的技术文档，演讲视频/ppt，还有各种工具软件，相关内容都整整齐齐地分享在&lt;a href="http://www.brendangregg.com/">他的技术博客&lt;/a>上，可以说他是一个非常高产的技术大牛。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/format,png-20230309231802218.png" alt="性能工具" />&lt;/p>
&lt;p>上图来自 Brendan Gregg 的新书《BPF Performance Tools: Linux System and Application Observability》。从这个图可以看出，Brendan Gregg 对系统性能领域的掌握程度，已经深挖到了硬件、操作系统和应用的每一个角落，可以说是 360 度无死角，整个计算机系统对他来说几乎都是透明的。波波认为，Brendan Gregg 是名副其实的，世界级的，系统性能领域的大神级人物。&lt;/p></description></item><item><title>程序员高效出书避坑和实践指南</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/programmer/efficient-book-publishing-and-practice-guide/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/programmer/efficient-book-publishing-and-practice-guide/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：详细介绍了程序员出书的一些常见问题，强烈建议有出书想法的朋友看看这篇文章。&lt;/p>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://www.cnblogs.com/JavaArchitect/p/14128202.html">https://www.cnblogs.com/JavaArchitect/p/14128202.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>古有三不朽， 所谓立德、立功、立言。程序员出一本属于自己的书，如果说是立言，可能过于高大上，但终究也算一件雅事。&lt;/p>
&lt;p>出书其实不挣钱，而且从写作到最终拿钱的周期也不短。但程序员如果有一本属于自己的技术书，那至少在面试中能很好地证明自己，也能渐渐地在业内积累自己的名气，面试和做其它事情时也能有不少底气。在本文里，本人就将结合自己的经验和自己踩过的坑，和大家聊聊程序员出书的那些事。&lt;/p>
&lt;h2 id="1出书的稿酬收益和所需要的时间">
 1.出书的稿酬收益和所需要的时间
 &lt;a class="anchor" href="#1%e5%87%ba%e4%b9%a6%e7%9a%84%e7%a8%bf%e9%85%ac%e6%94%b6%e7%9b%8a%e5%92%8c%e6%89%80%e9%9c%80%e8%a6%81%e7%9a%84%e6%97%b6%e9%97%b4">#&lt;/a>
&lt;/h2>
&lt;p>先说下出书的收益和需要付出的代价，这里姑且先不谈“出书带来的无形资产”，先谈下真金白银的稿酬。&lt;/p>
&lt;p>如果直接和出版社联系，一般稿酬是版税，是书价格的 8%乘以印刷数（或者实际销售数），如果你是大牛的话，还可以往上加，不过一般版税估计也就 10%到 12%。请注意这里的价格是书的全价，不是打折后的价格。&lt;/p>
&lt;p>比如一本书全价是 70 块，在京东等地打 7 折销售，那么版税是 70 块的 8%，也就是说卖出一本作者能有 5.6 的收益，当然真实拿到手以后还再要扣税。&lt;/p>
&lt;p>同时也请注意合同的约定是支付稿酬的方式是印刷数还是实际销售数，我和出版社谈的，一般是印刷数量，这有什么差别呢？现在计算机类的图书一般是首印 2500 册，那么实际拿到手的钱数是 70*8%*2500，当然还要扣税。但如果是按实际销售数量算的话，如果首印才销了 1800 本的话，那么就得按这个数量算钱了。&lt;/p>
&lt;p>现在一本 300 页的书，定价一般在 70 左右，按版税 8%和 2500 册算的话，税前收益是 14000，税后估计是 12000 左右，对新手作者的话，300 的书至少要写 8 个月，由此大家可以算下平均每个月的收益，算下来其实每月也就 1500 的收益，真不多。&lt;/p>
&lt;p>别人的情况我不敢说，但我出书以后，除了稿酬，还有哪些其它的收益呢？&lt;/p>
&lt;ul>
&lt;li>在当下和之前的公司面试时，告诉面试官我在相关方面出过书以后，面试官就直接会认为我很资深，帮我省了不少事情。&lt;/li>
&lt;li>我还在做线下的培训，我就直接拿我最近出的 Python 书做教材了，省得我再备课了。&lt;/li>
&lt;li>和别人谈项目，能用我的书证明自己的技术实力，如果是第一次和别人打交道，那么这种证明能立杆见效。&lt;/li>
&lt;/ul>
&lt;p>尤其是第一点，其实对一些小公司或者是一些外派开发岗而言，如果候选人在这个方面出过书，甚至都有可能免面试直接录取，本人之前面试过一个大公司的外派岗，就得到过这种待遇。&lt;/p>
&lt;h2 id="2支付稿酬的时间点和加印后的收益">
 2.支付稿酬的时间点和加印后的收益
 &lt;a class="anchor" href="#2%e6%94%af%e4%bb%98%e7%a8%bf%e9%85%ac%e7%9a%84%e6%97%b6%e9%97%b4%e7%82%b9%e5%92%8c%e5%8a%a0%e5%8d%b0%e5%90%8e%e7%9a%84%e6%94%b6%e7%9b%8a">#&lt;/a>
&lt;/h2>
&lt;p>我是和出版社直接联系出书，支付稿酬的时间点一般是在首印后的 3 个月内拿到首印部分稿酬的一部分（具体是 50%到 90%），然后在图书出版后的一年后再拿到其它部分的稿酬。当下有不少书，能销掉首印的册数就不错了，不过也有不少书能加印，甚至出第二和第三版，一般加印册数的版税会在加印后的半年到一年内结清。&lt;/p>
&lt;p>从支付稿酬的时间点上来，对作者确实会有延迟，外加上稿酬也不算高，相对于作者的辛勤劳动，所以出书真不是挣钱的事，而且拿钱的周期还长。如果个别图书公司工作人员一方面在出书阶段对作者没什么帮助， 另一方面还要在中间再挣个差价，那么真有些作践作者的辛勤劳动了。&lt;/p>
&lt;h2 id="3同图书公司打交道的所见所闻">
 3.同图书公司打交道的所见所闻
 &lt;a class="anchor" href="#3%e5%90%8c%e5%9b%be%e4%b9%a6%e5%85%ac%e5%8f%b8%e6%89%93%e4%ba%a4%e9%81%93%e7%9a%84%e6%89%80%e8%a7%81%e6%89%80%e9%97%bb">#&lt;/a>
&lt;/h2>
&lt;p>在和出版社编辑沟通前，我也和图书公司的工作人员交流过，不少工作人员对我也是比较尊重，交流虽然不算深入，但也算客气。不过最终对比出版社给出的稿酬等条件，我还是没有通过图书公司出书，这也是比较可惜的事情。下面我给出些具体的经历。&lt;/p>
&lt;ul>
&lt;li>我经常在博客园等地收到一些图书公司工作人员的留言，问要不要出书，一般我不问，他们不会说自己是出版社编辑还是图书公司的工作人员。有个别图书公司的工作人员，会向作者，尤其是新手作者，说些“出版社编辑一般不会直接和作者联系”，以及“出书一般是通过图书公司”等的话。其实这些话不能算错，比如你不联系出版社编辑，那么对方自然不会直接联系你，但相反如果作者直接和出版社编辑联系，第一没难度，第二可能更直接。&lt;/li>
&lt;li>我和出版社编辑交流大纲时，即使大纲有不足，他们也能直接给出具体的修改意见，比如某个章节该写什么，某个小节的大纲该怎么写。而我和个别图书公司的工作人员交流过大纲时，得到的反馈大多是“要重写”，怎么个重写法？这些工作人员可能只能给出抽象的意见，什么都要我自己琢磨。在我之前的博文&lt;a href="./how-do-programmers-publish-a-technical-book">程序员怎样出版一本技术书&lt;/a>里，我就给出过具体的经历。&lt;/li>
&lt;li>由于交流不深，所以我没有和图书公司签订过出书协议，但我知道，只有出版社能出书。由于没有经历过，所以我也不知道图书公司在合同里是否有避规风险等条款，但我见过一位图书公司人员人员给出的一些退稿案例，并隐约流露出对作者的责备之意。细思感觉不妥，对接的工作人员第一不能在出问题的第一时间及时发现并向作者反馈，第二在出问题之后不能对应协调最终导致退稿，第三在退稿之后，作者在付出劳动的情况下图书公司不仅不用承担任何风险，并还能指摘作者。对此，退稿固然有作者的因素，但同是作者的我未免有兔死狐悲之谈。而我在出版社出书时，编辑有时候甚至会主动关心，主动给素材，哪怕有问题也会第一时间修改，所以甚至大范围修改稿件的情况都基本没有出现。&lt;/li>
&lt;li>再说下图书公司给作者的稿酬。我见过按页给钱，比如一页 30 到 50 块，并卖断版权，即书重印后作者也无法再得到稿酬，如果是按版税给钱，我也见过给 6%，至于图书公司能否给到 8 个点甚至更高，我没见到过，所以不知道，也不敢擅拟。&lt;/li>
&lt;/ul>
&lt;p>我交流过的图书公司工作人员不多，交流也不深，因为我现在主要是和出版社的编辑交流。所以以上只是我对个别图书公司编辑的感受，我无意以偏概全，而和我交流的一些图书公司工作人员至少态度上对我很尊重。所以大家也可以对比尝试下和图书公司以及出版社合作的不同方式。不管怎样，你在写书甚至在签出书协议前，你需要问清楚如下的事项，并且对方有义务让你了解如下的事实。&lt;/p></description></item><item><title>程序员如何快速学习新技术</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/programmer-quickly-learn-new-technology/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/programmer-quickly-learn-new-technology/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：这是&lt;a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》&lt;/a>练级攻略篇中的一篇文章，分享了我对于如何快速学习一门新技术的看法。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/javamianshizhibei/training-strategy-articles.png" alt="《Java 面试指北》练级攻略篇" />&lt;/p>
&lt;/blockquote>
&lt;p>很多时候，我们因为工作原因需要快速学习某项技术，进而在项目中应用。或者说，我们想要去面试的公司要求的某项技术我们之前没有接触过，为了应对面试需要，我们需要快速掌握这项技术。&lt;/p>
&lt;p>作为一个人纯自学出生的程序员，这篇文章简单聊聊自己对于如何快速学习某项技术的看法。&lt;/p>
&lt;p>学习任何一门技术的时候，一定要先搞清楚这个技术是为了解决什么问题的。深入学习这个技术的之前，一定先从全局的角度来了解这个技术，思考一下它是由哪些模块构成的，提供了哪些功能，和同类的技术想必它有什么优势。&lt;/p>
&lt;p>比如说我们在学习 Spring 的时候，通过 Spring 官方文档你就可以知道 Spring 最新的技术动态，Spring 包含哪些模块 以及 Spring 可以帮你解决什么问题。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/20210506110341207.png" alt="" />&lt;/p>
&lt;p>再比如说我在学习消息队列的时候，我会先去了解这个消息队列一般在系统中有什么作用，帮助我们解决了什么问题。消息队列的种类很多，具体学习研究某个消息队列的时候，我会将其和自己已经学习过的消息队列作比较。像我自己在学习 RocketMQ 的时候，就会先将其和自己曾经学习过的第 1 个消息队列 ActiveMQ 进行比较，思考 RocketMQ 相对于 ActiveMQ 有了哪些提升，解决了 ActiveMQ 的哪些痛点，两者有哪些相似的地方，又有哪些不同的地方。&lt;/p>
&lt;p>&lt;strong>学习一个技术最有效最快的办法就是将这个技术和自己之前学到的技术建立连接，形成一个网络。&lt;/strong>&lt;/p>
&lt;p>然后，我建议你先去看看官方文档的教程，运行一下相关的 Demo ，做一些小项目。&lt;/p>
&lt;p>不过，官方文档通常是英文的，通常只有国产项目以及少部分国外的项目提供了中文文档。并且，官方文档介绍的往往也比较粗糙，不太适合初学者作为学习资料。&lt;/p>
&lt;p>如果你看不太懂官网的文档，你也可以搜索相关的关键词找一些高质量的博客或者视频来看。 &lt;strong>一定不要一上来就想着要搞懂这个技术的原理。&lt;/strong>&lt;/p>
&lt;p>就比如说我们在学习 Spring 框架的时候，我建议你在搞懂 Spring 框架所解决的问题之后，不是直接去开始研究 Spring 框架的原理或者源码，而是先实际去体验一下 Spring 框架提供的核心功能 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)，使用 Spring 框架写一些 Demo，甚至是使用 Spring 框架做一些小项目。&lt;/p>
&lt;p>一言以蔽之， &lt;strong>在研究这个技术的原理之前，先要搞懂这个技术是怎么使用的。&lt;/strong>&lt;/p>
&lt;p>这样的循序渐进的学习过程，可以逐渐帮你建立学习的快感，获得即时的成就感，避免直接研究原理性的知识而被劝退。&lt;/p>
&lt;p>&lt;strong>研究某个技术原理的时候，为了避免内容过于抽象，我们同样可以动手实践。&lt;/strong>&lt;/p>
&lt;p>比如说我们学习 Tomcat 原理的时候，我们发现 Tomcat 的自定义线程池挺有意思，那我们自己也可以手写一个定制版的线程池。再比如我们学习 Dubbo 原理的时候，可以自己动手造一个简易版的 RPC 框架。&lt;/p></description></item><item><title>程序员怎样出版一本技术书</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/programmer/how-do-programmers-publish-a-technical-book/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/programmer/how-do-programmers-publish-a-technical-book/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：详细介绍了程序员应该如何从头开始出一本自己的书籍。&lt;/p>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://www.cnblogs.com/JavaArchitect/p/12195219.html">https://www.cnblogs.com/JavaArchitect/p/12195219.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在面试或联系副业的时候，如果能令人信服地证明自己的实力，那么很有可能事半功倍。如何证明自己的实力？最有信服力的是大公司职位背景背书，没有之一，比如在 BAT 担任资深架构，那么其它话甚至都不用讲了。&lt;/p>
&lt;p>不过，不是每个人入职后马上就是大公司架构师，在上进的路上，还可以通过公众号，专栏博文，GitHub 代码量和出书出视频等方式来证明自己。和其它方式相比，属于自己的技术图书由于经过了国家级出版社的加持，相对更能让别人认可自己的实力，而对于一些小公司而言，一本属于自己的书甚至可以说是免面试的通行证。所以在本文里，就将和广大程序员朋友聊聊出版技术书的那些事。&lt;/p>
&lt;h2 id="1不是有能力了再出书而是在出书过程中升能力">
 1.不是有能力了再出书，而是在出书过程中升能力
 &lt;a class="anchor" href="#1%e4%b8%8d%e6%98%af%e6%9c%89%e8%83%bd%e5%8a%9b%e4%ba%86%e5%86%8d%e5%87%ba%e4%b9%a6%e8%80%8c%e6%98%af%e5%9c%a8%e5%87%ba%e4%b9%a6%e8%bf%87%e7%a8%8b%e4%b8%ad%e5%8d%87%e8%83%bd%e5%8a%9b">#&lt;/a>
&lt;/h2>
&lt;p>我知道的不少朋友，是在工作 3 年内出了第一本书，有些优秀的，甚至在校阶段就出书了。&lt;/p>
&lt;p>与之相比还有另外一种态度，不少同学可能想，要等到技术积累到一定程度再写。其实这或许就不怎么积极了，边写书，边升技术，而且写出的书对人还有帮助，这绝对可以做到的。&lt;/p>
&lt;p>比如有同学向深入了解最近比较热门的 Python 数据分析和机器学习，那么就可以在系统性的学习之后，整理之前学习到的爬虫，数据分析和机器学习的案例，根据自己的理解，用适合于初学者的方式整理一下，然后就能出书了。这种书，对资深的人帮助未必大，但由于包含案例，对入门级的读者绝对有帮助，因为这属于现身说法。而且话说回来，如果没有出书这个动力，或者学习过程也就是浅尝辄止，或者未必能全身心地投入，有了出书这个目标，更能保证学习的效果。&lt;/p>
&lt;h2 id="2适合初级开发高级开发和架构师写的书">
 2.适合初级开发，高级开发和架构师写的书
 &lt;a class="anchor" href="#2%e9%80%82%e5%90%88%e5%88%9d%e7%ba%a7%e5%bc%80%e5%8f%91%e9%ab%98%e7%ba%a7%e5%bc%80%e5%8f%91%e5%92%8c%e6%9e%b6%e6%9e%84%e5%b8%88%e5%86%99%e7%9a%84%e4%b9%a6">#&lt;/a>
&lt;/h2>
&lt;p>之前也提到了，初级开发适合写案例书，就拿 Python 爬虫数据分析机器学习题材为例，可以先找几本这方面现成的书，这些书里，或者章节内容不同，但一起集成看的话，应该可以包含这方面的内容。然后就参考别人书的思路，比如一章写爬虫，一章写 pandas，一章写 matplotlib 等等，整合起来，就可以用 若干个章节构成一本书了。总之，别人书里包含什么内容，你别照抄，但可以参考别人写哪些技术点。&lt;/p>
&lt;p>定好章节后，再定下每个章节的小节，比如第三章讲爬虫案例，那么可以定 3.1 讲爬虫概念，3.2 讲如何搭建 Scrapy 库，3.3 讲如何开发 Scrapy 爬虫案例，通过先章再节的次序，就可以定好一本书的框架。由于是案例书，所以是先给运行通的代码，再用这些代码案例教别人入门，所以案例未必很深，但需要让初学者看了就能懂，而且按照你给出的知识体系逐步学习之后，能理解这个主题的内容。并且，能在看完你这本书以后，能通过调通你给出的爬虫，机器学习等的案例，掌握这一领域的知识，并能从事这方面的基本开发。这个目标，对初级开发而言，稍微用点心，费点时间，应该不难达到。&lt;/p>
&lt;p>而对于高级开发和架构师而言，除了写存粹案例书以外，还可以在书里给出你在大公司里总结出来的开发经验，也就是所谓踩过的坑，比如 Python 在用 matplotlib 会图例时，在设置坐标轴方面有哪些技巧，设置时会遇到哪些常见问题，如果在书里大量包含这种经验，你的书含金量更高。&lt;/p>
&lt;p>此外，高级开发和架构师还可以写一些技术含量更高的书，比如就讲高并发场景下的实践经验，或者 k8s+docker 应对高并发的经验，这种书里，可以给出代码，更可以给出实施方案和架构实施技巧，比如就讲高并发场景里，缓存该如何选型，如何避免击穿，雪崩等场景，如何排查线上 redis 问题，如何设计故障应对预案。除了这条路之外，还可以深入细节，比如通过讲 dubbo 底层代码，告诉大家如何高效配置 dubbo，出了问题该如何排查。如果架构师或高级开发有这类书作为背书，外带大厂工作经验，那么就更可以打出自己的知名度。&lt;/p>
&lt;h2 id="3可以直接找出版社也可以找出版公司">
 3.可以直接找出版社，也可以找出版公司
 &lt;a class="anchor" href="#3%e5%8f%af%e4%bb%a5%e7%9b%b4%e6%8e%a5%e6%89%be%e5%87%ba%e7%89%88%e7%a4%be%e4%b9%9f%e5%8f%af%e4%bb%a5%e6%89%be%e5%87%ba%e7%89%88%e5%85%ac%e5%8f%b8">#&lt;/a>
&lt;/h2>
&lt;p>在我的这篇博文里，&lt;a href="https://www.cnblogs.com/JavaArchitect/p/11616906.html">程序员副业那些事：聊聊出书和录视频&lt;/a>，给出了通过出版社出书和图书公司出书的差别，供大家参考，大家看了以后可以自行决定出书方式。&lt;/p>
&lt;p>不过不管怎么选，在出书前你得搞明白一些事，或许个别图书出版公司的工作人员不会主动说，这需要你自己问清楚。&lt;/p>
&lt;ul>
&lt;li>你的合作方是谁？图书出版公司还是出版社？&lt;/li>
&lt;li>你的书将在哪个出版社出版？国内比较有名的是清华，人邮，电子和机械，同时其它出版社不能说不好，但业内比较认这四个。&lt;/li>
&lt;li>和你沟通的人，是最终有决定权的图书编辑吗？还是图书公司里的工作人员？再啰嗦下，最后能决定书能否出版，以及确定修改意见的，是出版社的编辑。&lt;/li>
&lt;/ul>
&lt;p>通过对比出版社和图书出版公司，在搞清楚诸多细节后，大家可以自己斟酌考虑合作的方式。而且，出版社和图书公司的联系方式，在官网上都有，大家可以自行通过邮件等方式联系。&lt;/p>
&lt;h2 id="4如果别人拿你做试错对象或有不尊重赶紧止损">
 4.如果别人拿你做试错对象，或有不尊重，赶紧止损
 &lt;a class="anchor" href="#4%e5%a6%82%e6%9e%9c%e5%88%ab%e4%ba%ba%e6%8b%bf%e4%bd%a0%e5%81%9a%e8%af%95%e9%94%99%e5%af%b9%e8%b1%a1%e6%88%96%e6%9c%89%e4%b8%8d%e5%b0%8a%e9%87%8d%e8%b5%b6%e7%b4%a7%e6%ad%a2%e6%8d%9f">#&lt;/a>
&lt;/h2>
&lt;p>我之前看到有图书出版公司招募面向 Java 初学者图书的作者，并且也主动联系过相关人员，得到的反馈大多是：“要重写”。&lt;/p>
&lt;p>比如我列了大纲发过去，反馈是“要重写”，原因是对方没学过 Java，但作为零基础的人看了我的大纲，发现学不会。至于要重写成什么样子 ，对方也说不上来，总之让我再给个大纲，再给一版后，同样没过，这次好些，给了我几本其它类似书的大纲，让我自行看别人有什么好的点。总之不提（或者说提不出）具体的改进点，要我自行尝试各种改进点，试到对方感觉可以为止。&lt;/p>
&lt;p>相比我和几位出版社专业的编辑沟通时，哪怕大纲或稿件有问题，对方会指明到点，并给出具体的修改意见。我不知道图书出版公司里的组织结构，但出版社里，计算机图书有专门的部门，专门的编辑，对方提出的意见都是比较专业，且修改起来很有操作性。&lt;/p>
&lt;p>另外，我在各种渠道，时不时看到有图书出版公司的人员，晒出别人交付的稿件，在众目睽睽之下，说其中有什么问题，意思让大家引以为戒。姑且不论这样做的动机，并且这位工作人员也涂掉了能表面作者身份的信息。但作者出于信任把稿件交到你手上，在不征得作者同意就公开稿件，说“不把作者当回事”，这并不为过。不然，完全可以用私信的方式和作者交流，而不是把作者无心之过公示于众。&lt;/p>
&lt;p>我在和出版社合作时，这类事绝没发生过，而且我认识的出版社编辑，都对各位作者保持着足够的尊重。而且我和我的朋友和多位图书出版公司的朋友交流时，也能得到尊重和礼遇。所以，如果大家在写书时，尤其在写第一本书时，如果遇到被试错，或者从言辞等方面感觉对方不把你当会事，那么可以当即止损。其实也没有什么“损失”，你把当前的大纲和稿件再和出版社编辑交流时，或许你的收益还能提升。&lt;/p></description></item><item><title>程序员最该拿的几种高含金量证书</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/programmer/high-value-certifications-for-programmers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/programmer/high-value-certifications-for-programmers/</guid><description>&lt;p>证书是能有效证明自己能力的好东西，它就是你实力的象征。在短短的面试时间内，证书可以为你加不少分。通过考证来提升自己，是一种性价比很高的办法。不过，相比金融、建筑、医疗等行业，IT 行业的职业资格证书并没有那么多。&lt;/p>
&lt;p>下面我总结了一下程序员可以考的一些常见证书。&lt;/p>
&lt;h2 id="软考">
 软考
 &lt;a class="anchor" href="#%e8%bd%af%e8%80%83">#&lt;/a>
&lt;/h2>
&lt;p>全国计算机技术与软件专业技术资格（水平）考试，简称“软考”，是国内认可度较高的一项计算机技术资格认证。尽管一些人吐槽其实际价值，但在特定领域和情况下，它还是非常有用的，例如软考证书在国企和事业单位中具有较高的认可度、在某些城市软考证书可以用于积分落户、可用于个税补贴。&lt;/p>
&lt;p>软考有初、中、高三个级别，建议直接考高级。相比于 PMP（项目管理专业人士认证），软考高项的难度更大，特别是论文部分，绝大部分人都挂在了论文部分。过了软考高项，在一些单位可以内部挂证，每个月多拿几百。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/programmer-life/programmer-certification/ruankao-advanced-certification%20.jpg" alt="软考高级证书" />&lt;/p>
&lt;p>官网地址：&lt;a href="https://www.ruankao.org.cn/">https://www.ruankao.org.cn/&lt;/a>。&lt;/p>
&lt;p>备考建议：&lt;a href="https://mp.weixin.qq.com/s/9aUXHJ7dXgrHuT19jRhCnw">2024 年上半年，一次通过软考高级架构师考试的备考秘诀 - 阿里云开发者&lt;/a>&lt;/p>
&lt;h2 id="pat">
 PAT
 &lt;a class="anchor" href="#pat">#&lt;/a>
&lt;/h2>
&lt;p>攀拓计算机能力测评（PAT）是一个专注于考察算法能力的测评体系，由浙江大学主办。该测评分为四个级别：基础级、乙级、甲级和顶级。&lt;/p>
&lt;p>通过 PAT 测评并达到联盟企业规定的相应评级和分数，可以跳过学历门槛，免除筛选简历和笔试环节，直接获得面试机会。具体有哪些公司可以去官网看看：&lt;a href="https://www.patest.cn/company">https://www.patest.cn/company&lt;/a> 。&lt;/p>
&lt;p>对于考研浙江大学的同学来说，PAT（甲级）成绩在一年内可以作为硕士研究生招生考试上机复试成绩。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/programmer-life/programmer-certification/pat-enterprise-alliance.png" alt="PAT（甲级）成绩作用" />&lt;/p>
&lt;h2 id="pmp">
 PMP
 &lt;a class="anchor" href="#pmp">#&lt;/a>
&lt;/h2>
&lt;p>PMP（Project Management Professional）认证由美国项目管理协会（PMI）提供，是全球范围内认可度最高的项目管理专业人士资格认证。PMP 认证旨在提升项目管理专业人士的知识和技能，确保项目顺利完成。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/programmer-life/programmer-certification/pmp-certification.png" alt="PMP 证书" />&lt;/p>
&lt;p>PMP 是“一证在手，全球通用”的资格认证，对项目管理人士来说，PMP 证书含金量还是比较高的。放眼全球，很多成功企业都会将 PMP 认证作为项目经理的入职标准。&lt;/p>
&lt;p>但是！真正有价值的不是 PMP 证书，而是《PMBOK》 那套项目管理体系，在《PMBOK》（PMP 考试指定用书）中也包含了非常多商业活动、实业项目、组织规划、建筑行业等各个领域的项目案例。&lt;/p>
&lt;p>另外，PMP 证书不是一个高大上的证书，而是一个基础的证书。&lt;/p>
&lt;h2 id="acp">
 ACP
 &lt;a class="anchor" href="#acp">#&lt;/a>
&lt;/h2>
&lt;p>ACP（Agile Certified Practitioner）认证同样由美国项目管理协会（PMI）提供，是项目管理领域的另一个重要认证。与 PMP（Project Management Professional）注重传统的瀑布方法论不同，ACP 专注于敏捷项目管理方法论，如 Scrum、Kanban、Lean、Extreme Programming（XP）等。&lt;/p>
&lt;h2 id="ocp">
 OCP
 &lt;a class="anchor" href="#ocp">#&lt;/a>
&lt;/h2>
&lt;p>Oracle Certified Professional（OCP）是 Oracle 公司提供的一项专业认证，专注于 Oracle 数据库及相关技术。这个认证旨在验证和认证个人在使用和管理 Oracle 数据库方面的专业知识和技能。&lt;/p></description></item><item><title>从ReentrantLock的实现看AQS的原理及应用</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/reentrantlock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/reentrantlock/</guid><description>&lt;blockquote>
&lt;p>本文转载自：&lt;a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html&lt;/a>&lt;/p>
&lt;p>作者：美团技术团队&lt;/p>
&lt;/blockquote>
&lt;p>Java 中的大部分同步类（Semaphore、ReentrantLock 等）都是基于 AbstractQueuedSynchronizer（简称为 AQS）实现的。AQS 是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。&lt;/p>
&lt;p>本文会从应用层逐渐深入到原理层，并通过 ReentrantLock 的基本特性和 ReentrantLock 与 AQS 的关联，来深入解读 AQS 相关独占锁的知识点，同时采取问答的模式来帮助大家理解 AQS。由于篇幅原因，本篇文章主要阐述 AQS 中独占锁的逻辑和 Sync Queue，不讲述包含共享锁和 Condition Queue 的部分（本篇文章核心为 AQS 原理剖析，只是简单介绍了 ReentrantLock，感兴趣同学可以阅读一下 ReentrantLock 的源码）。&lt;/p>
&lt;h2 id="1-reentrantlock">
 1 ReentrantLock
 &lt;a class="anchor" href="#1-reentrantlock">#&lt;/a>
&lt;/h2>
&lt;h3 id="11-reentrantlock-特性概览">
 1.1 ReentrantLock 特性概览
 &lt;a class="anchor" href="#11-reentrantlock-%e7%89%b9%e6%80%a7%e6%a6%82%e8%a7%88">#&lt;/a>
&lt;/h3>
&lt;p>ReentrantLock 意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解 ReentrantLock 的特性，我们先将 ReentrantLock 跟常用的 Synchronized 进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）：&lt;/p>
&lt;p>&lt;img src="https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png" alt="" />&lt;/p>
&lt;p>下面通过伪代码，进行更加直观的比较：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// **************************Synchronized的使用方式**************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1.用于代码块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">synchronized&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 2.用于对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">synchronized&lt;/span> (object) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 3.用于方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">synchronized&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span> () {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 4.可重入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 100; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// **************************ReentrantLock的使用方式**************************&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span> () &lt;span style="color:#66d9ef">throw&lt;/span> Exception {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 1.初始化选择公平锁、非公平锁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReentrantLock lock &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ReentrantLock(&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2.可用于代码块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.&lt;span style="color:#a6e22e">lock&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 3.支持多种加锁方式，比较灵活; 具有可重入特性&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(lock.&lt;span style="color:#a6e22e">tryLock&lt;/span>(100, TimeUnit.&lt;span style="color:#a6e22e">MILLISECONDS&lt;/span>)){ }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 4.手动释放锁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.&lt;span style="color:#a6e22e">unlock&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.&lt;span style="color:#a6e22e">unlock&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="12-reentrantlock-与-aqs-的关联">
 1.2 ReentrantLock 与 AQS 的关联
 &lt;a class="anchor" href="#12-reentrantlock-%e4%b8%8e-aqs-%e7%9a%84%e5%85%b3%e8%81%94">#&lt;/a>
&lt;/h3>
&lt;p>通过上文我们已经了解，ReentrantLock 支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《&lt;a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651749434&amp;amp;idx=3&amp;amp;sn=5ffa63ad47fe166f2f1a9f604ed10091&amp;amp;chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&amp;amp;scene=38#wechat_redirect">不可不说的 Java“锁”事&lt;/a>》），并且 ReentrantLock 的底层就是由 AQS 来实现的。那么 ReentrantLock 是如何通过公平锁和非公平锁与 AQS 关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与 AQS 之间的关系（加锁过程中与 AQS 的关联比较明显，解锁流程后续会介绍）。&lt;/p></description></item><item><title>从面试官和候选者的角度谈如何准备技术初试</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/technical-preliminary-preparation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/technical-preliminary-preparation/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：从面试官和面试者两个角度探讨了技术面试！非常不错！&lt;/p>
&lt;p>&lt;strong>内容概览：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>通过技术基础考察候选者，才能考察到候选者的真实技术实力：技术深度和广度。&lt;/li>
&lt;li>实战与理论结合。比如，候选人叙述 JVM 内存模型布局之后，可以接着问：有哪些原因可能会导致 OOM , 有哪些预防措施? 你是否遇到过内存泄露的问题? 如何排查和解决这类问题?&lt;/li>
&lt;li>项目经历考察不宜超过两个。因为要深入考察一个项目的详情，所占用的时间还是比较大的。一般来说，会让候选人挑选一个他或她觉得最有收获的/最有挑战的/印象最深刻的/自己觉得特有意思的项目。然后围绕这个项目进行发问。通常是从项目背景出发，考察项目的技术栈、项目模块及交互的整体理解、项目中遇到的有挑战性的技术问题及解决方案、排查和解决问题、代码可维护性问题、工程质量保障等。&lt;/li>
&lt;li>多问少说，让候选者多表现。根据候选者的回答适当地引导或递进或横向移动。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>原文地址：&lt;/strong> &lt;a href="https://www.cnblogs.com/lovesqcc/p/15169365.html">https://www.cnblogs.com/lovesqcc/p/15169365.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="考察目标和思路">
 考察目标和思路
 &lt;a class="anchor" href="#%e8%80%83%e5%af%9f%e7%9b%ae%e6%a0%87%e5%92%8c%e6%80%9d%e8%b7%af">#&lt;/a>
&lt;/h2>
&lt;p>首先明确，技术初试的考察目标：&lt;/p>
&lt;ul>
&lt;li>候选人的技术基础；&lt;/li>
&lt;li>候选人解决问题的思路和能力。&lt;/li>
&lt;/ul>
&lt;p>技术基础是基石（冰山之下的东西），占七分， 解决问题的思路和能力是落地（冰山之上露出的部分），占三分。 业务和技术基础考察，三七开。&lt;/p>
&lt;h2 id="技术基础考察">
 技术基础考察
 &lt;a class="anchor" href="#%e6%8a%80%e6%9c%af%e5%9f%ba%e7%a1%80%e8%80%83%e5%af%9f">#&lt;/a>
&lt;/h2>
&lt;h3 id="为什么要考察技术基础">
 为什么要考察技术基础?
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%80%83%e5%af%9f%e6%8a%80%e6%9c%af%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h3>
&lt;p>程序员最重要的两种技术思维能力，是逻辑思维能力和抽象设计能力。逻辑思维能力是基础，抽象设计能力是高阶。 考察技术基础，正好可以同时考察这两种思维能力。能不能理解基础技术概念及关联，是考察逻辑思维能力；能不能把业务问题抽象成技术问题并合理的组织映射，是考察抽象设计能力。&lt;/p>
&lt;p>绝大部分业务问题，都可以抽象成技术问题。在某种意义上，业务问题只是技术问题的领域化表述。&lt;/p>
&lt;p>因此，&lt;strong>通过技术基础考察候选者，才能考察到候选者的真实技术实力：技术深度和广度。&lt;/strong>&lt;/p>
&lt;h3 id="技术基础怎么考察">
 技术基础怎么考察？
 &lt;a class="anchor" href="#%e6%8a%80%e6%9c%af%e5%9f%ba%e7%a1%80%e6%80%8e%e4%b9%88%e8%80%83%e5%af%9f">#&lt;/a>
&lt;/h3>
&lt;p>技术基础怎么考察？通过有效的多角度的发问模式来考察。&lt;/p>
&lt;h4 id="是什么-为什么">
 是什么-为什么
 &lt;a class="anchor" href="#%e6%98%af%e4%bb%80%e4%b9%88-%e4%b8%ba%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h4>
&lt;p>是什么考察对概念的基本理解，为什么考察对概念的实现原理。&lt;/p>
&lt;p>比如：索引是什么？ 索引是如何实现的？&lt;/p>
&lt;h4 id="引导-横向发问-深入发问">
 引导-横向发问-深入发问
 &lt;a class="anchor" href="#%e5%bc%95%e5%af%bc-%e6%a8%aa%e5%90%91%e5%8f%91%e9%97%ae-%e6%b7%b1%e5%85%a5%e5%8f%91%e9%97%ae">#&lt;/a>
&lt;/h4>
&lt;p>引导性，比如 “你对 Java 同步工具熟悉吗？” 作个试探，得到肯定答复后，可以进一步问：“你熟悉哪些同步工具类？” 了解候选者的广度；&lt;/p>
&lt;p>获取候选者的回答后，可以进一步问：“ 谈谈 &lt;code>ConcurrentHashMap&lt;/code> 或 &lt;code>AQS&lt;/code> 的实现原理？”&lt;/p>
&lt;p>一个人在多大程度上把技术原理能讲得清晰，包括思路和细节，说明他对技术的掌握能力有多强。&lt;/p>
&lt;h4 id="跳跃式交叉式发问">
 跳跃式/交叉式发问
 &lt;a class="anchor" href="#%e8%b7%b3%e8%b7%83%e5%bc%8f%e4%ba%a4%e5%8f%89%e5%bc%8f%e5%8f%91%e9%97%ae">#&lt;/a>
&lt;/h4>
&lt;p>比如：讲到哈希高效查找，可以谈谈哈希一致性算法 。 两者既有关联又有很多不同点。也是一种技术广度的考察方法。&lt;/p>
&lt;h4 id="总结性发问">
 总结性发问
 &lt;a class="anchor" href="#%e6%80%bb%e7%bb%93%e6%80%a7%e5%8f%91%e9%97%ae">#&lt;/a>
&lt;/h4>
&lt;p>比如：你在做 XXX 中，获得了哪些可以分享的经验？ 考察候选人的归纳总结能力。&lt;/p></description></item><item><title>从校招入职腾讯的四年工作总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/four-year-work-in-tencent-summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/four-year-work-in-tencent-summary/</guid><description>&lt;p>程序员是一个流动性很大的职业，经常会有新面孔的到来，也经常会有老面孔的离开，有主动离开的，也有被动离职的。&lt;/p>
&lt;p>再加上这几年卷得厉害，做的事更多了，拿到的却更少了，互联网好像也没有那么香了。&lt;/p>
&lt;p>人来人往，变动无常的状态，其实也早已习惯。&lt;/p>
&lt;p>打工人的唯一出路，无外乎精进自己的专业技能，提升自己的核心竞争力，这样无论有什么变动，走到哪里，都能有口饭吃。&lt;/p>
&lt;p>今天分享一位博主，校招入职腾讯，工作四年后，离开的故事。&lt;/p>
&lt;p>至于为什么离开，我也不清楚，可能是有其他更好的选择，或者是觉得当前的工作对自己的提升有限。&lt;/p>
&lt;p>&lt;strong>下文中的“我”，指这位作者本人。&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>原文地址：&lt;a href="https://zhuanlan.zhihu.com/p/602517682">https://zhuanlan.zhihu.com/p/602517682&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>研究生毕业后， 一直在腾讯工作，不知不觉就过了四年。个人本身没有刻意总结的习惯，以前只顾着往前奔跑了，忘了停下来思考总结。记得看过一个职业规划文档，说的三年一个阶段，五年一个阶段的说法，现在恰巧是四年，同时又从腾讯离开，该做一个总结了。&lt;/p>
&lt;p>先对自己这四年做一个简单的评价吧：个人认为，没有完全的浪费和辜负这四年的光阴。为何要这么说了？因为我发现和别人对比，好像意义不大，比我混的好的人很多；比我混的差的人也不少。说到底，我只是一个普普通通的人，才不惊人，技不压众，接受自己的平凡，然后看自己做的，是否让自己满意就好。&lt;/p>
&lt;p>下面具体谈几点吧，我主要想聊下工作，绩效，EPC，嫡系看法，最后再谈下收获。&lt;/p>
&lt;h2 id="工作情况">
 工作情况
 &lt;a class="anchor" href="#%e5%b7%a5%e4%bd%9c%e6%83%85%e5%86%b5">#&lt;/a>
&lt;/h2>
&lt;p>我在腾讯内部没有转过岗，但是做过的项目也还是比较丰富的，包括：BUGLY、分布式调用链（Huskie)、众包系统（SOHO)，EPC 度量系统。其中一些是对外的，一些是内部系统，可能有些大家不知道。还是比较感谢这些项目经历，既有纯业务的系统，也有偏框架的系统，让我学到了不少知识。&lt;/p>
&lt;p>接下来，简单介绍一下每个项目吧，毕竟每一个项目都付出了很多心血的：&lt;/p>
&lt;p>BUGLY，这是一个终端 Crash 联网上报的系统，很多 APP 都接入了。Huskie，这是一个基于 zipkin 搭建的分布式调用链跟踪项目。SOHO，这是一个众包系统，主要是将数据标准和语音采集任务众包出去，让人家做。EPC 度量系统，这是研发效能度量系统，主要是度量研发效能情况的。这里我谈一下对于业务开发的理解和认识，很多人可能都跟我最开始一样，有一个疑惑，整天做业务开发如何成长？换句话说，就是说整天做 CRUD，如何成长？我开始也有这样的疑惑，后来我转变了观念。&lt;/p>
&lt;p>我觉得对于系统的复杂度，可以粗略的分为技术复杂度和业务复杂度，对于业务系统，就是业务复杂度高一些，对于框架系统就是技术复杂度偏高一些。解决这两种复杂度，都具有很大的挑战。&lt;/p>
&lt;p>此前做过的众包系统，就是各种业务逻辑，搞过去，搞过来，其实这就是业务复杂度高。为了解决这个问题，我们开始探索和实践领域驱动（DDD），确实带来了一些帮助，不至于系统那么混乱了。同时，我觉得这个过程中，自己对于 DDD 的感悟，对于我后来的项目系统划分和设计以及开发都带来了帮助。&lt;/p>
&lt;p>当然 DDD 不是银弹，我也不是吹嘘它有多好，只是了解了它后，有时候设计和开发时，能换一种思路。&lt;/p>
&lt;p>可以发现，其实平时咱们做业务，想做好，其实也没那么容易，如果可以多探索多实践，将一些好的方法或思想或架构引入进来，与个人和业务都会有有帮助。&lt;/p>
&lt;h2 id="绩效情况">
 绩效情况
 &lt;a class="anchor" href="#%e7%bb%a9%e6%95%88%e6%83%85%e5%86%b5">#&lt;/a>
&lt;/h2>
&lt;p>我在腾讯工作四年，腾讯半年考核一次，一共考核八次，回想了下，四年来的绩效情况为:三星，三星，五星，三星，五星，四星，四星，三星。统计一下， 四五星占比刚好一半。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/640.png" alt="" />&lt;/p>
&lt;p>PS：还好以前有奖杯，不然一点念想都没了。(现在腾讯似乎不发了）&lt;/p>
&lt;p>印象比较深的是两次五星获得经历。第一次五星是工作的第二年，那一年是在做众包项目，因为项目本身难度不大，因此我把一些精力投入到了团队的基础建设中，帮团队搭建了 java 以及 golang 的项目脚手架，又做了几次中心技术分享，最终 Leader 觉得我表现比较突出，因此给了我五星。看来，主动一些，与个人与团队都是有好处的，最终也能获得一些回报。&lt;/p>
&lt;p>第二次五星，就是与 EPC 有关了。说一个搞笑的事，我也是后来才知道的，项目初期，总监去汇报时，给老板演示系统，加载了很久指标才刷出来，总监很不好意思的说正在优化；过了一段时间，又去汇报演示，结果又很尴尬的刷了很久才出来，总监无赖表示还是在优化。没想到，自己曾经让总监这么丢脸，哈哈。好吧，说一下结果，最终，我自己写了一个查询引擎替换了 Mondrian，之后再也没有出现那种尴尬的情况了。随之而来，也给了好绩效鼓励。做 EPC 度量项目，我觉得自己成长很大，比如抗压能力，当你从零到一搭建一个系统时，会有一个先扛住再优化的过程，此外如果你的项目很重要，尤其是数据相关，那么任何一点问题，都可能让你神经紧绷，得想尽办法降低风险和故障。此外，另一个不同的感受就是，以前得项目，我大多是开发者，而这个系统，我是 Owner 负责人，当你 Owner 一个系统时，你得时刻负责，同时还需要思考系统的规划和方向，此外还需要分配好需求和把控进度，角色体验跟以前完全不一样。&lt;/p>
&lt;h2 id="谈谈-epc">
 谈谈 EPC
 &lt;a class="anchor" href="#%e8%b0%88%e8%b0%88-epc">#&lt;/a>
&lt;/h2>
&lt;p>很多人都骂 EPC，或者笑 EPC，作为度量平台核心开发者之一，我来谈谈客观的看法。&lt;/p>
&lt;p>其实 EPC 初衷是好的，希望通过全方位多维度的研效指标，来度量研发效能各环节的质量，进而反推业务，提升研发效能。然而，最终在实践的过程中，才发现，客观条件并不支持（工具还没建设好）；此外，一味的追求指标数据，使得下面的人想方设法让指标好看，最终违背了初衷。&lt;/p></description></item><item><title>大白话带你认识 JVM</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/jvm-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/jvm-intro/</guid><description>&lt;blockquote>
&lt;p>来自&lt;a href="https://juejin.im/user/5c2400afe51d45451758aa96">说出你的愿望吧丷&lt;/a>投稿，原文地址：&lt;a href="https://juejin.im/post/5e1505d0f265da5d5d744050">https://juejin.im/post/5e1505d0f265da5d5d744050&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>如果在文中用词或者理解方面出现问题，欢迎指出。此文旨在提及而不深究，但会尽量效率地把知识点都抛出来&lt;/p>
&lt;h2 id="一jvm-的基本介绍">
 一、JVM 的基本介绍
 &lt;a class="anchor" href="#%e4%b8%80jvm-%e7%9a%84%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···&lt;/p>
&lt;p>好，其实抛开这么专业的句子不说，就知道 JVM 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/da/da0380a04d9c04facd2add5f6dba06fa.png" alt="" />&lt;/p>
&lt;h3 id="11-java-文件是如何被运行的">
 1.1 Java 文件是如何被运行的
 &lt;a class="anchor" href="#11-java-%e6%96%87%e4%bb%b6%e6%98%af%e5%a6%82%e4%bd%95%e8%a2%ab%e8%bf%90%e8%a1%8c%e7%9a%84">#&lt;/a>
&lt;/h3>
&lt;p>比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。&lt;/p>
&lt;p>那我们的 &lt;strong>JVM&lt;/strong> 是不认识文本文件的，所以它需要一个 &lt;strong>编译&lt;/strong> ，让其成为一个它会读二进制文件的 &lt;strong>HelloWorld.class&lt;/strong>&lt;/p>
&lt;h4 id="-类加载器">
 ① 类加载器
 &lt;a class="anchor" href="#-%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8">#&lt;/a>
&lt;/h4>
&lt;p>如果 &lt;strong>JVM&lt;/strong> 想要执行这个 &lt;strong>.class&lt;/strong> 文件，我们需要将其装进一个 &lt;strong>类加载器&lt;/strong> 中，它就像一个搬运工一样，会把所有的 &lt;strong>.class&lt;/strong> 文件全部搬进 JVM 里面来。&lt;/p>
&lt;p>&lt;img src="https://static001.geekbang.org/infoq/2f/2f012fde94376f43a25dbe1dd07e0dd8.png" alt="" />&lt;/p>
&lt;h4 id="-方法区">
 ② 方法区
 &lt;a class="anchor" href="#-%e6%96%b9%e6%b3%95%e5%8c%ba">#&lt;/a>
&lt;/h4>
&lt;p>&lt;strong>方法区&lt;/strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等&lt;/p>
&lt;p>类加载器将 .class 文件搬过来就是先丢到这一块上&lt;/p>
&lt;h4 id="-堆">
 ③ 堆
 &lt;a class="anchor" href="#-%e5%a0%86">#&lt;/a>
&lt;/h4>
&lt;p>&lt;strong>堆&lt;/strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 &lt;strong>线程共享区域&lt;/strong> 。也就是说它们都是 &lt;strong>线程不安全&lt;/strong> 的&lt;/p></description></item><item><title>代码命名指南</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/basis/naming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/basis/naming/</guid><description>&lt;p>我还记得我刚工作那一段时间， 项目 Code Review 的时候，我经常因为变量命名不规范而被 “diss”!&lt;/p>
&lt;p>究其原因还是自己那会经验不足，而且，大学那会写项目的时候不太注意这些问题，想着只要把功能实现出来就行了。&lt;/p>
&lt;p>但是，工作中就不一样，为了代码的可读性、可维护性，项目组对于代码质量的要求还是很高的！&lt;/p>
&lt;p>前段时间，项目组新来的一个实习生也经常在 Code Review 因为变量命名不规范而被 “diss”，这让我想到自己刚到公司写代码那会的日子。&lt;/p>
&lt;p>于是，我就简单写了这篇关于变量命名规范的文章，希望能对同样有此困扰的小伙伴提供一些帮助。&lt;/p>
&lt;p>确实，编程过程中，有太多太多让我们头疼的事情了，比如命名、维护其他人的代码、写测试、与其他人沟通交流等等。&lt;/p>
&lt;p>据说之前在 Quora 网站，由接近 5000 名程序员票选出来的最难的事情就是“命名”。&lt;/p>
&lt;p>大名鼎鼎的《重构》的作者老马（Martin Fowler）曾经在&lt;a href="https://martinfowler.com/bliki/TwoHardThings.html">TwoHardThings&lt;/a>这篇文章中提到过 CS 领域有两大最难的事情：一是 &lt;strong>缓存失效&lt;/strong> ，一是 &lt;strong>程序命名&lt;/strong> 。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/java-guide-blog/marting-naming.png" alt="" />&lt;/p>
&lt;p>这个句话实际上也是老马引用别人的，类似的表达还有很多。比如分布式系统领域有两大最难的事情：一是 &lt;strong>保证消息顺序&lt;/strong> ，一是 &lt;strong>严格一次传递&lt;/strong> 。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/java-guide-blog/20210629104844645.png" alt="" />&lt;/p>
&lt;p>今天咱们就单独拎出 “&lt;strong>命名&lt;/strong>” 来聊聊！&lt;/p>
&lt;p>这篇文章配合我之前发的 &lt;a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;amp;mid=2247486449&amp;amp;idx=1&amp;amp;sn=c3b502529ff991c7180281bcc22877af&amp;amp;chksm=cea2443af9d5cd2c1c87049ed15ccf6f88275419c7dbe542406166a703b27d0f3ecf2af901f8&amp;amp;token=999884676&amp;amp;lang=zh_CN#rd">《编码 5 分钟，命名 2 小时？史上最全的 Java 命名规范参考！》&lt;/a> 这篇文章阅读效果更佳哦！&lt;/p>
&lt;h2 id="为什么需要重视命名">
 为什么需要重视命名？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e9%87%8d%e8%a7%86%e5%91%bd%e5%90%8d">#&lt;/a>
&lt;/h2>
&lt;p>咱们需要先搞懂为什么要重视编程中的命名这一行为，它对于我们的编码工作有着什么意义。&lt;/p>
&lt;p>&lt;strong>为什么命名很重要呢？&lt;/strong> 这是因为 &lt;strong>好的命名即是注释，别人一看到你的命名就知道你的变量、方法或者类是做什么的！&lt;/strong>&lt;/p>
&lt;p>简单来说就是 &lt;strong>别人根据你的命名就能知道你的代码要表达的意思&lt;/strong> （不过，前提这个人也要有基本的英语知识，对于一些编程中常见的单词比较熟悉）。&lt;/p>
&lt;p>简单举个例子说明一下命名的重要性。&lt;/p>
&lt;p>《Clean Code》这本书明确指出：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。&lt;/strong>&lt;/p>
&lt;p>举个例子：&lt;/p>
&lt;p>去掉下面复杂的注释，只需要创建一个与注释所言同一事物的函数即可&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// check to see if the employee is eligible for full benefits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> ((employee.&lt;span style="color:#a6e22e">flags&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span> HOURLY_FLAG) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (employee.&lt;span style="color:#a6e22e">age&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> 65))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>应替换为&lt;/p></description></item><item><title>代码重构指南</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/basis/refactoring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/basis/refactoring/</guid><description>&lt;p>前段时间重读了&lt;a href="https://book.douban.com/subject/30468597/">《重构：改善代码既有设计》&lt;/a>，收货颇多。于是，简单写了一篇文章来聊聊我对重构的看法。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/image-20220311155746549.png" alt="" />&lt;/p>
&lt;h2 id="何谓重构">
 何谓重构？
 &lt;a class="anchor" href="#%e4%bd%95%e8%b0%93%e9%87%8d%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>学习重构必看的一本神书《重构：改善代码既有设计》从两个角度给出了重构的定义：&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。&lt;/li>
&lt;li>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>用更贴近工程师的语言来说：&lt;strong>重构就是利用设计模式(如组合模式、策略模式、责任链模式)、软件设计原则（如 SOLID 原则、YAGNI 原则、KISS 原则）和重构手段（如封装、继承、构建测试体系）来让代码更容易理解，更易于修改。&lt;/strong>&lt;/p>
&lt;p>软件设计原则指导着我们组织和规范代码，同时，重构也是为了能够尽量设计出尽量满足软件设计原则的软件。&lt;/p>
&lt;p>正确重构的核心在于 &lt;strong>步子一定要小，每一步的重构都不会影响软件的正常运行，可以随时停止重构。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>常见的设计模式如下&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/basis/common-design-patterns.png" alt="常见的设计模式" />&lt;/p>
&lt;p>更全面的设计模式总结，可以看 &lt;strong>&lt;a href="https://github.com/iluwatar/java-design-patterns">java-design-patterns&lt;/a>&lt;/strong> 这个开源项目。&lt;/p>
&lt;p>&lt;strong>常见的软件设计原则如下&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/basis/programming-principles.png" alt="常见的软件设计原则" />&lt;/p>
&lt;p>更全面的设计原则总结，可以看 &lt;strong>&lt;a href="https://github.com/iluwatar/java-design-patterns">java-design-patterns&lt;/a>&lt;/strong> 和 &lt;strong>&lt;a href="https://github.com/nusr/hacker-laws-zh">hacker-laws-zh&lt;/a>&lt;/strong> 这两个开源项目。&lt;/p>
&lt;h2 id="为什么要重构">
 为什么要重构？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e9%87%8d%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>在上面介绍重构定义的时候，我从比较抽象的角度介绍了重构的好处：重构的主要目的主要是提升代码&amp;amp;架构的灵活性/可扩展性以及复用性。&lt;/p>
&lt;p>如果对应到一个真实的项目，重构具体能为我们带来什么好处呢？&lt;/p>
&lt;ol>
&lt;li>&lt;strong>让代码更容易理解&lt;/strong>：通过添加注释、命名规范、逻辑优化等手段可以让我们的代码更容易被理解；&lt;/li>
&lt;li>&lt;strong>避免代码腐化&lt;/strong>：通过重构干掉坏味道代码；&lt;/li>
&lt;li>&lt;strong>加深对代码的理解&lt;/strong>：重构代码的过程会加深你对某部分代码的理解；&lt;/li>
&lt;li>&lt;strong>发现潜在 bug&lt;/strong>：是这样的，很多潜在的 bug ，都是我们在重构的过程中发现的；&lt;/li>
&lt;li>……&lt;/li>
&lt;/ol>
&lt;p>看了上面介绍的关于重构带来的好处之后，你会发现重构的最终目标是 &lt;strong>提高软件开发速度和质量&lt;/strong> 。&lt;/p>
&lt;p>重构并不会减慢软件开发速度，相反，如果代码质量和软件设计较差，当我们想要添加新功能的话，开发速度会越来越慢。到了最后，甚至都有想要重写整个系统的冲动。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/bad&amp;amp;good-design.png" alt="" />&lt;/p>
&lt;p>《重构：改善代码既有设计》这本书中这样说：&lt;/p>
&lt;blockquote>
&lt;p>重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。&lt;/p>
&lt;/blockquote>
&lt;h2 id="性能优化就是重构吗">
 性能优化就是重构吗？
 &lt;a class="anchor" href="#%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e5%b0%b1%e6%98%af%e9%87%8d%e6%9e%84%e5%90%97">#&lt;/a>
&lt;/h2>
&lt;p>重构的目的是提高代码的可读性、可维护性和灵活性，它关注的是代码的内部结构——如何让开发者更容易理解代码，如何让后续的功能开发和维护更加高效。而性能优化则是为了让代码运行得更快、占用更少的资源，它关注的是程序的外部表现——如何减少响应时间、降低资源消耗、提升系统吞吐量。这两者看似对立，但实际上它们的目标是统一的，都是为了提高软件的整体质量。&lt;/p>
&lt;p>在实际开发中，理想的做法是首先&lt;strong>确保代码的可读性和可维护性&lt;/strong>，然后根据实际需求选择合适的性能优化手段。优秀的软件设计不是一味追求性能最大化，而是要在可维护性和性能之间找到平衡。通过这种方式，我们可以打造既&lt;strong>易于管理&lt;/strong>又具有&lt;strong>良好性能&lt;/strong>的软件系统。&lt;/p>
&lt;h2 id="何时进行重构">
 何时进行重构？
 &lt;a class="anchor" href="#%e4%bd%95%e6%97%b6%e8%bf%9b%e8%a1%8c%e9%87%8d%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>重构在是开发过程中随时可以进行的，见机行事即可，并不需要单独分配一两天的时间专门用来重构。&lt;/p>
&lt;h3 id="提交代码之前">
 提交代码之前
 &lt;a class="anchor" href="#%e6%8f%90%e4%ba%a4%e4%bb%a3%e7%a0%81%e4%b9%8b%e5%89%8d">#&lt;/a>
&lt;/h3>
&lt;p>《重构：改善代码既有设计》这本书介绍了一个 &lt;strong>营地法则&lt;/strong> 的概念:&lt;/p>
&lt;blockquote>
&lt;p>编程时，需要遵循营地法则：保证你离开时的代码库一定比来时更健康。&lt;/p>
&lt;/blockquote>
&lt;p>这个概念表达的核心思想其实很简单：在你提交代码的之前，花一会时间想一想，我这次的提交是让项目代码变得更健康了，还是更腐化了，或者说没什么变化？&lt;/p>
&lt;p>项目团队的每一个人只有保证自己的提交没有让项目代码变得更腐化，项目代码才会朝着健康的方向发展。&lt;/p>
&lt;p>&lt;strong>当我们离开营地（项目代码）的时候，请不要留下垃圾（代码坏味道）！尽量确保营地变得更干净了！&lt;/strong>&lt;/p></description></item><item><title>单元测试到底是什么？应该怎么做？</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/basis/unit-test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/basis/unit-test/</guid><description>&lt;blockquote>
&lt;p>本文重构完善自&lt;a href="https://www.jianshu.com/p/fa41fb80d2b8">谈谈为什么写单元测试 - 键盘男 - 2016&lt;/a>这篇文章。&lt;/p>
&lt;/blockquote>
&lt;h2 id="何谓单元测试">
 何谓单元测试？
 &lt;a class="anchor" href="#%e4%bd%95%e8%b0%93%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h2>
&lt;p>维基百科是这样介绍单元测试的：&lt;/p>
&lt;blockquote>
&lt;p>在计算机编程中，单元测试（Unit Testing）是针对程序模块（软件设计的最小单位）进行的正确性检验测试工作。&lt;/p>
&lt;p>程序单元是应用的 &lt;strong>最小可测试部件&lt;/strong> 。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。&lt;/p>
&lt;/blockquote>
&lt;p>由于每个单元有独立的逻辑，在做单元测试时，为了隔离外部依赖，确保这些依赖不影响验证逻辑，我们经常会用到 Fake、Stub 与 Mock 。&lt;/p>
&lt;p>关于 Fake、Mock 与 Stub 这几个概念的解读，可以看看这篇文章：&lt;a href="https://zhuanlan.zhihu.com/p/26942686">测试中 Fakes、Mocks 以及 Stubs 概念明晰 - 王下邀月熊 - 2018&lt;/a> 。&lt;/p>
&lt;h2 id="为什么需要单元测试">
 为什么需要单元测试？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h2>
&lt;h3 id="为重构保驾护航">
 为重构保驾护航
 &lt;a class="anchor" href="#%e4%b8%ba%e9%87%8d%e6%9e%84%e4%bf%9d%e9%a9%be%e6%8a%a4%e8%88%aa">#&lt;/a>
&lt;/h3>
&lt;p>我在&lt;a href="./refactoring.md">重构&lt;/a>这篇文章中这样写到：&lt;/p>
&lt;blockquote>
&lt;p>单元测试可以为重构提供信心，降低重构的成本。我们要像重视生产代码那样，重视单元测试。&lt;/p>
&lt;/blockquote>
&lt;p>每个开发者都会经历重构，重构后把代码改坏了的情况并不少见，很可能你只是修改了一个很简单的方法就导致系统出现了一个比较严重的错误。&lt;/p>
&lt;p>如果有了单元测试的话，就不会存在这个隐患了。写完一个类，把单元测试写了，确保这个类逻辑正确；写第二个类，单元测试……写 100 个类，道理一样，每个类做到第一点“保证逻辑正确性”，100 个类拼在一起肯定不出问题。你大可以放心一边重构，一边运行 APP；而不是整体重构完，提心吊胆地 run。&lt;/p>
&lt;h3 id="提高代码质量">
 提高代码质量
 &lt;a class="anchor" href="#%e6%8f%90%e9%ab%98%e4%bb%a3%e7%a0%81%e8%b4%a8%e9%87%8f">#&lt;/a>
&lt;/h3>
&lt;p>由于每个单元有独立的逻辑，做单元测试时需要隔离外部依赖，确保这些依赖不影响验证逻辑。因为要把各种依赖分离，单元测试会促进工程进行组件拆分，整理工程依赖关系，更大程度减少代码耦合。这样写出来的代码，更好维护，更好扩展，从而提高代码质量。&lt;/p>
&lt;h3 id="减少-bug">
 减少 bug
 &lt;a class="anchor" href="#%e5%87%8f%e5%b0%91-bug">#&lt;/a>
&lt;/h3>
&lt;p>一个机器，由各种细小的零件组成，如果其中某件零件坏了，机器运行故障。必须保证每个零件都按设计图要求的规格，机器才能正常运行。&lt;/p>
&lt;p>一个可单元测试的工程，会把业务、功能分割成规模更小、有独立的逻辑部件，称为单元。单元测试的目标，就是保证各个单元的逻辑正确性。单元测试保障工程各个“零件”按“规格”（需求）执行，从而保证整个“机器”（项目）运行正确，最大限度减少 bug。&lt;/p>
&lt;h3 id="快速定位-bug">
 快速定位 bug
 &lt;a class="anchor" href="#%e5%bf%ab%e9%80%9f%e5%ae%9a%e4%bd%8d-bug">#&lt;/a>
&lt;/h3>
&lt;p>如果程序有 bug，我们运行一次全部单元测试，找到不通过的测试，可以很快地定位对应的执行代码。修复代码后，运行对应的单元测试；如还不通过，继续修改，运行测试……直到&lt;strong>测试通过&lt;/strong>。&lt;/p>
&lt;h3 id="持续集成依赖单元测试">
 持续集成依赖单元测试
 &lt;a class="anchor" href="#%e6%8c%81%e7%bb%ad%e9%9b%86%e6%88%90%e4%be%9d%e8%b5%96%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h3>
&lt;p>持续集成需要依赖单元测试，当持续集成服务自动构建新代码之后，会自动运行单元测试来发现代码错误。&lt;/p>
&lt;h2 id="谁逼你写单元测试">
 谁逼你写单元测试？
 &lt;a class="anchor" href="#%e8%b0%81%e9%80%bc%e4%bd%a0%e5%86%99%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95">#&lt;/a>
&lt;/h2>
&lt;h3 id="领导要求">
 领导要求
 &lt;a class="anchor" href="#%e9%a2%86%e5%af%bc%e8%a6%81%e6%b1%82">#&lt;/a>
&lt;/h3>
&lt;p>有些经验丰富的领导，或多或少都会要求团队写单元测试。对于有一定工作经验的队友，这要求挺合理；对于经验尚浅的、毕业生，恐怕要死要活了，连代码都写不好，还要写单元测试，are you kidding me？&lt;/p></description></item><item><title>滴滴和头条两年后端工作经验分享</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/two-years-of-back-end-develop--experience-in-didi-and-toutiao/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：很实用的工作经验分享，看完之后十分受用！&lt;/p>
&lt;p>&lt;strong>内容概览&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。&lt;/li>
&lt;li>积极学习，保持技术热情。如果我们积极学习，保持技术能力、知识储备与工作年限成正比，这到了 35 岁哪还有什么焦虑呢，这样的大牛我觉得应该也是各大公司抢着要吧？&lt;/li>
&lt;li>在能为公司办成事，创造价值这一点上，我觉得最重要的两个字就是主动，主动承担任务，主动沟通交流，主动推动项目进展，主动协调资源，主动向上反馈，主动创造影响力等等。&lt;/li>
&lt;li>脸皮要厚一点，多找人聊，快速融入，最忌讳有问题也不说，自己把自己孤立起来。&lt;/li>
&lt;li>想舔就舔，不想舔也没必要酸别人，Respect Greatness。&lt;/li>
&lt;li>时刻准备着，技术在手就没什么可怕的，哪天干得不爽了直接跳槽。&lt;/li>
&lt;li>平时积极总结沉淀，多跟别人交流，形成方法论。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://www.nowcoder.com/discuss/351805">https://www.nowcoder.com/discuss/351805&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>先简单交代一下背景吧，某不知名 985 的本硕，17 年毕业加入滴滴，当时找工作时候也是在牛客这里跟大家一起奋战的。今年下半年跳槽到了头条，一直从事后端研发相关的工作。之前没有实习经历，算是两年半的工作经验吧。这两年半之间完成了一次晋升，换了一家公司，有过开心满足的时光，也有过迷茫挣扎的日子，不过还算顺利地从一只职场小菜鸟转变为了一名资深划水员。在这个过程中，总结出了一些还算实用的划水经验，有些是自己领悟到的，有些是跟别人交流学到的，在这里跟大家分享一下。&lt;/p>
&lt;h2 id="学会深入思考总结沉淀">
 学会深入思考，总结沉淀
 &lt;a class="anchor" href="#%e5%ad%a6%e4%bc%9a%e6%b7%b1%e5%85%a5%e6%80%9d%e8%80%83%e6%80%bb%e7%bb%93%e6%b2%89%e6%b7%80">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>我想说的第一条就是要学会深入思考，总结沉淀，这是我觉得最重要也是最有意义的一件事。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>先来说深入思考。&lt;/strong> 在程序员这个圈子里，常能听到一些言论：&lt;em>“我这个工作一点技术含量都没有，每天就 CRUD，再写写 if-else，这 TM 能让我学到什么东西？”&lt;/em>&lt;/p>
&lt;p>抛开一部分调侃和戏谑的论调不谈，这可能确实是一部分同学的真实想法，至少曾经的我，就这么认为过。后来随着工作经验的积累，加上和一些高 level 的同学交流探讨之后，我发现这个想法其实是非常错误的。之所以出现没什么可学的这样的看法，基本上是思维懒惰的结果。&lt;strong>任何一件看起来很不起眼的小事，只要进行深入思考，稍微纵向挖深或者横向拓宽一下，都是足以让人沉溺的知识海洋。&lt;/strong>&lt;/p>
&lt;p>举一个例子。某次有个同学跟我说，这周有个服务 OOM 了，查了一周发现有个地方 defer 写的有问题，改了几行代码上线修复了，周报都没法写。可能大家也遇到过这样的场景，还算是有一定的代表性。其实就查 bug 这件事来说，是一个发现问题，排查问题，解决问题的过程，包含了触发、定位、复现、根因、修复、复盘等诸多步骤，花了一周来做这件事，一定有不断尝试与纠错的过程，这里面其实就有很多思考的空间。比如说定位，如何缩小范围的？走了哪些弯路？用了哪些分析工具？比如说根因，可以研究的点起码有 linux 的 OOM，k8s 的 OOM，go 的内存管理，defer 机制，函数闭包的原理等等。如果这些真的都不涉及，仍然花了一周时间做这件事，那复盘应该会有很多思考，提出来几十个 WHY 没问题吧&amp;hellip;&lt;/p>
&lt;p>&lt;strong>再来说下总结沉淀。&lt;/strong> 这个我觉得也是大多数程序员比较欠缺的地方，只顾埋头干活，可以把一件事做的很好。但是几乎从来不做抽象总结，以至于工作好几年了，所掌握的知识还是零星的几点，不成体系，不仅容易遗忘，而且造成自己视野比较窄，看问题比较局限。适时地做一些总结沉淀是很重要的，这是一个从术到道的过程，会让自己看问题的角度更广，层次更高。遇到同类型的问题，可以按照总结好的方法论，系统化、层次化地推进和解决。&lt;/p>
&lt;p>还是举一个例子。做后台服务，今天优化了 1G 内存，明天优化了 50%的读写耗时，是不是可以做一下性能优化的总结？比如说在应用层，可以管理服务对接的应用方，梳理他们访问的合理性；在架构层，可以做缓存、预处理、读写分离、异步、并行等等；在代码层，可以做的事情更多了，资源池化、对象复用、无锁化设计、大 key 拆分、延迟处理、编码压缩、gc 调优还有各种语言相关的高性能实践&amp;hellip;等下次再遇到需要性能优化的场景，一整套思路立马就能套用过来了，剩下的就是工具和实操的事儿了。&lt;/p>
&lt;p>还有的同学说了，我就每天跟 PM 撕撕逼，做做需求，也不做性能优化啊。先不讨论是否可以搞性能优化，单就做业务需求来讲，也有可以总结的地方。比如说，如何做系统建设？系统核心能力，系统边界，系统瓶颈，服务分层拆分，服务治理这些问题有思考过吗？每天跟 PM 讨论需求，那作为技术同学该如何培养产品思维，引导产品走向，如何做到架构先行于业务，这些问题也是可以思考和总结的吧。就想一下，连接手维护别人烂代码这种蛋疼的事情，都能让 Martin Fowler 整出来一套重构理论，还显得那么高大上，我们确实也没啥必要对自己的工作妄自菲薄&amp;hellip;&lt;/p>
&lt;p>所以说：&lt;strong>学习和成长是一个自驱的过程，如果觉得没什么可学的，大概率并不是真的没什么可学的，而是因为自己太懒了，不仅是行动上太懒了，思维上也太懒了。可以多写技术文章，多分享，强迫自己去思考和总结，毕竟如果文章深度不够，大家也不好意思公开分享。&lt;/strong>&lt;/p>
&lt;h2 id="积极学习保持技术热情">
 积极学习，保持技术热情
 &lt;a class="anchor" href="#%e7%a7%af%e6%9e%81%e5%ad%a6%e4%b9%a0%e4%bf%9d%e6%8c%81%e6%8a%80%e6%9c%af%e7%83%ad%e6%83%85">#&lt;/a>
&lt;/h2>
&lt;p>最近两年在互联网圈里广泛传播的一种焦虑论叫做 35 岁程序员现象，大意是说程序员这个行业干到 35 岁就基本等着被裁员了。不可否认，互联网行业在这一点上确实不如公务员等体制内职业。但是，这个问题里 35 岁程序员并不是绝对生理意义上的 35 岁，应该是指那些工作十几年和工作两三年没什么太大区别的程序员。后面的工作基本是在吃老本，没有主动学习与充电，35 岁和 25 岁差不多，而且没有了 25 岁时对学习成长的渴望，反而添了家庭生活的诸多琐事，薪资要求往往也较高，在企业看来这确实是没什么竞争力。&lt;/p></description></item><item><title>读写分离和分库分表详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/read-and-write-separation-and-library-subtable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/read-and-write-separation-and-library-subtable/</guid><description>&lt;h2 id="读写分离">
 读写分离
 &lt;a class="anchor" href="#%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是读写分离">
 什么是读写分离？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb">#&lt;/a>
&lt;/h3>
&lt;p>见名思意，根据读写分离的名字，我们就可以知道：&lt;strong>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。&lt;/strong> 这样的话，就能够小幅提升写性能，大幅提升读性能。&lt;/p>
&lt;p>我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation.png" alt="读写分离示意图" />&lt;/p>
&lt;p>一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。&lt;/p>
&lt;h3 id="如何实现读写分离">
 如何实现读写分离？
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb">#&lt;/a>
&lt;/h3>
&lt;p>不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：&lt;/p>
&lt;ol>
&lt;li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。&lt;/li>
&lt;li>保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的&lt;strong>主从复制&lt;/strong>。&lt;/li>
&lt;li>系统将写请求交给主数据库处理，读请求交给从数据库处理。&lt;/li>
&lt;/ol>
&lt;p>落实到项目本身的话，常用的方式有两种：&lt;/p>
&lt;p>&lt;strong>1. 代理方式&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation-proxy.png" alt="代理方式实现读写分离" />&lt;/p>
&lt;p>我们可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。&lt;/p>
&lt;p>提供类似功能的中间件有 &lt;strong>MySQL Router&lt;/strong>（官方， MySQL Proxy 的替代方案）、&lt;strong>Atlas&lt;/strong>（基于 MySQL Proxy）、&lt;strong>MaxScale&lt;/strong>、&lt;strong>MyCat&lt;/strong>。&lt;/p>
&lt;p>关于 MySQL Router 多提一点：在 MySQL 8.2 的版本中，MySQL Router 能自动分辨对数据库读写/操作并把这些操作路由到正确的实例上。这是一项有价值的功能，可以优化数据库性能和可扩展性，而无需在应用程序中进行任何更改。具体介绍可以参考官方博客：&lt;a href="https://blogs.oracle.com/mysql/post/mysql-82-transparent-readwrite-splitting">MySQL 8.2 – transparent read/write splitting&lt;/a>。&lt;/p>
&lt;p>&lt;strong>2. 组件方式&lt;/strong>&lt;/p>
&lt;p>在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。&lt;/p>
&lt;p>这也是我比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 &lt;code>sharding-jdbc&lt;/code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。&lt;/p>
&lt;p>你可以在 shardingsphere 官方找到 &lt;a href="https://shardingsphere.apache.org/document/legacy/3.x/document/cn/manual/sharding-jdbc/usage/read-write-splitting/">sharding-jdbc 关于读写分离的操作&lt;/a>。&lt;/p>
&lt;h3 id="主从复制原理是什么">
 主从复制原理是什么？
 &lt;a class="anchor" href="#%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>MySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。&lt;/p></description></item><item><title>泛型&amp;通配符详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/generics-and-wildcards/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/basis/generics-and-wildcards/</guid><description>&lt;p>&lt;strong>泛型&amp;amp;通配符&lt;/strong> 相关的面试题为我的&lt;a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了&lt;a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》&lt;/a>（点击链接即可查看详细介绍以及获取方法）中。&lt;/p>
&lt;p>&lt;a href="hhttps://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》&lt;/a> 的部分内容展示如下，你可以将其看作是 &lt;a href="https://javaguide.cn/#/">JavaGuide&lt;/a> 的补充完善，两者可以配合使用。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/xingqiu/image-20220304102536445.png" alt="" />&lt;/p>
&lt;p>&lt;a href="hhttps://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》&lt;/a>只是星球内部众多资料中的一个，星球还有很多其他优质资料比如&lt;a href="https://javaguide.cn/zhuanlan/">专属专栏&lt;/a>、Java 编程视频、PDF 资料。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/xingqiu/image-20220211231206733.png" alt="" />&lt;/p></description></item><item><title>访问网页的全过程（知识串联）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/the-whole-process-of-accessing-web-pages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/the-whole-process-of-accessing-web-pages/</guid><description>&lt;p>开发岗中总是会考很多计算机网络的知识点，但如果让面试官只考一道题，便涵盖最多的计网知识点，那可能就是 &lt;strong>网页浏览的全过程&lt;/strong> 了。本篇文章将带大家从头到尾过一遍这道被考烂的面试题，必会！！！&lt;/p>
&lt;p>总的来说，网络通信模型可以用下图来表示，也就是大家只要熟记网络结构五层模型，按照这个体系，很多知识点都能顺出来了。访问网页的过程也是如此。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/five-layers.png" alt="" />&lt;/p>
&lt;p>开始之前，我们先简单过一遍完整流程：&lt;/p>
&lt;ol>
&lt;li>在浏览器中输入指定网页的 URL。&lt;/li>
&lt;li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。&lt;/li>
&lt;li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。&lt;/li>
&lt;li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。&lt;/li>
&lt;li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。&lt;/li>
&lt;li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。&lt;/li>
&lt;li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。&lt;/li>
&lt;/ol>
&lt;h2 id="应用层">
 应用层
 &lt;a class="anchor" href="#%e5%ba%94%e7%94%a8%e5%b1%82">#&lt;/a>
&lt;/h2>
&lt;p>一切的开始——打开浏览器，在地址栏输入 URL，回车确认。那么，什么是 URL？访问 URL 有什么用？&lt;/p>
&lt;h3 id="url">
 URL
 &lt;a class="anchor" href="#url">#&lt;/a>
&lt;/h3>
&lt;p>URL（Uniform Resource Locators），即统一资源定位器。网络上的所有资源都靠 URL 来定位，每一个文件就对应着一个 URL，就像是路径地址。理论上，文件资源和 URL 一一对应。实际上也有例外，比如某些 URL 指向的文件已经被重定位到另一个位置，这样就有多个 URL 指向同一个文件。&lt;/p>
&lt;h3 id="url-的组成结构">
 URL 的组成结构
 &lt;a class="anchor" href="#url-%e7%9a%84%e7%bb%84%e6%88%90%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/URL-parts.png" alt="URL的组成结构" />&lt;/p></description></item><item><title>分布式ID介绍&amp;实现方案总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-id/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-id/</guid><description>&lt;h2 id="分布式-id-介绍">
 分布式 ID 介绍
 &lt;a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f-id-%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;h3 id="什么是-id">
 什么是 ID？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-id">#&lt;/a>
&lt;/h3>
&lt;p>日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。&lt;/p>
&lt;p>我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人、地址 ID 对应且仅对应一个地址。&lt;/p>
&lt;p>简单来说，&lt;strong>ID 就是数据的唯一标识&lt;/strong>。&lt;/p>
&lt;h3 id="什么是分布式-id">
 什么是分布式 ID？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%88%86%e5%b8%83%e5%bc%8f-id">#&lt;/a>
&lt;/h3>
&lt;p>分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。&lt;/p>
&lt;p>我简单举一个分库分表的例子。&lt;/p>
&lt;p>我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 Sharding-JDBC）。&lt;/p>
&lt;p>在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。&lt;strong>我们如何为不同的数据节点生成全局唯一主键呢？&lt;/strong>&lt;/p>
&lt;p>这个时候就需要生成&lt;strong>分布式 ID&lt;/strong>了。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/id-after-the-sub-table-not-conflict.png" alt="" />&lt;/p>
&lt;h3 id="分布式-id-需要满足哪些要求">
 分布式 ID 需要满足哪些要求?
 &lt;a class="anchor" href="#%e5%88%86%e5%b8%83%e5%bc%8f-id-%e9%9c%80%e8%a6%81%e6%bb%a1%e8%b6%b3%e5%93%aa%e4%ba%9b%e8%a6%81%e6%b1%82">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-requirements.png" alt="" />&lt;/p>
&lt;p>分布式 ID 作为分布式系统中必不可少的一环，很多地方都要用到分布式 ID。&lt;/p>
&lt;p>一个最基本的分布式 ID 需要满足下面这些要求：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>全局唯一&lt;/strong>：ID 的全局唯一性肯定是首先要满足的！&lt;/li>
&lt;li>&lt;strong>高性能&lt;/strong>：分布式 ID 的生成速度要快，对本地资源消耗要小。&lt;/li>
&lt;li>&lt;strong>高可用&lt;/strong>：生成分布式 ID 的服务要保证可用性无限接近于 100%。&lt;/li>
&lt;li>&lt;strong>方便易用&lt;/strong>：拿来即用，使用方便，快速接入！&lt;/li>
&lt;/ul>
&lt;p>除了这些之外，一个比较好的分布式 ID 还应保证：&lt;/p></description></item><item><title>分布式ID设计指南</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-id-design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-id-design/</guid><description>&lt;p>::: tip&lt;/p>
&lt;p>看到百度 Geek 说的一篇结合具体场景聊分布式 ID 设计的文章，感觉挺不错的。于是，我将这篇文章的部分内容整理到了这里。原文传送门：&lt;a href="https://mp.weixin.qq.com/s/bFDLb6U6EgI-DvCdLTq_QA">分布式 ID 生成服务的技术原理和项目实战&lt;/a> 。&lt;/p>
&lt;p>:::&lt;/p>
&lt;p>网上绝大多数的分布式 ID 生成服务，一般着重于技术原理剖析，很少见到根据具体的业务场景去选型 ID 生成服务的文章。&lt;/p>
&lt;p>本文结合一些使用场景，进一步探讨业务场景中对 ID 有哪些具体的要求。&lt;/p>
&lt;h2 id="场景一订单系统">
 场景一：订单系统
 &lt;a class="anchor" href="#%e5%9c%ba%e6%99%af%e4%b8%80%e8%ae%a2%e5%8d%95%e7%b3%bb%e7%bb%9f">#&lt;/a>
&lt;/h2>
&lt;p>我们在商场买东西一码付二维码，下单生成的订单号，使用到的优惠券码，联合商品兑换券码，这些是在网上购物经常使用到的单号，那么为什么有些单号那么长，有些只有几位数？有些单号一看就知道年月日的信息，有些却看不出任何意义？下面展开分析下订单系统中不同场景的 id 服务的具体实现。&lt;/p>
&lt;h3 id="1一码付">
 1、一码付
 &lt;a class="anchor" href="#1%e4%b8%80%e7%a0%81%e4%bb%98">#&lt;/a>
&lt;/h3>
&lt;p>我们常见的一码付，指的是一个二维码可以使用支付宝或者微信进行扫码支付。&lt;/p>
&lt;p>二维码的本质是一个字符串。聚合码的本质就是一个链接地址。用户使用支付宝微信直接扫一个码付钱，不用担心拿支付宝扫了微信的收款码或者用微信扫了支付宝的收款码，这极大减少了用户扫码支付的时间。&lt;/p>
&lt;p>实现原理是当客户用 APP 扫码后，网站后台就会判断客户的扫码环境。（微信、支付宝、QQ 钱包、京东支付、云闪付等）。&lt;/p>
&lt;p>判断扫码环境的原理就是根据打开链接浏览器的 HTTP header。任何浏览器打开 http 链接时，请求的 header 都会有 User-Agent(UA、用户代理)信息。&lt;/p>
&lt;p>UA 是一个特殊字符串头，服务器依次可以识别出客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等很多信息。&lt;/p>
&lt;p>各渠道对应支付产品的名称不一样，一定要仔细看各支付产品的 API 介绍。&lt;/p>
&lt;ol>
&lt;li>微信支付：JSAPI 支付支付&lt;/li>
&lt;li>支付宝：手机网站支付&lt;/li>
&lt;li>QQ 钱包：公众号支付&lt;/li>
&lt;/ol>
&lt;p>其本质均为在 APP 内置浏览器中实现 HTML5 支付。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/distributed-system/distributed-id-design-pay-one-card.png" alt="文库会员支付示例" />&lt;/p>
&lt;p>文库的研发同学在这个思路上，做了优化迭代。动态生成一码付的二维码预先绑定用户所选的商品信息和价格，根据用户所选的商品动态更新。这样不仅支持一码多平台调起支付，而且不用用户选择商品输入金额，即可完成订单支付的功能，很丝滑。用户在真正扫码后，服务端才通过前端获取用户 UID，结合二维码绑定的商品信息，真正的生成订单，发送支付信息到第三方（qq、微信、支付宝），第三方生成支付订单推给用户设备，从而调起支付。&lt;/p>
&lt;p>区别于固定的一码付，在文库的应用中，使用到了动态二维码，二维码本质是一个短网址，ID 服务提供短网址的唯一标志参数。唯一的短网址映射的 ID 绑定了商品的订单信息，技术和业务的深度结合，缩短了支付流程，提升用户的支付体验。&lt;/p>
&lt;h3 id="2订单号">
 2、订单号
 &lt;a class="anchor" href="#2%e8%ae%a2%e5%8d%95%e5%8f%b7">#&lt;/a>
&lt;/h3>
&lt;p>订单号在实际的业务过程中作为一个订单的唯一标识码存在，一般实现以下业务场景：&lt;/p>
&lt;ol>
&lt;li>用户订单遇到问题，需要找客服进行协助；&lt;/li>
&lt;li>对订单进行操作，如线下收款，订单核销；&lt;/li>
&lt;li>下单，改单，成单，退单，售后等系统内部的订单流程处理和跟进。&lt;/li>
&lt;/ol>
&lt;p>很多时候搜索订单相关信息的时候都是以订单 ID 作为唯一标识符，这是由于订单号的生成规则的唯一性决定的。从技术角度看，除了 ID 服务必要的特性之外，在订单号的设计上需要体现几个特性：&lt;/p></description></item><item><title>分布式配置中心常见问题总结(付费)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-configuration-center/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-configuration-center/</guid><description>&lt;p>&lt;strong>分布式配置中心&lt;/strong> 相关的面试题为我的&lt;a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/javamianshizhibei/distributed-system.png" alt="" />&lt;/p></description></item><item><title>分布式事务常见解决方案总结(付费)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-transaction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-transaction/</guid><description>&lt;p>&lt;strong>分布式事务&lt;/strong> 相关的面试题为我的&lt;a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》中。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/javamianshizhibei/distributed-system.png" alt="" />&lt;/p></description></item><item><title>分布式锁常见实现方案总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-lock-implementations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-lock-implementations/</guid><description>&lt;p>通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁，Redis 用的要更多一点，我这里也先以 Redis 为例介绍分布式锁的实现。&lt;/p>
&lt;h2 id="基于-redis-实现分布式锁">
 基于 Redis 实现分布式锁
 &lt;a class="anchor" href="#%e5%9f%ba%e4%ba%8e-redis-%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81">#&lt;/a>
&lt;/h2>
&lt;h3 id="如何基于-redis-实现一个最简易的分布式锁">
 如何基于 Redis 实现一个最简易的分布式锁？
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e5%9f%ba%e4%ba%8e-redis-%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e6%9c%80%e7%ae%80%e6%98%93%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81">#&lt;/a>
&lt;/h3>
&lt;p>不论是本地锁还是分布式锁，核心都在于“互斥”。&lt;/p>
&lt;p>在 Redis 中， &lt;code>SETNX&lt;/code> 命令是可以帮助我们实现互斥。&lt;code>SETNX&lt;/code> 即 &lt;strong>SET&lt;/strong> if &lt;strong>N&lt;/strong>ot e&lt;strong>X&lt;/strong>ists (对应 Java 中的 &lt;code>setIfAbsent&lt;/code> 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， &lt;code>SETNX&lt;/code> 啥也不做。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&amp;gt; SETNX lockKey uniqueValue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>integer&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt; SETNX lockKey uniqueValue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>integer&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>释放锁的话，直接通过 &lt;code>DEL&lt;/code> 命令删除对应的 key 即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&amp;gt; DEL lockKey
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">(&lt;/span>integer&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。&lt;/p>
&lt;p>选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。&lt;/p></description></item><item><title>分布式锁介绍</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/distributed-lock/</guid><description>&lt;p>网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。&lt;/p>
&lt;p>这篇文章我们先介绍一下分布式锁的基本概念。&lt;/p>
&lt;h2 id="为什么需要分布式锁">
 为什么需要分布式锁？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81">#&lt;/a>
&lt;/h2>
&lt;p>在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。&lt;/p>
&lt;p>举个例子，假设现在有 100 个用户参与某个限时秒杀活动，每位用户限购 1 件商品，且商品的数量只有 3 个。如果不对共享资源进行互斥访问，就可能出现以下情况：&lt;/p>
&lt;ul>
&lt;li>线程 1、2、3 等多个线程同时进入抢购方法，每一个线程对应一个用户。&lt;/li>
&lt;li>线程 1 查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。&lt;/li>
&lt;li>线程 2 也执行查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。&lt;/li>
&lt;li>线程 1 继续执行，将库存数量减少 1 个，然后返回成功。&lt;/li>
&lt;li>线程 2 继续执行，将库存数量减少 1 个，然后返回成功。&lt;/li>
&lt;li>此时就发生了超卖问题，导致商品被多卖了一份。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/oversold-without-locking.png" alt="共享资源未互斥访问导致出现问题" />&lt;/p>
&lt;p>为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，即同一时刻只允许一个线程访问共享资源，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。&lt;/p>
&lt;p>&lt;strong>如何才能实现共享资源的互斥访问呢？&lt;/strong> 锁是一个比较通用的解决方案，更准确点来说是悲观锁。&lt;/p>
&lt;p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，&lt;strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程&lt;/strong>。&lt;/p>
&lt;p>对于单机多线程来说，在 Java 中，我们通常使用 &lt;code>ReentrantLock&lt;/code> 类、&lt;code>synchronized&lt;/code> 关键字这类 JDK 自带的 &lt;strong>本地锁&lt;/strong> 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。&lt;/p>
&lt;p>下面是我对本地锁画的一张示意图。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/jvm-local-lock.png" alt="本地锁" />&lt;/p>
&lt;p>从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。&lt;/p>
&lt;p>分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，&lt;strong>分布式锁&lt;/strong> 就诞生了。&lt;/p>
&lt;p>举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。&lt;/p></description></item><item><title>服务限流详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-availability/limit-request/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-availability/limit-request/</guid><description>&lt;p>针对软件系统来说，限流就是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。毕竟，软件系统的处理能力是有限的。如果说超过了其处理能力的范围，软件系统可能直接就挂掉了。&lt;/p>
&lt;p>限流可能会导致用户的请求无法被正确处理或者无法立即被处理，不过，这往往也是权衡了软件系统的稳定性之后得到的最优解。&lt;/p>
&lt;p>现实生活中，处处都有限流的实际应用，就比如排队买票是为了避免大量用户涌入购票而导致售票员无法处理。&lt;/p>
&lt;h2 id="常见限流算法有哪些">
 常见限流算法有哪些？
 &lt;a class="anchor" href="#%e5%b8%b8%e8%a7%81%e9%99%90%e6%b5%81%e7%ae%97%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b">#&lt;/a>
&lt;/h2>
&lt;p>简单介绍 4 种非常好理解并且容易实现的限流算法！&lt;/p>
&lt;blockquote>
&lt;p>图片来源于 InfoQ 的一篇文章&lt;a href="https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673">《分布式服务限流实战，已经为你排好坑了》&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h3 id="固定窗口计数器算法">
 固定窗口计数器算法
 &lt;a class="anchor" href="#%e5%9b%ba%e5%ae%9a%e7%aa%97%e5%8f%a3%e8%ae%a1%e6%95%b0%e5%99%a8%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h3>
&lt;p>固定窗口其实就是时间窗口，其原理是将时间划分为固定大小的窗口，在每个窗口内限制请求的数量或速率，即固定窗口计数器算法规定了系统单位时间处理的请求数量。&lt;/p>
&lt;p>假如我们规定系统中某个接口 1 分钟只能被访问 33 次的话，使用固定窗口计数器算法的实现思路如下：&lt;/p>
&lt;ul>
&lt;li>将时间划分固定大小窗口，这里是 1 分钟一个窗口。&lt;/li>
&lt;li>给定一个变量 &lt;code>counter&lt;/code> 来记录当前接口处理的请求数量，初始值为 0（代表接口当前 1 分钟内还未处理请求）。&lt;/li>
&lt;li>1 分钟之内每处理一个请求之后就将 &lt;code>counter+1&lt;/code> ，当 &lt;code>counter=33&lt;/code> 之后（也就是说在这 1 分钟内接口已经被访问 33 次的话），后续的请求就会被全部拒绝。&lt;/li>
&lt;li>等到 1 分钟结束后，将 &lt;code>counter&lt;/code> 重置 0，重新开始计数。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://static001.infoq.cn/resource/image/8d/15/8ded7a2b90e1482093f92fff555b3615.png" alt="固定窗口计数器算法" />&lt;/p>
&lt;p>优点：实现简单，易于理解。&lt;/p>
&lt;p>缺点：&lt;/p>
&lt;ul>
&lt;li>限流不够平滑。例如，我们限制某个接口每分钟只能访问 30 次，假设前 30 秒就有 30 个请求到达的话，那后续 30 秒将无法处理请求，这是不可取的，用户体验极差！&lt;/li>
&lt;li>无法保证限流速率，因而无法应对突然激增的流量。例如，我们限制某个接口 1 分钟只能访问 1000 次，该接口的 QPS 为 500，前 55s 这个接口 1 个请求没有接收，后 1s 突然接收了 1000 个请求。然后，在当前场景下，这 1000 个请求在 1s 内是没办法被处理的，系统直接就被瞬时的大量请求给击垮了。&lt;/li>
&lt;/ul>
&lt;h3 id="滑动窗口计数器算法">
 滑动窗口计数器算法
 &lt;a class="anchor" href="#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e8%ae%a1%e6%95%b0%e5%99%a8%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>滑动窗口计数器算法&lt;/strong> 算的上是固定窗口计数器算法的升级版，限流的颗粒度更小。&lt;/p></description></item><item><title>负载均衡原理及算法详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/load-balancing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/load-balancing/</guid><description>&lt;h2 id="什么是负载均衡">
 什么是负载均衡？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>负载均衡&lt;/strong> 指的是将用户请求分摊到不同的服务器上处理，以提高系统整体的并发处理能力以及可靠性。负载均衡服务可以有由专门的软件或者硬件来完成，一般情况下，硬件的性能更好，软件的价格更便宜（后文会详细介绍到）。&lt;/p>
&lt;p>下图是&lt;a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;amp;mid=2247519384&amp;amp;idx=1&amp;amp;sn=bc7e71af75350b755f04ca4178395b1a&amp;amp;chksm=cea1c353f9d64a458f797696d4144b4d6e58639371a4612b8e4d106d83a66d2289e7b2cd7431&amp;amp;token=660789642&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect">《Java 面试指北》&lt;/a> 「高并发篇」中的一篇文章的配图，从图中可以看出，系统的商品服务部署了多份在不同的服务器上，为了实现访问商品服务请求的分流，我们用到了负载均衡。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/load-balancing/multi-service-load-balancing.drawio.png" alt="多服务实例-负载均衡" />&lt;/p>
&lt;p>负载均衡是一种比较常用且实施起来较为简单的提高系统并发能力和可靠性的手段，不论是单体架构的系统还是微服务架构的系统几乎都会用到。&lt;/p>
&lt;h2 id="负载均衡分为哪几种">
 负载均衡分为哪几种？
 &lt;a class="anchor" href="#%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e5%88%86%e4%b8%ba%e5%93%aa%e5%87%a0%e7%a7%8d">#&lt;/a>
&lt;/h2>
&lt;p>负载均衡可以简单分为 &lt;strong>服务端负载均衡&lt;/strong> 和 &lt;strong>客户端负载均衡&lt;/strong> 这两种。&lt;/p>
&lt;p>服务端负载均衡涉及到的知识点更多，工作中遇到的也比较多，因此，我会花更多时间来介绍。&lt;/p>
&lt;h3 id="服务端负载均衡">
 服务端负载均衡
 &lt;a class="anchor" href="#%e6%9c%8d%e5%8a%a1%e7%ab%af%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>服务端负载均衡&lt;/strong> 主要应用在 &lt;strong>系统外部请求&lt;/strong> 和 &lt;strong>网关层&lt;/strong> 之间，可以使用 &lt;strong>软件&lt;/strong> 或者 &lt;strong>硬件&lt;/strong> 实现。&lt;/p>
&lt;p>下图是我画的一个简单的基于 Nginx 的服务端负载均衡示意图：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/load-balancing/server-load-balancing.png" alt="基于 Nginx 的服务端负载均衡" />&lt;/p>
&lt;p>&lt;strong>硬件负载均衡&lt;/strong> 通过专门的硬件设备（比如 &lt;strong>F5、A10、Array&lt;/strong> ）实现负载均衡功能。&lt;/p>
&lt;p>硬件负载均衡的优势是性能很强且稳定，缺点就是实在是太贵了。像基础款的 F5 最低也要 20 多万，绝大部分公司是根本负担不起的，业务量不大的话，真没必要非要去弄个硬件来做负载均衡，用软件负载均衡就足够了！&lt;/p>
&lt;p>在我们日常开发中，一般很难接触到硬件负载均衡，接触的比较多的还是 &lt;strong>软件负载均衡&lt;/strong> 。软件负载均衡通过软件（比如 &lt;strong>LVS、Nginx、HAproxy&lt;/strong> ）实现负载均衡功能，性能虽然差一些，但价格便宜啊！像基础款的 Linux 服务器也就几千，性能好一点的 2~3 万的就很不错了。&lt;/p>
&lt;p>根据 OSI 模型，服务端负载均衡还可以分为：&lt;/p>
&lt;ul>
&lt;li>二层负载均衡&lt;/li>
&lt;li>三层负载均衡&lt;/li>
&lt;li>四层负载均衡&lt;/li>
&lt;li>七层负载均衡&lt;/li>
&lt;/ul>
&lt;p>最常见的是四层和七层负载均衡，因此，本文也是重点介绍这两种负载均衡。&lt;/p>
&lt;blockquote>
&lt;p>Nginx 官网对四层负载和七层负载均衡均衡做了详细介绍，感兴趣的可以看看。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/">What Is Layer 4 Load Balancing?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.nginx.com/resources/glossary/layer-7-load-balancing/">What Is Layer 7 Load Balancing?&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型" />&lt;/p></description></item><item><title>高可用系统设计指南</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-availability/high-availability-system-design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-availability/high-availability-system-design/</guid><description>&lt;h2 id="什么是高可用可用性的判断标准是啥">
 什么是高可用？可用性的判断标准是啥？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e9%ab%98%e5%8f%af%e7%94%a8%e5%8f%af%e7%94%a8%e6%80%a7%e7%9a%84%e5%88%a4%e6%96%ad%e6%a0%87%e5%87%86%e6%98%af%e5%95%a5">#&lt;/a>
&lt;/h2>
&lt;p>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。&lt;/p>
&lt;p>一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。&lt;/p>
&lt;p>除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。&lt;/p>
&lt;h2 id="哪些情况会导致系统不可用">
 哪些情况会导致系统不可用？
 &lt;a class="anchor" href="#%e5%93%aa%e4%ba%9b%e6%83%85%e5%86%b5%e4%bc%9a%e5%af%bc%e8%87%b4%e7%b3%bb%e7%bb%9f%e4%b8%8d%e5%8f%af%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>黑客攻击；&lt;/li>
&lt;li>硬件故障，比如服务器坏掉。&lt;/li>
&lt;li>并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。&lt;/li>
&lt;li>代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。&lt;/li>
&lt;li>网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。&lt;/li>
&lt;li>自然灾害或者人为破坏。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ol>
&lt;h2 id="有哪些提高系统可用性的方法">
 有哪些提高系统可用性的方法？
 &lt;a class="anchor" href="#%e6%9c%89%e5%93%aa%e4%ba%9b%e6%8f%90%e9%ab%98%e7%b3%bb%e7%bb%9f%e5%8f%af%e7%94%a8%e6%80%a7%e7%9a%84%e6%96%b9%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;h3 id="注重代码质量测试严格把关">
 注重代码质量，测试严格把关
 &lt;a class="anchor" href="#%e6%b3%a8%e9%87%8d%e4%bb%a3%e7%a0%81%e8%b4%a8%e9%87%8f%e6%b5%8b%e8%af%95%e4%b8%a5%e6%a0%bc%e6%8a%8a%e5%85%b3">#&lt;/a>
&lt;/h3>
&lt;p>我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！&lt;/p>
&lt;p>另外，安利几个对提高代码质量有实际效果的神器：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.sonarqube.org/">Sonarqube&lt;/a>；&lt;/li>
&lt;li>Alibaba 开源的 Java 诊断工具 &lt;a href="https://arthas.aliyun.com/doc/">Arthas&lt;/a>；&lt;/li>
&lt;li>&lt;a href="https://github.com/alibaba/p3c">阿里巴巴 Java 代码规范&lt;/a>（Alibaba Java Code Guidelines）；&lt;/li>
&lt;li>IDEA 自带的代码分析等工具。&lt;/li>
&lt;/ul>
&lt;h3 id="使用集群减少单点故障">
 使用集群，减少单点故障
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8%e9%9b%86%e7%be%a4%e5%87%8f%e5%b0%91%e5%8d%95%e7%82%b9%e6%95%85%e9%9a%9c">#&lt;/a>
&lt;/h3>
&lt;p>先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例挂了，不到一秒就会有另外一台 Redis 实例顶上。&lt;/p></description></item><item><title>给想成长为高级别开发同学的七条建议</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/seven-tips-for-becoming-an-advanced-programmer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/seven-tips-for-becoming-an-advanced-programmer/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：普通程序员要想成长为高级程序员甚至是专家等更高级别，应该注意在哪些方面注意加强？开发内功修炼号主飞哥在这篇文章中就给出了七条实用的建议。&lt;/p>
&lt;p>&lt;strong>内容概览&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>刻意加强需求评审能力&lt;/li>
&lt;li>主动思考效率&lt;/li>
&lt;li>加强内功能力&lt;/li>
&lt;li>思考性能&lt;/li>
&lt;li>重视线上&lt;/li>
&lt;li>关注全局&lt;/li>
&lt;li>归纳总结能力&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://mp.weixin.qq.com/s/8lMGzBzXine-NAsqEaIE4g">https://mp.weixin.qq.com/s/8lMGzBzXine-NAsqEaIE4g&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="建议-1刻意加强需求评审能力">
 建议 1：刻意加强需求评审能力
 &lt;a class="anchor" href="#%e5%bb%ba%e8%ae%ae-1%e5%88%bb%e6%84%8f%e5%8a%a0%e5%bc%ba%e9%9c%80%e6%b1%82%e8%af%84%e5%ae%a1%e8%83%bd%e5%8a%9b">#&lt;/a>
&lt;/h3>
&lt;p>先从需求评审开始说。在互联网公司，需求评审是开发工作的主要入口。&lt;/p>
&lt;p>对于普通程序员来说，一般就是根据产品经理提的需求细节，开始设想这个功能要怎么实现，开发成本大概需要多长时间。把自己当成了需求到代码之间的翻译官。很少去思考需求的合理性，对于自己做的事情有多大价值，不管也不问。&lt;/p>
&lt;p>而对于高级别的程序员来说，并不会一开始就陷入细节，而是会更多地会从产品本身出发，询问产品经理为啥要做这个细节，目的是啥。换个说法，就是会先考虑这个需求是不是合理。&lt;/p>
&lt;p>如果需求高级不合理就进行 PK ，要么对需求进行调整，要么就砍掉。不过要注意的是 PK 和调整需求不仅仅砍需求，还有另外一个方向，那就是对需求进行加强。&lt;/p>
&lt;p>产品同学由于缺乏技术背景，很可能想的并不够充分，这个时候如果你有更好的想法，也完全可以提出来，加到需求里，让这个需求变得更有价值。&lt;/p>
&lt;p>总之，高级程序员并不会一五一十地按产品经理的需求文档来进行后面的开发，而是&lt;strong>一切从有利于业务的角度出发思考，对产品经理的需求进行删、改、增。&lt;/strong>&lt;/p>
&lt;p>这样的工作表面看似和开发无关，但是只有这样才能保证后续所有开发同学都是有价值的，而不是做一堆无用功。无用功做的多了会极大的挫伤开发的成就感。&lt;/p>
&lt;p>所以，&lt;strong>普通程序员要想成长为更高级别的开发，一定要加强需求评审能力的培养&lt;/strong>。&lt;/p>
&lt;h3 id="建议-2主动思考效率">
 建议 2：主动思考效率
 &lt;a class="anchor" href="#%e5%bb%ba%e8%ae%ae-2%e4%b8%bb%e5%8a%a8%e6%80%9d%e8%80%83%e6%95%88%e7%8e%87">#&lt;/a>
&lt;/h3>
&lt;p>普通的程序员，按部就班的去写代码，有活儿来我就干，没活儿的时候我就呆着。很少去深度思考现有的这些代码为什么要这么写，这么写的好处是啥，有哪些地方存在瓶颈，我是否可以把它优化一些。&lt;/p>
&lt;p>而高级一点程序员，并不会局限于把手头的活儿开发就算完事。他们会主动去琢磨，现在这种开发模式是不是不够的好。那么我是否能做一个什么东西能把这个效率给提升起来。&lt;/p>
&lt;p>举一个小例子，我 6 年前接手一个项目的时候，我发现运营一个月会找我四次，就是找我给她发送一个推送。她说以前的开发都是这么帮他弄的。虽然这个需求处理起来很简单，改两行发布一下就完事。但是烦啊，你想象一下你正专心写代码呢，她又双叒来找你了，思路全被她中断了。而且频繁地操作线上本来就会引入不确定的风险，万一那天手一抽抽搞错了，线上就完蛋了。&lt;/p>
&lt;p>我的做法就是，我专门抽了一周的时间，给她做了一套运营后台。这样以后所有的运营推送她就直接在后台上操作就完事了。我倒出精力去做其它更有价值的事情去了。&lt;/p>
&lt;p>所以，&lt;strong>第二个建议就是要主动思考一下现有工作中哪些地方效率有改进的空间，想到了就主动去改进它！&lt;/strong>&lt;/p>
&lt;h3 id="建议-3加强内功能力">
 建议 3：加强内功能力
 &lt;a class="anchor" href="#%e5%bb%ba%e8%ae%ae-3%e5%8a%a0%e5%bc%ba%e5%86%85%e5%8a%9f%e8%83%bd%e5%8a%9b">#&lt;/a>
&lt;/h3>
&lt;p>哪些算是内功呢，我想内功修炼的读者们肯定也都很熟悉的了，指的就是大家学校里都学过的操作系统、网络等这些基础。&lt;/p>
&lt;p>普通的程序员会觉得，这些基础知识我都会好么，我大学可是足足学了四年的。工作了以后并不会刻意来回头再来加强自己在这些基础上的深层次的提升。&lt;/p>
&lt;p>高级的程序员，非常清楚自己当年学的那点知识太皮毛了。工作之余也会深入地去研究 Linux、研究网络等方向的底层实现。&lt;/p>
&lt;p>事实上，互联网业界的技术大牛们很大程度是因为对这些基础的理解相当是深厚，具备了深厚的内功以后才促使他们成长为了技术大牛。&lt;/p>
&lt;p>我很难相信一个不理解底层，只会 CURD，只会用别人框架的开发将来能在技术方向成长为大牛。&lt;/p>
&lt;p>所以，&lt;strong>还建议多多锻炼底层技术内功能力&lt;/strong>。如果你不知道怎么练，那就坚持看「开发内功修炼」公众号。&lt;/p>
&lt;h3 id="建议-4思考性能">
 建议 4：思考性能
 &lt;a class="anchor" href="#%e5%bb%ba%e8%ae%ae-4%e6%80%9d%e8%80%83%e6%80%a7%e8%83%bd">#&lt;/a>
&lt;/h3>
&lt;p>普通程序员往往就是把需求开发完了就不管了，只要需求实现了，测试通过了就可以交付了。将来流量会有多大，没想过。自己的服务 QPS 能支撑多少，不清楚。&lt;/p>
&lt;p>而高级的程序员往往会关注自己写出来的代码的性能。&lt;/p>
&lt;p>在需求评审的时候，他们一般就会估算大概的请求流量有多大。进而设计阶段就会根据这个量设计符合性能要求的方案。&lt;/p>
&lt;p>在上线之前也会进行性能压测，检验一下在性能上是否符合预期。如果性能存在问题，瓶颈在哪儿，怎么样能进行优化一下。&lt;/p>
&lt;p>所以，&lt;strong>第四个建议就是一定要多多主动你所负责业务的性能，并多多进行优化和改进&lt;/strong>。我想这个建议的重要程度非常之高。但这是需要你具备深厚的内功才可以办的到的，否则如果你连网络是怎么工作的都不清楚，谈何优化！&lt;/p>
&lt;h3 id="建议-5重视线上">
 建议 5：重视线上
 &lt;a class="anchor" href="#%e5%bb%ba%e8%ae%ae-5%e9%87%8d%e8%a7%86%e7%ba%bf%e4%b8%8a">#&lt;/a>
&lt;/h3>
&lt;p>普通程序员往往对线上的事情很少去关注，手里记录的服务器就是自己的开发机和发布机，线上机器有几台，流量多大，最近有没有波动这些可能都不清楚。&lt;/p>
&lt;p>而高级的程序员深深的明白，有条件的话，会尽量多多观察自己的线上服务，观察一下代码跑的咋样，有没有啥 error log。请求峰值的时候 CPU、内存的消耗咋样。网络端口消耗的情况咋样，是否需要调节一些参数配置。&lt;/p>
&lt;p>当性能不尽如人意的时候，可能会回头再来思考出性能的改进方案，重新开发和上线。&lt;/p></description></item><item><title>工作五年之后，对技术和业务的思考</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/thinking-about-technology-and-business-after-five-years-of-work/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：这是我在两年前看到的一篇对我触动比较深的文章。确实要学会适应变化，并积累能力。积累解决问题的能力，优化思考方式，拓宽自己的认知。&lt;/p>
&lt;p>&lt;strong>原文地址：&lt;/strong> &lt;a href="https://mp.weixin.qq.com/s/CTbEdi0F4-qFoJT05kNlXA">https://mp.weixin.qq.com/s/CTbEdi0F4-qFoJT05kNlXA&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>苦海无边，回头无岸。&lt;/p>
&lt;h2 id="01-前言">
 01 前言
 &lt;a class="anchor" href="#01-%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>晃晃悠悠的，在互联网行业工作了五年，默然回首，你看哪里像灯火阑珊处？&lt;/p>
&lt;p>初入职场，大部分程序员会觉得苦学技术，以后会顺风顺水升职加薪，这样的想法没有错，但是不算全面，五年后你会不会继续做技术写代码这是核心问题。&lt;/p>
&lt;p>初入职场，会觉得努力加班可以不断提升能力，可以学到技术的公司就算薪水低点也可以接受，但是五年之后会认为加班都是在不断挤压自己的上升空间，薪水低是人生的天花板。&lt;/p>
&lt;p>这里想说的关键问题就是：初入职场的认知和想法大部分不会再适用于五年后的认知。&lt;/p>
&lt;p>工作五年之后面临的最大压力就是选择：职场天花板，技术能力天花板，薪水天花板，三十岁天花板。&lt;/p>
&lt;p>如何面对这些问题，是大部分程序员都在思考和纠结的。做选择的唯一参考点就是：利益最大化，这里可以理解为职场更好的升职加薪，顺风顺水。&lt;/p>
&lt;p>五年，变化最大不是工作经验，能力积累，而是心态，清楚的知道现实和理想之间是存在巨大的差距。&lt;/p>
&lt;h2 id="02-学会适应变化并积累能力">
 02 学会适应变化，并积累能力
 &lt;a class="anchor" href="#02-%e5%ad%a6%e4%bc%9a%e9%80%82%e5%ba%94%e5%8f%98%e5%8c%96%e5%b9%b6%e7%a7%af%e7%b4%af%e8%83%bd%e5%8a%9b">#&lt;/a>
&lt;/h2>
&lt;p>回首自己的职场五年，最认可的一句话就是：学会适应变化，并积累能力。&lt;/p>
&lt;p>变化的就是，五年的时间技术框架更新迭代，开发工具的变迁，公司环境队友的更换，甚至是不同城市的流浪，想着能把肉体和灵魂安放在一处，有句很经典的话就是：唯一不变的就是变化本身。&lt;/p>
&lt;p>要积累的是：解决问题的能力，思考方式，拓宽认知。&lt;/p>
&lt;p>这种很难直白的描述，属于个人认知的范畴，不同的人有不一样的看法，所以只能站在大众化的角度去思考。&lt;/p>
&lt;p>首先聊聊技术，大部分小白级别的，都希望自己的技术能力不断提高，争取做到架构师级别，但是站在当前的互联网环境中，这种想法实现难度还是偏高，这里既不是打击也不是为了抬杠。&lt;/p>
&lt;p>可以观察一下现状，技术团队大的 20-30 人，小的 10-15 人，能有一个架构师去专门管理底层框架都是少有现象。&lt;/p>
&lt;p>这个问题的原因很多，首先架构师的成本过高，环境架构也不是需要经常升级，说的难听点可能框架比项目生命周期更高。&lt;/p>
&lt;p>所以大部分公司的大部分业务，基于现有大部分成熟的开源框架都可以解决，这也就导致架构师这个角色通常由项目主管代替或者级别较高的开发直接负责，这就是现实情况。&lt;/p>
&lt;p>这就导致技术框架的选择思路就是：只选对的。即这方面的人才多，开源解决方案多，以此降低技术方面对公司业务发展的影响。&lt;/p>
&lt;p>那为什么还要不断学习和积累技术能力？如果没有这个能力，程序员岗位可能根本走不了五年之久，需要用技术深度积累不断解决工作中的各种问题，用技术的广度提升自己实现业务需求的认知边界，这是安放肉体的根本保障。&lt;/p>
&lt;p>这就是导致很多五年以后的程序员压力陡然升高的原因，走向管理岗的另一个壁垒就是业务思维和认知。&lt;/p>
&lt;h2 id="03-提高业务能力的积累">
 03 提高业务能力的积累
 &lt;a class="anchor" href="#03-%e6%8f%90%e9%ab%98%e4%b8%9a%e5%8a%a1%e8%83%bd%e5%8a%9b%e7%9a%84%e7%a7%af%e7%b4%af">#&lt;/a>
&lt;/h2>
&lt;p>程序员该不该用心研究业务，这个问题真的没有纠结的必要，只要不是纯技术型的公司，都需要面对业务。&lt;/p>
&lt;p>不管技术、运营、产品、管理层，都是在面向业务工作。&lt;/p>
&lt;p>从自己职场轨迹来看，五年变化最大就是解决业务问题的能力，职场之初面对很多业务场景都不知道如何下手，到几年之后设计业务的解决方案。&lt;/p>
&lt;p>这是大部分程序员在职场前五年跳槽就能涨薪的根本原因，面对业务场景，基于积累的经验和现有的开源工具，能快速给出合理的解决思路和实现过程。&lt;/p>
&lt;p>工作五年可能对技术底层的清晰程度都没有初入职场的小白清楚，但是写的程序却可以避开很多坑坑洼洼，对于业务的审视也是很细节全面。&lt;/p>
&lt;p>解决业务能力的积累，对于技术视野的宽度需求更甚，比如职场初期对于海量数据的处理束手无策，但是在工作几年之后见识数据行业的技术栈，真的就是技术选型的视野问题。&lt;/p>
&lt;p>什么是衡量技术能力的标准？站在一个共识的角度上看：系统的架构与代码设计能适应业务的不断变化和各种需求。&lt;/p>
&lt;p>相对比与技术，业务的变化更加快速频繁，高级工程师或者架构师之所以薪资高，这些角色一方面能适应业务的迭代，并且在工作中具有一定前瞻性，会考虑业务变化的情况下代码复用逻辑，这样的能力是需要一定的技术视野和业务思维的沉淀。&lt;/p>
&lt;p>所以职场中：业务能说的井井有条，代码能写的明明白白，得到机会的可能性更大。&lt;/p>
&lt;h2 id="04-不同的阶段技术和业务的平衡和选择">
 04 不同的阶段技术和业务的平衡和选择
 &lt;a class="anchor" href="#04-%e4%b8%8d%e5%90%8c%e7%9a%84%e9%98%b6%e6%ae%b5%e6%8a%80%e6%9c%af%e5%92%8c%e4%b8%9a%e5%8a%a1%e7%9a%84%e5%b9%b3%e8%a1%a1%e5%92%8c%e9%80%89%e6%8b%a9">#&lt;/a>
&lt;/h2>
&lt;p>从理性的角度看技术和业务两个方面，能让大部分人职场走的平稳顺利，但是不同的阶段对两者的平衡和选择是不一样的。&lt;/p>
&lt;p>在思考如何选择的时候，可以参考二八原则的逻辑，即在任何一组东西中，最重要的只占其中一小部分，约 20%，其余 80%尽管是多数，却是次要的，因此又称二八定律。&lt;/p>
&lt;p>个人真的非常喜欢这个原则，大部分人都不是天才，所以很难三心二意同时做好几件事情，在同一时间段内应该集中精力做好一件事件。&lt;/p>
&lt;p>但是单纯的二八原则模式可能不适应大部分职场初期的人，因为初期要学习很多内容，如何在职场生存：专业能力，职场关系，为人处世，产品设计等等。&lt;/p>
&lt;p>当然这些东西不是都要用心刻意学习，但是合理安排二二六原则或其他组合是更明智的，首先是专业能力要重点练习，其次可以根据自己的兴趣合理选择一到两个方面去慢慢了解，例如产品，运营，运维，数据等，毕竟三五年以后会不会继续写代码很难说，多给自己留个机会总是有备无患。&lt;/p>
&lt;p>在职场初期，基本都是从技术角度去思考问题，如何快速提升自己的编码能力，在公司能稳定是首要目标，因此大部分时间都是在做基础编码和学习规范，这时可能 90%的心思都是放在基础编码上，另外 10%会学习环境架构。&lt;/p>
&lt;p>最多一到两年，就会开始独立负责模块需求开发，需要自己设计整个代码思路，这里业务就会进入视野，要懂得业务上下游关联关系，学会思考如何设计代码结构，才能在需求变动的情况下代码改动较少，这个时候可能就会放 20%的心思在业务方面，30%学习架构方式。&lt;/p>
&lt;p>三到五年这个时间段，是解决问题能力提升最快的时候，因为这个阶段的程序员基本都是在开发核心业务链路，例如交易、支付、结算、智能商业等模块，需要对业务整体有较清晰的把握能力，不然就是给自己挖坑，这个阶段要对业务流付出大量心血思考。&lt;/p>
&lt;p>越是核心的业务线，越是容易爆发各种问题，如果在日常工作中不花心思处理各种细节问题，半夜异常自动的消息和邮件总是容易让人憔悴。&lt;/p>
&lt;p>所以努力学习技术是提升自己，培养自己的业务认知也同样重要，个人认为这二者的分量平分秋色，只是需要在合适的阶段做出合理的权重划分。&lt;/p>
&lt;h2 id="05-学会在职场做选择和生存">
 05 学会在职场做选择和生存
 &lt;a class="anchor" href="#05-%e5%ad%a6%e4%bc%9a%e5%9c%a8%e8%81%8c%e5%9c%ba%e5%81%9a%e9%80%89%e6%8b%a9%e5%92%8c%e7%94%9f%e5%ad%98">#&lt;/a>
&lt;/h2>
&lt;p>基于技术能力和业务思维，学会在职场做选择和生存，这些是职场前五年一路走来的最大体会。&lt;/p></description></item><item><title>红黑树</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/data-structure/red-black-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/data-structure/red-black-tree/</guid><description>&lt;h2 id="红黑树介绍">
 红黑树介绍
 &lt;a class="anchor" href="#%e7%ba%a2%e9%bb%91%e6%a0%91%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>红黑树（Red Black Tree）是一种自平衡二叉查找树。它是在 1972 年由 Rudolf Bayer 发明的，当时被称为平衡二叉 B 树（symmetric binary B-trees）。后来，在 1978 年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。&lt;/p>
&lt;p>由于其自平衡的特性，保证了最坏情形下在 O(logn) 时间复杂度内完成查找、增加、删除等操作，性能表现稳定。&lt;/p>
&lt;p>在 JDK 中，&lt;code>TreeMap&lt;/code>、&lt;code>TreeSet&lt;/code> 以及 JDK1.8 的 &lt;code>HashMap&lt;/code> 底层都用到了红黑树。&lt;/p>
&lt;h2 id="为什么需要红黑树">
 为什么需要红黑树？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e7%ba%a2%e9%bb%91%e6%a0%91">#&lt;/a>
&lt;/h2>
&lt;p>红黑树的诞生就是为了解决二叉查找树的缺陷。&lt;/p>
&lt;p>二叉查找树是一种基于比较的数据结构，它的每个节点都有一个键值，而且左子节点的键值小于父节点的键值，右子节点的键值大于父节点的键值。这样的结构可以方便地进行查找、插入和删除操作，因为只需要比较节点的键值就可以确定目标节点的位置。但是，二叉查找树有一个很大的问题，就是它的形状取决于节点插入的顺序。如果节点是按照升序或降序的方式插入的，那么二叉查找树就会退化成一个线性结构，也就是一个链表。这样的情况下，二叉查找树的性能就会大大降低，时间复杂度就会从 O(logn) 变为 O(n)。&lt;/p>
&lt;p>红黑树的诞生就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。&lt;/p>
&lt;h2 id="红黑树特点">
 &lt;strong>红黑树特点&lt;/strong>
 &lt;a class="anchor" href="#%e7%ba%a2%e9%bb%91%e6%a0%91%e7%89%b9%e7%82%b9">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>每个节点非红即黑。黑色决定平衡，红色不决定平衡。这对应了 2-3 树中一个节点内可以存放 1~2 个节点。&lt;/li>
&lt;li>根节点总是黑色的。&lt;/li>
&lt;li>每个叶子节点都是黑色的空节点（NIL 节点）。这里指的是红黑树都会有一个空的叶子节点，是红黑树自己的规则。&lt;/li>
&lt;li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）。通常这条规则也叫不会有连续的红色节点。一个节点最多临时会有 3 个子节点，中间是黑色节点，左右是红色节点。&lt;/li>
&lt;li>从任意节点到它的叶子节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。每一层都只是有一个节点贡献了树高决定平衡性，也就是对应红黑树中的黑色节点。&lt;/li>
&lt;/ol>
&lt;p>正是这些特点才保证了红黑树的平衡，让红黑树的高度不会超过 2log(n+1)。&lt;/p>
&lt;h2 id="红黑树数据结构">
 红黑树数据结构
 &lt;a class="anchor" href="#%e7%ba%a2%e9%bb%91%e6%a0%91%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#&lt;/a>
&lt;/h2>
&lt;p>建立在 BST 二叉搜索树的基础上，AVL、2-3 树、红黑树都是自平衡二叉树（统称 B-树）。但相比于 AVL 树，高度平衡所带来的时间复杂度，红黑树对平衡的控制要宽松一些，红黑树只需要保证黑色节点平衡即可。&lt;/p></description></item><item><title>华为 OD 275 天后，我进了腾讯！</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/huawei-od-275-days/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/huawei-od-275-days/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：一位朋友的华为 OD 工作经历以及腾讯面试经历分享，内容很不错。&lt;/p>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://www.cnblogs.com/shoufeng/p/14322931.html">https://www.cnblogs.com/shoufeng/p/14322931.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="时间线">
 时间线
 &lt;a class="anchor" href="#%e6%97%b6%e9%97%b4%e7%ba%bf">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>18 年 7 月，毕业于某不知名 985 计科专业；&lt;/li>
&lt;li>毕业前，在某马的 JavaEE（后台开发）培训了 6 个月；&lt;/li>
&lt;li>第一份工作（18-07 ~ 19-12）接触了大数据，感觉大数据更有前景；&lt;/li>
&lt;li>19 年 12 月，入职中国平安产险（去到才发现是做后台开发 😢）；&lt;/li>
&lt;li>20 年 3 月，从平安辞职，跳去华为 OD 做大数据基础平台；&lt;/li>
&lt;li>2021 年 1 月，入职鹅厂&lt;/li>
&lt;/ul>
&lt;h2 id="华为-od-工作经历总结">
 华为 OD 工作经历总结
 &lt;a class="anchor" href="#%e5%8d%8e%e4%b8%ba-od-%e5%b7%a5%e4%bd%9c%e7%bb%8f%e5%8e%86%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h2>
&lt;h3 id="为什么会去华为-od">
 为什么会去华为 OD
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e5%8e%bb%e5%8d%8e%e4%b8%ba-od">#&lt;/a>
&lt;/h3>
&lt;p>在平安产险（正式员工）只待了 3 个月，就跳去华为 OD，朋友们都是很不理解的 —— 好好的正编不做，去什么外包啊 😂&lt;/p>
&lt;p>但那个时候，我铁了心要去做大数据，不想和没完没了的 CRUD 打交道。刚好面试通过的岗位是华为 Cloud BU 的大数据部门，做的是国内政企中使用率绝对领先的大数据平台……
平台和工作内容都不错，这么好的机会，说啥也要去啊 💪&lt;/p>
&lt;blockquote>
&lt;p>其实有想过在平安内部转岗到大数据的，但是不满足“入职一年以上”这个要求；
「等待就是浪费生命」，在转正流程还没批下来的时候，赶紧溜了 😂&lt;/p>
&lt;/blockquote>
&lt;h3 id="华为-od-的工作内容">
 华为 OD 的工作内容
 &lt;a class="anchor" href="#%e5%8d%8e%e4%b8%ba-od-%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%86%85%e5%ae%b9">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>带着无限的期待，火急火燎地去华为报到了。&lt;/strong>&lt;/p>
&lt;p>和招聘的 HR 说的一样，和华为自有员工一起办公，工作内容和他们完全一样：&lt;/p>
&lt;blockquote>
&lt;p>主管根据你的能力水平分配工作，逐渐增加难度，能者多劳；
试用期 6 个月，有导师带你，一般都是高你 2 个 Level 的华为自有员工，基本都是部门大牛。&lt;/p></description></item><item><title>缓存基础常见面试题总结(付费)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/cache-basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/cache-basics/</guid><description>&lt;p>&lt;strong>缓存基础&lt;/strong> 相关的面试题为我的 &lt;a href="../../about-the-author/zhishixingqiu-two-years.md">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了&lt;a href="../../zhuanlan/java-mian-shi-zhi-bei.md">《Java 面试指北》&lt;/a>中。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/javamianshizhibei/database-questions.png" alt="" />&lt;/p></description></item><item><title>几道常见的链表算法题</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/linkedlist-algorithm-problems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/linkedlist-algorithm-problems/</guid><description>&lt;h2 id="1-两数相加">
 1. 两数相加
 &lt;a class="anchor" href="#1-%e4%b8%a4%e6%95%b0%e7%9b%b8%e5%8a%a0">#&lt;/a>
&lt;/h2>
&lt;h3 id="题目描述">
 题目描述
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0">#&lt;/a>
&lt;/h3>
&lt;blockquote>
&lt;p>Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。&lt;/p>
&lt;p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。&lt;/p>
&lt;/blockquote>
&lt;p>示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>输出：7 -&amp;gt; 0 -&amp;gt; 8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>原因：342 + 465 = 807
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="问题分析">
 问题分析
 &lt;a class="anchor" href="#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">#&lt;/a>
&lt;/h3>
&lt;p>Leetcode 官方详细解答地址：&lt;/p>
&lt;p>&lt;a href="https://leetcode-cn.com/problems/add-two-numbers/solution/">https://leetcode-cn.com/problems/add-two-numbers/solution/&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>要对头结点进行操作时，考虑创建哑节点 dummy，使用 dummy-&amp;gt;next 表示真正的头节点。这样可以避免处理头节点为空的边界问题。&lt;/p>
&lt;/blockquote>
&lt;p>我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐
位相加的过程。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/algorithms/34910956.jpg" alt="图1，对两数相加方法的可视化: 342 &amp;#43; 465 = 807， 每个结点都包含一个数字，并且数字按位逆序存储。" />&lt;/p>
&lt;h3 id="solution">
 Solution
 &lt;a class="anchor" href="#solution">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>我们首先从最低有效位也就是列表 l1 和 l2 的表头开始相加。注意需要考虑到进位的情况！&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Definition for singly-linked list.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * public class ListNode {
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * int val;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * ListNode next;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * ListNode(int x) { val = x; }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//https://leetcode-cn.com/problems/add-two-numbers/description/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> ListNode &lt;span style="color:#a6e22e">addTwoNumbers&lt;/span>(ListNode l1, ListNode l2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode dummyHead &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ListNode(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListNode p &lt;span style="color:#f92672">=&lt;/span> l1, q &lt;span style="color:#f92672">=&lt;/span> l2, curr &lt;span style="color:#f92672">=&lt;/span> dummyHead;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//carry 表示进位数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> carry &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (p &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">||&lt;/span> q &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> (p &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> p.&lt;span style="color:#a6e22e">val&lt;/span> : 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> (q &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> q.&lt;span style="color:#a6e22e">val&lt;/span> : 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> sum &lt;span style="color:#f92672">=&lt;/span> carry &lt;span style="color:#f92672">+&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//进位数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> carry &lt;span style="color:#f92672">=&lt;/span> sum &lt;span style="color:#f92672">/&lt;/span> 10;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//新节点的数值为sum % 10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ListNode(sum &lt;span style="color:#f92672">%&lt;/span> 10);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr &lt;span style="color:#f92672">=&lt;/span> curr.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (p &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) p &lt;span style="color:#f92672">=&lt;/span> p.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (q &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) q &lt;span style="color:#f92672">=&lt;/span> q.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (carry &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curr.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ListNode(carry);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> dummyHead.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2-翻转链表">
 2. 翻转链表
 &lt;a class="anchor" href="#2-%e7%bf%bb%e8%bd%ac%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h2>
&lt;h3 id="题目描述-1">
 题目描述
 &lt;a class="anchor" href="#%e9%a2%98%e7%9b%ae%e6%8f%8f%e8%bf%b0-1">#&lt;/a>
&lt;/h3>
&lt;blockquote>
&lt;p>剑指 offer:输入一个链表，反转链表后，输出链表的所有元素。&lt;/p></description></item><item><title>几道常见的字符串算法题</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/string-algorithm-problems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/string-algorithm-problems/</guid><description>&lt;blockquote>
&lt;p>作者：wwwxmu&lt;/p>
&lt;p>原文地址:&lt;a href="https://www.weiweiblog.cn/13string/">https://www.weiweiblog.cn/13string/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="1-kmp-算法">
 1. KMP 算法
 &lt;a class="anchor" href="#1-kmp-%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;p>谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有 O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而 KMP 算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。&lt;/p>
&lt;p>具体算法细节请参考：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解 KMP:&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/21923021">如何更好的理解和掌握 KMP 算法?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.sengxian.com/algorithms/kmp">KMP 算法详细解析&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://blog.jobbole.com/76611/">图解 KMP 算法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/av3246487/?from=search&amp;amp;seid=17173603269940723925">汪都能听懂的 KMP 字符串匹配算法【双语字幕】&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/av11866460?from=search&amp;amp;seid=12730654434238709250">KMP 字符串匹配算法 1&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>除此之外，再来了解一下 BM 算法！&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>BM 算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则 和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。
《字符串匹配的 KMP 算法》:&lt;a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="2-替换空格">
 2. 替换空格
 &lt;a class="anchor" href="#2-%e6%9b%bf%e6%8d%a2%e7%a9%ba%e6%a0%bc">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>剑指 offer：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。&lt;/p>
&lt;/blockquote>
&lt;p>这里我提供了两种方法：① 常规方法；② 利用 API 解决。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//https://www.weiweiblog.cn/replacespace/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 第一种方法：常规方法。利用String.charAt(i)以及String.valueOf(char).equals(&amp;#34; &amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * )遍历字符串并判断元素是否为空格。是则替换为&amp;#34;%20&amp;#34;,否则不替换
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">replaceSpace&lt;/span>(StringBuffer str) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> length &lt;span style="color:#f92672">=&lt;/span> str.&lt;span style="color:#a6e22e">length&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// System.out.println(&amp;#34;length=&amp;#34; + length);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StringBuffer result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuffer();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> length; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> str.&lt;span style="color:#a6e22e">charAt&lt;/span>(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (String.&lt;span style="color:#a6e22e">valueOf&lt;/span>(b).&lt;span style="color:#a6e22e">equals&lt;/span>(&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">append&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%20&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.&lt;span style="color:#a6e22e">append&lt;/span>(b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> result.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 第二种方法：利用API替换掉所用空格，一行代码解决问题
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">replaceSpace2&lt;/span>(StringBuffer str) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> str.&lt;span style="color:#a6e22e">toString&lt;/span>().&lt;span style="color:#a6e22e">replaceAll&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;\\s&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;%20&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于替换固定字符（比如空格）的情况，第二种方法其实可以使用 &lt;code>replace&lt;/code> 方法替换，性能更好!&lt;/p></description></item><item><title>计算机网络常见面试题总结(上)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/other-network-questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/other-network-questions/</guid><description>&lt;p>上篇主要是计算机网络基础和应用层相关的内容。&lt;/p>
&lt;h2 id="计算机网络基础">
 计算机网络基础
 &lt;a class="anchor" href="#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h2>
&lt;h3 id="网络分层模型">
 网络分层模型
 &lt;a class="anchor" href="#%e7%bd%91%e7%bb%9c%e5%88%86%e5%b1%82%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h3>
&lt;h4 id="osi-七层模型是什么每一层的作用是什么">
 OSI 七层模型是什么？每一层的作用是什么？
 &lt;a class="anchor" href="#osi-%e4%b8%83%e5%b1%82%e6%a8%a1%e5%9e%8b%e6%98%af%e4%bb%80%e4%b9%88%e6%af%8f%e4%b8%80%e5%b1%82%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h4>
&lt;p>&lt;strong>OSI 七层模型&lt;/strong> 是国际标准化组织提出的一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型" />&lt;/p>
&lt;p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。&lt;/p>
&lt;p>&lt;strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。&lt;/strong>&lt;/p>
&lt;p>上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/osi%e4%b8%83%e5%b1%82%e6%a8%a1%e5%9e%8b2.png" alt="osi七层模型2" />&lt;/p>
&lt;h4 id="tcpip-四层模型是什么每一层的作用是什么">
 TCP/IP 四层模型是什么？每一层的作用是什么？
 &lt;a class="anchor" href="#tcpip-%e5%9b%9b%e5%b1%82%e6%a8%a1%e5%9e%8b%e6%98%af%e4%bb%80%e4%b9%88%e6%af%8f%e4%b8%80%e5%b1%82%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h4>
&lt;p>&lt;strong>TCP/IP 四层模型&lt;/strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：&lt;/p>
&lt;ol>
&lt;li>应用层&lt;/li>
&lt;li>传输层&lt;/li>
&lt;li>网络层&lt;/li>
&lt;li>网络接口层&lt;/li>
&lt;/ol>
&lt;p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png" alt="TCP/IP 四层模型" />&lt;/p>
&lt;p>关于每一层作用的详细介绍，请看 &lt;a href="./osi-and-tcp-ip-model.md">OSI 和 TCP/IP 网络分层模型详解（基础）&lt;/a> 这篇文章。&lt;/p>
&lt;h4 id="为什么网络要分层">
 为什么网络要分层？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%bd%91%e7%bb%9c%e8%a6%81%e5%88%86%e5%b1%82">#&lt;/a>
&lt;/h4>
&lt;p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:&lt;/p>
&lt;ol>
&lt;li>Repository（数据库操作）&lt;/li>
&lt;li>Service（业务操作）&lt;/li>
&lt;li>Controller（前后端数据交互）&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。&lt;/strong>&lt;/p>
&lt;p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>各层之间相互独立&lt;/strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）&lt;strong>。这个和我们对开发时系统进行分层是一个道理。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>提高了灵活性和可替换性&lt;/strong>：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。并且，每一层都可以根据需要进行修改或替换，而不会影响到整个网络的结构。&lt;strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>大问题化小&lt;/strong>：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 &lt;strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>我想到了计算机世界非常非常有名的一句话，这里分享一下：&lt;/p></description></item><item><title>计算机网络常见面试题总结(下)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/other-network-questions2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/other-network-questions2/</guid><description>&lt;p>下篇主要是传输层和网络层相关的内容。&lt;/p>
&lt;h2 id="tcp-与-udp">
 TCP 与 UDP
 &lt;a class="anchor" href="#tcp-%e4%b8%8e-udp">#&lt;/a>
&lt;/h2>
&lt;h3 id="tcp-与-udp-的区别重要">
 TCP 与 UDP 的区别（重要）
 &lt;a class="anchor" href="#tcp-%e4%b8%8e-udp-%e7%9a%84%e5%8c%ba%e5%88%ab%e9%87%8d%e8%a6%81">#&lt;/a>
&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>是否面向连接&lt;/strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。&lt;/li>
&lt;li>&lt;strong>是否是可靠传输&lt;/strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。&lt;/li>
&lt;li>&lt;strong>是否有状态&lt;/strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（&lt;strong>这很渣男！&lt;/strong>）。&lt;/li>
&lt;li>&lt;strong>传输效率&lt;/strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。&lt;/li>
&lt;li>&lt;strong>传输形式&lt;/strong>：TCP 是面向字节流的，UDP 是面向报文的。&lt;/li>
&lt;li>&lt;strong>首部开销&lt;/strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。&lt;/li>
&lt;li>&lt;strong>是否提供广播或多播服务&lt;/strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；&lt;/li>
&lt;li>……&lt;/li>
&lt;/ol>
&lt;p>我把上面总结的内容通过表格形式展示出来了！确定不点个赞嘛？&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>&lt;/th>
 &lt;th>TCP&lt;/th>
 &lt;th>UDP&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>是否面向连接&lt;/td>
 &lt;td>是&lt;/td>
 &lt;td>否&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>是否可靠&lt;/td>
 &lt;td>是&lt;/td>
 &lt;td>否&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>是否有状态&lt;/td>
 &lt;td>是&lt;/td>
 &lt;td>否&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>传输效率&lt;/td>
 &lt;td>较慢&lt;/td>
 &lt;td>较快&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>传输形式&lt;/td>
 &lt;td>字节流&lt;/td>
 &lt;td>数据报文段&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>首部开销&lt;/td>
 &lt;td>20 ～ 60 bytes&lt;/td>
 &lt;td>8 bytes&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>是否提供广播或多播服务&lt;/td>
 &lt;td>否&lt;/td>
 &lt;td>是&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h3 id="什么时候选择-tcp什么时候选-udp">
 什么时候选择 TCP，什么时候选 UDP?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e9%80%89%e6%8b%a9-tcp%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e9%80%89-udp">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>UDP 一般用于即时通信&lt;/strong>，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。&lt;/li>
&lt;li>&lt;strong>TCP 用于对传输准确性要求特别高的场景&lt;/strong>，比如文件传输、发送和接收邮件、远程登录等等。&lt;/li>
&lt;/ul>
&lt;h3 id="http-基于-tcp-还是-udp">
 HTTP 基于 TCP 还是 UDP？
 &lt;a class="anchor" href="#http-%e5%9f%ba%e4%ba%8e-tcp-%e8%bf%98%e6%98%af-udp">#&lt;/a>
&lt;/h3>
&lt;p>&lt;del>&lt;strong>HTTP 协议是基于 TCP 协议的&lt;/strong>，所以发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。&lt;/del>&lt;/p></description></item><item><title>剑指offer部分编程题</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/the-sword-refers-to-offer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/the-sword-refers-to-offer/</guid><description>&lt;h2 id="斐波那契数列">
 斐波那契数列
 &lt;a class="anchor" href="#%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0%e5%88%97">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>题目描述：&lt;/strong>&lt;/p>
&lt;p>大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。
n&amp;lt;=39&lt;/p>
&lt;p>&lt;strong>问题分析：&lt;/strong>&lt;/p>
&lt;p>可以肯定的是这一题通过递归的方式是肯定能做出来，但是这样会有一个很大的问题，那就是递归大量的重复计算会导致内存溢出。另外可以使用迭代法，用 fn1 和 fn2 保存计算过程中的结果，并复用起来。下面我会把两个方法示例代码都给出来并给出两个方法的运行时间对比。&lt;/p>
&lt;p>&lt;strong>示例代码：&lt;/strong>&lt;/p>
&lt;p>采用迭代法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">Fibonacci&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> number) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (number &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (number &lt;span style="color:#f92672">==&lt;/span> 1 &lt;span style="color:#f92672">||&lt;/span> number &lt;span style="color:#f92672">==&lt;/span> 2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> first &lt;span style="color:#f92672">=&lt;/span> 1, second &lt;span style="color:#f92672">=&lt;/span> 1, third &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 3; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> number; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> third &lt;span style="color:#f92672">=&lt;/span> first &lt;span style="color:#f92672">+&lt;/span> second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> first &lt;span style="color:#f92672">=&lt;/span> second;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> second &lt;span style="color:#f92672">=&lt;/span> third;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> third;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>采用递归：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">Fibonacci&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">==&lt;/span> 1&lt;span style="color:#f92672">||&lt;/span>n&lt;span style="color:#f92672">==&lt;/span>2) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Fibonacci(n &lt;span style="color:#f92672">-&lt;/span> 2) &lt;span style="color:#f92672">+&lt;/span> Fibonacci(n &lt;span style="color:#f92672">-&lt;/span> 1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="跳台阶问题">
 跳台阶问题
 &lt;a class="anchor" href="#%e8%b7%b3%e5%8f%b0%e9%98%b6%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>题目描述：&lt;/strong>&lt;/p></description></item><item><title>降级&amp;熔断详解(付费)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-availability/fallback-and-circuit-breaker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-availability/fallback-and-circuit-breaker/</guid><description>&lt;p>&lt;strong>降级&amp;amp;熔断&lt;/strong> 相关的面试题为我的&lt;a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了&lt;a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》&lt;/a>中。&lt;/p></description></item><item><title>经典算法思想总结（含LeetCode题目推荐）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/classical-algorithm-problems-recommendations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/classical-algorithm-problems-recommendations/</guid><description>&lt;h2 id="贪心算法">
 贪心算法
 &lt;a class="anchor" href="#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;h3 id="算法思想">
 算法思想
 &lt;a class="anchor" href="#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3">#&lt;/a>
&lt;/h3>
&lt;p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。&lt;/p>
&lt;h3 id="一般解题步骤">
 一般解题步骤
 &lt;a class="anchor" href="#%e4%b8%80%e8%88%ac%e8%a7%a3%e9%a2%98%e6%ad%a5%e9%aa%a4">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>将问题分解为若干个子问题&lt;/li>
&lt;li>找出适合的贪心策略&lt;/li>
&lt;li>求解每一个子问题的最优解&lt;/li>
&lt;li>将局部最优解堆叠成全局最优解&lt;/li>
&lt;/ul>
&lt;h3 id="leetcode">
 LeetCode
 &lt;a class="anchor" href="#leetcode">#&lt;/a>
&lt;/h3>
&lt;p>455.分发饼干：&lt;a href="https://leetcode.cn/problems/assign-cookies/">https://leetcode.cn/problems/assign-cookies/&lt;/a>&lt;/p>
&lt;p>121.买卖股票的最佳时机：&lt;a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/&lt;/a>&lt;/p>
&lt;p>122.买卖股票的最佳时机 II：&lt;a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/&lt;/a>&lt;/p>
&lt;p>55.跳跃游戏：&lt;a href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/&lt;/a>&lt;/p>
&lt;p>45.跳跃游戏 II：&lt;a href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/&lt;/a>&lt;/p>
&lt;h2 id="动态规划">
 动态规划
 &lt;a class="anchor" href="#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92">#&lt;/a>
&lt;/h2>
&lt;h3 id="算法思想-1">
 算法思想
 &lt;a class="anchor" href="#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-1">#&lt;/a>
&lt;/h3>
&lt;p>动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。&lt;/p>
&lt;p>经典题目：01 背包、完全背包&lt;/p>
&lt;h3 id="一般解题步骤-1">
 一般解题步骤
 &lt;a class="anchor" href="#%e4%b8%80%e8%88%ac%e8%a7%a3%e9%a2%98%e6%ad%a5%e9%aa%a4-1">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>确定 dp 数组（dp table）以及下标的含义&lt;/li>
&lt;li>确定递推公式&lt;/li>
&lt;li>dp 数组如何初始化&lt;/li>
&lt;li>确定遍历顺序&lt;/li>
&lt;li>举例推导 dp 数组&lt;/li>
&lt;/ul>
&lt;h3 id="leetcode-1">
 LeetCode
 &lt;a class="anchor" href="#leetcode-1">#&lt;/a>
&lt;/h3>
&lt;p>509.斐波那契数：&lt;a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/&lt;/a>&lt;/p>
&lt;p>746.使用最小花费爬楼梯：&lt;a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/&lt;/a>&lt;/p>
&lt;p>416.分割等和子集：&lt;a href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/&lt;/a>&lt;/p>
&lt;p>518.零钱兑换：&lt;a href="https://leetcode.cn/problems/coin-change-ii/">https://leetcode.cn/problems/coin-change-ii/&lt;/a>&lt;/p>
&lt;p>647.回文子串：&lt;a href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/&lt;/a>&lt;/p>
&lt;p>516.最长回文子序列：&lt;a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/&lt;/a>&lt;/p>
&lt;h2 id="回溯算法">
 回溯算法
 &lt;a class="anchor" href="#%e5%9b%9e%e6%ba%af%e7%ae%97%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;h3 id="算法思想-2">
 算法思想
 &lt;a class="anchor" href="#%e7%ae%97%e6%b3%95%e6%80%9d%e6%83%b3-2">#&lt;/a>
&lt;/h3>
&lt;p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条&lt;/p>
&lt;p>件时，就“回溯”返回，尝试别的路径。其本质就是穷举。&lt;/p>
&lt;p>经典题目：8 皇后&lt;/p>
&lt;h3 id="一般解题步骤-2">
 一般解题步骤
 &lt;a class="anchor" href="#%e4%b8%80%e8%88%ac%e8%a7%a3%e9%a2%98%e6%ad%a5%e9%aa%a4-2">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。&lt;/li>
&lt;li>确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。&lt;/li>
&lt;li>以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。&lt;/li>
&lt;/ul>
&lt;h3 id="leetcode-2">
 leetcode
 &lt;a class="anchor" href="#leetcode-2">#&lt;/a>
&lt;/h3>
&lt;p>77.组合：&lt;a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/&lt;/a>&lt;/p></description></item><item><title>乐观锁和悲观锁详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/optimistic-lock-and-pessimistic-lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/optimistic-lock-and-pessimistic-lock/</guid><description>&lt;p>如果将悲观锁（Pessimistic Lock）和乐观锁（Optimistic Lock）对应到现实生活中来。悲观锁有点像是一位比较悲观（也可以说是未雨绸缪）的人，总是会假设最坏的情况，避免出现问题。乐观锁有点像是一位比较乐观的人，总是会假设最好的情况，在要出现问题之前快速解决问题。&lt;/p>
&lt;h2 id="什么是悲观锁">
 什么是悲观锁？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%82%b2%e8%a7%82%e9%94%81">#&lt;/a>
&lt;/h2>
&lt;p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，&lt;strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程&lt;/strong>。&lt;/p>
&lt;p>像 Java 中&lt;code>synchronized&lt;/code>和&lt;code>ReentrantLock&lt;/code>等独占锁就是悲观锁思想的实现。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">performSynchronisedTask&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 需要同步的操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> Lock lock &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ReentrantLock();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>lock.&lt;span style="color:#a6e22e">lock&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 需要同步的操作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lock.&lt;span style="color:#a6e22e">unlock&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的上下文切换，增加系统的性能开销。并且，悲观锁还可能会存在死锁问题（线程获得锁的顺序不当时），影响代码的正常运行。&lt;/p>
&lt;h2 id="什么是乐观锁">
 什么是乐观锁？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%b9%90%e8%a7%82%e9%94%81">#&lt;/a>
&lt;/h2>
&lt;p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。&lt;/p>
&lt;p>在 Java 中&lt;code>java.util.concurrent.atomic&lt;/code>包下面的原子变量类（比如&lt;code>AtomicInteger&lt;/code>、&lt;code>LongAdder&lt;/code>）就是使用了乐观锁的一种实现方式 &lt;strong>CAS&lt;/strong> 实现的。
&lt;img src="https://oss.javaguide.cn/github/javaguide/java/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%A6%82%E8%A7%88-20230814005211968.png" alt="JUC原子类概览" />&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 代价就是会消耗更多的内存空间（空间换时间）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>LongAdder sum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LongAdder();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sum.&lt;span style="color:#a6e22e">increment&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁问题，在性能上往往会更胜一筹。但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败并重试，这样同样会非常影响性能，导致 CPU 飙升。&lt;/p>
&lt;p>不过，大量失败重试的问题也是可以解决的，像我们前面提到的 &lt;code>LongAdder&lt;/code>以空间换时间的方式就解决了这个问题。&lt;/p>
&lt;p>理论上来说：&lt;/p>
&lt;ul>
&lt;li>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如&lt;code>LongAdder&lt;/code>），也是可以考虑使用乐观锁的，要视实际情况而定。&lt;/li>
&lt;li>乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考&lt;code>java.util.concurrent.atomic&lt;/code>包下面的原子变量类）。&lt;/li>
&lt;/ul>
&lt;h2 id="如何实现乐观锁">
 如何实现乐观锁？
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e4%b9%90%e8%a7%82%e9%94%81">#&lt;/a>
&lt;/h2>
&lt;p>乐观锁一般会使用版本号机制或 CAS 算法实现，CAS 算法相对来说更多一些，这里需要格外注意。&lt;/p></description></item><item><title>类加载过程详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/class-loading-process/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/class-loading-process/</guid><description>&lt;h2 id="类的生命周期">
 类的生命周期
 &lt;a class="anchor" href="#%e7%b1%bb%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">#&lt;/a>
&lt;/h2>
&lt;p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。&lt;/p>
&lt;p>这 7 个阶段的顺序如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/jvm/lifecycle-of-a-class.png" alt="一个类的完整生命周期" />&lt;/p>
&lt;h2 id="类加载过程">
 类加载过程
 &lt;a class="anchor" href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e8%bf%87%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？&lt;/strong>&lt;/p>
&lt;p>系统加载 Class 类型的文件主要三步：&lt;strong>加载-&amp;gt;连接-&amp;gt;初始化&lt;/strong>。连接过程又可分为三步：&lt;strong>验证-&amp;gt;准备-&amp;gt;解析&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-procedure.png" alt="类加载过程" />&lt;/p>
&lt;p>详见 &lt;a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3" title="Java Virtual Machine Specification - 5.3. Creation and Loading">Java Virtual Machine Specification - 5.3. Creation and Loading&lt;/a>。&lt;/p>
&lt;h3 id="加载">
 加载
 &lt;a class="anchor" href="#%e5%8a%a0%e8%bd%bd">#&lt;/a>
&lt;/h3>
&lt;p>类加载过程的第一步，主要完成下面 3 件事情：&lt;/p>
&lt;ol>
&lt;li>通过全类名获取定义此类的二进制字节流。&lt;/li>
&lt;li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。&lt;/li>
&lt;li>在内存中生成一个代表该类的 &lt;code>Class&lt;/code> 对象，作为方法区这些数据的访问入口。&lt;/li>
&lt;/ol>
&lt;p>虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：&amp;ldquo;通过全类名获取定义此类的二进制字节流&amp;rdquo; 并没有指明具体从哪里获取（ &lt;code>ZIP&lt;/code>、 &lt;code>JAR&lt;/code>、&lt;code>EAR&lt;/code>、&lt;code>WAR&lt;/code>、网络、动态代理技术运行时动态生成、其他文件生成比如 &lt;code>JSP&lt;/code>&amp;hellip;）、怎样获取。&lt;/p>
&lt;p>加载这一步主要是通过我们后面要讲到的 &lt;strong>类加载器&lt;/strong> 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 &lt;strong>双亲委派模型&lt;/strong> 决定（不过，我们也能打破由双亲委派模型）。&lt;/p>
&lt;blockquote>
&lt;p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容在&lt;a href="https://javaguide.cn/java/jvm/classloader.html" title="类加载器详解">类加载器详解&lt;/a>这篇文章中有详细介绍到。阅读本篇文章的时候，大家知道有这么个东西就可以了。&lt;/p>
&lt;/blockquote>
&lt;p>每个 Java 类都有一个引用指向加载它的 &lt;code>ClassLoader&lt;/code>。不过，数组类不是通过 &lt;code>ClassLoader&lt;/code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过&lt;code>getClassLoader()&lt;/code>方法获取 &lt;code>ClassLoader&lt;/code> 的时候和该数组的元素类型的 &lt;code>ClassLoader&lt;/code> 是一致的。&lt;/p></description></item><item><title>类加载器详解（重点）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/classloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/classloader/</guid><description>&lt;h2 id="回顾一下类加载过程">
 回顾一下类加载过程
 &lt;a class="anchor" href="#%e5%9b%9e%e9%a1%be%e4%b8%80%e4%b8%8b%e7%b1%bb%e5%8a%a0%e8%bd%bd%e8%bf%87%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;p>开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。&lt;/p>
&lt;ul>
&lt;li>类加载过程：&lt;strong>加载-&amp;gt;连接-&amp;gt;初始化&lt;/strong>。&lt;/li>
&lt;li>连接过程又可分为三步：&lt;strong>验证-&amp;gt;准备-&amp;gt;解析&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/jvm/class-loading-procedure.png" alt="类加载过程" />&lt;/p>
&lt;p>加载是类加载过程的第一步，主要完成下面 3 件事情：&lt;/p>
&lt;ol>
&lt;li>通过全类名获取定义此类的二进制字节流&lt;/li>
&lt;li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构&lt;/li>
&lt;li>在内存中生成一个代表该类的 &lt;code>Class&lt;/code> 对象，作为方法区这些数据的访问入口&lt;/li>
&lt;/ol>
&lt;h2 id="类加载器">
 类加载器
 &lt;a class="anchor" href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8">#&lt;/a>
&lt;/h2>
&lt;h3 id="类加载器介绍">
 类加载器介绍
 &lt;a class="anchor" href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h3>
&lt;p>类加载器从 JDK 1.0 就出现了，最初只是为了满足 Java Applet（已经被淘汰） 的需要。后来，慢慢成为 Java 程序中的一个重要组成部分，赋予了 Java 类可以被动态加载到 JVM 中并执行的能力。&lt;/p>
&lt;p>根据官方 API 文档的介绍：&lt;/p>
&lt;blockquote>
&lt;p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a &amp;ldquo;class file&amp;rdquo; of that name from a file system.&lt;/p></description></item><item><title>类文件结构详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/class-file-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/class-file-structure/</guid><description>&lt;h2 id="回顾一下字节码">
 回顾一下字节码
 &lt;a class="anchor" href="#%e5%9b%9e%e9%a1%be%e4%b8%80%e4%b8%8b%e5%ad%97%e8%8a%82%e7%a0%81">#&lt;/a>
&lt;/h2>
&lt;p>在 Java 中，JVM 可以理解的代码就叫做&lt;code>字节码&lt;/code>（即扩展名为 &lt;code>.class&lt;/code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。&lt;/p>
&lt;p>Clojure（Lisp 语言的一种方言）、Groovy、Scala、JRuby、Kotlin 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成&lt;code>.class&lt;/code>文件最终运行在 Java 虚拟机之上。&lt;code>.class&lt;/code>文件的二进制格式可以使用 &lt;a href="https://www.x-ways.net/winhex/">WinHex&lt;/a> 查看。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/basis/java-virtual-machine-program-language-os.png" alt="运行在 Java 虚拟机之上的编程语言" />&lt;/p>
&lt;p>可以说&lt;code>.class&lt;/code>文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。&lt;/p>
&lt;h2 id="class-文件结构总结">
 Class 文件结构总结
 &lt;a class="anchor" href="#class-%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h2>
&lt;p>根据 Java 虚拟机规范，Class 文件通过 &lt;code>ClassFile&lt;/code> 定义，有点类似 C 语言的结构体。&lt;/p>
&lt;p>&lt;code>ClassFile&lt;/code> 的结构如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>ClassFile {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u4 magic; &lt;span style="color:#75715e">//Class 文件的标志&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 minor_version;&lt;span style="color:#75715e">//Class 的小版本号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 major_version;&lt;span style="color:#75715e">//Class 的大版本号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 constant_pool_count;&lt;span style="color:#75715e">//常量池的数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cp_info constant_pool&lt;span style="color:#f92672">[&lt;/span>constant_pool_count&lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#75715e">//常量池&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 access_flags;&lt;span style="color:#75715e">//Class 的访问标记&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 this_class;&lt;span style="color:#75715e">//当前类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 super_class;&lt;span style="color:#75715e">//父类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 interfaces_count;&lt;span style="color:#75715e">//接口数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 interfaces&lt;span style="color:#f92672">[&lt;/span>interfaces_count&lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#75715e">//一个类可以实现多个接口&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 fields_count;&lt;span style="color:#75715e">//字段数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> field_info fields&lt;span style="color:#f92672">[&lt;/span>fields_count&lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#75715e">//一个类可以有多个字段&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 methods_count;&lt;span style="color:#75715e">//方法数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method_info methods&lt;span style="color:#f92672">[&lt;/span>methods_count&lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#75715e">//一个类可以有个多个方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> u2 attributes_count;&lt;span style="color:#75715e">//此类的属性表中的属性数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attribute_info attributes&lt;span style="color:#f92672">[&lt;/span>attributes_count&lt;span style="color:#f92672">]&lt;/span>;&lt;span style="color:#75715e">//属性表集合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过分析 &lt;code>ClassFile&lt;/code> 的内容，我们便可以知道 class 文件的组成。&lt;/p></description></item><item><title>聊聊大厂的绩效考核</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/work/employee-performance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/work/employee-performance/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>内容概览&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>在大部分公司，绩效跟你的年终奖、职级晋升、薪水涨幅等等福利是直接相关的。&lt;/li>
&lt;li>你的上级、上上级对你的绩效拥有绝对的话语权，这是潜规则，放到任何公司都是。成年人的世界，没有绝对的公平，绩效考核尤为明显。&lt;/li>
&lt;li>提升绩效的打法：
&lt;ul>
&lt;li>短期打法：找出 1-2 件事，体现出你的独特价值（抓关键事件）。&lt;/li>
&lt;li>长期打法：通过一步步信任的建立，成为团队的核心人员或者是老板的心腹，具备不可替代性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://mp.weixin.qq.com/s/D1s8p7z8Sp60c-ndGyh2yQ">https://mp.weixin.qq.com/s/D1s8p7z8Sp60c-ndGyh2yQ&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在新公司度过了一个完整的 Q3 季度，被打了绩效，也给下属打了绩效，感慨颇深。&lt;/p>
&lt;p>今天就好好聊聊&lt;strong>大厂打工人最最关心的「绩效考核」&lt;/strong>，谈谈它背后的逻辑以及潜规则，摸清楚了它，你在大厂这片丛林里才能更好的生存下去。&lt;/p>
&lt;h2 id="大厂的绩效到底有多重要">
 大厂的绩效到底有多重要？
 &lt;a class="anchor" href="#%e5%a4%a7%e5%8e%82%e7%9a%84%e7%bb%a9%e6%95%88%e5%88%b0%e5%ba%95%e6%9c%89%e5%a4%9a%e9%87%8d%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>先从公司角度，谈谈为什么需要绩效考核？&lt;/p>
&lt;p>有一个著名的管理者言论，即：企业战略的上三路和下三路。&lt;/p>
&lt;blockquote>
&lt;p>上三路是使命、愿景、价值观，下三路是组织、人才、KPI。下三路需要确保上三路能执行下去，否则便是空谈。那怎么才能达成呢？&lt;/p>
&lt;/blockquote>
&lt;p>马老板在湖畔大学的课堂上，对底下众多 CEO 学员说，“只能靠 KPI。没有 KPI，一切都是空话，组织和公司是不会进步的”。&lt;/p>
&lt;p>所以，KPI 一般是用来承接企业战略的。身处大厂的打工者们，也能深深感受到：每个季度的 KPI 是如何从大 Boss、到 Boss、再到基层，一层层拆解下来的，最终让所有人朝着一个方向行动，这便是 KPI 对于公司的意义。&lt;/p>
&lt;p>然鹅，并非每个员工都会站在 CEO 的高度去理解 KPI 的价值，大家更关注的是 KPI 对于我个人来说到底有什么意义？&lt;/p>
&lt;p>在互联网大厂，每家公司都会设定一套绩效考核体系，字节用的是 OKR，阿里用的是 KPI，通常都是「271」 制度，即：&lt;/p>
&lt;blockquote>
&lt;p>20% 的比例是 A+ 和 A，对应明星员工。&lt;/p>
&lt;p>70% 的比例是 B，对应普通员工。&lt;/p>
&lt;p>10% 的比例是 C 和 C-，对应需要绩效改进或者淘汰的员工。&lt;/p>
&lt;/blockquote>
&lt;p>有了三六九等，然后才有了利益分配。&lt;/p>
&lt;p>&lt;strong>在大厂，绩效结果跟奖金、晋升、薪水涨幅、股票授予是直接相关的。在内卷的今天，甚至可以直接划上等号。&lt;/strong>&lt;/p>
&lt;p>绩效好的员工，奖金必然多，一年可能调薪两次，晋升答辩时能 PK 掉绩效一般的人，职级低的人甚至可以晋升免试。&lt;/p>
&lt;p>而绩效差的人，有可能一年白干，甚至走人（大厂的末尾淘汰是不成文的规定）。&lt;/p>
&lt;p>总之，你能想到的直接利益都和「绩效」息息相关。所以，在大厂这片高手众多的丛林里，多琢磨下绩效背后的逻辑，既是生存之道，更是一技之长。&lt;/p>
&lt;h2 id="你是怎么看待绩效的">
 你是怎么看待绩效的？
 &lt;a class="anchor" href="#%e4%bd%a0%e6%98%af%e6%80%8e%e4%b9%88%e7%9c%8b%e5%be%85%e7%bb%a9%e6%95%88%e7%9a%84">#&lt;/a>
&lt;/h2>
&lt;p>凡是用来考核人的规则，大部分人在潜意识里都想去突破它，而不是被束缚。&lt;/p>
&lt;p>至少在我刚工作的前几年，看着身边有些同事因为背个 C 黯然离开的时候，觉得绩效考核就是一个冷血的管理工具。&lt;/p></description></item><item><title>美团三年，总结的10条血泪教训</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/meituan-three-year-summary-lesson-10/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/meituan-three-year-summary-lesson-10/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：作者用了很多生动的例子和故事展示了自己在美团的成长和感悟，看了之后受益颇多！&lt;/p>
&lt;p>&lt;strong>内容概览&lt;/strong>：&lt;/p>
&lt;p>本文的作者提出了以下十条建议，希望能对其他职场人有所启发和帮助：&lt;/p>
&lt;ol>
&lt;li>结构化思考与表达，提高个人影响力&lt;/li>
&lt;li>忘掉职级，该怼就怼，推动事情往前走&lt;/li>
&lt;li>用好平台资源，结识优秀的人，学习通识课&lt;/li>
&lt;li>一切都是争取来的，不要等待机会，要主动寻求&lt;/li>
&lt;li>关注商业，升维到老板思维，看清趋势，及时止损&lt;/li>
&lt;li>培养数据思维，利用数据了解世界，指导决策&lt;/li>
&lt;li>做一个好&amp;quot;销售&amp;quot;，无论是自己还是产品，都要学会展示和说服&lt;/li>
&lt;li>少加班多运动，保持身心健康，提高工作效率&lt;/li>
&lt;li>有随时可以离开的底气，不要被职场所困，借假修真，提升自己&lt;/li>
&lt;li>只是一份工作，不要过分纠结，相信自己，走出去看看&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://mp.weixin.qq.com/s/XidSVIwd4oKkDKEICaY1mQ">https://mp.weixin.qq.com/s/XidSVIwd4oKkDKEICaY1mQ&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在美团的三年多时光，如同一部悠长的交响曲，高高低低，而今离开已有一段时间。闲暇之余，梳理了三年多的收获与感慨，总结成 10 条，既是对过去一段时光的的一个深情回眸，也是对未来之路的一份期许。&lt;/p>
&lt;p>倘若一些感悟能为刚步入职场的年轻人，或是刚在职业生涯中崭露头角的后起之秀，带来一点点启示与帮助，也是莫大的荣幸。&lt;/p>
&lt;h2 id="01-结构化思考与表达">
 01 结构化思考与表达
 &lt;a class="anchor" href="#01-%e7%bb%93%e6%9e%84%e5%8c%96%e6%80%9d%e8%80%83%e4%b8%8e%e8%a1%a8%e8%be%be">#&lt;/a>
&lt;/h2>
&lt;p>美团是一家特别讲究方法论的公司，人人都要熟读四大名著《高效能人士的七个习惯》、《金字塔原理》、《用图表说话》和《学会提问》。&lt;/p>
&lt;p>与结构化思考和表达相关的，是《金字塔原理》，作者是麦肯锡公司第一位女性咨询顾问。这本书告诉我们，思考和表达的过程，就像构建金字塔（或者构建一棵树），先有整体结论，再寻找证据，证据之间要讲究相互独立、而且能穷尽（MECE 原则），论证的过程也要按特定的顺序进行，比如时间顺序、空间顺序、重要性顺序……&lt;/p>
&lt;p>作为大厂社畜，日常很大一部分工作就是写文档、看别人文档。大家做的事，但最后呈现的结果却有很大差异。一篇逻辑清晰、详略得当的文档，给人一种如沐春风的感受，能提炼出重要信息，是好的参考指南。&lt;/p>
&lt;p>结构化思考与表达算是职场最通用的能力，也是打造个人影响力最重要的途径之一。&lt;/p>
&lt;h2 id="02-忘掉职级该怼就怼">
 02 忘掉职级，该怼就怼
 &lt;a class="anchor" href="#02-%e5%bf%98%e6%8e%89%e8%81%8c%e7%ba%a7%e8%af%a5%e6%80%bc%e5%b0%b1%e6%80%bc">#&lt;/a>
&lt;/h2>
&lt;p>在阿里工作时，能看到每个人的 Title，看到江湖地位高（职级高+入职时间早）的同学，即便跟自己没有汇报关系，不自然的会多一层敬畏。推进工作时，会多一层压力，对方未读或已读未回时，不知如何应对。&lt;/p>
&lt;p>美团只能看到每个人的坑位信息，还有 Ta 的上级。工作相关的问题，可以向任何人提问，如果协同方没有及时响应，隔段时间@一次，甚至&amp;quot;怼一怼&amp;quot;，都没啥问题，事情一直往前推进才最重要。除了大象消息直接提问外，还有个大杀器&amp;ndash;TT（公司级问题流转系统），在上面提问时，加上对方主管，如果对方未及时回应，问题会自动升级，每天定时 Push，直到解决为止。&lt;/p>
&lt;p>我见到一些很年轻的同事，他们在推动 OKR、要资源的事上，很有一套，只要能达到自己的目标，不会考虑别人的感受，最终，他们还真能把事办成。&lt;/p>
&lt;p>当然了，段位越高的人，越能用自己的人格魅力、影响力、资源等，去影响和推动事情的进程，而不是靠对他人的 Push。只是在拿结果的事上，不要把自己太当回事，把别人太当回事，大家在一起，也只是为了完成各自的任务，忘掉职级，该怼时还得怼。&lt;/p>
&lt;h2 id="03-用好平台资源">
 03 用好平台资源
 &lt;a class="anchor" href="#03-%e7%94%a8%e5%a5%bd%e5%b9%b3%e5%8f%b0%e8%b5%84%e6%ba%90">#&lt;/a>
&lt;/h2>
&lt;p>没有人能在一家公司待一辈子，公司再牛，跟自己关系不大，重要的是，在有限的时间内，最大化用好平台资源。&lt;/p>
&lt;p>在美团除了认识自己节点的同事外，有幸认识一群特别棒的协作方，还有其他 BU 的同学。&lt;/p>
&lt;p>这些优秀的人身上，有很多共同的特质：谦虚、利他、乐于分享、双赢思维。&lt;/p>
&lt;p>有两位做运营的同学。&lt;/p>
&lt;p>一位是无意中关注他公众号结识上的。他公众号记录了很多职场成长、家庭建造上的思考和收获，还有定期个人复盘。他和太太都是大厂中层管理者，从文章中看到的不是他多厉害，而是非常接地气的故事。我们约饭了两次，有很多共同话题，现在还时不时有一些互动。&lt;/p>
&lt;p>一位职级更高的同学，他在内网发起了一个&amp;quot;请我喝一杯咖啡，和我一起聊聊个人困惑&amp;quot;的活动，我报名参与了一期。和他聊天的过程，特别像是一场教练对话（最近学习教练课程时才感受到的），帮我排除干扰、聚焦目标的同时，也从他分享个人成长蜕变的过程，收获很多动力。（刚好自己最近也学习了教练技术，后面也准备采用类似的方式，去帮助曾经像我一样迷茫的人）&lt;/p>
&lt;p>还有一些协作方同学。他们工作做得超级到位，能感受到，他们在乎他人时间；稍微有点出彩的事儿，不忘记拉上更多人。利他和双赢思维，在他们身上是最好的阐释。&lt;/p>
&lt;p>除了结识优秀的人，向他们学习外，还可以关注各个通道/工种的课程资源。&lt;/p>
&lt;p>在大厂，多数人的角色都是螺丝钉，但千万不要局限于做一颗螺丝钉。多去学习一些通识课，了解商业交付的各个环节，看清商业世界，明白自己的定位，超越自己的定位。&lt;/p>
&lt;h2 id="04-一切都是争取来的">
 04 一切都是争取来的
 &lt;a class="anchor" href="#04-%e4%b8%80%e5%88%87%e9%83%bd%e6%98%af%e4%ba%89%e5%8f%96%e6%9d%a5%e7%9a%84">#&lt;/a>
&lt;/h2>
&lt;p>工作很多年了，很晚才明白这个道理。&lt;/p>
&lt;p>之前一直认为，只要做好自己该做的，一定会被看见，被赏识，也会得到更多机会。但很多时候，这只是个人的一厢情愿。除了自己，不会有人关心你的权益。&lt;/p>
&lt;p>社会主义初级阶段，我国国内的主要矛盾是人民日益增长的物质文化需要同落后的社会生产之间的矛盾。无论在哪里，资源都是稀缺的，自己在乎的，就得去争取。&lt;/p>
&lt;p>想成长某个技能、想参与哪个模块、想做哪个项目，升职加薪……自己不提，不去争取，不会有人主动给你。&lt;/p>
&lt;p>争不争取是一回事，能不能得到是一回事，只有争取，才有可能得到。争取了，即便没有得到，最终也没失去什么。&lt;/p>
&lt;h2 id="05-关注商业">
 05 关注商业
 &lt;a class="anchor" href="#05-%e5%85%b3%e6%b3%a8%e5%95%86%e4%b8%9a">#&lt;/a>
&lt;/h2>
&lt;p>大公司，极度关注效率，大部分岗位，拆解的粒度越细，效率会越高，这些对组织是有利的。但对个人来说，则很容易螺丝钉化。&lt;/p></description></item><item><title>敏感词过滤方案总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/sentive-words-filter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/sentive-words-filter/</guid><description>&lt;p>系统需要对用户输入的文本进行敏感词过滤如色情、政治、暴力相关的词汇。&lt;/p>
&lt;p>敏感词过滤用的使用比较多的 &lt;strong>Trie 树算法&lt;/strong> 和 &lt;strong>DFA 算法&lt;/strong>。&lt;/p>
&lt;h2 id="算法实现">
 算法实现
 &lt;a class="anchor" href="#%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0">#&lt;/a>
&lt;/h2>
&lt;h3 id="trie-树">
 Trie 树
 &lt;a class="anchor" href="#trie-%e6%a0%91">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>Trie 树&lt;/strong> 也称为字典树、单词查找树，哈希树的一种变种，通常被用于字符串匹配，用来解决在一组字符串集合中快速查找某个字符串的问题。像浏览器搜索的关键词提示就可以基于 Trie 树来做的。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/security/brower-trie.png" alt="浏览器 Trie 树效果展示" />&lt;/p>
&lt;p>假如我们的敏感词库中有以下敏感词：&lt;/p>
&lt;ul>
&lt;li>高清视频&lt;/li>
&lt;li>高清 CV&lt;/li>
&lt;li>东京冷&lt;/li>
&lt;li>东京热&lt;/li>
&lt;/ul>
&lt;p>我们构造出来的敏感词 Trie 树就是下面这样的：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/security/sensitive-word-trie.png" alt="敏感词 Trie 树" />&lt;/p>
&lt;p>当我们要查找对应的字符串“东京热”的话，我们会把这个字符串切割成单个的字符“东”、“京”、“热”，然后我们从 Trie 树的根节点开始匹配。&lt;/p>
&lt;p>可以看出， &lt;strong>Trie 树的核心原理其实很简单，就是通过公共前缀来提高字符串匹配效率。&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://mvnrepository.com/artifact/org.apache.commons/commons-collections4">Apache Commons Collections&lt;/a> 这个库中就有 Trie 树实现：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/security/common-collections-trie.png" alt="Apache Commons Collections 中的 Trie 树实现" />&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Trie&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, String&lt;span style="color:#f92672">&amp;gt;&lt;/span> trie &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> PatriciaTrie&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trie.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Abigail&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;student&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trie.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Abi&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;doctor&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trie.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Annabel&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;teacher&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trie.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Christina&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;student&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trie.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Chris&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;doctor&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Assertions.&lt;span style="color:#a6e22e">assertTrue&lt;/span>(trie.&lt;span style="color:#a6e22e">containsKey&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Abigail&amp;#34;&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>assertEquals(&lt;span style="color:#e6db74">&amp;#34;{Abi=doctor, Abigail=student}&amp;#34;&lt;/span>, trie.&lt;span style="color:#a6e22e">prefixMap&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Abi&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>assertEquals(&lt;span style="color:#e6db74">&amp;#34;{Chris=doctor, Christina=student}&amp;#34;&lt;/span>, trie.&lt;span style="color:#a6e22e">prefixMap&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Chr&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">toString&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Trie 树是一种利用空间换时间的数据结构，占用的内存会比较大。也正是因为这个原因，实际工程项目中都是使用的改进版 Trie 树例如双数组 Trie 树（Double-Array Trie，DAT）。&lt;/p></description></item><item><title>普通人的春招总结（阿里、腾讯offer）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/summary-of-spring-recruitment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/summary-of-spring-recruitment/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：牛客网热帖，写的很全面！暑期实习，投了阿里、腾讯、字节，拿到了阿里和腾讯的 offer。&lt;/p>
&lt;p>&lt;strong>原文地址：&lt;/strong> &lt;a href="https://www.nowcoder.com/discuss/640519">https://www.nowcoder.com/discuss/640519&lt;/a>&lt;/p>
&lt;p>&lt;strong>下篇&lt;/strong>：&lt;a href="https://www.nowcoder.com/discuss/804679">十年饮冰，难凉热血——秋招总结&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="背景">
 背景
 &lt;a class="anchor" href="#%e8%83%8c%e6%99%af">#&lt;/a>
&lt;/h2>
&lt;p>写这篇文章的时候，腾讯 offer 已经下来了，春招也算结束了，这次找暑期实习没有像去年找日常实习一样海投，只投了 BAT 三家，阿里和腾讯收获了 offer，字节没有给面试机会，可能是笔试太拉垮了。&lt;/p>
&lt;p>楼主大三，双非本科，我的春招的起始时间应该是 2 月 20 日到 3 月 23 日收到阿里意向书为止，但是从 3 月 7 日蚂蚁技术终面面完之后就没有面过技术面了，只面过两个 HR 面，剩下的时间都在等 offer。最开始是找朋友内推了字节财经的日常实习，但是到现在还在简历评估，后面又投了财经的暑期实习，笔试之后就一直卡在流程里了。腾讯是一开始被天美捞了，一面挂了之后被 PCG 捞了，最后走完了流程。阿里提前批投了好多部门，蚂蚁最先走完了终面，就录入了系统，最后拿了 offer。这一路走过来真的是酸甜苦辣都经历过，因为学历自卑过，以至于想去考研。总而言之，一定要找一个搭档和你一起复习，比如说 @你怕是个憨批哦，这是我实验室的同学，也是我们实验室的队长，这个人是真的强，阿里核心部门都拿遍了，他在我复习的过程中给了我很多帮助。&lt;/p>
&lt;h2 id="写这个帖子的目的">
 写这个帖子的目的
 &lt;a class="anchor" href="#%e5%86%99%e8%bf%99%e4%b8%aa%e5%b8%96%e5%ad%90%e7%9a%84%e7%9b%ae%e7%9a%84">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>写给自己：总结反思一下大学前三年以及找工作的一些经历与感悟。&lt;/li>
&lt;li>写给还在找实习的朋友：希望自己的经历以及面经]能给你们一些启发和帮助。&lt;/li>
&lt;li>写给和我一样有着大厂梦的学弟学妹们：你们还有很长的准备时间，无论你之前在干什么，没有目标也好，碌碌无为也好，没找对方向也好，只要从现在开始，找对学习的方向，并且坚持不懈的学上一年两年，一定可以实现你的梦想的。&lt;/li>
&lt;/ol>
&lt;h2 id="我的大学经历">
 我的大学经历
 &lt;a class="anchor" href="#%e6%88%91%e7%9a%84%e5%a4%a7%e5%ad%a6%e7%bb%8f%e5%8e%86">#&lt;/a>
&lt;/h2>
&lt;p>先简单聊聊一下自己大学的经历。&lt;/p>
&lt;p>本人无论文、无比赛、无 ACM，要啥奖没啥奖，绩点还行，不是很拉垮，也不亮眼。保研肯定保不了，考研估计也考不上。&lt;/p>
&lt;p>大一时候加入了工作室，上学期自学了 C 语言和数据结构，从寒假开始学 Java，当时还不知道 Java 那么卷，我得到的消息是 Java 好找工作，这里就不由得感叹信息差的重要性了，我当时只知道前端、后端和安卓开发，而我确实对后端开发感兴趣，但是因为信息差，我只知道 Java 可以做后端开发，并不知道后端开发其实是一个很局限的概念，后面才慢慢了解到后台开发、服务端开发这些名词，也不知道 C++、Golang 等语言也可以做后台开发，所以就学了 Java。但其实 Java 更适合做业务，C++ 更适合做底层开发、服务端开发，我虽然对业务不反感，但是对 OS、Network 这些更感兴趣一些，当然这些会作为我的一些兴趣，业余时间会自己去研究下。&lt;/p>
&lt;h3 id="学习路线">
 学习路线
 &lt;a class="anchor" href="#%e5%ad%a6%e4%b9%a0%e8%b7%af%e7%ba%bf">#&lt;/a>
&lt;/h3>
&lt;p>大概学习的路线就是：Java SE 基础 -&amp;gt; MySQL -&amp;gt; Java Web（主要包括 JDBC、Servlet、JSP 等）-&amp;gt; SSM（其实当时 Spring Boot 已经兴起，但是我觉得没有 SSM 基础很难学会 Spring Boot，就先学了 SSM）-&amp;gt; Spring Boot -&amp;gt; Spring Cloud（当时虽然学了 Spring Cloud，但是缺少项目的锤炼，完全不会用，只是了解了分布式的一些概念）-&amp;gt; Redis -&amp;gt; Nginx -&amp;gt; 计算机网络（本来是计算机专业的必修课，可是我们专业要到大三下才学，所以就提前自学了）-&amp;gt; Dubbo -&amp;gt; Zookeeper -&amp;gt; JVM -&amp;gt; JUC -&amp;gt; Netty -&amp;gt; Rabbit MQ -&amp;gt; 操作系统（同计算机网络）-&amp;gt; 计算机组成原理（直接不开这门课）。&lt;/p></description></item><item><title>权限系统设计详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/design-of-authority-system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/design-of-authority-system/</guid><description>&lt;blockquote>
&lt;p>作者：转转技术团队&lt;/p>
&lt;p>原文：&lt;a href="https://mp.weixin.qq.com/s/ONMuELjdHYa0yQceTj01Iw">https://mp.weixin.qq.com/s/ONMuELjdHYa0yQceTj01Iw&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="老权限系统的问题与现状">
 老权限系统的问题与现状
 &lt;a class="anchor" href="#%e8%80%81%e6%9d%83%e9%99%90%e7%b3%bb%e7%bb%9f%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%8e%e7%8e%b0%e7%8a%b6">#&lt;/a>
&lt;/h2>
&lt;p>转转公司在过去并没有一个统一的权限管理系统，权限管理由各业务自行研发或是使用其他业务的权限系统，权限管理的不统一带来了不少问题：&lt;/p>
&lt;ol>
&lt;li>各业务重复造轮子，维护成本高&lt;/li>
&lt;li>各系统只解决部分场景问题，方案不够通用，新项目选型时没有可靠的权限管理方案&lt;/li>
&lt;li>缺乏统一的日志管理与审批流程，在授权信息追溯上十分困难&lt;/li>
&lt;/ol>
&lt;p>基于上述问题，去年底公司启动建设转转统一权限系统，目标是开发一套灵活、易用、安全的权限管理系统，供各业务使用。&lt;/p>
&lt;h2 id="业界权限系统的设计方式">
 业界权限系统的设计方式
 &lt;a class="anchor" href="#%e4%b8%9a%e7%95%8c%e6%9d%83%e9%99%90%e7%b3%bb%e7%bb%9f%e7%9a%84%e8%ae%be%e8%ae%a1%e6%96%b9%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>目前业界主流的权限模型有两种，下面分别介绍下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>基于角色的访问控制（RBAC）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>基于属性的访问控制（ABAC）&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="rbac-模型">
 RBAC 模型
 &lt;a class="anchor" href="#rbac-%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>基于角色的访问控制（Role-Based Access Control，简称 RBAC）&lt;/strong> 指的是通过用户的角色（Role）授权其相关权限，实现了灵活的访问控制，相比直接授予用户权限，要更加简单、高效、可扩展。&lt;/p>
&lt;p>一个用户可以拥有若干角色，每一个角色又可以被分配若干权限这样，就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系。&lt;/p>
&lt;p>用一个图来描述如下：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/security/design-of-authority-system/rbac.png" alt="RBAC 权限模型示意图" />&lt;/p>
&lt;p>当使用 &lt;code>RBAC模型&lt;/code> 时，通过分析用户的实际情况，基于共同的职责和需求，授予他们不同角色。这种 &lt;code>用户 -&amp;gt; 角色 -&amp;gt; 权限&lt;/code> 间的关系，让我们可以不用再单独管理单个用户权限，用户从授予的角色里面获取所需的权限。&lt;/p>
&lt;p>以一个简单的场景（Gitlab 的权限系统）为例，用户系统中有 &lt;code>Admin&lt;/code>、&lt;code>Maintainer&lt;/code>、&lt;code>Operator&lt;/code> 三种角色，这三种角色分别具备不同的权限，比如只有 &lt;code>Admin&lt;/code> 具备创建代码仓库、删除代码仓库的权限，其他的角色都不具备。我们授予某个用户 &lt;code>Admin&lt;/code> 这个角色，他就具备了 &lt;strong>创建代码仓库&lt;/strong> 和 &lt;strong>删除代码仓库&lt;/strong> 这两个权限。&lt;/p>
&lt;p>通过 &lt;code>RBAC模型&lt;/code> ，当存在多个用户拥有相同权限时，我们只需要创建好拥有该权限的角色，然后给不同的用户分配不同的角色，后续只需要修改角色的权限，就能自动修改角色内所有用户的权限。&lt;/p>
&lt;h3 id="abac-模型">
 ABAC 模型
 &lt;a class="anchor" href="#abac-%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>基于属性的访问控制（Attribute-Based Access Control，简称 ABAC）&lt;/strong> 是一种比 &lt;code>RBAC模型&lt;/code> 更加灵活的授权模型，它的原理是通过各种属性来动态判断一个操作是否可以被允许。这个模型在云系统中使用的比较多，比如 AWS，阿里云等。&lt;/p>
&lt;p>考虑下面这些场景的权限控制：&lt;/p>
&lt;ol>
&lt;li>授权某个人具体某本书的编辑权限&lt;/li>
&lt;li>当一个文档的所属部门跟用户的部门相同时，用户可以访问这个文档&lt;/li>
&lt;li>当用户是一个文档的拥有者并且文档的状态是草稿，用户可以编辑这个文档&lt;/li>
&lt;li>早上九点前禁止 A 部门的人访问 B 系统&lt;/li>
&lt;li>在除了上海以外的地方禁止以管理员身份访问 A 系统&lt;/li>
&lt;li>用户对 2022-06-07 之前创建的订单有操作权限&lt;/li>
&lt;/ol>
&lt;p>可以发现上述的场景通过 &lt;code>RBAC模型&lt;/code> 很难去实现，因为 &lt;code>RBAC模型&lt;/code> 仅仅描述了用户可以做什么操作，但是操作的条件，以及操作的数据，&lt;code>RBAC模型&lt;/code> 本身是没有这些限制的。但这恰恰是 &lt;code>ABAC模型&lt;/code> 的长处，&lt;code>ABAC模型&lt;/code> 的思想是基于用户、访问的数据的属性、以及各种环境因素去动态计算用户是否有权限进行操作。&lt;/p></description></item><item><title>认证授权基础概念详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/basis-of-authority-certification/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/basis-of-authority-certification/</guid><description>&lt;h2 id="认证-authentication-和授权-authorization的区别是什么">
 认证 (Authentication) 和授权 (Authorization)的区别是什么？
 &lt;a class="anchor" href="#%e8%ae%a4%e8%af%81-authentication-%e5%92%8c%e6%8e%88%e6%9d%83-authorization%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>这是一个绝大多数人都会混淆的问题。首先先从读音上来认识这两个名词，很多人都会把它俩的读音搞混，所以我建议你先先去查一查这两个单词到底该怎么读，他们的具体含义是什么。&lt;/p>
&lt;p>说简单点就是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>认证 (Authentication)：&lt;/strong> 你是谁。&lt;/li>
&lt;li>&lt;strong>授权 (Authorization)：&lt;/strong> 你有权限干什么。&lt;/li>
&lt;/ul>
&lt;p>稍微正式点（啰嗦点）的说法就是：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Authentication（认证）&lt;/strong> 是验证您的身份的凭据（例如用户名/用户 ID 和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。&lt;/li>
&lt;li>&lt;strong>Authorization（授权）&lt;/strong> 发生在 &lt;strong>Authentication（认证）&lt;/strong> 之后。授权嘛，光看意思大家应该就明白，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如 admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。&lt;/li>
&lt;/ul>
&lt;p>认证：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/security/authentication-login.png" alt="认证登录" />&lt;/p>
&lt;p>授权：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/security/20210604161032412.png" alt="没有权限" />&lt;/p>
&lt;p>这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。&lt;/p>
&lt;h2 id="rbac-模型了解吗">
 RBAC 模型了解吗？
 &lt;a class="anchor" href="#rbac-%e6%a8%a1%e5%9e%8b%e4%ba%86%e8%a7%a3%e5%90%97">#&lt;/a>
&lt;/h2>
&lt;p>系统权限控制最常采用的访问控制模型就是 &lt;strong>RBAC 模型&lt;/strong> 。&lt;/p>
&lt;p>&lt;strong>什么是 RBAC 呢？&lt;/strong> RBAC 即基于角色的权限访问控制（Role-Based Access Control）。这是一种通过角色关联权限，角色同时又关联用户的授权的方式。&lt;/p>
&lt;p>简单地说：一个用户可以拥有若干角色，每一个角色又可以被分配若干权限，这样就构造成“用户-角色-权限” 的授权模型。在这种模型中，用户与角色、角色与权限之间构成了多对多的关系。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/security/design-of-authority-system/rbac.png" alt="RBAC 权限模型示意图" />&lt;/p>
&lt;p>在 RBAC 权限模型中，权限与角色相关联，用户通过成为包含特定角色的成员而得到这些角色的权限，这就极大地简化了权限的管理。&lt;/p>
&lt;p>为了实现 RBAC 权限模型，数据库表的常见设计如下（一共 5 张表，2 张用户建立表之间的联系）：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/2020-11/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1-%E6%9D%83%E9%99%90.png" alt="" />&lt;/p>
&lt;p>通过这个权限模型，我们可以创建不同的角色并为不同的角色分配不同的权限范围（菜单）。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/books%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97.png" alt="" />&lt;/p>
&lt;p>通常来说，如果系统对于权限控制要求比较严格的话，一般都会选择使用 RBAC 模型来做权限控制。&lt;/p>
&lt;h2 id="什么是-cookie--cookie-的作用是什么">
 什么是 Cookie ? Cookie 的作用是什么?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-cookie--cookie-%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/security/cookie-sessionId.png" alt="" />&lt;/p></description></item><item><title>冗余设计详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-availability/redundancy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-availability/redundancy/</guid><description>&lt;p>冗余设计是保证系统和数据高可用的最常的手段。&lt;/p>
&lt;p>对于服务来说，冗余的思想就是相同的服务部署多份，如果正在使用的服务突然挂掉的话，系统可以很快切换到备份服务上，大大减少系统的不可用时间，提高系统的可用性。&lt;/p>
&lt;p>对于数据来说，冗余的思想就是相同的数据备份多份，这样就可以很简单地提高数据的安全性。&lt;/p>
&lt;p>实际上，日常生活中就有非常多的冗余思想的应用。&lt;/p>
&lt;p>拿我自己来说，我对于重要文件的保存方法就是冗余思想的应用。我日常所使用的重要文件都会同步一份在 GitHub 以及个人云盘上，这样就可以保证即使电脑硬盘损坏，我也可以通过 GitHub 或者个人云盘找回自己的重要文件。&lt;/p>
&lt;p>高可用集群（High Availability Cluster，简称 HA Cluster）、同城灾备、异地灾备、同城多活和异地多活是冗余思想在高可用系统设计中最典型的应用。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>高可用集群&lt;/strong> : 同一份服务部署两份或者多份，当正在使用的服务突然挂掉的话，可以切换到另外一台服务，从而保证服务的高可用。&lt;/li>
&lt;li>&lt;strong>同城灾备&lt;/strong>：一整个集群可以部署在同一个机房，而同城灾备中相同服务部署在同一个城市的不同机房中。并且，备用服务不处理请求。这样可以避免机房出现意外情况比如停电、火灾。&lt;/li>
&lt;li>&lt;strong>异地灾备&lt;/strong>：类似于同城灾备，不同的是，相同服务部署在异地（通常距离较远，甚至是在不同的城市或者国家）的不同机房中&lt;/li>
&lt;li>&lt;strong>同城多活&lt;/strong>：类似于同城灾备，但备用服务可以处理请求，这样可以充分利用系统资源，提高系统的并发。&lt;/li>
&lt;li>&lt;strong>异地多活&lt;/strong> : 将服务部署在异地的不同机房中，并且，它们可以同时对外提供服务。&lt;/li>
&lt;/ul>
&lt;p>高可用集群单纯是服务的冗余，并没有强调地域。同城灾备、异地灾备、同城多活和异地多活实现了地域上的冗余。&lt;/p>
&lt;p>同城和异地的主要区别在于机房之间的距离。异地通常距离较远，甚至是在不同的城市或者国家。&lt;/p>
&lt;p>和传统的灾备设计相比，同城多活和异地多活最明显的改变在于“多活”，即所有站点都是同时在对外提供服务的。异地多活是为了应对突发状况比如火灾、地震等自然或者人为灾害。&lt;/p>
&lt;p>光做好冗余还不够，必须要配合上 &lt;strong>故障转移&lt;/strong> 才可以！ 所谓故障转移，简单来说就是实现不可用服务快速且自动地切换到可用服务，整个过程不需要人为干涉。&lt;/p>
&lt;p>举个例子：哨兵模式的 Redis 集群中，如果 Sentinel（哨兵） 检测到 master 节点出现故障的话， 它就会帮助我们实现故障转移，自动将某一台 slave 升级为 master，确保整个 Redis 系统的可用性。整个过程完全自动，不需要人工介入。我在&lt;a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7">《Java 面试指北》&lt;/a>的「技术面试题篇」中的数据库部分详细介绍了 Redis 集群相关的知识点&amp;amp;面试题，感兴趣的小伙伴可以看看。&lt;/p>
&lt;p>再举个例子：Nginx 可以结合 Keepalived 来实现高可用。如果 Nginx 主服务器宕机的话，Keepalived 可以自动进行故障转移，备用 Nginx 主服务器升级为主服务。并且，这个切换对外是透明的，因为使用的虚拟 IP，虚拟 IP 不会改变。我在&lt;a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7">《Java 面试指北》&lt;/a>的「技术面试题篇」中的「服务器」部分详细介绍了 Nginx 相关的知识点&amp;amp;面试题，感兴趣的小伙伴可以看看。&lt;/p>
&lt;p>异地多活架构实施起来非常难，需要考虑的因素非常多。本人不才，实际项目中并没有实践过异地多活架构，我对其了解还停留在书本知识。&lt;/p>
&lt;p>如果你想要深入学习异地多活相关的知识，我这里推荐几篇我觉得还不错的文章：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/T6mMDdtTfBuIiEowCpqu6Q">搞懂异地多活，看这篇就够了- 水滴与银弹 - 2021&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s/hMD-IS__4JE5_nQhYPYSTg">四步构建异地多活&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://gk.link/a/10pKZ">《从零开始学架构》— 28 | 业务高可用的保障：异地多活架构&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>不过，这些文章大多也都是在介绍概念知识。目前，网上还缺少真正介绍具体要如何去实践落地异地多活架构的资料。&lt;/p></description></item><item><title>如何基于Redis实现延时任务</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-delayed-task/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/redis/redis-delayed-task/</guid><description>&lt;p>基于 Redis 实现延时任务的功能无非就下面两种方案：&lt;/p>
&lt;ol>
&lt;li>Redis 过期事件监听&lt;/li>
&lt;li>Redisson 内置的延时队列&lt;/li>
&lt;/ol>
&lt;p>面试的时候，你可以先说自己考虑了这两种方案，但最后发现 Redis 过期事件监听这种方案存在很多问题，因此你最终选择了 Redisson 内置的 DelayedQueue 这种方案。&lt;/p>
&lt;p>这个时候面试官可能会追问你一些相关的问题，我们后面会提到，提前准备就好了。&lt;/p>
&lt;p>另外，除了下面介绍到的这些问题之外，Redis 相关的常见问题建议你都复习一遍，不排除面试官会顺带问你一些 Redis 的其他问题。&lt;/p>
&lt;h3 id="redis-过期事件监听实现延时任务功能的原理">
 Redis 过期事件监听实现延时任务功能的原理？
 &lt;a class="anchor" href="#redis-%e8%bf%87%e6%9c%9f%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e5%ae%9e%e7%8e%b0%e5%bb%b6%e6%97%b6%e4%bb%bb%e5%8a%a1%e5%8a%9f%e8%83%bd%e7%9a%84%e5%8e%9f%e7%90%86">#&lt;/a>
&lt;/h3>
&lt;p>Redis 2.0 引入了发布订阅 (pub/sub) 功能。在 pub/sub 中，引入了一个叫做 &lt;strong>channel（频道）&lt;/strong> 的概念，有点类似于消息队列中的 &lt;strong>topic（主题）&lt;/strong>。&lt;/p>
&lt;p>pub/sub 涉及发布者（publisher）和订阅者（subscriber，也叫消费者）两个角色：&lt;/p>
&lt;ul>
&lt;li>发布者通过 &lt;code>PUBLISH&lt;/code> 投递消息给指定 channel。&lt;/li>
&lt;li>订阅者通过&lt;code>SUBSCRIBE&lt;/code>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-pub-sub.png" alt="Redis 发布订阅 (pub/sub) 功能" />&lt;/p>
&lt;p>在 pub/sub 模式下，生产者需要指定消息发送到哪个 channel 中，而消费者则订阅对应的 channel 以获取消息。&lt;/p>
&lt;p>Redis 中有很多默认的 channel，这些 channel 是由 Redis 本身向它们发送消息的，而不是我们自己编写的代码。其中，&lt;code>__keyevent@0__:expired&lt;/code> 就是一个默认的 channel，负责监听 key 的过期事件。也就是说，当一个 key 过期之后，Redis 会发布一个 key 过期的事件到&lt;code>__keyevent@&amp;lt;db&amp;gt;__:expired&lt;/code>这个 channel 中。&lt;/p></description></item><item><title>如何在技术初试中考察程序员的技术能力</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/how-to-examine-the-technical-ability-of-programmers-in-the-first-test-of-technology/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：从面试官和面试者两个角度探讨了技术面试！非常不错！&lt;/p>
&lt;p>&lt;strong>内容概览：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>实战与理论结合。比如，候选人叙述 JVM 内存模型布局之后，可以接着问：有哪些原因可能会导致 OOM , 有哪些预防措施? 你是否遇到过内存泄露的问题? 如何排查和解决这类问题?&lt;/li>
&lt;li>项目经历考察不宜超过两个。因为要深入考察一个项目的详情，所占用的时间还是比较大的。一般来说，会让候选人挑选一个他或她觉得最有收获的/最有挑战的/印象最深刻的/自己觉得特有意思的项目。然后围绕这个项目进行发问。通常是从项目背景出发，考察项目的技术栈、项目模块及交互的整体理解、项目中遇到的有挑战性的技术问题及解决方案、排查和解决问题、代码可维护性问题、工程质量保障等。&lt;/li>
&lt;li>多问少说，让候选者多表现。根据候选者的回答适当地引导或递进或横向移动。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://www.cnblogs.com/lovesqcc/p/15169365.html">https://www.cnblogs.com/lovesqcc/p/15169365.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="灵魂三连问">
 灵魂三连问
 &lt;a class="anchor" href="#%e7%81%b5%e9%ad%82%e4%b8%89%e8%bf%9e%e9%97%ae">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>你觉得人怎么样？ 【表达能力、沟通能力、学习能力、总结能力、自省改进能力、抗压能力、情绪管理能力、影响力、团队管理能力】&lt;/li>
&lt;li>如果让他独立完成项目的设计和实现，你觉得他能胜任吗？ 【系统设计能力、项目管理能力】&lt;/li>
&lt;li>他的分析和解决问题的能力，你的评价是啥？【原理理解能力、实战应用能力】&lt;/li>
&lt;/ol>
&lt;h2 id="考察目标和思路">
 考察目标和思路
 &lt;a class="anchor" href="#%e8%80%83%e5%af%9f%e7%9b%ae%e6%a0%87%e5%92%8c%e6%80%9d%e8%b7%af">#&lt;/a>
&lt;/h2>
&lt;p>首先明确，技术初试的考察目标：&lt;/p>
&lt;ul>
&lt;li>候选人的技术基础；&lt;/li>
&lt;li>候选人解决问题的思路和能力。&lt;/li>
&lt;/ul>
&lt;p>技术基础是基石（冰山之下的东西），占七分， 解决问题的思路和能力是落地（冰山之上露出的部分），占三分。 业务和技术基础考察，三七开。&lt;/p>
&lt;p>核心考察目标：分析和解决问题的能力。&lt;/p>
&lt;p>技术层面：深度 + 应用能力 + 广度。 对于校招或社招 P6 级别以下，要多注重 深度 + 应用能力，广度是加分项； 在 P6 之上，可增加 广度。&lt;/p>
&lt;ul>
&lt;li>校招：基础扎实，思维敏捷。 主要考察内容：基础数据结构与算法、进程与并发、内存管理、系统调用与 IO 机制、网络协议、数据库范式与设计、设计模式、设计原则、编程习惯；&lt;/li>
&lt;li>社招：经验丰富，里外兼修。 主要考察内容：有一定深度的基础技术机制，比如 Java 内存模型及内存泄露、 JVM 机制、类加载机制、数据库索引及查询优化、缓存、消息中间件、项目、架构设计、工程规范等。&lt;/li>
&lt;/ul>
&lt;h3 id="技术基础是什么">
 技术基础是什么?
 &lt;a class="anchor" href="#%e6%8a%80%e6%9c%af%e5%9f%ba%e7%a1%80%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>作为技术初试官，怎么去考察技术基础？究竟什么是技术基础？是知道什么，还是知道如何思考？知识作为现有的成熟原理体系，构成了基础的重要组成部分，而知道如何思考亦尤为重要。俗话说，知其然而知其所以然。知其然，是指熟悉现有知识体系，知其所以然，则是自底向上推导，真正理解知识的来龙去脉，理解为何是这样而不是那样。毕竟，对于本质是逻辑的程序世界而言，并无定法。知道如何思考，并能缜密地设计和开发，深入到细节，这就是技术基础吧。&lt;/p>
&lt;h3 id="为什么要考察技术基础">
 为什么要考察技术基础?
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%80%83%e5%af%9f%e6%8a%80%e6%9c%af%e5%9f%ba%e7%a1%80">#&lt;/a>
&lt;/h3>
&lt;p>程序员最重要的两种技术思维能力，是逻辑思维能力和抽象设计能力。逻辑思维能力是基础，抽象设计能力是高阶。 考察技术基础，正好可以同时考察这两种思维能力。能不能理解基础技术概念及关联，是考察逻辑思维能力；能不能把业务问题抽象成技术问题并合理的组织映射，是考察抽象设计能力。&lt;/p>
&lt;p>绝大部分业务问题，都可以抽象成技术问题。在某种意义上，业务问题只是技术问题的领域化表述。&lt;/p>
&lt;p>因此，通过技术基础考察候选者，才能考察到候选者的真实技术实力：技术深度和广度。&lt;/p>
&lt;h3 id="为什么不能单考察业务维度">
 为什么不能单考察业务维度？
 &lt;a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e5%8d%95%e8%80%83%e5%af%9f%e4%b8%9a%e5%8a%a1%e7%bb%b4%e5%ba%a6">#&lt;/a>
&lt;/h3>
&lt;p>因为业务方面通常比较熟悉，可能就直接按照现有方案说出来了，很难考察到候选人的深入理解、横向拓展和归纳总结能力。&lt;/p></description></item><item><title>如何甄别应聘者的包装程度</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/screen-candidates-for-packaging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/screen-candidates-for-packaging/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：经常听到培训班待过的朋友给我说他们的老师是怎么教他们“包装”自己的，不光是培训班，我认识的很多朋友也都会在面试之前“包装”一下自己，所以这个现象是普遍存在的。但是面试官也不都是傻子，通过下面这篇文章来看看面试官是如何甄别应聘者的包装程度。&lt;/p>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://my.oschina.net/hooker/blog/3014656">https://my.oschina.net/hooker/blog/3014656&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>上到职场干将下到职场萌新，都会接触到包装简历这个词语。当你简历投到心仪的公司，公司内负责求职的工作人员是如何甄别简历的包装程度的？我根据自己的经验写下了这篇文章，谁都不是天才，包装无可厚非，切勿对号入座!&lt;/p>
&lt;h2 id="正文">
 正文
 &lt;a class="anchor" href="#%e6%ad%a3%e6%96%87">#&lt;/a>
&lt;/h2>
&lt;p>在互联网极速膨胀的社会背景下，各行各业涌入互联网的 IT 民工日益增大。&lt;/p>
&lt;p>早在 2016 年，我司发布了 Java、Ios 工程师的招聘信息，就 Java 工程师单个岗位而言，日收简历近 200 份，Ios 日收简历近一千份。&lt;/p>
&lt;p>没错，这就是当年培训机构对 Ios 工程师这个岗位发起的市场讨伐。而随着近几年的发展，市场供大于求现象日益严重。人员摸底成为用人单位对人才考核的重大难题。&lt;/p>
&lt;p>笔者初次与求职者以面试的形式进行沟通是 2015 年 6 月。由于当时笔者从业时间短，经验不够丰富，错过了一些优秀的求职者。&lt;/p>
&lt;p>三年后的，今天，笔者再次因公司规模扩大而深入与求职者进行沟通。&lt;/p>
&lt;h3 id="1初选如何鉴别劣质简历">
 1.初选如何鉴别劣质简历
 &lt;a class="anchor" href="#1%e5%88%9d%e9%80%89%e5%a6%82%e4%bd%95%e9%89%b4%e5%88%ab%e5%8a%a3%e8%b4%a8%e7%ae%80%e5%8e%86">#&lt;/a>
&lt;/h3>
&lt;p>培训机构除了提供技术培训，往往还提供&lt;strong>简历编写指导&lt;/strong>、&lt;strong>面试指导&lt;/strong>。很多潜移默化的东西，我们很难甄别。但培训机构包装的简历，存在千遍一律的特征。&lt;/p>
&lt;p>&lt;strong>年龄较小却具备高级文凭&lt;/strong>&lt;/p>
&lt;p>年龄较小却具备高级文凭，这个或许不能作为一项标准，但是大部分的应聘者，均符合传统文凭的市场情况。个别技术爱好者可能通过自考获得文凭，这种情况需提供独有的技术亮点。&lt;/p>
&lt;p>&lt;strong>年龄较大却几乎不具备技术经验&lt;/strong>&lt;/p>
&lt;p>年龄较大却几乎不具备技术经验，相对前一点，这个问题就比较严重了。大家都知道，一个正常的人，对新事物的接受能力会随着年龄的增长而降低，互联网技术也包括其内。如果一个人年龄较大不具备技术经验，那么只有两种情况：&lt;/p>
&lt;ol>
&lt;li>中途转行(通过培训、自学等方式强行入行)。&lt;/li>
&lt;li>由于能力问题，已有的经验不敢写入简历中(能力与经验/薪资不符)。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>项目经验多为管理系统&lt;/strong>&lt;/p>
&lt;p>项目经验，这一项用来评估应聘者的水平太合适不过了。随着互联网的发展迭代，每一年都会出来很多创新型的互联网公司和新兴行业。笔者最近发布的招聘需求里面。CRM 系统、商城、XX 管理系统、问卷系统、课堂系统占了 90%的份额。试问现在 2019 年，内部管理系统这么火爆么。言归正传，我们对于简历的评估，应当多考虑“确有其事”的项目。比如说该人员当时就职于 XX 公司，该公司当时的背景下确实研发了该项目（外包除外）。&lt;/p>
&lt;p>&lt;strong>项目的背景不符合互联网发展背景&lt;/strong>&lt;/p>
&lt;p>项目背景，每年的市场走向不同，从早些年的电商、彩票风波，到后来的 O2O、夺宝、直播、新零售。每个系列的产品的出现，都符合市场的定义。如果简历中出现 18 年、19 年才刚立项做彩票(15 年政府禁止互联网彩票)、O2O、商城、夺宝(17 年初禁止夺宝类产品)、直播等产品。显然是非常不符合市场需求的。这种情况下需考虑具体情况是否存在理解空间。&lt;/p>
&lt;p>&lt;strong>缺乏新意&lt;/strong>&lt;/p>
&lt;p>不同工作经验下多个项目技术架构或项目结构一致，缺乏新意。一般情况而言，不同的公司技术栈不同，甚至产品的走向和模式完全不同。故此，当一个应聘者多家公司的多个项目中写到的技术千遍一律，业务流程异曲同工。看似整洁，实则更加缺乏说服力。&lt;/p>
&lt;p>&lt;strong>技术过于新颖，对旧技术却只字不提&lt;/strong>&lt;/p>
&lt;p>技术过于新颖，根据互联网技术发展的走向来看，我们在不断向新型技术靠拢。但是任何企业作为资历深厚的 CTO、架构师来说。往往会选择更稳定、更成熟、学习成本更低的已有技术。对新技术的追求不会过于明显。而培训机构则是“哪项技术火我们就教哪项”。故此，出现了很多走入互联网行业的新人对旧技术一窍不通。甚至很多技术都没听过。&lt;/p>
&lt;p>&lt;strong>工作经验较丰富，但从事的工作较低级。&lt;/strong>&lt;/p>
&lt;p>工作经验比较丰富，单从事的工作比较低级，这里存在很大的问题，要么就是原公司没法提供合理的舞台给该人员更好的发展空间，要么就是该人员能力不够，没法完成更高级的工作。当然，还有一种情况就是该人员包装过多的经验导致简历中不和谐。这种情况需要评估公司规模和背景。&lt;/p>
&lt;p>&lt;strong>公司背景跨省跨市&lt;/strong>&lt;/p>
&lt;p>可能很多用人单位和鄙人一样，最近接受到的简历，90%为跨市跳槽的人员。其中武汉占了 60%以上。均为武汉 XX 网络科技有限公司。公司规模均小于 50 人。也有厦门、宁波、南京等等。这个问题笔者就不提了，大家都懂的。跨地区跳槽不好查证。&lt;/p></description></item><item><title>软件工程简明教程</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/basis/software-engineering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/basis/software-engineering/</guid><description>&lt;p>大部分软件开发从业者，都会忽略软件开发中的一些最基础、最底层的一些概念。但是，这些软件开发的概念对于软件开发来说非常重要，就像是软件开发的基石一样。这也是我写这篇文章的原因。&lt;/p>
&lt;h2 id="何为软件工程">
 何为软件工程？
 &lt;a class="anchor" href="#%e4%bd%95%e4%b8%ba%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;p>1968 年 NATO（北大西洋公约组织）提出了&lt;strong>软件危机&lt;/strong>（&lt;strong>Software crisis&lt;/strong>）一词。同年，为了解决软件危机问题，“&lt;strong>软件工程&lt;/strong>”的概念诞生了。一门叫做软件工程的学科也就应运而生。&lt;/p>
&lt;p>随着时间的推移，软件工程这门学科也经历了一轮又一轮的完善，其中的一些核心内容比如软件开发模型越来越丰富实用！&lt;/p>
&lt;p>&lt;strong>什么是软件危机呢？&lt;/strong>&lt;/p>
&lt;p>简单来说，软件危机描述了当时软件开发的一个痛点：我们很难高效地开发出质量高的软件。&lt;/p>
&lt;p>Dijkstra（Dijkstra 算法的作者） 在 1972 年图灵奖获奖感言中也提高过软件危机，他是这样说的：“导致软件危机的主要原因是机器变得功能强大了几个数量级！坦率地说：只要没有机器，编程就完全没有问题。当我们有一些弱小的计算机时，编程成为一个温和的问题，而现在我们有了庞大的计算机，编程也同样成为一个巨大的问题”。&lt;/p>
&lt;p>&lt;strong>说了这么多，到底什么是软件工程呢？&lt;/strong>&lt;/p>
&lt;p>工程是为了解决实际的问题将理论应用于实践。软件工程指的就是将工程思想应用于软件开发。&lt;/p>
&lt;p>上面是我对软件工程的定义，我们再来看看比较权威的定义。IEEE 软件工程汇刊给出的定义是这样的：　(1)将系统化的、规范的、可量化的方法应用到软件的开发、运行及维护中，即将工程化方法应用于软件。　(2)在(1)中所述方法的研究。&lt;/p>
&lt;p>总之，软件工程的终极目标就是：&lt;strong>在更少资源消耗的情况下，创造出更好、更容易维护的软件。&lt;/strong>&lt;/p>
&lt;h2 id="软件开发过程">
 软件开发过程
 &lt;a class="anchor" href="#%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e8%bf%87%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B">维基百科是这样定义软件开发过程&lt;/a>的：&lt;/p>
&lt;blockquote>
&lt;p>软件开发过程（英语：software development process），或软件过程（英语：software process），是软件开发的开发生命周期（software development life cycle），其各个阶段实现了软件的需求定义与分析、设计、实现、测试、交付和维护。软件过程是在开发与构建系统时应遵循的步骤，是软件开发的路线图。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>需求分析：分析用户的需求，建立逻辑模型。&lt;/li>
&lt;li>软件设计：根据需求分析的结果对软件架构进行设计。&lt;/li>
&lt;li>编码：编写程序运行的源代码。&lt;/li>
&lt;li>测试 : 确定测试用例，编写测试报告。&lt;/li>
&lt;li>交付：将做好的软件交付给客户。&lt;/li>
&lt;li>维护：对软件进行维护比如解决 bug，完善功能。&lt;/li>
&lt;/ul>
&lt;p>软件开发过程只是比较笼统的层面上，一定义了一个软件开发可能涉及到的一些流程。&lt;/p>
&lt;p>软件开发模型更具体地定义了软件开发过程，对开发过程提供了强有力的理论支持。&lt;/p>
&lt;h2 id="软件开发模型">
 软件开发模型
 &lt;a class="anchor" href="#%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;p>软件开发模型有很多种，比如瀑布模型（Waterfall Model）、快速原型模型（Rapid Prototype Model）、V 模型（V-model）、W 模型（W-model）、敏捷开发模型。其中最具有代表性的还是 &lt;strong>瀑布模型&lt;/strong> 和 &lt;strong>敏捷开发&lt;/strong> 。&lt;/p>
&lt;p>&lt;strong>瀑布模型&lt;/strong> 定义了一套完成的软件开发周期，完整地展示了一个软件的的生命周期。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/schedule-task/up-264f2750a3d30366e36c375ec3a30ec2775.png" alt="" />&lt;/p>
&lt;p>&lt;strong>敏捷开发模型&lt;/strong> 是目前使用的最多的一种软件开发模型。&lt;a href="https://wiki.mbalib.com/wiki/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91">MBA 智库百科对敏捷开发的描述&lt;/a>是这样的:&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>敏捷开发&lt;/strong> 是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。&lt;/p>
&lt;/blockquote>
&lt;p>像现在比较常见的一些概念比如 &lt;strong>持续集成&lt;/strong>、&lt;strong>重构&lt;/strong>、&lt;strong>小版本发布&lt;/strong>、&lt;strong>低文档&lt;/strong>、&lt;strong>站会&lt;/strong>、&lt;strong>结对编程&lt;/strong>、&lt;strong>测试驱动开发&lt;/strong> 都是敏捷开发的核心。&lt;/p>
&lt;h2 id="软件开发的基本策略">
 软件开发的基本策略
 &lt;a class="anchor" href="#%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%ad%96%e7%95%a5">#&lt;/a>
&lt;/h2>
&lt;h3 id="软件复用">
 软件复用
 &lt;a class="anchor" href="#%e8%bd%af%e4%bb%b6%e5%a4%8d%e7%94%a8">#&lt;/a>
&lt;/h3>
&lt;p>我们在构建一个新的软件的时候，不需要从零开始，通过复用已有的一些轮子（框架、第三方库等）、设计模式、设计原则等等现成的物料，我们可以更快地构建出一个满足要求的软件。&lt;/p></description></item><item><title>设计模式常见面试题总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/design-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/design-pattern/</guid><description>&lt;p>&lt;strong>设计模式&lt;/strong> 相关的面试题已经整理到了 PDF 手册中，你可以在我的公众号“&lt;strong>JavaGuide&lt;/strong>”后台回复“&lt;strong>PDF&lt;/strong>” 获取。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号" />&lt;/p>
&lt;p>&lt;strong>《设计模式》PDF 电子书内容概览&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/design-pattern-pdf.png" alt="《设计模式》PDF文档概览" />&lt;/p></description></item><item><title>深度分页介绍及优化建议</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/deep-pagination-optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/deep-pagination-optimization/</guid><description>&lt;h2 id="深度分页介绍">
 深度分页介绍
 &lt;a class="anchor" href="#%e6%b7%b1%e5%ba%a6%e5%88%86%e9%a1%b5%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>查询偏移量过大的场景我们称为深度分页，这会导致查询性能较低，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">#&lt;/span> MySQL &lt;span style="color:#960050;background-color:#1e0010">在无法利用索引的情况下跳过&lt;/span>&lt;span style="color:#ae81ff">1000000&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">条记录后，再获取&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">条记录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> t_order &lt;span style="color:#66d9ef">ORDER&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> id &lt;span style="color:#66d9ef">LIMIT&lt;/span> &lt;span style="color:#ae81ff">1000000&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="深度分页问题的原因">
 深度分页问题的原因
 &lt;a class="anchor" href="#%e6%b7%b1%e5%ba%a6%e5%88%86%e9%a1%b5%e9%97%ae%e9%a2%98%e7%9a%84%e5%8e%9f%e5%9b%a0">#&lt;/a>
&lt;/h2>
&lt;p>当查询偏移量过大时，MySQL 的查询优化器可能会选择全表扫描而不是利用索引来优化查询。这是因为扫描索引和跳过大量记录可能比直接全表扫描更耗费资源。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/mysql/deep-pagination-phenomenon.png" alt="深度分页问题" />&lt;/p>
&lt;p>不同机器上这个查询偏移量过大的临界点可能不同，取决于多个因素，包括硬件配置（如 CPU 性能、磁盘速度）、表的大小、索引的类型和统计信息等。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/mysql/deep-pagination-phenomenon-critical-point.png" alt="转全表扫描的临界点" />&lt;/p>
&lt;p>MySQL 的查询优化器采用基于成本的策略来选择最优的查询执行计划。它会根据 CPU 和 I/O 的成本来决定是否使用索引扫描或全表扫描。如果优化器认为全表扫描的成本更低，它就会放弃使用索引。不过，即使偏移量很大，如果查询中使用了覆盖索引（covering index），MySQL 仍然可能会使用索引，避免回表操作。&lt;/p>
&lt;h2 id="深度分页优化建议">
 深度分页优化建议
 &lt;a class="anchor" href="#%e6%b7%b1%e5%ba%a6%e5%88%86%e9%a1%b5%e4%bc%98%e5%8c%96%e5%bb%ba%e8%ae%ae">#&lt;/a>
&lt;/h2>
&lt;p>这里以 MySQL 数据库为例介绍一下如何优化深度分页。&lt;/p>
&lt;h3 id="范围查询">
 范围查询
 &lt;a class="anchor" href="#%e8%8c%83%e5%9b%b4%e6%9f%a5%e8%af%a2">#&lt;/a>
&lt;/h3>
&lt;p>当可以保证 ID 的连续性时，根据 ID 范围进行分页是比较好的解决方案：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">查询指定&lt;/span> ID &lt;span style="color:#960050;background-color:#1e0010">范围的数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> t_order &lt;span style="color:#66d9ef">WHERE&lt;/span> id &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">100000&lt;/span> &lt;span style="color:#66d9ef">AND&lt;/span> id &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">100010&lt;/span> &lt;span style="color:#66d9ef">ORDER&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">也可以通过记录上次查询结果的最后一条记录的&lt;/span>ID进行下一页的查询&lt;span style="color:#960050;background-color:#1e0010">：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> t_order &lt;span style="color:#66d9ef">WHERE&lt;/span> id &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">100000&lt;/span> &lt;span style="color:#66d9ef">LIMIT&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种基于 ID 范围的深度分页优化方式存在很大限制：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>ID 连续性要求高&lt;/strong>: 实际项目中，数据库自增 ID 往往因为各种原因（例如删除数据、事务回滚等）导致 ID 不连续，难以保证连续性。&lt;/li>
&lt;li>&lt;strong>排序问题&lt;/strong>: 如果查询需要按照其他字段（例如创建时间、更新时间等）排序，而不是按照 ID 排序，那么这种方法就不再适用。&lt;/li>
&lt;li>&lt;strong>并发场景&lt;/strong>: 在高并发场景下，单纯依赖记录上次查询的最后一条记录的 ID 进行分页，容易出现数据重复或遗漏的问题。&lt;/li>
&lt;/ol>
&lt;h3 id="子查询">
 子查询
 &lt;a class="anchor" href="#%e5%ad%90%e6%9f%a5%e8%af%a2">#&lt;/a>
&lt;/h3>
&lt;p>我们先查询出 limit 第一个参数对应的主键值，再根据这个主键值再去过滤并 limit，这样效率会更快一些。&lt;/p></description></item><item><title>十大经典排序算法总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/10-classical-sorting-algorithms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/algorithms/10-classical-sorting-algorithms/</guid><description>&lt;blockquote>
&lt;p>本文转自：&lt;a href="http://www.guoyaohua.com/sorting.html">http://www.guoyaohua.com/sorting.html&lt;/a>，JavaGuide 对其做了补充完善。&lt;/p>
&lt;/blockquote>
&lt;h2 id="引言">
 引言
 &lt;a class="anchor" href="#%e5%bc%95%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。&lt;/p>
&lt;h2 id="简介">
 简介
 &lt;a class="anchor" href="#%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="排序算法总结">
 排序算法总结
 &lt;a class="anchor" href="#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h3>
&lt;p>常见的内部排序算法有：&lt;strong>插入排序&lt;/strong>、&lt;strong>希尔排序&lt;/strong>、&lt;strong>选择排序&lt;/strong>、&lt;strong>冒泡排序&lt;/strong>、&lt;strong>归并排序&lt;/strong>、&lt;strong>快速排序&lt;/strong>、&lt;strong>堆排序&lt;/strong>、&lt;strong>基数排序&lt;/strong>等，本文只讲解内部排序算法。用一张表格概括：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>排序算法&lt;/th>
 &lt;th>时间复杂度（平均）&lt;/th>
 &lt;th>时间复杂度（最差）&lt;/th>
 &lt;th>时间复杂度（最好）&lt;/th>
 &lt;th>空间复杂度&lt;/th>
 &lt;th>排序方式&lt;/th>
 &lt;th>稳定性&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>冒泡排序&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n)&lt;/td>
 &lt;td>O(1)&lt;/td>
 &lt;td>内部排序&lt;/td>
 &lt;td>稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>选择排序&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(1)&lt;/td>
 &lt;td>内部排序&lt;/td>
 &lt;td>不稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>插入排序&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n)&lt;/td>
 &lt;td>O(1)&lt;/td>
 &lt;td>内部排序&lt;/td>
 &lt;td>稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>希尔排序&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(1)&lt;/td>
 &lt;td>内部排序&lt;/td>
 &lt;td>不稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>归并排序&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(n)&lt;/td>
 &lt;td>外部排序&lt;/td>
 &lt;td>稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>快速排序&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(logn)&lt;/td>
 &lt;td>内部排序&lt;/td>
 &lt;td>不稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>堆排序&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(nlogn)&lt;/td>
 &lt;td>O(1)&lt;/td>
 &lt;td>内部排序&lt;/td>
 &lt;td>不稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>计数排序&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>O(k)&lt;/td>
 &lt;td>外部排序&lt;/td>
 &lt;td>稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>桶排序&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>O(n^2)&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>外部排序&lt;/td>
 &lt;td>稳定&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>基数排序&lt;/td>
 &lt;td>O(n×k)&lt;/td>
 &lt;td>O(n×k)&lt;/td>
 &lt;td>O(n×k)&lt;/td>
 &lt;td>O(n+k)&lt;/td>
 &lt;td>外部排序&lt;/td>
 &lt;td>稳定&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>术语解释&lt;/strong>：&lt;/p></description></item><item><title>十年大厂成长之路</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/ten-years-of-dachang-growth-road/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：这篇文章的作者有着丰富的工作经验，曾在大厂工作了 12 年。结合自己走过的弯路和接触过的优秀技术人，他总结出了一些对于个人成长具有普遍指导意义的经验和特质。&lt;/p>
&lt;p>&lt;strong>原文地址：&lt;/strong> &lt;a href="https://mp.weixin.qq.com/s/vIIRxznpRr5yd6IVyNUW2w">https://mp.weixin.qq.com/s/vIIRxznpRr5yd6IVyNUW2w&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>最近这段时间，有好几个年轻的同学和我聊到自己的迷茫。其中有关于技术成长的、有关于晋升的、有关于择业的。我很高兴他们愿意听我这个“过来人”分享自己的经验。&lt;/p>
&lt;p>我自己毕业后进入大厂，在大厂工作 12 年，我说的内容都来自于我自己或者身边人的真实情况。尤其，我会把 &lt;strong>【我自己走过的弯路】&lt;/strong> 和 &lt;strong>【我看到过的优秀技术人的特质】&lt;/strong> 相结合来给出建议。&lt;/p>
&lt;p>这些内容我觉得具有普遍的指导意义，所以决定做个整理分享出来。我相信，无论你在大厂还是小厂，如果你相信这些建议，或早或晚他们会帮助到你。&lt;/p>
&lt;p>我自己工作 12 年，走了些弯路，所以我就来讲讲，“在一个技术人 10 年的发展过程中，应该注意些什么”。我们把内容分为两块：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>十年技术路怎么走&lt;/strong>&lt;/li>
&lt;li>&lt;strong>一些重要选择&lt;/strong>&lt;/li>
&lt;/ol>
&lt;h2 id="01-十年技术路怎么走">
 01 十年技术路怎么走
 &lt;a class="anchor" href="#01-%e5%8d%81%e5%b9%b4%e6%8a%80%e6%9c%af%e8%b7%af%e6%80%8e%e4%b9%88%e8%b5%b0">#&lt;/a>
&lt;/h2>
&lt;h3 id="1-2-年-从菜鸟到职业">
 【1-2 年】=&amp;gt; 从“菜鸟”到“职业”
 &lt;a class="anchor" href="#1-2-%e5%b9%b4-%e4%bb%8e%e8%8f%9c%e9%b8%9f%e5%88%b0%e8%81%8c%e4%b8%9a">#&lt;/a>
&lt;/h3>
&lt;p>应届生刚进入到工作时，会有各种不适应。比如写好的代码会被反复打回、和团队老司机讨论技术问题会有一堆问号、不敢提问和质疑、碰到问题一个人使劲死磕等等。&lt;/p>
&lt;p>&lt;strong>简单来说就是，即使日以继夜地埋头苦干，最后也无法顺利的开展工作。&lt;/strong>&lt;/p>
&lt;p>这个阶段最重要的几个点：&lt;/p>
&lt;p>&lt;strong>【多看多模仿】&lt;/strong>：比如写代码的时候，不要就像在学校完成书本作业那样只关心功能是否正确，还要关心模块的设计、异常的处理、代码的可读性等等。在你还没有了解这些内容的精髓之前，也要照猫画虎地模仿起来，慢慢地你就会越来越明白真实世界的代码是怎么写的，以及为什么要这么写。&lt;/p>
&lt;p>做技术方案的时候也是同理，技术文档的要求你也许并不理解，但你可以先参考已有文档写起来。&lt;/p>
&lt;p>&lt;strong>【脸皮厚一点】&lt;/strong>：不懂就问，你是新人大家都是理解的。你做的各种方案也可以多找老司机们 review，不要怕被看笑话。&lt;/p>
&lt;p>&lt;strong>【关注工作方式】&lt;/strong>：比如发现需求在计划时间完不成就要尽快报风险、及时做好工作内容的汇报（例如周报）、开会后确定会议结论和 todo 项、承诺时间就要尽力完成、严格遵循公司的要求（例如发布规范、权限规范等）&lt;/p>
&lt;p>一般来说，工作 2 年后，你就应该成为一个职业人。老板可以相信任何工作交到你的手里，不会出现“意外”（例如一个重要需求明天要上线了，突然被告知上不了）。&lt;/p>
&lt;h3 id="3-4-年-从职业到尖兵">
 【3-4 年】=&amp;gt; 从“职业”到“尖兵”
 &lt;a class="anchor" href="#3-4-%e5%b9%b4-%e4%bb%8e%e8%81%8c%e4%b8%9a%e5%88%b0%e5%b0%96%e5%85%b5">#&lt;/a>
&lt;/h3>
&lt;p>工作两年后，对业务以及现有系统的了解已经到达了一定的程度，技术同学会开始承担更有难度的技术挑战。&lt;/p>
&lt;p>例如需要将性能提升到某一个水位、例如需要对某一个重要模块进行重构、例如有个重要的项目需要协同 N 个团队一起完成。&lt;/p>
&lt;p>可见，上述的这些技术问题，难度都已经远远超过一个普通的需求。解决这些问题需要有一定的技术能力，同时也需要具备更高的协同能力。&lt;/p>
&lt;p>这个阶段最重要的几个点：&lt;/p>
&lt;p>&lt;strong>【技术能力提升】&lt;/strong>：无论是公司内还是公司外的技术内容，都要多做主动的学习。基本上这个阶段的技术难题都集中在【性能】【稳定性】和【扩展性】上，而这些内容在业界都是有成型的方法论的。&lt;/p>
&lt;p>&lt;strong>【主人翁精神】&lt;/strong>：技术难题除了技术方案设计及落地外，背后还有一系列的其他工作。例如上线后对效果的观测、重点项目对于上下游改造和风险的了解程度、对于整个技改后续的计划（二期、三期的优化思路）等。&lt;/p>
&lt;p>在工作四年后，基本上你成为了团队的一、二号技术位。很多技术难题即使不是你来落地，也是由你来决定方案。你会做调研、会做方案对比、会考虑整个技改的生命周期。&lt;/p>
&lt;h3 id="5-7-年-从尖兵到专家">
 【5-7 年】=&amp;gt; 从“尖兵”到“专家”
 &lt;a class="anchor" href="#5-7-%e5%b9%b4-%e4%bb%8e%e5%b0%96%e5%85%b5%e5%88%b0%e4%b8%93%e5%ae%b6">#&lt;/a>
&lt;/h3>
&lt;p>技术尖兵重点在于解决某一个具体的技术难题或者重点项目。而下一步的发展方向，就是能够承担起来一整个“业务板块”，也就是“领域技术专家”。&lt;/p>
&lt;p>想要承担一整个“业务板块”需要 &lt;strong>【对业务领域有深刻的理解，同时基于这些理解来规划技术的发展方向】&lt;/strong> 。&lt;/p>
&lt;p>拿支付做个例子。简单的支付功能其实很容易完成，只要处理好和双联（网联和银联）的接口调用（成功、失败、异常）即可。但在很多背景下，支付没有那么简单。&lt;/p>
&lt;p>例如，支付是一个用户敏感型操作，非常强调用户体验，如何能兼顾体验和接口的不稳定？支付接口还需要承担费用，同步和异步的接口费用不同，如何能够降本？支付接口往往还有限额等。这一系列问题的背后涉及到很多技术的设计，包括异步化、补偿设计、资金流设计、最终一致性设计等等。&lt;/p>
&lt;p>这个阶段最重要的几个点：&lt;/p>
&lt;p>&lt;strong>【深入理解行业及趋势】&lt;/strong>：密切关注行业的各种变化（新鲜的玩法、政策的变动、竞对的策略、科技等外在因素的影响等等），和业务同学加强沟通。&lt;/p>
&lt;p>&lt;strong>【深入了解行业解决方案】&lt;/strong>：充分对标已有的国内外技术方案，做深入学习和尝试，评估建设及运维成本，结合业务趋势制定计划。&lt;/p>
&lt;h3 id="8-10-年-从专家到tl">
 【8-10 年】=&amp;gt; 从“专家”到“TL”
 &lt;a class="anchor" href="#8-10-%e5%b9%b4-%e4%bb%8e%e4%b8%93%e5%ae%b6%e5%88%b0tl">#&lt;/a>
&lt;/h3>
&lt;p>其实很多时候，如果能做到专家，基本也是一个 TL 的角色了，但这并不代表正在执行 TL 的职责。&lt;/p></description></item><item><title>树</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/data-structure/tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/data-structure/tree/</guid><description>&lt;p>树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。&lt;/p>
&lt;p>一棵树具有以下特点：&lt;/p>
&lt;ol>
&lt;li>一棵树中的任意两个结点有且仅有唯一的一条路径连通。&lt;/li>
&lt;li>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。&lt;/li>
&lt;li>一棵树不包含回路。&lt;/li>
&lt;/ol>
&lt;p>下图就是一颗树，并且是一颗二叉树。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/%E4%BA%8C%E5%8F%89%E6%A0%91-2.png" alt="二叉树" />&lt;/p>
&lt;p>如上图所示，通过上面这张图说明一下树中的常用概念：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>节点&lt;/strong>：树中的每个元素都可以统称为节点。&lt;/li>
&lt;li>&lt;strong>根节点&lt;/strong>：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。&lt;/li>
&lt;li>&lt;strong>父节点&lt;/strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。&lt;/li>
&lt;li>&lt;strong>子节点&lt;/strong>：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。&lt;/li>
&lt;li>&lt;strong>兄弟节点&lt;/strong>：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。&lt;/li>
&lt;li>&lt;strong>叶子节点&lt;/strong>：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。&lt;/li>
&lt;li>&lt;strong>节点的高度&lt;/strong>：该节点到叶子节点的最长路径所包含的边数。&lt;/li>
&lt;li>&lt;strong>节点的深度&lt;/strong>：根节点到该节点的路径所包含的边数&lt;/li>
&lt;li>&lt;strong>节点的层数&lt;/strong>：节点的深度+1。&lt;/li>
&lt;li>&lt;strong>树的高度&lt;/strong>：根节点的高度。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>关于树的深度和高度的定义可以看 stackoverflow 上的这个问题：&lt;a href="https://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height">What is the difference between tree depth and height?&lt;/a> 。&lt;/p>
&lt;/blockquote>
&lt;h2 id="二叉树的分类">
 二叉树的分类
 &lt;a class="anchor" href="#%e4%ba%8c%e5%8f%89%e6%a0%91%e7%9a%84%e5%88%86%e7%b1%bb">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>二叉树&lt;/strong>（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。&lt;/p>
&lt;p>&lt;strong>二叉树&lt;/strong> 的分支通常被称作“&lt;strong>左子树&lt;/strong>”或“&lt;strong>右子树&lt;/strong>”。并且，&lt;strong>二叉树&lt;/strong> 的分支具有左右次序，不能随意颠倒。&lt;/p>
&lt;p>&lt;strong>二叉树&lt;/strong> 的第 i 层至多拥有 &lt;code>2^(i-1)&lt;/code> 个节点，深度为 k 的二叉树至多总共有 &lt;code>2^(k+1)-1&lt;/code> 个节点（满二叉树的情况），至少有 2^(k) 个节点（关于节点的深度的定义国内争议比较多，我个人比较认可维基百科对&lt;a href="https://zh.wikipedia.org/wiki/%E6%A0%91_%28%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%29#/%E6%9C%AF%E8%AF%AD">节点深度的定义&lt;/a>）。&lt;/p></description></item><item><title>数据库基础知识总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/basis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/basis/</guid><description>&lt;p>数据库知识基础，这部分内容一定要理解记忆。虽然这部分内容只是理论知识，但是非常重要，这是后面学习 MySQL 数据库的基础。PS: 这部分内容由于涉及太多概念性内容，所以参考了维基百科和百度百科相应的介绍。&lt;/p>
&lt;h2 id="什么是数据库-数据库管理系统-数据库系统-数据库管理员">
 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%95%b0%e6%8d%ae%e5%ba%93-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%ae%a1%e7%90%86%e7%b3%bb%e7%bb%9f-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%ae%a1%e7%90%86%e5%91%98">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>数据库&lt;/strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。&lt;/li>
&lt;li>&lt;strong>数据库管理系统&lt;/strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。&lt;/li>
&lt;li>&lt;strong>数据库系统&lt;/strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。&lt;/li>
&lt;li>&lt;strong>数据库管理员&lt;/strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。&lt;/li>
&lt;/ul>
&lt;h2 id="什么是元组-码-候选码-主码-外码-主属性-非主属性">
 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%85%83%e7%bb%84-%e7%a0%81-%e5%80%99%e9%80%89%e7%a0%81-%e4%b8%bb%e7%a0%81-%e5%a4%96%e7%a0%81-%e4%b8%bb%e5%b1%9e%e6%80%a7-%e9%9d%9e%e4%b8%bb%e5%b1%9e%e6%80%a7">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>元组&lt;/strong>：元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。&lt;/li>
&lt;li>&lt;strong>码&lt;/strong>：码就是能唯一标识实体的属性，对应表中的列。&lt;/li>
&lt;li>&lt;strong>候选码&lt;/strong>：若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。&lt;/li>
&lt;li>&lt;strong>主码&lt;/strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。&lt;/li>
&lt;li>&lt;strong>外码&lt;/strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。&lt;/li>
&lt;li>&lt;strong>主属性&lt;/strong>：候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。&lt;/li>
&lt;li>&lt;strong>非主属性：&lt;/strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。&lt;/li>
&lt;/ul>
&lt;h2 id="什么是-er-图">
 什么是 ER 图？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af-er-%e5%9b%be">#&lt;/a>
&lt;/h2>
&lt;p>我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问到的。&lt;/p>
&lt;p>&lt;strong>ER 图&lt;/strong> 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。&lt;/p></description></item><item><title>数据冷热分离详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/data-cold-hot-separation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/data-cold-hot-separation/</guid><description>&lt;h2 id="什么是数据冷热分离">
 什么是数据冷热分离？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%95%b0%e6%8d%ae%e5%86%b7%e7%83%ad%e5%88%86%e7%a6%bb">#&lt;/a>
&lt;/h2>
&lt;p>数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。&lt;/p>
&lt;h3 id="冷数据和热数据">
 冷数据和热数据
 &lt;a class="anchor" href="#%e5%86%b7%e6%95%b0%e6%8d%ae%e5%92%8c%e7%83%ad%e6%95%b0%e6%8d%ae">#&lt;/a>
&lt;/h3>
&lt;p>热数据是指经常被访问和修改且需要快速访问的数据，冷数据是指不经常访问，对当前项目价值较低，但需要长期保存的数据。&lt;/p>
&lt;p>冷热数据到底如何区分呢？有两个常见的区分方法：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>时间维度区分&lt;/strong>：按照数据的创建时间、更新时间、过期时间等，将一定时间段内的数据视为热数据，超过该时间段的数据视为冷数据。例如，订单系统可以将 1 年前的订单数据作为冷数据，1 年内的订单数据作为热数据。这种方法适用于数据的访问频率和时间有较强的相关性的场景。&lt;/li>
&lt;li>&lt;strong>访问频率区分&lt;/strong>：将高频访问的数据视为热数据，低频访问的数据视为冷数据。例如，内容系统可以将浏览量非常低的文章作为冷数据，浏览量较高的文章作为热数据。这种方法需要记录数据的访问频率，成本较高，适合访问频率和数据本身有较强的相关性的场景。&lt;/li>
&lt;/ol>
&lt;p>几年前的数据并不一定都是冷数据，例如一些优质文章发表几年后依然有很多人访问，大部分普通用户新发表的文章却基本没什么人访问。&lt;/p>
&lt;p>这两种区分冷热数据的方法各有优劣，实际项目中，可以将两者结合使用。&lt;/p>
&lt;h3 id="冷热分离的思想">
 冷热分离的思想
 &lt;a class="anchor" href="#%e5%86%b7%e7%83%ad%e5%88%86%e7%a6%bb%e7%9a%84%e6%80%9d%e6%83%b3">#&lt;/a>
&lt;/h3>
&lt;p>冷热分离的思想非常简单，就是对数据进行分类，然后分开存储。冷热分离的思想可以应用到很多领域和场景中，而不仅仅是数据存储，例如：&lt;/p>
&lt;ul>
&lt;li>邮件系统中，可以将近期的比较重要的邮件放在收件箱，将比较久远的不太重要的邮件存入归档。&lt;/li>
&lt;li>日常生活中，可以将常用的物品放在显眼的位置，不常用的物品放入储藏室或者阁楼。&lt;/li>
&lt;li>图书馆中，可以将最受欢迎和最常借阅的图书单独放在一个显眼的区域，将较少借阅的书籍放在不起眼的位置。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;h3 id="数据冷热分离的优缺点">
 数据冷热分离的优缺点
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%86%b7%e7%83%ad%e5%88%86%e7%a6%bb%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>优点：热数据的查询性能得到优化（用户的绝大部分操作体验会更好）、节约成本（可以冷热数据的不同存储需求，选择对应的数据库类型和硬件配置，比如将热数据放在 SSD 上，将冷数据放在 HDD 上）&lt;/li>
&lt;li>缺点：系统复杂性和风险增加（需要分离冷热数据，数据错误的风险增加）、统计效率低（统计的时候可能需要用到冷库的数据）。&lt;/li>
&lt;/ul>
&lt;h2 id="冷数据如何迁移">
 冷数据如何迁移？
 &lt;a class="anchor" href="#%e5%86%b7%e6%95%b0%e6%8d%ae%e5%a6%82%e4%bd%95%e8%bf%81%e7%a7%bb">#&lt;/a>
&lt;/h2>
&lt;p>冷数据迁移方案：&lt;/p>
&lt;ol>
&lt;li>业务层代码实现：当有对数据进行写操作时，触发冷热分离的逻辑，判断数据是冷数据还是热数据，冷数据就入冷库，热数据就入热库。这种方案会影响性能且冷热数据的判断逻辑不太好确定，还需要修改业务层代码，因此一般不会使用。&lt;/li>
&lt;li>任务调度：可以利用 xxl-job 或者其他分布式任务调度平台定时去扫描数据库，找出满足冷数据条件的数据，然后批量地将其复制到冷库中，并从热库中删除。这种方法修改的代码非常少，非常适合按照时间区分冷热数据的场景。&lt;/li>
&lt;li>监听数据库的变更日志 binlog ：将满足冷数据条件的数据从 binlog 中提取出来，然后复制到冷库中，并从热库中删除。这种方法可以不用修改代码，但不适合按照时间维度区分冷热数据的场景。&lt;/li>
&lt;/ol>
&lt;p>如果你的公司有 DBA 的话，也可以让 DBA 进行冷数据的人工迁移，一次迁移完成冷数据到冷库。然后，再搭配上面介绍的方案实现后续冷数据的迁移工作。&lt;/p>
&lt;h2 id="冷数据如何存储">
 冷数据如何存储？
 &lt;a class="anchor" href="#%e5%86%b7%e6%95%b0%e6%8d%ae%e5%a6%82%e4%bd%95%e5%ad%98%e5%82%a8">#&lt;/a>
&lt;/h2>
&lt;p>冷数据的存储要求主要是容量大，成本低，可靠性高，访问速度可以适当牺牲。&lt;/p>
&lt;p>冷数据存储方案：&lt;/p>
&lt;ul>
&lt;li>中小厂：直接使用 MySQL/PostgreSQL 即可（不改变数据库选型和项目当前使用的数据库保持一致），比如新增一张表来存储某个业务的冷数据或者使用单独的冷库来存放冷数据（涉及跨库查询，增加了系统复杂性和维护难度）&lt;/li>
&lt;li>大厂：Hbase（常用）、RocksDB、Doris、Cassandra&lt;/li>
&lt;/ul>
&lt;p>如果公司成本预算足的话，也可以直接上 TiDB 这种分布式关系型数据库，直接一步到位。TiDB 6.0 正式支持数据冷热存储分离，可以降低 SSD 使用成本。使用 TiDB 6.0 的数据放置功能，可以在同一个集群实现海量数据的冷热存储，将新的热数据存入 SSD，历史冷数据存入 HDD。&lt;/p></description></item><item><title>数据脱敏方案总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/data-desensitization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/security/data-desensitization/</guid><description>&lt;blockquote>
&lt;p>本文转载完善自&lt;a href="https://mp.weixin.qq.com/s/1qFWczesU50ndPPLtABHFg">Hutool：一行代码搞定数据脱敏 - 京东云开发者&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="什么是数据脱敏">
 什么是数据脱敏
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%95%b0%e6%8d%ae%e8%84%b1%e6%95%8f">#&lt;/a>
&lt;/h2>
&lt;h3 id="数据脱敏的定义">
 数据脱敏的定义
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e8%84%b1%e6%95%8f%e7%9a%84%e5%ae%9a%e4%b9%89">#&lt;/a>
&lt;/h3>
&lt;p>数据脱敏百度百科中是这样定义的：&lt;/p>
&lt;blockquote>
&lt;p>数据脱敏，指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。这样就可以在开发、测试和其它非生产环境以及外包环境中安全地使用脱敏后的真实数据集。在涉及客户安全数据或者一些商业性敏感数据的情况下，在不违反系统规则条件下，对真实数据进行改造并提供测试使用，如身份证号、手机号、卡号、客户号等个人信息都需要进行数据脱敏。是数据库安全技术之一。&lt;/p>
&lt;/blockquote>
&lt;p>总的来说，数据脱敏是指对某些敏感信息通过脱敏规则进行数据的变形，实现敏感隐私数据的可靠保护。&lt;/p>
&lt;p>在数据脱敏过程中，通常会采用不同的算法和技术，以根据不同的需求和场景对数据进行处理。例如，对于身份证号码，可以使用掩码算法（masking）将前几位数字保留，其他位用 “X” 或 &amp;ldquo;*&amp;rdquo; 代替；对于姓名，可以使用伪造（pseudonymization）算法，将真实姓名替换成随机生成的假名。&lt;/p>
&lt;h3 id="常用脱敏规则">
 常用脱敏规则
 &lt;a class="anchor" href="#%e5%b8%b8%e7%94%a8%e8%84%b1%e6%95%8f%e8%a7%84%e5%88%99">#&lt;/a>
&lt;/h3>
&lt;p>常用脱敏规则是为了保护敏感数据的安全性，在处理和存储敏感数据时对其进行变换或修改。&lt;/p>
&lt;p>下面是几种常见的脱敏规则：&lt;/p>
&lt;ul>
&lt;li>替换(常用)：将敏感数据中的特定字符或字符序列替换为其他字符。例如，将信用卡号中的中间几位数字替换为星号（*）或其他字符。&lt;/li>
&lt;li>删除：将敏感数据中的部分内容随机删除。比如，将电话号码的随机 3 位数字进行删除。&lt;/li>
&lt;li>重排：将原始数据中的某些字符或字段的顺序打乱。例如，将身份证号码的随机位交错互换。&lt;/li>
&lt;li>加噪：在数据中注入一些误差或者噪音，达到对数据脱敏的效果。例如，在敏感数据中添加一些随机生成的字符。&lt;/li>
&lt;li>加密（常用）：使用加密算法将敏感数据转换为密文。例如，将银行卡号用 MD5 或 SHA-256 等哈希函数进行散列。常见加密算法总结可以参考这篇文章：&lt;a href="https://javaguide.cn/system-design/security/encryption-algorithms.html">https://javaguide.cn/system-design/security/encryption-algorithms.html&lt;/a> 。&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;h2 id="常用脱敏工具">
 常用脱敏工具
 &lt;a class="anchor" href="#%e5%b8%b8%e7%94%a8%e8%84%b1%e6%95%8f%e5%b7%a5%e5%85%b7">#&lt;/a>
&lt;/h2>
&lt;h3 id="hutool">
 Hutool
 &lt;a class="anchor" href="#hutool">#&lt;/a>
&lt;/h3>
&lt;p>Hutool 一个 Java 基础工具类，对文件、流、加密解密、转码、正则、线程、XML 等 JDK 方法进行封装，组成各种 Util 工具类，同时提供以下组件：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: center">模块&lt;/th>
 &lt;th style="text-align: center">介绍&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: center">hutool-aop&lt;/td>
 &lt;td style="text-align: center">JDK 动态代理封装，提供非 IOC 下的切面支持&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-bloomFilter&lt;/td>
 &lt;td style="text-align: center">布隆过滤，提供一些 Hash 算法的布隆过滤&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-cache&lt;/td>
 &lt;td style="text-align: center">简单缓存实现&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-core&lt;/td>
 &lt;td style="text-align: center">核心，包括 Bean 操作、日期、各种 Util 等&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-cron&lt;/td>
 &lt;td style="text-align: center">定时任务模块，提供类 Crontab 表达式的定时任务&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-crypto&lt;/td>
 &lt;td style="text-align: center">加密解密模块，提供对称、非对称和摘要算法封装&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-db&lt;/td>
 &lt;td style="text-align: center">JDBC 封装后的数据操作，基于 ActiveRecord 思想&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-dfa&lt;/td>
 &lt;td style="text-align: center">基于 DFA 模型的多关键字查找&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-extra&lt;/td>
 &lt;td style="text-align: center">扩展模块，对第三方封装（模板引擎、邮件、Servlet、二维码、Emoji、FTP、分词等）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-http&lt;/td>
 &lt;td style="text-align: center">基于 HttpUrlConnection 的 Http 客户端封装&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-log&lt;/td>
 &lt;td style="text-align: center">自动识别日志实现的日志门面&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-script&lt;/td>
 &lt;td style="text-align: center">脚本执行封装，例如 Javascript&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-setting&lt;/td>
 &lt;td style="text-align: center">功能更强大的 Setting 配置文件和 Properties 封装&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-system&lt;/td>
 &lt;td style="text-align: center">系统参数调用封装（JVM 信息等）&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-json&lt;/td>
 &lt;td style="text-align: center">JSON 实现&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-captcha&lt;/td>
 &lt;td style="text-align: center">图片验证码实现&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-poi&lt;/td>
 &lt;td style="text-align: center">针对 POI 中 Excel 和 Word 的封装&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-socket&lt;/td>
 &lt;td style="text-align: center">基于 Java 的 NIO 和 AIO 的 Socket 封装&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: center">hutool-jwt&lt;/td>
 &lt;td style="text-align: center">JSON Web Token (JWT) 封装实现&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>可以根据需求对每个模块单独引入，也可以通过引入&lt;code>hutool-all&lt;/code>方式引入所有模块，本文所使用的数据脱敏工具就是在 &lt;code>hutool.core&lt;/code> 模块。&lt;/p></description></item><item><title>图</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/data-structure/graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/data-structure/graph/</guid><description>&lt;p>图是一种较为复杂的非线性结构。 &lt;strong>为啥说其较为复杂呢？&lt;/strong>&lt;/p>
&lt;p>根据前面的内容，我们知道：&lt;/p>
&lt;ul>
&lt;li>线性数据结构的元素满足唯一的线性关系，每个元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继。&lt;/li>
&lt;li>树形数据结构的元素之间有着明显的层次关系。&lt;/li>
&lt;/ul>
&lt;p>但是，图形结构的元素之间的关系是任意的。&lt;/p>
&lt;p>&lt;strong>何为图呢？&lt;/strong> 简单来说，图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：&lt;strong>G(V,E)&lt;/strong>，其中，G 表示一个图，V 表示顶点的集合，E 表示边的集合。&lt;/p>
&lt;p>下图所展示的就是图这种数据结构，并且还是一张有向图。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/directed-graph.png" alt="有向图" />&lt;/p>
&lt;p>图在我们日常生活中的例子很多！比如我们在社交软件上好友关系就可以用图来表示。&lt;/p>
&lt;h2 id="图的基本概念">
 图的基本概念
 &lt;a class="anchor" href="#%e5%9b%be%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5">#&lt;/a>
&lt;/h2>
&lt;h3 id="顶点">
 顶点
 &lt;a class="anchor" href="#%e9%a1%b6%e7%82%b9">#&lt;/a>
&lt;/h3>
&lt;p>图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）&lt;/p>
&lt;p>对应到好友关系图，每一个用户就代表一个顶点。&lt;/p>
&lt;h3 id="边">
 边
 &lt;a class="anchor" href="#%e8%be%b9">#&lt;/a>
&lt;/h3>
&lt;p>顶点之间的关系用边表示。&lt;/p>
&lt;p>对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。&lt;/p>
&lt;h3 id="度">
 度
 &lt;a class="anchor" href="#%e5%ba%a6">#&lt;/a>
&lt;/h3>
&lt;p>度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。&lt;/p>
&lt;p>对应到好友关系图，度就代表了某个人的好友数量。&lt;/p>
&lt;h3 id="无向图和有向图">
 无向图和有向图
 &lt;a class="anchor" href="#%e6%97%a0%e5%90%91%e5%9b%be%e5%92%8c%e6%9c%89%e5%90%91%e5%9b%be">#&lt;/a>
&lt;/h3>
&lt;p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A 是 B 的同学，那么 B 也肯定是 A 的同学，那么在表示 A 和 B 的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。&lt;/p>
&lt;p>有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A 是 B 的爸爸，但 B 肯定不是 A 的爸爸，A 关注 B，B 不一定关注 A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。&lt;/p>
&lt;h3 id="无权图和带权图">
 无权图和带权图
 &lt;a class="anchor" href="#%e6%97%a0%e6%9d%83%e5%9b%be%e5%92%8c%e5%b8%a6%e6%9d%83%e5%9b%be">#&lt;/a>
&lt;/h3>
&lt;p>对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。&lt;/p>
&lt;p>对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。&lt;/p>
&lt;p>下图就是一个带权有向图。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/weighted-directed-graph.png" alt="带权有向图" />&lt;/p>
&lt;h2 id="图的存储">
 图的存储
 &lt;a class="anchor" href="#%e5%9b%be%e7%9a%84%e5%ad%98%e5%82%a8">#&lt;/a>
&lt;/h2>
&lt;h3 id="邻接矩阵存储">
 邻接矩阵存储
 &lt;a class="anchor" href="#%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5%e5%ad%98%e5%82%a8">#&lt;/a>
&lt;/h3>
&lt;p>邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。&lt;/p></description></item><item><title>网络攻击常见手段总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/network-attack-means/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/network-attack-means/</guid><description>&lt;blockquote>
&lt;p>本文整理完善自&lt;a href="https://mp.weixin.qq.com/s/AZwWrOlLxRSSi-ywBgZ0fA">TCP/IP 常见攻击手段 - 暖蓝笔记 - 2021&lt;/a>这篇文章。&lt;/p>
&lt;/blockquote>
&lt;p>这篇文章的内容主要是介绍 TCP/IP 常见攻击手段，尤其是 DDoS 攻击，也会补充一些其他的常见网络攻击手段。&lt;/p>
&lt;h2 id="ip-欺骗">
 IP 欺骗
 &lt;a class="anchor" href="#ip-%e6%ac%ba%e9%aa%97">#&lt;/a>
&lt;/h2>
&lt;h3 id="ip-是什么">
 IP 是什么?
 &lt;a class="anchor" href="#ip-%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>在网络中，所有的设备都会分配一个地址。这个地址就仿佛小蓝的家地址「&lt;strong>多少号多少室&lt;/strong>」，这个号就是分配给整个子网的，「&lt;strong>室&lt;/strong>」对应的号码即分配给子网中计算机的，这就是网络中的地址。「号」对应的号码为网络号，「&lt;strong>室&lt;/strong>」对应的号码为主机号，这个地址的整体就是 &lt;strong>IP 地址&lt;/strong>。&lt;/p>
&lt;h3 id="通过-ip-地址我们能知道什么">
 通过 IP 地址我们能知道什么？
 &lt;a class="anchor" href="#%e9%80%9a%e8%bf%87-ip-%e5%9c%b0%e5%9d%80%e6%88%91%e4%bb%ac%e8%83%bd%e7%9f%a5%e9%81%93%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>通过 IP 地址，我们就可以知道判断访问对象服务器的位置，从而将消息发送到服务器。一般发送者发出的消息首先经过子网的集线器，转发到最近的路由器，然后根据路由位置访问下一个路由器的位置，直到终点&lt;/p>
&lt;p>&lt;strong>IP 头部格式&lt;/strong> :&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/843fd07074874ee0b695eca659411b42~tplv-k3u1fbpfcp-zoom-1.png" alt="" />&lt;/p>
&lt;h3 id="ip-欺骗技术是什么">
 IP 欺骗技术是什么？
 &lt;a class="anchor" href="#ip-%e6%ac%ba%e9%aa%97%e6%8a%80%e6%9c%af%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h3>
&lt;p>骗呗，拐骗，诱骗！&lt;/p>
&lt;p>IP 欺骗技术就是&lt;strong>伪造&lt;/strong>某台主机的 IP 地址的技术。通过 IP 地址的伪装使得某台主机能够&lt;strong>伪装&lt;/strong>另外的一台主机，而这台主机往往具有某种特权或者被另外的主机所信任。&lt;/p>
&lt;p>假设现在有一个合法用户 &lt;strong>(1.1.1.1)&lt;/strong> 已经同服务器建立正常的连接，攻击者构造攻击的 TCP 数据，伪装自己的 IP 为 &lt;strong>1.1.1.1&lt;/strong>，并向服务器发送一个带有 RST 位的 TCP 数据段。服务器接收到这样的数据后，认为从 &lt;strong>1.1.1.1&lt;/strong> 发送的连接有错误，就会清空缓冲区中建立好的连接。&lt;/p>
&lt;p>这时，如果合法用户 &lt;strong>1.1.1.1&lt;/strong> 再发送合法数据，服务器就已经没有这样的连接了，该用户就必须从新开始建立连接。攻击时，伪造大量的 IP 地址，向目标发送 RST 数据，使服务器不对合法用户服务。虽然 IP 地址欺骗攻击有着相当难度，但我们应该清醒地意识到，这种攻击非常广泛，入侵往往从这种攻击开始。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/p3-juejin/7547a145adf9404aa3a05f01f5ca2e32~tplv-k3u1fbpfcp-zoom-1.png" alt="IP 欺骗 DDoS 攻击" />&lt;/p></description></item><item><title>系统设计常见面试题总结(付费)</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/system-design-questions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/system-design/system-design-questions/</guid><description>&lt;p>&lt;strong>系统设计&lt;/strong> 相关的面试题为我的&lt;a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">知识星球&lt;/a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了&lt;a href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北》&lt;/a>中。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/javamianshizhibei/system-design-questions.png" alt="" />&lt;/p></description></item><item><title>线性数据结构</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/data-structure/linear-data-structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/data-structure/linear-data-structure/</guid><description>&lt;h2 id="1-数组">
 1. 数组
 &lt;a class="anchor" href="#1-%e6%95%b0%e7%bb%84">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>数组（Array）&lt;/strong> 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。&lt;/p>
&lt;p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。&lt;/p>
&lt;p>数组的特点是：&lt;strong>提供随机访问&lt;/strong> 并且容量有限。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>假如数组的长度为 n&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>访问&lt;span style="color:#960050;background-color:#1e0010">：&lt;/span>O&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>1&lt;span style="color:#960050;background-color:#1e0010">）&lt;/span>&lt;span style="color:#75715e">//访问特定位置的元素&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>插入&lt;span style="color:#960050;background-color:#1e0010">：&lt;/span>O&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>n &lt;span style="color:#960050;background-color:#1e0010">）&lt;/span>&lt;span style="color:#75715e">//最坏的情况发生在插入发生在数组的首部并需要移动所有元素时&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>删除&lt;span style="color:#960050;background-color:#1e0010">：&lt;/span>O&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>n&lt;span style="color:#960050;background-color:#1e0010">）&lt;/span>&lt;span style="color:#75715e">//最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/array.png" alt="数组" />&lt;/p>
&lt;h2 id="2-链表">
 2. 链表
 &lt;a class="anchor" href="#2-%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h2>
&lt;h3 id="21-链表简介">
 2.1. 链表简介
 &lt;a class="anchor" href="#21-%e9%93%be%e8%a1%a8%e7%ae%80%e4%bb%8b">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>链表（LinkedList）&lt;/strong> 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。&lt;/p>
&lt;p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。&lt;/p>
&lt;p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。&lt;/p>
&lt;h3 id="22-链表分类">
 2.2. 链表分类
 &lt;a class="anchor" href="#22-%e9%93%be%e8%a1%a8%e5%88%86%e7%b1%bb">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>常见链表分类：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>单链表&lt;/li>
&lt;li>双向链表&lt;/li>
&lt;li>循环链表&lt;/li>
&lt;li>双向循环链表&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>假如链表中有n个元素&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>访问&lt;span style="color:#960050;background-color:#1e0010">：&lt;/span>O&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>n&lt;span style="color:#960050;background-color:#1e0010">）&lt;/span>&lt;span style="color:#75715e">//访问特定位置的元素&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>插入删除&lt;span style="color:#960050;background-color:#1e0010">：&lt;/span>O&lt;span style="color:#960050;background-color:#1e0010">（&lt;/span>1&lt;span style="color:#960050;background-color:#1e0010">）&lt;/span>&lt;span style="color:#75715e">//必须要要知道插入元素的位置&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="221-单链表">
 2.2.1. 单链表
 &lt;a class="anchor" href="#221-%e5%8d%95%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h4>
&lt;p>&lt;strong>单链表&lt;/strong> 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/single-linkedlist.png" alt="单链表" />&lt;/p>
&lt;h4 id="222-循环链表">
 2.2.2. 循环链表
 &lt;a class="anchor" href="#222-%e5%be%aa%e7%8e%af%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h4>
&lt;p>&lt;strong>循环链表&lt;/strong> 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/cs-basics/data-structure/circular-linkedlist.png" alt="循环链表" />&lt;/p>
&lt;h4 id="223-双向链表">
 2.2.3. 双向链表
 &lt;a class="anchor" href="#223-%e5%8f%8c%e5%90%91%e9%93%be%e8%a1%a8">#&lt;/a>
&lt;/h4>
&lt;p>&lt;strong>双向链表&lt;/strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。&lt;/p></description></item><item><title>消息队列基础知识总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/message-queue/message-queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-performance/message-queue/message-queue/</guid><description>&lt;p>::: tip&lt;/p>
&lt;p>这篇文章中的消息队列主要指的是分布式消息队列。&lt;/p>
&lt;p>:::&lt;/p>
&lt;p>“RabbitMQ？”“Kafka？”“RocketMQ？”&amp;hellip;在日常学习与开发过程中，我们常常听到消息队列这个关键词。我也在我的多篇文章中提到了这个概念。可能你是熟练使用消息队列的老手，又或者你是不懂消息队列的新手，不论你了不了解消息队列，本文都将带你搞懂消息队列的一些基本理论。&lt;/p>
&lt;p>如果你是老手，你可能从本文学到你之前不曾注意的一些关于消息队列的重要概念，如果你是新手，相信本文将是你打开消息队列大门的一板砖。&lt;/p>
&lt;h2 id="什么是消息队列">
 什么是消息队列？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97">#&lt;/a>
&lt;/h2>
&lt;p>我们可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/message-queue-small.png" alt="" />&lt;/p>
&lt;p>参与消息传递的双方称为 &lt;strong>生产者&lt;/strong> 和 &lt;strong>消费者&lt;/strong> ，生产者负责发送消息，消费者负责处理消息。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/message-queue-pub-sub-model.png" alt="发布/订阅（Pub/Sub）模型" />&lt;/p>
&lt;p>操作系统中的进程通信的一种很重要的方式就是消息队列。我们这里提到的消息队列稍微有点区别，更多指的是各个服务以及系统内部各个组件/模块之前的通信，属于一种 &lt;strong>中间件&lt;/strong> 。&lt;/p>
&lt;p>维基百科是这样介绍中间件的：&lt;/p>
&lt;blockquote>
&lt;p>中间件（英语：Middleware），又译中间件、中介层，是一类提供系统软件和应用软件之间连接、便于软件各部件之间的沟通的软件，应用软件可以借助中间件在不同的技术架构之间共享信息与资源。中间件位于客户机服务器的操作系统之上，管理着计算资源和网络通信。&lt;/p>
&lt;/blockquote>
&lt;p>简单来说：&lt;strong>中间件就是一类为应用软件服务的软件，应用软件是为用户服务的，用户不会接触或者使用到中间件。&lt;/strong>&lt;/p>
&lt;p>除了消息队列之外，常见的中间件还有 RPC 框架、分布式组件、HTTP 服务器、任务调度框架、配置中心、数据库层的分库分表工具和数据迁移工具等等。&lt;/p>
&lt;p>关于中间件比较详细的介绍可以参考阿里巴巴淘系技术的一篇回答：&lt;a href="https://www.zhihu.com/question/19730582/answer/1663627873">https://www.zhihu.com/question/19730582/answer/1663627873&lt;/a> 。&lt;/p>
&lt;p>随着分布式和微服务系统的发展，消息队列在系统设计中有了更大的发挥空间，使用消息队列可以降低系统耦合性、实现任务异步、有效地进行流量削峰，是分布式和微服务系统中重要的组件之一。&lt;/p>
&lt;h2 id="消息队列有什么用">
 消息队列有什么用？
 &lt;a class="anchor" href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;p>通常来说，使用消息队列主要能为我们的系统带来下面三点好处：&lt;/p>
&lt;ol>
&lt;li>异步处理&lt;/li>
&lt;li>削峰/限流&lt;/li>
&lt;li>降低系统耦合性&lt;/li>
&lt;/ol>
&lt;p>除了这三点之外，消息队列还有其他的一些应用场景，例如实现分布式事务、顺序保证和数据流处理。&lt;/p>
&lt;p>如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐你结合你自己的项目来回答。&lt;/p>
&lt;h3 id="异步处理">
 异步处理
 &lt;a class="anchor" href="#%e5%bc%82%e6%ad%a5%e5%a4%84%e7%90%86">#&lt;/a>
&lt;/h3>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/Asynchronous-message-queue.png" alt="通过异步处理提高系统性能" />&lt;/p>
&lt;p>将用户请求中包含的耗时操作，通过消息队列实现异步处理，将对应的消息发送到消息队列之后就立即返回结果，减少响应时间，提高用户体验。随后，系统再对消息进行消费。&lt;/p>
&lt;p>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，&lt;strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合&lt;/strong>，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。&lt;/p>
&lt;h3 id="削峰限流">
 削峰/限流
 &lt;a class="anchor" href="#%e5%89%8a%e5%b3%b0%e9%99%90%e6%b5%81">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。&lt;/strong>&lt;/p>
&lt;p>举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/%E5%89%8A%E5%B3%B0-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" alt="削峰" />&lt;/p>
&lt;h3 id="降低系统耦合性">
 降低系统耦合性
 &lt;a class="anchor" href="#%e9%99%8d%e4%bd%8e%e7%b3%bb%e7%bb%9f%e8%80%a6%e5%90%88%e6%80%a7">#&lt;/a>
&lt;/h3>
&lt;p>使用消息队列还可以降低系统耦合性。如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。&lt;/p>
&lt;p>生产者（客户端）发送消息到消息队列中去，消费者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/message-queue-pub-sub-model.png" alt="发布/订阅（Pub/Sub）模型" />&lt;/p>
&lt;p>&lt;strong>消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。&lt;/strong> 从上图可以看到&lt;strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合&lt;/strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。&lt;strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计&lt;/strong>。&lt;/p>
&lt;p>例如，我们商城系统分为用户、订单、财务、仓储、消息通知、物流、风控等多个服务。用户在完成下单后，需要调用财务（扣款）、仓储（库存管理）、物流（发货）、消息通知（通知用户发货）、风控（风险评估）等服务。使用消息队列后，下单操作和后续的扣款、发货、通知等操作就解耦了，下单完成发送一个消息到消息队列，需要用到的地方去订阅这个消息进行消息即可。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-performance/message-queue/message-queue-decouple-mall-example.png" alt="" />&lt;/p>
&lt;p>另外，为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。&lt;/p>
&lt;p>&lt;strong>备注：&lt;/strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了另外 5 种消息模型。&lt;/p></description></item><item><title>校招进入飞书的个人经验</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/my-personal-experience-in-2021/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/my-personal-experience-in-2021/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：这篇文章的作者校招最终去了飞书做开发。在这篇文章中，他分享了自己的校招经历以及个人经验。&lt;/p>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://www.ihewro.com/archives/1217/">https://www.ihewro.com/archives/1217/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="基本情况">
 基本情况
 &lt;a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e6%83%85%e5%86%b5">#&lt;/a>
&lt;/h2>
&lt;p>我是 C++主要是后台开发的方向。&lt;/p>
&lt;p>2021 春招入职字节飞书客户端，入职字节之前拿到了百度 offer（音视频直播部分） 以及腾讯 PCG （微视、后台开发）的 HR 面试通过（还没有收到录用意向书）。&lt;/p>
&lt;h2 id="不顺利的春招过程">
 不顺利的春招过程
 &lt;a class="anchor" href="#%e4%b8%8d%e9%a1%ba%e5%88%a9%e7%9a%84%e6%98%a5%e6%8b%9b%e8%bf%87%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;h3 id="春招实习对我来说不太顺利">
 春招实习对我来说不太顺利
 &lt;a class="anchor" href="#%e6%98%a5%e6%8b%9b%e5%ae%9e%e4%b9%a0%e5%af%b9%e6%88%91%e6%9d%a5%e8%af%b4%e4%b8%8d%e5%a4%aa%e9%a1%ba%e5%88%a9">#&lt;/a>
&lt;/h3>
&lt;p>实验室在 1 月份元旦的那天正式可以放假回家，但回家仍然继续“远程工作”，工作并没有减少，每天日复一日的测试，调试我们开发的“流媒体会议系统”。&lt;/p>
&lt;p>在 1 月的倒数第三天，我们开了“年终总结”线上会议。至此，作为研二基本上与实验室的工作开始告别。也正式开始了春招复习的阶段。&lt;/p>
&lt;p>2 月前已经间歇性的开始准备，无非就是在 LeetCode 上面刷刷题目，一天刷不了几道，后面甚至象征性的刷一下每日一题。对我的算法刷题帮助很少。&lt;/p>
&lt;p>2 月份开始，2 月初的时候，LeetCode 才刷了大概 40 多道题目，挤出了几周时间更新了 handsome 主题的 8.x 版本，这又是一个繁忙的几周。直到春节的当天正式发布，春节过后又开始陆陆续续用一些时间修复 bug，发布修复版本。2 月份这样悄悄溜走。&lt;/p>
&lt;h3 id="找实习的过程">
 找实习的过程
 &lt;a class="anchor" href="#%e6%89%be%e5%ae%9e%e4%b9%a0%e7%9a%84%e8%bf%87%e7%a8%8b">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>2021-3 月初&lt;/strong>&lt;/p>
&lt;p>3 月 初的时候，投了阿里提前批，没想到阿里 3 月 4 号提前批就结束了，那一天约的一面的电话面也被取消了。紧接了开学实验室开会同步进度的时候，发现大家都一面/二面/三面的进度，而我还没有投递的进度。&lt;/p>
&lt;p>&lt;strong>2021-3-8&lt;/strong>&lt;/p>
&lt;p>投递了字节飞书&lt;/p>
&lt;p>&lt;strong>2021-4 月初&lt;/strong>&lt;/p>
&lt;p>字节第一次一面，腾讯第一次一面&lt;/p>
&lt;p>&lt;strong>2021-4 中旬&lt;/strong>&lt;/p>
&lt;p>美团一、二面，腾讯第二次一面和二面，百度三轮面试，通过了。&lt;/p>
&lt;p>&lt;strong>2021-4 底&lt;/strong>&lt;/p>
&lt;p>腾讯第三次一面和字节第二次一面&lt;/p>
&lt;p>&lt;strong>2021-5 月初&lt;/strong>&lt;/p>
&lt;p>腾讯第三次二面和字节第二次二面，后面这两个都通过了&lt;/p>
&lt;h4 id="阿里">
 阿里
 &lt;a class="anchor" href="#%e9%98%bf%e9%87%8c">#&lt;/a>
&lt;/h4>
&lt;p>第一次投了钉钉，没想到因为行测做的不好，在简历筛选给拒绝了。&lt;/p></description></item><item><title>新入职一家公司如何快速进入工作状态</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/work/get-into-work-mode-quickly-when-you-join-a-company/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/work/get-into-work-mode-quickly-when-you-join-a-company/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：强烈建议每一位即将入职/在职的小伙伴看看这篇文章，看完之后可以帮助你少踩很多坑。整篇文章逻辑清晰，内容全面！&lt;/p>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://www.cnblogs.com/hunternet/p/14675348.html">https://www.cnblogs.com/hunternet/p/14675348.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/work/%E6%96%B0%E5%85%A5%E8%81%8C%E4%B8%80%E5%AE%B6%E5%85%AC%E5%8F%B8%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E8%BF%9B%E5%85%A5%E7%8A%B6%E6%80%81.png" alt="新入职一家公司如何快速进入状态" />&lt;/p>
&lt;p>一年一度的金三银四跳槽大戏即将落幕，相信很多跳槽的小伙伴们已经找到了心仪的工作，即将或已经有了新的开始。&lt;/p>
&lt;p>相信有过跳槽经验的小伙伴们都知道，每到一个新的公司面临的可能都是新的业务、新的技术、新的团队……这些可能会打破你原来工作思维、编码习惯、合作方式……&lt;/p>
&lt;p>而于公司而言，又不能给你几个月的时间去慢慢的熟悉。这个时候，如何快速进入工作状态，尽快发挥自己的价值是非常重要的。&lt;/p>
&lt;p>有些人可能会很幸运，入职的公司会有完善的流程与机制，通过一带一、各种培训等方式可以在短时间内快速的让新人进入工作状态。有些人可能就没有那么幸运了，就比如我在几年前跳槽进入某厂的时候，当时还没有像我们现在这么完善的带新人融入的机制，又赶上团队最忙的一段时间，刚一入职的当天下午就让给了我几个线上问题去排查，也没有任何的文档和培训。遇到情况，很多人可能会因为难以快速适应，最终承受不起压力而萌生退意。&lt;/p>
&lt;p>&lt;img src="https://hunter-picgos.oss-cn-shanghai.aliyuncs.com/picgo/bad175e3a380bea..jpg" alt="bad175e3a380bea." />&lt;/p>
&lt;p>那么，&lt;strong>我们应该如何去快速的让自己进入工作状态，适应新的工作节奏呢？&lt;/strong>&lt;/p>
&lt;p>新的工作面对着一堆的代码仓库，很多人常常感觉无从下手。但回顾一下自己过往的工作与项目的经验，我们可以发现它们有着异曲同工之处。当开始一个新的项目，一般会经历几个步骤：需求-&amp;gt;设计-&amp;gt;开发-&amp;gt;测试-&amp;gt;发布，就这么循环往复，我们完成了一个又一个的项目。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/high-quality-technical-articles/work/image-20220704191430466.png" alt="项目流程" />&lt;/p>
&lt;p>而在这个过程中主要有四个方面的知识那就是业务、技术、项目与团队贯穿始终。新入职一家公司，我们第一阶段的目标就是要具备能够跟着团队做项目的能力，因此我们所应尽快掌握的知识点也要从这四个方面入手。&lt;/p>
&lt;h2 id="业务">
 业务
 &lt;a class="anchor" href="#%e4%b8%9a%e5%8a%a1">#&lt;/a>
&lt;/h2>
&lt;p>很多人可能会认为作为一个技术人，最应该了解的不应该是技术吗？于是他们在进入一家公司后，就迫不及待的研究起来了一些技术文档，系统架构，甚至抱起来源代码就开始“啃”，如果你也是这么做的，那就大错特错了！在几乎所有的公司里，技术都是作为一个工具存在的，虽然它很重要，但是它也是为了承载业务所存在的，技术解决了如何做的问题，而业务却告诉我们，做什么，为什么做。一旦脱离了业务，那么技术的存在将毫无意义。&lt;/p>
&lt;p>想要了解业务，有两个非常重要的方式&lt;/p>
&lt;p>&lt;strong>一是靠问&lt;/strong>&lt;/p>
&lt;p>如果你加入的团队，有着完善的业务培训机制，详尽的需求文档，也许你不需要过多的询问就可以了解业务，但这只是理想中的情况，大多数公司是没有这个条件的。因此我们只能靠问。&lt;/p>
&lt;p>这里不得不提的是，作为一个新人一定要有一定的脸皮厚度，不懂就要问。我见过很多新人会因为内向、腼腆，遇到疑问总是不好意思去问，这导致他们很长一段时间都难以融入团队、承担更重要的责任。不怕要怕挨训、怕被怼，而且我相信绝对多数的程序员还是很好沟通的！&lt;/p>
&lt;p>&lt;strong>二是靠测试&lt;/strong>&lt;/p>
&lt;p>我认为测试绝对是一个人快速了解团队业务的方式。通过测试我们可以走一走自己团队所负责项目的整体流程，如果遇到自己走不下去或想不通的地方及时去问，在这个过程中我们自然而然的就可以快速的了解到核心的业务流程。&lt;/p>
&lt;p>在了解业务的过程中，我们应该注意的是不要让自己过多的去追求细节，我们的目的是先能够整体了解业务流程，我们面向哪些用户，提供了哪些服务……&lt;/p>
&lt;h2 id="技术">
 技术
 &lt;a class="anchor" href="#%e6%8a%80%e6%9c%af">#&lt;/a>
&lt;/h2>
&lt;p>在我们初步了解完业务之后，就该到技术了，也许你已经按捺不住翻开源代码的准备了，但还是要先提醒你一句先不要着急。&lt;/p>
&lt;p>这个时候我们应该先按照自己了解到的业务，结合自己过往的工作经验去思考一下如果是自己去实现这个系统，应该如何去做？这一步很重要，它可以在后面我们具体去了解系统的技术实现的时候去对比一下与自己的实现思路有哪些差异，为什么会有这些差异，哪些更好，哪些不好，对于不好我们可以提出自己的意见，对于更好的我们可以吸收学习为己用！&lt;/p>
&lt;p>接下来，我们就是要了解技术了，但也不是一上来就去翻源代码。 &lt;strong>应该按照从宏观到细节，由外而内逐步地对系统进行分析。&lt;/strong>&lt;/p>
&lt;p>首先，我们应该简单的了解一下 &lt;strong>自己团队/项目的所用到的技术栈&lt;/strong> ，Java 还是.NET、亦或是多种语言并存，项目是前后端分离还是服务端全包，使用的数据库是 MySQL 还是 PostgreSQL……，这样我们可能会对所用到的技术和框架，以及自己所负责的内容有一定的预期，这一点有的人可能在面试的时候就会简单了解过。&lt;/p>
&lt;p>下一步，我们应该了解的是 &lt;strong>系统的宏观业务架构&lt;/strong> 。自己的团队主要负责哪些系统，每个系统又主要包含哪些模块，又与哪些外部系统进行交互……对于这些，最好可以通过流程图或者思维导图等方式整理出来。&lt;/p>
&lt;p>然后，我们要做的是看一下 &lt;strong>自己的团队提供了哪些对外的接口或者服务&lt;/strong> 。每个接口和服务所提供功能是什么。这一点我们可以继续去测试自己的系统，这个时候我们要看一看主要流程中主要包含了哪些页面，每个页面又调用了后端的哪些接口，每个后端接口又对应着哪个代码仓库。(如果是单纯做后端服务的，可以看一下我们提供了哪些服务，又有哪些上游服务，每个上游服务调用自己团队的哪些服务……)，同样我们应该用画图的形式整理出来。&lt;/p>
&lt;p>接着，我们要了解一下 &lt;strong>自己的系统或服务又依赖了哪些外部服务&lt;/strong> ，也就是说需要哪些外部系统的支持，这些服务也许是团队之外、公司之外，也可能是其他公司提供的。这个时候我们可以简单的进入代码看一下与外部系统的交互是怎么做的，包括通讯框架(REST、RPC)、通讯协议……&lt;/p>
&lt;p>到了代码层面，我们首先应该了解每个模块代码的层次结构，一个模块分了多少层，每个层次的职责是什么，了解了这个就对系统的整个设计有了初步的概念，紧接着就是代码的目录结构、配置文件的位置。&lt;/p>
&lt;p>最后，我们可以寻找一个示例，可以是一个接口，一个页面，让我们的思路跟随者代码的运行的路线，从入参到出参，完整的走一遍来验证一下我们之前的了解。&lt;/p>
&lt;p>到了这里我们对于技术层面的了解就可以先告一段落了，我们的目的知识对系统有一个初步的认知，更细节的东西，后面我们会有大把的时间去了解&lt;/p>
&lt;h2 id="项目与团队">
 项目与团队
 &lt;a class="anchor" href="#%e9%a1%b9%e7%9b%ae%e4%b8%8e%e5%9b%a2%e9%98%9f">#&lt;/a>
&lt;/h2>
&lt;p>上面我们提到，新入职一家公司，第一阶段的目标是有跟着团队做项目的能力，接下来我们要了解的就是项目是如何运作的。&lt;/p>
&lt;p>我们应该把握从需求设计到代码编写入库最终到发布上线的整个过程中的一些关键点。例如项目采用敏捷还是瀑布的模式，一个迭代周期是多长，需求的来源以及展现形式，有没有需求评审，代码的编写规范是什么，编写完成后如何构建，如何入库，有没有提交规范，如何交付测试，发布前的准备是什么，发布工具如何使用……&lt;/p>
&lt;p>关于项目我们只需要观察同事，或者自己亲身经历一个迭代的开发，就能够大概了解清楚。&lt;/p>
&lt;p>在了解项目运作的同时，我们还应该去了解团队，同样我们应该先从外部开始，我们对接了哪些外部团队，比如需求从哪里来，是否对接公司外部的团队，提供服务的上游团队有哪些，依赖的下游团队有哪些，团队之间如何沟通，常用的沟通方式是什么……&lt;/p>
&lt;p>接下来则是团队内部，团队中有哪些角色，每个人的职责是什么，这样遇到问题我们也可以清楚的找到对应的同事寻求帮助。是否有一些定期的活动与会议，例如每日站会、周例会，是否有一些约定俗成的规矩，是否有一些内部评审，分享机制……&lt;/p>
&lt;h2 id="总结">
 总结
 &lt;a class="anchor" href="#%e6%80%bb%e7%bb%93">#&lt;/a>
&lt;/h2>
&lt;p>新入职一家公司，面临新的工作挑战，能够尽快进入工作状态，实现自己的价值，将会给你带来一个好的开始。&lt;/p>
&lt;p>作为一个程序员，能够尽快进入工作状态，意味着我们首先应该具备跟着团队做项目的能力，这里我站在了一个后端开发的角度上从业务、技术、项目与团队四个方面总结了一些方法和经验。&lt;/p>
&lt;p>关于如何快速进入工作状态，如果你有好的方法与建议，欢迎在评论区留言。&lt;/p>
&lt;p>最后我们用一张思维导图来回顾一下这篇文章的内容。如果你觉得这篇文章对你有所帮助，可以关注文末公众号，我会经常分享一些自己成长过程中的经验与心得，与大家一起学习与进步。&lt;/p></description></item><item><title>性能测试入门</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-availability/performance-test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-availability/performance-test/</guid><description>&lt;p>性能测试一般情况下都是由测试这个职位去做的，那还需要我们开发学这个干嘛呢？了解性能测试的指标、分类以及工具等知识有助于我们更好地去写出性能更好的程序，另外作为开发这个角色，如果你会性能测试的话，相信也会为你的履历加分不少。&lt;/p>
&lt;p>这篇文章是我会结合自己的实际经历以及在测试这里取的经所得，除此之外，我还借鉴了一些优秀书籍，希望对你有帮助。&lt;/p>
&lt;h2 id="不同角色看网站性能">
 不同角色看网站性能
 &lt;a class="anchor" href="#%e4%b8%8d%e5%90%8c%e8%a7%92%e8%89%b2%e7%9c%8b%e7%bd%91%e7%ab%99%e6%80%a7%e8%83%bd">#&lt;/a>
&lt;/h2>
&lt;h3 id="用户">
 用户
 &lt;a class="anchor" href="#%e7%94%a8%e6%88%b7">#&lt;/a>
&lt;/h3>
&lt;p>当用户打开一个网站的时候，最关注的是什么？当然是网站响应速度的快慢。比如我们点击了淘宝的主页，淘宝需要多久将首页的内容呈现在我的面前，我点击了提交订单按钮需要多久返回结果等等。&lt;/p>
&lt;p>所以，用户在体验我们系统的时候往往根据你的响应速度的快慢来评判你的网站的性能。&lt;/p>
&lt;h3 id="开发人员">
 开发人员
 &lt;a class="anchor" href="#%e5%bc%80%e5%8f%91%e4%ba%ba%e5%91%98">#&lt;/a>
&lt;/h3>
&lt;p>用户与开发人员都关注速度，这个速度实际上就是我们的系统&lt;strong>处理用户请求的速度&lt;/strong>。&lt;/p>
&lt;p>开发人员一般情况下很难直观的去评判自己网站的性能，我们往往会根据网站当前的架构以及基础设施情况给一个大概的值,比如：&lt;/p>
&lt;ol>
&lt;li>项目架构是分布式的吗？&lt;/li>
&lt;li>用到了缓存和消息队列没有？&lt;/li>
&lt;li>高并发的业务有没有特殊处理？&lt;/li>
&lt;li>数据库设计是否合理？&lt;/li>
&lt;li>系统用到的算法是否还需要优化？&lt;/li>
&lt;li>系统是否存在内存泄露的问题？&lt;/li>
&lt;li>项目使用的 Redis 缓存多大？服务器性能如何？用的是机械硬盘还是固态硬盘？&lt;/li>
&lt;li>……&lt;/li>
&lt;/ol>
&lt;h3 id="测试人员">
 测试人员
 &lt;a class="anchor" href="#%e6%b5%8b%e8%af%95%e4%ba%ba%e5%91%98">#&lt;/a>
&lt;/h3>
&lt;p>测试人员一般会根据性能测试工具来测试，然后一般会做出一个表格。这个表格可能会涵盖下面这些重要的内容：&lt;/p>
&lt;ol>
&lt;li>响应时间；&lt;/li>
&lt;li>请求成功率；&lt;/li>
&lt;li>吞吐量；&lt;/li>
&lt;li>……&lt;/li>
&lt;/ol>
&lt;h3 id="运维人员">
 运维人员
 &lt;a class="anchor" href="#%e8%bf%90%e7%bb%b4%e4%ba%ba%e5%91%98">#&lt;/a>
&lt;/h3>
&lt;p>运维人员会倾向于根据基础设施和资源的利用率来判断网站的性能，比如我们的服务器资源使用是否合理、数据库资源是否存在滥用的情况、当然，这是传统的运维人员，现在 Devops 火起来后，单纯干运维的很少了。我们这里暂且还保留有这个角色。&lt;/p>
&lt;h2 id="性能测试需要注意的点">
 性能测试需要注意的点
 &lt;a class="anchor" href="#%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e7%9a%84%e7%82%b9">#&lt;/a>
&lt;/h2>
&lt;p>几乎没有文章在讲性能测试的时候提到这个问题，大家都会讲如何去性能测试，有哪些性能测试指标这些东西。&lt;/p>
&lt;h3 id="了解系统的业务场景">
 了解系统的业务场景
 &lt;a class="anchor" href="#%e4%ba%86%e8%a7%a3%e7%b3%bb%e7%bb%9f%e7%9a%84%e4%b8%9a%e5%8a%a1%e5%9c%ba%e6%99%af">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>性能测试之前更需要你了解当前的系统的业务场景。&lt;/strong> 对系统业务了解的不够深刻，我们很容易犯测试方向偏执的错误，从而导致我们忽略了对系统某些更需要性能测试的地方进行测试。比如我们的系统可以为用户提供发送邮件的功能，用户配置成功邮箱后只需输入相应的邮箱之后就能发送，系统每天大概能处理上万次发邮件的请求。很多人看到这个可能就直接开始使用相关工具测试邮箱发送接口，但是，发送邮件这个场景可能不是当前系统的性能瓶颈，这么多人用我们的系统发邮件， 还可能有很多人一起发邮件，单单这个场景就这么人用，那用户管理可能才是性能瓶颈吧！&lt;/p>
&lt;h3 id="历史数据非常有用">
 历史数据非常有用
 &lt;a class="anchor" href="#%e5%8e%86%e5%8f%b2%e6%95%b0%e6%8d%ae%e9%9d%9e%e5%b8%b8%e6%9c%89%e7%94%a8">#&lt;/a>
&lt;/h3>
&lt;p>当前系统所留下的历史数据非常重要，一般情况下，我们可以通过相应的些历史数据初步判定这个系统哪些接口调用的比较多、哪些服务承受的压力最大，这样的话，我们就可以针对这些地方进行更细致的性能测试与分析。&lt;/p>
&lt;p>另外，这些地方也就像这个系统的一个短板一样，优化好了这些地方会为我们的系统带来质的提升。&lt;/p>
&lt;h2 id="常见性能指标">
 常见性能指标
 &lt;a class="anchor" href="#%e5%b8%b8%e8%a7%81%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87">#&lt;/a>
&lt;/h2>
&lt;h3 id="响应时间">
 响应时间
 &lt;a class="anchor" href="#%e5%93%8d%e5%ba%94%e6%97%b6%e9%97%b4">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>响应时间 RT(Response-time)就是用户发出请求到用户收到系统处理结果所需要的时间。&lt;/strong>&lt;/p>
&lt;p>RT 是一个非常重要且直观的指标，RT 数值大小直接反应了系统处理用户请求速度的快慢。&lt;/p>
&lt;h3 id="并发数">
 并发数
 &lt;a class="anchor" href="#%e5%b9%b6%e5%8f%91%e6%95%b0">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>并发数可以简单理解为系统能够同时供多少人访问使用也就是说系统同时能处理的请求数量。&lt;/strong>&lt;/p>
&lt;p>并发数反应了系统的负载能力。&lt;/p></description></item><item><title>虚拟线程常见问题总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/virtual-thread/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/concurrent/virtual-thread/</guid><description>&lt;blockquote>
&lt;p>本文部分内容来自 &lt;a href="https://github.com/Lorin-github">Lorin&lt;/a> 的&lt;a href="https://github.com/Snailclimb/JavaGuide/pull/2190">PR&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>虚拟线程在 Java 21 正式发布，这是一项重量级的更新。&lt;/p>
&lt;h2 id="什么是虚拟线程">
 什么是虚拟线程？
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;p>虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。&lt;/p>
&lt;h2 id="虚拟线程和平台线程有什么关系">
 虚拟线程和平台线程有什么关系？
 &lt;a class="anchor" href="#%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e5%92%8c%e5%b9%b3%e5%8f%b0%e7%ba%bf%e7%a8%8b%e6%9c%89%e4%bb%80%e4%b9%88%e5%85%b3%e7%b3%bb">#&lt;/a>
&lt;/h2>
&lt;p>在引入虚拟线程之前，&lt;code>java.lang.Thread&lt;/code> 包已经支持所谓的平台线程（Platform Thread），也就是没有虚拟线程之前，我们一直使用的线程。JVM 调度程序通过平台线程（载体线程）来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程（多个虚拟线程挂载在一个平台线程上），当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。&lt;/p>
&lt;p>虚拟线程、平台线程和系统内核线程的关系图如下所示（图源：&lt;a href="https://medium.com/javarevisited/how-to-use-java-19-virtual-threads-c16a32bad5f7">How to Use Java 19 Virtual Threads&lt;/a>）：&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/java/new-features/virtual-threads-platform-threads-kernel-threads-relationship.png" alt="虚拟线程、平台线程和系统内核线程的关系" />&lt;/p>
&lt;p>关于平台线程和系统内核线程的对应关系多提一点：在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个平台线程对应一个系统内核线程。Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一。具体可以参考 R 大的回答: &lt;a href="https://www.zhihu.com/question/23096638/answer/29617153">JVM 中的线程模型是用户级的么？&lt;/a>。&lt;/p>
&lt;h2 id="虚拟线程有什么优点和缺点">
 虚拟线程有什么优点和缺点？
 &lt;a class="anchor" href="#%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b%e6%9c%89%e4%bb%80%e4%b9%88%e4%bc%98%e7%82%b9%e5%92%8c%e7%bc%ba%e7%82%b9">#&lt;/a>
&lt;/h2>
&lt;h3 id="优点">
 优点
 &lt;a class="anchor" href="#%e4%bc%98%e7%82%b9">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>非常轻量级&lt;/strong>：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。&lt;/li>
&lt;li>&lt;strong>简化异步编程&lt;/strong>： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱（Callback Hell）。&lt;/li>
&lt;li>&lt;strong>减少资源开销&lt;/strong>： 由于虚拟线程是由 JVM 实现的，它能够更高效地利用底层资源，例如 CPU 和内存。虚拟线程的上下文切换比平台线程更轻量，因此能够更好地支持高并发场景。&lt;/li>
&lt;/ul>
&lt;h3 id="缺点">
 缺点
 &lt;a class="anchor" href="#%e7%bc%ba%e7%82%b9">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>不适用于计算密集型任务&lt;/strong>： 虚拟线程适用于 I/O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。&lt;/li>
&lt;li>&lt;strong>与某些第三方库不兼容&lt;/strong>： 虽然虚拟线程设计时考虑了与现有代码的兼容性，但某些依赖平台线程特性的第三方库可能不完全兼容虚拟线程。&lt;/li>
&lt;/ul>
&lt;h2 id="如何创建虚拟线程">
 如何创建虚拟线程？
 &lt;a class="anchor" href="#%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba%e8%99%9a%e6%8b%9f%e7%ba%bf%e7%a8%8b">#&lt;/a>
&lt;/h2>
&lt;p>官方提供了以下四种方式创建虚拟线程：&lt;/p></description></item><item><title>一个中科大差生的 8 年程序员工作总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/8-years-programmer-work-summary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/personal-experience/8-years-programmer-work-summary/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：这篇文章讲述了一位中科大的朋友 8 年的经历：从 2013 年毕业之后加入上海航天 x 院某卫星研究所，再到入职华为，从华为离职。除了丰富的经历之外，作者在文章还给出了很多自己对于工作/生活的思考。我觉得非常受用！我在这里，向这位作者表达一下衷心的感谢。&lt;/p>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://www.cnblogs.com/scada/p/14259332.html">https://www.cnblogs.com/scada/p/14259332.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h2 id="前言">
 前言
 &lt;a class="anchor" href="#%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h2>
&lt;p>今年终于从大菊花厂离职了，离职前收入大概 60w 不到吧！在某乎属于比较差的，今天终于有空写一下自己的职场故事，也算是给自己近 8 年的程序员工作做个总结复盘。&lt;/p>
&lt;p>近 8 年有些事情做对了，也有更多事情做错了，在这里记录一下，希望能够给后人一些帮助吧，也欢迎私信交流。文笔不好，见谅，有些细节记不清了，如果有出入，就当是我编的这个故事吧。&lt;/p>
&lt;p>&lt;em>PS：有几个问题先在这里解释一下，评论就不一一回复了&lt;/em>&lt;/p>
&lt;ol>
&lt;li>关于差生，我本人在科大时确实成绩偏下，差生主要讲这一点，没其他意思。&lt;/li>
&lt;li>因为买房是我人生中的大事，我认为需要记录和总结一下，本文中会有买房，房价之类的信息出现，您如果对房价，炒房等反感的话，请您停止阅读，并且我再这里为浪费您的时间先道个歉。&lt;/li>
&lt;/ol>
&lt;h2 id="2013-年">
 2013 年
 &lt;a class="anchor" href="#2013-%e5%b9%b4">#&lt;/a>
&lt;/h2>
&lt;h3 id="加入上海航天-x-院某卫星研究所">
 加入上海航天 x 院某卫星研究所
 &lt;a class="anchor" href="#%e5%8a%a0%e5%85%a5%e4%b8%8a%e6%b5%b7%e8%88%aa%e5%a4%a9-x-%e9%99%a2%e6%9f%90%e5%8d%ab%e6%98%9f%e7%a0%94%e7%a9%b6%e6%89%80">#&lt;/a>
&lt;/h3>
&lt;p>本人 86 年生人，13 年从中科大软件相关专业毕业，由于父母均是老师，从小接受的教育就是努力学习，找个稳定的“好工作”，报效国家。&lt;/p>
&lt;p>于是乎，毕业时候头脑一热加入了上海航天 x 院某卫星研究所，没有经过自己认真思考，仅仅听从父母意见，就草率的决定了自己的第一份工作，这也为我 5 年后离职埋下了隐患。这里总结第一条经验：&lt;/p>
&lt;p>&lt;strong>如果你的亲人是普通阶层，那对于人生中一些大事来说，他们给的建议往往就是普通阶层的思维，他们的阶层就是他们一生思维决策的结果，如果你的目标是跳出本阶层，那最好只把他们的建议当成参考。&lt;/strong>&lt;/p>
&lt;p>13 年 4 月份，我坐上火车来到上海，在一路换乘地铁来到了大闵行，出了地铁走路到单位，一路上建筑都比较老旧，我心里想这跟老家也没什么区别嘛，还大上海呢。&lt;/p>
&lt;p>到达单位报道，负责报道的老师很亲切，填写完资料，分配了一间宿舍，还给了大概 3k 左右安家费，当时我心里那个激动啊（乡下孩子没有见过钱啊，见谅），拿了安家费，在附近小超市买好生活用品，这样我就开始了自己航天生涯。&lt;/p>
&lt;p>经过 1 个月集中培训后，我分配到部门，主要负责卫星上嵌入式软件开发。不过说是高大上的卫星软件开发，其实刚开始就是打杂，给实验室、厂房推箱子搬设备，呵呵，说航天是个体力活相信很多航天人都有同感吧。不过当时年轻，心思很单纯，每天搬完设备，晚上主动加班，看文档材料，画软件流程图，编程练习，日子过得很充实。&lt;/p>
&lt;p>记得第一个月到手大概 5k 左右（好少呀），当时很多一起入职的同事抱怨，我没有，我甚至不太愿意和他们比较工资，这里总结第二条经验：&lt;/p>
&lt;p>&lt;strong>不要和你的同事比工资，没有意义，比工资总会有人受伤，更多的是负面影响，并且很多时候受伤的会是你。&lt;/strong>&lt;/p>
&lt;h3 id="工作中暂露头角">
 工作中暂露头角
 &lt;a class="anchor" href="#%e5%b7%a5%e4%bd%9c%e4%b8%ad%e6%9a%82%e9%9c%b2%e5%a4%b4%e8%a7%92">#&lt;/a>
&lt;/h3>
&lt;p>工作大概一个月的时候，我遇到了一件事情，让我从新员工里面开始暂露头角。事情是这样的当时国家要对军工单位进行 GJB5000A 软件开发等级认证（搞过这个认证的同学应该都知道，过这个认证那是要多酸爽有多酸爽），但是当时一个负责配置管理的同事却提出离职，原因是他考上了公务员，当时我们用的那个软件平台后台的版本控制是 SVN 实现的，恰好我在学校写程序时用过，呵呵，话说回来现在学生自己写软件很少有人会在本地搭版本控制器吧！我记得当时还被同学嘲笑过，这让我想起了乔布斯学习美术字的故事，这里总结一下：&lt;/p>
&lt;p>&lt;strong>不要说一项技能没有用，任何你掌握的技能都有价值，但是你要学会找到发挥它的场景。如果有一天你落水了，你可能会很庆幸，自己以前学会了游泳。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>工作中如果要上升，你要勇于承担麻烦的、有挑战的任务，当你推掉麻烦的时候，你也推掉了机遇。&lt;/strong>&lt;/p>
&lt;p>好了，扯远了，回到前面，当时我主动跟单位认证负责人提出，我可以帮忙负责这方面的工作，我有一定经验。这里要提一下这个负责人，是位女士，她是我非常敬佩的一个前辈，认真，负责，无私，整个人为国家的航天事业奉献了几十年，其实航天领域有非常多这样的老前辈，他们默默奋斗，拿着不高的薪水，为祖国的国防建设做出了巨大的贡献。当时这位负责人，看我平时工作认真积极，思维反应也比较灵活（因为过认证需要和认证专家现场答辩的）就同意了我的请求，接受到这个任务之后，我迅速投入，学习认证流程、体系文件、迅速掌握认证工作要点，一点一点把相关的工作做好，同时周期性对业务进行复盘，总结复盘可能是我自己的一个优点：&lt;/p>
&lt;p>&lt;strong>很多人喜欢不停的做事，但不会停下来思考，缺乏总结复盘的能力，其实阶段性总结复盘，不仅能够固化前面的经验，也能梳理后面的方向；把事情做对很重要，但是更重要的是做对的事；另外不要贪快，方向正确慢就是快&lt;/strong>(后半句是我后来才想明白的，如果早想明白，就不会混成目前这样了）&lt;/p>
&lt;p>1 个月后，当时有惊无险通过了当年的认证，当时负责人主动向单位申请了 2k 特别奖，当时我真的非常高兴，主要是自己的工作产生了价值，得到了认可。后来几个月的日子平淡无奇，有印象的好像只有两件事情。&lt;/p></description></item><item><title>一千行 MySQL 学习笔记</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/a-thousand-lines-of-mysql-study-notes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/mysql/a-thousand-lines-of-mysql-study-notes/</guid><description>&lt;blockquote>
&lt;p>原文地址：&lt;a href="https://shockerli.net/post/1000-line-mysql-note/">https://shockerli.net/post/1000-line-mysql-note/&lt;/a> ，JavaGuide 对本文进行了简答排版，新增了目录。&lt;/p>
&lt;/blockquote>
&lt;p>非常不错的总结，强烈建议保存下来，需要的时候看一看。&lt;/p>
&lt;h3 id="基本操作">
 基本操作
 &lt;a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* Windows服务 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 启动 MySQL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>			net &lt;span style="color:#66d9ef">start&lt;/span> mysql
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 创建Windows服务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>				sc &lt;span style="color:#66d9ef">create&lt;/span> mysql binPath&lt;span style="color:#f92672">=&lt;/span> mysqld_bin_path(&lt;span style="color:#960050;background-color:#1e0010">注意：等号与值之间有空格&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 连接与断开服务器 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 连接 MySQL
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>				mysql &lt;span style="color:#f92672">-&lt;/span>h &lt;span style="color:#960050;background-color:#1e0010">地址&lt;/span> &lt;span style="color:#f92672">-&lt;/span>P &lt;span style="color:#960050;background-color:#1e0010">端口&lt;/span> &lt;span style="color:#f92672">-&lt;/span>u &lt;span style="color:#960050;background-color:#1e0010">用户名&lt;/span> &lt;span style="color:#f92672">-&lt;/span>p &lt;span style="color:#960050;background-color:#1e0010">密码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 显示哪些线程正在运行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>				&lt;span style="color:#66d9ef">SHOW&lt;/span> PROCESSLIST
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 显示系统变量信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>				&lt;span style="color:#66d9ef">SHOW&lt;/span> VARIABLES
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="数据库操作">
 数据库操作
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 数据库操作 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 查看当前数据库
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#66d9ef">DATABASE&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 显示当前时间、用户名、数据库版本
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SELECT&lt;/span> now(), &lt;span style="color:#66d9ef">user&lt;/span>(), &lt;span style="color:#66d9ef">version&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 创建库
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">DATABASE&lt;/span>[ &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">数据库名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">数据库选项&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">数据库选项：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CHARACTER &lt;span style="color:#66d9ef">SET&lt;/span> charset_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">COLLATE&lt;/span> &lt;span style="color:#66d9ef">collation_name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 查看已有库
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SHOW&lt;/span> DATABASES[ &lt;span style="color:#66d9ef">LIKE&lt;/span> &lt;span style="color:#e6db74">&amp;#39;PATTERN&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 查看当前库信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SHOW&lt;/span> &lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">DATABASE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">数据库名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 修改库的选项信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">ALTER&lt;/span> &lt;span style="color:#66d9ef">DATABASE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">库名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">选项信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 删除库
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">DATABASE&lt;/span>[ &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">数据库名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">同时删除该数据库相关的目录及其目录内容&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="表的操作">
 表的操作
 &lt;a class="anchor" href="#%e8%a1%a8%e7%9a%84%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 表的操作 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 创建表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">CREATE&lt;/span> [&lt;span style="color:#66d9ef">TEMPORARY&lt;/span>] &lt;span style="color:#66d9ef">TABLE&lt;/span>[ &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span>] [&lt;span style="color:#960050;background-color:#1e0010">库名&lt;/span>.]&lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> ( &lt;span style="color:#960050;background-color:#1e0010">表的结构定义&lt;/span> )[ &lt;span style="color:#960050;background-color:#1e0010">表选项&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">每个字段必须有数据类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">最后一个字段后不能有逗号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">TEMPORARY&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">临时表，会话结束时表自动消失&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">对于字段的定义：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">字段名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">数据类型&lt;/span> [&lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>] [&lt;span style="color:#66d9ef">DEFAULT&lt;/span> default_value] [AUTO_INCREMENT] [&lt;span style="color:#66d9ef">UNIQUE&lt;/span> [&lt;span style="color:#66d9ef">KEY&lt;/span>] &lt;span style="color:#f92672">|&lt;/span> [&lt;span style="color:#66d9ef">PRIMARY&lt;/span>] &lt;span style="color:#66d9ef">KEY&lt;/span>] [&lt;span style="color:#66d9ef">COMMENT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;string&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 表选项
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- 字符集
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> CHARSET &lt;span style="color:#f92672">=&lt;/span> charset_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">如果表没有设定，则使用数据库字符集&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 存储引擎
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ENGINE &lt;span style="color:#f92672">=&lt;/span> engine_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">常见的引擎：&lt;/span>InnoDB MyISAM Memory&lt;span style="color:#f92672">/&lt;/span>Heap BDB Merge Example CSV MaxDB Archive
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">不同的引擎在保存表的结构和数据时采用不同的方式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyISAM表文件含义&lt;span style="color:#960050;background-color:#1e0010">：&lt;/span>.frm表定义&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>.MYD表数据&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>.MYI表索引
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InnoDB表文件含义&lt;span style="color:#960050;background-color:#1e0010">：&lt;/span>.frm表定义&lt;span style="color:#960050;background-color:#1e0010">，表空间数据和日志文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SHOW&lt;/span> ENGINES &lt;span style="color:#75715e">-- 显示存储引擎的状态信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SHOW&lt;/span> ENGINE &lt;span style="color:#960050;background-color:#1e0010">引擎名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>LOGS&lt;span style="color:#f92672">|&lt;/span>STATUS&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span> &lt;span style="color:#75715e">-- 显示存储引擎的日志或状态信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- 自增起始数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> 	AUTO_INCREMENT &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">行数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 数据文件目录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">DATA&lt;/span> DIRECTORY &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;目录&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 索引文件目录
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">INDEX&lt;/span> DIRECTORY &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;目录&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 表注释
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">COMMENT&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;string&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 分区选项
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> PARTITION &lt;span style="color:#66d9ef">BY&lt;/span> ... (&lt;span style="color:#960050;background-color:#1e0010">详细见手册&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 查看所有表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SHOW&lt;/span> TABLES[ &lt;span style="color:#66d9ef">LIKE&lt;/span> &lt;span style="color:#e6db74">&amp;#39;pattern&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SHOW&lt;/span> TABLES &lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">库名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 查看表结构
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SHOW&lt;/span> &lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">（信息更详细）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">DESC&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#66d9ef">DESCRIBE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#66d9ef">EXPLAIN&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#66d9ef">SHOW&lt;/span> COLUMNS &lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> [&lt;span style="color:#66d9ef">LIKE&lt;/span> &lt;span style="color:#e6db74">&amp;#39;PATTERN&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SHOW&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> STATUS [&lt;span style="color:#66d9ef">FROM&lt;/span> db_name] [&lt;span style="color:#66d9ef">LIKE&lt;/span> &lt;span style="color:#e6db74">&amp;#39;pattern&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 修改表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- 修改表本身的选项
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">ALTER&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表的选项&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> eg: &lt;span style="color:#66d9ef">ALTER&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> ENGINE&lt;span style="color:#f92672">=&lt;/span>MYISAM;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 对表进行重命名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">RENAME&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">原表名&lt;/span> &lt;span style="color:#66d9ef">TO&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">新表名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">RENAME&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">原表名&lt;/span> &lt;span style="color:#66d9ef">TO&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">库名&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">（可将表移动到另一个数据库）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- RENAME可以交换两个表名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- 修改表的字段机构（13.1.2. ALTER TABLE语法）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">ALTER&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">操作名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 操作名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">ADD&lt;/span>[ &lt;span style="color:#66d9ef">COLUMN&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">字段定义&lt;/span> &lt;span style="color:#75715e">-- 增加字段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">AFTER&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">字段名&lt;/span> &lt;span style="color:#75715e">-- 表示增加在该字段名后面
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">FIRST&lt;/span> &lt;span style="color:#75715e">-- 表示增加在第一个
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">ADD&lt;/span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span>(&lt;span style="color:#960050;background-color:#1e0010">字段名&lt;/span>) &lt;span style="color:#75715e">-- 创建主键
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">ADD&lt;/span> &lt;span style="color:#66d9ef">UNIQUE&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">索引名&lt;/span>] (&lt;span style="color:#960050;background-color:#1e0010">字段名&lt;/span>)&lt;span style="color:#75715e">-- 创建唯一索引
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">ADD&lt;/span> &lt;span style="color:#66d9ef">INDEX&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">索引名&lt;/span>] (&lt;span style="color:#960050;background-color:#1e0010">字段名&lt;/span>) &lt;span style="color:#75715e">-- 创建普通索引
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">DROP&lt;/span>[ &lt;span style="color:#66d9ef">COLUMN&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">字段名&lt;/span> &lt;span style="color:#75715e">-- 删除字段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">MODIFY&lt;/span>[ &lt;span style="color:#66d9ef">COLUMN&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">字段名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">字段属性&lt;/span> &lt;span style="color:#75715e">-- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> CHANGE[ &lt;span style="color:#66d9ef">COLUMN&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">原字段名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">新字段名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">字段属性&lt;/span> &lt;span style="color:#75715e">-- 支持对字段名修改
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#75715e">-- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">INDEX&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">索引名&lt;/span> &lt;span style="color:#75715e">-- 删除索引
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">FOREIGN&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">外键&lt;/span> &lt;span style="color:#75715e">-- 删除外键
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 删除表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span>[ &lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 清空表数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">TRUNCATE&lt;/span> [&lt;span style="color:#66d9ef">TABLE&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 复制表结构
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#66d9ef">LIKE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">要复制的表名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 复制表结构和数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> [&lt;span style="color:#66d9ef">AS&lt;/span>] &lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">要复制的表名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 检查表是否有错误
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">CHECK&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> tbl_name [, tbl_name] ... [&lt;span style="color:#66d9ef">option&lt;/span>] ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 优化表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> OPTIMIZE [&lt;span style="color:#66d9ef">LOCAL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> NO_WRITE_TO_BINLOG] &lt;span style="color:#66d9ef">TABLE&lt;/span> tbl_name [, tbl_name] ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 修复表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> REPAIR [&lt;span style="color:#66d9ef">LOCAL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> NO_WRITE_TO_BINLOG] &lt;span style="color:#66d9ef">TABLE&lt;/span> tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 分析表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">ANALYZE&lt;/span> [&lt;span style="color:#66d9ef">LOCAL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> NO_WRITE_TO_BINLOG] &lt;span style="color:#66d9ef">TABLE&lt;/span> tbl_name [, tbl_name] ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="数据操作">
 数据操作
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 数据操作 */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 增
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">INSERT&lt;/span> [&lt;span style="color:#66d9ef">INTO&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> [(&lt;span style="color:#960050;background-color:#1e0010">字段列表&lt;/span>)] &lt;span style="color:#66d9ef">VALUES&lt;/span> (&lt;span style="color:#960050;background-color:#1e0010">值列表&lt;/span>)[, (&lt;span style="color:#960050;background-color:#1e0010">值列表&lt;/span>), ...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- 可同时插入多条数据记录！
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> REPLACE与INSERT类似&lt;span style="color:#960050;background-color:#1e0010">，唯一的区别是对于匹配的行，现有行（与主键&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">唯一键比较）的数据会被替换，如果没有现有行，则插入新行。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">INSERT&lt;/span> [&lt;span style="color:#66d9ef">INTO&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">字段名&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">值&lt;/span>[, &lt;span style="color:#960050;background-color:#1e0010">字段名&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">值&lt;/span>, ...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 查
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">字段列表&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span>[ &lt;span style="color:#960050;background-color:#1e0010">其他子句&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 可来自多个表的多个字段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- 其他子句可以不使用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- 字段列表可以用*代替，表示所有字段
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 删
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">DELETE&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span>[ &lt;span style="color:#960050;background-color:#1e0010">删除条件子句&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">没有条件子句，则会删除全部&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 改
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">UPDATE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">字段名&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">新值&lt;/span>[, &lt;span style="color:#960050;background-color:#1e0010">字段名&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">新值&lt;/span>] [&lt;span style="color:#960050;background-color:#1e0010">更新条件&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="字符集编码">
 字符集编码
 &lt;a class="anchor" href="#%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bc%96%e7%a0%81">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 字符集编码 */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- MySQL、数据库、表、字段均可设置编码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 数据编码与客户端编码不需一致
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">SHOW&lt;/span> VARIABLES &lt;span style="color:#66d9ef">LIKE&lt;/span> &lt;span style="color:#e6db74">&amp;#39;character_set_%&amp;#39;&lt;/span> &lt;span style="color:#75715e">-- 查看所有字符集编码项
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> character_set_client &lt;span style="color:#960050;background-color:#1e0010">客户端向服务器发送数据时使用的编码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> character_set_results &lt;span style="color:#960050;background-color:#1e0010">服务器端将结果返回给客户端所使用的编码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> character_set_connection &lt;span style="color:#960050;background-color:#1e0010">连接层编码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">变量名&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">变量值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> character_set_client &lt;span style="color:#f92672">=&lt;/span> gbk;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> character_set_results &lt;span style="color:#f92672">=&lt;/span> gbk;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> character_set_connection &lt;span style="color:#f92672">=&lt;/span> gbk;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SET&lt;/span> &lt;span style="color:#66d9ef">NAMES&lt;/span> GBK; &lt;span style="color:#75715e">-- 相当于完成以上三个设置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 校对集
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">校对集用以排序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SHOW&lt;/span> CHARACTER &lt;span style="color:#66d9ef">SET&lt;/span> [&lt;span style="color:#66d9ef">LIKE&lt;/span> &lt;span style="color:#e6db74">&amp;#39;pattern&amp;#39;&lt;/span>]&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">SHOW&lt;/span> CHARSET [&lt;span style="color:#66d9ef">LIKE&lt;/span> &lt;span style="color:#e6db74">&amp;#39;pattern&amp;#39;&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">查看所有字符集&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SHOW&lt;/span> &lt;span style="color:#66d9ef">COLLATION&lt;/span> [&lt;span style="color:#66d9ef">LIKE&lt;/span> &lt;span style="color:#e6db74">&amp;#39;pattern&amp;#39;&lt;/span>] &lt;span style="color:#960050;background-color:#1e0010">查看所有校对集&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CHARSET &lt;span style="color:#960050;background-color:#1e0010">字符集编码&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">设置字符集编码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">COLLATE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">校对集编码&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">设置校对集编码&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="数据类型列类型">
 数据类型(列类型)
 &lt;a class="anchor" href="#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%88%97%e7%b1%bb%e5%9e%8b">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 数据类型（列类型） */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">数值类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- a. 整型 ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">类型&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">范围（有符号位）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tinyint &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">128&lt;/span> &lt;span style="color:#f92672">~&lt;/span> &lt;span style="color:#ae81ff">127&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">无符号位：&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">~&lt;/span> &lt;span style="color:#ae81ff">255&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> smallint &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">32768&lt;/span> &lt;span style="color:#f92672">~&lt;/span> &lt;span style="color:#ae81ff">32767&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mediumint &lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">8388608&lt;/span> &lt;span style="color:#f92672">~&lt;/span> &lt;span style="color:#ae81ff">8388607&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> int &lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bigint &lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> int(M) M表示总位数
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">默认存在符号位，&lt;/span>unsigned &lt;span style="color:#960050;background-color:#1e0010">属性修改&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">显示宽度，如果某个数不够定义字段时设置的位数，则前面以&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">补填，&lt;/span>zerofill &lt;span style="color:#960050;background-color:#1e0010">属性修改&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">例：&lt;/span>int(&lt;span style="color:#ae81ff">5&lt;/span>) &lt;span style="color:#960050;background-color:#1e0010">插入一个数&lt;/span>&lt;span style="color:#e6db74">&amp;#39;123&amp;#39;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，补填后为&lt;/span>&lt;span style="color:#e6db74">&amp;#39;00123&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">在满足要求的情况下，越小越好。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">表示&lt;/span>bool值真&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">表示&lt;/span>bool值假&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>MySQL没有布尔类型&lt;span style="color:#960050;background-color:#1e0010">，通过整型&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">和&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">表示。常用&lt;/span>tinyint(&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">表示布尔型。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- b. 浮点型 ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">类型&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">范围&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> float(&lt;span style="color:#960050;background-color:#1e0010">单精度&lt;/span>) &lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> double(&lt;span style="color:#960050;background-color:#1e0010">双精度&lt;/span>) &lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">浮点型既支持符号位&lt;/span> unsigned &lt;span style="color:#960050;background-color:#1e0010">属性，也支持显示宽度&lt;/span> zerofill &lt;span style="color:#960050;background-color:#1e0010">属性。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">不同于整型，前后均会补填&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">定义浮点型时，需指定总位数和小数位数。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> float(M, D) double(M, D)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> M表示总位数&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>D表示小数位数&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> M和D的大小会决定浮点数的范围&lt;span style="color:#960050;background-color:#1e0010">。不同于整型的固定范围。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> M既表示总位数&lt;span style="color:#960050;background-color:#1e0010">（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">支持科学计数法表示。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">浮点数表示近似值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- c. 定点数 ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> decimal &lt;span style="color:#75715e">-- 可变长度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> decimal(M, D) M也表示总位数&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>D表示小数位数&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">将浮点数转换为字符串来保存，每&lt;/span>&lt;span style="color:#ae81ff">9&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">位数字保存为&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">个字节。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">字符串类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- a. char, varchar ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> char &lt;span style="color:#960050;background-color:#1e0010">定长字符串，速度快，但浪费空间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> varchar &lt;span style="color:#960050;background-color:#1e0010">变长字符串，速度慢，但节省空间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> M表示能存储的最大长度&lt;span style="color:#960050;background-color:#1e0010">，此长度是字符数，非字节数。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">不同的编码，所占用的空间不同。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> char,&lt;span style="color:#960050;background-color:#1e0010">最多&lt;/span>&lt;span style="color:#ae81ff">255&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">个字符，与编码无关。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> varchar,&lt;span style="color:#960050;background-color:#1e0010">最多&lt;/span>&lt;span style="color:#ae81ff">65535&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字符，与编码有关。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">一条有效记录最大不能超过&lt;/span>&lt;span style="color:#ae81ff">65535&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">个字节。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> utf8 &lt;span style="color:#960050;background-color:#1e0010">最大为&lt;/span>&lt;span style="color:#ae81ff">21844&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">个字符，&lt;/span>gbk &lt;span style="color:#960050;background-color:#1e0010">最大为&lt;/span>&lt;span style="color:#ae81ff">32766&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">个字符，&lt;/span>latin1 &lt;span style="color:#960050;background-color:#1e0010">最大为&lt;/span>&lt;span style="color:#ae81ff">65532&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">个字符&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> varchar &lt;span style="color:#960050;background-color:#1e0010">是变长的，需要利用存储空间保存&lt;/span> varchar &lt;span style="color:#960050;background-color:#1e0010">的长度，如果数据小于&lt;/span>&lt;span style="color:#ae81ff">255&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">个字节，则采用一个字节来保存长度，反之需要两个字节来保存。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> varchar &lt;span style="color:#960050;background-color:#1e0010">的最大有效长度由最大行大小和使用的字符集确定。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">最大有效长度是&lt;/span>&lt;span style="color:#ae81ff">65532&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节，因为在&lt;/span>varchar存字符串时&lt;span style="color:#960050;background-color:#1e0010">，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是&lt;/span>&lt;span style="color:#ae81ff">65535&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">65532&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">例：若一个表定义为&lt;/span> &lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> tb(c1 int, c2 char(&lt;span style="color:#ae81ff">30&lt;/span>), c3 varchar(N)) charset&lt;span style="color:#f92672">=&lt;/span>utf8; &lt;span style="color:#960050;background-color:#1e0010">问&lt;/span>N的最大值是多少&lt;span style="color:#960050;background-color:#1e0010">？&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">答：&lt;/span>(&lt;span style="color:#ae81ff">65535&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">30&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- b. blob, text ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> blob &lt;span style="color:#960050;background-color:#1e0010">二进制字符串（字节字符串）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tinyblob, blob, mediumblob, longblob
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> text &lt;span style="color:#960050;background-color:#1e0010">非二进制字符串（字符字符串）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tinytext, text, mediumtext, longtext
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> text &lt;span style="color:#960050;background-color:#1e0010">在定义时，不需要定义长度，也不会计算总长度。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> text &lt;span style="color:#960050;background-color:#1e0010">类型在定义时，不可给&lt;/span>default值
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- c. binary, varbinary ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">类似于&lt;/span>char和varchar&lt;span style="color:#960050;background-color:#1e0010">，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> char, varchar, text &lt;span style="color:#960050;background-color:#1e0010">对应&lt;/span> binary, varbinary, blob.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">日期时间类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">一般用整型保存时间戳，因为&lt;/span>PHP可以很方便的将时间戳进行格式化&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> datetime &lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">日期及时间&lt;/span> &lt;span style="color:#ae81ff">1000&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">01&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">01&lt;/span> &lt;span style="color:#ae81ff">00&lt;/span>:&lt;span style="color:#ae81ff">00&lt;/span>:&lt;span style="color:#ae81ff">00&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">到&lt;/span> &lt;span style="color:#ae81ff">9999&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">12&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">31&lt;/span> &lt;span style="color:#ae81ff">23&lt;/span>:&lt;span style="color:#ae81ff">59&lt;/span>:&lt;span style="color:#ae81ff">59&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date &lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">日期&lt;/span> &lt;span style="color:#ae81ff">1000&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">01&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">01&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">到&lt;/span> &lt;span style="color:#ae81ff">9999&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">12&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">31&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">timestamp&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">时间戳&lt;/span> &lt;span style="color:#ae81ff">19700101000000&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">到&lt;/span> &lt;span style="color:#ae81ff">2038&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">01&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">19&lt;/span> &lt;span style="color:#ae81ff">03&lt;/span>:&lt;span style="color:#ae81ff">14&lt;/span>:&lt;span style="color:#ae81ff">07&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time &lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">时间&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">838&lt;/span>:&lt;span style="color:#ae81ff">59&lt;/span>:&lt;span style="color:#ae81ff">59&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">到&lt;/span> &lt;span style="color:#ae81ff">838&lt;/span>:&lt;span style="color:#ae81ff">59&lt;/span>:&lt;span style="color:#ae81ff">59&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">year&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">字节&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">年份&lt;/span> &lt;span style="color:#ae81ff">1901&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2155&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>datetime YYYY&lt;span style="color:#f92672">-&lt;/span>MM&lt;span style="color:#f92672">-&lt;/span>DD hh:mm:ss
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">timestamp&lt;/span> YY&lt;span style="color:#f92672">-&lt;/span>MM&lt;span style="color:#f92672">-&lt;/span>DD hh:mm:ss
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YYYYMMDDhhmmss
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YYMMDDhhmmss
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YYYYMMDDhhmmss
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YYMMDDhhmmss
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date YYYY&lt;span style="color:#f92672">-&lt;/span>MM&lt;span style="color:#f92672">-&lt;/span>DD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YY&lt;span style="color:#f92672">-&lt;/span>MM&lt;span style="color:#f92672">-&lt;/span>DD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YYYYMMDD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YYMMDD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YYYYMMDD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YYMMDD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>time hh:mm:ss
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hhmmss
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hhmmss
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">year&lt;/span> YYYY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YYYY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">枚举和集合&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 枚举(enum) ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>enum(val1, val2, val3...)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">在已知的值中进行单选。最大数量为&lt;/span>&lt;span style="color:#ae81ff">65535&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">枚举值在保存时，以&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">个字节的整型&lt;/span>(smallint)&lt;span style="color:#960050;background-color:#1e0010">保存。每个枚举值，按保存的位置顺序，从&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">开始逐一递增。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">表现为字符串类型，存储却是整型。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NULL值的索引是NULL&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">空字符串错误值的索引值是&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 集合（set） ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">set&lt;/span>(val1, val2, val3...)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">create&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span> tab ( gender &lt;span style="color:#66d9ef">set&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;男&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;女&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;无&amp;#39;&lt;/span>) );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">insert&lt;/span> &lt;span style="color:#66d9ef">into&lt;/span> tab &lt;span style="color:#66d9ef">values&lt;/span> (&lt;span style="color:#e6db74">&amp;#39;男, 女&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">最多可以有&lt;/span>&lt;span style="color:#ae81ff">64&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">个不同的成员。以&lt;/span>bigint存储&lt;span style="color:#960050;background-color:#1e0010">，共&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">个字节。采取位运算的形式。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">当创建表时，&lt;/span>SET成员值的尾部空格将自动被删除&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="列属性列约束">
 列属性(列约束)
 &lt;a class="anchor" href="#%e5%88%97%e5%b1%9e%e6%80%a7%e5%88%97%e7%ba%a6%e6%9d%9f">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 列属性（列约束） */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>. &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">主键&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">能唯一标识记录的字段，可以作为主键。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">一个表只能有一个主键。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">主键具有唯一性。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">声明字段时，用&lt;/span> &lt;span style="color:#66d9ef">primary&lt;/span> &lt;span style="color:#66d9ef">key&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">标识。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">也可以在字段列表之后声明&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">例：&lt;/span>&lt;span style="color:#66d9ef">create&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span> tab ( id int, stu varchar(&lt;span style="color:#ae81ff">10&lt;/span>), &lt;span style="color:#66d9ef">primary&lt;/span> &lt;span style="color:#66d9ef">key&lt;/span> (id));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">主键字段的值不能为&lt;/span>&lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">例：&lt;/span>&lt;span style="color:#66d9ef">create&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span> tab ( id int, stu varchar(&lt;span style="color:#ae81ff">10&lt;/span>), age int, &lt;span style="color:#66d9ef">primary&lt;/span> &lt;span style="color:#66d9ef">key&lt;/span> (stu, age));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span>. &lt;span style="color:#66d9ef">UNIQUE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">唯一索引（唯一约束）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">使得某字段的值也不能重复。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span>. &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">约束&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> null不是数据类型&lt;span style="color:#960050;background-color:#1e0010">，是列的一个属性。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">表示当前列是否可以为&lt;/span>&lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，表示什么都没有。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#960050;background-color:#1e0010">允许为空。默认。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">not&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#960050;background-color:#1e0010">不允许为空。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">insert&lt;/span> &lt;span style="color:#66d9ef">into&lt;/span> tab &lt;span style="color:#66d9ef">values&lt;/span> (&lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;val&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>. &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">默认值属性&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">当前字段的默认值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">insert&lt;/span> &lt;span style="color:#66d9ef">into&lt;/span> tab &lt;span style="color:#66d9ef">values&lt;/span> (&lt;span style="color:#66d9ef">default&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;val&amp;#39;&lt;/span>); &lt;span style="color:#75715e">-- 此时表示强制使用默认值。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">create&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span> tab ( add_time &lt;span style="color:#66d9ef">timestamp&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#66d9ef">current_timestamp&lt;/span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 表示将当前时间的时间戳设为默认值。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">current_date&lt;/span>, &lt;span style="color:#66d9ef">current_time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">5&lt;/span>. AUTO_INCREMENT &lt;span style="color:#960050;background-color:#1e0010">自动增长约束&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">自动增长必须为索引（主键或&lt;/span>&lt;span style="color:#66d9ef">unique&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">只能存在一个字段为自动增长。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">默认为&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">开始自动增长。可以通过表属性&lt;/span> auto_increment &lt;span style="color:#f92672">=&lt;/span> x进行设置&lt;span style="color:#960050;background-color:#1e0010">，或&lt;/span> &lt;span style="color:#66d9ef">alter&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span> tbl auto_increment &lt;span style="color:#f92672">=&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">6&lt;/span>. &lt;span style="color:#66d9ef">COMMENT&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">注释&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">例：&lt;/span>&lt;span style="color:#66d9ef">create&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span> tab ( id int ) &lt;span style="color:#66d9ef">comment&lt;/span> &lt;span style="color:#e6db74">&amp;#39;注释内容&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">7&lt;/span>. &lt;span style="color:#66d9ef">FOREIGN&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">外键约束&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">用于限制主表与从表数据完整性。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">alter&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span> t1 &lt;span style="color:#66d9ef">add&lt;/span> &lt;span style="color:#66d9ef">constraint&lt;/span> &lt;span style="color:#f92672">`&lt;/span>t1_t2_fk&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">foreign&lt;/span> &lt;span style="color:#66d9ef">key&lt;/span> (t1_id) &lt;span style="color:#66d9ef">references&lt;/span> t2(id);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 将表t1的t1_id外键关联到表t2的id字段。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- 每个外键都有一个名字，可以通过 constraint 指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MySQL中&lt;span style="color:#960050;background-color:#1e0010">，可以对&lt;/span>InnoDB引擎使用外键约束&lt;span style="color:#960050;background-color:#1e0010">：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">语法：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">foreign&lt;/span> &lt;span style="color:#66d9ef">key&lt;/span> (&lt;span style="color:#960050;background-color:#1e0010">外键字段）&lt;/span> &lt;span style="color:#66d9ef">references&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">主表名&lt;/span> (&lt;span style="color:#960050;background-color:#1e0010">关联字段&lt;/span>) [&lt;span style="color:#960050;background-color:#1e0010">主表记录删除时的动作&lt;/span>] [&lt;span style="color:#960050;background-color:#1e0010">主表记录更新时的动作&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为&lt;/span>&lt;span style="color:#66d9ef">null&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">前提是该外键列，没有&lt;/span>&lt;span style="color:#66d9ef">not&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">如果指定了&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span> &lt;span style="color:#66d9ef">update&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">或&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">：在删除或更新时，有如下几个操作可以选择：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span>. &lt;span style="color:#66d9ef">cascade&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span>. &lt;span style="color:#66d9ef">set&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，设置为&lt;/span>&lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">。主表数据被更新（主键值更新），从表的外键被设置为&lt;/span>&lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">。主表记录被删除，从表相关记录外键被设置成&lt;/span>&lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">。但注意，要求该外键列，没有&lt;/span>&lt;span style="color:#66d9ef">not&lt;/span> null属性约束&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">3&lt;/span>. &lt;span style="color:#66d9ef">restrict&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，拒绝父表删除和更新。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">注意，外键只被&lt;/span>InnoDB存储引擎所支持&lt;span style="color:#960050;background-color:#1e0010">。其他引擎是不支持的。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="建表规范">
 建表规范
 &lt;a class="anchor" href="#%e5%bb%ba%e8%a1%a8%e8%a7%84%e8%8c%83">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 建表规范 */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- Normal Format, NF
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">每个表保存一个实体信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">每个具有一个&lt;/span>ID字段作为主键
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> ID主键 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">原子表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 1NF, 第一范式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">字段不能再分，就满足第一范式。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 2NF, 第二范式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">满足第一范式的前提下，不能出现部分依赖。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">消除复合主键就可以避免部分依赖。增加单列关键字。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 3NF, 第三范式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">满足第二范式的前提下，不能出现传递依赖。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">将一个实体信息的数据放在一个表内实现。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="select">
 SELECT
 &lt;a class="anchor" href="#select">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* SELECT */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">SELECT&lt;/span> [&lt;span style="color:#66d9ef">ALL&lt;/span>&lt;span style="color:#f92672">|&lt;/span>&lt;span style="color:#66d9ef">DISTINCT&lt;/span>] select_expr &lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">WHERE&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">GROUP&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">合计函数&lt;/span>] &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">HAVING&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">ORDER&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">LIMIT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a. select_expr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 可以用 * 表示所有字段。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> tb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 可以使用表达式（计算公式、函数调用、字段也是个表达式）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">select&lt;/span> stu, &lt;span style="color:#ae81ff">29&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">25&lt;/span>, now() &lt;span style="color:#66d9ef">from&lt;/span> tb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">使用&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">关键字，也可省略&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">select&lt;/span> stu&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#66d9ef">as&lt;/span> add10 &lt;span style="color:#66d9ef">from&lt;/span> tb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b. &lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">子句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">用于标识查询来源。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 可以为表起别名。使用as关键字。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> tb1 &lt;span style="color:#66d9ef">AS&lt;/span> tt, tb2 &lt;span style="color:#66d9ef">AS&lt;/span> bb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- from子句后，可以同时出现多个表。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> tb1, tb2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 向优化符提示如何选择索引
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> USE &lt;span style="color:#66d9ef">INDEX&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">、&lt;/span>&lt;span style="color:#66d9ef">IGNORE&lt;/span> &lt;span style="color:#66d9ef">INDEX&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">、&lt;/span>&lt;span style="color:#66d9ef">FORCE&lt;/span> &lt;span style="color:#66d9ef">INDEX&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> table1 USE &lt;span style="color:#66d9ef">INDEX&lt;/span> (key1,key2) &lt;span style="color:#66d9ef">WHERE&lt;/span> key1&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">AND&lt;/span> key2&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#66d9ef">AND&lt;/span> key3&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> table1 &lt;span style="color:#66d9ef">IGNORE&lt;/span> &lt;span style="color:#66d9ef">INDEX&lt;/span> (key3) &lt;span style="color:#66d9ef">WHERE&lt;/span> key1&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">AND&lt;/span> key2&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#66d9ef">AND&lt;/span> key3&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">c&lt;/span>. &lt;span style="color:#66d9ef">WHERE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">子句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 从from获得的数据源中进行筛选。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- 整型1表示真，0表示假。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- 表达式由运算符和运算数组成。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- 运算数：变量（字段）、值、函数返回值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">-- 运算符：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">=&lt;/span>, &lt;span style="color:#f92672">&amp;lt;=&amp;gt;&lt;/span>, &lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>, &lt;span style="color:#f92672">!=&lt;/span>, &lt;span style="color:#f92672">&amp;lt;=&lt;/span>, &lt;span style="color:#f92672">&amp;lt;&lt;/span>, &lt;span style="color:#f92672">&amp;gt;=&lt;/span>, &lt;span style="color:#f92672">&amp;gt;&lt;/span>, &lt;span style="color:#f92672">!&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>, &lt;span style="color:#f92672">||&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">in&lt;/span> (&lt;span style="color:#66d9ef">not&lt;/span>) &lt;span style="color:#66d9ef">null&lt;/span>, (&lt;span style="color:#66d9ef">not&lt;/span>) &lt;span style="color:#66d9ef">like&lt;/span>, (&lt;span style="color:#66d9ef">not&lt;/span>) &lt;span style="color:#66d9ef">in&lt;/span>, (&lt;span style="color:#66d9ef">not&lt;/span>) &lt;span style="color:#66d9ef">between&lt;/span> &lt;span style="color:#66d9ef">and&lt;/span>, &lt;span style="color:#66d9ef">is&lt;/span> (&lt;span style="color:#66d9ef">not&lt;/span>), &lt;span style="color:#66d9ef">and&lt;/span>, &lt;span style="color:#66d9ef">or&lt;/span>, &lt;span style="color:#66d9ef">not&lt;/span>, xor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">is&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">is&lt;/span> &lt;span style="color:#66d9ef">not&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">加上&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">unknown&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，检验某个值的真假&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;=&amp;gt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">与&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">功能相同，&lt;/span>&lt;span style="color:#f92672">&amp;lt;=&amp;gt;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">可用于&lt;/span>null比较
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>d. &lt;span style="color:#66d9ef">GROUP&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">子句&lt;/span>, &lt;span style="color:#960050;background-color:#1e0010">分组子句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">GROUP&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">字段&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">别名&lt;/span> [&lt;span style="color:#960050;background-color:#1e0010">排序方式&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">分组后会进行排序。升序：&lt;/span>&lt;span style="color:#66d9ef">ASC&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，降序：&lt;/span>&lt;span style="color:#66d9ef">DESC&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">以下&lt;/span>[&lt;span style="color:#960050;background-color:#1e0010">合计函数&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">需配合&lt;/span> &lt;span style="color:#66d9ef">GROUP&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">使用：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">count&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">返回不同的非&lt;/span>NULL值数目 &lt;span style="color:#66d9ef">count&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">、&lt;/span>&lt;span style="color:#66d9ef">count&lt;/span>(&lt;span style="color:#960050;background-color:#1e0010">字段&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">sum&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">求和&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">max&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">求最大值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">min&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">求最小值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">avg&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">求平均值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> group_concat &lt;span style="color:#960050;background-color:#1e0010">返回带有来自一个组的连接的非&lt;/span>NULL值的字符串结果&lt;span style="color:#960050;background-color:#1e0010">。组内字符串连接。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>e. &lt;span style="color:#66d9ef">HAVING&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">子句，条件子句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">与&lt;/span> &lt;span style="color:#66d9ef">where&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">功能、用法相同，执行时机不同。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">where&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">在开始时执行检测数据，对原数据进行过滤。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">having&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">对筛选出的结果再次进行过滤。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">having&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">字段必须是查询出来的，&lt;/span>&lt;span style="color:#66d9ef">where&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">字段必须是数据表存在的。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">where&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">不可以使用字段的别名，&lt;/span>&lt;span style="color:#66d9ef">having&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">可以。因为执行&lt;/span>WHERE代码时&lt;span style="color:#960050;background-color:#1e0010">，可能尚未确定列值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">where&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">不可以使用合计函数。一般需用合计函数才会用&lt;/span> &lt;span style="color:#66d9ef">having&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>f. &lt;span style="color:#66d9ef">ORDER&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">子句，排序子句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">order&lt;/span> &lt;span style="color:#66d9ef">by&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">排序字段&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">别名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">排序方式&lt;/span> [,&lt;span style="color:#960050;background-color:#1e0010">排序字段&lt;/span>&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">别名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">排序方式&lt;/span>]...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">升序：&lt;/span>&lt;span style="color:#66d9ef">ASC&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，降序：&lt;/span>&lt;span style="color:#66d9ef">DESC&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">支持多个字段的排序。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">g&lt;/span>. &lt;span style="color:#66d9ef">LIMIT&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">子句，限制结果数量子句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">开始。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">limit&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">起始位置&lt;/span>, &lt;span style="color:#960050;background-color:#1e0010">获取条数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">省略第一个参数，表示从索引&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">开始。&lt;/span>&lt;span style="color:#66d9ef">limit&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">获取条数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>h. &lt;span style="color:#66d9ef">DISTINCT&lt;/span>, &lt;span style="color:#66d9ef">ALL&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">选项&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">distinct&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">去除重复记录&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">默认为&lt;/span> &lt;span style="color:#66d9ef">all&lt;/span>, &lt;span style="color:#960050;background-color:#1e0010">全部记录&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="union">
 UNION
 &lt;a class="anchor" href="#union">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* UNION */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">将多个&lt;/span>select查询的结果组合成一个结果集合&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SELECT&lt;/span> ... &lt;span style="color:#66d9ef">UNION&lt;/span> [&lt;span style="color:#66d9ef">ALL&lt;/span>&lt;span style="color:#f92672">|&lt;/span>&lt;span style="color:#66d9ef">DISTINCT&lt;/span>] &lt;span style="color:#66d9ef">SELECT&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">默认&lt;/span> &lt;span style="color:#66d9ef">DISTINCT&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">方式，即所有返回的行都是唯一的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">建议，对每个&lt;/span>SELECT查询加上小括号包裹&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">ORDER&lt;/span> &lt;span style="color:#66d9ef">BY&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">排序时，需加上&lt;/span> &lt;span style="color:#66d9ef">LIMIT&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">进行结合。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">需要各&lt;/span>select查询的字段数量一样&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">每个&lt;/span>select查询的字段列表(&lt;span style="color:#960050;background-color:#1e0010">数量、类型&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">应一致，因为结果中的字段名以第一条&lt;/span>select语句为准&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="子查询">
 子查询
 &lt;a class="anchor" href="#%e5%ad%90%e6%9f%a5%e8%af%a2">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 子查询 */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">子查询需用括号包裹。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- from型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> from后要求是一个表&lt;span style="color:#960050;background-color:#1e0010">，必须给子查询结果取个别名。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">简化每个查询内的条件。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> from型需将结果生成一个临时表格&lt;span style="color:#960050;background-color:#1e0010">，可用以原表的锁定的释放。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">子查询返回一个表，表型子查询。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> (&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> tb &lt;span style="color:#66d9ef">where&lt;/span> id&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> subfrom &lt;span style="color:#66d9ef">where&lt;/span> id&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- where型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">子查询返回一个值，标量子查询。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">不需要给子查询取别名。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> where子查询内的表&lt;span style="color:#960050;background-color:#1e0010">，不能直接用以更新。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> tb &lt;span style="color:#66d9ef">where&lt;/span> money &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#66d9ef">max&lt;/span>(money) &lt;span style="color:#66d9ef">from&lt;/span> tb);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 列子查询
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">如果子查询结果返回的是一列。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">使用&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">或&lt;/span> &lt;span style="color:#66d9ef">not&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">完成查询&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">exists&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">和&lt;/span> &lt;span style="color:#66d9ef">not&lt;/span> &lt;span style="color:#66d9ef">exists&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">条件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">如果子查询返回数据，则返回&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">或&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">。常用于判断条件。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">select&lt;/span> column1 &lt;span style="color:#66d9ef">from&lt;/span> t1 &lt;span style="color:#66d9ef">where&lt;/span> &lt;span style="color:#66d9ef">exists&lt;/span> (&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> t2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 行子查询
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">查询条件是一个行。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> t1 &lt;span style="color:#66d9ef">where&lt;/span> (id, gender) &lt;span style="color:#66d9ef">in&lt;/span> (&lt;span style="color:#66d9ef">select&lt;/span> id, gender &lt;span style="color:#66d9ef">from&lt;/span> t2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">行构造符：&lt;/span>(col1, col2, ...) &lt;span style="color:#960050;background-color:#1e0010">或&lt;/span> &lt;span style="color:#66d9ef">ROW&lt;/span>(col1, col2, ...)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 特殊运算符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">all&lt;/span>() &lt;span style="color:#960050;background-color:#1e0010">相当于&lt;/span> &lt;span style="color:#66d9ef">not&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">some&lt;/span>() &lt;span style="color:#960050;background-color:#1e0010">相当于&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>&lt;span style="color:#66d9ef">any&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">是&lt;/span> &lt;span style="color:#66d9ef">some&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">的别名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">some&lt;/span>() &lt;span style="color:#960050;background-color:#1e0010">不等同于&lt;/span> &lt;span style="color:#66d9ef">not&lt;/span> &lt;span style="color:#66d9ef">in&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，不等于其中某一个。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">all&lt;/span>, &lt;span style="color:#66d9ef">some&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">可以配合其他运算符一起使用。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="连接查询join">
 连接查询(join)
 &lt;a class="anchor" href="#%e8%bf%9e%e6%8e%a5%e6%9f%a5%e8%af%a2join">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 连接查询(join) */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">将多个表的字段进行连接，可以指定连接条件。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 内连接(inner join)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">默认就是内连接，可省略&lt;/span>&lt;span style="color:#66d9ef">inner&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">只有数据存在时才能发送连接。即连接结果不能出现空行。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">on&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表示连接条件。其条件表达式与&lt;/span>where类似&lt;span style="color:#960050;background-color:#1e0010">。也可以省略条件（表示条件永远为真）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">也可用&lt;/span>where表示连接条件&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">还有&lt;/span> &lt;span style="color:#66d9ef">using&lt;/span>, &lt;span style="color:#960050;background-color:#1e0010">但需字段名相同。&lt;/span> &lt;span style="color:#66d9ef">using&lt;/span>(&lt;span style="color:#960050;background-color:#1e0010">字段名&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 交叉连接 cross join
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">即，没有条件的内连接。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> tb1 &lt;span style="color:#66d9ef">cross&lt;/span> &lt;span style="color:#66d9ef">join&lt;/span> tb2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 外连接(outer join)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">如果数据不存在，也会出现在连接结果中。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 左外连接 left join
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">如果数据不存在，左表记录会出现，而右表为&lt;/span>null填充
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 右外连接 right join
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">如果数据不存在，右表记录会出现，而左表为&lt;/span>null填充
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 自然连接(natural join)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">自动判断连接条件完成连接。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">相当于省略了&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，会自动查找相同字段名。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">natural&lt;/span> &lt;span style="color:#66d9ef">join&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">natural&lt;/span> &lt;span style="color:#66d9ef">left&lt;/span> &lt;span style="color:#66d9ef">join&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">natural&lt;/span> &lt;span style="color:#66d9ef">right&lt;/span> &lt;span style="color:#66d9ef">join&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex &lt;span style="color:#66d9ef">from&lt;/span> info, extra_info &lt;span style="color:#66d9ef">where&lt;/span> info.stu_num &lt;span style="color:#f92672">=&lt;/span> extra_info.stu_id;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="truncate">
 TRUNCATE
 &lt;a class="anchor" href="#truncate">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* TRUNCATE */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">TRUNCATE&lt;/span> [&lt;span style="color:#66d9ef">TABLE&lt;/span>] tbl_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">清空数据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">删除重建表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">区别：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#66d9ef">truncate&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">是删除表再创建，&lt;/span>&lt;span style="color:#66d9ef">delete&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">是逐条删除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#66d9ef">truncate&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">重置&lt;/span>auto_increment的值&lt;span style="color:#960050;background-color:#1e0010">。而&lt;/span>delete不会
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>&lt;span style="color:#66d9ef">truncate&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">不知道删除了几条，而&lt;/span>delete知道&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，当被用于带分区的表时，&lt;/span>&lt;span style="color:#66d9ef">truncate&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">会保留分区&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="备份与还原">
 备份与还原
 &lt;a class="anchor" href="#%e5%a4%87%e4%bb%bd%e4%b8%8e%e8%bf%98%e5%8e%9f">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 备份与还原 */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">备份，将数据的结构与表内数据保存起来。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">利用&lt;/span> mysqldump &lt;span style="color:#960050;background-color:#1e0010">指令完成。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 导出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>mysqldump [&lt;span style="color:#66d9ef">options&lt;/span>] db_name [tables]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mysqldump [&lt;span style="color:#66d9ef">options&lt;/span>] &lt;span style="color:#75715e">---database DB1 [DB2 DB3...]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>mysqldump [&lt;span style="color:#66d9ef">options&lt;/span>] &lt;span style="color:#75715e">--all--database
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">导出一张表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　mysqldump &lt;span style="color:#f92672">-&lt;/span>u用户名 &lt;span style="color:#f92672">-&lt;/span>p密码 &lt;span style="color:#960050;background-color:#1e0010">库名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">文件名&lt;/span>(D:&lt;span style="color:#f92672">/&lt;/span>a.&lt;span style="color:#66d9ef">sql&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">导出多张表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　mysqldump &lt;span style="color:#f92672">-&lt;/span>u用户名 &lt;span style="color:#f92672">-&lt;/span>p密码 &lt;span style="color:#960050;background-color:#1e0010">库名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">文件名&lt;/span>(D:&lt;span style="color:#f92672">/&lt;/span>a.&lt;span style="color:#66d9ef">sql&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">导出所有表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　mysqldump &lt;span style="color:#f92672">-&lt;/span>u用户名 &lt;span style="color:#f92672">-&lt;/span>p密码 &lt;span style="color:#960050;background-color:#1e0010">库名&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">文件名&lt;/span>(D:&lt;span style="color:#f92672">/&lt;/span>a.&lt;span style="color:#66d9ef">sql&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">导出一个库&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　mysqldump &lt;span style="color:#f92672">-&lt;/span>u用户名 &lt;span style="color:#f92672">-&lt;/span>p密码 &lt;span style="color:#75715e">--lock-all-tables --database 库名 &amp;gt; 文件名(D:/a.sql)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">可以&lt;/span>&lt;span style="color:#f92672">-&lt;/span>w携带WHERE条件
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 导入
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">在登录&lt;/span>mysql的情况下&lt;span style="color:#960050;background-color:#1e0010">：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　&lt;span style="color:#66d9ef">source&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">备份文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">在不登录的情况下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>　　mysql &lt;span style="color:#f92672">-&lt;/span>u用户名 &lt;span style="color:#f92672">-&lt;/span>p密码 &lt;span style="color:#960050;background-color:#1e0010">库名&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">备份文件&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="视图">
 视图
 &lt;a class="anchor" href="#%e8%a7%86%e5%9b%be">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">什么是视图：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">视图具有表结构文件，但不存在数据文件。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">视图是存储在数据库中的查询的&lt;/span>sql语句&lt;span style="color:#960050;background-color:#1e0010">，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 创建视图
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CREATE&lt;/span> [&lt;span style="color:#66d9ef">OR&lt;/span> &lt;span style="color:#66d9ef">REPLACE&lt;/span>] [ALGORITHM &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>UNDEFINED &lt;span style="color:#f92672">|&lt;/span> MERGE &lt;span style="color:#f92672">|&lt;/span> TEMPTABLE&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>] &lt;span style="color:#66d9ef">VIEW&lt;/span> view_name [(column_list)] &lt;span style="color:#66d9ef">AS&lt;/span> select_statement
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">视图名必须唯一，同时不能与表重名。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">视图可以使用&lt;/span>select语句查询到的列名&lt;span style="color:#960050;background-color:#1e0010">，也可以自己指定相应的列名。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">可以指定视图执行的算法，通过&lt;/span>ALGORITHM指定&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> column_list如果存在&lt;span style="color:#960050;background-color:#1e0010">，则数目必须等于&lt;/span>SELECT语句检索的列数
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 查看结构
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SHOW&lt;/span> &lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">VIEW&lt;/span> view_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 删除视图
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">删除视图后，数据依然存在。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">可同时删除多个视图。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">VIEW&lt;/span> [&lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span>] view_name ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 修改视图结构
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">一般不修改视图，因为不是所有的更新视图都会映射到表上。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">ALTER&lt;/span> &lt;span style="color:#66d9ef">VIEW&lt;/span> view_name [(column_list)] &lt;span style="color:#66d9ef">AS&lt;/span> select_statement
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 视图作用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">简化业务逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">对客户端隐藏真实的表结构&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 视图算法(ALGORITHM)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> MERGE &lt;span style="color:#960050;background-color:#1e0010">合并&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">将视图的查询语句，与外部查询需要先合并再执行！&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TEMPTABLE &lt;span style="color:#960050;background-color:#1e0010">临时表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">将视图执行完毕后，形成临时表，再做外层查询！&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UNDEFINED &lt;span style="color:#960050;background-color:#1e0010">未定义&lt;/span>(&lt;span style="color:#960050;background-color:#1e0010">默认&lt;/span>)&lt;span style="color:#960050;background-color:#1e0010">，指的是&lt;/span>MySQL自主去选择相应的算法&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="事务transaction">
 事务(transaction)
 &lt;a class="anchor" href="#%e4%ba%8b%e5%8a%a1transaction">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">支持连续&lt;/span>SQL的集体成功或集体撤销&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">事务是数据库在数据完整性方面的一个功能。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">需要利用&lt;/span> InnoDB &lt;span style="color:#960050;background-color:#1e0010">或&lt;/span> BDB &lt;span style="color:#960050;background-color:#1e0010">存储引擎，对自动提交的特性支持完成。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> InnoDB被称为事务安全型引擎&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 事务开启
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">START&lt;/span> &lt;span style="color:#66d9ef">TRANSACTION&lt;/span>; &lt;span style="color:#960050;background-color:#1e0010">或者&lt;/span> &lt;span style="color:#66d9ef">BEGIN&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">开启事务后，所有被执行的&lt;/span>SQL语句均被认作当前事务内的SQL语句&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 事务提交
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">COMMIT&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 事务回滚
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">ROLLBACK&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">如果部分操作发生问题，映射到事务开启前。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 事务的特性
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">原子性（&lt;/span>Atomicity&lt;span style="color:#960050;background-color:#1e0010">）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">一致性（&lt;/span>Consistency&lt;span style="color:#960050;background-color:#1e0010">）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">事务前后数据的完整性必须保持一致。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">事务开始和结束时，外部数据一致&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">在整个事务过程中，操作是连续的&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">3&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">隔离性（&lt;/span>&lt;span style="color:#66d9ef">Isolation&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间的数据要相互隔离。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">持久性（&lt;/span>Durability&lt;span style="color:#960050;background-color:#1e0010">）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">一个事务一旦被提交，它对数据库中的数据改变就是永久性的。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 事务的实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">要求是事务支持的表类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">执行一组相关的操作前开启事务&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">3&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 事务的原理
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">利用&lt;/span>InnoDB的自动提交(autocommit)&lt;span style="color:#960050;background-color:#1e0010">特性完成。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">普通的&lt;/span>MySQL执行语句后&lt;span style="color:#960050;background-color:#1e0010">，当前的数据提交操作均可被其他客户端可见。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">而事务是暂时关闭“自动提交”机制，需要&lt;/span>commit提交持久化数据操作&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 注意
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">数据定义语言（&lt;/span>DDL&lt;span style="color:#960050;background-color:#1e0010">）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">事务不能被嵌套&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 保存点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> SAVEPOINT &lt;span style="color:#960050;background-color:#1e0010">保存点名称&lt;/span> &lt;span style="color:#75715e">-- 设置一个事务保存点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">ROLLBACK&lt;/span> &lt;span style="color:#66d9ef">TO&lt;/span> SAVEPOINT &lt;span style="color:#960050;background-color:#1e0010">保存点名称&lt;/span> &lt;span style="color:#75715e">-- 回滚到保存点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> RELEASE SAVEPOINT &lt;span style="color:#960050;background-color:#1e0010">保存点名称&lt;/span> &lt;span style="color:#75715e">-- 删除保存点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- InnoDB自动提交特性设置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SET&lt;/span> autocommit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">|&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">表示关闭自动提交，&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">表示开启自动提交。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">如果关闭了，那普通操作的结果对其他客户端也不可见，需要&lt;/span>commit提交后才能持久化数据操作&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">也可以关闭自动提交来开启事务。但与&lt;/span>&lt;span style="color:#66d9ef">START&lt;/span> TRANSACTION不同的是&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SET&lt;/span> autocommit是永久改变服务器的设置&lt;span style="color:#960050;background-color:#1e0010">，直到下次再次修改该设置。&lt;/span>(&lt;span style="color:#960050;background-color:#1e0010">针对当前连接&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">而&lt;/span>&lt;span style="color:#66d9ef">START&lt;/span> TRANSACTION记录开启前的状态&lt;span style="color:#960050;background-color:#1e0010">，而一旦事务提交或回滚后就需要再次开启事务。&lt;/span>(&lt;span style="color:#960050;background-color:#1e0010">针对当前事务&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="锁表">
 锁表
 &lt;a class="anchor" href="#%e9%94%81%e8%a1%a8">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 锁表 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">表锁定只用于防止其它客户端进行不正当地读取和写入&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MyISAM &lt;span style="color:#960050;background-color:#1e0010">支持表锁，&lt;/span>InnoDB &lt;span style="color:#960050;background-color:#1e0010">支持行锁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 锁定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">LOCK&lt;/span> TABLES tbl_name [&lt;span style="color:#66d9ef">AS&lt;/span> &lt;span style="color:#66d9ef">alias&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 解锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> UNLOCK TABLES
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="触发器">
 触发器
 &lt;a class="anchor" href="#%e8%a7%a6%e5%8f%91%e5%99%a8">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 触发器 */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">监听：记录的增加、修改、删除。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 创建触发器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TRIGGER&lt;/span> &lt;span style="color:#66d9ef">trigger_name&lt;/span> trigger_time trigger_event &lt;span style="color:#66d9ef">ON&lt;/span> tbl_name &lt;span style="color:#66d9ef">FOR&lt;/span> &lt;span style="color:#66d9ef">EACH&lt;/span> &lt;span style="color:#66d9ef">ROW&lt;/span> trigger_stmt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">参数：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trigger_time是触发程序的动作时间&lt;span style="color:#960050;background-color:#1e0010">。它可以是&lt;/span> &lt;span style="color:#66d9ef">before&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">或&lt;/span> &lt;span style="color:#66d9ef">after&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，以指明触发程序是在激活它的语句之前或之后触发。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trigger_event指明了激活触发程序的语句的类型
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">INSERT&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">：将新行插入表时激活触发程序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">UPDATE&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">：更改某一行时激活触发程序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">DELETE&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">：从表中删除某一行时激活触发程序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tbl_name&lt;span style="color:#960050;background-color:#1e0010">：监听的表，必须是永久性的表，不能将触发程序与&lt;/span>TEMPORARY表或视图关联起来&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trigger_stmt&lt;span style="color:#960050;background-color:#1e0010">：当触发程序激活时执行的语句。执行多个语句，可使用&lt;/span>&lt;span style="color:#66d9ef">BEGIN&lt;/span>...END复合语句结构
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 删除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">TRIGGER&lt;/span> [&lt;span style="color:#66d9ef">schema_name&lt;/span>.]&lt;span style="color:#66d9ef">trigger_name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">可以使用&lt;/span>old和new代替旧的和新的数据
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">更新操作，更新前是&lt;/span>&lt;span style="color:#66d9ef">old&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，更新后是&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">删除操作，只有&lt;/span>&lt;span style="color:#66d9ef">old&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">增加操作，只有&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 注意
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 字符连接函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>concat(str1,str2,...])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>concat_ws(separator,str1,str2,...)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 分支语句
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">条件&lt;/span> &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">执行语句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>elseif &lt;span style="color:#960050;background-color:#1e0010">条件&lt;/span> &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">执行语句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">执行语句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">end&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 修改最外层语句结束符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">delimiter&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">自定义结束符号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SQL语句
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">自定义结束符号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">delimiter&lt;/span> ; &lt;span style="color:#75715e">-- 修改回原来的分号
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 语句块包裹
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">语句块&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 特殊的执行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">只要添加记录，就会触发程序。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span>. &lt;span style="color:#66d9ef">Insert&lt;/span> &lt;span style="color:#66d9ef">into&lt;/span> &lt;span style="color:#66d9ef">on&lt;/span> duplicate &lt;span style="color:#66d9ef">key&lt;/span> &lt;span style="color:#66d9ef">update&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">语法会触发：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">如果没有重复记录，会触发&lt;/span> &lt;span style="color:#66d9ef">before&lt;/span> &lt;span style="color:#66d9ef">insert&lt;/span>, &lt;span style="color:#66d9ef">after&lt;/span> &lt;span style="color:#66d9ef">insert&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">如果有重复记录并更新，会触发&lt;/span> &lt;span style="color:#66d9ef">before&lt;/span> &lt;span style="color:#66d9ef">insert&lt;/span>, &lt;span style="color:#66d9ef">before&lt;/span> &lt;span style="color:#66d9ef">update&lt;/span>, &lt;span style="color:#66d9ef">after&lt;/span> &lt;span style="color:#66d9ef">update&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">如果有重复记录但是没有发生更新，则触发&lt;/span> &lt;span style="color:#66d9ef">before&lt;/span> &lt;span style="color:#66d9ef">insert&lt;/span>, &lt;span style="color:#66d9ef">before&lt;/span> &lt;span style="color:#66d9ef">update&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span>. &lt;span style="color:#66d9ef">Replace&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">语法&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">如果有记录，则执行&lt;/span> &lt;span style="color:#66d9ef">before&lt;/span> &lt;span style="color:#66d9ef">insert&lt;/span>, &lt;span style="color:#66d9ef">before&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>, &lt;span style="color:#66d9ef">after&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span>, &lt;span style="color:#66d9ef">after&lt;/span> &lt;span style="color:#66d9ef">insert&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="sql-编程">
 SQL 编程
 &lt;a class="anchor" href="#sql-%e7%bc%96%e7%a8%8b">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* SQL编程 */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">--// 局部变量 ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 变量声明
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">declare&lt;/span> var_name[,...] &lt;span style="color:#66d9ef">type&lt;/span> [&lt;span style="color:#66d9ef">default&lt;/span> value]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个&lt;/span>default子句&lt;span style="color:#960050;background-color:#1e0010">。值可以被指定为一个表达式，不需要为一个常数。如果没有&lt;/span>default子句&lt;span style="color:#960050;background-color:#1e0010">，初始值为&lt;/span>&lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 赋值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">使用&lt;/span> &lt;span style="color:#66d9ef">set&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">和&lt;/span> &lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#66d9ef">into&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">语句为变量赋值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">注意：在函数内是可以使用全局变量（用户自定义的变量）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">--// 全局变量 ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 定义、赋值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">set&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">语句可以定义并为变量赋值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">set&lt;/span> &lt;span style="color:#f92672">@&lt;/span>var &lt;span style="color:#f92672">=&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">也可以使用&lt;/span>&lt;span style="color:#66d9ef">select&lt;/span> into语句为变量初始化并赋值&lt;span style="color:#960050;background-color:#1e0010">。这样要求&lt;/span>select语句只能返回一行&lt;span style="color:#960050;background-color:#1e0010">，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">还可以把赋值语句看作一个表达式，通过&lt;/span>select执行完成&lt;span style="color:#960050;background-color:#1e0010">。此时为了避免&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">被当作关系运算符看待，使用&lt;/span>:&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">代替。（&lt;/span>set语句可以使用&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">和&lt;/span> :&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">）。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">@&lt;/span>var:&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">20&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">@&lt;/span>v1:&lt;span style="color:#f92672">=&lt;/span>id, &lt;span style="color:#f92672">@&lt;/span>v2&lt;span style="color:#f92672">=&lt;/span>name &lt;span style="color:#66d9ef">from&lt;/span> t1 &lt;span style="color:#66d9ef">limit&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> tbl_name &lt;span style="color:#66d9ef">where&lt;/span> &lt;span style="color:#f92672">@&lt;/span>var:&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">30&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#66d9ef">into&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">可以将表中查询获得的数据赋给变量。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-|&lt;/span> &lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#66d9ef">max&lt;/span>(height) &lt;span style="color:#66d9ef">into&lt;/span> &lt;span style="color:#f92672">@&lt;/span>max_height &lt;span style="color:#66d9ef">from&lt;/span> tb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 自定义变量名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">为了避免&lt;/span>select语句中&lt;span style="color:#960050;background-color:#1e0010">，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用&lt;/span>&lt;span style="color:#f92672">@&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">作为开始符号。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">@&lt;/span>var&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">变量被定义后，在整个会话周期都有效（登录到退出）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">--// 控制结构 ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- if语句
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">if&lt;/span> search_condition &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> statement_list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[elseif search_condition &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> statement_list]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#66d9ef">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> statement_list]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">end&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- case语句
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CASE&lt;/span> value &lt;span style="color:#66d9ef">WHEN&lt;/span> [compare&lt;span style="color:#f92672">-&lt;/span>value] &lt;span style="color:#66d9ef">THEN&lt;/span> &lt;span style="color:#66d9ef">result&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#66d9ef">WHEN&lt;/span> [compare&lt;span style="color:#f92672">-&lt;/span>value] &lt;span style="color:#66d9ef">THEN&lt;/span> &lt;span style="color:#66d9ef">result&lt;/span> ...]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#66d9ef">ELSE&lt;/span> &lt;span style="color:#66d9ef">result&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">END&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- while循环
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>[begin_label:] while search_condition &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> statement_list
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">end&lt;/span> while [end_label];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">如果需要在循环内提前终止&lt;/span> while循环&lt;span style="color:#960050;background-color:#1e0010">，则需要使用标签；标签需要成对出现。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 退出循环
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">退出整个循环&lt;/span> leave
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">退出当前循环&lt;/span> &lt;span style="color:#66d9ef">iterate&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">通过退出的标签决定退出哪个循环&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">--// 内置函数 ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 数值函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">abs&lt;/span>(x) &lt;span style="color:#75715e">-- 绝对值 abs(-10.9) = 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>format(x, d) &lt;span style="color:#75715e">-- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>ceil(x) &lt;span style="color:#75715e">-- 向上取整 ceil(10.1) = 11
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>floor(x) &lt;span style="color:#75715e">-- 向下取整 floor (10.1) = 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>round(x) &lt;span style="color:#75715e">-- 四舍五入去整
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">mod&lt;/span>(m, n) &lt;span style="color:#75715e">-- m%n m mod n 求余 10%3=1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>pi() &lt;span style="color:#75715e">-- 获得圆周率
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>pow(m, n) &lt;span style="color:#75715e">-- m^n
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>sqrt(x) &lt;span style="color:#75715e">-- 算术平方根
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>rand() &lt;span style="color:#75715e">-- 随机数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">truncate&lt;/span>(x, d) &lt;span style="color:#75715e">-- 截取d位小数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 时间日期函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>now(), &lt;span style="color:#66d9ef">current_timestamp&lt;/span>(); &lt;span style="color:#75715e">-- 当前日期时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">current_date&lt;/span>(); &lt;span style="color:#75715e">-- 当前日期
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">current_time&lt;/span>(); &lt;span style="color:#75715e">-- 当前时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>date(&lt;span style="color:#e6db74">&amp;#39;yyyy-mm-dd hh:ii:ss&amp;#39;&lt;/span>); &lt;span style="color:#75715e">-- 获取日期部分
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>time(&lt;span style="color:#e6db74">&amp;#39;yyyy-mm-dd hh:ii:ss&amp;#39;&lt;/span>); &lt;span style="color:#75715e">-- 获取时间部分
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>date_format(&lt;span style="color:#e6db74">&amp;#39;yyyy-mm-dd hh:ii:ss&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;%d %y %a %d %m %b %j&amp;#39;&lt;/span>); &lt;span style="color:#75715e">-- 格式化时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>unix_timestamp(); &lt;span style="color:#75715e">-- 获得unix时间戳
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>from_unixtime(); &lt;span style="color:#75715e">-- 从时间戳获得时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 字符串函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">length&lt;/span>(string) &lt;span style="color:#75715e">-- string长度，字节
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">char_length&lt;/span>(string) &lt;span style="color:#75715e">-- string的字符个数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">substring&lt;/span>(str, &lt;span style="color:#66d9ef">position&lt;/span> [,&lt;span style="color:#66d9ef">length&lt;/span>]) &lt;span style="color:#75715e">-- 从str的position开始,取length个字符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">replace&lt;/span>(str ,search_str ,replace_str) &lt;span style="color:#75715e">-- 在str中用replace_str替换search_str
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>instr(string ,&lt;span style="color:#66d9ef">substring&lt;/span>) &lt;span style="color:#75715e">-- 返回substring首次在string中出现的位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>concat(string [,...]) &lt;span style="color:#75715e">-- 连接字串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>charset(str) &lt;span style="color:#75715e">-- 返回字串字符集
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>lcase(string) &lt;span style="color:#75715e">-- 转换成小写
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">left&lt;/span>(string, &lt;span style="color:#66d9ef">length&lt;/span>) &lt;span style="color:#75715e">-- 从string2中的左边起取length个字符
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>load_file(file_name) &lt;span style="color:#75715e">-- 从文件读取内容
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>locate(&lt;span style="color:#66d9ef">substring&lt;/span>, string [,start_position]) &lt;span style="color:#75715e">-- 同instr,但可指定开始位置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>lpad(string, &lt;span style="color:#66d9ef">length&lt;/span>, &lt;span style="color:#66d9ef">pad&lt;/span>) &lt;span style="color:#75715e">-- 重复用pad加在string开头,直到字串长度为length
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>ltrim(string) &lt;span style="color:#75715e">-- 去除前端空格
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>repeat(string, &lt;span style="color:#66d9ef">count&lt;/span>) &lt;span style="color:#75715e">-- 重复count次
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>rpad(string, &lt;span style="color:#66d9ef">length&lt;/span>, &lt;span style="color:#66d9ef">pad&lt;/span>) &lt;span style="color:#75715e">--在str后用pad补充,直到长度为length
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>rtrim(string) &lt;span style="color:#75715e">-- 去除后端空格
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>strcmp(string1 ,string2) &lt;span style="color:#75715e">-- 逐字符比较两字串大小
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 流程函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#66d9ef">when&lt;/span> [condition] &lt;span style="color:#66d9ef">then&lt;/span> &lt;span style="color:#66d9ef">result&lt;/span> [&lt;span style="color:#66d9ef">when&lt;/span> [condition] &lt;span style="color:#66d9ef">then&lt;/span> &lt;span style="color:#66d9ef">result&lt;/span> ...] [&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">result&lt;/span>] &lt;span style="color:#66d9ef">end&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">多分支&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span>(expr1,expr2,expr3) &lt;span style="color:#960050;background-color:#1e0010">双分支。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 聚合函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">count&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">sum&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">max&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">min&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">avg&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>group_concat()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 其他常用函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>md5();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">default&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">--// 存储函数，自定义函数 ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 新建
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">FUNCTION&lt;/span> function_name (&lt;span style="color:#960050;background-color:#1e0010">参数列表&lt;/span>) &lt;span style="color:#66d9ef">RETURNS&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">返回值类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">函数体&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">函数名，应该合法的标识符，并且不应该与已有的关键字冲突。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">一个函数应该属于某个数据库，可以使用&lt;/span>db_name.function_name的形式执行当前函数所属数据库&lt;span style="color:#960050;background-color:#1e0010">，否则为当前数据库。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">参数部分，由&lt;/span>&lt;span style="color:#e6db74">&amp;#34;参数名&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">和&lt;/span>&lt;span style="color:#e6db74">&amp;#34;参数类型&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">组成。多个参数用逗号隔开。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">函数体由多条可用的&lt;/span>mysql语句&lt;span style="color:#960050;background-color:#1e0010">，流程控制，变量声明等语句构成。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">多条语句应该使用&lt;/span> &lt;span style="color:#66d9ef">begin&lt;/span>...&lt;span style="color:#66d9ef">end&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">语句块包含。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">一定要有&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">返回值语句。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 删除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">FUNCTION&lt;/span> [&lt;span style="color:#66d9ef">IF&lt;/span> &lt;span style="color:#66d9ef">EXISTS&lt;/span>] function_name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 查看
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SHOW&lt;/span> &lt;span style="color:#66d9ef">FUNCTION&lt;/span> STATUS &lt;span style="color:#66d9ef">LIKE&lt;/span> &lt;span style="color:#e6db74">&amp;#39;partten&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">SHOW&lt;/span> &lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">FUNCTION&lt;/span> function_name;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 修改
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">ALTER&lt;/span> &lt;span style="color:#66d9ef">FUNCTION&lt;/span> function_name &lt;span style="color:#960050;background-color:#1e0010">函数选项&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">--// 存储过程，自定义功能 ----------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">存储存储过程&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">是一段代码（过程），存储在数据库中的&lt;/span>sql组成&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">通过&lt;/span>call执行&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 创建
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">PROCEDURE&lt;/span> sp_name (&lt;span style="color:#960050;background-color:#1e0010">参数列表&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">过程体&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">参数列表：不同于函数的参数列表，需要指明参数类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">IN&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，表示输入型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">OUT&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，表示输出型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INOUT&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">，表示混合型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">注意，没有返回值。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="存储过程">
 存储过程
 &lt;a class="anchor" href="#%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 存储过程 */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">调用：&lt;/span>&lt;span style="color:#66d9ef">CALL&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">过程名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 注意
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">没有返回值。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">只能单独调用，不可夹杂在其他语句中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 参数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">IN&lt;/span>&lt;span style="color:#f92672">|&lt;/span>&lt;span style="color:#66d9ef">OUT&lt;/span>&lt;span style="color:#f92672">|&lt;/span>&lt;span style="color:#66d9ef">INOUT&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">参数名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">数据类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">IN&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">输入：在调用过程中，将数据输入到过程体内部的参数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">OUT&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">输出：在调用过程中，将过程体处理完的结果返回到客户端&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INOUT&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">输入输出：既可输入，也可输出&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 语法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">PROCEDURE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">过程名&lt;/span> (&lt;span style="color:#960050;background-color:#1e0010">参数列表&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">BEGIN&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">过程体&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">END&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="用户和权限管理">
 用户和权限管理
 &lt;a class="anchor" href="#%e7%94%a8%e6%88%b7%e5%92%8c%e6%9d%83%e9%99%90%e7%ae%a1%e7%90%86">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 用户和权限管理 */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- root密码重置
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">停止&lt;/span>MySQL服务
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span>. [Linux] &lt;span style="color:#f92672">/&lt;/span>usr&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#66d9ef">local&lt;/span>&lt;span style="color:#f92672">/&lt;/span>mysql&lt;span style="color:#f92672">/&lt;/span>bin&lt;span style="color:#f92672">/&lt;/span>safe_mysqld &lt;span style="color:#75715e">--skip-grant-tables &amp;amp;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> [Windows] mysqld &lt;span style="color:#75715e">--skip-grant-tables
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>. use mysql;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">4&lt;/span>. &lt;span style="color:#66d9ef">UPDATE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>&lt;span style="color:#66d9ef">user&lt;/span>&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#66d9ef">SET&lt;/span> PASSWORD&lt;span style="color:#f92672">=&lt;/span>PASSWORD(&lt;span style="color:#e6db74">&amp;#34;密码&amp;#34;&lt;/span>) &lt;span style="color:#66d9ef">WHERE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>&lt;span style="color:#66d9ef">user&lt;/span>&lt;span style="color:#f92672">`&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">5&lt;/span>. FLUSH &lt;span style="color:#66d9ef">PRIVILEGES&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">用户信息表：&lt;/span>mysql.&lt;span style="color:#66d9ef">user&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 刷新权限
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>FLUSH &lt;span style="color:#66d9ef">PRIVILEGES&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 增加用户
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">USER&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">用户名&lt;/span> IDENTIFIED &lt;span style="color:#66d9ef">BY&lt;/span> [PASSWORD] &lt;span style="color:#960050;background-color:#1e0010">密码&lt;/span>(&lt;span style="color:#960050;background-color:#1e0010">字符串&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">必须拥有&lt;/span>mysql数据库的全局CREATE USER权限&lt;span style="color:#960050;background-color:#1e0010">，或拥有&lt;/span>INSERT权限&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">只能创建用户，不能赋予权限。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">用户名，注意引号：如&lt;/span> &lt;span style="color:#e6db74">&amp;#39;user_name&amp;#39;&lt;/span>&lt;span style="color:#f92672">@&lt;/span>&lt;span style="color:#e6db74">&amp;#39;192.168.1.1&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">密码也需引号，纯数字密码也要加引号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">要在纯文本中指定密码，需忽略&lt;/span>PASSWORD关键词&lt;span style="color:#960050;background-color:#1e0010">。要把密码指定为由&lt;/span>PASSWORD()&lt;span style="color:#960050;background-color:#1e0010">函数返回的混编值，需包含关键字&lt;/span>PASSWORD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 重命名用户
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">RENAME&lt;/span> &lt;span style="color:#66d9ef">USER&lt;/span> old_user &lt;span style="color:#66d9ef">TO&lt;/span> new_user
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 设置密码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">SET&lt;/span> PASSWORD &lt;span style="color:#f92672">=&lt;/span> PASSWORD(&lt;span style="color:#e6db74">&amp;#39;密码&amp;#39;&lt;/span>) &lt;span style="color:#75715e">-- 为当前用户设置密码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">SET&lt;/span> PASSWORD &lt;span style="color:#66d9ef">FOR&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">用户名&lt;/span> &lt;span style="color:#f92672">=&lt;/span> PASSWORD(&lt;span style="color:#e6db74">&amp;#39;密码&amp;#39;&lt;/span>) &lt;span style="color:#75715e">-- 为指定用户设置密码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 删除用户
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#66d9ef">USER&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">用户名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 分配权限/添加用户
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">GRANT&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">权限列表&lt;/span> &lt;span style="color:#66d9ef">ON&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#66d9ef">TO&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">用户名&lt;/span> [IDENTIFIED &lt;span style="color:#66d9ef">BY&lt;/span> [PASSWORD] &lt;span style="color:#e6db74">&amp;#39;password&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#66d9ef">all&lt;/span> &lt;span style="color:#66d9ef">privileges&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表示所有权限&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#f92672">*&lt;/span>.&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表示所有库的所有表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">库名&lt;/span>.&lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表示某库下面的某表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">GRANT&lt;/span> &lt;span style="color:#66d9ef">ALL&lt;/span> &lt;span style="color:#66d9ef">PRIVILEGES&lt;/span> &lt;span style="color:#66d9ef">ON&lt;/span> &lt;span style="color:#f92672">`&lt;/span>pms&lt;span style="color:#f92672">`&lt;/span>.&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">TO&lt;/span> &lt;span style="color:#e6db74">&amp;#39;pms&amp;#39;&lt;/span>&lt;span style="color:#f92672">@&lt;/span>&lt;span style="color:#e6db74">&amp;#39;%&amp;#39;&lt;/span> IDENTIFIED &lt;span style="color:#66d9ef">BY&lt;/span> &lt;span style="color:#e6db74">&amp;#39;pms0817&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 查看权限
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">SHOW&lt;/span> GRANTS &lt;span style="color:#66d9ef">FOR&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">用户名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">-- 查看当前用户权限
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">SHOW&lt;/span> GRANTS; &lt;span style="color:#960050;background-color:#1e0010">或&lt;/span> &lt;span style="color:#66d9ef">SHOW&lt;/span> GRANTS &lt;span style="color:#66d9ef">FOR&lt;/span> &lt;span style="color:#66d9ef">CURRENT_USER&lt;/span>; &lt;span style="color:#960050;background-color:#1e0010">或&lt;/span> &lt;span style="color:#66d9ef">SHOW&lt;/span> GRANTS &lt;span style="color:#66d9ef">FOR&lt;/span> &lt;span style="color:#66d9ef">CURRENT_USER&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 撤消权限
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">REVOKE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">权限列表&lt;/span> &lt;span style="color:#66d9ef">ON&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">用户名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">REVOKE&lt;/span> &lt;span style="color:#66d9ef">ALL&lt;/span> &lt;span style="color:#66d9ef">PRIVILEGES&lt;/span>, &lt;span style="color:#66d9ef">GRANT&lt;/span> &lt;span style="color:#66d9ef">OPTION&lt;/span> &lt;span style="color:#66d9ef">FROM&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">用户名&lt;/span> &lt;span style="color:#75715e">-- 撤销所有权限
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 权限层级
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">全局层级：全局权限适用于一个给定服务器中的所有数据库，&lt;/span>mysql.&lt;span style="color:#66d9ef">user&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">GRANT&lt;/span> &lt;span style="color:#66d9ef">ALL&lt;/span> &lt;span style="color:#66d9ef">ON&lt;/span> &lt;span style="color:#f92672">*&lt;/span>.&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">和&lt;/span> &lt;span style="color:#66d9ef">REVOKE&lt;/span> &lt;span style="color:#66d9ef">ALL&lt;/span> &lt;span style="color:#66d9ef">ON&lt;/span> &lt;span style="color:#f92672">*&lt;/span>.&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">只授予和撤销全局权限。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">数据库层级：数据库权限适用于一个给定数据库中的所有目标，&lt;/span>mysql.db, mysql.&lt;span style="color:#66d9ef">host&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">GRANT&lt;/span> &lt;span style="color:#66d9ef">ALL&lt;/span> &lt;span style="color:#66d9ef">ON&lt;/span> db_name.&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">和&lt;/span>&lt;span style="color:#66d9ef">REVOKE&lt;/span> &lt;span style="color:#66d9ef">ALL&lt;/span> &lt;span style="color:#66d9ef">ON&lt;/span> db_name.&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">只授予和撤销数据库权限。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">表层级：表权限适用于一个给定表中的所有列，&lt;/span>mysql.talbes_priv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">GRANT&lt;/span> &lt;span style="color:#66d9ef">ALL&lt;/span> &lt;span style="color:#66d9ef">ON&lt;/span> db_name.tbl_name和REVOKE &lt;span style="color:#66d9ef">ALL&lt;/span> &lt;span style="color:#66d9ef">ON&lt;/span> db_name.tbl_name只授予和撤销表权限&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">列层级：列权限适用于一个给定表中的单一列，&lt;/span>mysql.columns_priv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">当使用&lt;/span>REVOKE时&lt;span style="color:#960050;background-color:#1e0010">，您必须指定与被授权列相同的列。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 权限列表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">ALL&lt;/span> [&lt;span style="color:#66d9ef">PRIVILEGES&lt;/span>] &lt;span style="color:#75715e">-- 设置除GRANT OPTION之外的所有简单权限
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">ALTER&lt;/span> &lt;span style="color:#75715e">-- 允许使用ALTER TABLE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">ALTER&lt;/span> &lt;span style="color:#66d9ef">ROUTINE&lt;/span> &lt;span style="color:#75715e">-- 更改或取消已存储的子程序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#75715e">-- 允许使用CREATE TABLE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">ROUTINE&lt;/span> &lt;span style="color:#75715e">-- 创建已存储的子程序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TEMPORARY&lt;/span> TABLES &lt;span style="color:#75715e">-- 允许使用CREATE TEMPORARY TABLE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">USER&lt;/span> &lt;span style="color:#75715e">-- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">VIEW&lt;/span> &lt;span style="color:#75715e">-- 允许使用CREATE VIEW
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">DELETE&lt;/span> &lt;span style="color:#75715e">-- 允许使用DELETE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">DROP&lt;/span> &lt;span style="color:#75715e">-- 允许使用DROP TABLE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">EXECUTE&lt;/span> &lt;span style="color:#75715e">-- 允许用户运行已存储的子程序
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>FILE &lt;span style="color:#75715e">-- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">INDEX&lt;/span> &lt;span style="color:#75715e">-- 允许使用CREATE INDEX和DROP INDEX
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">INSERT&lt;/span> &lt;span style="color:#75715e">-- 允许使用INSERT
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">LOCK&lt;/span> TABLES &lt;span style="color:#75715e">-- 允许对您拥有SELECT权限的表使用LOCK TABLES
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>PROCESS &lt;span style="color:#75715e">-- 允许使用SHOW FULL PROCESSLIST
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">REFERENCES&lt;/span> &lt;span style="color:#75715e">-- 未被实施
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>RELOAD &lt;span style="color:#75715e">-- 允许使用FLUSH
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>REPLICATION CLIENT &lt;span style="color:#75715e">-- 允许用户询问从属服务器或主服务器的地址
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>REPLICATION SLAVE &lt;span style="color:#75715e">-- 用于复制型从属服务器（从主服务器中读取二进制日志事件）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#75715e">-- 允许使用SELECT
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">SHOW&lt;/span> DATABASES &lt;span style="color:#75715e">-- 显示所有数据库
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">SHOW&lt;/span> &lt;span style="color:#66d9ef">VIEW&lt;/span> &lt;span style="color:#75715e">-- 允许使用SHOW CREATE VIEW
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>SHUTDOWN &lt;span style="color:#75715e">-- 允许使用mysqladmin shutdown
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>SUPER &lt;span style="color:#75715e">-- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">UPDATE&lt;/span> &lt;span style="color:#75715e">-- 允许使用UPDATE
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">USAGE&lt;/span> &lt;span style="color:#75715e">-- “无权限”的同义词
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">GRANT&lt;/span> &lt;span style="color:#66d9ef">OPTION&lt;/span> &lt;span style="color:#75715e">-- 允许授予权限
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="表维护">
 表维护
 &lt;a class="anchor" href="#%e8%a1%a8%e7%bb%b4%e6%8a%a4">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 表维护 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 分析和存储表的关键字分布
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">ANALYZE&lt;/span> [&lt;span style="color:#66d9ef">LOCAL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> NO_WRITE_TO_BINLOG] &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">表名&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 检查一个或多个表是否有错误
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">CHECK&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> tbl_name [, tbl_name] ... [&lt;span style="color:#66d9ef">option&lt;/span>] ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">option&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">{&lt;/span>QUICK &lt;span style="color:#f92672">|&lt;/span> FAST &lt;span style="color:#f92672">|&lt;/span> MEDIUM &lt;span style="color:#f92672">|&lt;/span> EXTENDED &lt;span style="color:#f92672">|&lt;/span> CHANGED&lt;span style="color:#960050;background-color:#1e0010">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">-- 整理数据文件的碎片
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>OPTIMIZE [&lt;span style="color:#66d9ef">LOCAL&lt;/span> &lt;span style="color:#f92672">|&lt;/span> NO_WRITE_TO_BINLOG] &lt;span style="color:#66d9ef">TABLE&lt;/span> tbl_name [, tbl_name] ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="杂项">
 杂项
 &lt;a class="anchor" href="#%e6%9d%82%e9%a1%b9">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 杂项 */&lt;/span> &lt;span style="color:#75715e">------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">可用反引号（&lt;/span>&lt;span style="color:#f92672">`&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">每个库目录存在一个保存当前数据库的选项文件&lt;/span>db.opt&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">注释：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">单行注释&lt;/span> &lt;span style="color:#f92672">#&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">注释内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">多行注释&lt;/span> &lt;span style="color:#75715e">/* 注释内容 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">单行注释&lt;/span> &lt;span style="color:#75715e">-- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>. &lt;span style="color:#960050;background-color:#1e0010">模式通配符：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#960050;background-color:#1e0010">任意单个字符&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">任意多个字符，甚至包括零字符&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">单引号需要进行转义&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#e6db74">&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">5. CMD命令行内的语句结束符可以为 &amp;#34;;&amp;#34;, &amp;#34;\G&amp;#34;, &amp;#34;\g&amp;#34;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">6. SQL对大小写不敏感
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">7. 清除已有语句：\c
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>一位大龄程序员所经历的面试的历炼和思考</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-and-thinking-of-an-interview-experienced-by-an-older-programmer/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：本文的作者，今年 36 岁，已有 8 年 JAVA 开发经验。在阿里云三年半，有赞四年半，已是标准的大龄程序员了。在这篇文章中，作者给出了一些关于面试和个人能力提升的一些小建议，非常实用！&lt;/p>
&lt;p>&lt;strong>内容概览&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>个人介绍，是对自己的一个更为清晰、深入和全面的认识契机。&lt;/li>
&lt;li>简历是充分展示自己的浓缩精华，也是重新审视自己和过往经历的契机。不仅仅是简要介绍技能和经验，更要最大程度凸显自己的优势领域（差异化）。&lt;/li>
&lt;li>我个人是不赞成海投的，而倾向于定向投。找准方向投，虽然目标更少，但更有效率。&lt;/li>
&lt;li>技术探索，一定要先理解原理。原理不懂，就会浮于表层，不能真正掌握它。技术原理探究要掌握到什么程度？数据结构与算法设计、考量因素、技术机制、优化思路。要在脑中回放，直到一切细节而清晰可见。如果能够清晰有条理地表述出来，就更好了。技术原理探究，一定要看源码。看了源码与没看源码是有区别的。没看源码，虽然说得出来，但终是隔了一层纸；看了源码，才捅破了那层纸，有了自己的理解，也就能说得更加有底气了。当然，也可能是我缺乏演戏的本领。&lt;/li>
&lt;li>要善于从失败中学习。正是在杭州四个月空档期的持续学习、思考、积累和提炼，以及面试失败的反思、不断调整对策、完善准备、改善原有的短板，采取更为合理的方式，才在回武汉的短短两个周内拿到比较满意的 offer 。&lt;/li>
&lt;li>面试是通过沟通来理解双方的过程。面试中的问题，千变万化，但有一些问题是需要提前准备好的。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://www.cnblogs.com/lovesqcc/p/14354921.html">https://www.cnblogs.com/lovesqcc/p/14354921.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>从每一段经历中学习，在每一件事情中修行。善于从挫折中学习。&lt;/p>
&lt;h2 id="引子">
 引子
 &lt;a class="anchor" href="#%e5%bc%95%e5%ad%90">#&lt;/a>
&lt;/h2>
&lt;p>我今年 36 岁，已有 8 年 JAVA 开发经验。在阿里云三年半，有赞四年半，已是标准的大龄程序员了。&lt;/p>
&lt;p>在多年的读书、学习和思考中，我的价值观、人生观和世界观也逐步塑造成型。我意识到自己的志趣在于做教育文化方面，因此在半冲动之下，8 月份下旬，裸辞去找工作了。有限理性难以阻挡冲动的个性。不建议裸辞，做事应该有规划、科学合理。&lt;/p>
&lt;p>尽管我最初认为自己“有理想有目标有意愿有能力”，找一份教育开发的工作应该不难，但事实上我还是过于乐观了。现实很快给我泼了一瓢瓢冷水。我屡战屡败，又屡败屡战。惊讶地发现自己还有这个韧性。面试是一项历炼，如果没有被失败击倒，那么从中会生长出一份韧性，这种韧性能让人走得更远。谁没有经历过失败的历练呢？失败是最伟大的导师了，如果你愿意跟他学一学的话。&lt;/p>
&lt;p>在面试的过程中，我很快发现自己的劣势：&lt;/p>
&lt;ul>
&lt;li>投入精力做业务，技术深度不够，对原理的理解局限于较浅的层次；&lt;/li>
&lt;li>视野不够开阔，局限于自己所做的订单业务线，对其它关联业务线（比如商品、营销、支付等）了解不够；&lt;/li>
&lt;li>思维不够开阔，大部分时间投入在开发和测试上，对运维、产品、业务、商业层面思考都思考不多；&lt;/li>
&lt;li>缺乏管理经验，年龄偏大；这两项劣势我一度低估，但逐渐凸显出来，甚至让我一度不自信，但最终我还是走出来了。&lt;/li>
&lt;/ul>
&lt;p>但我也有自己的优势。职业竞争的基本法则是稀缺性和差异化。能够解决大型项目的架构设计和攻克技术难题，精通某个高端技术领域是稀缺性体现；而能够做事能做到缜密周全精细化，有高并发大流量系统开发经验，则是差异性体现。稀缺性是上策，差异化是中策，而降格以求就是下策了。&lt;/p>
&lt;p>我缺乏稀缺性优势，但还有一点差异化优势：&lt;/p>
&lt;ul>
&lt;li>对每一份工作都很踏实，时间均在 3 年 - 5 年之间，有一点大厂光环，能获得更多面试机会（虽然不一定能面上）；&lt;/li>
&lt;li>坚持写博客，孜孜不倦地追求软件开发的“道”，时常思考记录开发中遇到的问题及解决方案；&lt;/li>
&lt;li>做事认真严谨，能够从整体分析和思考问题，也很注重基础提升；&lt;/li>
&lt;li>对工程质量、性能优化、稳定性建设、业务配置化设计有实践经验；&lt;/li>
&lt;li>大流量微服务系统的长期开发维护经验。&lt;/li>
&lt;/ul>
&lt;p>我投出简历的公司并不多。在不多的面试中，我逐渐意识到网上的“斩获几十家大厂 offer”的说法并不可信。理由如下：&lt;/p>
&lt;ul>
&lt;li>如果能真斩获大量大厂 offer ，面试的级别很大概率是初级工程师。要知道面试 4 年以上的工程师，面试的深度和广度令人发指，从基础的算法、到各种中间件的原理机制到实际运维架构，无所不包，真个是沉浸在“技术的海洋”，除非一个人的背景和实力非常强大，平时也做了非常深且广的沉淀；&lt;/li>
&lt;li>一个背景和实力非常强大的人，是不会有兴趣去投入这么多精力去面各种公司，仅仅是为了吹嘘自己有多能耐；实力越强的人，他会有自己的选择逻辑，投的简历会更定向精准。话说，他为什么不花更多精力投入在那些能够让他有最大化收益的优秀企业呢？&lt;/li>
&lt;li>培训机构做的广告。因为他们最清楚新手需要的是信心，哪怕是伪装出来的信心。&lt;/li>
&lt;/ul>
&lt;p>好了，闲话不多说了。我讲讲自己在面试中所经受的历练和思考吧。&lt;/p>
&lt;h2 id="准备工作">
 准备工作
 &lt;a class="anchor" href="#%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c">#&lt;/a>
&lt;/h2>
&lt;p>人生或许很长，但面试的时间很短，最长不过一小时或一个半小时。别人如何在短短一小时内能够更清晰地认识长达三十多年的你呢？这就需要你做大量细致的准备工作了。在某种程度上，面试与舞蹈有异曲同工之妙：台上五分钟，台下十年功。&lt;/p>
&lt;p>准备工作主要包括简历准备、个人介绍、公司了解、技术探索、表述能力、常见问题、中高端职位、好的心态。准备工作是对自身和对外部世界的一次全面深入的重新认知。&lt;/p>
&lt;p>初期，我以为自己准备很充分，简历改改就完事了。随着一次次受挫，才发现自己的准备很不充分。在现在的我看来，准备七分，应变三分。准备，就是要知己知彼，知道对方会问哪些问题（通常是系统/项目/技术的深度和广度）、自己应当如何作答；应变，就是当自己遇到不会、不懂、不知道的问题时，如何合理地展示自己的解决思路，以及根据面试中答不上来的问题查漏补缺，夯实基础。&lt;/p>
&lt;p>这个过程，实际上也是学习的过程。持续的反思和提炼、学习新的内容、重新认识自己和过往经历等。&lt;/p>
&lt;h3 id="简历准备">
 简历准备
 &lt;a class="anchor" href="#%e7%ae%80%e5%8e%86%e5%87%86%e5%a4%87">#&lt;/a>
&lt;/h3>
&lt;p>最开始，我做得比较简单。把以前的简历拿出来，添加上新的工作经历，略作修改，但整体上模板基本不变。&lt;/p>
&lt;p>在基本面上，我做的是较为细致的，诚实地写上了自己擅长和熟悉的技能和经验经历，排版也尽力做得整洁美观（学过一些 UI 设计）。不浮夸也不故作谦虚。&lt;/p></description></item><item><title>应用层常见协议总结（应用层）</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/application-layer-protocol/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/cs-basics/network/application-layer-protocol/</guid><description>&lt;h2 id="http超文本传输协议">
 HTTP:超文本传输协议
 &lt;a class="anchor" href="#http%e8%b6%85%e6%96%87%e6%9c%ac%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>超文本传输协议（HTTP，HyperText Transfer Protocol)&lt;/strong> 是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。&lt;/p>
&lt;p>HTTP 使用客户端-服务器模型，客户端向服务器发送 HTTP Request（请求），服务器响应请求并返回 HTTP Response（响应），整个过程如下图所示。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/450px-HTTP-Header.png" alt="" />&lt;/p>
&lt;p>HTTP 协议基于 TCP 协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。&lt;/p>
&lt;p>另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。&lt;/p>
&lt;h2 id="websocket全双工通信协议">
 Websocket：全双工通信协议
 &lt;a class="anchor" href="#websocket%e5%85%a8%e5%8f%8c%e5%b7%a5%e9%80%9a%e4%bf%a1%e5%8d%8f%e8%ae%ae">#&lt;/a>
&lt;/h2>
&lt;p>WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。&lt;/p>
&lt;p>WebSocket 协议在 2008 年诞生，2011 年成为国际标准，几乎所有主流较新版本的浏览器都支持该协议。不过，WebSocket 不只能在基于浏览器的应用程序中使用，很多编程语言、框架和服务器都提供了 WebSocket 支持。&lt;/p>
&lt;p>WebSocket 协议本质上是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/system-design/web-real-time-message-push/1460000042192394.png" alt="Websocket 示意图" />&lt;/p>
&lt;p>下面是 WebSocket 的常见应用场景：&lt;/p>
&lt;ul>
&lt;li>视频弹幕&lt;/li>
&lt;li>实时消息推送，详见&lt;a href="https://javaguide.cn/system-design/web-real-time-message-push.html">Web 实时消息推送详解&lt;/a>这篇文章&lt;/li>
&lt;li>实时游戏对战&lt;/li>
&lt;li>多用户协同编辑&lt;/li>
&lt;li>社交聊天&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;p>WebSocket 的工作过程可以分为以下几个步骤：&lt;/p></description></item><item><title>有了 HTTP 协议，为什么还要有 RPC ？</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/rpc/httprpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/distributed-system/rpc/httprpc/</guid><description>&lt;blockquote>
&lt;p>本文来自&lt;a href="https://juejin.cn/user/4001878057422087">小白 debug&lt;/a>投稿，原文：&lt;a href="https://juejin.cn/post/7121882245605883934">https://juejin.cn/post/7121882245605883934&lt;/a> 。&lt;/p>
&lt;/blockquote>
&lt;p>我想起了我刚工作的时候，第一次接触 RPC 协议，当时就很懵，我 HTTP 协议用的好好的，为什么还要用 RPC 协议？&lt;/p>
&lt;p>于是就到网上去搜。&lt;/p>
&lt;p>不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在&lt;strong>用一个我们不认识的概念去解释另外一个我们不认识的概念&lt;/strong>，懂的人不需要看，不懂的人看了还是不懂。&lt;/p>
&lt;p>这种看了，又好像没看的感觉，云里雾里的很难受，&lt;strong>我懂&lt;/strong>。&lt;/p>
&lt;p>为了避免大家有强烈的&lt;strong>审丑疲劳&lt;/strong>，今天我们来尝试重新换个方式讲一讲。&lt;/p>
&lt;h2 id="从-tcp-聊起">
 从 TCP 聊起
 &lt;a class="anchor" href="#%e4%bb%8e-tcp-%e8%81%8a%e8%b5%b7">#&lt;/a>
&lt;/h2>
&lt;p>作为一个程序员，假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用 socket 进行编程。&lt;/p>
&lt;p>这时候，我们可选项一般也就&lt;strong>TCP 和 UDP 二选一。TCP 可靠，UDP 不可靠。&lt;/strong> 除非是马总这种神级程序员（早期 QQ 大量使用 UDP），否则，只要稍微对可靠性有些要求，普通人一般无脑选 TCP 就对了。&lt;/p>
&lt;p>类似下面这样。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ini" data-lang="ini">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fd&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">socket(AF_INET,SOCK_STREAM,0);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>SOCK_STREAM&lt;/code>，是指使用&lt;strong>字节流&lt;/strong>传输数据，说白了就是&lt;strong>TCP 协议&lt;/strong>。&lt;/p>
&lt;p>在定义了 socket 之后，我们就可以愉快的对这个 socket 进行操作，比如用&lt;code>bind()&lt;/code>绑定 IP 端口，用&lt;code>connect()&lt;/code>发起建连。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/f410977cda814d32b0eff3645c385a8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png" alt="握手建立连接流程" />&lt;/p>
&lt;p>在连接建立之后，我们就可以使用&lt;code>send()&lt;/code>发送数据，&lt;code>recv()&lt;/code>接收数据。&lt;/p>
&lt;p>光这样一个纯裸的 TCP 连接，就可以做到收发数据了，那是不是就够了？&lt;/p>
&lt;p>不行，这么用会有问题。&lt;/p>
&lt;h2 id="使用纯裸-tcp-会有什么问题">
 使用纯裸 TCP 会有什么问题
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8%e7%ba%af%e8%a3%b8-tcp-%e4%bc%9a%e6%9c%89%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;p>八股文常背，TCP 是有三个特点，&lt;strong>面向连接&lt;/strong>、&lt;strong>可靠&lt;/strong>、基于&lt;strong>字节流&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://oss.javaguide.cn/github/javaguide/distributed-system/rpc/acb4508111cb47d8a3df6734d04818bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp.png" alt="TCP是什么" />&lt;/p>
&lt;p>这三个特点真的概括的 &lt;strong>非常精辟&lt;/strong> ，这个八股文我们没白背。&lt;/p>
&lt;p>每个特点展开都能聊一篇文章，而今天我们需要关注的是 &lt;strong>基于字节流&lt;/strong> 这一点。&lt;/p></description></item><item><title>糟糕程序员的 20 个坏习惯</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/20-bad-habits-of-bad-programmers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/advanced-programmer/20-bad-habits-of-bad-programmers/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：Kaito 大佬的一篇文章，很实用的建议！&lt;/p>
&lt;p>&lt;strong>原文地址：&lt;/strong> &lt;a href="https://mp.weixin.qq.com/s/6hUU6SZsxGPWAIIByq93Rw">https://mp.weixin.qq.com/s/6hUU6SZsxGPWAIIByq93Rw&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>我想你肯定遇到过这样一类程序员：&lt;strong>他们无论是写代码，还是写文档，又或是和别人沟通，都显得特别专业&lt;/strong>。每次遇到这类人，我都在想，他们到底是怎么做到的？&lt;/p>
&lt;p>随着工作时间的增长，渐渐地我也总结出一些经验，他们身上都保持着一些看似很微小的优秀习惯，但正是因为这些习惯，体现出了一个优秀程序员的基本素养。&lt;/p>
&lt;p>但今天我们来换个角度，来看看一个糟糕程序员有哪些坏习惯？只要我们都能避开这些问题，就可以逐渐向一个优秀程序员靠近。&lt;/p>
&lt;h2 id="1技术名词拼写不规范">
 1、技术名词拼写不规范
 &lt;a class="anchor" href="#1%e6%8a%80%e6%9c%af%e5%90%8d%e8%af%8d%e6%8b%bc%e5%86%99%e4%b8%8d%e8%a7%84%e8%8c%83">#&lt;/a>
&lt;/h2>
&lt;p>无论是个人简历，还是技术文档，我经常看到拼写不规范的技术名词，例如 JAVA、javascript、python、MySql、Hbase、restful。&lt;/p>
&lt;p>正确的拼写应该是 Java、JavaScript、Python、MySQL、HBase、RESTful，不要小看这个问题，很多面试官很有可能因为这一点刷掉你的简历。&lt;/p>
&lt;h2 id="2写文档中英文混排不规范">
 2、写文档，中英文混排不规范
 &lt;a class="anchor" href="#2%e5%86%99%e6%96%87%e6%a1%a3%e4%b8%ad%e8%8b%b1%e6%96%87%e6%b7%b7%e6%8e%92%e4%b8%8d%e8%a7%84%e8%8c%83">#&lt;/a>
&lt;/h2>
&lt;p>中文描述使用英文标点符号，英文和数字使用了全角字符，中文与英文、数字之间没有空格等等。&lt;/p>
&lt;p>其中很多人会忽视中文和英文、数字之间加一个「空格」，这样排版阅读起来会更舒服。之前我的文章排版，都是遵循了这些细节。&lt;/p>
&lt;h2 id="3重要逻辑不写注释或写得很拖沓">
 3、重要逻辑不写注释，或写得很拖沓
 &lt;a class="anchor" href="#3%e9%87%8d%e8%a6%81%e9%80%bb%e8%be%91%e4%b8%8d%e5%86%99%e6%b3%a8%e9%87%8a%e6%88%96%e5%86%99%e5%be%97%e5%be%88%e6%8b%96%e6%b2%93">#&lt;/a>
&lt;/h2>
&lt;p>复杂且重要的逻辑代码，很多程序员不写注释，除了自己能看懂代码逻辑，其他人根本看不懂。或者是注释虽然写了，但写得很拖沓，没有逻辑可言。&lt;/p>
&lt;p>重要的逻辑不止要写注释，还要写得简洁、清晰。如果是一眼就能读懂的简单代码，可以不加注释。&lt;/p>
&lt;h2 id="4写复杂冗长的函数">
 4、写复杂冗长的函数
 &lt;a class="anchor" href="#4%e5%86%99%e5%a4%8d%e6%9d%82%e5%86%97%e9%95%bf%e7%9a%84%e5%87%bd%e6%95%b0">#&lt;/a>
&lt;/h2>
&lt;p>一个函数几百行，一个文件上千行代码，复杂函数不做拆分，导致代码变得越来越难维护，最后谁也不敢动。&lt;/p>
&lt;p>基本的设计模式还是要遵守的，例如单一职责，一个函数只做一件事，开闭原则，对扩展开放，对修改关闭。&lt;/p>
&lt;p>如果函数逻辑确实复杂，也至少要保证主干逻辑足够清晰。&lt;/p>
&lt;h2 id="5不看官方文档只看垃圾博客">
 5、不看官方文档，只看垃圾博客
 &lt;a class="anchor" href="#5%e4%b8%8d%e7%9c%8b%e5%ae%98%e6%96%b9%e6%96%87%e6%a1%a3%e5%8f%aa%e7%9c%8b%e5%9e%83%e5%9c%be%e5%8d%9a%e5%ae%a2">#&lt;/a>
&lt;/h2>
&lt;p>很多人遇到问题不先去看官方文档，而是热衷于去看垃圾博客，这些博客的内容都是互相抄袭，错误百出。&lt;/p>
&lt;p>其实很多软件官方文档写得已经非常好了，常见问题都能找到答案，认真读一读官方文档，比看垃圾博客强一百倍，要养成看官方文档的好习惯。&lt;/p>
&lt;h2 id="6宣扬内功无用论">
 6、宣扬内功无用论
 &lt;a class="anchor" href="#6%e5%ae%a3%e6%89%ac%e5%86%85%e5%8a%9f%e6%97%a0%e7%94%a8%e8%ae%ba">#&lt;/a>
&lt;/h2>
&lt;p>有些人天天追求日新月异的开源项目和框架，却不肯花时间去啃一啃底层原理，常见问题虽然可以解决，但遇到稍微深一点的问题就束手无策。&lt;/p>
&lt;p>很多高大上的架构设计，思路其实都源于底层。想一想，像计算机体系结构、操作系统、网络协议这些东西，经过多少年演进才变为现在的样子，演进过程中遇到的复杂问题比比皆是，理解了解决这些问题的思路，再看上层技术会变得很简单。&lt;/p>
&lt;h2 id="7乐于炫技">
 7、乐于炫技
 &lt;a class="anchor" href="#7%e4%b9%90%e4%ba%8e%e7%82%ab%e6%8a%80">#&lt;/a>
&lt;/h2>
&lt;p>有些人天天把「高大上」的技术名词挂在嘴边，生怕别人不知道自己学了什么高深技术，嘴上乐于炫技，但别人一问他细节就会哑口无言。&lt;/p>
&lt;h2 id="8不接受质疑">
 8、不接受质疑
 &lt;a class="anchor" href="#8%e4%b8%8d%e6%8e%a5%e5%8f%97%e8%b4%a8%e7%96%91">#&lt;/a>
&lt;/h2>
&lt;p>自己设计的方案，别人提出疑问时只会回怼，而不是理性分析利弊，抱着学习的心态交流。&lt;/p>
&lt;p>这些人学了点东西就觉得自己很有本事，殊不知只是自己见识太少。&lt;/p>
&lt;h2 id="9接口协议不规范">
 9、接口协议不规范
 &lt;a class="anchor" href="#9%e6%8e%a5%e5%8f%a3%e5%8d%8f%e8%ae%ae%e4%b8%8d%e8%a7%84%e8%8c%83">#&lt;/a>
&lt;/h2>
&lt;p>和别人定 API 协议全靠口头沟通，不给规范的文档说明，甚至到了测试联调时会发现，竟然和协商的还不一样，或者改协议了却不通知对接方，合作体验极差。&lt;/p>
&lt;h2 id="10遇到问题自己死磕">
 10、遇到问题自己死磕
 &lt;a class="anchor" href="#10%e9%81%87%e5%88%b0%e9%97%ae%e9%a2%98%e8%87%aa%e5%b7%b1%e6%ad%bb%e7%a3%95">#&lt;/a>
&lt;/h2>
&lt;p>很初级程序员容易犯的问题，遇到问题只会自己死磕，拖到 deadline 也没有产出，领导来问才知道有问题解决不了。&lt;/p>
&lt;p>有问题及时反馈才是对自己负责，对团队负责。&lt;/p>
&lt;h2 id="11一说就会一写就废">
 11、一说就会，一写就废
 &lt;a class="anchor" href="#11%e4%b8%80%e8%af%b4%e5%b0%b1%e4%bc%9a%e4%b8%80%e5%86%99%e5%b0%b1%e5%ba%9f">#&lt;/a>
&lt;/h2>
&lt;p>平时技术方案吹得天花乱坠，一让他写代码就废，典型的眼高手低选手。&lt;/p>
&lt;h2 id="12表达没有逻辑不站在对方角度看问题">
 12、表达没有逻辑，不站在对方角度看问题
 &lt;a class="anchor" href="#12%e8%a1%a8%e8%be%be%e6%b2%a1%e6%9c%89%e9%80%bb%e8%be%91%e4%b8%8d%e7%ab%99%e5%9c%a8%e5%af%b9%e6%96%b9%e8%a7%92%e5%ba%a6%e7%9c%8b%e9%97%ae%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;p>讨论问题不交代背景，上来就说自己的方案，别人听得云里雾里，让你从头描述你又讲不明白。&lt;/p>
&lt;p>学会沟通和表达，是合作的基础。&lt;/p></description></item><item><title>斩获 20+ 大厂 offer 的面试经验分享</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-of-get-offer-from-over-20-big-companies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/high-quality-technical-articles/interview/the-experience-of-get-offer-from-over-20-big-companies/</guid><description>&lt;blockquote>
&lt;p>&lt;strong>推荐语&lt;/strong>：很实用的面试经验分享！&lt;/p>
&lt;p>&lt;strong>原文地址&lt;/strong>：&lt;a href="https://mp.weixin.qq.com/s/HXKg6-H0kGUU2OA1DS43Bw">https://mp.weixin.qq.com/s/HXKg6-H0kGUU2OA1DS43Bw&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>突然回想起当年，我也在秋招时也斩获了 20+的互联网各大厂 offer。现在想起来也是有点唏嘘，毕竟拿得再多也只能选择一家。不过许多朋友想让我分享下互联网面试方法，今天就来给大家仔细讲讲打法！&lt;/p>
&lt;p>如今金九银十已经过去，满是硝烟的求职战场上也只留下一处处炮灰。在现在这段日子，又是重新锻炼，时刻准备着明年金三银四的时候。&lt;/p>
&lt;p>对于还没毕业的学生来说，明年三四月是春招补招或者实习招聘的机会；对于职场老油条来说，明年三四月也是拿完年终奖准备提桶跑路的时候。&lt;/p>
&lt;p>所以这段日子，就需要好好准备积累面试方法以及面试经验，明年的冲锋陷阵打下基础。这篇文章将为大家讲讲，程序员应该如何准备好技术面试。&lt;/p>
&lt;p>一般而言，互联网公司技术岗的招聘都会根据需要设置为 3 ～ 4 轮面试，一些 HC 较少的岗位可能还会经历 5 ～ 8 轮面试不等。除此之外，视公司情况，面试之前还可能也会设定相应的笔试环节。&lt;/p>
&lt;p>多轮的面试中包括技术面和 HR 面。相对来说，在整体的招聘流程中，技术面的决定性比较重要，HR 面更多的是确认候选人的基本情况和职业素养。&lt;/p>
&lt;p>不过在某些大厂，HR 也具有一票否决权，所以每一轮面试都该好好准备和应对。技术面试一般可分为五个部分：&lt;/p>
&lt;ol>
&lt;li>双方自我介绍&lt;/li>
&lt;li>项目经历&lt;/li>
&lt;li>专业知识考查&lt;/li>
&lt;li>编码能力考察&lt;/li>
&lt;li>候选人 Q&amp;amp;A&lt;/li>
&lt;/ol>
&lt;h2 id="双方自我介绍">
 双方自我介绍
 &lt;a class="anchor" href="#%e5%8f%8c%e6%96%b9%e8%87%aa%e6%88%91%e4%bb%8b%e7%bb%8d">#&lt;/a>
&lt;/h2>
&lt;p>面试往往是以自我介绍作为开场，很多时候一段条理清晰逻辑明确的开场会决定整场面试的氛围和节奏。&lt;/p>
&lt;p>&lt;strong>作为候选人，我们可以在自我介绍中适当的为本次面试提供指向性的信息，以辅助面试官去发掘自己身上的亮点和长处&lt;/strong>。&lt;/p>
&lt;p>其实自我介绍并不是简单的个人基本情况的条条过目，而是对自己简历的有效性概括。&lt;/p>
&lt;p>什么是有效性概括呢，就是意味着需要对简历中的信息进行核心关键词的提取整合。一段话下来，就能够让面试官对你整体的情况有了了解，从而能够引导面试官的联系提问。&lt;/p>
&lt;h2 id="项目经历">
 项目经历
 &lt;a class="anchor" href="#%e9%a1%b9%e7%9b%ae%e7%bb%8f%e5%8e%86">#&lt;/a>
&lt;/h2>
&lt;p>项目经历是面试过程中非常重要的一环，特别是在社招的面试中。一般社招的职级越高，往往越看重项目经历。&lt;/p>
&lt;p>而对于一般的校招生而言，几份岗位度匹配度以及项目完整性高的项目经历可以成为面试的亮点，也是决定于拿&lt;code>SP&lt;/code> or &lt;code>SSP&lt;/code>的关键。&lt;/p>
&lt;p>但是准备好项目经历，并不是一件容易的事情。很多人并不清楚应该怎样去描述自己的项目，更不知道应该在经历中如何去体现自己的优势和亮点。&lt;/p>
&lt;p>这里针对项目经历给大家提几点建议：&lt;/p>
&lt;p>&lt;strong>1、高效有条理的描述&lt;/strong>&lt;/p>
&lt;p>项目经历的一般是简历里篇幅最大的部分，所以在面试时这部分同样重要。在表述时，语言的逻辑和条理一定要清晰，以保证面试官能够在最快的时间抓到你的项目的整体思路。&lt;/p>
&lt;p>相信很多人都听说过写简历的各种原则，比如&lt;code>STAR&lt;/code>、&lt;code>SMART&lt;/code>等。但实际上这些原则都可以用来规范自己的表达逻辑。&lt;/p>
&lt;p>&lt;code>STAR&lt;/code>原则相对简单，用来在面试过程中规范自己的条理非常有效。所谓&lt;code>STAR&lt;/code>，即&lt;code>Situation&lt;/code>、&lt;code>Target&lt;/code>、&lt;code>Action&lt;/code>、&lt;code>Result&lt;/code>。这跟写论文写文档的逻辑划分大体一致。&lt;/p>
&lt;ul>
&lt;li>&lt;code>Situation&lt;/code>: 即项目背景，需要将项目提出的原因、现状以及出发点表述清楚。简单来说，就是要将项目提出的来龙去脉描述清晰。比如某某平台建设的原因，是切入用户怎样的痛点之类的。&lt;/li>
&lt;li>&lt;code>Target&lt;/code>: 即项目目标，这点描述的是项目预期达到或完成的程度。**最好是有可量化的指标和预期结果。**比如性能优化的指标、架构优化所带来的业务收益等等。&lt;/li>
&lt;li>&lt;code>Action&lt;/code>: 即方法方案，意味着完成项目具体实施的行为。这点在技术面试中最为重要，也是表现候选人能力的基础。**项目的方法或方案可以从技术栈出发，根据采用的不同技术点来具体写明解决了哪些问题。**比如用了什么框架/技术实现了什么架构/优化/设计，解决了项目中什么样的问题。&lt;/li>
&lt;li>&lt;code>Result&lt;/code>: 即项目获得结果，这点可以在面试中讲讲自己经历过项目后的思考和反思。这样会让面试官感受到你的成长和沉淀，会比直接的结果并动人。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2、充分准备项目亮点&lt;/strong>&lt;/p>
&lt;p>说实话，大部分人其实都没有十分亮眼的项目，但是并不意味着没有项目经历的亮点。特别是在面试中。&lt;/p>
&lt;p>在面试中，你可以通过充分的准备以及深入的思考来突出你的项目亮点。比如可以从以下几个方向入手：&lt;/p>
&lt;ul>
&lt;li>充分了解项目的业务逻辑和技术架构&lt;/li>
&lt;li>熟悉项目的整体架构和关键设计&lt;/li>
&lt;li>明确的知道业务架构或技术方案选型以及决策逻辑&lt;/li>
&lt;li>深入掌握项目中涉及的组件以及框架&lt;/li>
&lt;li>熟悉项目中的疑难杂症或长期遗留 bug 的解决方案&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;h2 id="专业知识考查">
 专业知识考查
 &lt;a class="anchor" href="#%e4%b8%93%e4%b8%9a%e7%9f%a5%e8%af%86%e8%80%83%e6%9f%a5">#&lt;/a>
&lt;/h2>
&lt;p>有经验的面试官往往会在对项目经历刨根问底的同时，从中考察你的专业知识。&lt;/p></description></item><item><title>字符集详解</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/database/character-set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/database/character-set/</guid><description>&lt;p>MySQL 字符编码集中有两套 UTF-8 编码实现：&lt;strong>&lt;code>utf8&lt;/code>&lt;/strong> 和 &lt;strong>&lt;code>utf8mb4&lt;/code>&lt;/strong>。&lt;/p>
&lt;p>如果使用 &lt;strong>&lt;code>utf8&lt;/code>&lt;/strong> 的话，存储 emoji 符号和一些比较复杂的汉字、繁体字就会出错。&lt;/p>
&lt;p>为什么会这样呢？这篇文章可以从源头给你解答。&lt;/p>
&lt;h2 id="字符集是什么">
 字符集是什么？
 &lt;a class="anchor" href="#%e5%ad%97%e7%ac%a6%e9%9b%86%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 &lt;strong>字符集&lt;/strong> 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。&lt;/p>
&lt;p>&lt;strong>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？&lt;/strong>&lt;/p>
&lt;p>我们要将这些字符和二进制的数据一一对应起来，比如说字符“a”对应“01100001”，反之，“01100001”对应 “a”。我们将字符对应二进制数据的过程称为&amp;quot;&lt;strong>字符编码&lt;/strong>&amp;quot;，反之，二进制数据解析成字符的过程称为“&lt;strong>字符解码&lt;/strong>”。&lt;/p>
&lt;h2 id="字符编码是什么">
 字符编码是什么？
 &lt;a class="anchor" href="#%e5%ad%97%e7%ac%a6%e7%bc%96%e7%a0%81%e6%98%af%e4%bb%80%e4%b9%88">#&lt;/a>
&lt;/h2>
&lt;p>字符编码是一种将字符集中的字符与计算机中的二进制数据相互转换的方法，可以看作是一种映射规则。也就是说，字符编码的目的是为了让计算机能够存储和传输各种文字信息。&lt;/p>
&lt;p>每种字符集都有自己的字符编码规则，常用的字符集编码规则有 ASCII 编码、 GB2312 编码、GBK 编码、GB18030 编码、Big5 编码、UTF-8 编码、UTF-16 编码等。&lt;/p>
&lt;h2 id="有哪些常见的字符集">
 有哪些常见的字符集？
 &lt;a class="anchor" href="#%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e5%ad%97%e7%ac%a6%e9%9b%86">#&lt;/a>
&lt;/h2>
&lt;p>常见的字符集有：ASCII、GB2312、GB18030、GBK、Unicode……。&lt;/p>
&lt;p>不同的字符集的主要区别在于：&lt;/p>
&lt;ul>
&lt;li>可以表示的字符范围&lt;/li>
&lt;li>编码方式&lt;/li>
&lt;/ul>
&lt;h3 id="ascii">
 ASCII
 &lt;a class="anchor" href="#ascii">#&lt;/a>
&lt;/h3>
&lt;p>&lt;strong>ASCII&lt;/strong> (&lt;strong>A&lt;/strong>merican &lt;strong>S&lt;/strong>tandard &lt;strong>C&lt;/strong>ode for &lt;strong>I&lt;/strong>nformation &lt;strong>I&lt;/strong>nterchange，美国信息交换标准代码) 是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。&lt;/p>
&lt;p>&lt;strong>为什么 ASCII 字符集没有考虑到中文等其他字符呢？&lt;/strong> 因为计算机是美国人发明的，当时，计算机的发展还处于比较雏形的时代，还未在其他国家大规模使用。因此，美国发布 ASCII 字符集的时候没有考虑兼容其他国家的语言。&lt;/p>
&lt;p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。&lt;/p>
&lt;p>一个 ASCII 码长度是一个字节也就是 8 个 bit，比如“a”对应的 ASCII 码是“01100001”。不过，最高位是 0 仅仅作为校验位，其余 7 位使用 0 和 1 进行组合，所以，ASCII 字符集可以定义 128（2^7）个字符。&lt;/p></description></item><item><title>最重要的JVM参数总结</title><link>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/jvm-parameters-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lwmfjc.github.io/zh/docs/technology/Interview/java/jvm/jvm-parameters-intro/</guid><description>&lt;blockquote>
&lt;p>本文由 JavaGuide 翻译自 &lt;a href="https://www.baeldung.com/jvm-parameters">https://www.baeldung.com/jvm-parameters&lt;/a>，并对文章进行了大量的完善补充。&lt;/p>
&lt;p>JDK 版本：1.8&lt;/p>
&lt;/blockquote>
&lt;h2 id="1概述">
 1.概述
 &lt;a class="anchor" href="#1%e6%a6%82%e8%bf%b0">#&lt;/a>
&lt;/h2>
&lt;p>在本篇文章中，你将掌握最常用的 JVM 参数配置。&lt;/p>
&lt;h2 id="2堆内存相关">
 2.堆内存相关
 &lt;a class="anchor" href="#2%e5%a0%86%e5%86%85%e5%ad%98%e7%9b%b8%e5%85%b3">#&lt;/a>
&lt;/h2>
&lt;blockquote>
&lt;p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。&lt;strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="./pictures/%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%e5%b8%b8%e8%a7%81%e9%85%8d%e7%bd%ae%e5%8f%82%e6%95%b0.png" alt="内存区域常见配置参数" />&lt;/p>
&lt;h3 id="21显式指定堆内存xms和-xmx">
 2.1.显式指定堆内存&lt;code>–Xms&lt;/code>和&lt;code>-Xmx&lt;/code>
 &lt;a class="anchor" href="#21%e6%98%be%e5%bc%8f%e6%8c%87%e5%ae%9a%e5%a0%86%e5%86%85%e5%ad%98xms%e5%92%8c-xmx">#&lt;/a>
&lt;/h3>
&lt;p>与性能有关的最常见实践之一是根据应用程序要求初始化堆内存。如果我们需要指定最小和最大堆大小（推荐显示指定大小），以下参数可以帮助你实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>-Xms&amp;lt;heap size&amp;gt;&lt;span style="color:#f92672">[&lt;/span>unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-Xmx&amp;lt;heap size&amp;gt;&lt;span style="color:#f92672">[&lt;/span>unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>heap size&lt;/strong> 表示要初始化内存的具体大小。&lt;/li>
&lt;li>&lt;strong>unit&lt;/strong> 表示要初始化内存的单位。单位为 &lt;strong>&lt;em>“ g”&lt;/em>&lt;/strong> (GB)、&lt;strong>&lt;em>“ m”&lt;/em>&lt;/strong>（MB）、&lt;strong>&lt;em>“ k”&lt;/em>&lt;/strong>（KB）。&lt;/li>
&lt;/ul>
&lt;p>举个栗子 🌰，如果我们要为 JVM 分配最小 2 GB 和最大 5 GB 的堆内存大小，我们的参数应该这样来写：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>-Xms2G -Xmx5G
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="22显式新生代内存young-generation">
 2.2.显式新生代内存(Young Generation)
 &lt;a class="anchor" href="#22%e6%98%be%e5%bc%8f%e6%96%b0%e7%94%9f%e4%bb%a3%e5%86%85%e5%ad%98young-generation">#&lt;/a>
&lt;/h3>
&lt;p>根据&lt;a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html">Oracle 官方文档&lt;/a>，在堆总可用内存配置完成之后，第二大影响因素是为 &lt;code>Young Generation&lt;/code> 在堆内存所占的比例。默认情况下，YG 的最小大小为 1310 &lt;em>MB&lt;/em>，最大大小为 &lt;em>无限制&lt;/em>。&lt;/p>
&lt;p>一共有两种指定 新生代内存(Young Generation)大小的方法：&lt;/p>
&lt;p>&lt;strong>1.通过&lt;code>-XX:NewSize&lt;/code>和&lt;code>-XX:MaxNewSize&lt;/code>指定&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>-XX:NewSize&lt;span style="color:#f92672">=&lt;/span>&amp;lt;young size&amp;gt;&lt;span style="color:#f92672">[&lt;/span>unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-XX:MaxNewSize&lt;span style="color:#f92672">=&lt;/span>&amp;lt;young size&amp;gt;&lt;span style="color:#f92672">[&lt;/span>unit&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>举个栗子 🌰，如果我们要为 新生代分配 最小 256m 的内存，最大 1024m 的内存我们的参数应该这样来写：&lt;/p></description></item></channel></rss>