<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021年最后一个周日</title>
    <url>/2021/12/26/life/20121226/</url>
    <content><![CDATA[<h2 id="装宽带">装宽带</h2>
<p>太晚了，不想写了-
-。简单写几个字吧，满心期待的装了宽带，但是并没有我想像的那么快乐。反而打了两把游戏更难过了，难过的是浪费了时间也什么都没得到
## 图书馆<br />
下午跑去图书馆收获倒是挺多，可能是我不太熟悉，对于书架上的书没有太大的感触。但是环境真的太棒了，很安静，感觉多发出点声音我都会觉得不好意思，大家都很自觉。也许对经常网上都能找到电子书看(程序员的事怎么能是盗呢)的人帮助不会特别大，但对于很大一部分人绝对帮助特别大，包括学生、老年人、还有一些文学类书籍阅读者等等(我一直认为文学类的一定要纸质的看起来才有味道~)<br />
当然，从图书馆回来我又打了两把游戏 o_O，dota2 yyds!!
打完日常卸载，哈哈</p>
<p>每次去图书馆我都会想起那句话，<code>"一个国家为其年轻人所提供的教育，决定了这个国家未来的样子"</code>。<br />
希望能多办点这样的图书馆，大家都能少点浮躁，多点沉淀；虽然我并不是热心公益人士，但我还是希望咱们国家的人民都生活的越来越好。不要辜负我们曾经受过的苦难。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>《作酒》有感</title>
    <url>/2022/04/16/life/20220416/</url>
    <content><![CDATA[<p>最近几天吃饭，经常听到一首很嗨的歌。旋律很轻快，其实本来也就一听而过，可能是耳闻目染次数多了，好奇心上来了，查了下歌词。</p>
<p>听这首歌期间我居然联想了很多，果然是老emo了。不知道怎么回事，我这种与世无争的心态，听完后居然也让我幻想了一下这歌描述的爱情模样。我又突然想到，如今社会上离婚率居高不下，也许与网络信息的传输有密切关联。如果是古代，嫁错人或者娶错人，大家也都都认了，有什么小打小闹都互相包含。而如今，生活压力不断增大，加上网络上爆炸式（至少效果是）的宣传爱情，对比显著，很让人一着魔就陷进去，就摒弃几年甚至十几年的夫妻之情，去追求所谓的真爱、自由。</p>
<p>每个人对自己的过往，或多或少都会不甘。如果这种不甘自己没有办法化解，那么就会在某一刻爆发。每个人都应该，也必定会为自己曾经的所作所为负责。不要懵懵懂懂地进入(现代)婚姻，这样对自己和它人都极其不负责。
爆炸式的信息接收会激发你所有的冲动与不甘。</p>
<iframe src="//player.bilibili.com/player.html?aid=211411097&amp;bvid=BV1aa411y7u9&amp;cid=505755578&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
</iframe>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>人为什么要结婚(找对象)</title>
    <url>/2022/07/24/life/20220724/</url>
    <content><![CDATA[<p>其实这是我在六七年前思考的一个问题，我觉得结婚，并不能单纯的作为一个世俗任务。很多人，是因为年纪到了结婚，因为父母催结婚，因为看到别人结婚而结婚，总之，是为别人而活。但我觉得，结婚的本质，应该是两个人生活的结合，包括了很多，比如生活中的喜怒哀乐互享，这是最基础的，开心了有人替你高兴，生气难过了有人安慰你、心疼你。如果连这个都做不到而各活各的，那我实在想不明白这种婚姻的意义在哪，而现在很多情况正是这样，有为了家庭而工作辛苦而没有交集的，也有单纯的相处腻了、懒了。</p>
<p>而说到腻，这就在于一点，就是有些婚姻是很仓促的，压根就没看清楚对方的样子(性格、三观)，或者是不清楚自己喜欢的是什么样的人，就已经在一起了，之后才发现对方很多问题不是自己能接受的，但是这个时候已经晚了。所以“内在”，才能持久吸引一个人，因为这是不轻易随时光变迁而改变的。</p>
<p>分享也并非简单的分享，如果分享的东西对方没有啥感觉，那这种关系也是很难持久的。因此，最佳的婚姻，应该是异性知己，你的一些心理，不用向对方解释太多，当然
这里并不是说一开始就是这种状态，更多是通过后面不断了解、不断磨合而达成这种状态，当你被别人误会了有人理解，这是世间最好的良药。理解一个人，就是拯救一个世界，一花一世界，一树一菩提。</p>
<p><strong>婚姻，就是找个互相理解的爱人，共享世间冷暖，白首不相离。</strong></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>test1</title>
    <url>/2021/12/24/test/test1/</url>
    <content><![CDATA[<p>随便加点内容，注意，上面空了一行</p>
<h3 id="测试">测试</h3>
<h2 id="图片测试">图片测试</h2>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>test2</title>
    <url>/2021/12/24/test/test2/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String hello=<span class="string">&quot;ly&quot;</span>; </span><br><span class="line">System.out.println(<span class="string">&quot;Helo World&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>git使用ssh连不上</title>
    <url>/2022/04/22/problem/git/01/</url>
    <content><![CDATA[<ul>
<li><p>处理方式 在系统的host文件中，添加ip指定</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br><span class="line">140.82.114.4 github.com</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>git问题</tag>
      </tags>
  </entry>
  <entry>
    <title>hugo踩坑</title>
    <url>/2021/12/27/problem/hugo/01a/</url>
    <content><![CDATA[<ul>
<li>对于访问文件资源
<ul>
<li>hugo的文件夹名不能以-结尾。<br />
</li>
<li>一个文件夹(比如这里是hugo文件夹)中，其中的index.md文件中引用图片时，是以index.md所在文件夹(也就是hugo文件夹)为根目录访问图片；而其中的01a.md文件中引用图片时，是以和该文件同级的01a文件夹(也就是hugo/01a/)为根目录，访问图片<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1640875951876.png" /></li>
</ul></li>
<li>当一个文件夹下存在index.md文件时，其他文件(代表的文章)不显示在网站的文章列表<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1640875552500.png" /></li>
<li>为了某些文件预览功能，我建议使用下面的文件夹结构处理文章及资源<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1640876339569.png" /></li>
</ul>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>hugo问题</tag>
      </tags>
  </entry>
  <entry>
    <title>hugo踩坑</title>
    <url>/2021/12/27/problem/hugo/p1/</url>
    <content><![CDATA[<ul>
<li>对于访问文件资源
<ul>
<li>hugo的文件夹名不能以-结尾。<br />
</li>
<li>一个文件夹(比如这里是hugo文件夹)中，其中的index.md文件中引用图片时，是以index.md所在文件夹(也就是hugo文件夹)为根目录访问图片；而其中的01a.md文件中引用图片时，是以和该文件同级的01a文件夹(也就是hugo/01a/)为根目录，访问图片<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1640875951876.png" /></li>
</ul></li>
<li>当一个文件夹下存在index.md文件时，其他文件(代表的文章)不显示在网站的文章列表<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1640875552500.png" /></li>
<li>为了某些文件预览功能，我建议使用下面的文件夹结构处理文章及资源<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1640876339569.png" /></li>
</ul>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>hugo问题</tag>
      </tags>
  </entry>
  <entry>
    <title>问题01</title>
    <url>/2022/05/14/problem/idea/01/</url>
    <content><![CDATA[<h2 id="cannot-download-sources">Cannot download sources</h2>
<p>在maven项目(根目录)下执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn dependency:resolve -Dclassifier=sources</span><br></pre></td></tr></table></figure>
<p>会开始下载，有控制台输出，结束后再点即可</p>
<h2 id="预留">预留</h2>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>idea问题</tag>
      </tags>
  </entry>
  <entry>
    <title>post</title>
    <url>/2022/11/01/problem/linux/20221101/</url>
    <content><![CDATA[<ul>
<li><p>在安装可视化的时候，出现<code>需要libmysqlclient.so.18()(64bit)</code>解决方案</p>
<blockquote>
<p>将mysql卸载即可 http://wenfeifei.com/art/detail/yGM1BG4</p>
</blockquote></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>问题</category>
      </categories>
      <tags>
        <tag>linux问题</tag>
      </tags>
  </entry>
  <entry>
    <title>类、实例初始化</title>
    <url>/2022/09/22/review/basics/Class_and_instance_initialization/</url>
    <content><![CDATA[<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> i=test();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> j=method();</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;(6)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Son()&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;(7)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;(8)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;(9)&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;(10)&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Son s1=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">		System.out.println();</span><br><span class="line">		Son s2=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> i=test();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> j=method();</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;(1)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Father()&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;(2)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;(3)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;(4)&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.print(<span class="string">&quot;(5)&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(5)(1)(10)(6)(9)(3)(2)(9)(8)(7)</span><br><span class="line">(9)(3)(2)(9)(8)(7)</span><br></pre></td></tr></table></figure>
<h2 id="分析">分析</h2>
<ul>
<li><p>类初始化过程</p>
<ul>
<li>当实例化了一个对象/或main所在类会导致类初始化</li>
<li>子类初始化前会先初始化父类</li>
<li>类初始化执行的是<clinit >方法，编译查看字节码可得知 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220922091920061.png"
alt="image-20220922091920061" /></li>
<li><clinit >由静态类变量显示赋值语句 以及
静态代码块组成(由上到下顺序)，且只执行一次<br />
如下<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220922100207544.png"
alt="image-20220922100207544" /></li>
</ul></li>
<li><p>实例初始化过程</p>
<ul>
<li>执行的是<init>方法 由非静态实例变量显示赋值语句 以及 非静态代码块
[从上到下顺序] 以及对应构造器代码[最后执行] 组成
其中，子类构造器一定会调用super() [最前面] 1） super() 【最前】 2）i =
test() 3）子类的非静态代码块 【2，3按顺序】
<ol start="4" type="1">
<li>子类的无参构造(最后)<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220922100330126.png"
alt="image-20220922100330126" /></li>
</ol></li>
</ul></li>
<li><p>重写的问题
如上所示，初始化Son对象的时候，会先调用super()方法，即初始化父类，然后会先调用父类的
非静态变量赋值以及非静态代码块，最后才是父类的构造器代码块</p>
<p>调用父类非静态变量赋值的时候，如果调用了非静态方法，就会涉及到重写问题，比如这里的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> i= test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会调用子类(当前正在初始化的对象)的test()方法，而不是父类的test()</p>
<ul>
<li>哪些方法不可被重写
final方法、静态方法、父类中的private等修饰使得子类不可见的方法</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>方法的参数传递机制</title>
    <url>/2022/09/22/review/basics/Method_parameter_passing_mechanism/</url>
    <content><![CDATA[<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exam4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">MyData</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyData</span>();</span><br><span class="line"></span><br><span class="line">        change(i, str, num, arr, my);</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">        System.out.println(<span class="string">&quot;arr = &quot;</span> + Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">&quot;my.a = &quot;</span> + my.a); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> j, String s, Integer n, <span class="type">int</span>[] a,</span></span><br><span class="line"><span class="params">                              MyData m)</span> &#123;</span><br><span class="line">        j+=<span class="number">1</span>;</span><br><span class="line">        s+=<span class="string">&quot;world&quot;</span>;</span><br><span class="line">        n+=<span class="number">1</span>;</span><br><span class="line">        a[<span class="number">0</span>]+=<span class="number">1</span>;</span><br><span class="line">        m.a+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">i = 1</span><br><span class="line">str = hello</span><br><span class="line">num = 2</span><br><span class="line">arr = [2, 2, 3, 4, 5]</span><br><span class="line">my.a = 11</span><br></pre></td></tr></table></figure>
<h2 id="知识点">知识点</h2>
<ul>
<li>方法的参数传递机制</li>
<li>String、包装类等对象的不可变性</li>
</ul>
<h2 id="分析">分析</h2>
<ul>
<li><p>对于包装类，如果是使用new，那么一定是开辟新的空间；如果是直接赋值，那么-128-127之间会有缓存池(堆中)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当使用new的时候，一定在堆中新开辟的空间</span></span><br><span class="line">Integer a1= <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);</span><br><span class="line">Integer b1= <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>);</span><br><span class="line">System.out.println(a1 == b1);<span class="comment">//false</span></span><br><span class="line">Integer a2= -<span class="number">128</span>;</span><br><span class="line">Integer b2= -<span class="number">128</span>;</span><br><span class="line">System.out.println(a2 == b2);<span class="comment">//true</span></span><br><span class="line">Integer a21= -<span class="number">129</span>;</span><br><span class="line">Integer b21= -<span class="number">129</span>;</span><br><span class="line">System.out.println(a21 == b21);<span class="comment">//false</span></span><br><span class="line">Integer a3=  <span class="number">127</span>;</span><br><span class="line">Integer b3=  <span class="number">127</span>;</span><br><span class="line">System.out.println(a3 == b3);<span class="comment">//true</span></span><br><span class="line">Integer a4=  <span class="number">22</span>;</span><br><span class="line">Integer b4=  <span class="number">22</span>;</span><br><span class="line">System.out.println(a4 == b4);<span class="comment">//true</span></span><br><span class="line">Integer a31=  <span class="number">128</span>;</span><br><span class="line">Integer b31=  <span class="number">128</span>;</span><br><span class="line">System.out.println(a31 == b31);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
<li><p>对于String类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先查找常量池中是否有&quot;abc&quot;，如果有直接返回在常量池中的引用,</span></span><br><span class="line"><span class="comment">//如果没有，则在常量池中创建&quot;abc&quot;,然后返回该引用</span></span><br><span class="line">String a=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//先查找常量池中是否有&quot;abc&quot;，如果有则在堆内存中创建对象，然后返回堆内存中的地址</span></span><br><span class="line"><span class="comment">//如果没有，则先在常量池中创建字符串对象，然后再在堆内存中创建对象，最后返回堆内存中的地址</span></span><br><span class="line">String ab=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(a==ab);<span class="comment">//true</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//intern() //判断常量池中是否有ab对象的字符串，如果存在&quot;abc&quot;则返回&quot;abc&quot;在</span></span><br><span class="line"><span class="comment">//常量池中的引用，如果不存在则在常量池中创建,</span></span><br><span class="line"><span class="comment">//并返回&quot;abc&quot;在常量池中的引用</span></span><br><span class="line">System.out.println(a==ab.intern());<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li><p>change方法调用之前，jvm中的结构 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220922113056133.png"
alt="image-20220922113056133" /></p></li>
<li><p>方法栈帧中的数据 执行change方法后，实参给形参赋值：
基本数据类型：数据值 引用数据类型：地址值</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220922211437515.png"
alt="image-20220922211437515" />
<figcaption aria-hidden="true">image-20220922211437515</figcaption>
</figure>
<p>当实参是特殊的类型时：比如String、包装类等对象，不可变，即
<code>s+="world";</code> 会导致创建两个对象，如图（ Integer也是） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220922211733044.png"
alt="image-20220922211733044" /></p></li>
</ul>
<p>数组和对象，则是找到堆内存中的地址，直接更改</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>成员变量与局部变量</title>
    <url>/2022/09/23/review/basics/member_variables_and_local_variables/</url>
    <content><![CDATA[<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> s;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     i++;</span><br><span class="line">     j++;</span><br><span class="line">     s++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> j)</span> &#123;</span><br><span class="line">     j++;</span><br><span class="line">     i++;</span><br><span class="line">     s++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Exam5</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exam5</span>();</span><br><span class="line">     <span class="type">Exam5</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exam5</span>();</span><br><span class="line">     obj1.test(<span class="number">10</span>);</span><br><span class="line">     obj1.test(<span class="number">20</span>);</span><br><span class="line">     obj2.test(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">     System.out.println(obj1.i + <span class="string">&quot;,&quot;</span> + obj1.j + <span class="string">&quot;,&quot;</span> + obj1.s);</span><br><span class="line">     System.out.println(obj2.i + <span class="string">&quot;,&quot;</span> + obj2.j + <span class="string">&quot;,&quot;</span> + obj2.s);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果">运行结果</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2,1,5</span><br><span class="line">1,1,5</span><br></pre></td></tr></table></figure>
<h2 id="分析">分析</h2>
<h3 id="就近原则">就近原则</h3>
<p>代码中有很多修改变量的语句，下面是用就近原则+作用域分析的图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220923110928107.png"
alt="image-20220923110928107" /></p>
<h3 id="局部变量和类变量">局部变量和类变量</h3>
<ul>
<li><p>局部变量包括方法体{}，形参，以及代码块</p>
<p>带static为类变量，不带的为实例变量<br />
代码中的变量分类 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220923111604883.png"
alt="image-20220923111604883" /></p></li>
<li><p>修饰符 --局部变量只有final -- 实例变量 public , protected ,
private , final , static , volatile transient</p></li>
<li><p>存储位置</p>
<p>局部变量：栈<br />
实例变量：堆<br />
类变量：方法区（类信息、常量、静态变量）<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220923111251514.png"
alt="image-20220923111251514" /></p></li>
<li><p>作用域 局部变量：从声明处开始，到所属的 } 结束 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220923112828922.png"
alt="image-20220923112828922" /></p></li>
<li><p>this <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220923113054686.png"
alt="image-20220923113054686" /></p></li>
<li><p>题中的s既可以用成员变量访问，也可以用类名访问</p></li>
<li><p>生命周期</p>
<ul>
<li>局部变量：每一个线程，每一次调用执行都是新的生命周期</li>
<li>实例变量：随着对象的创建而初始化，随着对象被回收而消亡（垃圾回收器），每一个对象的实例变量是独立的</li>
<li>类变量：随着类的初始化而初始化，随着类的卸载而消亡，该类的所有对象的类变量是共享的</li>
</ul></li>
</ul>
<h3 id="代码的执行jvm中">代码的执行，jvm中</h3>
<p>Exam5 obj1=new Exam5();</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220923113659581.png"
alt="image-20220923113659581" />
<figcaption aria-hidden="true">image-20220923113659581</figcaption>
</figure>
<p>obj1.test(10)</p>
<p>非静态代码块或者进入方法，都会在栈中开辟空间存储局部变量 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220923113808372.png"
alt="image-20220923113808372" /></p>
<p>注意：静态代码块定义的变量，只会存在于静态代码块中。不是类变量，也不属于成员变量</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>递归与迭代</title>
    <url>/2022/09/22/review/basics/recursion_and_iteration/</url>
    <content><![CDATA[<h2 id="编程题">编程题</h2>
<p>有n步台阶，一次只能上1步或2步，共有多少种走法</p>
<h3 id="分析">分析</h3>
<ul>
<li><p>分析<br />
n = 1，1步 f(1) = 1<br />
n = 2, 两个1步,2步 f(2) = 2<br />
n = 3, 分两种情况： 最后1步是2级台阶/最后1步是1级台阶， 即 f(3) =
f(1)+f(2) n = 4, 分两种情况： 最后1步是2级台阶/最后1步是1级台阶， 即f(4)
= f(2)+f(3)</p>
<p>也就是说，不管有几(n)个台阶，总要分成两种情况：最后1步是2级台阶/最后1步是1级台阶，即
f(n)= f(n-2) + f(n-1)</p></li>
</ul>
<h3 id="递归">递归</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> f(n-<span class="number">2</span>)+f(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      System.out.println(f(<span class="number">1</span>)); <span class="comment">//1</span></span><br><span class="line">      System.out.println(f(<span class="number">2</span>)); <span class="comment">//2</span></span><br><span class="line">      System.out.println(f(<span class="number">3</span>)); <span class="comment">//3</span></span><br><span class="line">      System.out.println(f(<span class="number">4</span>)); <span class="comment">//5</span></span><br><span class="line">      System.out.println(f(<span class="number">5</span>)); <span class="comment">//8</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>debug调试 方法栈 f(4)----&gt;分解成f(2)+f(3) f(2)---返回-
f(3)---f(2)返回---f(1)返回 【f(3)分解成f(2)和f(1)】 方法栈的个数： <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220923093752921.png"
alt="image-20220923093752921" /></li>
</ul>
<h3 id="使用循环">使用循环</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">loop</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(n + <span class="string">&quot;不能小于1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> one=<span class="number">2</span>;<span class="comment">//最后只走1步，会有2种走法</span></span><br><span class="line">    <span class="type">int</span> two=<span class="number">1</span>;<span class="comment">//最后走2步，会有1种走法</span></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//最后跨两级台阶+最后跨一级台阶的走法</span></span><br><span class="line">        sum=two+one;</span><br><span class="line">        two=one;</span><br><span class="line">        one=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220923095719037.png"
alt="image-20220923095719037" />
<figcaption aria-hidden="true">image-20220923095719037</figcaption>
</figure>
<h3 id="小结">小结</h3>
<ul>
<li>方法调用自身称为递归，利用变量的原值推出新值称为迭代(while循环)</li>
<li>递归<br />
优点：大问题转换为小问题，代码精简<br />
缺点：浪费空间（栈空间），可能会照成栈的溢出</li>
<li>迭代<br />
优点：效率高，时间只受循环次数限制，不受出栈入栈时间<br />
缺点：不如递归精简，可读性稍差</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>自增变量</title>
    <url>/2022/09/21/review/basics/self_incrementing_variable/</url>
    <content><![CDATA[<h2 id="题目">题目</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">i=i++;</span><br><span class="line"><span class="type">int</span> j=i++;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i+ ++i * i++;</span><br><span class="line">System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">System.out.println(<span class="string">&quot;j=&quot;</span>+j);</span><br><span class="line">System.out.println(<span class="string">&quot;k=&quot;</span>+k);</span><br></pre></td></tr></table></figure>
<h2 id="讲解">讲解</h2>
<h3
id="对于操作数栈和局部变量表的理解">对于操作数栈和局部变量表的理解</h3>
<ul>
<li><p>对于下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> j=<span class="number">9</span>;</span><br><span class="line">j=i;</span><br></pre></td></tr></table></figure>
<p>反编译之后，查看字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"><span class="number">2</span> istore_1</span><br><span class="line"><span class="number">3</span> bipush <span class="number">9</span></span><br><span class="line"><span class="number">5</span> istore_2</span><br><span class="line"><span class="number">6</span> iload_1</span><br><span class="line"><span class="number">7</span> istore_2</span><br><span class="line"><span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>如下图，这三行代码，是依次把10，9先放到局部变量表的1，2位置。<br />
之后呢，再把局部变量表中1位置的值，放入操作数栈中<br />
最后，将操作数栈弹出一个数(10)，将数值赋给局部变量表中的位置2</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220921114316189.png"
alt="image-20220921114316189" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220921122617548.png"
alt="image-20220921122617548" />
如上图，当方法为静态方法时，局部变量表0位置存储的是实参第1个数</p>
<p>(当方法为非静态方法时，局部变量表0位置存储的是this引用)</p></li>
<li><p>对于下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> j=<span class="number">20</span>;</span><br><span class="line">i=i++;</span><br><span class="line">j=++j;</span><br><span class="line">System.out.println(i);</span><br><span class="line">System.out.println(j);</span><br></pre></td></tr></table></figure>
<p>编译后的字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">20</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">10</span> istore_1</span><br><span class="line"><span class="number">11</span> iinc <span class="number">2</span> by <span class="number">1</span></span><br><span class="line"><span class="number">14</span> iload_2</span><br><span class="line"><span class="number">15</span> istore_2</span><br><span class="line"><span class="number">16</span> getstatic #<span class="number">5</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span><br><span class="line"><span class="number">19</span> iload_1</span><br><span class="line"><span class="number">20</span> invokevirtual #<span class="number">6</span> &lt;java/io/PrintStream.println : (I)V&gt;</span><br><span class="line"><span class="number">23</span> getstatic #<span class="number">5</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;</span><br><span class="line"><span class="number">26</span> iload_2</span><br><span class="line"><span class="number">27</span> invokevirtual #<span class="number">6</span> &lt;java/io/PrintStream.println : (I)V&gt;</span><br><span class="line"><span class="number">30</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>如上对于j = ++j ;是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">11</span> iinc <span class="number">2</span> by <span class="number">1</span></span><br><span class="line"><span class="number">14</span> iload_2</span><br><span class="line"><span class="number">15</span> istore_2</span><br></pre></td></tr></table></figure>
<p>先对局部变量表2中的 值 加1，然后将结果
放入操作数栈中，之后再将操作数栈弹出一个数并赋值给 位置2</p></li>
</ul>
<h3 id="对于题目的解释">对于题目的解释</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">i=i++;</span><br><span class="line"><span class="type">int</span> j=i++;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i+ ++i * i++;</span><br><span class="line">System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">System.out.println(<span class="string">&quot;j=&quot;</span>+j);</span><br><span class="line">System.out.println(<span class="string">&quot;k=&quot;</span>+k);</span><br></pre></td></tr></table></figure>
<p>编译后的字节码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> <span class="number">1</span> istore_1</span><br><span class="line"> <span class="number">2</span> iload_1</span><br><span class="line"> <span class="number">3</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"> <span class="number">6</span> istore_1</span><br><span class="line"> <span class="number">7</span> iload_1</span><br><span class="line"> <span class="number">8</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">11</span> istore_2</span><br><span class="line"><span class="number">12</span> iload_1</span><br><span class="line"><span class="number">13</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">16</span> iload_1</span><br><span class="line"><span class="number">17</span> iload_1</span><br><span class="line"><span class="number">18</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">21</span> imul</span><br><span class="line"><span class="number">22</span> iadd</span><br><span class="line"><span class="number">23</span> istore_3</span><br></pre></td></tr></table></figure>
<p>对于 int j = i++</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">7</span> iload_1</span><br><span class="line"> <span class="number">8</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">11</span> istore_2</span><br></pre></td></tr></table></figure>
<p>先将i的值放进栈中，然后将局部变量表中的i + 1，之后将栈中的值赋值给j
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220921135728555.png"
alt="image-20220921135728555" /></p>
<p>到这步骤的时候，i = 2 ，j = 1</p>
<p>最后一步 int k = i+ ++i * i++</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span> iload_1</span><br><span class="line"><span class="number">13</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">16</span> iload_1</span><br><span class="line"><span class="number">17</span> iload_1</span><br><span class="line"><span class="number">18</span> iinc <span class="number">1</span> by <span class="number">1</span></span><br><span class="line"><span class="number">21</span> imul</span><br><span class="line"><span class="number">22</span> iadd</span><br><span class="line"><span class="number">23</span> istore_3</span><br></pre></td></tr></table></figure>
<p>如字节码所示，先将i load进操作数栈中(2)，然后将局部变量表中的i 自增
(3)，之后将自增后的结果(3)放入操作数栈中，第二次将局部变量表中的i放入操作数栈中。然后此时操作数栈中存在
3 3 2 (由栈顶到栈底) ，依次进行乘法加法 （3*3+2） =11 ，放入局部变量表3
中。 所以结果为 2， 1，11</p>
<h3 id="小结">小结</h3>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220921140923018.png" /></p>
<p>​</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>单例设计模式</title>
    <url>/2022/09/21/review/basics/singleton_design_pattern/</url>
    <content><![CDATA[<h2 id="特点">特点</h2>
<ul>
<li>该类只有一个实例
<ul>
<li>构造器私有化</li>
</ul></li>
<li>该类内部自行创建该实例
<ul>
<li>使用静态变量保存</li>
</ul></li>
<li>能向外部提供这个实例
<ul>
<li>直接暴露</li>
<li>使用静态变量的get方法获取</li>
</ul></li>
</ul>
<h2 id="几大方法">几大方法</h2>
<h3 id="饿汉式">饿汉式</h3>
<p>随着类的加载进行初始化，不管是否需要都会直接创建实例对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 INSTANCE=<span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举">枚举</h3>
<p>枚举类表示该类型的对象是有限的几个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">	 INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用静态代码块">使用静态代码块</h3>
<p>随着类的加载进行初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton2 INSTANCE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如图，当初始化实例时需要进行复杂取值操作时，可以取代第一种方法 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220921143557083.png"
alt="image-20220921143557083" /></p>
<h3 id="懒汉式">懒汉式</h3>
<ul>
<li><p>延迟创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> &#123;</span><br><span class="line">	<span class="comment">//为了防止重排序，需要添加volatile关键字</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton4 INSTANCE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * double check</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//2 先判断一次,对于后面的操作(此时已经创建了对象)能减少加锁次数</span></span><br><span class="line">		<span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果这里不加锁会导致线程安全问题，可能刚进了判断语句之后，执行权被剥夺了又创建好了对象，</span></span><br><span class="line">			<span class="comment">//所以判断及创建对象必须是原子操作</span></span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line">				<span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="comment">//用来模拟多线程被剥夺执行权</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//如果这个地方不加volatile,会出现的问题是,指令重排 1,2,3是正常的,</span></span><br><span class="line">					<span class="comment">//会重排成1,3,2 然后别的线程去拿的时候，判断为非空，但是实际上运行的时候，发现里面的数据是空的</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">//1 memory = allocate();//分配对象空间</span></span><br><span class="line">					<span class="comment">//2 instance(memory); //初始化对象</span></span><br><span class="line">					<span class="comment">//3 instance = memory; //设置instance指向刚刚分配的位置</span></span><br><span class="line">					INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> INSTANCE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用静态内部类">使用静态内部类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton6</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton6</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton6 INSTANCE=<span class="keyword">new</span> <span class="title class_">Singleton6</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>只有当内部类被加载和初始化的时候，才会创建INSTANCE实例对象</li>
<li>静态内部类不会自动随着外部类的加载和初始化而初始化，他需要单独去加载和初始化</li>
<li>又由于他是在内部类加载和初始化时，创建的，属于类加载器处理的，所以是线程安全的</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域及事务</title>
    <url>/2022/09/23/review/ssm/scope_transaction/</url>
    <content><![CDATA[<h2 id="四种作用域">四种作用域</h2>
<ul>
<li>singleton：默认值，当IOC容器一创建就会创建bean实例，而且是单例的，每次得到的是同一个</li>
<li>prototype：原型的，IOC容器创建时不再创建bean实例。每次调用getBean方法时再实例化该bean（每次都会进行实例化）</li>
<li>request：每次请求会实例化一个bean</li>
<li>session：在一次会话中共享一个bean</li>
</ul>
<h2 id="事务">事务</h2>
<h3 id="事务是什么">事务是什么</h3>
<p>逻辑上的一组操作，要么都执行，要么都不执行</p>
<h3 id="事务的特性">事务的特性</h3>
<p>ACID</p>
<ul>
<li>Atomicity <code>/ˌætəˈmɪsəti/</code>原子性 ,
要么全部成功，要么全部失败</li>
<li>Consistency <code>/kənˈsɪstənsi/</code> 一致性 , 数据库的完整性</li>
<li>Isolation <code>/ˌaɪsəˈleɪʃn/</code> 隔离性 ,
数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致
, 这里涉及到事务隔离级别</li>
<li>Durability <code>/ˌdjʊərəˈbɪləti/</code> 持久性 ,
事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</li>
</ul>
<h3 id="spring支持两种方式的事务管理">Spring支持两种方式的事务管理</h3>
<ul>
<li><p>编程式事务管理 <figure class="highlight plaintext"><figcaption><span>execute</span></figcaption><table><tr><td class="code"><pre><span class="line">使用transactionTemplate</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Autowired</span><br><span class="line">private TransactionTemplate transactionTemplate;</span><br><span class="line">public void testTransaction() &#123;</span><br><span class="line"></span><br><span class="line">        transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) &#123;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line"></span><br><span class="line">                    // ....  业务代码</span><br><span class="line">                &#125; catch (Exception e)&#123;</span><br><span class="line">                    //回滚</span><br><span class="line">                    transactionStatus.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用transactionManager</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// ....  业务代码</span></span><br><span class="line">              transactionManager.commit(status);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              transactionManager.rollback(status);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明式事务管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">  <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">  b.bMethod();</span><br><span class="line">  c.cMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="事务传播行为">事务传播行为</h3>
<p>Definition <code>/ˌdefɪˈnɪʃ(ə)n/</code> 定义</p>
<p>Propagation <code>/ˌprɒpəˈɡeɪʃn/</code> 传播<br />
假设有代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    B b;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.XXXXXX)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共7种，其中主要有4种如下</p>
<ul>
<li><p><strong><code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong>
如果外部方法没有开启事务，则内部方法创建一个新的事务，即内外两个方法的事务互相独立；如果外部方法存在事务，则内部方法加入该事务，即内外两个方法使用同一个事务</p></li>
<li><p><strong><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong>
如果外部方法存在事务，则会挂起当前的事务，并且开启一个新事务，当外部方法抛出异常时，内部方法不会回滚；而当内部方法抛出异常时，外部方法会检测到并进行回滚。
如果外部方法不存在事务，则也会开启一个新事务</p></li>
<li><p><strong><code>TransactionDefinition.PROPAGATION_NESTED</code></strong>:
如果外部方法开启事务，则在内部再开启一个事务，作为嵌套事务存在；如果外部方法无事务，则单独开启一个事务</p>
<blockquote>
<p><strong>在外围方法开启事务的情况下<code>Propagation.NESTED</code>修饰的内部方法属于外部事务的子事务，外围主事务回滚，子事务一定回滚，而内部子事务可以单独回滚而不影响外围主事务和其他子事务，也就是和上面的PROPAGATION_REQUIRES_NEW相反</strong></p>
</blockquote></li>
<li><p><strong><code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong>
如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常 mandatory
<code>/ˈmændətəri/</code> 强制的</p></li>
<li><p>下面三个比较不常用</p>
<ul>
<li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>:
如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>:
以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>:
以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul></li>
</ul>
<h3 id="事务隔离级别">事务隔离级别</h3>
<ul>
<li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong>
读未提交，级别最低，允许读取尚未提交的数据，可能会导致脏读、幻读或不可重复读</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong>
读已提交，对同一字段的多次读取结果都是一致的。可以阻止脏读，但幻读或不可重复读仍会发生</li>
<li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong>
串行化，可以防止脏读、幻读及不可重复读，所有事务依次逐个执行，完全服从ACID，但严重影响性能</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>测试</title>
    <url>/2022/05/20/work/ztx/hg/</url>
    <content><![CDATA[<h2 id="问题">问题</h2>
]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>ztx</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础</title>
    <url>/2022/12/20/review/java_guide/database/basis/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<blockquote>
<p>这部分内容由于涉及太多概念性内容，所以参考了维基百科和百度百科相应的介绍。</p>
</blockquote>
<h1
id="什么是数据库数据库管理系统数据库系统数据库管理员">什么是数据库，数据库管理系统，数据库系统，数据库管理员</h1>
<ul>
<li><strong>数据库</strong>：数据库（<strong>DataBase
简称DB</strong>）就是<strong>信息的集合</strong>或者说<strong>数据库管理系统管理的数据的集合</strong>。</li>
<li><strong>数据库管理系统</strong>：数据库管理系统（<strong>Database
Management System
简称DBMS</strong>）是一种<strong>操纵和管理数据库</strong>的大型软件，通常用于建立、使用和维护
<strong>数据库</strong>。</li>
<li><strong>数据库系统（范围最大）</strong>：数据库系统（Data Base
System，简称DBS）通常由<strong>软件、数据和数据管理员（DBA）</strong>组成。</li>
<li><strong>数据库管理员</strong>：数据库管理员（Database
Adminitrator，简称DBA）负责全面<strong>管理和控制</strong>数据库系统
<strong>(是一个人)</strong></li>
</ul>
<p><strong>数据库系统基本构成</strong>如下图所示<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110143032664.png"
alt="image-20230110143032664" /></p>
<h1
id="什么是元组码候选码主码外码主属性非主属性">什么是元组，码，候选码，主码，外码，主属性，非主属性</h1>
<ul>
<li><strong>元组</strong>：元组（tuple）是<strong>关系数据库</strong>中的<strong>基本概念</strong>，<strong>关系</strong>是一张表，表中的<strong>每行</strong>（即数据库中的每条<strong>记录</strong>）就是一个元组，每列就是一个属性。在<strong>二维表</strong>里，元组也成为<strong>行</strong></li>
<li><strong>码</strong>：码就是能<strong>唯一标识实体</strong>的属性，对应表中的<strong>列</strong></li>
<li><strong>候选码</strong>：若关系中的<strong>某一属性</strong>或<strong>属性组的值</strong>能<strong>唯一的标识一个元组</strong>，而<strong>其任何、子集都不能再标识</strong>，则称该<strong>属性组</strong>为<strong>候选码</strong>。例如：在学生实体中，<strong>“学号”</strong>是能唯一的区分学生实体的，同时又假设<strong>“姓名”、“班级”的属性组合</strong>足以区分学生实体，那么<strong>{学号}</strong>和<strong>{姓名，班级}</strong>都是<strong>候选码</strong>。</li>
<li><strong>主码</strong>：主码也叫<strong>主键</strong>，主码是<strong>从候选码</strong>中选出来的。一个实体集中只能有<strong>一个主码</strong>，但可以有<strong>多个候选码</strong></li>
<li><strong>外码</strong>：外码也叫<strong>外键</strong>。如果<strong>一个关系中的一个属性</strong>是<strong>另外一个关系中的主码</strong>则这个属性为外码。</li>
<li><strong>主属性</strong> ：
<strong>候选码中出现过的属性</strong>称为主属性(<strong>这里强调单个</strong>）。比如关系
工人（工号，身份证号，姓名，性别，部门）.
显然<strong>工号和身份证号</strong>都能够唯一标示这个关系，所以都是候选码。<strong>工号、身份证号这两个属性就是主属性</strong>。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>
<li><strong>非主属性：</strong>
<strong>不包含在任何一个候选码中的属性</strong>称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li>
</ul>
<h1 id="主键和外键有什么区别">主键和外键有什么区别</h1>
<ul>
<li><strong>主键(主码)</strong>
：主键用于<strong>唯一标识一个元组</strong>，不能有重复，不允许为空。一个表只能有一个主键。</li>
<li><strong>外键(外码)</strong>
：外键用来和其他表建立联系用，<strong>外键是另一表的主键</strong>，外键是可以有重复的，可以是空值。一个表可以有多个外键</li>
</ul>
<h1 id="为什么不推荐使用外键与级联">为什么不推荐使用外键与级联</h1>
<ul>
<li><p>对于外键和级联，阿里巴巴开发手册这样说道</p>
<blockquote>
<p>【强制】不得使用外键与级联，一切<strong>外键概念</strong>必须在应用层解决。</p>
<p>说明: 以学生和成绩的关系为例，学生表中的 student_id
是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的
student_id，同时触发成绩表中的 student_id 更新，即为级联更新。</p>
<p>缺点：
<strong>外键与级联更新适用于单机低并发，不适合分布式、高并发集群;
级联更新是强阻塞，存在数据库更新风暴的风 险;
外键影响数据库的插入速度</strong></p>
</blockquote></li>
<li><p>为什么不要使用外键</p>
<ol type="1">
<li><p>增加了复杂性</p>
<blockquote>
<ol type="a">
<li>每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦,
<strong>测试数据极为不方便</strong>; b.
外键的主从关系是定的，假如那天需求有变化，<strong>数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦</strong>。</li>
</ol>
</blockquote></li>
<li><p>增加了额外操作</p>
<blockquote>
<p>数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（<strong>个人觉得这个不是不用外键的原因</strong>，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</p>
</blockquote></li>
<li><p>对分库分表很不友好：因为分库分表下外键无法生效</p></li>
<li><p>...</p></li>
</ol></li>
<li><p>外键的一些好处</p>
<ol type="1">
<li>保证了<strong>数据库数据的一致性和完整性</strong>；</li>
<li>级联操作方便，<strong>减轻了程序代码量</strong>；</li>
<li>......</li>
</ol>
<p><strong>如果系统不涉及分库分表</strong>，<strong>并发量不是很高</strong>的情况还是可以考虑使用外键的</p></li>
</ul>
<h1 id="什么是er图">什么是ER图</h1>
<blockquote>
<p>做一个项目的时候一定要试着<strong>画 ER
图来捋清数据库设计</strong>，这个也是面试官问你项目的时候经常会被问道的。</p>
</blockquote>
<ul>
<li>E-R图，也称 <strong>实体-联系图（Entity Relationship
Diagram）</strong>，提供表示<strong>实体类型</strong>、<strong>属性</strong>和<strong>关系</strong>，用来描述现实世界的<strong>概念模型</strong>。它是描述<strong>现实世界关系概念模型</strong>的有效方法，是<strong>表示概念关系模型</strong>的一种方式</li>
<li>下图是一个学生选课的 ER
图，<strong>每个学生可以选若干门课程</strong>，<strong>同一门课程也可以被若干人选择</strong>，所以它们之间的关系是<strong>多对多（M:
N）</strong>。另外，还有<strong>其他两种关系</strong>是：<strong>1 对
1（1:1）</strong>、<strong>1 对多（1: N）</strong> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110151637953.png"
alt="image-20230110151637953" />
将<strong>ER图</strong>转换成<strong>数据库实际的关系模型</strong>（实际设计中，我们通常会将任课教师也作为一个实体来处理）<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110151807973.png"
alt="image-20230110151807973" /></li>
</ul>
<h1 id="数据库范式了解吗">数据库范式了解吗</h1>
<ol type="1">
<li><p><strong>1NF(第一范式)</strong>
属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，<strong>不能再分为多个其他的字段</strong>了。<strong>1NF
是所有关系型数据库的最基本要求</strong>
，也就是说关系型数据库中创建的表一定满足第一范式。</p></li>
<li><p><strong>2NF(第二范式)</strong> 2NF 在 1NF
的基础之上，<strong>消除了非主属性对于码的部分函数依赖</strong>。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p>
<blockquote>
<p>第二范式要求，在满足第二范式的基础上，还要满足数据表里得每一条数据记录，都是可唯一标识的。而且所有<strong>非主键字段</strong>，都必须完全依赖主键，不能只依赖主键的一部分，如下，主键为商品名称、供应商名称，是主码是<strong>属性组</strong>。而供应商电话只依赖于供应商id，商品价格只依赖于价格。所以不满足第二范式</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110153212488.png"
alt="image-20230110153212488" />
<figcaption aria-hidden="true">image-20230110153212488</figcaption>
</figure></li>
<li><p><strong>3NF(第三范式)</strong>3NF 在 2NF
的基础之上，消除了<strong>非主属性对于码的传递函数依赖</strong> 。符合
3NF
要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系
R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 →
系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合
3NF 的要求。</p>
<blockquote>
<p>确保数据表中的每一个非主键字段都和主键字段相关，也就是说，要求数据表中的所有<strong>非主键字段</strong>不能依赖于其他<strong>非主键字段</strong>。（即，不能存在非主属性A依赖于非主属性B，非主属性B依赖于主键C的情况，即存在A
--&gt; B --&gt; C
的决定关系），规则的意思是<strong>所有非主键属性之间</strong>不能有依赖关系，必须互相独立</p>
<blockquote>
<p>简单举例：<br />
部门信息表：每个部门有<strong>部门编号(dept_id)</strong>、<strong>部门名称</strong>、<strong>部门简介</strong>等消息<br />
员工信息表：每个员工有<strong>员工编号</strong>、<strong>姓名</strong>、<strong>部门编号</strong>。（注意，列出部门编号就不能再将部门名称、部门简介等部门相关的信息再加入员工信息表中，否则将不满足第3范式（但其实是满足第二范式的））</p>
</blockquote>
</blockquote></li>
</ol>
<p>总结</p>
<ul>
<li>1NF：属性<strong>不可再分</strong>。</li>
<li>2NF：1NF
的基础之上，<strong>消除了非主属性对于码的部分函数依赖</strong>。</li>
<li>3NF：3NF 在 2NF
的基础之上，消除了<strong>非主属性对于码的传递函数依赖</strong> 。</li>
</ul>
<blockquote>
<p>一些概念：</p>
<ul>
<li><strong>函数依赖（functional dependency）</strong>
：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y
的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</li>
<li><strong>部分函数依赖（partial functional dependency）</strong>
：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X
部分函数依赖。比如学生基本信息表 R
中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R
关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以<strong>姓名部分函数依赖与（学号，身份证号）</strong>；<strong>（感觉这个例子虽然是对的，但是不利于理解第二范式）</strong></li>
<li><strong>完全函数依赖(Full functional dependency)</strong>
：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表
R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在
R
关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li>
<li><strong>传递函数依赖</strong> ： 在关系模式 R(U)中，设 X，Y，Z 是 U
的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定
X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional
dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和
Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系
R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 →
系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li>
</ul>
</blockquote>
<h1 id="什么是存储过程">什么是存储过程</h1>
<ul>
<li><p>作用：我们可以把存储过程看成是一些 <strong>SQL
语句的集合</strong>，中间加了点逻辑控制语句。存储过程在业<strong>务比较复杂的时候是非常实用</strong>的，比如很多时候我们完成一个操作可能需要写一大串
SQL
语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。<strong>存储过程一旦调试完成通过后就能稳定运行</strong>，另外，使用<strong>存储过程比单纯
SQL
语句执行要快</strong>，因为<strong>存储过程是预编译过</strong>的。</p></li>
<li><p>存储过程在互联网公司应用不多，因为存储过程<strong>难以调试</strong>和<strong>扩展</strong>，而且<strong>没有移植性</strong>，还会消耗<strong>数据库资源</strong></p>
<blockquote>
<p>阿里巴巴Java开发手册要求禁止使用存储过程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/0fa082bc4d4f919065767476a41b2156.png"
alt="阿里巴巴Java开发手册: 禁止存储过程" /></p>
</blockquote></li>
</ul>
<h1 id="dropdelete与truncate区别">drop、delete与truncate区别</h1>
<h2 id="用法不同">用法不同</h2>
<ul>
<li>drop(丢弃数据): <code>drop table 表名</code>
，直接<strong>将表都删除掉</strong>，在删除表的时候使用。</li>
<li>truncate (清空数据) : <code>truncate table 表名</code>
，只<strong>删除表中的数据</strong>，再<strong>插入数据的时候自增长 id
又从 1 开始</strong>，在清空表中数据的时候使用。</li>
<li>delete（删除数据） :
<code>delete from 表名 where 列名=值</code>，<strong>删除某一行的数据，如果不加
where 子句和<code>truncate table 表名</code>作用类似</strong>。</li>
</ul>
<p>truncate 和不带 where 子句的 delete、以及 drop
都会删除表内的数据，但是 <strong>truncate 和 delete
只删除数据不删除表的结构(定义)，执行 drop
语句，此表的结构也会删除，也就是执行 drop
之后对应的表不复存在。</strong></p>
<h2 id="属于不同的数据库语言">属于不同的数据库语言</h2>
<ul>
<li><strong>truncate 和 drop 属于
DDL(数据定义语言)语句，操作立即生效</strong>，原数据<strong>不放到
rollback segment</strong>
中，<strong>不能回滚</strong>，操作<strong>不触发 trigger</strong>。而
<strong>delete 语句是 DML (数据库操作语言)</strong>语句，这个操作会放到
<strong>rollback segement</strong>
中，<strong>事务提交之后才生效</strong>。</li>
<li>DML语句和DDL语句区别
<ol type="1">
<li>DML 是<strong>数据库操作语言（Data Manipulation
Language）</strong>的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。</li>
<li><strong>DDL （Data Definition
Language）</strong>是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和
DML 语言的最大区别是 DML
只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。<strong>DDL
语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用</strong>。</li>
</ol></li>
<li>由于<code>select</code>不会对表进行破坏，所以有的地方也会把<code>select</code>单独区分开叫做数据库查询语言<strong>DQL（Data
Query Language）</strong></li>
</ul>
<h2 id="执行速度不同">执行速度不同</h2>
<ul>
<li><p>一般来说：drop &gt; truncate &gt;
delete（这个我没有设计测试过）</p>
<blockquote>
<p><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</p>
<p><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</p>
<p><code>drop</code>命令会把表占用的空间全部释放掉。</p>
<p>Tips：你应该更多地关注在使用场景上，而不是执行效率。</p>
</blockquote></li>
</ul>
<h1 id="数据库设计通常分为哪几步">数据库设计通常分为哪几步</h1>
<ol type="1">
<li><strong>需求分析</strong> :
分析用户的需求，包括数据、功能和性能需求。</li>
<li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画
E-R 图。</li>
<li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R
模型到关系模型的转换。</li>
<li><strong>物理结构设计</strong> :
主要是为所设计的数据库选择合适的存储结构和存取路径。</li>
<li><strong>数据库实施</strong> : 包括编程、测试和试运行</li>
<li><strong>数据库的运行和维护</strong> :
系统的运行与数据库的日常维护。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-database</tag>
      </tags>
  </entry>
  <entry>
    <title>字符集详解</title>
    <url>/2023/01/10/review/java_guide/database/charactor-set/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<ul>
<li>MySQL字符编码集有<strong>两套UTF-8</strong>编码实现：<strong>utf-8</strong>
和 <strong>utf8mb4</strong><br />
而其中，utf-8
<strong>不支持存储</strong>emoji符号和一些比较复杂的汉字、繁体字，会出错</li>
</ul>
<h1 id="何为字符集">何为字符集</h1>
<ul>
<li>字符是<strong>各种文字</strong>和<strong>符号</strong>的统称，包括<strong>各个国家文字</strong>、<strong>标点符号</strong>、<strong>表情</strong>、<strong>数字</strong>等等
<ul>
<li>字符集就是<strong>一系列字符</strong>的集合，字符集的种类较多，每个字符集可以表示的<strong>字符范围</strong>通常不同，就比如说<strong>有些字符集</strong>无法表示汉字</li>
</ul></li>
<li>计算机只能存储<strong>二进制</strong>的数据，那<strong>英文</strong>、<strong>汉字</strong>、<strong>表情</strong>等字符应该如何存储呢
<ul>
<li>我们要将这些<strong>字符和二进制的数据一一对应</strong>起来，比如说字符“a”对应“01100001”，反之，“01100001”对应
“a”。我们将字符对应二进制数据的过程称为"<strong>字符编码</strong>"，反之，二进制数据解析成字符的过程称为“<strong>字符解码</strong>”。</li>
</ul></li>
</ul>
<h1 id="有哪些常见的字符集">有哪些常见的字符集</h1>
<ul>
<li>常见的字符集有<strong>ASCLL</strong>、<strong>GB2312</strong>、<strong>GBK</strong>、<strong>UTF-8</strong></li>
<li>不同的字符集的主要区别在于
<ol type="1">
<li>可以表示的<strong>字符范围</strong></li>
<li><strong>编码方式</strong></li>
</ol></li>
</ul>
<h2 id="ascll">ASCLL</h2>
<ul>
<li><p><strong>ASCII</strong> (<strong>A</strong>merican
<strong>S</strong>tandard <strong>C</strong>ode for
<strong>I</strong>nformation
<strong>I</strong>nterchange，美国信息交换标准代码)
是一套主要用于现代美国英语的字符集（这也是 ASCII
字符集的局限性所在）</p>
<blockquote>
<p><strong>为什么 ASCII 字符集没有考虑到中文等其他字符呢？</strong>
因为计算机是美国人发明的，当时，计算机的发展还处于比较雏形的时代，还未在其他国家大规模使用。因此，美国发布
ASCII 字符集的时候没有考虑兼容其他国家的语言</p>
</blockquote></li>
<li><p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33
个控制字符（比如回车、删除）无法显示</p></li>
<li><p>一个 ASCII 码长度是一个字节也就是 8 个 bit，比如“a”对应的 ASCII
码是“01100001”。不过，最高位是 0 仅仅作为校验位，其余 7 位使用 0 和 1
进行组合，所以，ASCII 字符集可以定义 128（2^7）个字符</p>
<blockquote>
<p>由于，ASCII
码可以表示的字符实在是太少了。后来，人们对其进行了扩展得到了
<strong>ASCII 扩展字符集</strong> 。ASCII 扩展字符集使用 8
位（bits）表示一个字符，所以，ASCII 扩展字符集可以定义
256（2^8）个字符</p>
</blockquote></li>
<li><p>总共128个，下面少了33个无法显示的<strong>控制字符</strong> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/c1c6375d08ca268690cef2b13591a5b4.png"
alt="ASCII字符编码" /></p></li>
</ul>
<h2 id="gb2312">GB2312</h2>
<blockquote>
<p>我们上面说了，ASCII
字符集是一种现代美国英语适用的字符集。因此，很多国家都捣鼓了一个适合自己国家语言的字符集。</p>
</blockquote>
<ul>
<li>GB2312
字符集是一种<strong>对汉字比较友好</strong>的字符集，共<strong>收录 6700
多个汉字</strong>，<strong>基本涵盖了绝大部分常用汉字</strong>。不过，GB2312
字符集<strong>不支持绝大部分的生僻字和繁体字</strong></li>
<li>（<strong>对于中英文字符，使用的字节数不一样 ( 1和2 )</strong>
）对于英语字符，GB2312 编码和 ASCII 码是相同的，1
字节编码即可。对于非英字符，需要 2 字节编码。</li>
</ul>
<h2 id="gbk">GBK</h2>
<p>GBK 字符集可以看作是 <strong>GB2312 字符集的扩展</strong>，兼容
GB2312 字符集，共收录了 20000 多个汉字。</p>
<p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母</p>
<h2 id="gb18030">GB18030</h2>
<p><strong>GB18030 完全兼容 GB2312 和 GBK
字符集</strong>，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止<strong>最全面的汉字字符集</strong>，共收录汉字
70000 多个</p>
<h2 id="big5">BIG5</h2>
<p>BIG5 主要针对的是<strong>繁体中文</strong>，收录了 13000
多个汉字。</p>
<h2 id="unicode-utf-8编码">Unicode &amp; UTF-8编码</h2>
<blockquote>
<p>了更加适合本国语言，诞生了很多种字符集。</p>
<p>我们上面也说了不同的字符集可以表示的字符范围以及编码规则存在差异。这就导致了一个非常严重的问题：<strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong>
就比如说你使用 UTF-8 编码方式打开 GB2312
编码格式的文件就会出现乱码。示例：“牛”这个汉字 GB2312
编码后的十六进制数值为 “C5A3”，而 “C5A3” 用 UTF-8 解码之后得到的却是
“ţ”。</p>
</blockquote>
<p>你可以通过这个网站在线进行编码和解码：https://www.haomeili.net/HanZi/ZiFuBianMaZhuanHuan
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/836c49b117ee4408871b0020b74c991d.png"
alt="img" /></p>
<p>乱码的本质：<strong>编码</strong>和<strong>解码</strong>时用了不同或者不兼容的字符集</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/a8808cbabeea49caa3af27d314fa3c02-1.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li><p>如果我们能够有一种字符集将世界上所有的字符都纳入其中就好了，于是Unicode带着这个使命诞生了。</p>
<blockquote>
<p>Unicode 字符集中包含了世界上几乎所有已知的字符。不过，<strong>Unicode
字符集并没有规定如何存储这些字符</strong>（也就是如何使用二进制数据表示这些字符）<br />
于是有了 <strong>UTF-8</strong>（<strong>8</strong>-bit
<strong>U</strong>nicode <strong>T</strong>ransformation
<strong>F</strong>ormat）。类似的还有 UTF-16、 UTF-32</p>
</blockquote></li>
<li><p>其中，UTF-8
使用1-4个字节为每个字符编码，UTF-16使用2或4个字节为每个字符编码，UTF-32<strong>固定</strong>使用4个字节为每个字符编码</p></li>
<li><p>UTF-8
可以<strong>根据不同的符号自动选择编码的长短</strong>，像<strong>英文字符只需要
1 个字节</strong>就够了，这一点 <strong>ASCII 字符集</strong>一样
。因此，<strong>对于英语字符，UTF-8 编码和 ASCII
码是相同</strong>的</p></li>
<li><p>UTF-32
的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是 UTF-8
的 4 倍之多。</p></li>
<li><p><strong>UTF-8</strong> 是目前使用最广的一种字符编码 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1280px-Utf8webgrowth.svg.png"
alt="img" /></p></li>
</ul>
<h1 id="mysql字符集">MySQL字符集</h1>
<ul>
<li><p>MySQL支持很多字符编码的方式，比如UTF-8，GB2312，GBK，BIG5</p></li>
<li><p>使用<code>SHOW CHARSET</code>命令查看 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20211008164229671.png"
alt="img" /></p></li>
<li><p><strong>通常情况下</strong>，我们建议使用UTF-8作为默认的字符编码方式</p></li>
<li><p>然而，MySQL字符编码中有两套UTF-8编码实现</p>
<ul>
<li>utf-8：<code>utf8</code>编码只支持<code>1-3</code>个字节 。 在
<code>utf8</code> 编码中，中文是占 3
个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4
个字节，一些较复杂的文字、繁体字也是 4 个字节</li>
<li><strong><code>utf8mb4</code></strong> ： UTF-8
的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储
emoji 符号</li>
</ul></li>
<li><p>为何会有两套UTF-8编码实现，原因如下 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20211008164542347.png"
alt="img" />
因此，如果你需要存储<code>emoji</code>类型的数据或者一些比较复杂的文字、繁体字到
MySQL 数据库的话，数据库的编码一定要指定为<code>utf8mb4</code>
而不是<code>utf8</code> ，要不然存储的时候就会报错了。 测试：</p>
<ol type="1">
<li><p>环境，MySQL 5.7 + 建表语句： ，这里指定数据库CHARSET为utf8</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` varchar(<span class="number">66</span>)   NOT NULL,</span><br><span class="line">  `name` varchar(<span class="number">33</span>)    NOT NULL,</span><br><span class="line">  `phone` varchar(<span class="number">33</span>)    DEFAULT NULL,</span><br><span class="line">  `password` varchar(<span class="number">100</span>)   DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8; </span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">66</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">33</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">33</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">100</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="comment">------</span></span><br><span class="line">这边应该是写错了，如果是这个<span class="keyword">sql</span>，是可以插入成功的</span><br><span class="line">著作权归所有</span><br><span class="line">原文链接：https:<span class="operator">/</span><span class="operator">/</span>javaguide.cn<span class="operator">/</span>database<span class="operator">/</span><span class="type">character</span><span class="operator">-</span>set.html</span><br></pre></td></tr></table></figure></li>
<li><p>插入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`id`, `name`, `phone`, `password`)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">	(<span class="string">&#x27;A00003&#x27;</span>, <span class="string">&#x27;guide哥😘😘😘&#x27;</span>, <span class="string">&#x27;181631312312&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 报错</span></span><br><span class="line"> Incorrect string <span class="keyword">value</span>: <span class="string">&#x27;\xF0\x9F\x98\x98\xF0\x9F...&#x27;</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-database</tag>
      </tags>
  </entry>
  <entry>
    <title>算法红皮书 1.1.1-1.1.5</title>
    <url>/2022/02/21/study/algorithm/algorithhms_4th/1.1.1-1.1.5/</url>
    <content><![CDATA[<h2 id="基础编程模型">基础编程模型</h2>
<h3 id="java程序的基本结构">Java程序的基本结构</h3>
<ul>
<li>本书学习算法的方法：用Java编程语言编写的程序来实现算法(相比用自然语言有很多优势)</li>
<li>劣势：编程语言特定，使算法的思想和实现细节变得困难(所以本书尽量使用大部分语言都必须的语法)</li>
<li>把描述和实现算法所用到的语言特性、软件库和操作系统特定总称为基础编程模型</li>
<li>Java程序的基本结构
<ul>
<li><p>一段Java程序或者是一个静态方法库，或者定义了一个数据类型，需要用到的语法</p>
<ul>
<li>原始数据类型(在计算机中精确地定义整数浮点数布尔值等)</li>
<li>语句(创建变量并赋值，控制运行流程或引发副作用来进行计算，包括声明、赋值、条件、循环、调用和返回)</li>
<li>数组(多个同种数据类型值的集合)</li>
<li>静态方法(封装并重用代码)</li>
<li>字符串(一连串的字符，内置一些对他们的操作)</li>
<li>标准输入/输出(是程序与外界联系的桥梁)</li>
<li>数据抽象(数据抽象封装和重用代码，可以定义非原始数据类型，进而面向对象编程)</li>
</ul></li>
<li><p>把这种输入命令执行程序的环境称为 虚拟终端</p></li>
<li><p>要执行一条Java程序，需要先用javac命令编译，然后用java命令运行，比如下面的文件，需要使用命令</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac BinarySearch.java</span><br><span class="line">java BinarySearch </span><br></pre></td></tr></table></figure></p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645434867646.png" /><br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645434894479.png" /></p></li>
</ul></li>
</ul>
<h3 id="原始数据类型与表达式">原始数据类型与表达式</h3>
<ul>
<li>数据类型就是一组数据和其所能进行的操作的集合</li>
<li>Java中最基础的数据类型(整型int，双精度实数类型double,布尔值boolean,字符型char)</li>
<li>Java程序控制用标识符命名的变量</li>
<li>对于原始类型，用标识符引用变量，+-*/指定操作，用字面量来表示值(如1或3.14),用表达式表示对值的操作(
表达式:(x+2.334)/2 )</li>
<li>只要能够指定值域和在此值域上的操作，就能定义一个数据类型(很像数学上函数的定义)</li>
<li>+-*/是被重载过的</li>
<li>运算产生的数据的数据类型和参与运算的数据的数据类型是相同的(5/3=1,5.0/3.0=1.6667等)</li>
<li>如下图(图歪了亿点点..) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645435436655.png" /><br />
</li>
<li>表达式</li>
<li>表达式具有优先级，Java使用的是中缀表达式(一个字面量紧接运算符，然后是另一个字面量)。逻辑运算中优先级
! &amp;&amp; || ,运算符中 * / % 高于+ -
。括号能改变这些规则。代码中尽量使用括号消除对优先级的依赖</li>
<li>类型转换
<ul>
<li>数值会自动提升为高级数据类型，如1+2.5 1会被先转为double
1.0，值也为double的3.5</li>
<li>强转(把类型名放在括号里讲其转换为括号中的类型)
讲高级数据类型转为低级可能会导致精度的缺失，尽量少使用</li>
</ul></li>
<li>比较
<ul>
<li>==、!=、&lt;、&lt;=、&gt;、&gt;=，这些运算符称为
混合类型运算符，因为结果是布尔型而不是参与比较的数据类型</li>
<li>结果是布尔型的表达式称为布尔表达式</li>
</ul></li>
<li>其他原始类型(int为32位，double为64位)
<ul>
<li>long,64位整数</li>
<li>short,16位整数</li>
<li>char,16位字符</li>
<li>byte,8位整数</li>
<li>32位单精度实数,float ### 语句</li>
</ul></li>
<li>语句用来创建和操作变量、对变量赋值并控制操作的执行流程</li>
<li>包括声明语句、赋值语句、条件语句、循环语句、调用和返回语句</li>
<li>声明：让一个变量名和一个类型在编译时关联起来</li>
<li>赋值：将(由一个表达式定义的)某个数据类型额值和一个变量关联起来</li>
<li>条件语句： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (&lt;boolean expression&gt;) &#123; &lt;block statement&gt; &#125;</span><br></pre></td></tr></table></figure></li>
<li>循环语句 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(&lt;boolean expression&gt;) &#123; &lt;block statement&gt; &#125;</span><br></pre></td></tr></table></figure> 其中循环语句中的代码段称为循环体</li>
<li>break与continue语句
<ul>
<li>break，立即退出循环</li>
<li>continue，立即开始下一轮循环 ### 简便记法</li>
<li>声明并初始化</li>
<li>隐式赋值
<ul>
<li>++i;--i</li>
<li>i/=2;i+=1</li>
</ul></li>
<li>单语句代码段(省略if/while代码段的花括号)</li>
<li>for语句 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(&lt;initialize&gt;;&lt;boolean expression&gt;;&lt;increment&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;block statements&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这段代码等价于后面的 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;initialize&gt;;</span><br><span class="line">while(&lt;boolean expression&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  &lt;block statments&gt;</span><br><span class="line">  &lt;increment&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>java语句总结<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645493111378.png" />
### 数组</li>
</ul></li>
<li>数组能够存储相同类型的多个数据</li>
<li>N个数组的数组编号为0至N-1；这种数组在Java中称为一维数组</li>
<li>创建并初始化数组
<ul>
<li>需要三个步骤，声明数组名字和类型，创建数组，初始化数组元素</li>
<li>声明并初始化一个数组<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645493370383.png" /></li>
<li>简化写法<br />
double[] a = new double[N];</li>
<li>使用数组(访问的索引小于0或者大于N-1时会抛出ArrayIndexOutOfBoundsException)</li>
<li>典型的数组处理代码<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645493720043.png" /></li>
</ul></li>
<li>起别名
<ul>
<li>下面的情况并没有将数组新复制一份，而是a，b指向了同一个数组<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645493897849.png" /></li>
</ul></li>
<li>二维数组
<ul>
<li>Java中二维数组就是一堆数组的数组</li>
<li>二维数组可以是参差不齐，比如a[0]=new double[5],a[1]=new
double[6]之类</li>
<li>二维数组的创建及初始化 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double[][] a;</span><br><span class="line">a = new double[M][N];</span><br><span class="line">for (int i = 0; i &lt; M; i++)</span><br><span class="line">    for (int j = 0; j &lt; N; j++)</span><br><span class="line">        a[i][j] = 0.0;</span><br></pre></td></tr></table></figure></li>
<li>精简后的代码 double[][] a=new double[M][N];</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法红皮书(第四版)</tag>
      </tags>
  </entry>
  <entry>
    <title>算法红皮书 1.1.6-1.1.11</title>
    <url>/2022/02/22/study/algorithm/algorithhms_4th/1.1.6-1.1.11/</url>
    <content><![CDATA[<h2 id="基础编程模型">基础编程模型</h2>
<h3 id="静态方法">静态方法</h3>
<ul>
<li>本书中所有的Java程序要么是数据类型的定义，要么是一个静态方法库</li>
<li>当讨论静态方法和实体方法共有的属性时，我们会使用不加定语的方法一词</li>
<li>方法需要参数(某种数据类型的值)并根据参数计算出某种数据类型的返回值(例如数学函数的结果)或者产生某种副作用(例如打印一个值)</li>
<li>静态方法由签名(public static
以及函数的返回值,方法名及一串参数)和函数体组成</li>
<li>调用静态方法(写出方法名并在后面的括号中列出数值)</li>
<li>方法的性质
<ul>
<li>方法的参数按值传递，方法中使用的参数变量能够引用调用者的参数并改变其内容(只是不能改变<strong><em>原数组变量</em></strong>本身)</li>
<li>方法名可以被重载</li>
<li>方法只能返回一个值，但能包含多个返回语句</li>
<li>方法可以产生副作用</li>
</ul></li>
<li>递归：方法可以调用自己
可以使用数学归纳法证明所解释算法的正确性,编写递归重要的三点
<ul>
<li>递归总有一个最简单的情况(方法第一条总包含return的条件语句)</li>
<li>递归调用总是去尝试解决一个规模更小的子问题</li>
<li>递归调用的父问题和尝试解决的子问题之间不应该由交集
如下图中，两个子问题各自操作的数组部分是不同的<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645498373138.png" /></li>
</ul></li>
<li>基础编程模型
<ul>
<li>静态方法库是定义在一个Java类中的一组静态方法</li>
<li>Java开发的基本模式是编写一个静态方法库(包含一个main()方法)类完成一个任务<br />
</li>
<li>在本书中，当我们提到用于执行一项人物的Java程序时，我们指的就是用这种模式开发的代码(还包括对数据类型的定义)</li>
</ul></li>
<li>模块化编程
<ul>
<li>通过静态方法库实现了模块化编程<br />
</li>
<li>一个库中的静态方法也能够调用另一个库中定义的静态方法</li>
</ul></li>
<li>单元测试
<ul>
<li>Java编程最佳实践之一就是每个静态方法库中都包含一个main()函数来测试库中所有的方法</li>
<li>本书中使用main()来说明模块的功能并将测试用例留作练习</li>
</ul></li>
<li>外部库
<ul>
<li>系统标准库 java.lang.*:包括Math库;String和StringBuilder库</li>
<li>导入的系统库 java.util.Arrays</li>
<li>本书中其他库</li>
<li>本书使用了作者开发的标准库Std* ### API</li>
</ul></li>
<li>模块化编程重要组成部分，记录库方法的用法并供其他人参考的文档</li>
<li>会统一使用应用程序编程接口API的方法列出每个库方法、签名及简述</li>
<li>用例(调用另一个库中的方法的程序)，实现(实现了某个API方法的Java代码)</li>
<li>作者自己的两个库，一个扩展Math.random(),一个支持各种统计
<ul>
<li>随机静态方法库(StdRandom)的API<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645499238258.png" /></li>
<li>数据分析方法库(StdStats)的API<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645499266972.png" /></li>
<li>StdRandom库中的静态方法的实现 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645499387538.png" /></li>
</ul></li>
<li>编写自己的库
<ul>
<li>编写用例，实现中将计算过程分解</li>
<li>明确静态方法库和与之对应的API</li>
<li>实现API和一个能够对方法进行独立测试的main()函数</li>
<li>API的目的是将调用和实现分离 ### 字符串</li>
</ul></li>
<li>字符串拼接，使用 +</li>
<li>类型转换(将用户从键盘输入的内容转换成相应数据类型的值以及将各种数据类型的值转换成能够在屏幕上显示的值)<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645499613030.png" /></li>
<li>如果数字跟在+后面，那么会将数据类型的值自动转换为字符串</li>
<li>命令行参数
<ul>
<li>Java中字符串的存在，使程序能够接收到从命令行传递来的信息</li>
<li>当输入命令java和一个库名及一系列字符串后，Java系统会调用库的main()方法并将后面的一系列字符串变成一个数组作为参数传递给它
### 输入输出</li>
</ul></li>
<li>Java程序可以从<strong><em>命令行参数</em></strong>或者一个名为<strong><em>标准输入流</em></strong>的抽象字符流中获得输入，并将输出写入另一个名为标准输出流的字符流中</li>
<li>默认情况下，命令行参数、标准输入和标准输出是和应用程序绑定的，而应用程序是由能够接受命令输入的操作系统或是开发环境所支持</li>
<li>使用终端来指代这个应用程序提供的供输入和显示的窗口,如图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645500007895.png" /></li>
<li>命令和参数
<ul>
<li>终端窗口包含一个提示符，通过它我们能够向操作系统输入命令和参数</li>
<li>操作系统常用命令<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645500167245.png" /></li>
</ul></li>
<li>标准输出
<ul>
<li>StdOut库的作用是支持标准输出</li>
<li>标准输出库的静态方法的API<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645500444820.png" /></li>
<li>格式化输出
字符%并紧跟一个字符表示的转换代码(包括d,f和s)。%和转换代码之间可以插入证书表示值的宽度，且转换后会在字符串左边添加空格以达到需要的宽度。负数表示空格从右边加</li>
<li>宽度后用小数点及数值可以指定精度(或String字符串所截取的长度)</li>
<li>格式中转换代码和对应参数的数据类型必须匹配 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645500484321.png" /></li>
</ul></li>
<li>标准输入
<ul>
<li>StdIn库从标准输入流中获取数据，然后将标准输出定向到终端窗口</li>
<li>标准输入流最重要的特点，这些值会在程序读取后消失</li>
<li>例子<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645500902261.png" /></li>
<li>标准输入库中的静态方法API<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645500946918.png" /></li>
</ul></li>
<li>重定向和管道
<ul>
<li>将标准输出重定向到一个文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java RandomSeq 1000 100.0 200.0 &gt; data.txt</span><br></pre></td></tr></table></figure></li>
<li>从文件而不是终端应用程序中读取数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java Average &lt; data.txt</span><br></pre></td></tr></table></figure></li>
<li>将一个程序的输出重定向为另一个程序的输入，叫做管道<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java RandomSeq 1000 100.0 200.0 | java Average</span><br></pre></td></tr></table></figure>
<ul>
<li>突破了我们能够处理的输入输出流的长度限制<br />
</li>
<li>即使计算机没有足够的空间来存储十亿个数，</li>
<li>我们仍然可以将例子中的1000 换成1 000 000 000
（当然我们还是需要一些时间来处理它们）。当RandomSeq 调用StdOut.println()
时，它就向输出流的末尾添加了一个字符串；当Average 调用StdIn.readInt()
时，它就从输入流的开头删除了一个字符串。这些动作发生的实际顺序取决于操作系统</li>
</ul></li>
<li>命令行的重定向及管道<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645501458419.png" /></li>
</ul></li>
<li>基于文件的输入输出</li>
<li>In和Out库提供了一些静态方法,来实现向文件中写入或从文件中读取一个原始数据类型的数组的抽象</li>
<li>用于读取和写入数组的静态方法的API<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645508058593.png" /></li>
<li>标准绘图库(基本方法和控制方法)--这里跳过 ### 二分查找</li>
<li>如图，在终端接收需要判断的数字，如果不存在于白名单(文件中的int数组)中则输出</li>
<li>开发用例以及使用测试文件(数组长度很大的白名单)</li>
<li>模拟实际情况来展示当前算法的必要性，比如
<ul>
<li>将客户的账号保存在一个文件中，我们称它为白名单；</li>
<li>从标准输入中得到每笔交易的账号；</li>
<li>使用这个测试用例在标准输出中打印所有与任何客户无关的账号，公司很可能拒绝此类交易。
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645508356801.png" /></li>
</ul></li>
<li>使用顺序查找<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int rank(int key, int[] a)</span><br><span class="line">&#123;</span><br><span class="line">  for (int i = 0; i &lt; a.length; i++)</span><br><span class="line">    if (a[i] == key) return i;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当处理大量输入的时候，顺序查找的效率极其低 ### 展望</li>
<li>下一节，鼓励使用数据抽象，或称面向对象编程，而不是操作预定义的数据类型的静态方法</li>
<li>使用数据抽象的好处
<ul>
<li>复用性</li>
<li>链式数据结构比数组更灵活</li>
<li>可以准确地定义锁面对的算法问题 ### 1.1 End</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法红皮书(第四版)</tag>
      </tags>
  </entry>
  <entry>
    <title>算法红皮书 1.2.1-1.2.5</title>
    <url>/2022/02/22/study/algorithm/algorithhms_4th/1.2.1-1.2.5/</url>
    <content><![CDATA[<h2 id="数据抽象">数据抽象</h2>
<p><strong><em>数据类型</em></strong>指的是一组值和一组对这些值的操作的集合<br />
* 定义和使用数据类型的过程，也被称为数据抽象 *
Java编程的基础是使用class关键字构造被称为<strong><em>引用类型</em></strong>的数据类型，也称面向对象编程
* 定义自己的数据类型来抽象任意对象 *
抽象数据类型（ADT）是一种能够对使用者隐藏数据表示的数据类型 *
抽象数据类型将数据和函数的实现相关联，将数据的表示方式隐藏起来 *
抽象数据类型使用时，关注API描述的操作上而不会去关心数据的表示；实现抽象数据类型时，关注数据本身并将实现对数据的各种操作
* 研究同一个问题的不同算法的主要原因是他们的性能不同</p>
<h3 id="使用抽象数据类型">使用抽象数据类型</h3>
<ul>
<li>使用一种数据类型并不一定非得知道它是如何实现的</li>
<li>使用Counter(计数器)的简单数据类型的程序，操作有
<ul>
<li>创建对象并初始化为0</li>
<li>当前值加1</li>
<li>获取当前值</li>
</ul></li>
<li>场景，用于电子计票</li>
<li>抽象数据类型的API(应用程序编程接口)
<ul>
<li>API用来说明抽象数据类型的行为</li>
<li>将列出所有构造函数和实例方法(即操作)</li>
</ul></li>
<li>计算器的API<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645622786940.png" /></li>
<li>继承的方法
<ul>
<li>所有数据类型都会继承toString()方法</li>
<li>Java会在用+运算符将任意数据类型的值和String值连接时调用toString()</li>
<li>默认实现：返回该数据类型值的内存地址</li>
</ul></li>
<li>用例代码
<ul>
<li>可以在用例代码中，声明变量、创建对象来保存数据类型的值并允许通过实例方法来操作它们</li>
</ul></li>
<li>对象
<ul>
<li>对象是能够承载数据类型的值的实体</li>
<li>对象三大特性：状态、标识和行为
<ul>
<li>状态：数据类型中的值</li>
<li>标识：在内存中的地址</li>
<li>行为：数据类型的操作</li>
</ul></li>
<li>Java使用"引用类型"和原始数据类型区别</li>
</ul></li>
<li>创建对象
<ul>
<li>每种数据类型中的值都存储于一个对象中</li>
<li>构造函数总是返回他的数据类型的对象的引用</li>
<li>使用new()，会为新的对象分配内存空间，调用构造函数初始化对象中的值，返回该对象的一个引用</li>
</ul></li>
<li>抽象数据类型向用例隐藏了值的表示细节</li>
<li>实例方法：参数按值传递</li>
<li>方法每次触发都和一个对象相关</li>
<li>静态方法的主要作用是实现函数；非静态(实例)方法的主要作用是实现数据类型的操作</li>
<li>使用对象<br />
开发某种数据类型的用例
<ul>
<li>声明该类型的变量，以引用对象</li>
<li>使用new触发能够创建该类型的对象的一个构造函数</li>
<li>使用变量名调用实例方法</li>
</ul></li>
<li>赋值语句(对象赋值)
<ul>
<li>别名：两个变量同时指向同一个对象</li>
</ul></li>
<li>将对象作为参数
<ul>
<li>Java将参数值的一个副本从调用端传递给了方法，这种方式称为按值传递</li>
<li>当使用引用类型作为参数时我们创建的都是别名，这种约定会传递引用的值(复制引用)，也就是传递对象的引用</li>
<li>虽然无法改变原始的引用(将原变量指向另一个Counter对象)，但能够改变该对象的值</li>
</ul></li>
<li>将对象作为返回值
<ul>
<li>由于Java只由一个返回值，有了对象实际上就能返回多个值</li>
</ul></li>
<li>数组也是对象
<ul>
<li>将数组传递给一个方法或是将一个数组变量放在赋值语句的右侧时，我们都是在创建数组引用的一个副本，而非数组的副本</li>
</ul></li>
<li>对象的数组<br />
创建一个对象的数组
<ul>
<li>使用方括号语法调用数组的构造函数创建数组</li>
<li>对于每个数组元素调用它的构造函数创建相应的对象<br />
如下图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1645625875287.png" /></li>
</ul></li>
<li>运用数据抽象的思想编写代码(定义和使用数据类型，将数据类型的值封装在对象中)的方式称为面向对象编程</li>
<li>总结
<ul>
<li>数据类型指的是一组值和一组对值的操作的集合</li>
<li>我们会在数据类型的Java类中编写用理</li>
<li>对象是能够存储任意该数据类型的值的实体</li>
<li>对象有三个关键性质：状态、标识和行为</li>
</ul></li>
</ul>
<h3 id="抽象数据类型举例">抽象数据类型举例</h3>
<ul>
<li>本书中将会用到或开发的所有数据类型
<ul>
<li>java.lang.*</li>
<li>Java标准库中的抽象数据类型，需要import，比如java.io、java.net等</li>
<li>I/O处理嘞抽象数据类型,StdIn和StdOut</li>
<li>面向数据类抽象数据类型，计算机和和信息处理</li>
<li>集合类抽象数据类型，主要是为了简化对同一类型的一组数据的操作，包括Bag、Stack和Queue，PQ(优先队列)、ST(符号表)、SET(集合)</li>
<li>面向操作的抽象数据类型(用来分析各种算法)</li>
<li>图算法相关的抽象数据类型，用来封装各种图的表示的面向数据的抽象数据类型，和一些提供图的处理算法的面向操作的抽象数据类型</li>
</ul></li>
<li>几何对象(画图(图形)的)[跳过]</li>
<li>信息处理
<ul>
<li>抽象数据类型是组织信息的一种自然方式</li>
<li>定义和真实世界中的物体相对应的对象</li>
</ul></li>
<li>字符串
<ul>
<li>java的String</li>
<li>一个String值是一串可以由索引访问的char值</li>
<li>有了String类型可以写出清晰干净的用例代码而无需关心字符串的表示方式</li>
</ul></li>
</ul>
<h3 id="抽象数据类型的实现">抽象数据类型的实现</h3>
<ul>
<li>使用Java的类(class)实现抽象数据类型并将所有代码放入一个和类名相同并带有.java扩展名的文件</li>
<li>如下图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647917949340.png" /></li>
<li>实例变量<br />
用来定义数据类型的值(每个对象的状态)<br />
</li>
<li>构造函数
<ul>
<li>每个Java类都至少有一个构造函数以创建一个对象的标识</li>
<li>每个构造函数将创建一个对象并向调用者返回一个该对象的引用<br />
</li>
</ul></li>
<li>实例方法
<ul>
<li>如图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647917973220.png" /></li>
</ul></li>
<li>作用域
<ul>
<li>参数变量、局部变量、实例变量</li>
<li>范围(如图)<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647917991340.png" /></li>
</ul></li>
<li>API、用例与实现
<ul>
<li>我们要学习的每个抽象数据类型的实现，都会是一个含有若干私有实例变量、构造函数、实例方法和一个测试用例的Java类</li>
<li>用例和实现分离(一般将用例独立成含有静态方法main()的类)</li>
<li>做法如下
<ul>
<li>定义一份API，APi的作用是将使用和实现分离，以实现模块化编程</li>
<li>用一个Java类<strong>实现</strong>API的定义</li>
<li>实现多个测试用例来验证前两步做出的设计决定</li>
</ul></li>
<li>例子如下
<ul>
<li>API<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647917905216.png" /></li>
<li>典型用例<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647918040166.png" /></li>
<li>数据类型的实现<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647918079248.png" /></li>
<li>使用方法(执行程序)<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647918109793.png" /></li>
</ul></li>
</ul></li>
</ul>
<h3 id="更多抽象数据类型的实现">更多抽象数据类型的实现</h3>
<ul>
<li>日期
<ul>
<li>两种实现方式<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647919855792.png" /></li>
<li>本书反复出现的主题，即理解各种实现对空间和时间的需求<br />
</li>
</ul></li>
<li>维护多个实现
<ul>
<li>比较同一份API的两种实现在同一个用例中的性能表现，需要下面非正式的命名约定
<ul>
<li>使用前缀的描述性修饰符，比如BasicDate和SmallDate,以及是否合法的SmartDate</li>
<li>适合大多数用力的需求的实现，比如Date</li>
</ul></li>
</ul></li>
<li>累加器</li>
</ul>
<h3 id="数据类型的设计">数据类型的设计</h3>
<ul>
<li>抽象数据类型是一种向用例隐藏内部表示的数据类型
<ul>
<li>封装(数据封装)<br />
</li>
<li>设计APi<br />
</li>
</ul></li>
<li>算法与抽象数据类型
<ul>
<li>能够准确地说明一个算法的目的及其他程序应该如何使用该算法</li>
<li>每个Java程序都是一组静态方法和(或)一种数据类型的实现的集合</li>
</ul></li>
<li>本书中关注的是抽象数据类型的实现中的操作和向用例隐藏其中的数据表示</li>
<li>例子，将二分法封装
<ul>
<li>API<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647926825727.png" /></li>
<li>典型的用例<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647926860564.png" /></li>
<li>数据类型的实现<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647926913576.png" /></li>
</ul></li>
<li>接口继承
<ul>
<li>Java语言为定义对象之间的关系提供了支持，称为接口</li>
<li>接口继承使得我们的程序能够通过调用接口中的方法操作实现该接口的任意类型的对象<br />
</li>
</ul></li>
<li>本书中使用到的接口<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647927204860.png" /></li>
<li>继承
<ul>
<li>由Object类继承得到的方法<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647927291658.png" /></li>
<li>继承toString()并自定义</li>
<li>封装类型(内置的引用类型，包括Boolean、Byte、Character、Double、Float、Integer、Long和Short)</li>
</ul></li>
<li>等价性
<ul>
<li>如图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647927424380.png" /></li>
<li>例子，在Date中重写equals<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1647927476357.png" /></li>
</ul></li>
<li>内存管理<br />
Java具有自动内存管理，通过记录孤儿对象并将它们的内存释放到内存池中</li>
<li>不可变性<br />
使用final保证数据不可变<br />
使用final修饰的引用类型，不能再引用(指向)其他对象，但对象本身的值可改变<br />
</li>
<li>契约式设计
<ul>
<li>Java语言能够在程序运行时检测程序状态</li>
<li>异常(Exception)+断言(Assertion)</li>
</ul></li>
<li>异常与错误<br />
允许抛出异常或抛出错误<br />
</li>
<li>断言<br />
程序不应该依赖断言</li>
</ul>
<h3 id="end">End</h3>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法红皮书(第四版)</tag>
      </tags>
  </entry>
  <entry>
    <title>算法红皮书 1.3.1.1-1.3.2.5</title>
    <url>/2022/03/22/study/algorithm/algorithhms_4th/1.3.1.1-1.3.2.5/</url>
    <content><![CDATA[<h2 id="背包队列和栈">背包、队列和栈</h2>
<ul>
<li>数据类型的值就是一组对象的集合，所有操作都是关于添加、删除或是访问集合中的对象<br />
</li>
<li>本章将学习三种数据类型：背包Bag、队列Queue、栈Stack
<ul>
<li>对集合中的对象的表示方式直接影响各种操作的效率<br />
</li>
<li>介绍泛型和迭代<br />
</li>
<li>介绍并说明链式数据结构的重要性(链表)</li>
</ul></li>
</ul>
<h3 id="api">API</h3>
<ul>
<li>泛型可迭代的基础集合数据类型的API
<ul>
<li>背包<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406152057569.png"
alt="image-20220406152057569" /></li>
<li>队列(先进先出FIFO)<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406153613674.png"
alt="image-20220406153613674" /></li>
<li>下压(后进先出,LIFO)栈 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406153640138.png"
alt="image-20220406153640138" /></li>
</ul></li>
<li>泛型
<ul>
<li>泛型，参数化类型<br />
</li>
<li>在每份API 中，类名后的<Item> 记号将Item
定义为一个类型参数，它是一个象征性的占位符，表示的是用例将会使用的某种具体数据类型<br />
</li>
</ul></li>
<li>自动装箱
<ul>
<li>用来处理原始类型<br />
</li>
<li>Boolean、Byte、Character、Double、Float、Integer、Long 和Short
分别对应着boolean、byte、char、double、float、int、long 和short<br />
</li>
<li>自动将一个原始数据类型转换为一个封装类型称为自动装箱，自动将一个封装类型转换为一个原始数据类型被称为自动拆箱<br />
</li>
</ul></li>
<li>可迭代的集合类型
<ul>
<li>迭代访问集合中的所有元素<br />
</li>
</ul></li>
<li>背包是一种不支持从中删除元素的集合数据类型--帮助用例收集元素并迭代遍历所有收集到的元素（<strong>无序遍历</strong>）
<ul>
<li>典型用例，计算标准差<br />
<img src="./1.3.1.1-1.3.2.5/1648014765406.png" /></li>
</ul></li>
<li>先进先出队列
<ul>
<li>是一种基于先进先出(FIFO)策略的集合类型<br />
</li>
<li>使用队列的主要原因：集合保存元素的同时保存它们的相对顺序<br />
</li>
<li>如图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406153751756.png"
alt="image-20220406153751756" /></li>
<li>Queue用例(先进先出)<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406153829692.png"
alt="image-20220406153829692" /></li>
</ul></li>
<li>下压栈
<ul>
<li>简称栈，是一种基于后进先出LIFO策略的集合类型<br />
</li>
<li>比如，收邮件等，如图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406154449201.png"
alt="image-20220406154449201" /></li>
<li>Stack的用例<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406154510301.png"
alt="image-20220406154510301" /></li>
</ul></li>
<li>用栈解决算数表达式的问题<br />
（双栈算数表达式求值算法）<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406155021820.png"
alt="image-20220406155021820" /></li>
</ul>
<h3 id="集合类数据类型的实现">集合类数据类型的实现</h3>
<ul>
<li><p>定容栈，表示容量固定的字符串栈的抽象数据类型</p>
<ul>
<li><p>只能处理String值，支持push和pop</p></li>
<li><p>抽象数据类型<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406155522256.png"
alt="image-20220406155522256" /></p></li>
<li><p>测试用例</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406155637243.png"
alt="image-20220406155637243" />
<figcaption aria-hidden="true">image-20220406155637243</figcaption>
</figure></li>
<li><p>使用方法<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406155712507.png"
alt="image-20220406155712507" /></p></li>
<li><p>数据类型的实现<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406155728513.png"
alt="image-20220406155728513" /></p></li>
</ul></li>
<li><p>泛型</p>
<ul>
<li><code>public class FixedCapacityStack&lt;Item&gt;</code></li>
<li>由于不允许直接创建泛型数组，所以 <del>a =new Item[cap]</del>
不允许，应该改为<br />
a=(Item[])new Object[cap];<br />
</li>
<li>泛型定容栈的抽象数据类型<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406160905236.png"
alt="image-20220406160905236" /></li>
<li>测试用例<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406160932941.png"
alt="image-20220406160932941" /></li>
<li>使用方法<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406160957117.png"
alt="image-20220406160957117" /></li>
<li>数据类型的实现<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406161022669.png"
alt="image-20220406161022669" /></li>
</ul></li>
<li><p>调整数组大小</p>
<ul>
<li>N为当前元素的数量<br />
使用resize创建新的数组<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406161247788.png"
alt="image-20220406161247788" /></li>
<li>当元素满了的时候进行扩容<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406161332720.png"
alt="image-20220406161332720" /></li>
<li>当元素过少(1/4)的时候，进行减半<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406161408973.png"
alt="image-20220406161408973" /></li>
</ul></li>
<li><p>对象游离</p>
<ul>
<li><p>Java的垃圾回收策略是回收所有无法被访问的对象的内存</p></li>
<li><p>示例中，被弹出的元素不再需要，但由于数组中的引用仍然让它可以继续存在（垃圾回收器无法回收），这种情况（保存了一个不需要的对象的引用）称为游离，避免游离的做法就是将数组元素设为null</p></li>
</ul></li>
<li><p>迭代</p>
<ul>
<li><p>foreach和while<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406162432642.png"
alt="image-20220406162432642" /></p>
<ul>
<li>集合数据类型必须实现iterator()并返回Iterator对象</li>
<li>Iterator类必须包括两个方法,hasNext()和next()</li>
</ul></li>
<li><p>让类继承Iterable<Item>使类可迭代 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406163317535.png"
alt="image-20220406163317535" /></p></li>
<li><p>使用一个嵌套类<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220406163515174.png"
alt="image-20220406163515174" /></p></li>
<li><p>下压栈的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResizingArrayStack</span>&lt;Item&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Item&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>		Item[] a = (Item[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];      <span class="comment">/* 栈元素 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>	<span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;                                  <span class="comment">/* 元素数量 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>(N == <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>(N);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">( <span class="type">int</span> max )</span></span><br><span class="line">	&#123;       <span class="comment">/* 将栈移动到一个大小为max 的新数组 */</span></span><br><span class="line">		Item[] temp = (Item[]) <span class="keyword">new</span> <span class="title class_">Object</span>[max];</span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++ )</span><br><span class="line">			temp[i] = a[i];</span><br><span class="line">		a = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">( Item item )</span></span><br><span class="line">	&#123;       <span class="comment">/* 将元素添加到栈顶 */</span></span><br><span class="line">		<span class="keyword">if</span> ( N == a.length )</span><br><span class="line">			resize( <span class="number">2</span> * a.length );</span><br><span class="line">		a[N++] = item;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Item <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">	&#123;                       <span class="comment">/* 从栈顶删除元素 */</span></span><br><span class="line">		<span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> a[--N];</span><br><span class="line">		a[N] = <span class="literal">null</span>;    <span class="comment">/* 避免对象游离（请见1.3.2.4 节） */</span></span><br><span class="line">		<span class="keyword">if</span> ( N &gt; <span class="number">0</span> &amp;&amp; N == a.length / <span class="number">4</span> )</span><br><span class="line">			resize( a.length / <span class="number">2</span> );</span><br><span class="line">		<span class="keyword">return</span>(item);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="keyword">new</span> <span class="title class_">ReverseArrayIterator</span>() );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ReverseArrayIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Item&gt;</span><br><span class="line">	&#123;       <span class="comment">/* 支持后进先出的迭代 */</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> N;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>(i &gt; <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> Item <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>(a[--i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="end">End</h3>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法红皮书(第四版)</tag>
      </tags>
  </entry>
  <entry>
    <title>算法红皮书1.3.3.1-1.3.4</title>
    <url>/2022/04/06/study/algorithm/algorithhms_4th/1.3.3.1-1.3.4/</url>
    <content><![CDATA[<h2 id="背包队列和栈">背包、队列和栈</h2>
<h3 id="链表">链表</h3>
<ul>
<li><p>链表是一种递归的数据结构，它或者为空(null)，或者是一个指向一个结点（node）的引用，该节点含有一个泛型的元素和一个指向另一条链表的引用。
#### 结点记录</p></li>
<li><p>使用嵌套类定义结点的抽象数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">	Item item;</span><br><span class="line">	Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>该类没有其它任何方法，且会在代码中直接引用实例变量，这种类型的变量称为记录</li>
</ul></li>
</ul>
<h4 id="构造链表">构造链表</h4>
<ul>
<li>需要一个Node类型的变量，保证它的值是null或者指向另一个Node对象的next域指向了另一个链表</li>
<li>如下图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220407091501353.png"
alt="image-20220407091501353" /></li>
<li>链表表示的是一列元素</li>
<li>链式结构在本书中的可视化表示
长方形表示对象；实例变量的值写在长方形中；用指向被引用对象的箭头表示引用关系</li>
<li>术语<strong>链接</strong>表示对结点的引用</li>
</ul>
<h4 id="在表头插入结点">在表头插入结点</h4>
<ul>
<li><p>在首结点为first 的给定链表开头插入字符串not，我们先将first
保存在oldfirst 中， 然后将一个新结点赋予first，并将它的item
域设为not，next 域设为oldfirst</p></li>
<li><p>时间复杂度为O(1)</p></li>
<li><p>如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220407092921756.png"
alt="image-20220407092921756" /></p></li>
</ul>
<h4 id="从表头删除结点">从表头删除结点</h4>
<ul>
<li><p>将first指向first.next</p></li>
<li><p>原先的结点称为孤儿，Java的内存管理系统最终将回收它所占用的内存</p></li>
<li><p>如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220407093000788.png"
alt="image-20220407093000788" /></p></li>
</ul>
<h4 id="在表尾插入结点">在表尾插入结点</h4>
<ul>
<li><p>每个修改链表的操作都需要增加检查是否要修改该变量（以及做出相应修改）的代码</p></li>
<li><p>例如，当删除链表首结点时可能改变指向链表的尾结点的引用，因为链表中只有一个结点时它既是首结点又是尾结点</p></li>
<li><p>如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220407094045245.png"
alt="image-20220407094045245" /></p></li>
</ul>
<h4 id="其他位置的插入和删除操作">其他位置的插入和删除操作</h4>
<p>删除指定结点；在指定节点插入新结点</p>
<ul>
<li>需要将链表尾结点的前一个节点中的链接（它指向的是last）值改为null</li>
<li>为了找到指向last的结点，需要遍历链表，时间复杂度为O(n)</li>
<li>实现任意插入和删除操作的标准解决方案是<strong>双向链表</strong></li>
</ul>
<h4 id="遍历">遍历</h4>
<ul>
<li><p>将x初始化为链表首结点，然后通过x.item访问和x相关联的元素，并将x设为x.next来访问链表中的下一个结点，知道x=null(没有下一个结点了，到达链表结尾)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 处理x.item</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="栈的实现">栈的实现</h4>
<ul>
<li><p>使用链表实现栈</p></li>
<li><p>将栈保存为一条链表，栈的顶部即为表头，实例变量first
指向栈顶。这样，当使用push() 压入一个元素时，我们会按照1.3.3.3
节所讨论的代码将该元素添加在表头；当使用pop()
删除一个元素时，我们会按照1.3.3.4
节讨论的代码将该元素从表头删除。要实现size() 方法，我们用实例变量N
保存元素的个数，在压入元素时将N 加1，在弹出元素时将N
减1。要实现isEmpty() 方法，只需检查first 是否为null（或者可以检查N
是否为0）</p></li>
<li><p>实现上述几个操作的时间复杂度为O(1)</p></li>
<li><p>下压堆栈（链表的实现）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span>&lt;Item&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Item&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> Node first;</span><br><span class="line">	<span class="comment">// 栈顶（最近添加的元素）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line">	<span class="comment">// 元素数量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 定义了结点的嵌套类</span></span><br><span class="line">		Item item;</span><br><span class="line">		Node next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Boolean <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">return</span> <span class="variable">first</span> <span class="operator">=</span>= <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 或：N == 0</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> N;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Item item)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 向栈顶添加元素</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">oldfirst</span> <span class="operator">=</span> first;</span><br><span class="line">		first = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">		first.item = item;</span><br><span class="line">		first.next = oldfirst;</span><br><span class="line">		N++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Item <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 从栈顶删除元素</span></span><br><span class="line">		<span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> first.item;</span><br><span class="line">		first = first.next;</span><br><span class="line">		N--;</span><br><span class="line">		<span class="keyword">return</span> item;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// iterator() 的实现请见算法1.4</span></span><br><span class="line">	<span class="comment">// 测试用例main() 的实现请见本节前面部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试用例(pop()之前测试用例做了判断)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 创建一个栈并根据StdIn中的指示压入或弹出字符串</span></span><br><span class="line">	Stack&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();</span><br><span class="line">	<span class="keyword">while</span> (!StdIn.isEmpty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> StdIn.readString();</span><br><span class="line">		<span class="keyword">if</span> (!item.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">		s.push(item); <span class="keyword">else</span> <span class="keyword">if</span> (!s.isEmpty()) StdOut.print(s.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	StdOut.println(<span class="string">&quot;(&quot;</span> + s.size() + <span class="string">&quot; left on stack)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="队列的实现">队列的实现</h4>
<ul>
<li><p>这里维护了first和last两个变量</p></li>
<li><p>Queue实现使用的数据结构和Stack都是链表，但实现了不同的添加和删除元素的算法，所以前者是先入先出，后者是后进先出</p></li>
<li><p>Queue的测试用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 创建一个队列并操作字符串入列或出列</span></span><br><span class="line">	Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;String&gt;();</span><br><span class="line">	<span class="keyword">while</span> (!StdIn.isEmpty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> StdIn.readString();</span><br><span class="line">		<span class="keyword">if</span> (!item.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">		q.enqueue(item); <span class="keyword">else</span> <span class="keyword">if</span> (!q.isEmpty()) StdOut.print(q.dequeue() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	StdOut.println(<span class="string">&quot;(&quot;</span> + q.size() + <span class="string">&quot; left on queue)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Queue的测试用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 创建一个队列并操作字符串入列或出列</span></span><br><span class="line">	Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;String&gt;();</span><br><span class="line">	<span class="keyword">while</span> (!StdIn.isEmpty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> StdIn.readString();</span><br><span class="line">		<span class="keyword">if</span> (!item.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">		q.enqueue(item); <span class="keyword">else</span> <span class="keyword">if</span> (!q.isEmpty()) StdOut.print(q.dequeue() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	StdOut.println(<span class="string">&quot;(&quot;</span> + q.size() + <span class="string">&quot; left on queue)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Queue的实现</p>
<ul>
<li>如下，enqueue()需要额外考虑first，dequeue()需要额外考虑last
<ul>
<li>如果原队列没有结点，那么增加后last指向了新的元素，应该把first也指向新元素</li>
<li>如果原对队列只有一个元素，那么删除后first确实指向null，而last没有更新，所以需要下面的判断手动更新</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue</span>&lt;Item&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Item&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> Node first;</span><br><span class="line">	<span class="comment">// 指向最早添加的结点的链接</span></span><br><span class="line">	<span class="keyword">private</span> Node last;</span><br><span class="line">	<span class="comment">// 指向最近添加的结点的链接</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line">	<span class="comment">// 队列中的元素数量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 定义了结点的嵌套类</span></span><br><span class="line">		Item item;</span><br><span class="line">		Node next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Boolean <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">return</span> <span class="variable">first</span> <span class="operator">=</span>= <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 或： N == 0.</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> N;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Item item)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 向表尾添加元素</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">oldlast</span> <span class="operator">=</span> last;</span><br><span class="line">		last = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">		last.item = item;</span><br><span class="line">		last.next = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) first = last; <span class="keyword">else</span> oldlast.next = last;</span><br><span class="line">		N++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Item <span class="title function_">dequeue</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 从表头删除元素</span></span><br><span class="line">		<span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> first.item;</span><br><span class="line">		first = first.next;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) last = <span class="literal">null</span>;</span><br><span class="line">		N--;</span><br><span class="line">		<span class="keyword">return</span> item;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// iterator() 的实现请见算法1.4</span></span><br><span class="line">	<span class="comment">// 测试用例main() 的实现请见前面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在结构化数据集时，链表是数组的一种重要替代方法</p></li>
</ul>
<h4 id="背包的实现">背包的实现</h4>
<ul>
<li><p>只需要将Stack中的push()改为add()即可，并去掉pop()</p></li>
<li><p>下面添加了Iterator实现类，以及iterator()具体方法
其中，嵌套类ListIterator
维护了一个实例变量current来记录链表的当前结点。hasNext()
方法会检测current 是否为null，next() 方法会保存当前元素的引用，将current
变量指向链表中的下个结点并返回所保存的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bag</span>&lt;Item&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Item&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> Node first;</span><br><span class="line">	<span class="comment">// 链表的首结点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">	&#123;</span><br><span class="line">		Item item;</span><br><span class="line">		Node next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Item item)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 和Stack 的push() 方法完全相同</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">oldfirst</span> <span class="operator">=</span> first;</span><br><span class="line">		first = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">		first.item = item;</span><br><span class="line">		first.next = oldfirst;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListIterator</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;Item&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="type">Node</span> <span class="variable">current</span> <span class="operator">=</span> first;</span><br><span class="line">		<span class="keyword">public</span> Boolean <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> current != <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> Item <span class="title function_">next</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> current.item;</span><br><span class="line">			current = current.next;</span><br><span class="line">			<span class="keyword">return</span> item;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="综述">综述</h3>
<ul>
<li>学习了支持泛型和迭代的背包、队列和栈</li>
<li>现在拥有两种表示对象集合的方式，即数组和链表---&gt;顺序存储和链式存储
<ul>
<li>各种含有多个链接的数据结构，如二叉树的数据结构，由<strong>含有两个链接的节点</strong>组成</li>
<li><strong>复合型</strong>的数据结构：背包存储栈，队列存储数组等，例如用数组的背包表示<strong>图</strong></li>
</ul></li>
<li>基础数据结构 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220407105102346.png"
alt="image-20220407105102346" /></li>
<li>研究新领域时，按以下步骤识别并使用数据抽象解决问题
<ul>
<li>定义API</li>
<li>根据应用场景开发<strong>用例代码</strong></li>
<li>描述数据结构（一组值的表示），并在API所对应的抽象数据类型的实现中根据它定义类的实例变量</li>
<li>描述算法（实现一组操作的方式），实现类的实例方法</li>
<li>分析算法的性能特点</li>
</ul></li>
<li>本书的数据结构举例 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220407105552258.png"
alt="image-20220407105552258" /></li>
</ul>
<h3 id="end">End</h3>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法红皮书(第四版)</tag>
      </tags>
  </entry>
  <entry>
    <title>算法红皮书 1.4.1-1.4.10</title>
    <url>/2022/04/07/study/algorithm/algorithhms_4th/1.4.1-1.4.10/</url>
    <content><![CDATA[<h2 id="算法分析">算法分析</h2>
<p>使用<strong>数学分析</strong>为算法成本建立简洁的模型，并使用实验数据验证这些模型</p>
<h3 id="科学方法">科学方法</h3>
<ul>
<li>观察、假设、预测、观察并核实预测、反复确认预测和观察</li>
<li>原则：实验可重现</li>
</ul>
<h3 id="观察">观察</h3>
<ul>
<li><p>计算性任务的困难程度可以用<strong>问题的规模</strong>来衡量</p></li>
<li><p>问题规模可以是输入的大小或某个命令行参数的值</p></li>
<li><p>研究问题规模和运行时间的关系</p></li>
<li><p>使用计时器得到大概的运行时间 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220407113311126.png"
alt="image-20220407113311126" /></p>
<ul>
<li><p>典型用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            a[i] = StdRandom.uniform(-<span class="number">1000000</span>, <span class="number">1000000</span>);</span><br><span class="line">        <span class="type">Stopwatch</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stopwatch</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> ThreeSum.count(a);</span><br><span class="line">        <span class="type">double</span> <span class="variable">time</span> <span class="operator">=</span> timer.elapsedTime();</span><br><span class="line">        StdOut.println(cnt + <span class="string">&quot; triples &quot;</span> + time + <span class="string">&quot; seconds&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用方法 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220407113407342.png"
alt="image-20220407113407342" /></p></li>
<li><p>数据类型的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stopwatch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stopwatch</span><span class="params">()</span> &#123;</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">elapsedTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (now - start) / <span class="number">1000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="数学模型">数学模型</h3>
<ul>
<li><p>程序运行的总时间主要和两点有关：执行每条语句的耗时；执行每条语句的频率</p></li>
<li><p>定义：我们用~f(N) 表示所有随着N 的增大除以f(N) 的结果趋近于1
的函数。我们用g(N) ~ f(N) 表示g(N)/f(N) 随着N 的增大趋近于1。
即使用曰等号忽略较小的项</p></li>
<li><p><span class="math display">\[
f(N)=N^b(logN)^c
\]</span></p>
<p>将f(N)称为g(N)的增长的数量级</p></li>
<li><p>常见的增长数量级函数 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220407170444747.png"
alt="image-20220407170444747" /></p></li>
<li><p>本书用性质表示需要用实验验证的猜想</p>
<ul>
<li><p>ThreeSum分析
执行最频繁的指令决定了程序执行的总时间--我们将这些指令称为程序的<strong>内循环</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220407170842908.png"
alt="image-20220407170842908" />
<figcaption aria-hidden="true">image-20220407170842908</figcaption>
</figure></li>
<li><p>程序运行时间的分析 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220407170938405.png"
alt="image-20220407170938405" /></p></li>
<li><p>算法的分析
ThreeSum的运行时间增长数量级为N^3，与在哪台机器无关</p></li>
<li><p>成本模型
3-sum的成本模型：数组的访问次数（访问数组元素的次数，无论读写）</p></li>
<li><p>总结-得到运行时间的数学模型所需的步骤</p>
<ul>
<li>确定输入模型，定义问题的规模</li>
<li>识别内循环</li>
<li>根据内循环中的操作确定成本模型</li>
<li>对于给定的输入，判断这些操作的执行效率</li>
</ul></li>
</ul></li>
</ul>
<h3 id="增长数量级的分类">增长数量级的分类</h3>
<ul>
<li>成长增长的数量级一般都是问题规模N的若干函数之一，如下表 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408091530468.png"
alt="image-20220408091530468" />
<ul>
<li>常数级别表示运行时间不依赖于N</li>
<li>对数级别，经典例子是<strong>二分查找</strong></li>
<li>线性级别（常见的for循环）</li>
<li>线性对数级别 ，其中，对数的底数和增长的数量级无关</li>
<li>平方级别，一般指两个嵌套的for循环</li>
<li>立方级别，一般含有三个嵌套的for循环</li>
<li>指数级别</li>
</ul></li>
<li>问题规模（图） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408092436213.png"
alt="image-20220408092436213" /></li>
<li>典型的增长数量级函数（图） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408092500239.png"
alt="image-20220408092500239" /></li>
<li>典型的增长数量级函数 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408092659849.png"
alt="image-20220408092659849" /></li>
<li>在某个成本模型下可以提出精确的命题
比如，归并排序所需的比较次数在<span
class="math inline">\(1/2NlgN\)</span>~<span
class="math inline">\(NlgN\)</span>之间
，即归并排序所需的运行时间的增长数量级是线性对数的，也就是：归并排序是线性对数的</li>
</ul>
<h3 id="设计更快的算法">设计更快的算法</h3>
<ul>
<li><p>前提，目前已知归并排序是线性对数级别的，二分查找是对数级别的</p></li>
<li><p>将3-sum问题简化为2-sum问题，即找出一个输入文件中所有和为0的整数对的数量，为了简化问题，题设所有整数均不相同</p>
<ul>
<li><p>可以使用双层循环，以<strong>平方级别</strong>来解决</p></li>
<li><p>改进后的算法，当且仅当-a[i]存在于数组中且a[i]非零时，a[i]存在于某个和为0的整数对之中</p></li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoSumFast</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span>[] a)</span> &#123; <span class="comment">// 计算和为0的整数对的数目</span></span><br><span class="line">			Arrays.sort(a);</span><br><span class="line">			<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">			<span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">				<span class="keyword">if</span> (BinarySearch.rank(-a[i], a) &gt; i)</span><br><span class="line">					cnt++;</span><br><span class="line">			<span class="keyword">return</span> cnt;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">			<span class="type">int</span>[] a = In.readInts(args[<span class="number">0</span>]);</span><br><span class="line">			StdOut.println(count(a));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>3-sum问题的快速算法</p>
<ul>
<li><p>当且仅当-(a[i]+a[j])在数组中,且不是a[i]也不是a[j]时，整数对(a[i]和a[j])为某个和为0的三元组的一部分</p></li>
<li><p>总运行时间和<span
class="math inline">\(N^2logN\)</span>成正比</p></li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreeSumFast</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span>[] a)</span> &#123; <span class="comment">// 计算和为０的三元组的数目</span></span><br><span class="line">        Arrays.sort(a);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">                <span class="keyword">if</span> (BinarySearch.rank(-a[i] - a[j], a) &gt; j) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] a = In.readInts(args[<span class="number">0</span>]);</span><br><span class="line">        StdOut.println(count(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>下界</p>
<ul>
<li><p>为算法在最坏情况下的运行时间给出一个下界的思
想是非常有意义的</p></li>
<li><p>运行时间的总结</p>
<p>图1 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408095417424.png"
alt="image-20220408095417424" /> 图2 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408095509262.png"
alt="image-20220408095509262" /></p></li>
<li><p>实现并分析该问题的一种简单解法，我们称之为<strong>暴力算法</strong></p></li>
<li><p>算法的改进，能降低算法所需的运行时间的增长数量级</p></li>
</ul></li>
</ul></li>
</ul>
<h3 id="倍率实验">倍率实验</h3>
<ul>
<li><p>翻倍后运行时间，与没翻倍时的运行时间成正比</p></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublingRatio</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">timeTrial</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">		<span class="comment">// 参见DoublingTest（请见1.4.2.3 节实验程序）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="type">double</span> <span class="variable">prev</span> <span class="operator">=</span> timeTrial(<span class="number">125</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">250</span>; <span class="literal">true</span>; N += N)</span><br><span class="line">				&#123;</span><br><span class="line">			<span class="type">double</span> <span class="variable">time</span> <span class="operator">=</span> timeTrial(N);</span><br><span class="line">			StdOut.printf(<span class="string">&quot;%6d %7.1f &quot;</span>, N, time);</span><br><span class="line">			StdOut.printf(<span class="string">&quot;%5.1fn&quot;</span>, time/prev);</span><br><span class="line">			prev = time;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>试验结果 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408112657967.png"
alt="image-20220408112657967" /></li>
<li>预测 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408112708320.png"
alt="image-20220408112708320" /></li>
<li>倍率定理（没看懂，不管） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408112746465.png"
alt="image-20220408112746465" />
<ul>
<li>评估它解决大型问题的可行性</li>
<li>评估使用更快的计算机所产生的价值</li>
</ul></li>
</ul></li>
</ul>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>大常数，<span class="math inline">\(c = 10^3或10^6\)</span></li>
<li>非决定性的内循环</li>
<li>指令时间</li>
<li>系统因素</li>
<li>不分伯仲（相同任务在不同场景效率不一样）</li>
<li>对输入的强烈依赖</li>
<li>多个问题参量</li>
</ul>
<h3 id="处理对于输入的依赖">处理对于输入的依赖</h3>
<ul>
<li>输入模型，例如假设ThreeSum的所有输入均为随机int值，可能不切实际</li>
<li>输入的分析，需要数学几千</li>
<li>对最坏情况下的性能保证
<ul>
<li>命题（这里只针对之前的代码） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408113444176.png"
alt="image-20220408113444176" /></li>
</ul></li>
<li>对计划算法，有时候对输入需要进行打乱</li>
<li>操作序列</li>
<li>均摊分析 通过记录所有操作的总成本并除以操作总数来将成本均摊</li>
</ul>
<h3 id="内存">内存</h3>
<ul>
<li>Java的内存分配系统</li>
<li>原始数据类型的常见内存、需求 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408113805644.png"
alt="image-20220408113805644" />
这里漏了，short也是2字节。总结boolean、byte 1字节；char、short
2字节；int、float 4字节；long、double 8字节</li>
<li>对象（跳过）
<ul>
<li><p>要知道一个对象所使用的内存量，需要将所有实例变量使用的内存与内存本身的开销（一般是16字节）</p></li>
<li><p>一般内存的使用都会被填充为<strong>8字节的倍数</strong>（注意，说的是64位计算机中的机器字）</p></li>
<li><p><strong>引用</strong>存储需要8字节</p></li>
<li><p>典型对象的内存需求 例如第一个，16+4=20；20+4 = 24为8的倍数</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408114020688.png"
alt="image-20220408114020688" />
<figcaption aria-hidden="true">image-20220408114020688</figcaption>
</figure></li>
<li><p>链表，嵌套的非静态（内部）类，如<strong>上面的Node，需要额外的8字节</strong>（用于外部类的引用）</p></li>
<li><p>数组 int值、double值、对象和数组的数组对内存的典型需求
比如一个原始数据类型的数组，需要24字节的头信息（16字节的对象开销，4字节用于保存长度[数组长度]，以及4填充字节，再加上保存值需要的内存）
Date对象需要的：一个含有N 个Date 对象（请见表1.2.12）的数 组需要使用24
字节（数组开销）加上8N 字节（所有引用）加上每个对象的32 字节，总共（24
+40N）字节 【这里说的是需要，和本身存储是两回事】</p></li>
<li><figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408114325192.png"
alt="image-20220408114325192" />
<figcaption aria-hidden="true">image-20220408114325192</figcaption>
</figure></li>
<li><p>字符串对象</p>
<blockquote>
<p>String 的标准实现含有4 个实例变量：一个指向字符数组的引用（8
字节）和三 个int 值（各4 字节）。第一个int
值描述的是字符数组中的偏移量，第二个int
值是一个计数器（字符串的长度）。按照图1.4.10
中所示的实例变量名，对象所表示的字符串由value[offset]到value[offset +
count - 1] 中的字符组成。String 对象中的第三个int
值是一个散列值，它在某些情况下可以节省一些计算，我们现在可以忽略它。因此，每个String
对象总共会使用40字节（16 字节表示对象，三个int 实例变量各需4
字节，加上数组引用的8 字节和4 个填充字节）</p>
</blockquote></li>
<li><p>字符串的值和子字符串</p>
<ul>
<li>一个长度为N 的String 对象一般需要使用40 字节（String
对象本身）加上（24+2N）字节（字符数组），总共（64+2N）字节</li>
<li>Java 对字符串的表示希望能够避免复制字符串中的字符</li>
<li>一个子字符串所需的额外内存是一个常数，构造一个子字符串所需的时间也是常数</li>
<li>关于子字符串 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220408151726265.png"
alt="image-20220408151726265" /></li>
</ul></li>
</ul></li>
</ul>
<h3 id="展望">展望</h3>
<ul>
<li>最重要的是代码正确，其次才是性能</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法红皮书(第四版)</tag>
      </tags>
  </entry>
  <entry>
    <title>算法红皮书 1.5.1-1.5.3</title>
    <url>/2022/04/09/study/algorithm/algorithhms_4th/1.5.1-1.5.3/</url>
    <content><![CDATA[<h2 id="案例研究union-find-算法">案例研究：union-find 算法</h2>
<ul>
<li>设计和分析算法的基本方法
<ul>
<li>优秀的算法能解决实际问题</li>
<li>高效的算法也可以很简单</li>
<li>理解某个实现的性能特点是一项有趣的挑战</li>
<li>在解决同一个问题的多种算法间选择，科学方法是一种重要工具</li>
<li>迭代式改进能让算法效率越来越高</li>
</ul></li>
</ul>
<h3 id="动态连通性">动态连通性</h3>
<ul>
<li>从输入中读取整数对p
q，如果已知的所有整数对都不能说明p,q相连，就打印出pq</li>
<li>网络：整个程序能够判定是否需要在pq之间架设一条新的连接才能进行通信</li>
<li>变量名等价性（即指向同一个对象的多个引用）</li>
<li>数学集合：在处理一个整数对pq时，我们是在判断它们是否属于相同的集合</li>
<li>本节中，将对象称为<strong>触点</strong>，整数对称为<strong>连接</strong>，等价类称为<strong>连通分量</strong>或是<strong>简称分量</strong></li>
<li>连通性
问题只要求我们的程序能够判别给定的整数对pq是否相连，并没有要求给两者之间的通路上的所有连接</li>
<li>union-find算法的API<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220413001331923.png"
alt="image-20220413001331923" /></li>
<li>数据结构和算法的设计影响到算法的效率</li>
</ul>
<h3 id="实现">实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UF</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[]	id;</span><br><span class="line">	<span class="comment">/* 分量id（以触点作为索引） */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>	count;</span><br><span class="line">	<span class="comment">/* 分量数量 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">UF</span><span class="params">( <span class="type">int</span> N )</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">/* 初始化分量id数组 */</span></span><br><span class="line">		count	= N;</span><br><span class="line">		id	= <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">		<span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++ )</span><br><span class="line">					id[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">return</span>(count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Boolean <span class="title function_">connected</span><span class="params">( <span class="type">int</span> p, <span class="type">int</span> q )</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">return</span>(find( p ) == find( q ) );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">( <span class="type">int</span> p )</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">( <span class="type">int</span> p, <span class="type">int</span> q )</span></span><br><span class="line">	<span class="comment">/* 请见1.5.2.1节用例（quick-find）、1.5.2.3节用例（quick-union）和算法1.5（加权quick-union） */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">/* 解决由StdIn得到的动态连通性问题 */</span></span><br><span class="line">		<span class="type">int</span>	<span class="variable">N</span>	<span class="operator">=</span> StdIn.readint();</span><br><span class="line">		<span class="comment">/* 读取触点数量 */</span></span><br><span class="line">		<span class="type">UF</span>	<span class="variable">uf</span>	<span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UF</span>( N );</span><br><span class="line">		<span class="comment">/* 初始化N个分量 */</span></span><br><span class="line">		<span class="keyword">while</span> ( !StdIn.isEmpty() )</span><br><span class="line">				&#123;</span><br><span class="line">			<span class="type">int</span>	<span class="variable">p</span>	<span class="operator">=</span> StdIn.readint();</span><br><span class="line">			<span class="type">int</span>	<span class="variable">q</span>	<span class="operator">=</span> StdIn.readint();</span><br><span class="line">			<span class="comment">/* 读取整数对 */</span></span><br><span class="line">			<span class="keyword">if</span> ( uf.connected( p, q ) )</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">/* 如果已经连通则忽略 */</span></span><br><span class="line">			uf.union( p, q );</span><br><span class="line">			<span class="comment">/* 归并分量 */</span></span><br><span class="line">			StdOut.println( p + <span class="string">&quot; &quot;</span> + q );</span><br><span class="line">			<span class="comment">/* 打印连接 */</span></span><br><span class="line">		&#125;</span><br><span class="line">		StdOut.println( uf.count() + <span class="string">&quot;components&quot;</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>union-find的成本模型：union-find
API的各种算法，统计的是<strong>数组的访问次数</strong>，不论读写</p>
<ul>
<li><p>以下有三种实现</p>
<ul>
<li><p>且仅当id[p] 等于id[q] 时p 和q 是连通的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> id[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 将p和q归并到相同的分量中</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">pID</span> <span class="operator">=</span> find(p);mi</span><br><span class="line">	<span class="type">int</span> <span class="variable">qID</span> <span class="operator">=</span> find(q);</span><br><span class="line">	<span class="comment">// 如果p和q已经在相同的分量之中则不需要采取任何行动</span></span><br><span class="line">	<span class="keyword">if</span> (pID == qID) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 将p的分量重命名为q的名称</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; id.length; i++)</span><br><span class="line">	<span class="keyword">if</span> (id[i] == pID) id[i] = qID;</span><br><span class="line">	count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命题F：在quick-find 算法中，每次find()
调用只需要访问数组一次，而归并两个分量的union()
操作访问数组的次数在(N+3) 到(2N+1) 之间。<br />
证明：由代码马上可以知道，每次connected() 调用都会检查id[]
数组中的两个元素是否相等，即会调用两次find() 方法。归并两个分量的union()
操作会调用两次find()，检查id[] 数组中的全部N 个元素并改变它们中1 到N-1
个元素的值。</p>
</blockquote>
<blockquote>
<p>假设我们使用quick-find
算法来解决动态连通性问题并且最后只得到了一个连通分量，那么这至少需要调用N-1
次union()，即至少(N+3)(N-1) ～ N2
次数组访问——我们马上可以猜想动态连通性的quick-find 算法是平方级别的</p>
</blockquote></li>
<li><p>以触点作为索引的id[]数组，每个触点所对应的id[]元素都是同一个分量中的另一个触点的名称
如下图： <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220413222744695.png"
alt="image-20220413222744695" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 找出分量的名称</span></span><br><span class="line">	<span class="keyword">while</span> (p != id[p]) p = id[p];</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 将p和q的根节点统一</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">	<span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">	<span class="keyword">if</span> (pRoot == qRoot) <span class="keyword">return</span>;</span><br><span class="line">	id[pRoot] = qRoot;</span><br><span class="line">	count--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>quick-union算法的最坏情况 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220413223324173.png"
alt="image-20220413223324173" /></p></li>
<li><p>加权quick-union算法（减少树的高度）
用一个数组来表示各个节点对应的分量的大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeightedQuickUnionUF</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">	<span class="comment">// 父链接数组（由触点索引）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[] sz;</span><br><span class="line">	<span class="comment">// （由触点索引的）各个根节点所对应的分量的大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">	<span class="comment">// 连通分量的数量</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">WeightedQuickUnionUF</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">	&#123;</span><br><span class="line">		count = N;</span><br><span class="line">		id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) id[i] = i;</span><br><span class="line">		sz = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) sz[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Boolean <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 跟随链接找到根节点</span></span><br><span class="line">		<span class="keyword">while</span> (p != id[p]) p = id[p];</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> find(p);</span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> find(q);</span><br><span class="line">		<span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 将小树的根节点连接到大树的根节点</span></span><br><span class="line">		<span class="keyword">if</span> (sz[i] &lt; sz[j]) &#123;</span><br><span class="line">			id[i] = j;</span><br><span class="line">			sz[j] += sz[i];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			id[j] = i;</span><br><span class="line">			sz[i] += sz[j];</span><br><span class="line">		&#125;</span><br><span class="line">		count--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>quick-union 算法与加权quick-union 算法的对比（100 个触点，88
次union() 操作） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220413223710124.png"
alt="image-20220413223710124" /></p></li>
</ul></li>
<li><p>所有操作的总成本 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220413223824910.png"
alt="image-20220413223824910" /></p></li>
</ul>
<h3 id="展望">展望</h3>
<p>研究问题的步骤</p>
<ul>
<li>完整而详细地定义问题，找出解决问题所必需的基本抽象操作并定义一份
API。</li>
<li>简洁地实现一种初级算法，给出一个精心组织的开发用例并使用实际数据作为输入。</li>
<li>当实现所能解决的问题的最大规模达不到期望时决定改进还是放弃。</li>
<li>逐步改进实现，通过经验性分析或（和）数学分析验证改进后的效果。</li>
<li>用更高层次的抽象表示数据结构或算法来设计更高级的改进版本。</li>
<li>如果可能尽量为最坏情况下的性能提供保证，但在处理普通数据时也要有良好的性能。</li>
<li>在适当的时候将更细致的深入研究留给有经验的研究者并继续解决下一个问题。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法红皮书(第四版)</tag>
      </tags>
  </entry>
  <entry>
    <title>算法红皮书 2.1.1</title>
    <url>/2022/04/13/study/algorithm/algorithhms_4th/2.1.1/</url>
    <content><![CDATA[<h1 id="排序">排序</h1>
<p>排序就是将一组对象按照某种逻辑顺序重新排序的过程</p>
<ul>
<li>对排序算法的分析有助于理解本书中比较算法性能的方法</li>
<li>类似技术能解决其他类型问题</li>
<li>排序算法常常是我们解决其他问题的第一步</li>
</ul>
<h2 id="初级排序算法">初级排序算法</h2>
<ul>
<li>熟悉术语及技巧</li>
<li>某些情况下初级算法更有效</li>
<li>有助于改进复杂算法的效率</li>
</ul>
<h3 id="游戏规则">游戏规则</h3>
<ul>
<li><p>主要关注重新排序<strong>数组元素</strong>的算法，每个元素都会有一个<strong>主键</strong></p></li>
<li><p>排序后索引较大的主键大于索引较小的主键</p></li>
<li><p>一般情况下排序算法通过两个方法操作数据，less()进行比较，exch()进行交换</p></li>
<li><p>排序算法类的模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 请见算法2.1、算法2.2、算法2.3、算法2.4、算法2.5或算法2.7*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title function_">less</span><span class="params">(Comparable v, Comparable w)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Comparable</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Comparable[] a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 在单行中打印数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">		StdOut.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		StdOut.println();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">isSorted</span><span class="params">(Comparable[] a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 测试数组元素是否有序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">		<span class="keyword">if</span> (less(a[i], a[i-<span class="number">1</span>])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]</span></span><br><span class="line"><span class="params">	args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 从标准输入读取字符串，将它们排序并输出</span></span><br><span class="line">		String[] a = In.readStrings();</span><br><span class="line">		sort(a);</span><br><span class="line">		<span class="keyword">assert</span> <span class="title function_">isSorted</span><span class="params">(a)</span>;</span><br><span class="line">		show(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">% </span><span class="language-bash">more tiny.txt</span></span><br><span class="line">S O R T E X A M P L E</span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">java Example &lt; tiny.txt</span></span><br><span class="line">A E E L M O P R S T X</span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">more words3.txt</span></span><br><span class="line">bed bug dad yes zoo ... all bad yet</span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">java Example &lt; words.txt</span></span><br><span class="line">all bad bed bug dad ... yes yet zoo</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>使用assert验证</p></li>
<li><p>排序成本模型：在研究排序算法时，我们需要计算比较和交换的数量。对于不交换元素的算法，我们会比较访问数组的次数</p></li>
<li><p>额外内存开销和运行时间同等重要，排序算法分为</p>
<ul>
<li>除了函数调用需要的栈和固定数目的实例变量之外，无需额外内存的<strong>原地排序算法</strong></li>
<li>需要额外内存空间来存储另一份数组副本的<strong>其他排序算法</strong></li>
</ul></li>
<li><p>数据类型</p>
<ul>
<li><p>排序模板适用于任何实现了Comparable接口的数据类型</p></li>
<li><p>对于自己的数据类型，实现Comparable接口即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Date&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> day;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> month;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> year;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> m, <span class="type">int</span> y)</span></span><br><span class="line">	&#123;</span><br><span class="line">		day = d;</span><br><span class="line">		month = m;</span><br><span class="line">		year = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">day</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> day;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">month</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> month;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">year</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> year;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Date that)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.year &gt; that.year ) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.year &lt; that.year ) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.month &gt; that.month) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.month &lt; that.month) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.day &gt; that.day ) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.day &lt; that.day ) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> month + <span class="string">&quot;/&quot;</span> + day + <span class="string">&quot;/&quot;</span> + year;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>compareTo()必须实现<strong>全序关系</strong>
<ul>
<li>自反性，反对称性及传递性</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>经典算法，包括选择排序、插入排序、希尔排序、归并排序、快速排序和堆排序</p></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法红皮书(第四版)</tag>
      </tags>
  </entry>
  <entry>
    <title>算法红皮书 2.1.2-2.1.3</title>
    <url>/2022/04/23/study/algorithm/algorithhms_4th/2.1.2-2.1.3/</url>
    <content><![CDATA[<h1 id="排序">排序</h1>
<h2 id="初级排序算法">初级排序算法</h2>
<h3 id="选择排序">选择排序</h3>
<ul>
<li><p>命题A。对于长度为N 的数组，选择排序需要大约 N^2/2 次比较和N
次交换。</p></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将a[]按升序排列</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">		<span class="comment">// 数组长度</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 将a[i]和a[i+1..N]中最小的元素交换</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">			<span class="comment">// 最小元素的索引</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; N; j++)</span><br><span class="line">			<span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">			exch(a, i, min);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>特点</p>
<ul>
<li>运行时间与输入无关，即输入数据的初始状态（比如是否已排序好等等）不影响排序时间</li>
<li>数据移动是最少的（只使用了N次交换，交换次数和数组的大小是线性关系</li>
</ul></li>
</ul>
<h3 id="插入排序">插入排序</h3>
<ul>
<li><p>命题B。对于随机排列的长度为N
且主键不重复的数组，平均情况下插入排序需要～ N^2/4 次比较以及～ N^2/4
次交换。最坏情况下需要～ N^2/2 次比较和～ N^2/2
次交换，最好情况下需要N-1次比较和0 次交换。</p></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="comment">//将下表为 n-1的数，依次和n-2,n-3一直到0比较，</span></span><br><span class="line">        <span class="comment">//所以第二层for只走到1，因为0前面没有值</span></span><br><span class="line">        <span class="comment">//如果比前面的值小，就进行交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j - <span class="number">1</span>]); j--) &#123;</span><br><span class="line">                exch(a, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当倒置的数量很小时，插入排序比本章中的其他任何算法都快</p></li>
<li><blockquote>
<p>命题C。插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。</p>
</blockquote></li>
<li><blockquote>
<p>性质D。对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数</p>
</blockquote></li>
</ul>
<h3 id="希尔排序">希尔排序</h3>
<ul>
<li><p>希尔排序的思想是使数组中任意间隔为h的元素都是有序的，这样的数组称为h有序数组，一个h有序数组就是h个互相独立的有序数组编制在一起组成的数组</p></li>
<li><p>算法2.3 的实现使用了序列1/2（3k-1），从N/3
开始递减至1。我们把这个序列称为递增序列</p></li>
<li><p>详述</p></li>
<li><p>实现希尔排序的一种方法是对于每个h，用插入排序将h
个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是在h-
子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由1
改为h
即可。这样，希尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。</p></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将a[]按升序排列</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">		<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 1, 4, 13, 40, 121, 364, 1093, ...</span></span><br><span class="line">		<span class="keyword">while</span> (h &gt;= <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 将数组变为h有序</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; N; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 将a[i]插入到a[i-h], a[i-2*h], a[i-3*h]... 之中</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h)</span><br><span class="line">				exch(a, j, j-h);</span><br><span class="line">			&#125;</span><br><span class="line">			h = h/<span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// less()、exch()、isSorted()和main()方法见“排序算法类模板”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过提升速度来解决其他方式无法解决的问题是研究算法的设计和性能的主要原因之一</p></li>
</ul>
<h2 id="归并排序">归并排序</h2>
<p>归并排序最吸引人的性质是它能够保证将任意长度为N的数组排序所需时间和NlogN成正比，主要缺点是他所需的额外空间和N成正比</p>
<ul>
<li>归并排序示意图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220426112820116.png"
alt="image-20220426112820116" /></li>
</ul>
<h3 id="自顶向下的归并排序">自顶向下的归并排序</h3>
<ul>
<li><p>原地归并的抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里有一个前提，就是a[i..mid]是有序的，</span></span><br><span class="line"><span class="comment"> * a[mid..hi]是有序的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Comparable[] a,</span></span><br><span class="line"><span class="params">                         <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//先在辅助数组赋上需要的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最坏情况下这里时需要比较hi-lo+1次的，也就是数组长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            <span class="comment">//说明i(左边）比较完了，直接拿右边的值放进去</span></span><br><span class="line">            a[k] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;</span><br><span class="line">            <span class="comment">//说明j(右边)比较完了，直接拿左边的值放进去</span></span><br><span class="line">            a[k] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) &#123;</span><br><span class="line">            <span class="comment">//左右都还有值的情况下，取出最小的值放进去</span></span><br><span class="line">            a[k] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>递归进行归并排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//保证左边有序</span></span><br><span class="line">        sort(a, lo, mid);</span><br><span class="line">        <span class="comment">//保证右边有序</span></span><br><span class="line">        sort(a, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">//归并数组有序的两部分</span></span><br><span class="line">        merge(a, lo, mid, hi);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>辅助数组的一次性初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="title class_">Comparable</span>[a.length];<span class="comment">//辅助数组，一次性分配空间</span></span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自顶向下的归并排序的调用轨迹 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220426111242973.png"
alt="image-20220426111242973" /></p></li>
<li><p>N=16时归并排序中子数组的依赖树 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220426140310539.png"
alt="image-20220426140310539" /></p></li>
<li><p>每个结点都表示一个sort() 方法通过merge()
方法归并而成的子数组。这棵树正好有n 层。对于0 到n-1
之间的任意k，自顶向下的第k 层有2^k 个子数组，每个数组的长度为 <span
class="math inline">\(2^{(n-k)}\)</span>，归并最多需要<span
class="math inline">\(2^{(n-k)}\)</span>次比较。因此每层的比较次数为$
2^k * 2 ^ {( n - 1 )} = 2 ^ n $ ，n层总共为 <span
class="math inline">\(n*2^n = lg N * (2 ^ { lg N}) = lg N *
N\)</span></p></li>
<li><blockquote>
<p>命题F。对于长度为N 的任意数组，自顶向下的归并排序需要(1/2)N lgN 至N
lgN 次比较。</p>
<p>注：因为归并所需要的比较次数最少为N/2</p>
</blockquote></li>
<li><blockquote>
<p>命题G。对于长度为N
的任意数组，自顶向下的归并排序最多需要访问数组6NlgN 次。
证明。每次归并最多需要访问数组6N 次（2N 次用来复制，2N
次用来将排好序的元素移动回去，另外最多比较2N 次），根据命题F
即可得到这个命题的结果。</p>
</blockquote></li>
</ul>
<h3 id="自底向上的归并排序">自底向上的归并排序</h3>
<p>递归实现的归并排序时算法设计中<strong>分治思想</strong>
的典型应用<br />
自底向上的归并排序的可视轨迹</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220426153552531.png" /></p>
<ul>
<li><p>源代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">       aux = <span class="keyword">new</span> <span class="title class_">Comparable</span>[N];</span><br><span class="line">       <span class="comment">//每次合并的子数组长度翻倍</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> <span class="number">1</span>; sz &lt; N; sz = sz + sz) &#123;</span><br><span class="line">           <span class="comment">//lo:子数组索引 </span></span><br><span class="line">           <span class="comment">//边界问题， 假设是N为2^n，则倒数第二个数组的元素的下标，一定在倒数第一个元素下标(n-sz)之前</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> <span class="number">0</span>; lo &lt; N - sz; lo += sz + sz) &#123;</span><br><span class="line">               <span class="comment">//循环合并一个个的小数组</span></span><br><span class="line">               merge(a, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>子数组的大小sz的初始值为1，每次加倍</p></li>
<li><p>最后一个子数组的大小只有在数组大小是sz的偶数倍的时候才会等于sz（否则比sz小)</p></li>
<li><blockquote>
<p>命题H。对于长度为N 的任意数组，自底向上的归并排序需要1/2NlgN 至NlgN
次比较，最多访问数组6NlgN 次。</p>
</blockquote></li>
<li><blockquote>
<p>自底向上的归并排序比较适合用链表组织的数据。想象一下将链表先按大小为1
的子链表进行排序，然后是大小为2 的子链表，然后是大小为4
的子链表等。这种方法只需要重新组织链表链接就能将链表原地排序（不需要创建任何新的链表结点）</p>
</blockquote></li>
<li><p>归并排序告诉我们，当能够用其中一种方法解决一个问题时，都应该试试另一种，可以像Merge.sort()那样化整为零（然后递归地解决）问题，或者像MergeBU.sort()那样循序渐进的解决问题</p></li>
<li><blockquote>
<p>命题I。没有任何基于比较的算法能够保证使用少于lg（N!）～ NlgN
次比较将长度为N 的数组排序</p>
</blockquote></li>
<li><blockquote>
<p>命题J。归并排序是一种渐进最优的基于比较排序的算法。</p>
</blockquote></li>
</ul></li>
</ul>
<h2 id="快速排序">快速排序</h2>
<p>快速排序是应用最广泛的排序算法</p>
<h3 id="基本算法">基本算法</h3>
<ul>
<li><p>是一种分治的排序算法，将一个数组分成两个子数组，将两部分独立的排序</p></li>
<li><p>归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将两个数组排序；快速排序将数组排序的方式是当两个子数组都有序时整个数组也都有序了</p></li>
<li><p>归并排序：递归调用发生在处理数组之前；快速排序：递归调用发生在处理数组之后</p></li>
<li><p>归并排序中数组被分为两半；快速排序中切分取决于数组内容</p></li>
<li><p>快速排序示意图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220503184109136.png"
alt="image-20220503184109136" /></p></li>
<li><p>递归代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(a, lo, hi); <span class="comment">//切分</span></span><br><span class="line">        sort(a, lo, j - <span class="number">1</span>); <span class="comment">/// 将左半部分a[lo .. j-1]排序</span></span><br><span class="line">        sort(a, j + <span class="number">1</span>, hi);<span class="comment">//将右半部分a[j+1..hi]排序</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>快速排序递归的将子数组a[lo..hi]排序，先用partition()方法将a[j]放到一个合适的位置，然后再用递归调用将其他位置的元素排序
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220503184859350.png"
alt="image-20220503184859350" /></p></li>
<li><p>切分后使得数组满足三个条件</p>
<ul>
<li>对于某个j，a[j]已经排定</li>
<li>a[lo]到a[j-1]的所有元素都不大于a[j]</li>
<li>a[j+1]的所有元素都不小于a[j]</li>
</ul></li>
<li><p>归纳法证明数组有序：</p>
<blockquote>
<p>如果左子数组和右子数组都是有序的，那么由左子数组（有序且没有任何元素大于切分元素）、切分元素和右子数组（有序且没有任何元素小于切分元素）组成的结果数组也一定是有序的</p>
</blockquote></li>
</ul></li>
<li><blockquote>
<p>一般策略是先随意地取a[lo]
作为切分元素，即那个将会被排定的元素，然后我们从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素显然是没有排定的，因此我们交换它们的位置。如此继续，我们就可以保证左指针i
的左侧元素都不大于切分元素，右指针j
的右侧元素都不小于切分元素。当两个指针相遇时，我们只需要将切分元素a[lo]
和左子数组最右侧的元素（a[j]）交换然后返回j 即可</p>
</blockquote></li>
<li><p>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = hi + <span class="number">1</span>; <span class="comment">//左右扫描指针</span></span><br><span class="line">    <span class="type">Comparable</span> <span class="variable">v</span> <span class="operator">=</span> a[lo]; <span class="comment">//切分元素</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//从左往右扫描，如果找到了大于等于v值的数，就退出循环</span></span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右往左扫描，如果找到了小于等于v值得数，就退出循环</span></span><br><span class="line">        <span class="keyword">while</span> (less(a[--j], v)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;<span class="comment">//如果i，j相遇则退出循环</span></span><br><span class="line">        <span class="comment">//将左边大于等于v值的数与右边小于等于v值的数交换</span></span><br><span class="line">        exch(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面的遍历结束后，a[lo+1...j]和a[i..hi]都已经分别有序</span></span><br><span class="line">    <span class="comment">//且a[j]&lt;=a[i]&lt;=a[lo]，所以应该交换a[lo]和a[j](而不是a[i)，因为</span></span><br><span class="line">    <span class="comment">//a[i]有可能大于a[lo]</span></span><br><span class="line">    exch(a, lo, j);</span><br><span class="line">    <span class="comment">//返回a[lo]被交换的位置</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>切分轨迹 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220503190908482.png"
alt="image-20220503190908482" /></p></li>
<li></li>
</ul>
<h3 id="性能特点">性能特点</h3>
<blockquote>
<p>将长度为N的无重复数组排序，快速排序平均需要~2N lnN
次比较（以及1/6的交换）</p>
</blockquote>
<h3 id="算法改进">算法改进</h3>
<p>三向切分</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法红皮书(第四版)</tag>
      </tags>
  </entry>
  <entry>
    <title>算法红皮书 2.4</title>
    <url>/2022/05/27/study/algorithm/algorithhms_4th/2.4/</url>
    <content><![CDATA[<h1 id="优先队列">优先队列</h1>
<ul>
<li>有些情况下，不需要要求处理的元素全部有序，只要求每次都处理键值最大的元素，然后再收集更多的元素，然后再处理键值最大的元素</li>
<li>需要一种数据结构，支持操作：删除最大元素和插入元素，这种数据类型叫做优先队列</li>
<li>优先队列的基本表现形式：其一或两种操作都能在线性时间内完成</li>
<li>基于<strong>二叉堆数据结构</strong>的优先队列，用数组保存元素并按照一定条件排序，以实现高效的删除最大元素和插入元素</li>
</ul>
<h2 id="api">API</h2>
<ul>
<li><p>抽象数据类型，最重要的操作是删除最大元素和插入元素
delMax()和insert()</p></li>
<li><p>用“最大元素”代替“最大键值”或是“键值最大的元素”</p></li>
<li><p>泛型优先队列的API <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220530231019846.png"
alt="image-20220530231019846" /></p></li>
<li><p>优先队列的调用示例 从N各输入中找到最大的M各元素所需成本 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220530231059427.png"
alt="image-20220530231059427" /></p>
<ul>
<li><p>优先队列的用例
pq里面最多放5个，当大于5个的时候，就从中剔除1个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopM</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 打印输入流中最大的M行</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> Integer.parseint(args[<span class="number">0</span>]);</span><br><span class="line">		MinPQ&lt;Transaction&gt; pq = <span class="keyword">new</span> <span class="title class_">MinPQ</span>&lt;Transaction&gt;(M+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span> (StdIn.hasNextLine())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 为下一行输入创建一个元素并放入优先队列中</span></span><br><span class="line">			pq.insert(<span class="keyword">new</span> <span class="title class_">Transaction</span>(StdIn.readLine()));</span><br><span class="line">			<span class="keyword">if</span> (pq.size() &gt; M)</span><br><span class="line">			  pq.delMin();</span><br><span class="line">			<span class="comment">// 如果优先队列中存在M+1个元素则删除其中最小的元素</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 最大的M个元素都在优先队列中</span></span><br><span class="line">		Stack&lt;Transaction&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Transaction&gt;();</span><br><span class="line">		<span class="keyword">while</span> (!pq.isEmpty()) stack.push(pq.delMin());</span><br><span class="line">		<span class="keyword">for</span> (Transaction t : stack) StdOut.println(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>应用 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220530231154665.png"
alt="image-20220530231154665" /></p></li>
</ul></li>
</ul>
<h2 id="初级实现">初级实现</h2>
<ul>
<li>数组实现（无序）
insert元素和栈的push()方法完全一样；要删除最大元素，可以添加一段类似选择排序的内循环的代码，将最大元素的边界元素交换，然后删除</li>
<li>数组实现（有序）
insert()方法时，始终将较大的元素，向右边移动一格以使数组有序；<strong>删除</strong>最大元素就是pop()</li>
<li>链表表示法</li>
<li>可以用基于链表的下压栈的代码作为基础，而后可以选择修改pop()
来找到并返回最大元素，或是修改push() 来保证所有元素为逆序并用pop()
来删除并返回链表的首元素(也就是最大的元素)</li>
<li>优先队列的各种实现在最坏情况下运行时间的增长数量级 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220530231218833.png"
alt="image-20220530231218833" /></li>
<li>在一个优先队列上执行的一系列操作如表2.4.4所示 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220530231233202.png"
alt="image-20220530231233202" /></li>
</ul>
<h2 id="堆的定义">堆的定义</h2>
<blockquote>
<p>当一棵二叉树的每个节点都大于等于他的两个子结点时，它被称为堆有序</p>
</blockquote>
<ul>
<li><p>重要性质1</p>
<p>在堆有序的二叉树中，每个结点都小于等于它的父结点（如果有的话）。从任意结点向上，我们都能得到一列非递减的元素；从任意结点向下，我们都能得到一列非递增的元素</p></li>
<li><p>重要命题 根结点是堆有序的二叉树中的最大结点</p></li>
<li><p>二叉堆表示法</p>
<ul>
<li>如果使用指针来表示堆有序的二叉树，需要三个指针来找到它的上下结点</li>
<li>使用数组来表示(前提是使用完全二叉树来表示)，那么只要一层一层由上向下从左至右，在每个结点的下方连接两个更小的结点，直至将N个结点全部连接完毕
即将二叉树的结点按照层级顺序放入数组中</li>
</ul></li>
<li><blockquote>
<p>二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使
用数组的第一个位置）</p>
</blockquote></li>
<li><p>图解 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220530231408925.png"
alt="image-20220530231408925" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220530231421881.png"
alt="image-20220530231421881" />
<figcaption aria-hidden="true">image-20220530231421881</figcaption>
</figure></li>
<li><p>下面将<strong>二叉树</strong> 简称为堆</p></li>
<li><p>在一个堆中，位置k
的结点的父结点的位置为k/2，而它的两个子结点的位置则分别为2k
和2k+1。这样在不使用指针的情况下（我们在第3
章中讨论二叉树时会用到它们）我们也可以通过计算数组的索引在树中上下移动：从a[k]
向上一层就令k 等于k/2，向下一层则令k 等于2k 或2k+1</p></li>
<li><blockquote>
<p>一棵大小为N的完全二叉树的高度为[lgN]</p>
</blockquote>
<p>当N达到2的幂时树的高度为加1 数组不使用位置[0]</p></li>
<li></li>
</ul>
<h2 id="堆的算法">堆的算法</h2>
<ul>
<li><p>堆实现的比较和交换方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Boolean <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">Key</span> <span class="variable">t</span> <span class="operator">=</span> pq[i];</span><br><span class="line">	pq[i] = pq[j];</span><br><span class="line">	pq[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>堆的操作首先进行一些简单的改动，打破堆的状态，再遍历堆并按照要求将堆的状态回复，这个过程称为堆的<strong>有序化</strong></p></li>
<li><p>当某个结点的优先级上升（或是在堆底加入一个新的元素）时，我们需要由下至上恢复堆的顺序。当某个结点的优先级下降（例如，将根结点替换为一个较小的元素）时，我们需要由上至下恢复堆的顺序</p></li>
<li><p>由下至上的堆有序化（上浮）<em>【在最后位置插入一个元素】</em></p>
<ul>
<li><p>说明
如果堆的有序状态因为某个结点变得比它的父结点更大而被打破，那么我们就需要通过交换它和它的父结点来修复堆。交换后，这个结点比它的两个子结点都大（一个是曾经的父结点，另一个比它更小，因为它是曾经父结点的子结点），但这个结点仍然可能比它现在的父结点更大。我们可以一遍遍地用同样的办法恢复秩序，将这个结点不断向上移动直到我们遇
到了一个更大的父结点。</p></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>, k))</span><br><span class="line">	&#123;</span><br><span class="line">		exch(k/<span class="number">2</span>, k);</span><br><span class="line">		k = k/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>由上至下的堆有序化（下沉）<em>【在根节点插入一个元素】</em></p>
<ul>
<li><p>如果堆的有序状态因为某个结点变得比它的两个子结点或是其中之一更小了而被打破了，那么我们可以通过将它和它的两个子结点中的较大者交换来恢复堆。交换可能会在子结点处继续打破堆的有序状态，因此我们需要不断地用相同的方式将其修复，将结点向下移动直到它的子结点都比它更小或是到达了堆的底部</p></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>*k;</span><br><span class="line">    <span class="comment">//j&lt;N用来判断j是否存在右兄弟结点，当j==N（即j为树的[从左到右]最末一个结点，那么它没有右兄弟结点）</span></span><br><span class="line">		<span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j+<span class="number">1</span>)) j++;</span><br><span class="line">    <span class="comment">//当根节点没有小于子节点时，跳出循环</span></span><br><span class="line">		<span class="keyword">if</span> (!less(k, j)) <span class="keyword">break</span>;</span><br><span class="line">		exch(k, j);</span><br><span class="line">		k = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>对于上面的说明</p>
<ul>
<li>插入元素。我们将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位
置（如图2.4.5 左半部分所示）。</li>
<li>删除最大元素。我们从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减
小堆的大小并让这个元素下沉到合适的位置（如图2.4.5 右半部分所示）</li>
<li>上面对优先队列API的实现，能够保证插入元素和删除元素这两个操作的用时，和队列的大小仅成对数关系</li>
</ul></li>
<li><p>图解堆的操作 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220530231448254.png"
alt="image-20220530231448254" /></p></li>
<li><p>基于堆的优先队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> Key[] pq;</span><br><span class="line">	<span class="comment">// 基于堆的完全二叉树</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 存储于pq[1..N]中，pq[0]没有使用</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MaxPQ</span><span class="params">(<span class="type">int</span> maxN)</span></span><br><span class="line">	&#123;</span><br><span class="line">		pq = (Key[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[maxN+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Boolean <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">return</span> <span class="variable">N</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> N;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key v)</span></span><br><span class="line">	&#123;</span><br><span class="line">		pq[++N] = v;</span><br><span class="line">		swim(N);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Key</span> <span class="variable">max</span> <span class="operator">=</span> pq[<span class="number">1</span>];</span><br><span class="line">		<span class="comment">// 从根结点得到最大元素</span></span><br><span class="line">		exch(<span class="number">1</span>, N--);</span><br><span class="line">		<span class="comment">// 将其和最后一个结点交换</span></span><br><span class="line">		pq[N+<span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">		<span class="comment">// 防止对象游离</span></span><br><span class="line">		sink(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 恢复堆的有序性</span></span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 辅助方法的实现请见本节前面的代码框</span></span><br><span class="line">	<span class="keyword">private</span> Boolean <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>说明</p>
<ul>
<li><p>优先队列由一个基于堆的完全二叉树表示， 存储于数组pq[1..N]
中，pq[0] 没有使用。在insert() 中，我们将N
加一并把新元素添加在数组最后，然后用swim() 恢复堆的秩序。在delMax()
中，我们从pq[1] 中得到需要返回的元素，然后将pq[N] 移动到pq[1]，将N
减一并用sink() 恢复堆的秩序。同时我们还将不再使用的pq[N+1]
设为null，以便系统回收它所占用的空间。和以前一样（请见1.3
节），这里省略了动态调整数组大小的代码</p></li>
<li><blockquote>
<p>对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过（lgN+1）次比较，删除最大元素的操作需要不超过2lgN
次比较。</p>
</blockquote></li>
<li><p>在堆上进行操作 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220530231507695.png"
alt="image-20220530231507695" /></p></li>
</ul></li>
<li><p>多叉堆
基于用数组表示的完全三叉树构造堆并修改相应的代码并不困难。对于数组中1
至N 的N 个元素，位置k的结点大于等于位于3k-1、3k 和3k+1
的结点，小于等于位于(k+1)/3 的结点</p></li>
<li><p>调整数组大小 添加一个没有参数的构造函数， 在insert()
中添加将数组长度加倍的代码，在delMax()中添加将数组长度减半的代码，就像在1.3
节中的栈那样</p></li>
<li><p>元素的不可变性
优先队列存储了用例创建的对象，但同时假设用例代码不会改变它们</p></li>
<li><p>索引优先队列
注意minIndex()，最小元素的索引不一定是0，这里说的索引不是IndexMinPQ数据结构中的数组的索引。这两个不是一个意思
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220530231606619.png"
alt="image-20220530231606619" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220530231629490.png"
alt="image-20220530231629490" /></p>
<ul>
<li>表2.4.6 含有N
个元素的基于堆的索引优先队列所有操作在最坏情况下的成本</li>
</ul></li>
</ul></li>
<li><p>索引优先队列用例
将多个<strong>有序</strong>的输入流归并成一个有序的输出流
★注意，这多个输入流本身是有序的</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Multiway</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(In[] streams)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> streams.length;</span><br><span class="line">		IndexMinPQ&lt;String&gt; pq = <span class="keyword">new</span> <span class="title class_">IndexMinPQ</span>&lt;String&gt;(N);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (!streams[i].isEmpty())&#123;</span><br><span class="line">        <span class="comment">//初始化，从文件流中读取一个数，放到优先队列中</span></span><br><span class="line">				pq.insert(i, streams[i].readString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!pq.isEmpty())</span><br><span class="line">		&#123;</span><br><span class="line">			StdOut.println(pq.min());</span><br><span class="line">      <span class="comment">//从优先队列中取最小的数出来</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pq.delMin();</span><br><span class="line">			<span class="keyword">if</span> (!streams[i].isEmpty())</span><br><span class="line">        <span class="comment">//取出数的那个位置，再从文件流读一个值放进去</span></span><br><span class="line">				pq.insert(i, streams[i].readString());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> args.length;</span><br><span class="line">		In[] streams = <span class="keyword">new</span> <span class="title class_">In</span>[N];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">				streams[i] = <span class="keyword">new</span> <span class="title class_">In</span>(args[i]);</span><br><span class="line">    <span class="comment">//三个文件地址</span></span><br><span class="line">		merge(streams);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li></li>
</ul>
<h2 id="堆排序">堆排序</h2>
<ul>
<li><p>我们可以把任意优先队列变成一种排序方法，将所有元素插入一个查找最小元素的优先队列，然后再重复调用删除最小元素的操作来将他们按顺序删去</p>
<ul>
<li>用堆来实现经典而优雅的排序算法--堆排序</li>
<li>为了与前面代码保持一致，使用面向最大元素的优先队列并重复删除最大元素；为了排序需要，直接使用swim()和sink()，且将需要排序的数组本身作为堆，省去额外空间</li>
</ul></li>
<li><p>堆的构造</p>
<ul>
<li><p>可以从左到右，就像连续向优先队列中插入元素一样</p></li>
<li><p>从右到左，用sink()函数构造子堆</p></li>
<li><p>★
重要前提：每个子堆都符合优先序列的根节点大于其他两个子节点（也就是我们可以跳过大小为1的子堆）
所以只要对每个子堆的根节点，进行sink()函数操作就可以构造出优先队列结构的数组了</p></li>
<li><p>进行排序
主要是将数组的位置1和N-1进行交换，然后在1位置进行sink()操作
不断循环，即可让整个数组有序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sort(Comparable[] a)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> N/<span class="number">2</span>; k &gt;= <span class="number">1</span>;</span><br><span class="line">	k--)</span><br><span class="line">	sink(a, k, N);</span><br><span class="line">	<span class="keyword">while</span> (N &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		exch(a, <span class="number">1</span>, N--);</span><br><span class="line">		sink(a, <span class="number">1</span>, N);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意，这里的sink()函数被修改过，主要是指定了要sink的最后一个位置【sink()
被修改过，以a[] 和N 作为参数】</li>
</ul></li>
</ul></li>
<li><p>堆排序的轨迹（每次下沉后的数组内容） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220530231711247.png"
alt="image-20220530231711247" /></p></li>
<li><p>堆排序：堆的构造（左）和下沉排序（右） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220530231727650.png"
alt="image-20220530231727650" /></p></li>
<li><p>堆排序的主要工作都是在第二阶段完成的。这里我们将堆中的最大元素删除，然后放入堆缩小
后数组中空出的位置</p>
<blockquote>
<p>将N个元素排序，堆排序只需少于（2N x lgN+2N
）次比较（以及一般次数的交换）</p>
<p>。2N 项来自于堆的构造（ 见命题R）。2NlgN
项来自于每次下沉操作最大可能需要2lgN次比较（见命题P 与命题Q）</p>
</blockquote></li>
<li><p>我们将该实现和优先队列的API
独立开来是为了突出这个排序算法的简洁性（sort() 方法只需8 行代码，sink()
函数8 行），并使其可以嵌入其他代码之中。</p></li>
<li><p>小结</p>
<ul>
<li>在最坏的情况下它也能保证使用～ 2NlgN
次比较和恒定的额外空间。当空间十分紧张的时候（例如在嵌入式系统或低成本的移动设备中）它很流行，因为它只用几行就能实现（甚至机器码也是）较好的性能。但现代系统的许多应用很少使用它，因为它无法利用缓存。数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远远高于大多数比较都在相邻元素间进行的算法，如快速排序、归并排序，甚至是希尔排序</li>
<li>用堆实现的优先队列在现代应用程序中越来越重要，因为它能在插入操作和删除最大元素操作混合的动态场景中保证对数级别的运行时间</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法红皮书(第四版)</tag>
      </tags>
  </entry>
  <entry>
    <title>算法红皮书 2.5</title>
    <url>/2022/05/29/study/algorithm/algorithhms_4th/2.5/</url>
    <content><![CDATA[<ul>
<li>排序如此有用的原因是，在有序的数组中查找一个元素，要比在一个无序的数组中查找简单得多</li>
<li>通用排序算法是最重要的</li>
<li>算法思想虽然简单，但是适用领域广泛</li>
</ul>
<h2 id="将各种数据排序">将各种数据排序</h2>
<ul>
<li><p>Java的约定使得我们能够利用Java的回调机制将任意实现Comparable接口的数据类型排序</p>
<ul>
<li>我们的代码直接能够将String、Integer、Double 和一些其他例如File 和URL
类型的数组排序，因为它们都实现了Comparable 接口</li>
</ul></li>
<li><p>交易事务
商业数据的处理，设想一家互联网商业公司为每笔交易记录都保存了所有的相关信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Transaction that)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.when.compareTo(that.when);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>指针排序
我们使用的方法在经典教材中被称为<strong>指针排序</strong>，因为我们只处理元素的引用而不移动数据本身</p></li>
<li><p>不可变的键
用不可变的数据类型作为键，比如String、Integer、Double和File等</p></li>
<li><p>廉价的交换</p>
<ul>
<li><p>使用引用的另一个好处是不必移动整个元素对于几乎任意大小的元素，使用引用使得在一般情况下交换的成本和比较的成本几乎相同（代价是需要额外的空间存储这些引用）</p></li>
<li><p>研究将数字排序的算法性能的一种方法就是观察其所需的比较和交换总数，因为这里隐式地假设了比较和交换的成本是相同的</p></li>
</ul></li>
<li><p>多种排序方法</p>
<ul>
<li>根据情况将一组对象按照不同的方式排序。Java 的Comparator
接口允许我们在一个类之中实现多种排序方法</li>
</ul></li>
<li><p>多键数组</p>
<ul>
<li><p>一个元素的多种属性都可能被用作排序的键</p>
<ul>
<li>我们可以定义多种比较器，要将Transaction
对象的数组按照时间排序可以调用： Insertion.sort(a, new
Transaction.WhenOrder()) 或者这样来按照金额排序： Insertion.sort(a, new
Transaction.HowMuchOrder())</li>
</ul></li>
<li><p>使用Comparator的插入排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a, Comparator c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> a.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; less(Comparator, a[j], a[j-<span class="number">1</span>]); j--)</span><br><span class="line">	exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title function_">less</span><span class="params">(Comparator c, Object v, Object w)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> c.compare(v, w) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exch</span><span class="params">(Object[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">	a[i] = a[j];</span><br><span class="line">	a[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用比较器实现优先队列</p>
<ul>
<li>扩展优先队列
<ul>
<li>导入 java.util.Comparator；</li>
<li>为 MaxPQ 添加一个实例变量 comparator
以及一个构造函数，该构造函数接受一个比较器 作为参数并用它将comparator
初始化；</li>
<li>在 less()中检查 comparator属性是否为
null（如果不是的话就用它进行比较）。</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用了Comparator的插入排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transaction</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String who;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Date when;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> amount;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WhoOrder</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Transaction&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Transaction v, Transaction w)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> v.who.compareTo(w.who);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WhenOrder</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Transaction&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Transaction v, Transaction w)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> v.when.compareTo(w.when);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HowMuchOrder</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Transaction&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Transaction v, Transaction w)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (v.amount &lt; w.amount) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (v.amount &gt; w.amount) <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>稳定性</p>
<ul>
<li>如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为是稳定的</li>
<li>例如，考虑一个需要处理大量含有地理位置和时间戳的事件的互联网商业应用程
序。首先，我们在事件发生时将它们挨个存储在一个数组中，这样在数组中它们已经是按照时间顺序排好了的。现在假设在进一步处理前将按照地理位置切分。一种简单的方法是将数组按照位置排序。如果排序算法不是稳定的，排序后的每个城市的交易可能不会再是按照时间顺序排列的了</li>
<li>我们学习过的一部分算法是稳定的（插入排序和归并排序），但很多不是（选择排序、希尔排序、快速排序和堆排序）</li>
<li>有很多办法能够将任意排序算法变成稳定的（请见练习2.5.18），但一般只有在稳定性是必要的情况下稳定的排序算法才有优势</li>
<li>图示 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220531233431323.png"
alt="image-20220531233431323" /></li>
</ul></li>
</ul></li>
</ul>
<h2 id="我应该使用哪种排序算法">我应该使用哪种排序算法</h2>
<ul>
<li>各种排序算法的性能特点 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220531233605671.png"
alt="image-20220531233605671" />
<ul>
<li>快速排序是最快的通用排序算法</li>
</ul></li>
<li>将原始类型数据排序
一些性能优先的应用的重点可能是将数字排序，因此更合理的做法是跳过引用直接将原始数据
类型的数据排序</li>
<li>Java系统库的排序算法 java.util.Arrays.sort() <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220531233910990.png"
alt="image-20220531233910990" /></li>
<li>Java
的系统程序员选择对原始数据类型使用（三向切分的）快速排序，对引用类型使用归并排
序。这些选择实际上也暗示着用速度和空间（对于原始数据类型）来换取稳定性（对于引用类型），</li>
<li>如果考虑稳定性，则选择Merge.sort() 归并排序</li>
</ul>
<h2 id="问题的归约">问题的归约</h2>
<ul>
<li><p>归约指的是为解决某个问题而发明的算法正好可以用来解决另一种问题</p></li>
<li><p>使用解决问题B 的方法来解决问题A 时，你都是在将A
归约为B。</p></li>
<li><p>如果先将数据排序，那么解决剩下的问题就剩下线性级别的时间，归约后的运行时间的增长数量级由平方级别降低到了线性级别</p>
<ul>
<li><p>找出重复元素的个数（先排序，后遍历）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Quick.sort(a);</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 假设a.length &gt; 0.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">  <span class="keyword">if</span> (a[i].compareTo(a[i-<span class="number">1</span>]) != <span class="number">0</span>)</span><br><span class="line">    count++;</span><br></pre></td></tr></table></figure></li>
<li><p>Kendall tau距离</p></li>
<li><p>优先队列</p>
<blockquote>
<p>在2.4
节中我们已经见过两个被归约为优先队列操作的问题的例子。一个是2.4.2.1
节中的TopM，它能够找到输入流中M 个最大的元素；另一个是2.4.4.7
节中的Multiway，它能够将M
个输入流归并为一个有序的输出流。这两个问题都可以轻易用长度为M
的优先队列解决</p>
</blockquote></li>
<li><p>中位数与顺序统计 (与快速排序有关)</p></li>
<li></li>
</ul></li>
</ul>
<h2 id="排序应用一览">排序应用一览</h2>
<ul>
<li>商业计算：按照名字或者数字排序的账号、按照日期或者金额排序的交易、按照
邮编或者地址排序的邮件、按照名称或者日期排序的文件等，
处理这些数据必然需要排序算</li>
<li>信息搜索：有序的顺序可以使用经典的<strong>二分查找法</strong></li>
<li><strong>运筹学</strong>指的是研究数学模型并将其应用于问题解决和决策的领域</li>
<li>事件驱动模拟、数值计算、组合搜索</li>
<li>基于排序算法的算法
<ul>
<li>Prim算法和Dijkstra算法</li>
<li>Kruskal算法</li>
<li>霍夫曼压缩</li>
<li>字符串处理</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法红皮书(第四版)</tag>
      </tags>
  </entry>
  <entry>
    <title>算法红皮书 3.1.1-3.1.7</title>
    <url>/2022/05/31/study/algorithm/algorithhms_4th/3.1.1-3.1.7/</url>
    <content><![CDATA[<h1 id="查找">查找</h1>
<ul>
<li>经典查找算法</li>
<li>用<strong>符号表</strong>这个词来描述抽象的表格，将信息（值）存储在其中，然后按照指定的<strong>键</strong>来获取这些信息</li>
<li>符号表也被称为<strong>字典</strong>
<ul>
<li>在英语字典里，键就是单词，值就是单词对应的定义、发音和词源</li>
<li>符号表有时又叫索引</li>
<li>在一本书的索引中，键就是术语，而值就是书中该术语出现的所有页码</li>
</ul></li>
<li>下面学习三种经典的数据类型：二叉查找树、红黑树和散列表</li>
</ul>
<h2 id="符号表">符号表</h2>
<ul>
<li><p>符号表最主要的目的是将<strong>键</strong>和<strong>值</strong>联系起来</p></li>
<li><p>用例能够将一个键值对插入符号表并希望在之后能够从符号表的所有键值对中按照键直接找到相对应的值</p></li>
<li><blockquote>
<p>符号表是一种存储键值对的数据结构，支持两种操作：<strong>插入</strong>(put)，即将一组新的键值对存入表中；查找(get)，即根据给定的键得到相应的值</p>
</blockquote></li>
<li><p>典型的符号表应用 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220605224818125.png"
alt="image-20220605224818125" /></p></li>
</ul>
<h3 id="api">API</h3>
<ul>
<li><p>符号表是一种<strong>典型的数据类型</strong>
：代表着一组定义清晰的值及相应的操作。使用应用程序编程接口（API）来精确地定义这些操作
一种简单的泛型符号表API ST(Symbol Table) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220605225252370.png"
alt="image-20220605225252370" /></p></li>
<li><p>泛型
对于符号表，我们通过明确地指定查找时键和值的类型来区分它们的不同角色【key和value】</p></li>
<li><p>重复的键</p>
<ul>
<li>这里假设每个键只对应着一个值（表中不允许重复值）</li>
<li>当用例代码向表中存入的键值对和表中已有的键（及关联的值）冲突时，新的值会替代旧的值</li>
<li>上述定义了关联数组的抽象形式，可以将符号表想象成数组，键即索引，值即数组中的值</li>
<li>在一个关联数组中，键可以是任意类型，但我们仍然可以用它来快速访问数组的值</li>
<li>非Java使用st[key]来替代st.get(key)，用st[key]=val来替代st.put(key,val)</li>
</ul></li>
<li><p>键不能为空</p></li>
<li><p>值不能为空（因为规定当键不存在时get()返回空）
当值为空表示删除</p></li>
<li><p>删除操作</p>
<ul>
<li><p>延时删除，先将键对应的值置空，之后在某个时刻删除所有值为空的键</p></li>
<li><p>即时删除，立即从表中删除指定的键 put实现的开头：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(val == <span class="literal">null</span>)&#123;</span><br><span class="line"> delete(key);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>便捷方法 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220606233111252.png"
alt="image-20220606233111252" /></p></li>
<li><p>迭代 在API第一行加上implements Iterable<Key>
，所有实现都包含iterator()方法来实现hasNext()和next()方法的迭代器；这里采用另一种方式：定义keys返回一个Iterable<Key>对象以方便便利所有的键，且允许遍历一部分</p></li>
<li><p>键的等价性
自定义的键需要重写equals()方法；且最好使用不可变数据类型作为键</p></li>
</ul></li>
</ul>
<h3 id="有序符号表">有序符号表</h3>
<ul>
<li>一种有序的泛型符号表的API <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220607214708600.png"
alt="image-20220607214708600" /></li>
<li>最大值和最小值、向下取整和向上取整、排名和选择</li>
<li>对于0到size()-1的所有i都有i==rank(select(i))，且所有的键都满足key ==
select(rank(key))</li>
<li>范围查找</li>
<li>例外情况
当一个方法需要返回一个键但表中没有合适的键可以返回时，我们约定抛出一个异常</li>
<li>有序符号表中冗余有序性方法的默认实现 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220607215850406.png"
alt="image-20220607215850406" /></li>
<li>所有Comparable类型中compareTo()方法和equals()方法的一致性</li>
<li>★★成本模型
在学习符号表的实现时，我们会统计<strong>比较的次数</strong>（等价性测试或是键的相互比较），在内循环<strong>不进行比较（极少）</strong>的情况下，我们会统计数组的访问次数</li>
</ul>
<h3 id="用例举例">用例举例</h3>
<p>如何使用</p>
<ul>
<li><p>行为测试用例 简单的符号表测试用例 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220607220233749.png"
alt="image-20220607220233749" /></p>
<ul>
<li>测试用例的键、值和输出 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220607220249349.png"
alt="image-20220607220249349" /></li>
</ul></li>
<li><p>性能测试用例 查找频率最高的单词</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FrequencyCounter</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">minlen</span> <span class="operator">=</span> Integer.parseint(args[<span class="number">0</span>]);</span><br><span class="line">		<span class="comment">// 最小键长</span></span><br><span class="line">		ST&lt;String, Integer&gt; st = <span class="keyword">new</span> <span class="title class_">ST</span>&lt;String, Integer&gt;();</span><br><span class="line">		<span class="keyword">while</span> (!StdIn.isEmpty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 构造符号表并统计频率</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> StdIn.readString();</span><br><span class="line">			<span class="keyword">if</span> (word.length() &lt; minlen) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 忽略较短的单词</span></span><br><span class="line">			<span class="keyword">if</span> (!st.contains(word)) st.put(word, <span class="number">1</span>); <span class="keyword">else</span> st.put(word, st.get(word) + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 找出出现频率最高的单词</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">max</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">		st.put(max, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (String word : st.keys())</span><br><span class="line">		<span class="keyword">if</span> (st.get(word) &gt; st.get(max))</span><br><span class="line">		max = word;</span><br><span class="line">		StdOut.println(max + <span class="string">&quot; &quot;</span> + st.get(max));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个单词都会被作为键进行搜索，因此处理性能和输入文本的单词总量必然有关；其次，输入的每个单词都会被存入符号表（输入中不重复单词的总数也就是所有键都被插入以后符号表的大小），因此输入流中不同的单词的总数也是相关的</p></li>
</ul>
<h3 id="无序链表中的顺序查找">无序链表中的顺序查找</h3>
<ul>
<li><p>顺序查找的定义：使用链表，每个结点存储一个键值对，get()实现即为遍历链表，用equals()方法比较需被查找的键和每个节点中的键。如果匹配成功我们就返回相应的值，否则返回null。put()实现也是遍历链表，用equals()方法比较需被查找的键和每个节点中的键。如果匹配成功我们就用第二个参数指定更新和该键相关联的值，否则我们就用给定的键值对创建一个新的结点并将其插入到链表的开头。这种方法称为<strong>顺序查找</strong></p></li>
<li><p><strong>命中</strong>表示一次成功的查找，<strong>未命中</strong>表示一次失败的查找</p></li>
<li><p>使用基于链表的符号表的索引用例的轨迹 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220607223552831.png"
alt="image-20220607223552831" /></p></li>
<li><p>顺序查找（基于无序链表）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequentialSearchST</span>&lt;Key,Value&gt;</span><br><span class="line">  &#123;</span><br><span class="line">	<span class="keyword">private</span> Node first;</span><br><span class="line">	<span class="comment">//链表首结点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">		<span class="comment">//链表结点的定义</span></span><br><span class="line">		Key key;</span><br><span class="line">		Value val;</span><br><span class="line">		Node next;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key, Value val, Node next)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">this</span>.key = key;</span><br><span class="line">			<span class="built_in">this</span>.val = val;</span><br><span class="line">			<span class="built_in">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 查找给定的键，返回相关联的值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">		<span class="keyword">if</span> (key.equals(x.key))</span><br><span class="line">		<span class="keyword">return</span> x.val;</span><br><span class="line">		<span class="comment">// 命中</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="comment">// 未名中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key, Value val)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 查找给定的键，找到则更新其值，否则在表中新建结点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> first; x != <span class="literal">null</span>; x = x.next)</span><br><span class="line">		<span class="keyword">if</span> (key.equals(x.key))</span><br><span class="line">		&#123;</span><br><span class="line">			x.val = val;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 命中，更新</span></span><br><span class="line">		first = <span class="keyword">new</span> <span class="title class_">Node</span>(key, val, first);</span><br><span class="line">		<span class="comment">// 未命中，新建结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><blockquote>
<p>在含有N
对键值的基于（无序）链表的符号表中，未命中的查找和插入操作都需要N
次比较。命中的查找在最坏情况下需要N 次比较。特别地，向一个空表中插入N
个不同的键需要∼ N2/2 次比较</p>
</blockquote></li>
</ul></li>
<li><blockquote>
<p>查找一个已经存在的键并不需要线性级别的时间。一种度量方法是查找表中的每个键，并将总
时间除以N</p>
</blockquote></li>
</ul>
<h3 id="有序数组中的二分查找">有序数组中的二分查找</h3>
<p>有序符号表API：它使用的数据结构是一对平行的数组，一个存储键一个存储值</p>
<p>//rank()：小于k的键的数量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchST</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;, Value&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> Key[] keys;</span><br><span class="line">	<span class="keyword">private</span> Value[] vals;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">BinarySearchST</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 调整数组大小的标准代码请见算法1.1</span></span><br><span class="line">		keys = (Key[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[capacity];</span><br><span class="line">		vals = (Value[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> N;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rank(key);</span><br><span class="line">        <span class="comment">//注意，这里i不一定就是刚好是key所在的索引，他表示比key的值小的个数</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>) <span class="keyword">return</span> vals[i]; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rank</span><span class="params">(Key key)</span></span><br><span class="line">	<span class="comment">// 请见算法3.2（续1）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key, Value val)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 查找键，找到则更新值，否则创建新的元素</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rank(key);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			vals[i] = val;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//根据成本模型，这里不统计</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> N; j &gt; i; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			keys[j] = keys[j-<span class="number">1</span>];</span><br><span class="line">			vals[j] = vals[j-<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		keys[i] = key;</span><br><span class="line">		vals[i] = val;</span><br><span class="line">		N++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Key key)</span></span><br><span class="line">	<span class="comment">// 该方法的实现请见练习3.1.16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>二分查找
我们使用有序数组存储键的原因是，经典二分查找法能够根据数组的索引大大减少每次查找所需的比较次数</p></li>
<li><p>递归的二分查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rank</span><span class="params">(Key key, <span class="type">int</span> lo, <span class="type">int</span> hi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (hi &lt; lo) <span class="keyword">return</span> lo;</span><br><span class="line">	<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(keys[mid]);</span><br><span class="line">	<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> rank(key, lo, mid-<span class="number">1</span>); <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> rank(key, mid+<span class="number">1</span>, hi); <span class="keyword">else</span> <span class="keyword">return</span> mid; <span class="comment">//如果存在，返回key所在位置的索引（也就是key之前的元素的个数 ）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>rank()的性质：如果表中存在该键，rank()应该返回该键的位置，也就是表中小于它的键的数量；如果表中不存在该键，ran()还是应该返回表中小于它的键的数量</p></li>
<li><p>好好想想算法3.2（续1）中非递归的rank()
为什么能够做到这些（你可以证明两个版本的等价性，或者直接证明非递归版本中的循环在结束时lo
的值正好等于表中小于被查找的键的键的数量），所有程序员都能从这些思考中有所收获。（提示：<strong>lo
的初始值为0，且永远不会变小</strong>） 假设有下面这么一组数(key
value)</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">9</td>
</tr>
</tbody>
</table>
<p>我要查找6，那么轨迹为： low=0，high=4，mid=2 low=2+1=3，high=4，mid=3
low=3+1=4，high=4，mid=4
low=4，high=4-1，此时high&lt;low，返回low【也就是说找到了最接近于要查找的数的下标】</p>
<ul>
<li>带图轨迹 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220612215031691.png"
alt="image-20220612215031691" /></li>
</ul></li>
<li><p>基于二分查找的有序符号表的其他操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Key <span class="title function_">min</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> keys[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> keys[N-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Key <span class="title function_">select</span><span class="params">(<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> keys[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大于等于key的最小整数</span></span><br><span class="line"><span class="keyword">public</span> Key <span class="title function_">ceiling</span><span class="params">(Key key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rank(key);</span><br><span class="line">	<span class="keyword">return</span> keys[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小于等于key的最大整数</span></span><br><span class="line"><span class="keyword">public</span> Key <span class="title function_">floor</span><span class="params">(Key key)</span></span><br><span class="line"><span class="comment">// 请见练习3.1.17</span></span><br><span class="line"><span class="keyword">public</span> Key <span class="title function_">delete</span><span class="params">(Key key)</span></span><br><span class="line"><span class="comment">// 请见练习3.1.16</span></span><br><span class="line"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title function_">keys</span><span class="params">(Key lo, Key hi)</span></span><br><span class="line">&#123;</span><br><span class="line">	Queue&lt;Key&gt; q = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;Key&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rank(lo); i &lt; rank(hi); i++)</span><br><span class="line">	q.enqueue(keys[i]);</span><br><span class="line">	<span class="keyword">if</span> (contains(hi))</span><br><span class="line">	q.enqueue(keys[rank(hi)]);</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="对二分查找的分析">对二分查找的分析</h3>
<blockquote>
<p>在N
个键的有序数组中进行二分查找最多需要（lgN+1）次比较（无论是否成功）</p>
</blockquote>
<blockquote>
<p>向大小为N 的有序数组中插入一个新的元素在最坏情况下需要访问∼ 2N
次数组，因此向一个空符号表中插入N 个元素在最坏情况下需要访问∼ N2
次数组</p>
</blockquote>
<h3 id="预览">预览</h3>
<ul>
<li>简单的符号表实现的成本总结</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220612220530385.png"
alt="image-20220612220530385" />
<figcaption aria-hidden="true">image-20220612220530385</figcaption>
</figure>
<ul>
<li>符号表的各种实现的优缺点 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220612220639930.png"
alt="image-20220612220639930" /></li>
<li>我们有若干种高效的符号表实现，它们能够并且已经被应用于无数程序之中了</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法红皮书(第四版)</tag>
      </tags>
  </entry>
  <entry>
    <title>算法红皮书 3.2.1</title>
    <url>/2022/06/12/study/algorithm/algorithhms_4th/3.2.1/</url>
    <content><![CDATA[<h2 id="二叉查找树">二叉查找树</h2>
<ul>
<li><p>使用每个结点含有两个链接（链表中每个结点只含有一个链接）的二叉查找树来高效地实现符号表</p></li>
<li><p>该数据结构由结点组成，结点包含的链接可以为空(null)或者指向其他结点</p></li>
<li><blockquote>
<p>一棵二叉查找树（BST）是一棵二叉树，其中每个结点都含有一个Comparable
的键（以
及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。</p>
</blockquote></li>
<li><figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220614212331828.png"
alt="image-20220614212331828" />
<figcaption aria-hidden="true">image-20220614212331828</figcaption>
</figure></li>
</ul>
<h3 id="基本实现">基本实现</h3>
<ul>
<li><p>数据表示</p>
<ul>
<li>每个结点都含有一个键、一个值、一条左链接、一条右链接和一个结点计数器
左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该节点的所有键组成的二叉查找树，变量N给出了以该结点为根的子树的结点总数</li>
<li>对于任意节点总是成立 size(x)=size(x.left)+size(x.right)+1</li>
</ul></li>
<li><p>多棵二叉查找树表示同一组有序的键来实现构建和使用二叉查找树的高校算法
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220614214218638.png"
alt="image-20220614214218638" /></p></li>
<li><p>查找</p>
<ul>
<li>在符号表中查找一个键可能得到两种结果：如果含有该键的结点存在表中，我们的查找就命中了，然后返回值；否则查找未命中（返回null)</li>
<li>递归：如果树是空的，则查找未命中；如果被查找的键和根节点的键相等，查找命中，否则在适当的子树中查找：如果被查找的键较小就选择左子树，否则选择右子树</li>
<li>下面的get()方法，第一个参数是一个结点（子树根节点），第二个参数是被查找的键，代码会保证只有该结点所表示的子树才会含有和被查找的键相等的结点</li>
<li>从根结点开始，在每个结点中查找的进程都会递归地在它的一个子结点上展开，因此一次查找也就定义了树的一条路径。对于命中的查找，路径在含有被查找的键的结点处结束。对于未命中的查找，路径的终点是一个空链接
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220614215917733.png"
alt="image-20220614215917733" /></li>
</ul></li>
<li><p>基于二叉查找树的符号表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BST</span>&lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;, Value&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> Node root;</span><br><span class="line">	<span class="comment">// 二叉查找树的根结点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">private</span> Key key;</span><br><span class="line">		<span class="comment">// 键</span></span><br><span class="line">		<span class="keyword">private</span> Value val;</span><br><span class="line">		<span class="comment">// 值</span></span><br><span class="line">		<span class="keyword">private</span> Node left, right;</span><br><span class="line">		<span class="comment">// 指向子树的链接</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> N;</span><br><span class="line">		<span class="comment">// 以该结点为根的子树中的结点总数</span></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Key key, Value val, <span class="type">int</span> N)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">this</span>.key = key;</span><br><span class="line">			<span class="built_in">this</span>.val = val;</span><br><span class="line">			<span class="built_in">this</span>.N = N;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> size(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(Node x)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">return</span> x.N;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span></span><br><span class="line">	<span class="comment">// 请见算法3.3（续1）</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key, Value val)</span></span><br><span class="line">	<span class="comment">// 请见算法3.3（续1）</span></span><br><span class="line">	<span class="comment">// max()、min()、floor()、ceiling()方法请见算法3.3（续2）</span></span><br><span class="line">	<span class="comment">// select()、rank()方法请见算法3.3（续3）</span></span><br><span class="line">	<span class="comment">// delete()、deleteMin()、deleteMax()方法请见算法3.3（续4）</span></span><br><span class="line">	<span class="comment">// keys()方法请见算法3.3（续5）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个Node 对象都是一棵含有N
个结点的子树的根结点，它的左链接指向一棵由小于该结点的所有键组成的二叉查找树，右链接指向一棵由大于该结点的所有键组成的二叉查找
树。root 变量指向二叉查找树的根结点Node
对象（这棵树包含了符号表中的所有键值对）</li>
</ul></li>
<li><p>二叉查找树的查找和排序方法的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Value <span class="title function_">get</span><span class="params">(Key key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> get(root, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Value <span class="title function_">get</span><span class="params">(Node x, Key key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 在以x为根结点的子树中查找并返回key所对应的值；</span></span><br><span class="line">	<span class="comment">// 如果找不到则返回null</span></span><br><span class="line">	<span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">	<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> get(x.left, key); <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> get(x.right, key); <span class="keyword">else</span> <span class="keyword">return</span> x.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Key key, Value val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 查找key，找到则更新它的值，否则为它创建一个新的结点</span></span><br><span class="line">	root = put(root, key, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node x, Key key, Value val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 如果key存在于以x为根结点的子树中则更新它的值；</span></span><br><span class="line">	<span class="comment">// 否则将以key和val为键值对的新结点插入到该子树中</span></span><br><span class="line">	<span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val, <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">    <span class="comment">//注意，这里进行比较后，确认新节点应该放在当前节点的左边还是右边</span></span><br><span class="line">	<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) x.left = put(x.left, key, val); <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) x.right = put(x.right, key, val); <span class="keyword">else</span> x.val = val;</span><br><span class="line">	x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>插入
put()方法的实现逻辑和递归查找很相似：如果树是空的，就返回一个含有该键值对的新节点；如果被查找的键小于根节点的键，我们就会继续在左子树中插入该键，否则在右子树中插入该键</p></li>
<li><p>递归</p>
<ul>
<li>可以将递归调用前的代码想象成沿着树向下走：它会将给定的键和每个结点的键相比较并根据结果向左或者向右移动到下一个结点。然后可以将递归调用后的代码想象成沿着树向上爬</li>
<li>在一棵简单的二叉查找树中，唯一的新链接就是在最底层指向新结点的链接，重置更上层的链接可以通过比较语句来避免。同样，我们只需要将路径上每个结点中的计数器的值加1，但我们使用了更加通用的代码，使之等于结点的所有子结点的计数器之和加1</li>
</ul></li>
<li><p>使用二叉查找树的标准索引用例的轨迹 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220614221847861.png"
alt="image-20220614221847861" /></p></li>
</ul>
<h3 id="分析">分析</h3>
<blockquote>
<p>在由N 个随机键构造的二叉查找树中，查找命中平均所需的比较次数为∼
2lnN</p>
</blockquote>
<blockquote>
<p>在由N
个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为∼
2lnN（约1.39lgN）</p>
</blockquote>
<h3 id="有序性相关的方法与删除操作">有序性相关的方法与删除操作</h3>
<h4 id="最大键和最小键">最大键和最小键</h4>
<p>如果根结点的左链接为空，那么一棵二叉查找树中最小的键就是根结点；如果左链接非空，那么
树中的最小键就是左子树中的最小键</p>
<h4 id="向上取整和向下取整">向上取整和向下取整</h4>
<blockquote>
<p>如果给定的键key 小于二叉查找树的根结点的键，那么小于等于key
的最大键floor(key) 一定 在根结点的左子树中；如果给定的键key
大于二叉查找树的根结点，那么只有当根结点右子树中存在小于等于key
的结点时，小于等于key
的最大键才会出现在右子树中，否则根结点就是小于等于key的最大键</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220623224733617.png"
alt="image-20220623224733617" />
<figcaption aria-hidden="true">image-20220623224733617</figcaption>
</figure>
<h4 id="选择操作">选择操作</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Key <span class="title function_">min</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> min(root).key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">min</span><span class="params">(Node x)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (x.left == <span class="literal">null</span>) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> min(x.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Key <span class="title function_">floor</span><span class="params">(Key key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> floor(root, key);</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">return</span> x.key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">floor</span><span class="params">(Node x, Key key)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(x.key);</span><br><span class="line">	<span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) <span class="keyword">return</span> floor(x.left, key);</span><br><span class="line">	<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> floor(x.right, key);</span><br><span class="line">	<span class="keyword">if</span> (t != <span class="literal">null</span>) <span class="keyword">return</span> t; <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="排名">排名</h4>
<h4 id="删除最大键和删除最小键">删除最大键和删除最小键</h4>
<h4 id="删除操作">删除操作</h4>
<h4 id="范围查找">范围查找</h4>
<h4 id="性能分析">性能分析</h4>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法红皮书(第四版)</tag>
      </tags>
  </entry>
  <entry>
    <title>01-flowable基础</title>
    <url>/2022/05/14/study/flowable/boge_blbl/01-base/</url>
    <content><![CDATA[<h2 id="flowable介绍">Flowable介绍</h2>
<ul>
<li><p>flowable的历史</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514094153736.png"
alt="image-20220514094153736" />
<figcaption aria-hidden="true">image-20220514094153736</figcaption>
</figure></li>
<li><p>flowable是BPNM的一个基于java的软件实现，不仅包括BPMN，还有DMN决策表和CMMNCase管理引擎，并且有自己的用户管理、微服务API等</p></li>
</ul>
<h2 id="获取engine对象">获取Engine对象</h2>
<ul>
<li><p>maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.flowable/flowable-engine --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.flowable<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flowable-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置并获取ProcessEngine</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProcessEngineConfiguration configuration=</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StandaloneProcessEngineConfiguration</span>();</span><br><span class="line">        <span class="comment">//配置</span></span><br><span class="line">        configuration.setJdbcDriver(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        configuration.setJdbcUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        configuration.setJdbcPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//nullCatalogMeansCurrent=true 设置为只查当前连接的schema库</span></span><br><span class="line">        configuration.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/flowable-learn?&quot;</span> +</span><br><span class="line">                <span class="string">&quot;useUnicode=true&amp;characterEncoding=utf-8&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&amp;allowMultiQueries=true&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&amp;nullCatalogMeansCurrent=true&quot;</span>);</span><br><span class="line">        <span class="comment">//如果数据库中表结构不存在则新建</span></span><br><span class="line">        configuration.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);</span><br><span class="line">        <span class="comment">//构建ProcessEngine</span></span><br><span class="line">        ProcessEngine processEngine=configuration.buildProcessEngine();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="日志和表结构介绍">日志和表结构介绍</h2>
<ul>
<li><p>添加slf4j依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-reload4j --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-reload4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.36<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-api --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.17.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>添加log配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">log4j.rootLogger</span> = <span class="string">DEBUG, CA</span></span><br><span class="line"><span class="attr">log4j.appender.CA</span> = <span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.CA.layout</span> = <span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.CA.layout.ConversionPattern</span> = <span class="string">%d&#123;hh:mm:ss,SSS&#125; &#123;%t&#125; %-5p %c %x - %m%n</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此时再次启动就会看到一堆日志</li>
</ul></li>
<li><p>表 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514102041305.png"
alt="image-20220514102041305" /></p></li>
</ul>
<h2 id="流程定义文件解析">流程定义文件解析</h2>
<ul>
<li><p>先通过流程绘制器绘制流程</p></li>
<li><p>案例（官网，请假流程） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514102241579.png"
alt="image-20220514102241579" /></p>
<ul>
<li><p>设计好流程之后，流程数据保存在holiday-request.bpmn20.xml文件中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:bpmndi</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:omgdc</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:omgdi</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:flowable</span>=<span class="string">&quot;http://flowable.org/bpmn&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">typeLanguage</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">expressionLanguage</span>=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--id process key--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">&quot;holidayRequest&quot;</span> <span class="attr">name</span>=<span class="string">&quot;请假流程&quot;</span> <span class="attr">isExecutable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">&quot;startEvent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--sequenceFlow表示的是线条箭头--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">sourceRef</span>=<span class="string">&quot;startEvent&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;approveTask&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;approveTask&quot;</span> <span class="attr">name</span>=<span class="string">&quot;同意或者拒绝请假&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">sourceRef</span>=<span class="string">&quot;approveTask&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;decision&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusiveGateway</span> <span class="attr">id</span>=<span class="string">&quot;decision&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">sourceRef</span>=<span class="string">&quot;decision&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;externalSystemCall&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--条件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">          $&#123;approved&#125;</span><br><span class="line">        ]]&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span>  <span class="attr">sourceRef</span>=<span class="string">&quot;decision&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sendRejectionMail&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--条件--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">          $&#123;!approved&#125;</span><br><span class="line">        ]]&gt;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">serviceTask</span> <span class="attr">id</span>=<span class="string">&quot;externalSystemCall&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Enter holidays in external system&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">flowable:class</span>=<span class="string">&quot;org.flowable.CallExternalSystemDelegate&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">sourceRef</span>=<span class="string">&quot;externalSystemCall&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;holidayApprovedTask&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;holidayApprovedTask&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Holiday approved&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">sourceRef</span>=<span class="string">&quot;holidayApprovedTask&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;approveEnd&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--发送一个邮件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">serviceTask</span> <span class="attr">id</span>=<span class="string">&quot;sendRejectionMail&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Send out rejection email&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">flowable:class</span>=<span class="string">&quot;org.flowable.SendRejectionMail&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sendRejectionMail&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;rejectEnd&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">&quot;approveEnd&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">&quot;rejectEnd&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="部署流程-代码实现">部署流程-代码实现</h2>
<ul>
<li><p>使用@bofore 处理测试中繁琐的配置操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="type">ProcessEngineConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">    configuration =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StandaloneProcessEngineConfiguration</span>();</span><br><span class="line">    <span class="comment">//配置</span></span><br><span class="line">    configuration.setJdbcDriver(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    configuration.setJdbcUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    configuration.setJdbcPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">//nullCatalogMeansCurrent=true 设置为只查当前连接的schema库</span></span><br><span class="line">    configuration.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/flowable-learn?&quot;</span> +</span><br><span class="line">            <span class="string">&quot;useUnicode=true&amp;characterEncoding=utf-8&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&amp;allowMultiQueries=true&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&amp;nullCatalogMeansCurrent=true&quot;</span>);</span><br><span class="line">    <span class="comment">//如果数据库中表结构不存在则新建</span></span><br><span class="line">    configuration.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ProcessEngine提供的几个服务 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514103435244.png"
alt="image-20220514103435244" /></p></li>
<li><p>流程部署</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流程的部署</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeploy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> configuration.buildProcessEngine();</span><br><span class="line">    <span class="comment">//获取服务(repository，流程定义)</span></span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> processEngine.getRepositoryService();</span><br><span class="line">    <span class="type">Deployment</span> <span class="variable">deploy</span> <span class="operator">=</span> repositoryService.createDeployment().addClasspathResource(<span class="string">&quot;holiday-request.bpmn20.xml&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;请求流程&quot;</span>) <span class="comment">//流程名</span></span><br><span class="line">            .deploy(); </span><br><span class="line">    System.out.println(<span class="string">&quot;部署id&quot;</span> + deploy.getId()); </span><br><span class="line">    System.out.println(<span class="string">&quot;部署名&quot;</span> + deploy.getName());</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>表结构 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514104106140.png"
alt="image-20220514104106140" /></p></li>
</ul>
<h2 id="查询和删除操作">查询和删除操作</h2>
<ul>
<li><p>查询已经部署的流程定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流程定义及部署的查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeployQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=configuration.buildProcessEngine();</span><br><span class="line">    RepositoryService repositoryService=processEngine.getRepositoryService();</span><br><span class="line">    <span class="comment">//流程部署查询</span></span><br><span class="line">    <span class="comment">//这里只部署了一个流程定义</span></span><br><span class="line">    <span class="type">Deployment</span> <span class="variable">deployment</span> <span class="operator">=</span> repositoryService.createDeploymentQuery()</span><br><span class="line">            .deploymentId(<span class="string">&quot;1&quot;</span>).singleResult();</span><br><span class="line">    System.out.println(<span class="string">&quot;部署时的名称:&quot;</span>+deployment.getName());</span><br><span class="line">    <span class="comment">//流程定义查询器</span></span><br><span class="line">    <span class="type">ProcessDefinitionQuery</span> <span class="variable">processDefinitionQuery</span> <span class="operator">=</span> repositoryService.createProcessDefinitionQuery();</span><br><span class="line">    <span class="comment">//查询到的流程定义</span></span><br><span class="line">    <span class="type">ProcessDefinition</span> <span class="variable">processDefinition</span> <span class="operator">=</span> processDefinitionQuery.deploymentId(<span class="string">&quot;1&quot;</span>).singleResult();</span><br><span class="line">  </span><br><span class="line">    System.out.println(<span class="string">&quot;部署id:&quot;</span>+processDefinition.getDeploymentId());</span><br><span class="line">    System.out.println(<span class="string">&quot;定义名:&quot;</span>+processDefinition.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;描述:&quot;</span>+processDefinition.getDescription());</span><br><span class="line">    System.out.println(<span class="string">&quot;定义id:&quot;</span>+processDefinition.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>删除流程定义</p>
<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteDeploy</span><span class="params">()</span>&#123;</span><br><span class="line">        ProcessEngine processEngine=configuration.buildProcessEngine();</span><br><span class="line">        RepositoryService repositoryService=processEngine.</span><br><span class="line">                getRepositoryService();</span><br><span class="line">        <span class="comment">//注意：第一个参数时部署id</span></span><br><span class="line">        <span class="comment">//后面那个参数表示级联删除，如果流程启动了会同时删除任务。</span></span><br><span class="line">        repositoryService.deleteDeployment(<span class="string">&quot;2501&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>下面三个表的数据都会被删除 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514105321078.png"
alt="image-20220514105321078" /></p></li>
</ul></li>
</ul>
<h2 id="启动流程实例">启动流程实例</h2>
<ul>
<li><p>由于刚才将部署删除了，所以这里再运行testDeploy()重新部署上</p></li>
<li><p>这里通过流程定义key（xml中的id）启动流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流程运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRunProcess</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=configuration.buildProcessEngine();</span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> processEngine.getRuntimeService();</span><br><span class="line">    <span class="comment">//这边模拟表单数据(表单数据有多种处理方式，这只是其中一种)</span></span><br><span class="line">    Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;employee&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;nrOfHolidays&quot;</span>,<span class="number">3</span>);</span><br><span class="line">    map.put(<span class="string">&quot;description&quot;</span>,<span class="string">&quot;工作累了想出去玩&quot;</span>);</span><br><span class="line">    <span class="type">ProcessInstance</span> <span class="variable">holidayRequest</span> <span class="operator">=</span> runtimeService.startProcessInstanceByKey(<span class="string">&quot;holidayRequest&quot;</span>, map);</span><br><span class="line">    System.out.println(<span class="string">&quot;流程定义的id:&quot;</span>+holidayRequest.getProcessDefinitionId());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前活跃id:&quot;</span>+holidayRequest.getActivityId());</span><br><span class="line">    System.out.println(<span class="string">&quot;流程运行id:&quot;</span>+holidayRequest.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>三个表 act_ru_variable act_ru_task arc_ru_execution</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514111442166.png"
alt="image-20220514111442166" />
<figcaption aria-hidden="true">image-20220514111442166</figcaption>
</figure></li>
</ul>
<h2 id="查询任务">查询任务</h2>
<ul>
<li><p>这里先指定一下每个任务的候选人，修改xml文件中userTask的节点属性</p>
<ul>
<li><p>修改前先删除一下之前部署的流程图(还是上面的代码)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流程删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteDeploy</span><span class="params">()</span>&#123;</span><br><span class="line">        ProcessEngine processEngine=configuration.buildProcessEngine();</span><br><span class="line">        RepositoryService repositoryService=processEngine.</span><br><span class="line">                getRepositoryService();</span><br><span class="line">        <span class="comment">//注意：第一个参数时部署id</span></span><br><span class="line">        <span class="comment">//后面那个参数表示级联删除，true表示如果流程启动了会同时删除任务。</span></span><br><span class="line">        repositoryService.deleteDeployment(<span class="string">&quot;2501&quot;</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里用false参数测试，会提示失败，运行中的流程不允许删除。将第二个参数改为true即可级联删除<br />
删除后可以发现下面几个表数据全部清空了 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514112055940.png"
alt="image-20220514112055940" /></p></li>
<li><p>然后修改xml定义文件并运行testDeploy()重新部署</p>
<ul>
<li><p>定义修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;approveTask&quot;</span> <span class="attr">name</span>=<span class="string">&quot;同意或者拒绝请假&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;zhangsan&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里增加了assignee属性值--&gt;</span>        </span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>运行流程 testRunProcess()</p>
<ul>
<li>运行后节点会跳到给zhangsan的那个任务，查看数据库表 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514112605263.png"
alt="image-20220514112605263" /></li>
<li>流程变量 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514112655133.png"
alt="image-20220514112655133" /></li>
</ul></li>
<li><p>查询任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试任务查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryTask</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=configuration.buildProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="comment">//通过流程定义查询任务</span></span><br><span class="line">    List&lt;Task&gt; list = taskService.createTaskQuery().processDefinitionKey(<span class="string">&quot;holidayRequest&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="keyword">for</span> (Task task:list)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务对应的流程定义id&quot;</span>+task.getProcessDefinitionId());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务名&quot;</span>+task.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务处理人&quot;</span>+task.getAssignee());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务描述&quot;</span>+task.getDescription());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务id&quot;</span>+task.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="处理任务">处理任务</h2>
<ul>
<li><p>流程图定义的分析
任务A处理后，根据处理结果（这里是拒绝），会走向任务D，然后任务D是一个Service，且通过java的委托对象，自动实现操作</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514115334229.png"
alt="image-20220514115334229" />
<figcaption aria-hidden="true">image-20220514115334229</figcaption>
</figure></li>
<li><p>到了D那个节点，这里指定了一个自定义的java类处理 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514115513100.png"
alt="image-20220514115513100" /></p>
<ul>
<li><p>代码配置，注意类名和xml中的一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.flowable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.flowable.engine.delegate.DelegateExecution;</span><br><span class="line"><span class="keyword">import</span> org.flowable.engine.delegate.JavaDelegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendRejectionMail</span> <span class="keyword">implements</span> <span class="title class_">JavaDelegate</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是一个flowable中的触发器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delegateExecution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(DelegateExecution delegateExecution)</span> &#123;</span><br><span class="line">        <span class="comment">//触发执行的逻辑 按照我们在流程中的定义给被拒绝的员工发送通知邮件</span></span><br><span class="line">        System.out.println(<span class="string">&quot;不好意思，你的请假申请被拒绝了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>任务的完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompleteTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ProcessEngine</span> <span class="variable">engine</span> <span class="operator">=</span> configuration.buildProcessEngine();</span><br><span class="line">        <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> engine.getTaskService();</span><br><span class="line">        <span class="comment">//查找出张三在这个流程定义中的任务</span></span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery().processDefinitionKey(<span class="string">&quot;holidayRequest&quot;</span>)</span><br><span class="line">                .taskAssignee(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">                .singleResult();</span><br><span class="line">        <span class="comment">//创建流程变量</span></span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;approved&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//完成任务</span></span><br><span class="line">        taskService.complete(task.getId(), map);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>控制台 <img
src="C:\Users\ly\AppData\Roaming\Typora\typora-user-images\image-20220514120154300.png"
alt="image-20220514120154300" /></li>
<li>数据库 下面几个表的数据都被清空了 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514120320988.png"
alt="image-20220514120320988" /></li>
</ul></li>
</ul>
<h2 id="历史任务的完成">历史任务的完成</h2>
<ul>
<li><p>Flowable流程引擎可以自动存储所有流程实例的审计数据或历史数据</p></li>
<li><p>先查看一下刚才用的流程定义的id <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514120756973.png"
alt="image-20220514120756973" /></p></li>
<li><p>历史信息查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHistory</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=configuration.buildProcessEngine();</span><br><span class="line">    HistoryService historyService=processEngine.getHistoryService();</span><br><span class="line">    List&lt;HistoricActivityInstance&gt; list = historyService.createHistoricActivityInstanceQuery()</span><br><span class="line">            .processDefinitionId(<span class="string">&quot;holidayRequest:1:7503&quot;</span>)</span><br><span class="line">            .finished() <span class="comment">//查询已经完成的</span></span><br><span class="line">            .orderByHistoricActivityInstanceEndTime().asc() <span class="comment">//指定排序字段和升降序</span></span><br><span class="line">            .list();</span><br><span class="line">    <span class="keyword">for</span>(HistoricActivityInstance history:list)&#123;</span><br><span class="line">        <span class="comment">//注意,和视频不一样的地方，history表还记录了流程箭头流向的那个节点</span></span><br><span class="line">        <span class="comment">//_flow_</span></span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">&quot;活动名--&quot;</span>+history.getActivityName()+</span><br><span class="line">                        <span class="string">&quot;处理人--&quot;</span>+history.getAssignee()+</span><br><span class="line">                        <span class="string">&quot;活动id--&quot;</span>+history.getActivityId()+</span><br><span class="line">                <span class="string">&quot;处理时长--&quot;</span>+history.getDurationInMillis()+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>不一样的地方，在旧版本时没有的 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514121509725.png"
alt="image-20220514121509725" /></p></li>
</ul>
<h2 id="流程设计器">流程设计器</h2>
<ul>
<li><p>有eclipse流程设计器，和flowable流程设计器</p></li>
<li><p>使用eclipse的设计，会生成一个bar文件，代码稍微有点不同
接收一个ZipInputStream</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514122035548.png"
alt="image-20220514122035548" />
<figcaption aria-hidden="true">image-20220514122035548</figcaption>
</figure></li>
</ul>
<h2 id="flowableui">FlowableUI</h2>
<ul>
<li>使用flowable官方提供的包，里面有一个war，直接用命令 java -jar
xx.war启动即可</li>
<li>这个应用分成四个模块 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514121818052.png"
alt="image-20220514121818052" /></li>
<li>流程图的绘制及用户分配 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514121906621.png"
alt="image-20220514121906621" /></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>flowable_波哥_b站</tag>
      </tags>
  </entry>
  <entry>
    <title>boge-02-flowable进阶_1</title>
    <url>/2022/05/14/study/flowable/boge_blbl/02-advance_1/</url>
    <content><![CDATA[<h2 id="表结构">表结构</h2>
<ul>
<li><p>尽量通过API动数据</p></li>
<li><p>ACT_RE：repository，包含流程定义和流程静态资源</p></li>
<li><p>ACT_RU:
runtime，包含流程实例、任务、变量等，流程结束会删除</p></li>
<li><p>ACT_HI:
history，包含历史数据，比如历史流程实例、变量、任务等</p></li>
<li><p>ACT_GE: general，通用数据</p></li>
<li><p>ACT_ID:
identity，组织机构。包含标识的信息，如用户、用户组等等</p></li>
<li><p>具体的</p>
<ul>
<li><p>流程历史记录</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514220723828.png"
alt="image-20220514220723828" />
<figcaption aria-hidden="true">image-20220514220723828</figcaption>
</figure></li>
<li><p>流程定义表 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514220740732.png"
alt="image-20220514220740732" /></p></li>
<li><p>运行实例表 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514220808753.png"
alt="image-20220514220808753" /></p></li>
<li><p>用户用户组表</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514220856033.png"
alt="image-20220514220856033" />
<figcaption aria-hidden="true">image-20220514220856033</figcaption>
</figure></li>
</ul></li>
<li><p>源码中的体现 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514220933558.png"
alt="image-20220514220933558" /></p></li>
</ul>
<h2 id="默认的配置文件加载">默认的配置文件加载</h2>
<ul>
<li><p>对于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ProcessEngine</span> <span class="variable">defaultProcessEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line"><span class="comment">//--&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ProcessEngine <span class="title function_">getDefaultProcessEngine</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getProcessEngine(NAME_DEFAULT); <span class="comment">//NAME_DEFAULT = &quot;default&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//--&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ProcessEngine <span class="title function_">getProcessEngine</span><span class="params">(String processEngineName)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isInitialized()) &#123;</span><br><span class="line">            init();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> processEngines.get(processEngineName);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//--&gt;部分</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes all process engines that can be found on the classpath for resources &lt;code&gt;flowable.cfg.xml&lt;/code&gt; (plain Flowable style configuration) and for resources</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;flowable-context.xml&lt;/code&gt; (Spring style configuration).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isInitialized()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (processEngines == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Create new map to store process-engines if current map is null</span></span><br><span class="line">                processEngines = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectUtil.getClassLoader();</span><br><span class="line">            Enumeration&lt;URL&gt; resources = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resources = classLoader.getResources(<span class="string">&quot;flowable.cfg.xml&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlowableIllegalArgumentException</span>(<span class="string">&quot;problem retrieving flowable.cfg.xml resources on the classpath: &quot;</span> + System.getProperty(<span class="string">&quot;java.class.path&quot;</span>), e);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//后面还有，每帖出来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>注意这行<code>classLoader.getResources("flowable.cfg.xml");</code>
需要在resources根目录下放这么一个文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/flow1?useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8<span class="symbol">&amp;amp;</span>allowMultiQueries=true<span class="symbol">&amp;amp;</span>nullCatalogMeansCurrent=true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcDriver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUsername&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcPassword&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseSchemaUpdate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--异步执行器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;asyncExecutorActivate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>新建数据库flow1，运行测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processEngine2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">defaultProcessEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    System.out.println(defaultProcessEngine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时数据库已经有表</p></li>
</ul>
<h2 id="加载自定义名称的配置文件">加载自定义名称的配置文件</h2>
<ul>
<li><p>把刚才的数据库清空，将flowable的配置文件放到目录custom/lycfg.xml中
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514225700704.png"
alt="image-20220514225700704" /></p></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processEngine03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ProcessEngineConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(<span class="string">&quot;custom/lycfg.xml&quot;</span>);</span><br><span class="line">        System.out.println(configuration);</span><br><span class="line">        <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> configuration.buildProcessEngine();</span><br><span class="line">        System.out.println(processEngine);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="processengine源码查看">ProcessEngine源码查看</h2>
<ul>
<li><p>源码追溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">configuration.buildProcessEngine()</span><br><span class="line"><span class="comment">//---&gt;ProcessEngineConfigurationImpl.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ProcessEngine <span class="title function_">buildProcessEngine</span><span class="params">()</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="type">ProcessEngineImpl</span> <span class="variable">processEngine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessEngineImpl</span>(<span class="built_in">this</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----&gt;ProcessEngineImpl.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessEngineImpl</span> <span class="keyword">implements</span> <span class="title class_">ProcessEngine</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(ProcessEngineImpl.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> RepositoryService repositoryService;</span><br><span class="line">    <span class="keyword">protected</span> RuntimeService runtimeService;</span><br><span class="line">    <span class="keyword">protected</span> HistoryService historicDataService;</span><br><span class="line">    <span class="keyword">protected</span> IdentityService identityService;</span><br><span class="line">    <span class="keyword">protected</span> TaskService taskService;</span><br><span class="line">    <span class="keyword">protected</span> FormService formService;</span><br><span class="line">    <span class="keyword">protected</span> ManagementService managementService;</span><br><span class="line">    <span class="keyword">protected</span> DynamicBpmnService dynamicBpmnService;</span><br><span class="line">    <span class="keyword">protected</span> ProcessMigrationService processInstanceMigrationService;</span><br><span class="line">    <span class="keyword">protected</span> AsyncExecutor asyncExecutor;</span><br><span class="line">    <span class="keyword">protected</span> AsyncExecutor asyncHistoryExecutor;</span><br><span class="line">    <span class="keyword">protected</span> CommandExecutor commandExecutor;</span><br><span class="line">    <span class="keyword">protected</span> Map&lt;Class&lt;?&gt;, SessionFactory&gt; sessionFactories;</span><br><span class="line">    <span class="keyword">protected</span> TransactionContextFactory transactionContextFactory;</span><br><span class="line">    <span class="keyword">protected</span> ProcessEngineConfigurationImpl processEngineConfiguration;</span><br><span class="line">    <span class="comment">//这里通过ProcessEngineConfigurationImpl获取各种对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProcessEngineImpl</span><span class="params">(ProcessEngineConfigurationImpl processEngineConfiguration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.processEngineConfiguration = processEngineConfiguration;</span><br><span class="line">        <span class="built_in">this</span>.name = processEngineConfiguration.getEngineName();</span><br><span class="line">        <span class="built_in">this</span>.repositoryService = processEngineConfiguration.getRepositoryService();</span><br><span class="line">        <span class="built_in">this</span>.runtimeService = processEngineConfiguration.getRuntimeService();</span><br><span class="line">        <span class="built_in">this</span>.historicDataService = processEngineConfiguration.getHistoryService();</span><br><span class="line">        <span class="built_in">this</span>.identityService = processEngineConfiguration.getIdentityService();</span><br><span class="line">        <span class="built_in">this</span>.taskService = processEngineConfiguration.getTaskService();</span><br><span class="line">        <span class="built_in">this</span>.formService = processEngineConfiguration.getFormService();</span><br><span class="line">        <span class="built_in">this</span>.managementService = processEngineConfiguration.getManagementService();</span><br><span class="line">        <span class="built_in">this</span>.dynamicBpmnService = processEngineConfiguration.getDynamicBpmnService();</span><br><span class="line">        <span class="built_in">this</span>.processInstanceMigrationService = processEngineConfiguration.getProcessMigrationService();</span><br><span class="line">        <span class="built_in">this</span>.asyncExecutor = processEngineConfiguration.getAsyncExecutor();</span><br><span class="line">        <span class="built_in">this</span>.asyncHistoryExecutor = processEngineConfiguration.getAsyncHistoryExecutor();</span><br><span class="line">        <span class="built_in">this</span>.commandExecutor = processEngineConfiguration.getCommandExecutor();</span><br><span class="line">        <span class="built_in">this</span>.sessionFactories = processEngineConfiguration.getSessionFactories();</span><br><span class="line">        <span class="built_in">this</span>.transactionContextFactory = processEngineConfiguration.getTransactionContextFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----&gt;ProcessEngine.class 获取各个service服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProcessEngine</span> <span class="keyword">extends</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** the version of the flowable library */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">VERSION</span> <span class="operator">=</span> FlowableVersions.CURRENT_VERSION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Starts the execuctors (async and async history), if they are configured to be auto-activated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">startExecutors</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    RepositoryService <span class="title function_">getRepositoryService</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    RuntimeService <span class="title function_">getRuntimeService</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    FormService <span class="title function_">getFormService</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    TaskService <span class="title function_">getTaskService</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    HistoryService <span class="title function_">getHistoryService</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    IdentityService <span class="title function_">getIdentityService</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    ManagementService <span class="title function_">getManagementService</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    DynamicBpmnService <span class="title function_">getDynamicBpmnService</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    ProcessMigrationService <span class="title function_">getProcessMigrationService</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    ProcessEngineConfiguration <span class="title function_">getProcessEngineConfiguration</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2
id="processengineconfiguration中的init方法">ProcessEngineConfiguration中的init方法</h2>
<ul>
<li><p>源码追溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">configuration.buildProcessEngine()</span><br><span class="line"><span class="comment">//---&gt;ProcessEngineConfigurationImpl.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ProcessEngine <span class="title function_">buildProcessEngine</span><span class="params">()</span> &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="type">ProcessEngineImpl</span> <span class="variable">processEngine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessEngineImpl</span>(<span class="built_in">this</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---&gt;ProcessEngineConfigurationImpl.init();</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        initEngineConfigurations();</span><br><span class="line">        initConfigurators();</span><br><span class="line">        configuratorsBeforeInit();</span><br><span class="line">        initClock();</span><br><span class="line">        initObjectMapper();</span><br><span class="line">        initProcessDiagramGenerator();</span><br><span class="line">        initCommandContextFactory();</span><br><span class="line">        initTransactionContextFactory();</span><br><span class="line">        initCommandExecutors();</span><br><span class="line">        initIdGenerator();</span><br><span class="line">        initHistoryLevel();</span><br><span class="line">        initFunctionDelegates();</span><br><span class="line">        initAstFunctionCreators();</span><br><span class="line">        initDelegateInterceptor();</span><br><span class="line">        initBeans();</span><br><span class="line">        initExpressionManager();</span><br><span class="line">        initAgendaFactory();</span><br><span class="line">        <span class="comment">//关系型数据库</span></span><br><span class="line">        <span class="keyword">if</span> (usingRelationalDatabase) &#123;</span><br><span class="line">            initDataSource();<span class="comment">//下面拿这个举例1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            initNonRelationalDataSource();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usingRelationalDatabase || usingSchemaMgmt) &#123;</span><br><span class="line">            initSchemaManager();</span><br><span class="line">            initSchemaManagementCommand();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        configureVariableServiceConfiguration();</span><br><span class="line">        configureJobServiceConfiguration();</span><br><span class="line"></span><br><span class="line">        initHelpers();</span><br><span class="line">        initVariableTypes();</span><br><span class="line">        initFormEngines();</span><br><span class="line">        initFormTypes();</span><br><span class="line">        initScriptingEngines();</span><br><span class="line">        initBusinessCalendarManager();</span><br><span class="line">        initServices();</span><br><span class="line">        initWsdlImporterFactory();</span><br><span class="line">        initBehaviorFactory();</span><br><span class="line">        initListenerFactory();</span><br><span class="line">        initBpmnParser();</span><br><span class="line">        initProcessDefinitionCache();</span><br><span class="line">        initProcessDefinitionInfoCache();</span><br><span class="line">        initAppResourceCache();</span><br><span class="line">        initKnowledgeBaseCache();</span><br><span class="line">        initJobHandlers();</span><br><span class="line">        initHistoryJobHandlers();</span><br><span class="line"></span><br><span class="line">        initTransactionFactory();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usingRelationalDatabase) &#123;</span><br><span class="line">            initSqlSessionFactory();<span class="comment">//下面拿这个举例2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        initSessionFactories();</span><br><span class="line">        <span class="comment">//相关表结构操作</span></span><br><span class="line">        initDataManagers(); <span class="comment">//下面拿这个举例2</span></span><br><span class="line">        initEntityManagers();</span><br><span class="line">        initCandidateManager();</span><br><span class="line">        initVariableAggregator();</span><br><span class="line">        initHistoryManager();</span><br><span class="line">        initChangeTenantIdManager();</span><br><span class="line">        initDynamicStateManager();</span><br><span class="line">        initProcessInstanceMigrationValidationManager();</span><br><span class="line">        initIdentityLinkInterceptor();</span><br><span class="line">        initJpa();</span><br><span class="line">        initDeployers();</span><br><span class="line">        initEventHandlers();</span><br><span class="line">        initFailedJobCommandFactory();</span><br><span class="line">        initEventDispatcher();</span><br><span class="line">        initProcessValidator();</span><br><span class="line">        initFormFieldHandler();</span><br><span class="line">        initDatabaseEventLogging();</span><br><span class="line">        initFlowable5CompatibilityHandler();</span><br><span class="line">        initVariableServiceConfiguration(); <span class="comment">//流程变量</span></span><br><span class="line">        initIdentityLinkServiceConfiguration();</span><br><span class="line">        initEntityLinkServiceConfiguration();</span><br><span class="line">        initEventSubscriptionServiceConfiguration();</span><br><span class="line">        initTaskServiceConfiguration();</span><br><span class="line">        initJobServiceConfiguration();</span><br><span class="line">        initBatchServiceConfiguration();</span><br><span class="line">        initAsyncExecutor();</span><br><span class="line">        initAsyncHistoryExecutor();</span><br><span class="line"></span><br><span class="line">        configuratorsAfterInit();</span><br><span class="line">        afterInitTaskServiceConfiguration();</span><br><span class="line">        afterInitEventRegistryEventBusConsumer();</span><br><span class="line">        </span><br><span class="line">        initHistoryCleaningManager();</span><br><span class="line">        initLocalizationManagers();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//---&gt;AbstractEngineConfiguration </span></span><br><span class="line"><span class="comment">//----&gt;AbstractEngineConfiguration.initDataSrouce()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title function_">getDefaultDatabaseTypeMappings</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">databaseTypeMappings</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;H2&quot;</span>, DATABASE_TYPE_H2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;HSQL Database Engine&quot;</span>, DATABASE_TYPE_HSQL);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;MySQL&quot;</span>, DATABASE_TYPE_MYSQL);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;MariaDB&quot;</span>, DATABASE_TYPE_MYSQL);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;Oracle&quot;</span>, DATABASE_TYPE_ORACLE);</span><br><span class="line">        databaseTypeMappings.setProperty(PRODUCT_NAME_POSTGRES, DATABASE_TYPE_POSTGRES);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;Microsoft SQL Server&quot;</span>, DATABASE_TYPE_MSSQL);</span><br><span class="line">        databaseTypeMappings.setProperty(DATABASE_TYPE_DB2, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/NT&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/NT64&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2 UDP&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/LINUX&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/LINUX390&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/LINUXX8664&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/LINUXZ64&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/LINUXPPC64&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/LINUXPPC64LE&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/400 SQL&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/6000&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2 UDB iSeries&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/AIX64&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/HPUX&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/HP64&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/SUN&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/SUN64&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/PTX&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2/2&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(<span class="string">&quot;DB2 UDB AS400&quot;</span>, DATABASE_TYPE_DB2);</span><br><span class="line">        databaseTypeMappings.setProperty(PRODUCT_NAME_CRDB, DATABASE_TYPE_COCKROACHDB);</span><br><span class="line">        <span class="keyword">return</span> databaseTypeMappings;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//initDataSource();</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dataSource == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dataSourceJndiName != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dataSource = (DataSource) <span class="keyword">new</span> <span class="title class_">InitialContext</span>().lookup(dataSourceJndiName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlowableException</span>(<span class="string">&quot;couldn&#x27;t lookup datasource from &quot;</span> + dataSourceJndiName + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jdbcUrl != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((jdbcDriver == <span class="literal">null</span>) || (jdbcUsername == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlowableException</span>(<span class="string">&quot;DataSource or JDBC properties have to be specified in a process engine configuration&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                logger.debug(<span class="string">&quot;initializing datasource to db: &#123;&#125;&quot;</span>, jdbcUrl);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Configuring Datasource with following properties (omitted password for security)&quot;</span>);</span><br><span class="line">                    logger.info(<span class="string">&quot;datasource driver : &#123;&#125;&quot;</span>, jdbcDriver);</span><br><span class="line">                    logger.info(<span class="string">&quot;datasource url : &#123;&#125;&quot;</span>, jdbcUrl);</span><br><span class="line">                    logger.info(<span class="string">&quot;datasource user name : &#123;&#125;&quot;</span>, jdbcUsername);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">PooledDataSource</span> <span class="variable">pooledDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PooledDataSource</span>(<span class="built_in">this</span>.getClass().getClassLoader(), jdbcDriver, jdbcUrl, jdbcUsername, jdbcPassword);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (jdbcMaxActiveConnections &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pooledDataSource.setPoolMaximumActiveConnections(jdbcMaxActiveConnections);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (jdbcMaxIdleConnections &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pooledDataSource.setPoolMaximumIdleConnections(jdbcMaxIdleConnections);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (jdbcMaxCheckoutTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pooledDataSource.setPoolMaximumCheckoutTime(jdbcMaxCheckoutTime);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (jdbcMaxWaitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pooledDataSource.setPoolTimeToWait(jdbcMaxWaitTime);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (jdbcPingEnabled) &#123;</span><br><span class="line">                    pooledDataSource.setPoolPingEnabled(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (jdbcPingQuery != <span class="literal">null</span>) &#123;</span><br><span class="line">                        pooledDataSource.setPoolPingQuery(jdbcPingQuery);</span><br><span class="line">                    &#125;</span><br><span class="line">                    pooledDataSource.setPoolPingConnectionsNotUsedFor(jdbcPingConnectionNotUsedFor);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (jdbcDefaultTransactionIsolationLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pooledDataSource.setDefaultTransactionIsolationLevel(jdbcDefaultTransactionIsolationLevel);</span><br><span class="line">                &#125;</span><br><span class="line">                dataSource = pooledDataSource;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (databaseType == <span class="literal">null</span>) &#123;</span><br><span class="line">            initDatabaseType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//initSqlSessionFactory();</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initSqlSessionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlSessionFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取MyBatis配置文件信息</span></span><br><span class="line">                inputStream = getMyBatisXmlConfigurationStream();</span><br><span class="line"></span><br><span class="line">                <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Environment</span>(<span class="string">&quot;default&quot;</span>, transactionFactory, dataSource);</span><br><span class="line">                <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);</span><br><span class="line">                <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">                properties.put(<span class="string">&quot;prefix&quot;</span>, databaseTablePrefix);</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">wildcardEscapeClause</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> ((databaseWildcardEscapeCharacter != <span class="literal">null</span>) &amp;&amp; (databaseWildcardEscapeCharacter.length() != <span class="number">0</span>)) &#123;</span><br><span class="line">                    wildcardEscapeClause = <span class="string">&quot; escape &#x27;&quot;</span> + databaseWildcardEscapeCharacter + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                properties.put(<span class="string">&quot;wildcardEscapeClause&quot;</span>, wildcardEscapeClause);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// set default properties</span></span><br><span class="line">                properties.put(<span class="string">&quot;limitBefore&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                properties.put(<span class="string">&quot;limitAfter&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                properties.put(<span class="string">&quot;limitBetween&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                properties.put(<span class="string">&quot;limitBeforeNativeQuery&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                properties.put(<span class="string">&quot;limitAfterNativeQuery&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                properties.put(<span class="string">&quot;blobType&quot;</span>, <span class="string">&quot;BLOB&quot;</span>);</span><br><span class="line">                properties.put(<span class="string">&quot;boolValue&quot;</span>, <span class="string">&quot;TRUE&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (databaseType != <span class="literal">null</span>) &#123;</span><br><span class="line">                    properties.load(getResourceAsStream(pathToEngineDbProperties()));</span><br><span class="line">                &#125;</span><br><span class="line">              </span><br><span class="line">                <span class="comment">//Mybatis相关的配置</span></span><br><span class="line">                <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> initMybatisConfiguration(environment, reader, properties);</span><br><span class="line">                sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(configuration);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlowableException</span>(<span class="string">&quot;Error while building ibatis SqlSessionFactory: &quot;</span> + e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                IoUtil.closeSilently(inputStream);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//ProcessEngineConfigurationImpl.getMyBatisXmlConfigurationStream();</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> InputStream <span class="title function_">getMyBatisXmlConfigurationStream</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getResourceAsStream(mybatisMappingFile);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//代码往上翻</span></span><br><span class="line">  <span class="comment">//构造器中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProcessEngineConfigurationImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        mybatisMappingFile = DEFAULT_MYBATIS_MAPPING_FILE;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//其中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_MYBATIS_MAPPING_FILE</span> <span class="operator">=</span> <span class="string">&quot;org/flowable/db/mapping/mappings.xml&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>查找映射文件 mappings.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;org.flowable.common.engine.impl.persistence.entity.ByteArrayRefTypeHandler&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;ByteArrayRefTypeHandler&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;org.flowable.common.engine.impl.persistence.entity.ByteArrayRefTypeHandler&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;VariableByteArrayRefTypeHandler&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;org.flowable.common.engine.impl.persistence.entity.ByteArrayRefTypeHandler&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;JobByteArrayRefTypeHandler&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;org.flowable.common.engine.impl.persistence.entity.ByteArrayRefTypeHandler&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;BatchByteArrayRefTypeHandler&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;ByteArrayRefTypeHandler&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;org.flowable.common.engine.impl.persistence.entity.ByteArrayRef&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;VariableByteArrayRefTypeHandler&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;org.flowable.common.engine.impl.persistence.entity.ByteArrayRef&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;JobByteArrayRefTypeHandler&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;org.flowable.common.engine.impl.persistence.entity.ByteArrayRef&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;BatchByteArrayRefTypeHandler&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;org.flowable.common.engine.impl.persistence.entity.ByteArrayRef&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/ChangeTenantBpmn.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/entity/Attachment.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/entity/Comment.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/job/service/db/mapping/entity/DeadLetterJob.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/entity/Deployment.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/entity/Execution.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/entity/ActivityInstance.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/entity/HistoricActivityInstance.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/entity/HistoricDetail.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/entity/HistoricProcessInstance.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/variable/service/db/mapping/entity/HistoricVariableInstance.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/task/service/db/mapping/entity/HistoricTaskInstance.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/task/service/db/mapping/entity/HistoricTaskLogEntry.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/identitylink/service/db/mapping/entity/HistoricIdentityLink.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/entitylink/service/db/mapping/entity/HistoricEntityLink.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/job/service/db/mapping/entity/HistoryJob.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/identitylink/service/db/mapping/entity/IdentityLink.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/entitylink/service/db/mapping/entity/EntityLink.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/job/service/db/mapping/entity/Job.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/entity/Model.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/entity/ProcessDefinition.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/entity/ProcessDefinitionInfo.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/common/db/mapping/entity/Property.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/common/db/mapping/entity/ByteArray.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/common/db/mapping/common.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/entity/Resource.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/job/service/db/mapping/entity/SuspendedJob.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/job/service/db/mapping/entity/ExternalWorkerJob.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/common/db/mapping/entity/TableData.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/task/service/db/mapping/entity/Task.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/job/service/db/mapping/entity/TimerJob.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/variable/service/db/mapping/entity/VariableInstance.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/eventsubscription/service/db/mapping/entity/EventSubscription.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/db/mapping/entity/EventLogEntry.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/batch/service/db/mapping/entity/Batch.xml&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/flowable/batch/service/db/mapping/entity/BatchPart.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ProcessEnginConfigurationImpl.init()中的代码</span></span><br><span class="line">initDataManagers(); <span class="comment">//下面拿这个举例3</span></span><br><span class="line"><span class="comment">//-&gt;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initDataManagers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.initDataManagers();</span><br><span class="line">        <span class="keyword">if</span> (attachmentDataManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            attachmentDataManager = <span class="keyword">new</span> <span class="title class_">MybatisAttachmentDataManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (commentDataManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            commentDataManager = <span class="keyword">new</span> <span class="title class_">MybatisCommentDataManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (deploymentDataManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//下面拿这个查看</span></span><br><span class="line">            deploymentDataManager = <span class="keyword">new</span> <span class="title class_">MybatisDeploymentDataManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (eventLogEntryDataManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            eventLogEntryDataManager = <span class="keyword">new</span> <span class="title class_">MybatisEventLogEntryDataManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (executionDataManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            executionDataManager = <span class="keyword">new</span> <span class="title class_">MybatisExecutionDataManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dbSqlSessionFactory != <span class="literal">null</span> &amp;&amp; executionDataManager <span class="keyword">instanceof</span> AbstractDataManager) &#123;</span><br><span class="line">            dbSqlSessionFactory.addLogicalEntityClassMapping(<span class="string">&quot;execution&quot;</span>, ((AbstractDataManager) executionDataManager).getManagedEntityClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (historicActivityInstanceDataManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            historicActivityInstanceDataManager = <span class="keyword">new</span> <span class="title class_">MybatisHistoricActivityInstanceDataManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (activityInstanceDataManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            activityInstanceDataManager = <span class="keyword">new</span> <span class="title class_">MybatisActivityInstanceDataManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (historicDetailDataManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            historicDetailDataManager = <span class="keyword">new</span> <span class="title class_">MybatisHistoricDetailDataManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (historicProcessInstanceDataManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            historicProcessInstanceDataManager = <span class="keyword">new</span> <span class="title class_">MybatisHistoricProcessInstanceDataManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modelDataManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            modelDataManager = <span class="keyword">new</span> <span class="title class_">MybatisModelDataManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (processDefinitionDataManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            processDefinitionDataManager = <span class="keyword">new</span> <span class="title class_">MybatisProcessDefinitionDataManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (processDefinitionInfoDataManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            processDefinitionInfoDataManager = <span class="keyword">new</span> <span class="title class_">MybatisProcessDefinitionInfoDataManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resourceDataManager == <span class="literal">null</span>) &#123;</span><br><span class="line">            resourceDataManager = <span class="keyword">new</span> <span class="title class_">MybatisResourceDataManager</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//--&gt;MybatisDeploymentDataManager，这个类相当于mybatis中的mapper</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Joram Barrez</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisDeploymentDataManager</span> <span class="keyword">extends</span> <span class="title class_">AbstractProcessDataManager</span>&lt;DeploymentEntity&gt; <span class="keyword">implements</span> <span class="title class_">DeploymentDataManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MybatisDeploymentDataManager</span><span class="params">(ProcessEngineConfigurationImpl processEngineConfiguration)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(processEngineConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">DeploymentEntity</span>&gt; getManagedEntityClass() &#123;</span><br><span class="line">        <span class="keyword">return</span> DeploymentEntityImpl.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DeploymentEntity <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DeploymentEntityImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">findDeploymentCountByQueryCriteria</span><span class="params">(DeploymentQueryImpl deploymentQuery)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Long) getDbSqlSession().selectOne(<span class="string">&quot;selectDeploymentCountByQueryCriteria&quot;</span>, deploymentQuery);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Deployment&gt; <span class="title function_">findDeploymentsByQueryCriteria</span><span class="params">(DeploymentQueryImpl deploymentQuery)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;selectDeploymentsByQueryCriteria&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> getDbSqlSession().selectList(query, deploymentQuery);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getDeploymentResourceNames</span><span class="params">(String deploymentId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDbSqlSession().getSqlSession().selectList(<span class="string">&quot;selectResourceNamesByDeploymentId&quot;</span>, deploymentId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Deployment&gt; <span class="title function_">findDeploymentsByNativeQuery</span><span class="params">(Map&lt;String, Object&gt; parameterMap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getDbSqlSession().selectListWithRawParameter(<span class="string">&quot;selectDeploymentByNativeQuery&quot;</span>, parameterMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">findDeploymentCountByNativeQuery</span><span class="params">(Map&lt;String, Object&gt; parameterMap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Long) getDbSqlSession().selectOne(<span class="string">&quot;selectDeploymentCountByNativeQuery&quot;</span>, parameterMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="processengine各种方法对比">ProcessEngine各种方法对比</h2>
<ul>
<li>ProcessEngines.getDefaultProcessEngine();的方式</li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line"> * Initializes all process engines that can be found on the classpath for resources &lt;code&gt;flowable.cfg.xml&lt;/code&gt; (plain Flowable style configuration) and for resources</span><br><span class="line"> * &lt;code&gt;flowable-context.xml&lt;/code&gt; (Spring style configuration).</span><br><span class="line"> */</span><br><span class="line">public static synchronized void init() &#123;</span><br><span class="line">    if (!isInitialized()) &#123;</span><br><span class="line">        if (processEngines == null) &#123;</span><br><span class="line">            // Create new map to store process-engines if current map is null</span><br><span class="line">            processEngines = new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        ClassLoader classLoader = ReflectUtil.getClassLoader();</span><br><span class="line">        Enumeration&lt;URL&gt; resources = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            resources = classLoader.getResources(&quot;flowable.cfg.xml&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new FlowableIllegalArgumentException(&quot;problem retrieving flowable.cfg.xml resources on the classpath: &quot; + System.getProperty(&quot;java.class.path&quot;), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Remove duplicated configuration URL&#x27;s using set. Some</span><br><span class="line">        // classloaders may return identical URL&#x27;s twice, causing duplicate</span><br><span class="line">        // startups</span><br><span class="line">        Set&lt;URL&gt; configUrls = new HashSet&lt;&gt;();</span><br><span class="line">        while (resources.hasMoreElements()) &#123;</span><br><span class="line">            configUrls.add(resources.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        for (URL resource : configUrls) &#123;</span><br><span class="line">            LOGGER.info(&quot;Initializing process engine using configuration &#x27;&#123;&#125;&#x27;&quot;, resource);</span><br><span class="line">            initProcessEngineFromResource(resource); //注意这个</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            resources = classLoader.getResources(&quot;flowable-context.xml&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new FlowableIllegalArgumentException(&quot;problem retrieving flowable-context.xml resources on the classpath: &quot; + System.getProperty(&quot;java.class.path&quot;), e);</span><br><span class="line">        &#125;</span><br><span class="line">        while (resources.hasMoreElements()) &#123;</span><br><span class="line">            URL resource = resources.nextElement();</span><br><span class="line">            LOGGER.info(&quot;Initializing process engine using Spring configuration &#x27;&#123;&#125;&#x27;&quot;, resource);</span><br><span class="line">            initProcessEngineFromSpringResource(resource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setInitialized(true);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        LOGGER.info(&quot;Process engines already initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以通过Spring配置文件的方式</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">initProcessEngineFromResource(resource); <span class="comment">//注意这个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> EngineInfo <span class="title function_">initProcessEngineFromResource</span><span class="params">(URL resourceUrl)</span> &#123;</span><br><span class="line">        <span class="type">EngineInfo</span> <span class="variable">processEngineInfo</span> <span class="operator">=</span> processEngineInfosByResourceUrl.get(resourceUrl.toString());</span><br><span class="line">        <span class="comment">// if there is an existing process engine info</span></span><br><span class="line">        <span class="keyword">if</span> (processEngineInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// remove that process engine from the member fields</span></span><br><span class="line">            processEngineInfos.remove(processEngineInfo);</span><br><span class="line">            <span class="keyword">if</span> (processEngineInfo.getException() == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">processEngineName</span> <span class="operator">=</span> processEngineInfo.getName();</span><br><span class="line">                processEngines.remove(processEngineName);</span><br><span class="line">                processEngineInfosByName.remove(processEngineName);</span><br><span class="line">            &#125;</span><br><span class="line">            processEngineInfosByResourceUrl.remove(processEngineInfo.getResourceUrl());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">resourceUrlString</span> <span class="operator">=</span> resourceUrl.toString();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;initializing process engine for resource &#123;&#125;&quot;</span>, resourceUrl);</span><br><span class="line">            <span class="comment">//注意这个</span></span><br><span class="line">            <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> buildProcessEngine(resourceUrl);</span><br><span class="line">            <span class="type">String</span> <span class="variable">processEngineName</span> <span class="operator">=</span> processEngine.getName();</span><br><span class="line">            LOGGER.info(<span class="string">&quot;initialised process engine &#123;&#125;&quot;</span>, processEngineName);</span><br><span class="line">            processEngineInfo = <span class="keyword">new</span> <span class="title class_">EngineInfo</span>(processEngineName, resourceUrlString, <span class="literal">null</span>);</span><br><span class="line">            processEngines.put(processEngineName, processEngine);</span><br><span class="line">            processEngineInfosByName.put(processEngineName, processEngineInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Exception while initializing process engine: &#123;&#125;&quot;</span>, e.getMessage(), e);</span><br><span class="line">            processEngineInfo = <span class="keyword">new</span> <span class="title class_">EngineInfo</span>(<span class="literal">null</span>, resourceUrlString, ExceptionUtils.getStackTrace(e));</span><br><span class="line">        &#125;</span><br><span class="line">        processEngineInfosByResourceUrl.put(resourceUrlString, processEngineInfo);</span><br><span class="line">        processEngineInfos.add(processEngineInfo);</span><br><span class="line">        <span class="keyword">return</span> processEngineInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buildProcessEngine(resourceUrl);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ProcessEngine <span class="title function_">buildProcessEngine</span><span class="params">(URL resource)</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = resource.openStream();</span><br><span class="line">            <span class="type">ProcessEngineConfiguration</span> <span class="variable">processEngineConfiguration</span> <span class="operator">=</span> ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream);</span><br><span class="line">            <span class="keyword">return</span> processEngineConfiguration.buildProcessEngine();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FlowableIllegalArgumentException</span>(<span class="string">&quot;couldn&#x27;t open resource stream: &quot;</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IoUtil.closeSilently(inputStream);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>flowable_波哥_b站</tag>
      </tags>
  </entry>
  <entry>
    <title>boge-02-flowable进阶_2</title>
    <url>/2022/05/14/study/flowable/boge_blbl/02-advance_2/</url>
    <content><![CDATA[<h2 id="service服务接口">Service服务接口</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514233449225.png"
alt="image-20220514233449225" />
<figcaption aria-hidden="true">image-20220514233449225</figcaption>
</figure>
<ul>
<li>各个Service类 RepositoryService 资源管理类，流程定义、部署、文件
RuntimeService 流程运行管理类，运行过程中（执行） TaskService 任务管理类
HistoryService 历史管理类 ManagerService 引擎管理类</li>
</ul>
<h2 id="flowable图标">Flowable图标</h2>
<p>BPMN2.0定义的一些图标</p>
<ul>
<li>时间</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514233856102.png"
alt="image-20220514233856102" />
<figcaption aria-hidden="true">image-20220514233856102</figcaption>
</figure>
<ul>
<li>活动 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514234008644.png"
alt="image-20220514234008644" /></li>
<li>网关 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514234018899.png"
alt="image-20220514234018899" /></li>
<li></li>
</ul>
<h2 id="流程部署深入解析">流程部署深入解析</h2>
<ul>
<li><p>使用eclipse打包部署(没有eclipse环境，所以这里只有截图)
将两个流程，打包为bar文件，然后放到项目resources文件夹中 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514235033874.png"
alt="image-20220514235033874" /><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514235051403.png"
alt="image-20220514235051403" /></p></li>
<li><p>这里是为了测试一次部署多个流程（定义，图） 代码如下 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514235134845.png"
alt="image-20220514235134845" /></p></li>
<li><p>部署完成后查看表结构</p>
<ul>
<li><p>act_re_procdef</p>
<p>部署id一样 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514235300573.png"
alt="image-20220514235300573" /></p></li>
<li><p>act_re_deployment <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514235344635.png"
alt="image-20220514235344635" /></p></li>
<li><p>结论：部署和定义是1对多的关系</p></li>
</ul></li>
<li><p>每次部署所涉及到的资源文件 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514235449058.png"
alt="image-20220514235449058" /></p></li>
<li><p>涉及到的三张表</p>
<ul>
<li><p>act_ge_bytearray <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220514235610659.png"
alt="image-20220514235610659" /></p></li>
<li><p>act_re_procdef category--&gt;xml中的namespace
name--&gt;定义时起的名称 key_---&gt;xml中定义的id
resource_name---&gt;xml文件名称 dgrm_resource_name--&gt;生成图片名称
suspension_state --&gt; 是否被挂起</p>
<p>tenant_id -- &gt;谁部署的流程</p></li>
<li><p>act_re_deployment name_部署名</p></li>
</ul></li>
<li><p>代码 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515000033931.png"
alt="image-20220515000033931" /></p></li>
<li><p>主要源码 DeployCmd.class <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515000146834.png"
alt="image-20220515000146834" /></p></li>
<li><p>DeploymentEntityManagerImpl.java <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515000232452.png"
alt="image-20220515000232452" /></p></li>
<li><p>insert()方法 插入并执行资源 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515000308747.png"
alt="image-20220515000308747" /> 点开里面的insert方法 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515000330794.png"
alt="image-20220515000330794" /></p></li>
<li><p>AbstractDataManger.insert() <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515000405402.png"
alt="image-20220515000405402" /></p></li>
<li><p>回到test类，deploy()方法最终就是完成了表结构的数据的操作（通过Mybatis）</p></li>
</ul>
<h2 id="流程的挂起和激活">流程的挂起和激活</h2>
<ul>
<li><p>xml文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;definitions xmlns=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span></span><br><span class="line">             xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">             xmlns:xsd=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span><br><span class="line">             xmlns:bpmndi=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span></span><br><span class="line">             xmlns:omgdc=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span></span><br><span class="line">             xmlns:omgdi=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span></span><br><span class="line">             xmlns:flowable=<span class="string">&quot;http://flowable.org/bpmn&quot;</span></span><br><span class="line">             typeLanguage=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span><br><span class="line">             expressionLanguage=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span></span><br><span class="line">             targetNamespace=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--id process key--&gt;</span><br><span class="line">    &lt;process id=<span class="string">&quot;holidayRequest&quot;</span> name=<span class="string">&quot;请假流程&quot;</span> isExecutable=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;startEvent id=<span class="string">&quot;startEvent&quot;</span>/&gt;</span><br><span class="line">        &lt;!--sequenceFlow表示的是线条箭头--&gt;</span><br><span class="line">        &lt;sequenceFlow sourceRef=<span class="string">&quot;startEvent&quot;</span> targetRef=<span class="string">&quot;approveTask&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;userTask id=<span class="string">&quot;approveTask&quot;</span> name=<span class="string">&quot;同意或者拒绝请假&quot;</span> flowable:assignee=<span class="string">&quot;zhangsan&quot;</span>/&gt;</span><br><span class="line">        &lt;sequenceFlow sourceRef=<span class="string">&quot;approveTask&quot;</span> targetRef=<span class="string">&quot;decision&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--网关--&gt;</span><br><span class="line">        &lt;exclusiveGateway id=<span class="string">&quot;decision&quot;</span>/&gt;</span><br><span class="line">        &lt;sequenceFlow sourceRef=<span class="string">&quot;decision&quot;</span> targetRef=<span class="string">&quot;externalSystemCall&quot;</span>&gt;</span><br><span class="line">            &lt;!--条件--&gt;</span><br><span class="line">            &lt;conditionExpression xsi:type=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span><br><span class="line">                &lt;![CDATA[</span><br><span class="line">          $&#123;approved&#125;</span><br><span class="line">        ]]&gt;</span><br><span class="line">            &lt;/conditionExpression&gt;</span><br><span class="line">        &lt;/sequenceFlow&gt;</span><br><span class="line">        &lt;sequenceFlow  sourceRef=<span class="string">&quot;decision&quot;</span> targetRef=<span class="string">&quot;sendRejectionMail&quot;</span>&gt;</span><br><span class="line">            &lt;!--条件--&gt;</span><br><span class="line">            &lt;conditionExpression xsi:type=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span><br><span class="line">                &lt;![CDATA[</span><br><span class="line">          $&#123;!approved&#125;</span><br><span class="line">        ]]&gt;</span><br><span class="line">            &lt;/conditionExpression&gt;</span><br><span class="line">        &lt;/sequenceFlow&gt;</span><br><span class="line"></span><br><span class="line">        &lt;serviceTask id=<span class="string">&quot;externalSystemCall&quot;</span> name=<span class="string">&quot;Enter holidays in external system&quot;</span></span><br><span class="line">                     flowable:class=<span class="string">&quot;org.flowable.CallExternalSystemDelegate&quot;</span>/&gt;</span><br><span class="line">        &lt;sequenceFlow sourceRef=<span class="string">&quot;externalSystemCall&quot;</span> targetRef=<span class="string">&quot;holidayApprovedTask&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;userTask id=<span class="string">&quot;holidayApprovedTask&quot;</span> name=<span class="string">&quot;Holiday approved&quot;</span> flowable:assignee=<span class="string">&quot;lisi&quot;</span>/&gt;</span><br><span class="line">        &lt;sequenceFlow sourceRef=<span class="string">&quot;holidayApprovedTask&quot;</span> targetRef=<span class="string">&quot;approveEnd&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--发送一个邮件--&gt;</span><br><span class="line">        &lt;serviceTask id=<span class="string">&quot;sendRejectionMail&quot;</span> name=<span class="string">&quot;Send out rejection email&quot;</span></span><br><span class="line">                     flowable:class=<span class="string">&quot;org.flowable.SendRejectionMail&quot;</span>/&gt;</span><br><span class="line">        &lt;sequenceFlow sourceRef=<span class="string">&quot;sendRejectionMail&quot;</span> targetRef=<span class="string">&quot;rejectEnd&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;endEvent id=<span class="string">&quot;approveEnd&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;endEvent id=<span class="string">&quot;rejectEnd&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/process&gt;</span><br><span class="line"></span><br><span class="line">&lt;/definitions&gt;</span><br></pre></td></tr></table></figure>
<p>部署的流程默认情况下为激活，如果不想使用该定义的流程，那么可以挂起该流程，当然该流程定义下边所有的流程实例全部暂停。</p></li>
<li><p>流程定义被定义为挂起，该流程定义将不允许启动新的流程实例，且该流程定义下所有的流程实例将被全部挂起暂停执行</p></li>
<li><p>表结构
act_re_procdef表中的SUSPENSION_STATE字段来表示1激活，2挂起</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515075535507.png"
alt="image-20220515075535507" />
<figcaption aria-hidden="true">image-20220515075535507</figcaption>
</figure></li>
<li><p>挂起流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSuspend</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">engine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> engine.getRepositoryService();</span><br><span class="line">    <span class="comment">//找到流程定义</span></span><br><span class="line">    <span class="type">ProcessDefinition</span> <span class="variable">processDefinition</span> <span class="operator">=</span> repositoryService.</span><br><span class="line">            createProcessDefinitionQuery().processDefinitionId(<span class="string">&quot;holidayRequest:1:7503&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="comment">//当前流程定义的状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">suspended</span> <span class="operator">=</span> processDefinition.isSuspended();</span><br><span class="line">    <span class="keyword">if</span> (suspended) &#123;</span><br><span class="line">        <span class="comment">//如果挂起则激活</span></span><br><span class="line">        System.out.println(<span class="string">&quot;激活流程(定义)&quot;</span> + processDefinition.getId() + <span class="string">&quot;name:&quot;</span> + processDefinition</span><br><span class="line">                .getName());</span><br><span class="line">        repositoryService.activateProcessDefinitionById(processDefinition.getId());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果激活则挂起</span></span><br><span class="line">        System.out.println(<span class="string">&quot;挂起流程(定义)&quot;</span> + processDefinition.getId() + <span class="string">&quot;name:&quot;</span> + processDefinition</span><br><span class="line">                .getName());</span><br><span class="line">        repositoryService.suspendProcessDefinitionById(processDefinition.getId());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515080404847.png"
alt="image-20220515080404847" /></p></li>
<li><p>如果这时启动流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流程运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRunProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();<span class="comment">//configuration.buildProcessEngine();</span></span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> processEngine.getRuntimeService();</span><br><span class="line">    <span class="comment">//这边模拟表单数据(表单数据有多种处理方式，这只是其中一种)</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;employee&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;nrOfHolidays&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    map.put(<span class="string">&quot;description&quot;</span>, <span class="string">&quot;工作累了想出去玩&quot;</span>);</span><br><span class="line">    <span class="type">ProcessInstance</span> <span class="variable">holidayRequest</span> <span class="operator">=</span> runtimeService.startProcessInstanceByKey(</span><br><span class="line">            <span class="string">&quot;holidayRequest&quot;</span>, map);</span><br><span class="line">    System.out.println(<span class="string">&quot;流程定义的id:&quot;</span> + holidayRequest.getProcessDefinitionId());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前活跃id:&quot;</span> + holidayRequest.getActivityId());</span><br><span class="line">    System.out.println(<span class="string">&quot;流程运行id:&quot;</span> + holidayRequest.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则会出现异常报错信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">org.flowable.common.engine.api.FlowableException: Cannot start process instance. Process definition 请假流程 (id = holidayRequest:1:7503) is suspended</span><br></pre></td></tr></table></figure></li>
<li><p>此时再运行一次testSuspend()，将流程定义激活，此时数据库act_re_procdef表中的SUSPENSION_STATE字段值为1
再运行testRunProcess()，流程正常启动 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515081034659.png"
alt="image-20220515081034659" /></p></li>
</ul>
<h2 id="启动流程的原理">启动流程的原理</h2>
<ul>
<li><p>流程启动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流程运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRunProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();<span class="comment">//configuration.buildProcessEngine();</span></span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> processEngine.getRepositoryService();</span><br><span class="line">    <span class="type">Deployment</span> <span class="variable">deploy</span> <span class="operator">=</span> repositoryService.createDeployment()</span><br><span class="line">            .addClasspathResource(<span class="string">&quot;holiday-request.bpmn20.xml&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;ly05150817部署的请假流程&quot;</span>)</span><br><span class="line">            .deploy();</span><br><span class="line">    <span class="comment">//通过部署id查找流程定义</span></span><br><span class="line">    <span class="type">ProcessDefinition</span> <span class="variable">processDefinition</span> <span class="operator">=</span> repositoryService.createProcessDefinitionQuery().</span><br><span class="line">            deploymentId(deploy.getId())</span><br><span class="line">            .singleResult();</span><br><span class="line">  </span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> processEngine.getRuntimeService();</span><br><span class="line">    <span class="comment">//这边模拟表单数据(表单数据有多种处理方式，这只是其中一种)</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;employee&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;nrOfHolidays&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    map.put(<span class="string">&quot;description&quot;</span>, <span class="string">&quot;工作累了想出去玩&quot;</span>);</span><br><span class="line">    <span class="type">ProcessInstance</span> <span class="variable">holidayRequest</span> <span class="operator">=</span> runtimeService.startProcessInstanceById(</span><br><span class="line">            processDefinition.getId(), <span class="string">&quot;order1000&quot;</span>, map);</span><br><span class="line">    System.out.println(<span class="string">&quot;流程定义的id:&quot;</span> + holidayRequest.getProcessDefinitionId());</span><br><span class="line">    System.out.println(<span class="string">&quot;当前活跃id:&quot;</span> + holidayRequest.getActivityId());</span><br><span class="line">    System.out.println(<span class="string">&quot;流程运行id:&quot;</span> + holidayRequest.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>涉及到的表：(HI中也有对应的表)</p>
<ul>
<li><p>ACT_RU_EXECUTION 运行时流程执行实例
当启动一个实例的时候，这里会有两个流程执行</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515084231981.png"
alt="image-20220515084231981" />
<figcaption aria-hidden="true">image-20220515084231981</figcaption>
</figure></li>
<li><p>ACT_RU_IDENTITYLINK 运行时用户关系信息</p>
<ul>
<li><p>记录流程实例当前所处的节点</p></li>
<li><p>数据库表 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515084517415.png"
alt="image-20220515084517415" /></p></li>
<li><p>有几种任务处理人的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdentityLinkType</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ASSIGNEE</span> <span class="operator">=</span> <span class="string">&quot;assignee&quot;</span>; <span class="comment">//指派</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CANDIDATE</span> <span class="operator">=</span> <span class="string">&quot;candidate&quot;</span>;<span class="comment">//候选</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">OWNER</span> <span class="operator">=</span> <span class="string">&quot;owner&quot;</span>;<span class="comment">//拥有者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">STARTER</span> <span class="operator">=</span> <span class="string">&quot;starter&quot;</span>;<span class="comment">//启动者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARTICIPANT</span> <span class="operator">=</span> <span class="string">&quot;participant&quot;</span>;<span class="comment">//参与者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REACTIVATOR</span> <span class="operator">=</span> <span class="string">&quot;reactivator&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>ACT_RU_TASK 运行时任务表 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515084822445.png"
alt="image-20220515084822445" /></p></li>
<li><p>ACT_RU_VARIABLE 运行时变量表</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515084910997.png"
alt="image-20220515084910997" />
<figcaption aria-hidden="true">image-20220515084910997</figcaption>
</figure></li>
</ul></li>
</ul>
<h2 id="处理流程的原理">处理流程的原理</h2>
<ul>
<li><p>流程处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompleted</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="comment">//获取当前流程实例绑定的流程变量</span></span><br><span class="line">    Map&lt;String, Object&gt; processVariables = task.getProcessVariables();</span><br><span class="line">    Set&lt;String&gt; keySet = processVariables.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String key:keySet)&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> processVariables.get(key);</span><br><span class="line">        System.out.println(<span class="string">&quot;key:&quot;</span>+key+<span class="string">&quot;--value:&quot;</span>+o);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    processVariables.put(<span class="string">&quot;approved&quot;</span>,<span class="literal">true</span>);<span class="comment">//同意</span></span><br><span class="line">    processVariables.put(<span class="string">&quot;description&quot;</span>,<span class="string">&quot;我被修改了&quot;</span>);</span><br><span class="line">    taskService.complete(task.getId(),processVariables);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这里用的是之前的xml，所以应该给一个服务监听类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallExternalSystemDelegate</span> <span class="keyword">implements</span> <span class="title class_">JavaDelegate</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(DelegateExecution execution)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;您的请求通过了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>任务处理后，这里添加了一个变量，且修改了变量description <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515091219370.png"
alt="image-20220515091219370" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515091248276.png"
alt="image-20220515091248276" /></p>
<ul>
<li>可以通过流程变量，它可以在整个流程过程中流转的[注意，这里流程结束后流程变量会不存在的，但是act_hi_variinst里面可以看到流程变量实例]
//我感觉应该用表单替代</li>
</ul></li>
<li><p>act_ru_task和act_ru_identitylink</p>
<ul>
<li>两者区别
<ul>
<li><strong>ACT _ RU _
IDENTITYLINK</strong>：此表存储有关用户或组的数据及其与（流程/案例/等）实例相关的角色。该表也被其他需要身份链接的引擎使用。【显示全部，包括已完成】</li>
<li><strong>ACT _ RU _
TASK</strong>：此表包含一个正在运行的实例的每个未完成用户任务的条目。然后在查询用户的任务列表时使用此表。【这里只显示运行中】</li>
</ul></li>
<li>act_ru_task 记录当前实例所运行的当前节点的信息 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515091649172.png"
alt="image-20220515091649172" /></li>
<li>act_ru_identitylink <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515091833571.png"
alt="image-20220515091833571" /></li>
</ul></li>
<li><p>act_ru_execution这个表的数据不会有变动 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515091928802.png"
alt="image-20220515091928802" /></p></li>
</ul>
<h2 id="流程结束的原理">流程结束的原理</h2>
<ul>
<li><p>流程走完</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCompleted1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">        <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">                .processInstanceId(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">                .taskAssignee(<span class="string">&quot;lisi&quot;</span>)</span><br><span class="line">                .singleResult();</span><br><span class="line">        <span class="comment">//获取当前流程实例绑定的流程变量</span></span><br><span class="line">        Map&lt;String, Object&gt; processVariables = task.getProcessVariables();</span><br><span class="line">        Set&lt;String&gt; keySet = processVariables.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> processVariables.get(key);</span><br><span class="line">            System.out.println(<span class="string">&quot;key:&quot;</span> + key + <span class="string">&quot;--value:&quot;</span> + o);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            processVariables.put(&quot;approved&quot;,true);//拒绝</span></span><br><span class="line"><span class="comment">            processVariables.put(&quot;description&quot;,&quot;我被修改了&quot;);*/</span></span><br><span class="line">        taskService.complete(task.getId(), processVariables);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>此时跟流程相关的数据都会被清空掉 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515093046925.png"
alt="image-20220515093046925" /></p></li>
<li><p>历史数据</p>
<ul>
<li><p>变量 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515093214154.png"
alt="image-20220515093214154" /></p></li>
<li><p>任务流转历史 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515093316108.png"
alt="image-20220515093316108" /></p></li>
<li><p>流程实例 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515093350660.png"
alt="image-20220515093350660" /></p></li>
<li><p>涉及到的用户 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515093451995.png"
alt="image-20220515093451995" /></p></li>
<li><p>流程活动</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515093538334.png"
alt="image-20220515093538334" />
<figcaption aria-hidden="true">image-20220515093538334</figcaption>
</figure></li>
<li></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>flowable_波哥_b站</tag>
      </tags>
  </entry>
  <entry>
    <title>02-flowable进阶_3</title>
    <url>/2022/05/15/study/flowable/boge_blbl/02-advance_3/</url>
    <content><![CDATA[<h2 id="任务分配-uel表达式">任务分配-uel表达式</h2>
<p>通过变量指定来进行分配</p>
<ul>
<li><p>首先绘制流程图（定义） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515100239983.png"
alt="image-20220515100239983" /></p>
<ul>
<li>变量处理 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515100603738.png"
alt="image-20220515100603738" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515100629221.png"
alt="image-20220515100629221" /></li>
</ul></li>
<li><p>之后将xml文件导出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;definitions xmlns=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> xmlns:xsd=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> xmlns:flowable=<span class="string">&quot;http://flowable.org/bpmn&quot;</span> xmlns:bpmndi=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> xmlns:omgdc=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span> xmlns:omgdi=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span> typeLanguage=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> expressionLanguage=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span> targetNamespace=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span> exporter=<span class="string">&quot;Flowable Open Source Modeler&quot;</span> exporterVersion=<span class="string">&quot;6.7.2&quot;</span>&gt;</span><br><span class="line">  &lt;process id=<span class="string">&quot;holiday-new&quot;</span> name=<span class="string">&quot;新请假流程&quot;</span> isExecutable=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">    &lt;documentation&gt;<span class="keyword">new</span>-description&lt;/documentation&gt;</span><br><span class="line">    &lt;startEvent id=<span class="string">&quot;startEvent1&quot;</span> flowable:formFieldValidation=<span class="string">&quot;true&quot;</span>&gt;&lt;/startEvent&gt;</span><br><span class="line">    &lt;userTask id=<span class="string">&quot;sid-8D901410-5BD7-4EED-B988-5E40D12298C7&quot;</span> name=<span class="string">&quot;创建请假流程&quot;</span> flowable:assignee=<span class="string">&quot;$&#123;assignee0&#125;&quot;</span> flowable:formFieldValidation=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">      &lt;extensionElements&gt;</span><br><span class="line">        &lt;modeler:initiator-can-complete xmlns:modeler=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;&lt;![CDATA[<span class="literal">false</span>]]&gt;&lt;/modeler:initiator-can-complete&gt;</span><br><span class="line">      &lt;/extensionElements&gt;</span><br><span class="line">    &lt;/userTask&gt;</span><br><span class="line">    &lt;userTask id=<span class="string">&quot;sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&quot;</span> name=<span class="string">&quot;审批请假流程&quot;</span> flowable:assignee=<span class="string">&quot;$&#123;assignee1&#125;&quot;</span> flowable:formFieldValidation=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">      &lt;extensionElements&gt;</span><br><span class="line">        &lt;modeler:initiator-can-complete xmlns:modeler=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;&lt;![CDATA[<span class="literal">false</span>]]&gt;&lt;/modeler:initiator-can-complete&gt;</span><br><span class="line">      &lt;/extensionElements&gt;</span><br><span class="line">    &lt;/userTask&gt;</span><br><span class="line">    &lt;sequenceFlow id=<span class="string">&quot;sid-631EFFB0-795A-4777-B49E-CF7D015BFF15&quot;</span> sourceRef=<span class="string">&quot;sid-8D901410-5BD7-4EED-B988-5E40D12298C7&quot;</span> targetRef=<span class="string">&quot;sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&quot;</span>&gt;&lt;/sequenceFlow&gt;</span><br><span class="line">    &lt;endEvent id=<span class="string">&quot;sid-15CAD0D3-7F8B-404C-9346-A8D2A456D47B&quot;</span>&gt;&lt;/endEvent&gt;</span><br><span class="line">    &lt;sequenceFlow id=<span class="string">&quot;sid-001CA567-6169-4F8A-A0E5-010721D52508&quot;</span> sourceRef=<span class="string">&quot;sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&quot;</span> targetRef=<span class="string">&quot;sid-15CAD0D3-7F8B-404C-9346-A8D2A456D47B&quot;</span>&gt;&lt;/sequenceFlow&gt;</span><br><span class="line">    &lt;sequenceFlow id=<span class="string">&quot;sid-0A4A52F2-ECF6-44B2-AA41-F926AA7F5932&quot;</span> sourceRef=<span class="string">&quot;startEvent1&quot;</span> targetRef=<span class="string">&quot;sid-8D901410-5BD7-4EED-B988-5E40D12298C7&quot;</span>&gt;&lt;/sequenceFlow&gt;</span><br><span class="line">  &lt;/process&gt;</span><br><span class="line">  &lt;bpmndi:BPMNDiagram id=<span class="string">&quot;BPMNDiagram_holiday-new&quot;</span>&gt;</span><br><span class="line">    &lt;bpmndi:BPMNPlane bpmnElement=<span class="string">&quot;holiday-new&quot;</span> id=<span class="string">&quot;BPMNPlane_holiday-new&quot;</span>&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;startEvent1&quot;</span> id=<span class="string">&quot;BPMNShape_startEvent1&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;30.0&quot;</span> width=<span class="string">&quot;30.0&quot;</span> x=<span class="string">&quot;100.0&quot;</span> y=<span class="string">&quot;145.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;sid-8D901410-5BD7-4EED-B988-5E40D12298C7&quot;</span> id=<span class="string">&quot;BPMNShape_sid-8D901410-5BD7-4EED-B988-5E40D12298C7&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;80.0&quot;</span> width=<span class="string">&quot;100.0&quot;</span> x=<span class="string">&quot;225.0&quot;</span> y=<span class="string">&quot;120.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&quot;</span> id=<span class="string">&quot;BPMNShape_sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;80.0&quot;</span> width=<span class="string">&quot;100.0&quot;</span> x=<span class="string">&quot;370.0&quot;</span> y=<span class="string">&quot;120.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;sid-15CAD0D3-7F8B-404C-9346-A8D2A456D47B&quot;</span> id=<span class="string">&quot;BPMNShape_sid-15CAD0D3-7F8B-404C-9346-A8D2A456D47B&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;28.0&quot;</span> width=<span class="string">&quot;28.0&quot;</span> x=<span class="string">&quot;555.0&quot;</span> y=<span class="string">&quot;146.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=<span class="string">&quot;sid-001CA567-6169-4F8A-A0E5-010721D52508&quot;</span> id=<span class="string">&quot;BPMNEdge_sid-001CA567-6169-4F8A-A0E5-010721D52508&quot;</span> flowable:sourceDockerX=<span class="string">&quot;50.0&quot;</span> flowable:sourceDockerY=<span class="string">&quot;40.0&quot;</span> flowable:targetDockerX=<span class="string">&quot;14.0&quot;</span> flowable:targetDockerY=<span class="string">&quot;14.0&quot;</span>&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;469.94999999997356&quot;</span> y=<span class="string">&quot;160.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;555.0&quot;</span> y=<span class="string">&quot;160.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=<span class="string">&quot;sid-0A4A52F2-ECF6-44B2-AA41-F926AA7F5932&quot;</span> id=<span class="string">&quot;BPMNEdge_sid-0A4A52F2-ECF6-44B2-AA41-F926AA7F5932&quot;</span> flowable:sourceDockerX=<span class="string">&quot;15.0&quot;</span> flowable:sourceDockerY=<span class="string">&quot;15.0&quot;</span> flowable:targetDockerX=<span class="string">&quot;50.0&quot;</span> flowable:targetDockerY=<span class="string">&quot;40.0&quot;</span>&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;129.94999928606217&quot;</span> y=<span class="string">&quot;160.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;224.99999999995185&quot;</span> y=<span class="string">&quot;160.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=<span class="string">&quot;sid-631EFFB0-795A-4777-B49E-CF7D015BFF15&quot;</span> id=<span class="string">&quot;BPMNEdge_sid-631EFFB0-795A-4777-B49E-CF7D015BFF15&quot;</span> flowable:sourceDockerX=<span class="string">&quot;50.0&quot;</span> flowable:sourceDockerY=<span class="string">&quot;40.0&quot;</span> flowable:targetDockerX=<span class="string">&quot;50.0&quot;</span> flowable:targetDockerY=<span class="string">&quot;40.0&quot;</span>&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;324.9499999999907&quot;</span> y=<span class="string">&quot;160.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;369.9999999999807&quot;</span> y=<span class="string">&quot;160.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">    &lt;/bpmndi:BPMNPlane&gt;</span><br><span class="line">  &lt;/bpmndi:BPMNDiagram&gt;</span><br><span class="line">&lt;/definitions&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>流程定义的部署</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流程的部署</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeploy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> configuration.buildProcessEngine();</span><br><span class="line">    <span class="comment">//获取服务(repository，流程定义)</span></span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> processEngine.getRepositoryService();</span><br><span class="line">    <span class="type">Deployment</span> <span class="variable">deploy</span> <span class="operator">=</span> repositoryService.createDeployment()</span><br><span class="line">            .addClasspathResource(<span class="string">&quot;新请假流程.bpmn20.xml&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;请求流程&quot;</span>) <span class="comment">//流程名</span></span><br><span class="line">            .deploy();</span><br><span class="line">    System.out.println(<span class="string">&quot;部署id&quot;</span> + deploy.getId());</span><br><span class="line">    System.out.println(<span class="string">&quot;部署名&quot;</span> + deploy.getName());</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>流程的启动（在流程启动时就已经处理好了各个节点的处理人）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流程实例的启动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRunProcess2</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> engine.getRuntimeService();</span><br><span class="line">    <span class="comment">//启动流程时，发起人就已经设置好了</span></span><br><span class="line">    Map&lt;String,Object&gt; variables=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    variables.put(<span class="string">&quot;assignee0&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    variables.put(<span class="string">&quot;assignee1&quot;</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="type">ProcessInstance</span> <span class="variable">processInstance</span> <span class="operator">=</span> runtimeService.startProcessInstanceById(<span class="string">&quot;holiday-new:1:4&quot;</span>,variables);</span><br><span class="line">    System.out.println(processInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>查看数据库表数据</p>
<ul>
<li><p>act_ru_variable</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515101806631.png"
alt="image-20220515101806631" /><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515101906703.png"
alt="image-20220515101906703" /></p></li>
<li><p>act_ru_task <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515101840975.png"
alt="image-20220515101840975" /></p></li>
</ul></li>
<li><p>让张三完成处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testComplete</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery().taskAssignee(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    taskService.complete(task.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>此时观察task和identity这两张表</p>
<p>任务变成了李四，而identity多了张三的记录<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515102508734.png"
alt="image-20220515102508734" /></p></li>
</ul></li>
</ul>
<h2 id="任务分配-监听器分配">任务分配-监听器分配</h2>
<ul>
<li><p>首先，java代码中，自定义一个监听器
【注意，这里给任务分配assignee是在create中分配才是有用的】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.flowable.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.flowable.engine.delegate.TaskListener;</span><br><span class="line"><span class="keyword">import</span> org.flowable.task.service.delegate.DelegateTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTaskListener</span> <span class="keyword">implements</span> <span class="title class_">TaskListener</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听器触发的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delegateTask</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(DelegateTask delegateTask)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;MyTaskListener触发：&quot;</span>+delegateTask</span><br><span class="line">                .getName());</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;创建请假流程&quot;</span>.equals(delegateTask.getName())</span><br><span class="line">        &amp;&amp;<span class="string">&quot;create&quot;</span>.equals(delegateTask.getEventName()))&#123;</span><br><span class="line">            delegateTask.setAssignee(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            delegateTask.setAssignee(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两个节点走的是同一个监听器</p></li>
<li><p>xml定义中任务监听器的配置(两个节点都配置了) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515103504436.png"
alt="image-20220515103504436" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;definitions xmlns=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> xmlns:xsd=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> xmlns:flowable=<span class="string">&quot;http://flowable.org/bpmn&quot;</span> xmlns:bpmndi=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> xmlns:omgdc=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span> xmlns:omgdi=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span> typeLanguage=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> expressionLanguage=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span> targetNamespace=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span> exporter=<span class="string">&quot;Flowable Open Source Modeler&quot;</span> exporterVersion=<span class="string">&quot;6.7.2&quot;</span>&gt;</span><br><span class="line">  &lt;process id=<span class="string">&quot;holiday-new&quot;</span> name=<span class="string">&quot;新请假流程&quot;</span> isExecutable=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">    &lt;documentation&gt;<span class="keyword">new</span>-description&lt;/documentation&gt;</span><br><span class="line">    &lt;startEvent id=<span class="string">&quot;startEvent1&quot;</span> flowable:formFieldValidation=<span class="string">&quot;true&quot;</span>&gt;&lt;/startEvent&gt;</span><br><span class="line">    &lt;userTask id=<span class="string">&quot;sid-8D901410-5BD7-4EED-B988-5E40D12298C7&quot;</span> name=<span class="string">&quot;创建请假流程&quot;</span> flowable:formFieldValidation=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">      &lt;extensionElements&gt;</span><br><span class="line">        &lt;flowable:taskListener event=<span class="string">&quot;create&quot;</span> class=<span class="string">&quot;org.flowable.listener.MyTaskListener&quot;</span>&gt;&lt;/flowable:taskListener&gt;</span><br><span class="line">      &lt;/extensionElements&gt;</span><br><span class="line">    &lt;/userTask&gt;</span><br><span class="line">    &lt;userTask id=<span class="string">&quot;sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&quot;</span> name=<span class="string">&quot;审批请假流程&quot;</span> flowable:formFieldValidation=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">      &lt;extensionElements&gt;</span><br><span class="line">        &lt;flowable:taskListener event=<span class="string">&quot;create&quot;</span> class=<span class="string">&quot;org.flowable.listener.MyTaskListener&quot;</span>&gt;&lt;/flowable:taskListener&gt;</span><br><span class="line">      &lt;/extensionElements&gt;</span><br><span class="line">    &lt;/userTask&gt;</span><br><span class="line">    &lt;sequenceFlow id=<span class="string">&quot;sid-631EFFB0-795A-4777-B49E-CF7D015BFF15&quot;</span> sourceRef=<span class="string">&quot;sid-8D901410-5BD7-4EED-B988-5E40D12298C7&quot;</span> targetRef=<span class="string">&quot;sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&quot;</span>&gt;&lt;/sequenceFlow&gt;</span><br><span class="line">    &lt;sequenceFlow id=<span class="string">&quot;sid-001CA567-6169-4F8A-A0E5-010721D52508&quot;</span> sourceRef=<span class="string">&quot;sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&quot;</span> targetRef=<span class="string">&quot;sid-15CAD0D3-7F8B-404C-9346-A8D2A456D47B&quot;</span>&gt;&lt;/sequenceFlow&gt;</span><br><span class="line">    &lt;sequenceFlow id=<span class="string">&quot;sid-0A4A52F2-ECF6-44B2-AA41-F926AA7F5932&quot;</span> sourceRef=<span class="string">&quot;startEvent1&quot;</span> targetRef=<span class="string">&quot;sid-8D901410-5BD7-4EED-B988-5E40D12298C7&quot;</span>&gt;&lt;/sequenceFlow&gt;</span><br><span class="line">    &lt;endEvent id=<span class="string">&quot;sid-15CAD0D3-7F8B-404C-9346-A8D2A456D47B&quot;</span>&gt;&lt;/endEvent&gt;</span><br><span class="line">  &lt;/process&gt;</span><br><span class="line">  &lt;bpmndi:BPMNDiagram id=<span class="string">&quot;BPMNDiagram_holiday-new&quot;</span>&gt;</span><br><span class="line">    &lt;bpmndi:BPMNPlane bpmnElement=<span class="string">&quot;holiday-new&quot;</span> id=<span class="string">&quot;BPMNPlane_holiday-new&quot;</span>&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;startEvent1&quot;</span> id=<span class="string">&quot;BPMNShape_startEvent1&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;30.0&quot;</span> width=<span class="string">&quot;30.0&quot;</span> x=<span class="string">&quot;100.0&quot;</span> y=<span class="string">&quot;115.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;sid-8D901410-5BD7-4EED-B988-5E40D12298C7&quot;</span> id=<span class="string">&quot;BPMNShape_sid-8D901410-5BD7-4EED-B988-5E40D12298C7&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;80.0&quot;</span> width=<span class="string">&quot;100.0&quot;</span> x=<span class="string">&quot;195.0&quot;</span> y=<span class="string">&quot;90.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&quot;</span> id=<span class="string">&quot;BPMNShape_sid-5EB8F68B-7876-42AF-98E1-FCA27F99D8CE&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;80.0&quot;</span> width=<span class="string">&quot;100.0&quot;</span> x=<span class="string">&quot;370.0&quot;</span> y=<span class="string">&quot;90.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;sid-15CAD0D3-7F8B-404C-9346-A8D2A456D47B&quot;</span> id=<span class="string">&quot;BPMNShape_sid-15CAD0D3-7F8B-404C-9346-A8D2A456D47B&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;28.0&quot;</span> width=<span class="string">&quot;28.0&quot;</span> x=<span class="string">&quot;570.0&quot;</span> y=<span class="string">&quot;116.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=<span class="string">&quot;sid-001CA567-6169-4F8A-A0E5-010721D52508&quot;</span> id=<span class="string">&quot;BPMNEdge_sid-001CA567-6169-4F8A-A0E5-010721D52508&quot;</span> flowable:sourceDockerX=<span class="string">&quot;50.0&quot;</span> flowable:sourceDockerY=<span class="string">&quot;40.0&quot;</span> flowable:targetDockerX=<span class="string">&quot;14.0&quot;</span> flowable:targetDockerY=<span class="string">&quot;14.0&quot;</span>&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;469.9499999999809&quot;</span> y=<span class="string">&quot;130.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;570.0&quot;</span> y=<span class="string">&quot;130.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=<span class="string">&quot;sid-0A4A52F2-ECF6-44B2-AA41-F926AA7F5932&quot;</span> id=<span class="string">&quot;BPMNEdge_sid-0A4A52F2-ECF6-44B2-AA41-F926AA7F5932&quot;</span> flowable:sourceDockerX=<span class="string">&quot;15.0&quot;</span> flowable:sourceDockerY=<span class="string">&quot;15.0&quot;</span> flowable:targetDockerX=<span class="string">&quot;50.0&quot;</span> flowable:targetDockerY=<span class="string">&quot;40.0&quot;</span>&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;129.94999891869114&quot;</span> y=<span class="string">&quot;130.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;195.0&quot;</span> y=<span class="string">&quot;130.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=<span class="string">&quot;sid-631EFFB0-795A-4777-B49E-CF7D015BFF15&quot;</span> id=<span class="string">&quot;BPMNEdge_sid-631EFFB0-795A-4777-B49E-CF7D015BFF15&quot;</span> flowable:sourceDockerX=<span class="string">&quot;50.0&quot;</span> flowable:sourceDockerY=<span class="string">&quot;40.0&quot;</span> flowable:targetDockerX=<span class="string">&quot;50.0&quot;</span> flowable:targetDockerY=<span class="string">&quot;40.0&quot;</span>&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;294.95000000000005&quot;</span> y=<span class="string">&quot;130.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;369.99999999993753&quot;</span> y=<span class="string">&quot;130.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">    &lt;/bpmndi:BPMNPlane&gt;</span><br><span class="line">  &lt;/bpmndi:BPMNDiagram&gt;</span><br><span class="line">&lt;/definitions&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>之后将流程再重新部署一遍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流程的部署</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeploy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> configuration.buildProcessEngine();</span><br><span class="line">    <span class="comment">//获取服务(repository，流程定义)</span></span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> processEngine.getRepositoryService();</span><br><span class="line">    <span class="type">Deployment</span> <span class="variable">deploy</span> <span class="operator">=</span> repositoryService.createDeployment()</span><br><span class="line">            .addClasspathResource(<span class="string">&quot;新请假流程.bpmn20.xml&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;请求流程&quot;</span>) <span class="comment">//流程名</span></span><br><span class="line">            .deploy();</span><br><span class="line">    System.out.println(<span class="string">&quot;部署id&quot;</span> + deploy.getId());</span><br><span class="line">    System.out.println(<span class="string">&quot;部署名&quot;</span> + deploy.getName());</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>流程运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流程实例的启动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRunProcess3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">engine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> engine.getRuntimeService();</span><br><span class="line">    <span class="type">ProcessInstance</span> <span class="variable">processInstance</span> <span class="operator">=</span> runtimeService.startProcessInstanceById(</span><br><span class="line">            <span class="string">&quot;holiday-new:1:4&quot;</span>);</span><br><span class="line">    System.out.println(processInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>控制台查看 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515104113169.png"
alt="image-20220515104113169" /></p></li>
<li><p>数据库查看 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515104240526.png"
alt="image-20220515104240526" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515104248454.png"
alt="image-20220515104248454" /></p></li>
<li><p>让小明处理任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testComplete</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery().taskAssignee(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    taskService.complete(task.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数据库查看 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515104524706.png"
alt="image-20220515104524706" /></p></li>
</ul>
<h2 id="流程变量">流程变量</h2>
<ul>
<li><p>全局变量（跟流程有关）和局部变量（跟task有关）</p></li>
<li><p>一个流程定义，可以运行多个流程实例； <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515105403272.png"
alt="image-20220515105403272" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515105511486.png"
alt="image-20220515105511486" /> 当用到子流程时，就会出现一对多的关系
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515105549313.png"
alt="image-20220515105549313" /></p></li>
<li><p>全局变量被重复赋值时后面会覆盖前面</p></li>
<li><p>流程图的创建 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515110130347.png"
alt="image-20220515110130347" /> 这里还设置了条件，详见xm文件
sequenceFlow.conditionExpression 属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">xmlns:flowable</span>=<span class="string">&quot;http://flowable.org/bpmn&quot;</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> <span class="attr">xmlns:omgdc</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span> <span class="attr">xmlns:omgdi</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span> <span class="attr">typeLanguage</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">expressionLanguage</span>=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span> <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span> <span class="attr">exporter</span>=<span class="string">&quot;Flowable Open Source Modeler&quot;</span> <span class="attr">exporterVersion</span>=<span class="string">&quot;6.7.2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">&quot;evection&quot;</span> <span class="attr">name</span>=<span class="string">&quot;出差申请单&quot;</span> <span class="attr">isExecutable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">documentation</span>&gt;</span>出差申请单<span class="tag">&lt;/<span class="name">documentation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-BFB6D699-D3B5-4C6C-A0F2-00584EAAF207&quot;</span> <span class="attr">name</span>=<span class="string">&quot;创建出差申请单&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;$&#123;assignee0&#125;&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-EE410204-0433-4FE6-A958-48585A2A7B4B&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-BFB6D699-D3B5-4C6C-A0F2-00584EAAF207&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-D10C4F45-B429-4E24-B474-5354F1661645&quot;</span> <span class="attr">name</span>=<span class="string">&quot;部门经理审批&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;$&#123;assignee1&#125;&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-752CE2F2-40EC-4140-AF60-BEACD06D43A7&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-BFB6D699-D3B5-4C6C-A0F2-00584EAAF207&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-D10C4F45-B429-4E24-B474-5354F1661645&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-35AB278B-E16D-4CEC-98B1-FBB139FB5AC1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;总经理审批&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;$&#123;assignee2&#125;&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-4C26DA5C-A4CC-48A5-ABA9-853E82FC2413&quot;</span> <span class="attr">name</span>=<span class="string">&quot;财务审批</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;$&#123;assignee3&#125;&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-BE043A23-0F38-4ED9-A0D1-F4C2F7908A50&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-35AB278B-E16D-4CEC-98B1-FBB139FB5AC1&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-4C26DA5C-A4CC-48A5-ABA9-853E82FC2413&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">&quot;sid-B3A1D5D4-E1FD-4599-A482-762C7C617844&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">endEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-6C0130A8-E078-486B-9B6E-D8C14BBCD8EF&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-4C26DA5C-A4CC-48A5-ABA9-853E82FC2413&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-B3A1D5D4-E1FD-4599-A482-762C7C617844&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-F85B2D44-1B42-4748-AB35-123C7CCD2F75&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-D10C4F45-B429-4E24-B474-5354F1661645&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-35AB278B-E16D-4CEC-98B1-FBB139FB5AC1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span>&lt;![CDATA[$&#123;num &gt;= 3&#125;]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-B12793A8-FC65-408C-81AD-EC81FEEF6E46&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-D10C4F45-B429-4E24-B474-5354F1661645&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-4C26DA5C-A4CC-48A5-ABA9-853E82FC2413&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span>&lt;![CDATA[$&#123;num &lt; 3&#125;]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">&quot;BPMNDiagram_evection&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;evection&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNPlane_evection&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_startEvent1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;75.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-BFB6D699-D3B5-4C6C-A0F2-00584EAAF207&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-BFB6D699-D3B5-4C6C-A0F2-00584EAAF207&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;175.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;50.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-D10C4F45-B429-4E24-B474-5354F1661645&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-D10C4F45-B429-4E24-B474-5354F1661645&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;320.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;50.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-35AB278B-E16D-4CEC-98B1-FBB139FB5AC1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-35AB278B-E16D-4CEC-98B1-FBB139FB5AC1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;555.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;50.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-4C26DA5C-A4CC-48A5-ABA9-853E82FC2413&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-4C26DA5C-A4CC-48A5-ABA9-853E82FC2413&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;555.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;210.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-B3A1D5D4-E1FD-4599-A482-762C7C617844&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-B3A1D5D4-E1FD-4599-A482-762C7C617844&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;750.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;236.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-EE410204-0433-4FE6-A958-48585A2A7B4B&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-EE410204-0433-4FE6-A958-48585A2A7B4B&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;129.9499984899576&quot;</span> <span class="attr">y</span>=<span class="string">&quot;90.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;175.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;90.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-752CE2F2-40EC-4140-AF60-BEACD06D43A7&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-752CE2F2-40EC-4140-AF60-BEACD06D43A7&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;274.95000000000005&quot;</span> <span class="attr">y</span>=<span class="string">&quot;90.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;320.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;90.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-B12793A8-FC65-408C-81AD-EC81FEEF6E46&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-B12793A8-FC65-408C-81AD-EC81FEEF6E46&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;419.95000000000005&quot;</span> <span class="attr">y</span>=<span class="string">&quot;124.0085106382979&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;555.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;215.95744680851067&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-6C0130A8-E078-486B-9B6E-D8C14BBCD8EF&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-6C0130A8-E078-486B-9B6E-D8C14BBCD8EF&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;14.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;14.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;654.9499999998701&quot;</span> <span class="attr">y</span>=<span class="string">&quot;250.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;750.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;250.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-BE043A23-0F38-4ED9-A0D1-F4C2F7908A50&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-BE043A23-0F38-4ED9-A0D1-F4C2F7908A50&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;605.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;129.95&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;605.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;210.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-F85B2D44-1B42-4748-AB35-123C7CCD2F75&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-F85B2D44-1B42-4748-AB35-123C7CCD2F75&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;419.95000000000005&quot;</span> <span class="attr">y</span>=<span class="string">&quot;90.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;555.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;90.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>流程进行部署</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流程的部署</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeploy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取ProcessEngine对象</span></span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取服务(repository，流程定义)</span></span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> processEngine.getRepositoryService();</span><br><span class="line">    <span class="type">Deployment</span> <span class="variable">deploy</span> <span class="operator">=</span> repositoryService.createDeployment()</span><br><span class="line">            .addClasspathResource(<span class="string">&quot;出差申请单.bpmn20.xml&quot;</span>)</span><br><span class="line">            .name(<span class="string">&quot;请假流程&quot;</span>) <span class="comment">//流程名</span></span><br><span class="line">            .deploy();</span><br><span class="line">    System.out.println(<span class="string">&quot;部署id&quot;</span> + deploy.getId());</span><br><span class="line">    System.out.println(<span class="string">&quot;部署名&quot;</span> + deploy.getName());</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>流程运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流程实例的定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runProcess</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> processEngine.getRuntimeService();</span><br><span class="line">    Map&lt;String,Object&gt; variables=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    variables.put(<span class="string">&quot;assignee0&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    variables.put(<span class="string">&quot;assignee1&quot;</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    variables.put(<span class="string">&quot;assignee2&quot;</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    variables.put(<span class="string">&quot;assignee3&quot;</span>,<span class="string">&quot;赵财务&quot;</span>);</span><br><span class="line">    <span class="type">ProcessInstance</span> <span class="variable">processInstance</span> <span class="operator">=</span> runtimeService.</span><br><span class="line">            startProcessInstanceById(<span class="string">&quot;evection:1:4&quot;</span>, variables);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>//这时候节点走到张三了，让张三处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    Map&lt;String,Object&gt; processVariables=task.getProcessVariables();</span><br><span class="line">    processVariables.put(<span class="string">&quot;num&quot;</span>,<span class="number">3</span>);</span><br><span class="line">    taskService.complete(task.getId(),processVariables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>下面修改num的值，修改之前 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515113105628.png"
alt="image-20220515113105628" /></p>
<ul>
<li><p>全局变量的查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getVariables</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine(); </span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .includeProcessVariables() <span class="comment">//注意，这个一定要加的不然获取不到全局变量</span></span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="comment">//这里只能获取到任务的局部变量</span></span><br><span class="line">    Map&lt;String, Object&gt; processVariables = task.getProcessVariables();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前流程变量--start&quot;</span>);</span><br><span class="line">    Set&lt;String&gt; keySet1 = processVariables.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String key:keySet1)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key--&quot;</span>+key+<span class="string">&quot;value--&quot;</span>+processVariables.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前流程变量--end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateVariables</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .includeProcessVariables() <span class="comment">//注意，这个一定要加的不然获取不到全局变量</span></span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    Map&lt;String, Object&gt; processVariables = task.getProcessVariables();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前流程变量--start&quot;</span>);</span><br><span class="line">    Set&lt;String&gt; keySet = processVariables.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String key:keySet)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key--&quot;</span>+key+<span class="string">&quot;value--&quot;</span>+processVariables.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前流程变量--end&quot;</span>);</span><br><span class="line">    processVariables.put(<span class="string">&quot;num&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    taskService.setVariablesLocal(task.getId(),processVariables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结果</p>
<p>按照视频的说法，这里错了，应该是会多了5条记录 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515120415965.png"
alt="image-20220515120415965" /></p></li>
</ul></li>
<li><p>局部变量的再次测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateVariables</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .includeProcessVariables()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="comment">//流程还没开始运行的情况下，取到的是全局变量</span></span><br><span class="line">    Map&lt;String, Object&gt; processVariables = task.getProcessVariables();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前流程变量--start&quot;</span>);</span><br><span class="line">    Set&lt;String&gt; keySet = processVariables.keySet();</span><br><span class="line">    <span class="keyword">for</span>(String key:keySet)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key--&quot;</span>+key+<span class="string">&quot;value--&quot;</span>+processVariables.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前流程变量--end&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    Map&lt;String,Object&gt; varLocalInsert=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    varLocalInsert.put(<span class="string">&quot;num&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    Map&lt;String,Object&gt; varUpdate=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    varUpdate.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;嘿嘿&quot;</span>);</span><br><span class="line">    <span class="comment">//这里测试会不会把全局变量全部覆盖</span></span><br><span class="line">    taskService.setVariables(task.getId(),varUpdate);</span><br><span class="line">    taskService.setVariablesLocal(task.getId(),varLocalInsert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改前 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515120817587.png"
alt="image-20220515120817587" /></li>
<li>修改后 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515121223413.png"
alt="image-20220515121223413" />
<ul>
<li>结果表明这是批量增加/修改，而不是覆盖</li>
</ul></li>
</ul></li>
<li><p>当前数据库的数据 1个局部变量num，5个全局变量 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515121439233.png"
alt="image-20220515121439233" /></p></li>
<li><p>接下来在张三节点设置一个局部变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    Map&lt;String,Object&gt; processVariables=task.getProcessVariables();</span><br><span class="line">    processVariables.put(<span class="string">&quot;num&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    taskService.complete(task.getId(),processVariables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看数据库表，发现num已经被修改成2</li>
</ul></li>
<li><p>这时李四设置了一个局部变量num=6</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateVariables2</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .includeProcessVariables()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">            .singleResult(); </span><br><span class="line">  </span><br><span class="line">    Map&lt;String,Object&gt; varLocalInsert=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    varLocalInsert.put(<span class="string">&quot;num&quot;</span>,<span class="number">6</span>);</span><br><span class="line">    Map&lt;String,Object&gt; varUpdate=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    varUpdate.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;嘿嘿&quot;</span>);</span><br><span class="line">    <span class="comment">//这里测试会不会把全局变量全部覆盖</span></span><br><span class="line">    <span class="comment">//taskService.setVariables(task.getId(),varUpdate);</span></span><br><span class="line">    taskService.setVariablesLocal(task.getId(),varLocalInsert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅仅多了一条记录 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515122216621.png"
alt="image-20220515122216621" /></p></li>
<li><p>修改全局变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateVariables3</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .includeProcessVariables()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">  </span><br><span class="line">    Map&lt;String,Object&gt; varLocalInsert=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    varLocalInsert.put(<span class="string">&quot;num&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    varLocalInsert.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a被修改了&quot;</span>);</span><br><span class="line">    <span class="comment">//这里测试会不会把全局变量全部覆盖</span></span><br><span class="line">    <span class="comment">//taskService.setVariables(task.getId(),varUpdate);</span></span><br><span class="line">    taskService.setVariables(task.getId(),varLocalInsert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结果如下，<strong>当局部变量和全局变量的名称一样时，只能修改局部变量</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515122635345.png"
alt="image-20220515122635345" /></p></li>
<li><p>让李四完成审批
这里存在局部变量num=18，且完成时设置了局部变量20</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete4</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .includeProcessVariables()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    System.out.println(<span class="string">&quot;taskId&quot;</span>+task.getId());</span><br><span class="line">    Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;num&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    taskService.complete(task.getId(),map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意，这里全局变量被改成20了，局部变量被删除了 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515123339736.png"
alt="image-20220515123339736" /> 走到了总经理审批</p></li>
<li><p>再测试 将数据清空，重新部署并运行流程</p>
<p>现在在赵四节点，局部变量为 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515124117180.png"
alt="image-20220515124117180" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete4</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .includeProcessVariables()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    System.out.println(<span class="string">&quot;taskId&quot;</span>+task.getId());</span><br><span class="line">    Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;num&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    taskService.setVariablesLocal(task.getId(),map);</span><br><span class="line">    taskService.complete(task.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行完之后，局部变量变成20了，但是流程走不下去
稍作更改，添加一个全局变量(但是由于存在局部变量a，所以这里全局变量没设置成功)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete4</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .includeProcessVariables()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    System.out.println(<span class="string">&quot;taskId&quot;</span>+task.getId());</span><br><span class="line">    Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;num&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    taskService.setVariablesLocal(task.getId(),map);</span><br><span class="line">    Map&lt;String,Object&gt; map1=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map1.put(<span class="string">&quot;num&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    taskService.setVariables(task.getId(),map1);</span><br><span class="line">    taskService.complete(task.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>现在只能通过在complete中设置，来使得全局变量生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete4</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .includeProcessVariables()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    System.out.println(<span class="string">&quot;taskId&quot;</span>+task.getId());</span><br><span class="line">    Map&lt;String,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;num&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    taskService.setVariablesLocal(task.getId(),map);</span><br><span class="line">  </span><br><span class="line">    Map&lt;String,Object&gt; map1=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map1.put(<span class="string">&quot;num&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//taskService.setVariables(task.getId(),map1);</span></span><br><span class="line">    taskService.complete(task.getId(),map1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果，全局变量设置成功，且任务流转到了财务那 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515124802205.png"
alt="image-20220515124802205" /></li>
</ul></li>
<li><p>再测试</p>
<ul>
<li><p>在存在局部变量num=2的情况下执行下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  	</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .includeProcessVariables()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    System.out.println(<span class="string">&quot;taskId&quot;</span> + task.getId());</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;num&quot;</span>, <span class="number">15</span>);</span><br><span class="line">    taskService.setVariables(task.getId(), map);</span><br><span class="line">    taskService.complete(task.getId());</span><br><span class="line">    <span class="comment">/*Map&lt;String,Object&gt; map1=new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">    map1.put(&quot;num&quot;,1);</span></span><br><span class="line"><span class="comment">    taskService.complete(task.getId(),map1);*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会提示报错，Unknown property used in expression: ${num &gt;= 3}</p>
<p>//说明线条中查找的是全局变量</p></li>
<li><p>在不存在局部变量num的情况下执行上面代码，会走总经理审批（num&gt;3)</p></li>
<li><p>在complete中加上map参数，验证明线条查找的是全局变量的值，complete带上variables会设置全局变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete5</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .includeProcessVariables()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    System.out.println(<span class="string">&quot;taskId&quot;</span> + task.getId());</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;num&quot;</span>, <span class="number">15</span>);</span><br><span class="line">   <span class="comment">// taskService.setVariables(task.getId(), map);</span></span><br><span class="line">    taskService.complete(task.getId(),map);</span><br><span class="line">    <span class="comment">/*Map&lt;String,Object&gt; map1=new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">    map1.put(&quot;num&quot;,1);</span></span><br><span class="line"><span class="comment">    taskService.complete(task.getId(),map1);*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据库表 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515130825823.png"
alt="image-20220515130825823" /></li>
</ul></li>
<li><p>act_hi_varinst 里面看得到局部变量</p></li>
</ul></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>flowable_波哥_b站</tag>
      </tags>
  </entry>
  <entry>
    <title>boge-02-flowable进阶_4</title>
    <url>/2022/05/15/study/flowable/boge_blbl/02-advance_4/</url>
    <content><![CDATA[<h2 id="候选人">候选人</h2>
<ul>
<li><p>流程图设计</p>
<ul>
<li>总体 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515143002689.png"
alt="image-20220515143002689" /></li>
<li>具体 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515142952857.png"
alt="image-20220515142952857" /></li>
</ul></li>
<li><p>部署并启动流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deploy</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine= ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> processEngine.getRepositoryService();</span><br><span class="line">    <span class="type">Deployment</span> <span class="variable">deploy</span> <span class="operator">=</span> repositoryService.createDeployment().name(<span class="string">&quot;ly画的请假流程-候选人&quot;</span>)</span><br><span class="line">            .addClasspathResource(<span class="string">&quot;请假流程-候选人.bpmn20.xml&quot;</span>)</span><br><span class="line">            .deploy();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runProcess</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置候选人</span></span><br><span class="line">    Map&lt;String,Object&gt; variables=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    variables.put(<span class="string">&quot;candidate1&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    variables.put(<span class="string">&quot;candidate2&quot;</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    variables.put(<span class="string">&quot;candidate3&quot;</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//获取流程运行服务</span></span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> engine.getRuntimeService();</span><br><span class="line">    <span class="comment">//运行流程</span></span><br><span class="line">    <span class="type">ProcessInstance</span> <span class="variable">processInstance</span> <span class="operator">=</span> runtimeService.startProcessInstanceById(</span><br><span class="line">            <span class="string">&quot;holiday-candidate:1:4&quot;</span>,variables);</span><br><span class="line">    System.out.println(<span class="string">&quot;processInstance--&quot;</span>+processInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查看数据库表数据</p>
<ul>
<li>处理人为空 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515144843249.png"
alt="image-20220515144843249" /></li>
<li>变量 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515144901217.png"
alt="image-20220515144901217" /></li>
<li>图解 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515144943769.png"
alt="image-20220515144943769" /></li>
</ul></li>
<li><p>实际，作为登录用户如果是张三/李四或者王五，那它可以查看它自己是候选人的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询候选任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryCandidate</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    TaskService taskService=processEngine.getTaskService();</span><br><span class="line">    List&lt;Task&gt; tasks = taskService.createTaskQuery()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;5001&quot;</span>)</span><br><span class="line">            .taskCandidateUser(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="keyword">for</span>(Task task:tasks)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id--&quot;</span>+task.getId()+<span class="string">&quot;--&quot;</span>+task.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>拾取任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拾取任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">claimTaskCandidate</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    TaskService taskService=engine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;5001&quot;</span>)</span><br><span class="line">            .taskCandidateUser(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="keyword">if</span>(task != <span class="literal">null</span> )&#123;</span><br><span class="line">        <span class="comment">//拾取任务</span></span><br><span class="line">        taskService.claim(task.getId(),<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;拾取任务成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据库数据 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515145820087.png"
alt="image-20220515145820087" /></li>
<li>此时查询李四候选任务，就查询不到了</li>
</ul></li>
<li><p>归还任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拾取任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unclaimTaskCandidate</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    TaskService taskService=engine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;5001&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="keyword">if</span>(task != <span class="literal">null</span> )&#123;</span><br><span class="line">        <span class="comment">//归还任务</span></span><br><span class="line">        taskService.unclaim(task.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;归还任务成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据库数据 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515150149037.png"
alt="image-20220515150149037" /></li>
<li>此时用李四，拾取成功 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515150352270.png"
alt="image-20220515150352270" /></li>
</ul></li>
<li><p>任务交接(委托)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务交接(委托)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskCandidate</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    TaskService taskService=engine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;5001&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="keyword">if</span>(task != <span class="literal">null</span> )&#123;</span><br><span class="line">        taskService.setAssignee(task.getId(),<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;任务交接给赵六&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515150637180.png"
alt="image-20220515150637180" /></li>
</ul></li>
<li><p>完成任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> engine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;5001&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;赵六&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="keyword">if</span>(task!=<span class="literal">null</span>)&#123;</span><br><span class="line">        taskService.complete(task.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;完成任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>此时任务给wz了 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515150842118.png"
alt="image-20220515150842118" /></p></li>
</ul>
<h2 id="候选人组">候选人组</h2>
<ul>
<li><p>当候选人很多的情况下，可以分组。（先创建组，然后将用户放到组中）</p></li>
<li><p>维护用户和组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine= ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">IdentityService</span> <span class="variable">identityService</span> <span class="operator">=</span> engine.getIdentityService();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> identityService.newUser(<span class="string">&quot;李飞&quot;</span>);</span><br><span class="line">    user1.setFirstName(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">    user1.setLastName(<span class="string">&quot;fei&quot;</span>);</span><br><span class="line">    identityService.saveUser(user1);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> identityService.newUser(<span class="string">&quot;灯标&quot;</span>);</span><br><span class="line">    user2.setFirstName(<span class="string">&quot;deng&quot;</span>);</span><br><span class="line">    user2.setLastName(<span class="string">&quot;biao&quot;</span>);</span><br><span class="line">    identityService.saveUser(user2);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> identityService.newUser(<span class="string">&quot;田家&quot;</span>);</span><br><span class="line">    user3.setFirstName(<span class="string">&quot;tian&quot;</span>);</span><br><span class="line">    user3.setLastName(<span class="string">&quot;jia&quot;</span>);</span><br><span class="line">    identityService.saveUser(user3);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createGroup</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">IdentityService</span> <span class="variable">identityService</span> <span class="operator">=</span> engine.getIdentityService();</span><br><span class="line">    <span class="type">Group</span> <span class="variable">group1</span> <span class="operator">=</span> identityService.newGroup(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">    group1.setName(<span class="string">&quot;销售部&quot;</span>);</span><br><span class="line">    group1.setType(<span class="string">&quot;typ1&quot;</span>);</span><br><span class="line">    identityService.saveGroup(group1);</span><br><span class="line">    <span class="type">Group</span> <span class="variable">group2</span> <span class="operator">=</span> identityService.newGroup(<span class="string">&quot;group2&quot;</span>);</span><br><span class="line">    group2.setName(<span class="string">&quot;开发部&quot;</span>);</span><br><span class="line">    group2.setType(<span class="string">&quot;typ2&quot;</span>);</span><br><span class="line">    identityService.saveGroup(group2);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userGroup</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">IdentityService</span> <span class="variable">identityService</span> <span class="operator">=</span> engine.getIdentityService();</span><br><span class="line">    <span class="comment">//找到组</span></span><br><span class="line">    <span class="type">Group</span> <span class="variable">group1</span> <span class="operator">=</span> identityService.createGroupQuery().groupId(<span class="string">&quot;group1&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="comment">//找到所有用户</span></span><br><span class="line">    List&lt;User&gt; list = identityService.createUserQuery().list();</span><br><span class="line">    <span class="keyword">for</span>(User user:list)&#123;</span><br><span class="line">        identityService.createMembership(user.getId(),group1.getId());</span><br><span class="line">  </span><br><span class="line">        System.out.println(user.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>表结构</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515152203278.png"
alt="image-20220515152203278" />
<figcaption aria-hidden="true">image-20220515152203278</figcaption>
</figure>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515152221653.png"
alt="image-20220515152221653" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515152232911.png"
alt="image-20220515152232911" /></p></li>
</ul></li>
<li><p>应用，创建流程图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515152724439.png"
alt="image-20220515152724439" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515152756047.png"
alt="image-20220515152756047" /></p></li>
<li><p>xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">xmlns:flowable</span>=<span class="string">&quot;http://flowable.org/bpmn&quot;</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> <span class="attr">xmlns:omgdc</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span> <span class="attr">xmlns:omgdi</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span> <span class="attr">typeLanguage</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">expressionLanguage</span>=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span> <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span> <span class="attr">exporter</span>=<span class="string">&quot;Flowable Open Source Modeler&quot;</span> <span class="attr">exporterVersion</span>=<span class="string">&quot;6.7.2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">&quot;holiday-group&quot;</span> <span class="attr">name</span>=<span class="string">&quot;请求流程-候选人组&quot;</span> <span class="attr">isExecutable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-B4CAA6EE-47C0-4C51-AB0F-7A347AA88CF9&quot;</span> <span class="attr">name</span>=<span class="string">&quot;创建请假单&quot;</span> <span class="attr">flowable:candidateGroups</span>=<span class="string">&quot;$&#123;g1&#125;&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-FAA16FF3-BFC5-49AA-8BB5-7DF1918F67FF&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-B4CAA6EE-47C0-4C51-AB0F-7A347AA88CF9&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-C3C15BE2-2D50-4178-AD36-D6BAC5C47526&quot;</span> <span class="attr">name</span>=<span class="string">&quot;总经理审批&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;wz&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-9821E7E5-DB4A-4BE5-95C7-2721E98D6BD6&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-B4CAA6EE-47C0-4C51-AB0F-7A347AA88CF9&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-C3C15BE2-2D50-4178-AD36-D6BAC5C47526&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">&quot;sid-BF42EC91-584D-4C19-8EC0-9658CD948CDE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">endEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-6F5E54EF-5767-4E22-8AC7-322C7E332B6B&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-C3C15BE2-2D50-4178-AD36-D6BAC5C47526&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-BF42EC91-584D-4C19-8EC0-9658CD948CDE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">&quot;BPMNDiagram_holiday-group&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;holiday-group&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNPlane_holiday-group&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_startEvent1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;163.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-B4CAA6EE-47C0-4C51-AB0F-7A347AA88CF9&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-B4CAA6EE-47C0-4C51-AB0F-7A347AA88CF9&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;165.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;135.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-C3C15BE2-2D50-4178-AD36-D6BAC5C47526&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-C3C15BE2-2D50-4178-AD36-D6BAC5C47526&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;330.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;135.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-BF42EC91-584D-4C19-8EC0-9658CD948CDE&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-BF42EC91-584D-4C19-8EC0-9658CD948CDE&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;510.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;164.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-9821E7E5-DB4A-4BE5-95C7-2721E98D6BD6&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-9821E7E5-DB4A-4BE5-95C7-2721E98D6BD6&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;264.94999999998356&quot;</span> <span class="attr">y</span>=<span class="string">&quot;175.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;330.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;175.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-FAA16FF3-BFC5-49AA-8BB5-7DF1918F67FF&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-FAA16FF3-BFC5-49AA-8BB5-7DF1918F67FF&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;129.94340692927761&quot;</span> <span class="attr">y</span>=<span class="string">&quot;177.55019845363262&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;164.99999999999906&quot;</span> <span class="attr">y</span>=<span class="string">&quot;176.4985&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-6F5E54EF-5767-4E22-8AC7-322C7E332B6B&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-6F5E54EF-5767-4E22-8AC7-322C7E332B6B&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;14.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;14.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;429.9499999999989&quot;</span> <span class="attr">y</span>=<span class="string">&quot;176.04062499999998&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;510.0021426561354&quot;</span> <span class="attr">y</span>=<span class="string">&quot;177.70839534661596&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>部署并启动流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deploy</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine processEngine= ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> processEngine.getRepositoryService();</span><br><span class="line">    <span class="type">Deployment</span> <span class="variable">deploy</span> <span class="operator">=</span> repositoryService.createDeployment().name(<span class="string">&quot;ly画的请假流程-候选人&quot;</span>)</span><br><span class="line">            .addClasspathResource(<span class="string">&quot;请求流程-候选人组.bpmn20.xml&quot;</span>)</span><br><span class="line">            .deploy();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runProcess</span><span class="params">()</span>&#123;</span><br><span class="line">  </span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="comment">//实际开发，应该按下面代码让用户选</span></span><br><span class="line">    <span class="type">IdentityService</span> <span class="variable">identityService</span> <span class="operator">=</span> engine.getIdentityService();</span><br><span class="line">    List&lt;Group&gt; list = identityService.createGroupQuery().list();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//获取流程运行服务</span></span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> engine.getRuntimeService();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//设置候选人</span></span><br><span class="line">    Map&lt;String,Object&gt; variables=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    variables.put(<span class="string">&quot;g1&quot;</span>,<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">    <span class="comment">//运行流程</span></span><br><span class="line">    <span class="type">ProcessInstance</span> <span class="variable">processInstance</span> <span class="operator">=</span> runtimeService.</span><br><span class="line">            startProcessInstanceById(</span><br><span class="line">            <span class="string">&quot;holiday-group:1:25004&quot;</span>,variables);</span><br><span class="line">    System.out.println(<span class="string">&quot;processInstance--&quot;</span>+processInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>表 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515153509046.png"
alt="image-20220515153509046" /> variables <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515153549630.png"
alt="image-20220515153549630" /></p></li>
<li><p>查找当前用户所在组的任务，并拾取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询候选组任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryCandidateGroup</span><span class="params">()</span>&#123;</span><br><span class="line">    String userId=<span class="string">&quot;灯标&quot;</span>;</span><br><span class="line">    ProcessEngine processEngine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">IdentityService</span> <span class="variable">identityService</span> <span class="operator">=</span> processEngine.getIdentityService();</span><br><span class="line">    <span class="type">Group</span> <span class="variable">group</span> <span class="operator">=</span> identityService.createGroupQuery().</span><br><span class="line">            groupMember(userId)</span><br><span class="line">            .singleResult();</span><br><span class="line">    System.out.println(<span class="string">&quot;灯标组id&quot;</span>+group.getId());</span><br><span class="line">  </span><br><span class="line">    TaskService taskService=processEngine.getTaskService();</span><br><span class="line">    List&lt;Task&gt; tasks = taskService.createTaskQuery()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;27501&quot;</span>)</span><br><span class="line">            .taskCandidateGroup(group.getId())</span><br><span class="line">            .list();</span><br><span class="line">    <span class="keyword">for</span>(Task task:tasks)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id--&quot;</span>+task.getId()+<span class="string">&quot;--&quot;</span>+task.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;27501&quot;</span>)</span><br><span class="line">            .taskCandidateGroup(group.getId())</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="keyword">if</span>(task!=<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拾取任务--&quot;</span>+task.getId()</span><br><span class="line">        +<span class="string">&quot;任务名--&quot;</span>+task.getName());</span><br><span class="line">        taskService.claim(task.getId(),userId);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据库数据 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515154857421.png"
alt="image-20220515154857421" /></li>
</ul></li>
<li><p>完成任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> engine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .processInstanceId(<span class="string">&quot;27501&quot;</span>)</span><br><span class="line">            .taskAssignee(<span class="string">&quot;灯标&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    <span class="keyword">if</span>(task!=<span class="literal">null</span>)&#123;</span><br><span class="line">        taskService.complete(task.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;完成任务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="section"></h2>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>flowable_波哥_b站</tag>
      </tags>
  </entry>
  <entry>
    <title>boge-02-flowable进阶_5</title>
    <url>/2022/05/15/study/flowable/boge_blbl/02-advance_5/</url>
    <content><![CDATA[<h2 id="网关">网关</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515155359395.png"
alt="image-20220515155359395" />
<figcaption aria-hidden="true">image-20220515155359395</figcaption>
</figure>
<h3 id="排他网关">排他网关</h3>
<p>会按照所有出口顺序流定义的顺序对它们进行计算，选择第一个条件计算为true的顺序流（<strong>当没有设置条件时，认为顺序流为true</strong>）继续流程</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515155535107.png"
alt="image-20220515155535107" />
<figcaption aria-hidden="true">image-20220515155535107</figcaption>
</figure>
<ul>
<li><p>排他网关的绘制 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515161442209.png"
alt="image-20220515161442209" /> xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">xmlns:flowable</span>=<span class="string">&quot;http://flowable.org/bpmn&quot;</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> <span class="attr">xmlns:omgdc</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span> <span class="attr">xmlns:omgdi</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span> <span class="attr">typeLanguage</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">expressionLanguage</span>=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span> <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span> <span class="attr">exporter</span>=<span class="string">&quot;Flowable Open Source Modeler&quot;</span> <span class="attr">exporterVersion</span>=<span class="string">&quot;6.7.2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">&quot;holiday-exclusive&quot;</span> <span class="attr">name</span>=<span class="string">&quot;请假流程-排他网关&quot;</span> <span class="attr">isExecutable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-3D5ED4D4-97F5-4FFD-B160-F00566ECC55E&quot;</span> <span class="attr">name</span>=<span class="string">&quot;创建请假单&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;zhangsan&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-33A73370-751D-413F-9306-39DEAA674DB6&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-3D5ED4D4-97F5-4FFD-B160-F00566ECC55E&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusiveGateway</span> <span class="attr">id</span>=<span class="string">&quot;sid-5B2117E6-D341-49F2-85B2-336CA836C7D8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">exclusiveGateway</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-D1B1F6E0-EA7F-4FF7-AD0C-5D43DBCEBFD2&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-3D5ED4D4-97F5-4FFD-B160-F00566ECC55E&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-5B2117E6-D341-49F2-85B2-336CA836C7D8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-08A6CB64-C9BB-4342-852D-444A75315BDE&quot;</span> <span class="attr">name</span>=<span class="string">&quot;总经理审批&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;wangwu&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-EA98D0C3-E41D-4DEB-8933-91A1B7301ABE&quot;</span> <span class="attr">name</span>=<span class="string">&quot;部门经理审批&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;lisi&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-24F73F7F-EB61-484F-A494-686E194D0118&quot;</span> <span class="attr">name</span>=<span class="string">&quot;人事审批&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;zhaoliu&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-8BA0B88C-BA4F-446D-B5E7-6BF0830B1DC8&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-EA98D0C3-E41D-4DEB-8933-91A1B7301ABE&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-24F73F7F-EB61-484F-A494-686E194D0118&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-E748F81F-B0B2-4C34-B993-FBAA2BCD0995&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-08A6CB64-C9BB-4342-852D-444A75315BDE&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-24F73F7F-EB61-484F-A494-686E194D0118&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-928C6C6F-57F1-40F2-BE0F-1A9FF3E6E9E4&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-5B2117E6-D341-49F2-85B2-336CA836C7D8&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-08A6CB64-C9BB-4342-852D-444A75315BDE&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span>&lt;![CDATA[$&#123;num&gt;3&#125;]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-4DB25720-11C8-401E-BB4C-83BB25510B2E&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-5B2117E6-D341-49F2-85B2-336CA836C7D8&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-EA98D0C3-E41D-4DEB-8933-91A1B7301ABE&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span>&lt;![CDATA[$&#123;num&lt;3&#125;]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">&quot;BPMNDiagram_holiday-exclusive&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;holiday-exclusive&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNPlane_holiday-exclusive&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_startEvent1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;163.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-3D5ED4D4-97F5-4FFD-B160-F00566ECC55E&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-3D5ED4D4-97F5-4FFD-B160-F00566ECC55E&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;150.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;135.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-5B2117E6-D341-49F2-85B2-336CA836C7D8&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-5B2117E6-D341-49F2-85B2-336CA836C7D8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;315.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;155.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-08A6CB64-C9BB-4342-852D-444A75315BDE&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-08A6CB64-C9BB-4342-852D-444A75315BDE&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;420.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;225.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-EA98D0C3-E41D-4DEB-8933-91A1B7301ABE&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-EA98D0C3-E41D-4DEB-8933-91A1B7301ABE&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;405.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;30.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-24F73F7F-EB61-484F-A494-686E194D0118&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-24F73F7F-EB61-484F-A494-686E194D0118&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;630.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;225.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-8BA0B88C-BA4F-446D-B5E7-6BF0830B1DC8&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-8BA0B88C-BA4F-446D-B5E7-6BF0830B1DC8&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;504.95000000000005&quot;</span> <span class="attr">y</span>=<span class="string">&quot;70.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;680.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;70.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;680.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;225.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-4DB25720-11C8-401E-BB4C-83BB25510B2E&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-4DB25720-11C8-401E-BB4C-83BB25510B2E&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;335.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;155.5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;335.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;70.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;404.99999999996083&quot;</span> <span class="attr">y</span>=<span class="string">&quot;70.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-33A73370-751D-413F-9306-39DEAA674DB6&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-33A73370-751D-413F-9306-39DEAA674DB6&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;59.94725673598754&quot;</span> <span class="attr">y</span>=<span class="string">&quot;177.70973069236373&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;150.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;175.96677419354836&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-D1B1F6E0-EA7F-4FF7-AD0C-5D43DBCEBFD2&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-D1B1F6E0-EA7F-4FF7-AD0C-5D43DBCEBFD2&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;20.5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;249.95000000000002&quot;</span> <span class="attr">y</span>=<span class="string">&quot;175.18431734317343&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;315.42592592592536&quot;</span> <span class="attr">y</span>=<span class="string">&quot;175.42592592592592&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-E748F81F-B0B2-4C34-B993-FBAA2BCD0995&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-E748F81F-B0B2-4C34-B993-FBAA2BCD0995&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;519.95&quot;</span> <span class="attr">y</span>=<span class="string">&quot;265.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;629.9999999998776&quot;</span> <span class="attr">y</span>=<span class="string">&quot;265.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-928C6C6F-57F1-40F2-BE0F-1A9FF3E6E9E4&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-928C6C6F-57F1-40F2-BE0F-1A9FF3E6E9E4&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;335.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;194.43942522321433&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;335.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;265.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;420.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;265.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>部署</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deploy</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine= ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> engine.getRepositoryService();</span><br><span class="line">    <span class="type">Deployment</span> <span class="variable">deploy</span> <span class="operator">=</span> repositoryService.createDeployment()</span><br><span class="line">            .addClasspathResource(<span class="string">&quot;请假流程-排他网关.bpmn20.xml&quot;</span>)</span><br><span class="line">            .deploy();</span><br><span class="line">    System.out.println(<span class="string">&quot;部署成功:&quot;</span>+deploy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">engine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> engine.getRuntimeService();</span><br><span class="line">    Map&lt;String, Object&gt; variables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    variables.put(<span class="string">&quot;num&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    runtimeService.startProcessInstanceById</span><br><span class="line">            (<span class="string">&quot;holiday-exclusive:1:4&quot;</span>, variables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>数据库 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515161800379.png"
alt="image-20220515161800379" /></li>
</ul></li>
<li><p>张三完成任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> engine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .taskAssignee(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    taskService.complete(task.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//接下来会走到部门经理审批</p></li>
<li><p>此时再ran一个num为4的实例，然后张三完成，此时会走到总经理审批</p>
<ul>
<li><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515162344557.png"
title="fig:" alt="image-20220515162344557" /></li>
</ul></li>
<li><p>注意，如果这里num设置为3，则会报错 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515162412014.png"
alt="image-20220515162412014" /></p></li>
<li><p>两者区别 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515162512860.png"
alt="image-20220515162512860" />
如果上面的分支都不满足条件，那么会直接异常结束
//如果使用排他网关，如果条件都不满足，流程和任务都还在，只是代码抛异常
//如果两个都满足，那么会找出先定义的线走</p></li>
</ul>
<h3 id="并行网关">并行网关</h3>
<ul>
<li><p>绘制流程图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515163112903.png"
alt="image-20220515163112903" /></p></li>
<li><p>xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">xmlns:flowable</span>=<span class="string">&quot;http://flowable.org/bpmn&quot;</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> <span class="attr">xmlns:omgdc</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span> <span class="attr">xmlns:omgdi</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span> <span class="attr">typeLanguage</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">expressionLanguage</span>=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span> <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span> <span class="attr">exporter</span>=<span class="string">&quot;Flowable Open Source Modeler&quot;</span> <span class="attr">exporterVersion</span>=<span class="string">&quot;6.7.2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">&quot;holiday-parr-key&quot;</span> <span class="attr">name</span>=<span class="string">&quot;请假流程-并行网关&quot;</span> <span class="attr">isExecutable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">documentation</span>&gt;</span>holiday-parr-descr<span class="tag">&lt;/<span class="name">documentation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-47EAD72A-932E-4850-9218-08A7335CEEDD&quot;</span> <span class="attr">name</span>=<span class="string">&quot;创建请假单&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;zhangsan&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-8B72154F-6D29-47F8-A81C-A070F82B95F9&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-47EAD72A-932E-4850-9218-08A7335CEEDD&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parallelGateway</span> <span class="attr">id</span>=<span class="string">&quot;sid-8B323A3D-F6DA-4D38-9CAE-D4CDA1031343&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">parallelGateway</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-5F0BF3BD-BC7C-4AA0-AF87-F679C8EEB40B&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-47EAD72A-932E-4850-9218-08A7335CEEDD&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-8B323A3D-F6DA-4D38-9CAE-D4CDA1031343&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-AEFBD42F-2A10-4630-8E56-EDBD35CC95B1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;技术经理&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;lisi&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-49DBB929-7488-471A-B79C-6BBFF4C810E0&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-8B323A3D-F6DA-4D38-9CAE-D4CDA1031343&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-AEFBD42F-2A10-4630-8E56-EDBD35CC95B1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-8FB84D20-C946-4988-B4C4-16FFD899AF63&quot;</span> <span class="attr">name</span>=<span class="string">&quot;项目经理&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;wangwu&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-DCF940BC-05D4-4260-8C50-A4C6E291DEA3&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-8B323A3D-F6DA-4D38-9CAE-D4CDA1031343&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-8FB84D20-C946-4988-B4C4-16FFD899AF63&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parallelGateway</span> <span class="attr">id</span>=<span class="string">&quot;sid-B25B9926-873F-46F5-9D62-D155462C1665&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">parallelGateway</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-18DF81F2-2B7F-4CC7-AD70-8A878FC7B125&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-AEFBD42F-2A10-4630-8E56-EDBD35CC95B1&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-B25B9926-873F-46F5-9D62-D155462C1665&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-B00C2DDD-8A30-4BA0-A2F8-69185D8506F5&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-8FB84D20-C946-4988-B4C4-16FFD899AF63&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-B25B9926-873F-46F5-9D62-D155462C1665&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-143837B7-0687-4268-B381-BA2442E39097&quot;</span> <span class="attr">name</span>=<span class="string">&quot;总经理&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;zjl&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">&quot;sid-5ACFE3BE-E094-43A9-85C5-7D438EFE5A97&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">endEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-4255A9F7-39A1-46D3-AF14-DBEFF17AE911&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-143837B7-0687-4268-B381-BA2442E39097&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-5ACFE3BE-E094-43A9-85C5-7D438EFE5A97&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-2F49B59A-6860-4101-8156-84780094E6FE&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-B25B9926-873F-46F5-9D62-D155462C1665&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-5ACFE3BE-E094-43A9-85C5-7D438EFE5A97&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span>&lt;![CDATA[$&#123;num &lt;= 3&#125;]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-A5253FCB-3D23-483F-A511-197811F656D6&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-B25B9926-873F-46F5-9D62-D155462C1665&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-143837B7-0687-4268-B381-BA2442E39097&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span>&lt;![CDATA[$&#123;num &gt; 3&#125;]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">&quot;BPMNDiagram_holiday-parr-key&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;holiday-parr-key&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNPlane_holiday-parr-key&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_startEvent1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;163.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-47EAD72A-932E-4850-9218-08A7335CEEDD&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-47EAD72A-932E-4850-9218-08A7335CEEDD&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;175.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;138.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-8B323A3D-F6DA-4D38-9CAE-D4CDA1031343&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-8B323A3D-F6DA-4D38-9CAE-D4CDA1031343&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;387.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;143.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-AEFBD42F-2A10-4630-8E56-EDBD35CC95B1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-AEFBD42F-2A10-4630-8E56-EDBD35CC95B1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;495.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;45.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-8FB84D20-C946-4988-B4C4-16FFD899AF63&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-8FB84D20-C946-4988-B4C4-16FFD899AF63&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;495.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;225.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-B25B9926-873F-46F5-9D62-D155462C1665&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-B25B9926-873F-46F5-9D62-D155462C1665&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;695.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;143.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-143837B7-0687-4268-B381-BA2442E39097&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-143837B7-0687-4268-B381-BA2442E39097&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;795.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;60.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-5ACFE3BE-E094-43A9-85C5-7D438EFE5A97&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-5ACFE3BE-E094-43A9-85C5-7D438EFE5A97&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;840.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;225.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-4255A9F7-39A1-46D3-AF14-DBEFF17AE911&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-4255A9F7-39A1-46D3-AF14-DBEFF17AE911&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;14.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;14.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;847.586690647482&quot;</span> <span class="attr">y</span>=<span class="string">&quot;139.95&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;853.095383523332&quot;</span> <span class="attr">y</span>=<span class="string">&quot;225.02614923910227&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-8B72154F-6D29-47F8-A81C-A070F82B95F9&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-8B72154F-6D29-47F8-A81C-A070F82B95F9&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;129.9499984899576&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;174.9999999999917&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-49DBB929-7488-471A-B79C-6BBFF4C810E0&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-49DBB929-7488-471A-B79C-6BBFF4C810E0&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;404.70744680851067&quot;</span> <span class="attr">y</span>=<span class="string">&quot;145.2843450479233&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;395.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;82.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;494.9999999999998&quot;</span> <span class="attr">y</span>=<span class="string">&quot;84.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-2F49B59A-6860-4101-8156-84780094E6FE&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-2F49B59A-6860-4101-8156-84780094E6FE&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;14.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;14.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;715.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;182.43746693121696&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;715.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;239.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;840.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;239.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-DCF940BC-05D4-4260-8C50-A4C6E291DEA3&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-DCF940BC-05D4-4260-8C50-A4C6E291DEA3&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;407.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;182.44067421259845&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;407.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;265.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;494.9999999999674&quot;</span> <span class="attr">y</span>=<span class="string">&quot;265.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-A5253FCB-3D23-483F-A511-197811F656D6&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-A5253FCB-3D23-483F-A511-197811F656D6&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;715.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;143.5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;715.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;90.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;795.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;96.13899613899613&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-5F0BF3BD-BC7C-4AA0-AF87-F679C8EEB40B&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-5F0BF3BD-BC7C-4AA0-AF87-F679C8EEB40B&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;20.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;20.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;274.9499999999998&quot;</span> <span class="attr">y</span>=<span class="string">&quot;173.87912087912088&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;388.52284263959393&quot;</span> <span class="attr">y</span>=<span class="string">&quot;164.5190355329949&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-18DF81F2-2B7F-4CC7-AD70-8A878FC7B125&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-18DF81F2-2B7F-4CC7-AD70-8A878FC7B125&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;20.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;20.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;594.95&quot;</span> <span class="attr">y</span>=<span class="string">&quot;107.91823529411766&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;701.273276904474&quot;</span> <span class="attr">y</span>=<span class="string">&quot;156.70967741935485&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-B00C2DDD-8A30-4BA0-A2F8-69185D8506F5&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-B00C2DDD-8A30-4BA0-A2F8-69185D8506F5&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;20.5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;594.95&quot;</span> <span class="attr">y</span>=<span class="string">&quot;235.23460410557183&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;702.9632352941177&quot;</span> <span class="attr">y</span>=<span class="string">&quot;170.94457720588235&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>并行网关的条件会被忽略 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515163308541.png"
alt="image-20220515163308541" /></p></li>
<li><p>代码测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//部署并运行</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deploy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ProcessEngine</span> <span class="variable">engine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">        <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> engine.getRepositoryService();</span><br><span class="line">        <span class="type">Deployment</span> <span class="variable">deploy</span> <span class="operator">=</span> repositoryService.createDeployment()</span><br><span class="line">                .addClasspathResource(<span class="string">&quot;请假流程-并行网关.bpmn20.xml&quot;</span>)</span><br><span class="line">                .deploy();</span><br><span class="line">        System.out.println(<span class="string">&quot;部署成功:&quot;</span> + deploy.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ProcessEngine</span> <span class="variable">engine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">        <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> engine.getRuntimeService();</span><br><span class="line">        Map&lt;String, Object&gt; variables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        variables.put(<span class="string">&quot;num&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        runtimeService.startProcessInstanceById</span><br><span class="line">                (<span class="string">&quot;holiday-parr-key:1:12504&quot;</span>, variables);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>此时任务停留在zhangsan <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515163545652.png"
alt="image-20220515163545652" /></p></li>
<li><p>让zhangsan完成任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> engine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .taskAssignee(<span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">            .processInstanceId(<span class="string">&quot;15001&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    taskService.complete(task.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查看表数据(一个任务包含多个执行实例) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515163747247.png"
alt="image-20220515163747247" /></p></li>
<li><p>让王五和李四进行审批
查看数据库，wangwu审批后，act_ru_task就少了一条记录 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515164011925.png"
alt="image-20220515164011925" /></p></li>
<li><p>此时走到总经理节点 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515164102982.png"
alt="image-20220515164102982" /></p></li>
<li><p>图解 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515164127110.png"
alt="image-20220515164127110" /></p></li>
</ul>
<h3 id="包容网关">包容网关</h3>
<ul>
<li><p>包容网关可以选择多于一条顺序流。即固定几条必走，其他几条走条件</p></li>
<li><p>流程图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515164830895.png"
alt="image-20220515164830895" /> xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">xmlns:flowable</span>=<span class="string">&quot;http://flowable.org/bpmn&quot;</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> <span class="attr">xmlns:omgdc</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span> <span class="attr">xmlns:omgdi</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span> <span class="attr">typeLanguage</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">expressionLanguage</span>=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span> <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span> <span class="attr">exporter</span>=<span class="string">&quot;Flowable Open Source Modeler&quot;</span> <span class="attr">exporterVersion</span>=<span class="string">&quot;6.7.2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">&quot;holiday-inclusive&quot;</span> <span class="attr">name</span>=<span class="string">&quot;holiday-inclusive-name&quot;</span> <span class="attr">isExecutable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">documentation</span>&gt;</span>holiday-inclusive-desc<span class="tag">&lt;/<span class="name">documentation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-6C2C29AA-C1D2-4B09-A542-ED194A13F5F2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;创建请假单&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;i0&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-CAD92170-984F-49E0-BB6D-589B11F7FB8B&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-6C2C29AA-C1D2-4B09-A542-ED194A13F5F2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inclusiveGateway</span> <span class="attr">id</span>=<span class="string">&quot;sid-46FAF12A-7430-4AFA-AABB-99B2D875C9CD&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">inclusiveGateway</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-CCD38C3B-C06F-4646-B979-F65C0CA26321&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-6C2C29AA-C1D2-4B09-A542-ED194A13F5F2&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-46FAF12A-7430-4AFA-AABB-99B2D875C9CD&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-9AD9C288-F114-4AC6-9366-A09A786B068E&quot;</span> <span class="attr">name</span>=<span class="string">&quot;项目经理&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;i1&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-764DC717-439D-425E-83FF-D81BD08A2562&quot;</span> <span class="attr">name</span>=<span class="string">&quot;人事&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;i2&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-B8DE143C-4636-4F2C-99C9-8949E23B0042&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-46FAF12A-7430-4AFA-AABB-99B2D875C9CD&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-764DC717-439D-425E-83FF-D81BD08A2562&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-AC8D2717-5BCD-4C5B-81BB-2FF66CFFC615&quot;</span> <span class="attr">name</span>=<span class="string">&quot;技术经理&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;i3&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inclusiveGateway</span> <span class="attr">id</span>=<span class="string">&quot;sid-6449A9C8-B7A3-44EE-BEDF-154AF323B1A8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">inclusiveGateway</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-A52331B4-3769-46D8-AAC1-C34214C729BD&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-9AD9C288-F114-4AC6-9366-A09A786B068E&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-6449A9C8-B7A3-44EE-BEDF-154AF323B1A8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-681E9C5D-AD4B-45DD-BF12-E2CD5304ADFB&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-764DC717-439D-425E-83FF-D81BD08A2562&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-6449A9C8-B7A3-44EE-BEDF-154AF323B1A8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-78E79754-E64A-4ADE-A9BB-F9B224D3A5A0&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-AC8D2717-5BCD-4C5B-81BB-2FF66CFFC615&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-6449A9C8-B7A3-44EE-BEDF-154AF323B1A8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusiveGateway</span> <span class="attr">id</span>=<span class="string">&quot;sid-65D4D76B-AD2B-4AE9-8E78-7B8C33BD9E55&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">exclusiveGateway</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-422FC4A8-B667-4271-9CB3-A1D2CFEFC5E1&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-6449A9C8-B7A3-44EE-BEDF-154AF323B1A8&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-65D4D76B-AD2B-4AE9-8E78-7B8C33BD9E55&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-4B834200-7995-453B-BC08-AF93C9F29FCF&quot;</span> <span class="attr">name</span>=<span class="string">&quot;总经理&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;wz&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modeler:initiator-can-complete</span> <span class="attr">xmlns:modeler</span>=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;</span>&lt;![CDATA[false]]&gt;<span class="tag">&lt;/<span class="name">modeler:initiator-can-complete</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">&quot;sid-7296D067-FF72-49F9-B416-2452640A0FBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">endEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-AD0571E9-839D-4F1F-89ED-05BE60F841FD&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-4B834200-7995-453B-BC08-AF93C9F29FCF&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-7296D067-FF72-49F9-B416-2452640A0FBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-E808AF78-E258-4997-B4FE-C393D8EBA3B9&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-46FAF12A-7430-4AFA-AABB-99B2D875C9CD&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-9AD9C288-F114-4AC6-9366-A09A786B068E&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span>&lt;![CDATA[$&#123;num&gt;3&#125;]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-E4AD02E7-A69A-4684-9A00-DE9B11711348&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-46FAF12A-7430-4AFA-AABB-99B2D875C9CD&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-AC8D2717-5BCD-4C5B-81BB-2FF66CFFC615&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span>&lt;![CDATA[$&#123;num &lt;= 3&#125;]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-A6760B6A-B74F-4D35-93C2-6653751F8873&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-65D4D76B-AD2B-4AE9-8E78-7B8C33BD9E55&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-4B834200-7995-453B-BC08-AF93C9F29FCF&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span>&lt;![CDATA[$&#123;num &gt; 3&#125;]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-97A0DAB9-564D-4A62-92A4-26C7056CD347&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-65D4D76B-AD2B-4AE9-8E78-7B8C33BD9E55&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-7296D067-FF72-49F9-B416-2452640A0FBC&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span>&lt;![CDATA[$&#123;num&lt;=3 &#125;]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">&quot;BPMNDiagram_holiday-inclusive&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;holiday-inclusive&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNPlane_holiday-inclusive&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_startEvent1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;163.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-6C2C29AA-C1D2-4B09-A542-ED194A13F5F2&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-6C2C29AA-C1D2-4B09-A542-ED194A13F5F2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;195.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;135.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-46FAF12A-7430-4AFA-AABB-99B2D875C9CD&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-46FAF12A-7430-4AFA-AABB-99B2D875C9CD&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;366.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;145.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-9AD9C288-F114-4AC6-9366-A09A786B068E&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-9AD9C288-F114-4AC6-9366-A09A786B068E&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;451.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;30.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-764DC717-439D-425E-83FF-D81BD08A2562&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-764DC717-439D-425E-83FF-D81BD08A2562&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;450.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;120.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-AC8D2717-5BCD-4C5B-81BB-2FF66CFFC615&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-AC8D2717-5BCD-4C5B-81BB-2FF66CFFC615&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;465.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;255.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-6449A9C8-B7A3-44EE-BEDF-154AF323B1A8&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-6449A9C8-B7A3-44EE-BEDF-154AF323B1A8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;656.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;137.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-65D4D76B-AD2B-4AE9-8E78-7B8C33BD9E55&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-65D4D76B-AD2B-4AE9-8E78-7B8C33BD9E55&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;750.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;137.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-4B834200-7995-453B-BC08-AF93C9F29FCF&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-4B834200-7995-453B-BC08-AF93C9F29FCF&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;855.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;60.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-7296D067-FF72-49F9-B416-2452640A0FBC&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-7296D067-FF72-49F9-B416-2452640A0FBC&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;900.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;240.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-681E9C5D-AD4B-45DD-BF12-E2CD5304ADFB&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-681E9C5D-AD4B-45DD-BF12-E2CD5304ADFB&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;20.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;20.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;549.9499999999988&quot;</span> <span class="attr">y</span>=<span class="string">&quot;159.14772727272728&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;656.3351955307262&quot;</span> <span class="attr">y</span>=<span class="string">&quot;157.33435754189946&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-CCD38C3B-C06F-4646-B979-F65C0CA26321&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-CCD38C3B-C06F-4646-B979-F65C0CA26321&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;20.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;20.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;294.94999999999993&quot;</span> <span class="attr">y</span>=<span class="string">&quot;171.45390070921985&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;367.32450331125824&quot;</span> <span class="attr">y</span>=<span class="string">&quot;166.32119205298014&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-AD0571E9-839D-4F1F-89ED-05BE60F841FD&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-AD0571E9-839D-4F1F-89ED-05BE60F841FD&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;14.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;14.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;907.3347402597402&quot;</span> <span class="attr">y</span>=<span class="string">&quot;139.95&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;913.1831773972388&quot;</span> <span class="attr">y</span>=<span class="string">&quot;240.02104379436742&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-A6760B6A-B74F-4D35-93C2-6653751F8873&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-A6760B6A-B74F-4D35-93C2-6653751F8873&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;22.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;7.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;775.8406515580737&quot;</span> <span class="attr">y</span>=<span class="string">&quot;142.87818696883852&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;855.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;116.58716981132078&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-B8DE143C-4636-4F2C-99C9-8949E23B0042&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-B8DE143C-4636-4F2C-99C9-8949E23B0042&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;405.4272235576724&quot;</span> <span class="attr">y</span>=<span class="string">&quot;165.5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;428.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;165.5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;428.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;160.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;449.99999999999346&quot;</span> <span class="attr">y</span>=<span class="string">&quot;160.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-422FC4A8-B667-4271-9CB3-A1D2CFEFC5E1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-422FC4A8-B667-4271-9CB3-A1D2CFEFC5E1&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;20.5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;695.4399309245483&quot;</span> <span class="attr">y</span>=<span class="string">&quot;157.5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;750.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;157.5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-97A0DAB9-564D-4A62-92A4-26C7056CD347&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-97A0DAB9-564D-4A62-92A4-26C7056CD347&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;14.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;14.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;770.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;176.44111163227018&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;770.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;264.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;900.033302364888&quot;</span> <span class="attr">y</span>=<span class="string">&quot;254.96981315483313&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-A52331B4-3769-46D8-AAC1-C34214C729BD&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-A52331B4-3769-46D8-AAC1-C34214C729BD&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;20.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;20.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;550.95&quot;</span> <span class="attr">y</span>=<span class="string">&quot;94.83228571428573&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;662.6257153758107&quot;</span> <span class="attr">y</span>=<span class="string">&quot;150.3587786259542&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-E808AF78-E258-4997-B4FE-C393D8EBA3B9&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-E808AF78-E258-4997-B4FE-C393D8EBA3B9&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;386.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;145.5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;386.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;70.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;451.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;70.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-CAD92170-984F-49E0-BB6D-589B11F7FB8B&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-CAD92170-984F-49E0-BB6D-589B11F7FB8B&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;129.94999191137833&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;162.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;162.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;175.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;194.99999999998522&quot;</span> <span class="attr">y</span>=<span class="string">&quot;175.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-E4AD02E7-A69A-4684-9A00-DE9B11711348&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-E4AD02E7-A69A-4684-9A00-DE9B11711348&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;386.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;184.4426890432099&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;386.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;295.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;465.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;295.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-78E79754-E64A-4ADE-A9BB-F9B224D3A5A0&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-78E79754-E64A-4ADE-A9BB-F9B224D3A5A0&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;20.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;20.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;561.6083333333333&quot;</span> <span class="attr">y</span>=<span class="string">&quot;255.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;665.2307692307692&quot;</span> <span class="attr">y</span>=<span class="string">&quot;166.20769230769233&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>部署并运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deploy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">engine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> engine.getRepositoryService();</span><br><span class="line">    <span class="type">Deployment</span> <span class="variable">deploy</span> <span class="operator">=</span> repositoryService.createDeployment()</span><br><span class="line">            .addClasspathResource(<span class="string">&quot;holiday-inclusive-name.bpmn20.xml&quot;</span>)</span><br><span class="line">            .deploy();</span><br><span class="line">    System.out.println(<span class="string">&quot;部署成功:&quot;</span> + deploy.getId());</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">engine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> engine.getRuntimeService();</span><br><span class="line">    Map&lt;String, Object&gt; variables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    variables.put(<span class="string">&quot;num&quot;</span>, <span class="number">4</span>);</span><br><span class="line">    runtimeService.startProcessInstanceById</span><br><span class="line">            (<span class="string">&quot;holiday-inclusive:1:4&quot;</span>, variables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>i0完成任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> engine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .taskAssignee(<span class="string">&quot;i0&quot;</span>)</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    taskService.complete(task.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>看数据，默认走人事和项目经理 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515165318571.png"
alt="image-20220515165318571" /></p></li>
<li><p>i1,i2所在任务执行完后，会发现走总经理 i1走完之后 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515165402581.png"
alt="image-20220515165402581" /></p>
<ul>
<li><p>i2走的时候，把num设为1，直接结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskComplete</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> engine.getTaskService();</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery()</span><br><span class="line">            .taskAssignee(<span class="string">&quot;i2&quot;</span>)</span><br><span class="line">            .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">            .singleResult();</span><br><span class="line">    taskService.setVariable(task.getId(),</span><br><span class="line">            <span class="string">&quot;num&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    taskService.complete(task.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li></li>
</ul>
<h3 id="事件网关">事件网关</h3>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515165548361.png"
alt="image-20220515165548361" />
<figcaption aria-hidden="true">image-20220515165548361</figcaption>
</figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>flowable_波哥_b站</tag>
      </tags>
  </entry>
  <entry>
    <title>boge-02-flowable进阶_6</title>
    <url>/2022/05/15/study/flowable/boge_blbl/02-advance_6/</url>
    <content><![CDATA[<h2 id="任务回退-串行回退">任务回退-串行回退</h2>
<ul>
<li><p>流程图绘制 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515170035810.png"
alt="image-20220515170035810" /></p></li>
<li><p>xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;definitions xmlns=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> xmlns:xsd=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> xmlns:flowable=<span class="string">&quot;http://flowable.org/bpmn&quot;</span> xmlns:bpmndi=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> xmlns:omgdc=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span> xmlns:omgdi=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span> typeLanguage=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> expressionLanguage=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span> targetNamespace=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span> exporter=<span class="string">&quot;Flowable Open Source Modeler&quot;</span> exporterVersion=<span class="string">&quot;6.7.2&quot;</span>&gt;</span><br><span class="line">  &lt;process id=<span class="string">&quot;reback-key&quot;</span> name=<span class="string">&quot;回退处理&quot;</span> isExecutable=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">    &lt;documentation&gt;reback-desc&lt;/documentation&gt;</span><br><span class="line">    &lt;startEvent id=<span class="string">&quot;startEvent1&quot;</span> flowable:formFieldValidation=<span class="string">&quot;true&quot;</span>&gt;&lt;/startEvent&gt;</span><br><span class="line">    &lt;userTask id=<span class="string">&quot;sid-D380E41A-48EE-4C08-AD01-1D509C512543&quot;</span> name=<span class="string">&quot;用户1&quot;</span> flowable:assignee=<span class="string">&quot;user1&quot;</span> flowable:formFieldValidation=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">      &lt;extensionElements&gt;</span><br><span class="line">        &lt;modeler:initiator-can-complete xmlns:modeler=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;&lt;![CDATA[<span class="literal">false</span>]]&gt;&lt;/modeler:initiator-can-complete&gt;</span><br><span class="line">      &lt;/extensionElements&gt;</span><br><span class="line">    &lt;/userTask&gt;</span><br><span class="line">    &lt;sequenceFlow id=<span class="string">&quot;sid-E2423FC5-F954-43D3-B57C-8460057CB7D6&quot;</span> sourceRef=<span class="string">&quot;startEvent1&quot;</span> targetRef=<span class="string">&quot;sid-D380E41A-48EE-4C08-AD01-1D509C512543&quot;</span>&gt;&lt;/sequenceFlow&gt;</span><br><span class="line">    &lt;userTask id=<span class="string">&quot;sid-AF50E3D0-2014-4308-A717-D76586837D70&quot;</span> name=<span class="string">&quot;用户2&quot;</span> flowable:assignee=<span class="string">&quot;user2&quot;</span> flowable:formFieldValidation=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">      &lt;extensionElements&gt;</span><br><span class="line">        &lt;modeler:initiator-can-complete xmlns:modeler=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;&lt;![CDATA[<span class="literal">false</span>]]&gt;&lt;/modeler:initiator-can-complete&gt;</span><br><span class="line">      &lt;/extensionElements&gt;</span><br><span class="line">    &lt;/userTask&gt;</span><br><span class="line">    &lt;sequenceFlow id=<span class="string">&quot;sid-7C8750DC-E1C1-4AB2-B18C-2C103B61A5E5&quot;</span> sourceRef=<span class="string">&quot;sid-D380E41A-48EE-4C08-AD01-1D509C512543&quot;</span> targetRef=<span class="string">&quot;sid-AF50E3D0-2014-4308-A717-D76586837D70&quot;</span>&gt;&lt;/sequenceFlow&gt;</span><br><span class="line">    &lt;userTask id=<span class="string">&quot;sid-F4CE7565-5977-4B9C-A603-AB3B817B8C8C&quot;</span> name=<span class="string">&quot;用户3&quot;</span> flowable:assignee=<span class="string">&quot;user3&quot;</span> flowable:formFieldValidation=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">      &lt;extensionElements&gt;</span><br><span class="line">        &lt;modeler:initiator-can-complete xmlns:modeler=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;&lt;![CDATA[<span class="literal">false</span>]]&gt;&lt;/modeler:initiator-can-complete&gt;</span><br><span class="line">      &lt;/extensionElements&gt;</span><br><span class="line">    &lt;/userTask&gt;</span><br><span class="line">    &lt;sequenceFlow id=<span class="string">&quot;sid-F91582FE-D110-48C9-9407-605E503E42B2&quot;</span> sourceRef=<span class="string">&quot;sid-AF50E3D0-2014-4308-A717-D76586837D70&quot;</span> targetRef=<span class="string">&quot;sid-F4CE7565-5977-4B9C-A603-AB3B817B8C8C&quot;</span>&gt;&lt;/sequenceFlow&gt;</span><br><span class="line">    &lt;userTask id=<span class="string">&quot;sid-727C1235-F9C1-4CC5-BC6C-E56ABCA105B0&quot;</span> name=<span class="string">&quot;用户4&quot;</span> flowable:assignee=<span class="string">&quot;user4&quot;</span> flowable:formFieldValidation=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line">      &lt;extensionElements&gt;</span><br><span class="line">        &lt;modeler:initiator-can-complete xmlns:modeler=<span class="string">&quot;http://flowable.org/modeler&quot;</span>&gt;&lt;![CDATA[<span class="literal">false</span>]]&gt;&lt;/modeler:initiator-can-complete&gt;</span><br><span class="line">      &lt;/extensionElements&gt;</span><br><span class="line">    &lt;/userTask&gt;</span><br><span class="line">    &lt;sequenceFlow id=<span class="string">&quot;sid-6D998C20-2A97-44B5-92D0-118E5CB05795&quot;</span> sourceRef=<span class="string">&quot;sid-F4CE7565-5977-4B9C-A603-AB3B817B8C8C&quot;</span> targetRef=<span class="string">&quot;sid-727C1235-F9C1-4CC5-BC6C-E56ABCA105B0&quot;</span>&gt;&lt;/sequenceFlow&gt;</span><br><span class="line">    &lt;endEvent id=<span class="string">&quot;sid-6E5F5037-1979-4150-8408-D0BFD0315BCA&quot;</span>&gt;&lt;/endEvent&gt;</span><br><span class="line">    &lt;sequenceFlow id=<span class="string">&quot;sid-3ECF3E34-6C07-4AE6-997B-583BF8868AC8&quot;</span> sourceRef=<span class="string">&quot;sid-727C1235-F9C1-4CC5-BC6C-E56ABCA105B0&quot;</span> targetRef=<span class="string">&quot;sid-6E5F5037-1979-4150-8408-D0BFD0315BCA&quot;</span>&gt;&lt;/sequenceFlow&gt;</span><br><span class="line">  &lt;/process&gt;</span><br><span class="line">  &lt;bpmndi:BPMNDiagram id=<span class="string">&quot;BPMNDiagram_reback-key&quot;</span>&gt;</span><br><span class="line">    &lt;bpmndi:BPMNPlane bpmnElement=<span class="string">&quot;reback-key&quot;</span> id=<span class="string">&quot;BPMNPlane_reback-key&quot;</span>&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;startEvent1&quot;</span> id=<span class="string">&quot;BPMNShape_startEvent1&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;30.0&quot;</span> width=<span class="string">&quot;30.0&quot;</span> x=<span class="string">&quot;100.0&quot;</span> y=<span class="string">&quot;163.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;sid-D380E41A-48EE-4C08-AD01-1D509C512543&quot;</span> id=<span class="string">&quot;BPMNShape_sid-D380E41A-48EE-4C08-AD01-1D509C512543&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;80.0&quot;</span> width=<span class="string">&quot;100.0&quot;</span> x=<span class="string">&quot;165.0&quot;</span> y=<span class="string">&quot;135.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;sid-AF50E3D0-2014-4308-A717-D76586837D70&quot;</span> id=<span class="string">&quot;BPMNShape_sid-AF50E3D0-2014-4308-A717-D76586837D70&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;80.0&quot;</span> width=<span class="string">&quot;100.0&quot;</span> x=<span class="string">&quot;320.0&quot;</span> y=<span class="string">&quot;138.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;sid-F4CE7565-5977-4B9C-A603-AB3B817B8C8C&quot;</span> id=<span class="string">&quot;BPMNShape_sid-F4CE7565-5977-4B9C-A603-AB3B817B8C8C&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;80.0&quot;</span> width=<span class="string">&quot;100.0&quot;</span> x=<span class="string">&quot;465.0&quot;</span> y=<span class="string">&quot;138.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;sid-727C1235-F9C1-4CC5-BC6C-E56ABCA105B0&quot;</span> id=<span class="string">&quot;BPMNShape_sid-727C1235-F9C1-4CC5-BC6C-E56ABCA105B0&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;80.0&quot;</span> width=<span class="string">&quot;100.0&quot;</span> x=<span class="string">&quot;610.0&quot;</span> y=<span class="string">&quot;138.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=<span class="string">&quot;sid-6E5F5037-1979-4150-8408-D0BFD0315BCA&quot;</span> id=<span class="string">&quot;BPMNShape_sid-6E5F5037-1979-4150-8408-D0BFD0315BCA&quot;</span>&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=<span class="string">&quot;28.0&quot;</span> width=<span class="string">&quot;28.0&quot;</span> x=<span class="string">&quot;755.0&quot;</span> y=<span class="string">&quot;164.0&quot;</span>&gt;&lt;/omgdc:Bounds&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=<span class="string">&quot;sid-6D998C20-2A97-44B5-92D0-118E5CB05795&quot;</span> id=<span class="string">&quot;BPMNEdge_sid-6D998C20-2A97-44B5-92D0-118E5CB05795&quot;</span> flowable:sourceDockerX=<span class="string">&quot;50.0&quot;</span> flowable:sourceDockerY=<span class="string">&quot;40.0&quot;</span> flowable:targetDockerX=<span class="string">&quot;50.0&quot;</span> flowable:targetDockerY=<span class="string">&quot;40.0&quot;</span>&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;564.9499999999907&quot;</span> y=<span class="string">&quot;178.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;609.9999999999807&quot;</span> y=<span class="string">&quot;178.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=<span class="string">&quot;sid-7C8750DC-E1C1-4AB2-B18C-2C103B61A5E5&quot;</span> id=<span class="string">&quot;BPMNEdge_sid-7C8750DC-E1C1-4AB2-B18C-2C103B61A5E5&quot;</span> flowable:sourceDockerX=<span class="string">&quot;50.0&quot;</span> flowable:sourceDockerY=<span class="string">&quot;40.0&quot;</span> flowable:targetDockerX=<span class="string">&quot;50.0&quot;</span> flowable:targetDockerY=<span class="string">&quot;40.0&quot;</span>&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;264.9499999999882&quot;</span> y=<span class="string">&quot;175.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;292.5&quot;</span> y=<span class="string">&quot;175.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;292.5&quot;</span> y=<span class="string">&quot;178.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;319.9999999999603&quot;</span> y=<span class="string">&quot;178.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=<span class="string">&quot;sid-3ECF3E34-6C07-4AE6-997B-583BF8868AC8&quot;</span> id=<span class="string">&quot;BPMNEdge_sid-3ECF3E34-6C07-4AE6-997B-583BF8868AC8&quot;</span> flowable:sourceDockerX=<span class="string">&quot;50.0&quot;</span> flowable:sourceDockerY=<span class="string">&quot;40.0&quot;</span> flowable:targetDockerX=<span class="string">&quot;14.0&quot;</span> flowable:targetDockerY=<span class="string">&quot;14.0&quot;</span>&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;709.9499999999999&quot;</span> y=<span class="string">&quot;178.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;755.0&quot;</span> y=<span class="string">&quot;178.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=<span class="string">&quot;sid-E2423FC5-F954-43D3-B57C-8460057CB7D6&quot;</span> id=<span class="string">&quot;BPMNEdge_sid-E2423FC5-F954-43D3-B57C-8460057CB7D6&quot;</span> flowable:sourceDockerX=<span class="string">&quot;15.0&quot;</span> flowable:sourceDockerY=<span class="string">&quot;15.0&quot;</span> flowable:targetDockerX=<span class="string">&quot;50.0&quot;</span> flowable:targetDockerY=<span class="string">&quot;40.0&quot;</span>&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;129.94340692927761&quot;</span> y=<span class="string">&quot;177.55019845363262&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;164.99999999999906&quot;</span> y=<span class="string">&quot;176.4985&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=<span class="string">&quot;sid-F91582FE-D110-48C9-9407-605E503E42B2&quot;</span> id=<span class="string">&quot;BPMNEdge_sid-F91582FE-D110-48C9-9407-605E503E42B2&quot;</span> flowable:sourceDockerX=<span class="string">&quot;50.0&quot;</span> flowable:sourceDockerY=<span class="string">&quot;40.0&quot;</span> flowable:targetDockerX=<span class="string">&quot;50.0&quot;</span> flowable:targetDockerY=<span class="string">&quot;40.0&quot;</span>&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;419.94999999999067&quot;</span> y=<span class="string">&quot;178.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=<span class="string">&quot;464.9999999999807&quot;</span> y=<span class="string">&quot;178.0&quot;</span>&gt;&lt;/omgdi:waypoint&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">    &lt;/bpmndi:BPMNPlane&gt;</span><br><span class="line">  &lt;/bpmndi:BPMNDiagram&gt;</span><br><span class="line">&lt;/definitions&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>部署并运行</p></li>
<li><p>依次完成1，2，3</p>
<ul>
<li><p>从任意节点跳转到任意节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backProcess</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">        <span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> engine.getRuntimeService();</span><br><span class="line">        <span class="comment">//从当前流程跳转到任意节点</span></span><br><span class="line">        runtimeService.createChangeActivityStateBuilder()</span><br><span class="line">                .processInstanceId(<span class="string">&quot;2501&quot;</span>)</span><br><span class="line">                <span class="comment">//4--&gt;3 ，活动id</span></span><br><span class="line">                .moveActivityIdTo(<span class="string">&quot;sid-727C1235-F9C1-4CC5-BC6C-E56ABCA105B0&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;sid-F4CE7565-5977-4B9C-A603-AB3B817B8C8C&quot;</span>)</span><br><span class="line">                .changeState();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可以在这个表里让用户选择回退节点 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515170856822.png"
alt="image-20220515170856822" /></p></li>
<li><p>此时让user3再完成任务</p></li>
<li><p>注：用下面的方法，不关心当前节点，只写明要跳转的结点即可 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515171133458.png"
alt="image-20220515171133458" /></p></li>
</ul></li>
</ul>
<h2 id="自定义表单">自定义表单</h2>
<h3 id="内置表单">内置表单</h3>
<ul>
<li><p>绘制 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515173247794.png"
alt="image-20220515173247794" /></p>
<ul>
<li><p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">xmlns:flowable</span>=<span class="string">&quot;http://flowable.org/bpmn&quot;</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> <span class="attr">xmlns:omgdc</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span> <span class="attr">xmlns:omgdi</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span> <span class="attr">typeLanguage</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">expressionLanguage</span>=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span> <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span> <span class="attr">exporter</span>=<span class="string">&quot;Flowable Open Source Modeler&quot;</span> <span class="attr">exporterVersion</span>=<span class="string">&quot;6.7.2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">&quot;form1-test-key&quot;</span> <span class="attr">name</span>=<span class="string">&quot;form1-test-name&quot;</span> <span class="attr">isExecutable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">documentation</span>&gt;</span>form1-test-desc<span class="tag">&lt;/<span class="name">documentation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flowable:formProperty</span> <span class="attr">id</span>=<span class="string">&quot;days&quot;</span> <span class="attr">name</span>=<span class="string">&quot;天数&quot;</span> <span class="attr">type</span>=<span class="string">&quot;long&quot;</span> <span class="attr">default</span>=<span class="string">&quot;5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">flowable:formProperty</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flowable:formProperty</span> <span class="attr">id</span>=<span class="string">&quot;start_time&quot;</span> <span class="attr">name</span>=<span class="string">&quot;开始时间&quot;</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">datePattern</span>=<span class="string">&quot;MM-dd-yyyy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">flowable:formProperty</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flowable:formProperty</span> <span class="attr">id</span>=<span class="string">&quot;reason&quot;</span> <span class="attr">name</span>=<span class="string">&quot;原因&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">flowable:formProperty</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-4C9C8571-1423-4137-93FC-6A138D504E24&quot;</span> <span class="attr">name</span>=<span class="string">&quot;用户申请&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flowable:formProperty</span> <span class="attr">id</span>=<span class="string">&quot;days&quot;</span> <span class="attr">name</span>=<span class="string">&quot;天数&quot;</span> <span class="attr">type</span>=<span class="string">&quot;long&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">flowable:formProperty</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flowable:formProperty</span> <span class="attr">id</span>=<span class="string">&quot;start_time&quot;</span> <span class="attr">name</span>=<span class="string">&quot;开始时间&quot;</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">datePattern</span>=<span class="string">&quot;MM-dd-yyyy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">flowable:formProperty</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flowable:formProperty</span> <span class="attr">id</span>=<span class="string">&quot;reason&quot;</span> <span class="attr">name</span>=<span class="string">&quot;原因&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">flowable:formProperty</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-8944FE04-D27B-435F-A8A8-4E545AB3D6C0&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-4C9C8571-1423-4137-93FC-6A138D504E24&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusiveGateway</span> <span class="attr">id</span>=<span class="string">&quot;sid-35DD948A-C095-486E-98E0-4A0EEC4D9FBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">exclusiveGateway</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-0EA36B83-6115-414F-BC7D-9CB338B03F22&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-4C9C8571-1423-4137-93FC-6A138D504E24&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-35DD948A-C095-486E-98E0-4A0EEC4D9FBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-4B6496FE-B5FE-41AC-83F8-4B7224B09FBD&quot;</span> <span class="attr">name</span>=<span class="string">&quot;总监审批&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-8DE5EA05-89D5-48B0-9359-F8ABFB3A3500&quot;</span> <span class="attr">name</span>=<span class="string">&quot;部门经理审批&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusiveGateway</span> <span class="attr">id</span>=<span class="string">&quot;sid-0EC09183-F41B-4785-83E7-423BB86EB013&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">exclusiveGateway</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-562C26B5-B634-4771-BF54-C311D56A5317&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-4B6496FE-B5FE-41AC-83F8-4B7224B09FBD&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-0EC09183-F41B-4785-83E7-423BB86EB013&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-9AC3E009-D4D6-4D8B-883C-701E044715E9&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-8DE5EA05-89D5-48B0-9359-F8ABFB3A3500&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-0EC09183-F41B-4785-83E7-423BB86EB013&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">&quot;sid-9CD52D35-7874-42F4-B392-466F71316BFE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">endEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-FABB64D1-0182-41D8-90FE-53FE7FE3F024&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-0EC09183-F41B-4785-83E7-423BB86EB013&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-9CD52D35-7874-42F4-B392-466F71316BFE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-E4DB6764-3EA3-427B-AD00-4D812E404FD6&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-35DD948A-C095-486E-98E0-4A0EEC4D9FBC&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-4B6496FE-B5FE-41AC-83F8-4B7224B09FBD&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span>&lt;![CDATA[$&#123;day &gt; 3&#125;]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-585C37CB-61FE-4518-B3B6-5722A90A854F&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-35DD948A-C095-486E-98E0-4A0EEC4D9FBC&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-8DE5EA05-89D5-48B0-9359-F8ABFB3A3500&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span>&lt;![CDATA[$&#123;day &lt;= 3&#125;]]&gt;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">&quot;BPMNDiagram_form1-test-key&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;form1-test-key&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNPlane_form1-test-key&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_startEvent1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;163.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-4C9C8571-1423-4137-93FC-6A138D504E24&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-4C9C8571-1423-4137-93FC-6A138D504E24&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;175.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;138.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-35DD948A-C095-486E-98E0-4A0EEC4D9FBC&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-35DD948A-C095-486E-98E0-4A0EEC4D9FBC&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;315.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;150.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-4B6496FE-B5FE-41AC-83F8-4B7224B09FBD&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-4B6496FE-B5FE-41AC-83F8-4B7224B09FBD&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;405.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;30.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-8DE5EA05-89D5-48B0-9359-F8ABFB3A3500&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-8DE5EA05-89D5-48B0-9359-F8ABFB3A3500&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;405.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;225.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-0EC09183-F41B-4785-83E7-423BB86EB013&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-0EC09183-F41B-4785-83E7-423BB86EB013&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;585.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;165.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-9CD52D35-7874-42F4-B392-466F71316BFE&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-9CD52D35-7874-42F4-B392-466F71316BFE&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;670.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;171.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-585C37CB-61FE-4518-B3B6-5722A90A854F&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-585C37CB-61FE-4518-B3B6-5722A90A854F&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;335.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;189.43998414376327&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;335.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;265.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;405.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;265.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-E4DB6764-3EA3-427B-AD00-4D812E404FD6&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-E4DB6764-3EA3-427B-AD00-4D812E404FD6&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;336.66824324324324&quot;</span> <span class="attr">y</span>=<span class="string">&quot;151.67117117117118&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;342.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;66.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;404.9999999999999&quot;</span> <span class="attr">y</span>=<span class="string">&quot;68.23008849557522&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-0EA36B83-6115-414F-BC7D-9CB338B03F22&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-0EA36B83-6115-414F-BC7D-9CB338B03F22&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;20.5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;274.95000000000005&quot;</span> <span class="attr">y</span>=<span class="string">&quot;174.60633484162895&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;316.77118644067775&quot;</span> <span class="attr">y</span>=<span class="string">&quot;171.76800847457628&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-8944FE04-D27B-435F-A8A8-4E545AB3D6C0&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-8944FE04-D27B-435F-A8A8-4E545AB3D6C0&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;129.9499984899576&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;174.9999999999917&quot;</span> <span class="attr">y</span>=<span class="string">&quot;178.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-FABB64D1-0182-41D8-90FE-53FE7FE3F024&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-FABB64D1-0182-41D8-90FE-53FE7FE3F024&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;14.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;14.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;624.5591869398207&quot;</span> <span class="attr">y</span>=<span class="string">&quot;185.37820512820514&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;670.0002755524882&quot;</span> <span class="attr">y</span>=<span class="string">&quot;185.08885188426405&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-9AC3E009-D4D6-4D8B-883C-701E044715E9&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-9AC3E009-D4D6-4D8B-883C-701E044715E9&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;20.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;20.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;504.95000000000005&quot;</span> <span class="attr">y</span>=<span class="string">&quot;238.33333333333334&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;591.9565217391304&quot;</span> <span class="attr">y</span>=<span class="string">&quot;191.93913043478258&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-562C26B5-B634-4771-BF54-C311D56A5317&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-562C26B5-B634-4771-BF54-C311D56A5317&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;20.5&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;20.5&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;504.95000000000005&quot;</span> <span class="attr">y</span>=<span class="string">&quot;70.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;605.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;70.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;605.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;165.5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>将流程定义部署</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">@Test</span><br><span class="line">public void deploy() &#123;</span><br><span class="line">    ProcessEngine engine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    RepositoryService repositoryService = engine.getRepositoryService();</span><br><span class="line">    Deployment deploy = repositoryService.createDeployment()</span><br><span class="line">            .addClasspathResource(&quot;form1-test-name.bpmn20.xml&quot;)</span><br><span class="line">            .deploy();</span><br><span class="line">    System.out.println(&quot;部署成功:&quot; + deploy.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查看部署的流程内置的表单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getStartForm</span><span class="params">()</span>&#123;</span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">FormService</span> <span class="variable">formService</span> <span class="operator">=</span> engine.getFormService();</span><br><span class="line">    <span class="type">StartFormData</span> <span class="variable">startFormData</span> <span class="operator">=</span> formService.getStartFormData(<span class="string">&quot;form1-test-key:1:17504&quot;</span>);</span><br><span class="line">    List&lt;FormProperty&gt; formProperties =</span><br><span class="line">            startFormData.getFormProperties();</span><br><span class="line">    <span class="keyword">for</span> (FormProperty property:formProperties)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id==&gt;&quot;</span>+property.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;name==&gt;&quot;</span>+property.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;value==&gt;&quot;</span>+property.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<ul>
<li><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515173832080.png"
title="fig:" alt="image-20220515173832080" /></li>
</ul></li>
<li><p>第一种启动方式，通过map <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515174011517.png"
alt="image-20220515174011517" /></p></li>
<li><p>第二种启动方式</p></li>
<li><p>```java <span class="citation" data-cites="Test">@Test</span>
public void startProcess2(){ ProcessEngine
engine=ProcessEngines.getDefaultProcessEngine(); FormService formService
= engine.getFormService(); Map&lt;String,String&gt; map=new
HashMap&lt;&gt;(); map.put("days","2"); map.put("startTime","22020405");
map.put("reason","想玩");
formService.submitStartFormData("form1-test-key:1:17504",map); }
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 注意查看act_ru_variable变量表</span><br><span class="line">    ![image-20220515174247320](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515174247320.png)</span><br><span class="line"></span><br><span class="line">- 查看任务中的表单数据</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  </span><br><span class="line">      /**</span><br><span class="line">       * 查看对应的表单数据</span><br><span class="line">       */</span><br><span class="line">      @Test</span><br><span class="line">      public void getTaskFormData()&#123;</span><br><span class="line">          ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">          FormService formService = engine.getFormService();</span><br><span class="line">          TaskFormData taskFormData = formService.getTaskFormData(&quot;20012&quot;);</span><br><span class="line">          List&lt;FormProperty&gt; formProperties = taskFormData.getFormProperties();</span><br><span class="line">  </span><br><span class="line">          for (FormProperty property:formProperties)&#123;</span><br><span class="line">              System.out.println(&quot;id==&gt;&quot;+property.getId());</span><br><span class="line">              System.out.println(&quot;name==&gt;&quot;+property.getName());</span><br><span class="line">              System.out.println(&quot;value==&gt;&quot;+property.getValue());</span><br><span class="line">          &#125;</span><br><span class="line">          //这里做一个测试，设置处理人</span><br><span class="line">           /*TaskService taskService = engine.getTaskService();</span><br><span class="line">         taskService.setAssignee(&quot;20012&quot;,&quot;lalala&quot;);*/</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>查看完成的任务【主要】//有点问题，不管 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220515175944504.png"
alt="image-20220515175944504" /></p></li>
</ul></li>
</ul>
<h3 id="外置表单">外置表单</h3>
<ul>
<li><p>[flowable-ui中没找到，不知道是不是eclipse独有的]</p></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>flowable_波哥_b站</tag>
      </tags>
  </entry>
  <entry>
    <title>boge-03-其他</title>
    <url>/2022/05/19/study/flowable/boge_blbl/03-others/</url>
    <content><![CDATA[<h2 id="会签">会签</h2>
<ul>
<li><p>流程图绘制 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220519172038904.png"
alt="image-20220519172038904" /></p>
<ul>
<li><p>注意上面几个参数</p>
<ul>
<li>多实例类型用来判断串行并行</li>
<li>基数（有几个用户处理）</li>
<li>元素变量</li>
<li>集合（集合变量）</li>
<li>完成条件--这里填的是 ${nrOfCompletedInstances &gt; 1 }</li>
</ul></li>
<li><p>在任务监听器 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220519171545786.png"
alt="image-20220519171545786" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.flowable.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.flowable.engine.ProcessEngine;</span><br><span class="line"><span class="keyword">import</span> org.flowable.engine.ProcessEngines;</span><br><span class="line"><span class="keyword">import</span> org.flowable.engine.TaskService;</span><br><span class="line"><span class="keyword">import</span> org.flowable.engine.delegate.TaskListener;</span><br><span class="line"><span class="keyword">import</span> org.flowable.task.api.Task;</span><br><span class="line"><span class="keyword">import</span> org.flowable.task.service.delegate.DelegateTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiInstanceTaskListener</span> <span class="keyword">implements</span> <span class="title class_">TaskListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(DelegateTask delegateTask)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理aaaa&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(delegateTask.getEventName().equals(<span class="string">&quot;create&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;任务id&quot;</span> + delegateTask.getId());</span><br><span class="line">            System.out.println(<span class="string">&quot;哪些人需要会签&quot;</span> + delegateTask.getVariable(<span class="string">&quot;persons&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;任务处理人&quot;</span> + delegateTask.getVariable(<span class="string">&quot;person&quot;</span>));</span><br><span class="line">            <span class="type">ProcessEngine</span> <span class="variable">engine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">            <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> engine.getTaskService();</span><br><span class="line">            <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery().taskId(delegateTask.getId()).singleResult();</span><br><span class="line">            task.setAssignee(delegateTask.getVariable(<span class="string">&quot;person&quot;</span>).toString());</span><br><span class="line">            taskService.saveTask(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li></li>
<li><p>xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">xmlns:flowable</span>=<span class="string">&quot;http://flowable.org/bpmn&quot;</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> <span class="attr">xmlns:omgdc</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span> <span class="attr">xmlns:omgdi</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span> <span class="attr">typeLanguage</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="attr">expressionLanguage</span>=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span> <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span> <span class="attr">exporter</span>=<span class="string">&quot;Flowable Open Source Modeler&quot;</span> <span class="attr">exporterVersion</span>=<span class="string">&quot;6.7.2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">&quot;join-key&quot;</span> <span class="attr">name</span>=<span class="string">&quot;会签测试1&quot;</span> <span class="attr">isExecutable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">documentation</span>&gt;</span>join-desc<span class="tag">&lt;/<span class="name">documentation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;申请人&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">startEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;sid-477F728E-2F63-43BF-A278-76FBCF58B475&quot;</span> <span class="attr">name</span>=<span class="string">&quot;会签人员&quot;</span> <span class="attr">flowable:formFieldValidation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flowable:taskListener</span> <span class="attr">event</span>=<span class="string">&quot;create&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.flowable.listener.MultiInstanceTaskListener&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">flowable:taskListener</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">multiInstanceLoopCharacteristics</span> <span class="attr">isSequential</span>=<span class="string">&quot;false&quot;</span> <span class="attr">flowable:collection</span>=<span class="string">&quot;persons&quot;</span> <span class="attr">flowable:elementVariable</span>=<span class="string">&quot;person&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensionElements</span>&gt;</span><span class="tag">&lt;/<span class="name">extensionElements</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">loopCardinality</span>&gt;</span>3<span class="tag">&lt;/<span class="name">loopCardinality</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">completionCondition</span>&gt;</span>$&#123;nrOfCompletedInstances &gt; 1 &#125;<span class="tag">&lt;/<span class="name">completionCondition</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">multiInstanceLoopCharacteristics</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">userTask</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-B5F81E26-E53B-4D10-8328-C5B3C35E0DD5&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-477F728E-2F63-43BF-A278-76FBCF58B475&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">&quot;sid-3448D902-AE89-467D-8945-805BDEDE7BCA&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">endEvent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;sid-598B2F86-A13B-48BE-88AF-6B61CDA24EA7&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sid-477F728E-2F63-43BF-A278-76FBCF58B475&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sid-3448D902-AE89-467D-8945-805BDEDE7BCA&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">&quot;BPMNDiagram_join-key&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;join-key&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNPlane_join-key&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;startEvent1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_startEvent1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;30.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;105.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;100.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-477F728E-2F63-43BF-A278-76FBCF58B475&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-477F728E-2F63-43BF-A278-76FBCF58B475&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;80.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;330.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;60.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNShape</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-3448D902-AE89-467D-8945-805BDEDE7BCA&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNShape_sid-3448D902-AE89-467D-8945-805BDEDE7BCA&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdc:Bounds</span> <span class="attr">height</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;28.0&quot;</span> <span class="attr">x</span>=<span class="string">&quot;600.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;106.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdc:Bounds</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNShape</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-B5F81E26-E53B-4D10-8328-C5B3C35E0DD5&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-B5F81E26-E53B-4D10-8328-C5B3C35E0DD5&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;15.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;40.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;134.94999855629513&quot;</span> <span class="attr">y</span>=<span class="string">&quot;115.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;232.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;115.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;232.5&quot;</span> <span class="attr">y</span>=<span class="string">&quot;100.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;330.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;100.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bpmndi:BPMNEdge</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;sid-598B2F86-A13B-48BE-88AF-6B61CDA24EA7&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BPMNEdge_sid-598B2F86-A13B-48BE-88AF-6B61CDA24EA7&quot;</span> <span class="attr">flowable:sourceDockerX</span>=<span class="string">&quot;50.0&quot;</span> <span class="attr">flowable:sourceDockerY</span>=<span class="string">&quot;40.0&quot;</span> <span class="attr">flowable:targetDockerX</span>=<span class="string">&quot;14.0&quot;</span> <span class="attr">flowable:targetDockerY</span>=<span class="string">&quot;14.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;429.95000000000005&quot;</span> <span class="attr">y</span>=<span class="string">&quot;100.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;515.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;100.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;515.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;120.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">omgdi:waypoint</span> <span class="attr">x</span>=<span class="string">&quot;600.0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;120.0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">omgdi:waypoint</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bpmndi:BPMNEdge</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bpmndi:BPMNPlane</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li></li>
</ul></li>
<li><p>将流程部署</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deploy</span><span class="params">()</span> &#123;</span><br><span class="line">    deleteAll();</span><br><span class="line">    <span class="type">ProcessEngine</span> <span class="variable">engine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> engine.getRepositoryService();</span><br><span class="line">    <span class="type">Deployment</span> <span class="variable">deploy</span> <span class="operator">=</span> repositoryService.createDeployment()</span><br><span class="line">            .addClasspathResource(<span class="string">&quot;会签测试1.bpmn20.xml&quot;</span>)</span><br><span class="line">            .deploy();</span><br><span class="line">    System.out.println(<span class="string">&quot;部署成功:&quot;</span> + deploy.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行流程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">@Test</span><br><span class="line">public void run()&#123;</span><br><span class="line">    ProcessEngine defaultProcessEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    RuntimeService runtimeService = defaultProcessEngine.getRuntimeService();</span><br><span class="line">    HashMap&lt;String,Object&gt; map=new HashMap<span class="tag">&lt;&gt;</span>();</span><br><span class="line">    ArrayList<span class="tag">&lt;<span class="name">String</span>&gt;</span> persons=new ArrayList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">    persons.add(&quot;张三&quot;);</span><br><span class="line">    persons.add(&quot;李四&quot;);</span><br><span class="line">    persons.add(&quot;王五&quot;);</span><br><span class="line">  </span><br><span class="line">    map.put(&quot;persons&quot;,persons);</span><br><span class="line">    ProcessInstance processInstance = runtimeService.startProcessInstanceById(&quot;join-key:1:17504&quot;,map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>此时数据库会有三个任务 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220519171653406.png"
alt="image-20220519171653406" /></p></li>
<li><p>完成第一个任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completeTask</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//15020</span></span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> engine.getTaskService();</span><br><span class="line">    taskService.complete(<span class="string">&quot;20020&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>再完成一个任务后，流程会直接结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completeTask</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//15020</span></span><br><span class="line">    ProcessEngine engine=ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    <span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> engine.getTaskService();</span><br><span class="line">    taskService.complete(<span class="string">&quot;20028&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>流程结束</p></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>flowable_波哥_b站</tag>
      </tags>
  </entry>
  <entry>
    <title>Flowable-01-GettingStarted</title>
    <url>/2022/04/27/study/flowable/offical/01/</url>
    <content><![CDATA[<h2 id="入门">入门</h2>
<h3 id="什么是流动性">什么是流动性</h3>
<blockquote>
<p>Flowable 是一个用 Java 编写的轻量级业务流程引擎。Flowable
流程引擎允许您部署 BPMN 2.0 流程定义（用于定义流程的行业 XML
标准）、创建这些流程定义的流程实例、运行查询、访问活动或历史流程实例和相关数据等等。</p>
</blockquote>
<blockquote>
<p>可以使用 Flowable REST API 通过 HTTP 进行通信。还有几个 Flowable
应用程序（Flowable Modeler、Flowable Admin、Flowable IDM 和 Flowable
Task）提供开箱即用的示例 UI，用于处理流程和任务。</p>
</blockquote>
<h3 id="flowable和activiti">Flowable和Activiti</h3>
<p>Flowable是Activiti的一个分支</p>
<h3 id="构建命令行命令">构建命令行命令</h3>
<h4 id="创建流程引擎">创建流程引擎</h4>
<p>请假流程如下</p>
<ul>
<li>员工要求休假数次</li>
<li>经理批准或拒绝请求</li>
<li>之后将模拟再某个外部系统中注册请求，并向员工发送一封包含结果的邮件</li>
</ul>
<p>创建一个空的Mave项目，并添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.flowable<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flowable-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.176<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!--当版本号&gt;=8.0.22时会报date转字符串的错误--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加一个带有Main方法的类</p>
<p>这里实例化一个<strong>ProcessEngine</strong>实例，一般只需要实例化一次，是通过<strong>ProcessEngineConfiguration</strong>创建的，用来配置和调整流程引擎的配置</p>
<ul>
<li><em>ProcessEngineConfiguration</em>也可以使用配置 XML 文件创建</li>
<li><em>ProcessEngineConfiguration</em>需要的最低配置是与数据库的 JDBC
连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.flowable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.flowable.engine.ProcessEngine;</span><br><span class="line"><span class="keyword">import</span> org.flowable.engine.ProcessEngineConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HolidayRequest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里改用mysql，注意后面的nullCatalogMeansCurrent=true</span></span><br><span class="line">        <span class="comment">//注意，pom需要添加mysql驱动依赖</span></span><br><span class="line">        <span class="type">ProcessEngineConfiguration</span> <span class="variable">cfg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandaloneProcessEngineConfiguration</span>()</span><br><span class="line">                .setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/flowable_official?useUnicode=true&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&amp;allowMultiQueries=true&quot;</span></span><br><span class="line">                        +<span class="string">&quot;&amp;nullCatalogMeansCurrent=true&quot;</span></span><br><span class="line">                )</span><br><span class="line">                .setJdbcUsername(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">                .setJdbcPassword(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line">                .setJdbcDriver(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)</span><br><span class="line">                .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);</span><br><span class="line">        <span class="comment">/* //这是官网，用的h2</span></span><br><span class="line"><span class="comment">        ProcessEngineConfiguration cfg = new StandaloneProcessEngineConfiguration()</span></span><br><span class="line"><span class="comment">                .setJdbcUrl(&quot;jdbc:h2:mem:flowable;DB_CLOSE_DELAY=-1&quot;)</span></span><br><span class="line"><span class="comment">                .setJdbcUsername(&quot;sa&quot;)</span></span><br><span class="line"><span class="comment">                .setJdbcPassword(&quot;&quot;)</span></span><br><span class="line"><span class="comment">                .setJdbcDriver(&quot;org.h2.Driver&quot;)</span></span><br><span class="line"><span class="comment">                .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> cfg.buildProcessEngine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行后会出现slf4j的警告，添加依赖并编写配置文件即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">log4j.rootLogger</span>=<span class="string">DEBUG, CA</span></span><br><span class="line"><span class="attr">log4j.appender.CA</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="attr">log4j.appender.CA.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="attr">log4j.appender.CA.layout.ConversionPattern</span>=<span class="string">%d&#123;hh:mm:ss,SSS&#125; [%t] %-5p %c %x - %m%n</span></span><br></pre></td></tr></table></figure>
<p>重运行程序无警告</p>
<p>会自动往mysql添加一些表及数据</p>
<h4 id="部署流程定义">部署流程定义</h4>
<p>flowable 引擎希望以 BPMN 2.0
格式定义流程，这是一种在行业中被广泛接受的 XML
标准。Flowable术语称之为<strong>流程定义</strong>
（可以理解成许多执行的蓝图），从流程定义中可以启动许多<strong>流程实例</strong></p>
<p>流程定义了请假假期所涉及的不同步骤，而一个流程实例与一位特定员工的假期请相匹配。</p>
<blockquote>
<p>BPMN 2.0 存储为
XML，但它也有一个可视化部分：它以标准方式定义每个不同的步骤类型（人工任务、自动服务调用等）如何表示，以及如何将这些不同的步骤连接到彼此。通过这种方式，BPMN
2.0 标准允许技术人员和业务人员以双方都理解的方式就业务流程进行交流。</p>
</blockquote>
<p>我们将使用的流程定义</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220428092931927.png" /></p>
<ul>
<li>假设该过程是通过提供一些信息开始的</li>
<li>左边的圆圈称为<strong>开始事件</strong></li>
<li>第一个矩形是<strong>用户任务</strong>（经理必须执行，批准或拒绝）</li>
<li>根据经理决定，<strong>专用网关</strong>
（带有十字菱形）会将流程实例路由到批准或拒绝路径</li>
<li>如果获得批准，必须在某个外部系统中注册请求，然后再次为原始员工执行用户任务，通知他们该决定</li>
<li>如果被拒绝，则会向员工发送一封电子邮件，通知他们这一点</li>
</ul>
<p>此类流程定义使用可视化建模工具建模，例如Flowable
Designer（Eclipse）或FlowableModeler（Web应用程序）</p>
<ul>
<li><p>BPMN 2.0 及其概念
下面的holiday-request.bmpn20.xm文件放在src/main/resouces中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:bpmndi</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:omgdc</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:omgdi</span>=<span class="string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">xmlns:flowable</span>=<span class="string">&quot;http://flowable.org/bpmn&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">typeLanguage</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">expressionLanguage</span>=<span class="string">&quot;http://www.w3.org/1999/XPath&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.flowable.org/processdef&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">&quot;holidayRequest&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Holiday Request&quot;</span> <span class="attr">isExecutable</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">&quot;startEvent&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--线条指向--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">sourceRef</span>=<span class="string">&quot;startEvent&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;approveTask&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;approveTask&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Approve or reject request&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--线条指向--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">sourceRef</span>=<span class="string">&quot;approveTask&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;decision&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusiveGateway</span> <span class="attr">id</span>=<span class="string">&quot;decision&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--线条指向，下面有两个分支--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--线条指向approved--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">sourceRef</span>=<span class="string">&quot;decision&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;externalSystemCall&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span></span><br><span class="line">                &lt;![CDATA[</span><br><span class="line">          $&#123;approved&#125;</span><br><span class="line">        ]]&gt;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--线条指向!approved--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">sourceRef</span>=<span class="string">&quot;decision&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;sendRejectionMail&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span></span><br><span class="line">                &lt;![CDATA[</span><br><span class="line">          $&#123;!approved&#125;</span><br><span class="line">        ]]&gt;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sequenceFlow</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--分支1--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serviceTask</span> <span class="attr">id</span>=<span class="string">&quot;externalSystemCall&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Enter holidays in external system&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">flowable:class</span>=<span class="string">&quot;org.flowable.CallExternalSystemDelegate&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--线条指向--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">sourceRef</span>=<span class="string">&quot;externalSystemCall&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;holidayApprovedTask&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户任务--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;holidayApprovedTask&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Holiday approved&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--线条指向--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">sourceRef</span>=<span class="string">&quot;holidayApprovedTask&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;approveEnd&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--服务任务--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serviceTask</span> <span class="attr">id</span>=<span class="string">&quot;sendRejectionMail&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Send out rejection email&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">flowable:class</span>=<span class="string">&quot;org.flowable.SendRejectionMail&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--线条指向--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">sourceRef</span>=<span class="string">&quot;sendRejectionMail&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;rejectEnd&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--分支2结束--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">&quot;approveEnd&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--分支2结束--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">&quot;rejectEnd&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>解释</p>
<ul>
<li>该文件与BPMN2.0标准规范完全兼容</li>
<li>每个步骤（活动
activity），都有一个id属性，在XML中，该属性提供唯一标识符
name属性为可选的名称，增加了可视化图表的可读性</li>
<li>活动通过<strong>顺序流(sequenceFlow)</strong>连接，即可视图中的定向箭头。执行流程实例时，执行将从开始事件流向下一个活动，且遵循顺序流</li>
<li>离开<em>专有网关</em>的<em>序列流</em>（带有 X
的菱形）显然是特殊的：两者都有一个以<em>表达式</em>形式定义的<em>条件</em>（见第
25 和 32
行）。当流程实例执行到达此<em>gateway</em>时，将评估<em>条件</em>并采用第一个解析为<em>true</em>的条件。这就是这里<em>独有</em>的含义：只选择一个。如果需要不同的路由行为，当然也可以使用其他类型的网关
<ul>
<li>表达式以<span
class="math inline">\({approved}的形式，是\)</span>{approved ==
true}的简写</li>
<li>approved称为过程变量，他与流程实例一起存储（持久数据为，在流程实例的声明周期内使用），意味着必须在流程实例的某个时间点（提交经理用户任务时，即结点<userTask id="approveTask" />[Flowable术语，完成])设置此流程变量）</li>
</ul></li>
</ul></li>
<li><p>部署流程
使用RepositoryService，它可以从ProcessEngine对象中检索，通过传递XML文件的位置并调用deploy()方法来执行它来创建一个新的Deployment</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> processEngine.getRepositoryService();</span><br><span class="line"><span class="comment">//部署流程</span></span><br><span class="line"><span class="type">Deployment</span> <span class="variable">deployment</span> <span class="operator">=</span> repositoryService.createDeployment()</span><br><span class="line">  .addClasspathResource(<span class="string">&quot;holiday-request.bpmn20.xml&quot;</span>)</span><br><span class="line">  .deploy();</span><br><span class="line">        <span class="comment">//打印部署id</span></span><br><span class="line">System.out.println(<span class="string">&quot;Found deployment id : &quot;</span> + deployment.getId());</span><br></pre></td></tr></table></figure>
<p>每次部署的id存在act_re_deployment表中 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220428103748269.png" /></p></li>
<li><p>通过API查询来验证引擎是否知道流程定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ProcessDefinition</span> <span class="variable">processDefinition</span> <span class="operator">=</span> repositoryService.createProcessDefinitionQuery()</span><br><span class="line">  .deploymentId(deployment.getId())</span><br><span class="line">  .singleResult();</span><br><span class="line">System.out.println(<span class="string">&quot;Found process definition : &quot;</span> + processDefinition.getName());</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul></li>
</ul>
<h4 id="启动流程实例">启动流程实例</h4>
<p>现在已经将流程定义部署到流程引擎中了，所以可以将此<strong>流程定义</strong>作为“蓝图”来启动流程实例</p>
<p>启动前提供一些<em>初始流程变量</em>
，通常，当流程自动触发时，将通过呈现给用户的表单或者通过REST
API获得这些信息，本例为保持简单使用java.util.Scanner在命令中简单输入一些数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner scanner= <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Who are you?&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">employee</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;How many holidays do you want to request?&quot;</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">nrOfHolidays</span> <span class="operator">=</span> Integer.valueOf(scanner.nextLine());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Why do you need them?&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> scanner.nextLine();</span><br></pre></td></tr></table></figure>
<p>接下来，通过RuntimeService启动一个流程实例，流程实例使用key启动，此键与BPMN2.0
XML文件中设置的id属性匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> processEngine.getRuntimeService();</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; variables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">variables.put(<span class="string">&quot;employee&quot;</span>, employee);</span><br><span class="line">variables.put(<span class="string">&quot;nrOfHolidays&quot;</span>, nrOfHolidays);</span><br><span class="line">variables.put(<span class="string">&quot;description&quot;</span>, description);</span><br><span class="line"><span class="type">ProcessInstance</span> <span class="variable">processInstance</span> <span class="operator">=</span></span><br><span class="line">  runtimeService.startProcessInstanceByKey(<span class="string">&quot;holidayRequest&quot;</span>, variables);</span><br></pre></td></tr></table></figure>
<ul>
<li>流程实例启动时，会创建一个<strong>执行(execution)</strong>并将其放入<strong>start
event启动事件</strong>中。之后，此<strong>执行(execution)</strong>遵守<strong>user
task 用户任务</strong>的<strong>序列流 sequence
flow</strong>以供经理批准并执行<strong>用户任务user
task</strong>行为</li>
<li>此行为将在数据库中创建一个任务，稍后可以使用查询找到该任务</li>
<li>用户任务处于<em>等待状态</em>，引擎将停止进一步执行任何操作，返回
API 调用</li>
</ul>
<h4 id="支线交易性-sidetrack-transactionality">支线：交易性 (Sidetrack:
transactionality)</h4>
<ul>
<li>当您进行 Flowable API
调用时，默认情况下，一切都是同步<strong>synchronous</strong>的，并且是同一事务的一部分。这意味着，当方法调用返回时，将启动并提交事务。</li>
<li>当一个流程实例启动时，从流程实例启动到下一个<em>等待状态</em>会有<strong>一个数据库事务</strong>。在本例中，这是第一个用户任务。当引擎到达这个用户任务时，状态被持久化到数据库中并且事务被提交并且API调用返回</li>
<li>在 Flowable
中，当继续一个流程实例时，总会有一个数据库事务从前一个<em>等待状态</em>转到下一个<em>等待状态</em>。</li>
<li></li>
</ul>
<h4 id="查询和完成任务">查询和完成任务</h4>
<ul>
<li><p>为用户任务配置分配</p>
<ul>
<li><p>[第一个任务进入"经理"组]</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;approveTask&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Approve or reject request&quot;</span> <span class="attr">flowable:candidateGroups</span>=<span class="string">&quot;managers&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>第二个任务的<em>受让人assignee</em>属性
基于我们在流程实例启动时传递的流程变量的动态分配</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;holidayApprovedTask&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Holiday approved&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;$&#123;employee&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>查询并返回"managers"组的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line">List&lt;Task&gt; tasks = taskService.createTaskQuery().taskCandidateGroup(<span class="string">&quot;managers&quot;</span>).list();</span><br><span class="line">System.out.println(<span class="string">&quot;You have &quot;</span> + tasks.size() + <span class="string">&quot; tasks:&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;tasks.size(); i++) &#123;</span><br><span class="line">  System.out.println((i+<span class="number">1</span>) + <span class="string">&quot;) &quot;</span> + tasks.get(i).getName());<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220428132839571.png"
alt="image-20220428132839571" />
<figcaption aria-hidden="true">image-20220428132839571</figcaption>
</figure>
<p>有三个是因为启动了三个实例</p></li>
<li><p>获取特定的流程实例变量，并在屏幕上显示实际请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Which task would you like to complete?&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">taskIndex</span> <span class="operator">=</span> Integer.valueOf(scanner.nextLine());</span><br><span class="line"><span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> tasks.get(taskIndex - <span class="number">1</span>);</span><br><span class="line">Map&lt;String, Object&gt; processVariables = taskService.getVariables(task.getId());</span><br><span class="line">System.out.println(processVariables.get(<span class="string">&quot;employee&quot;</span>) + <span class="string">&quot; wants &quot;</span> +</span><br><span class="line">    processVariables.get(<span class="string">&quot;nrOfHolidays&quot;</span>) + <span class="string">&quot; of holidays. Do you approve this?&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>设置variables让经理批准</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">approved</span> <span class="operator">=</span> scanner.nextLine().toLowerCase().equals(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">variables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">variables.put(<span class="string">&quot;approved&quot;</span>, approved);</span><br><span class="line"><span class="comment">//经理完成任务</span></span><br><span class="line">taskService.complete(task.getId(), variables);</span><br></pre></td></tr></table></figure>
<p><span
class="math inline">\(\color{red}该任务现已完成，并且基于&quot;approved&quot;流程变量选择离开专用网关的两条路径之一\)</span></p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220428133646782.png" /></p></li>
</ul></li>
</ul>
<h4 id="编写javadelegate">编写JavaDelegate</h4>
<ul>
<li><p>实现在请求被批准时将执行的自动逻辑，在BPMN2.0
XML中，这是一个<strong>服务任务</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">serviceTask</span> <span class="attr">id</span>=<span class="string">&quot;externalSystemCall&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Enter holidays in external system&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">flowable:class</span>=<span class="string">&quot;org.flowable.CallExternalSystemDelegate&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里指定了具体实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.flowable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.flowable.engine.delegate.DelegateExecution;</span><br><span class="line"><span class="keyword">import</span> org.flowable.engine.delegate.JavaDelegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallExternalSystemDelegate</span> <span class="keyword">implements</span> <span class="title class_">JavaDelegate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(DelegateExecution execution)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Calling the external system for employee &quot;</span></span><br><span class="line">            + execution.getVariable(<span class="string">&quot;employee&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<strong>执行execution</strong>到达<strong>service
tast服务任务</strong>时，BPMN 2.0 XML中引用的类被实例化并被调用</p></li>
<li><p>运行，发现自定义逻辑确实已执行</p></li>
</ul>
<h4 id="处理历史数据">处理历史数据</h4>
<p>Flowable引擎会自动存储所有流程实例的<strong>审计数据audit
data</strong> 或<strong>历史数据historical data</strong></p>
<p>下面，显示一直在执行的流程实例的持续时间，从ProcessEngine获取HistoryService并创建历史活动查询。这里添加了过滤--1
仅针对一个特定流程实例的活动 --2 只有已经完成的活动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HistoryService</span> <span class="variable">historyService</span> <span class="operator">=</span> processEngine.getHistoryService();</span><br><span class="line">List&lt;HistoricActivityInstance&gt; activities =</span><br><span class="line">  historyService.createHistoricActivityInstanceQuery()</span><br><span class="line">   .processInstanceId(processInstance.getId())</span><br><span class="line">   .finished()</span><br><span class="line">   .orderByHistoricActivityInstanceEndTime().asc()</span><br><span class="line">   .list();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (HistoricActivityInstance activity : activities) &#123;</span><br><span class="line">  System.out.println(activity.getActivityId() + <span class="string">&quot; took &quot;</span></span><br><span class="line">    + activity.getDurationInMillis() + <span class="string">&quot; milliseconds&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结论">结论</h4>
<p>本教程介绍了各种 Flowable 和 BPMN 2.0
概念和术语，同时还演示了如何以编程方式使用 Flowable API。</p>
<h3 id="flowable-rest-api入门">Flowable REST API入门</h3>
<h4 id="设置rest应用程序">设置REST应用程序</h4>
<p>使用flowable-rest.war , java -jar flowable-rest.war</p>
<p>测试是否运行成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --user rest-admin:test http://localhost:8080/flowable-rest/service/management/engine</span><br></pre></td></tr></table></figure>
<h4 id="部署流程定义-1">部署流程定义</h4>
<ul>
<li><p>先切到该文件夹下 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220428220759415.png" /></p></li>
<li><p>使用下面命令启动flowable-rest</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar flowable-rest.war</span><br></pre></td></tr></table></figure></li>
<li><p>部署流程定义</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --user rest-admin:test -F &quot;file=@holiday-request.bpmn20.xml&quot; http://localhost:8080/flowable-rest/service/repository/deployments</span><br></pre></td></tr></table></figure></li>
<li><p>查看流程是否部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --user rest-admin:test http://localhost:8080/flowable-rest/service/repository/process-definitions</span><br></pre></td></tr></table></figure>
<ul>
<li>将返回一个列表，列表每个元素是当前部署到引擎的所有流程定义</li>
</ul></li>
</ul>
<h4 id="启动流程实例-1">启动流程实例</h4>
<ul>
<li><p>命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --user rest-admin:test -H &quot;Content-Type: application/json&quot; -X POST -d &#x27;&#123; &quot;processDefinitionKey&quot;:&quot;holidayRequest&quot;, &quot;variables&quot;: [ &#123; &quot;name&quot;:&quot;employee&quot;, &quot;value&quot;: &quot;John Doe&quot; &#125;, &#123; &quot;name&quot;:&quot;nrOfHolidays&quot;, &quot;value&quot;: 7 &#125;]&#125;&#x27; http://localhost:8080/flowable-rest/service/runtime/process-instances</span><br></pre></td></tr></table></figure>
<p>windows中会报错...估计是没转义啥的原因 将返回</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;43&quot;</span><span class="punctuation">,</span><span class="attr">&quot;url&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://localhost:8080/flowable-rest/service/runtime/process-instances/43&quot;</span><span class="punctuation">,</span><span class="attr">&quot;businessKey&quot;</span><span class="punctuation">:</span><span class="keyword">null</span><span class="punctuation">,</span><span class="attr">&quot;suspended&quot;</span><span class="punctuation">:</span><span class="keyword">false</span><span class="punctuation">,</span><span class="attr">&quot;ended&quot;</span><span class="punctuation">:</span><span class="keyword">false</span><span class="punctuation">,</span><span class="attr">&quot;processDefinitionId&quot;</span><span class="punctuation">:</span><span class="string">&quot;holidayRequest:1:42&quot;</span><span class="punctuation">,</span><span class="attr">&quot;processDefinitionUrl&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://localhost:8080/flowable-rest/service/repository/process-definitions/holidayRequest:1:42&quot;</span><span class="punctuation">,</span><span class="attr">&quot;activityId&quot;</span><span class="punctuation">:</span><span class="keyword">null</span><span class="punctuation">,</span><span class="attr">&quot;variables&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span><span class="attr">&quot;tenantId&quot;</span><span class="punctuation">:</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span><span class="attr">&quot;completed&quot;</span><span class="punctuation">:</span><span class="keyword">false</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="任务列表和完成任务">任务列表和完成任务</h4>
<ul>
<li><p>获取manager经理组的所有任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --user rest-admin:test -H &quot;Content-Type: application/json&quot; -X POST -d &#x27;&#123; &quot;candidateGroup&quot; : &quot;managers&quot; &#125;&#x27; http://localhost:8080/flowable-rest/service/query/tasks</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用命令完成一个任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl --user rest-admin:test -H &quot;Content-Type: application/json&quot; -X POST -d &#x27;&#123; &quot;action&quot; : &quot;complete&quot;, &quot;variables&quot; : [ &#123; &quot;name&quot; : &quot;approved&quot;, &quot;value&quot; : true&#125; ]  &#125;&#x27; http://localhost:8080/flowable-rest/service/runtime/tasks/25</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里会报下面的错</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;Internal server error&quot;</span><span class="punctuation">,</span><span class="attr">&quot;exception&quot;</span><span class="punctuation">:</span><span class="string">&quot;couldn&#x27;t instantiate class org.flowable.CallExternalSystemDelegate&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>解决办法</p>
<blockquote>
<p>这意味着引擎找不到服务任务中引用的 CallExternalSystemDelegate
类。为了解决这个问题，需要将该类放在应用程序的类路径中（这将需要重新启动）。按照本节所述创建类，将其打包为JAR，并将其放在Tomcat的webapps文件夹下的flowable-rest文件夹的WEB-INF/lib文件夹中。</p>
</blockquote></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>flowable官方</tag>
      </tags>
  </entry>
  <entry>
    <title>Flowable-02-Configuration</title>
    <url>/2022/04/29/study/flowable/offical/02/</url>
    <content><![CDATA[<h3 id="创建流程引擎">创建流程引擎</h3>
<p>Flowable 流程引擎通过一个名为 flowable.cfg.xml 的 XML
文件进行配置</p>
<ul>
<li><p>现在类路径下放置floable.cfg.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:h2:mem:flowable;DB_CLOSE_DELAY=1000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcDriver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.h2.Driver&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUsername&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sa&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcPassword&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseSchemaUpdate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;asyncExecutorActivate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mailServerHost&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mail.my-corp.com&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mailServerPort&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5025&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>然后使用静态方法进行获取ProcessEngine</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br></pre></td></tr></table></figure></li>
<li><p>还有其他配置，这里不一一列举，详见文档地址
https://www.flowable.com/open-source/docs/bpmn/ch03-Configuration</p></li>
<li><p>大致目录如下 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220429095214773.png"
alt="image-20220429095214773" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220429095245768.png"
alt="image-20220429095245768" /></p></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>flowable官方</tag>
      </tags>
  </entry>
  <entry>
    <title>Flowable-03-api</title>
    <url>/2022/04/29/study/flowable/offical/03/</url>
    <content><![CDATA[<h3 id="流程引擎api和服务">流程引擎API和服务</h3>
<p>引擎API是与Flowable交互的常见方式，主要起点是ProcessEngine，可以通过配置（Configuration章节）中描述的多种方式创建。</p>
<p>从ProcessEngine获取包含工作流/BPM方法的各种服务。ProcessEngine和服务对象是线程安全的</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/api.services.png"
alt="api.services" />
<figcaption aria-hidden="true">api.services</figcaption>
</figure>
<p>下面是通过processEngine获取各种服务的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ProcessEngine</span> <span class="variable">processEngine</span> <span class="operator">=</span> ProcessEngines.getDefaultProcessEngine();</span><br><span class="line"></span><br><span class="line"><span class="type">RuntimeService</span> <span class="variable">runtimeService</span> <span class="operator">=</span> processEngine.getRuntimeService();</span><br><span class="line"><span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span> processEngine.getRepositoryService();</span><br><span class="line"><span class="type">TaskService</span> <span class="variable">taskService</span> <span class="operator">=</span> processEngine.getTaskService();</span><br><span class="line"><span class="type">ManagementService</span> <span class="variable">managementService</span> <span class="operator">=</span> processEngine.getManagementService();</span><br><span class="line"><span class="type">IdentityService</span> <span class="variable">identityService</span> <span class="operator">=</span> processEngine.getIdentityService();</span><br><span class="line"><span class="type">HistoryService</span> <span class="variable">historyService</span> <span class="operator">=</span> processEngine.getHistoryService();</span><br><span class="line"><span class="type">FormService</span> <span class="variable">formService</span> <span class="operator">=</span> processEngine.getFormService();</span><br><span class="line"><span class="type">DynamicBpmnService</span> <span class="variable">dynamicBpmnService</span> <span class="operator">=</span> processEngine.getDynamicBpmnService();</span><br></pre></td></tr></table></figure>
<p>ProcessEngines.getDefaultProcessEngine()在第一次调用时初始化并构建流程引擎，然后返回相同的流程引擎</p>
<p>ProcessEngines类将扫描所有flowable.cfg.xml和flowable-context.xml文件。</p>
<blockquote>
<p>对于所有 flowable.cfg.xml 文件，流程引擎将以典型的 Flowable
方式构建：ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream).buildProcessEngine()。</p>
<p>对于所有 flowable-context.xml 文件，流程引擎将以 Spring
方式构建：首先创建 Spring
应用程序上下文，然后从该应用程序上下文中获取流程引擎。</p>
</blockquote>
<blockquote>
<p>The <strong>RepositoryService</strong> is probably the first service
needed when working with the Flowable engine.</p>
</blockquote>
<p>该服务<strong>(RepositoryService)</strong>提供用于管理和操作部署<strong>deployments</strong>和流程定义的操作</p>
<ul>
<li>查询引擎已知的部署和流程定义</li>
<li>暂停和激活作为一个整体或特定流程定义的部署。挂起意味着不能对它们执行进一步的操作，而激活则相反并再次启用操作</li>
<li>检索各种资源，例如引擎自动生成的部署或流程图中包含的文件</li>
<li>检索流程定义的 POJO 版本，该版本可用于使用 Java 而不是 XML
来内省流程</li>
</ul>
<p>RepositoryService主要是关于静态信息（不会改变的数据，或者至少不会改变太多），而RuntimeService处理启动流程定义的<em>新流程实例</em></p>
<ul>
<li><p>流程定义定义了流程中不同步骤的结构和行为，流程实例是此类流程定义的一次执行</p></li>
<li><p>对于每个流程定义，通常有许多实例同时运行</p></li>
<li><p>Runtime也用于检索和存储<strong>流程变量</strong></p></li>
<li><p>Runtimeservice还可以用来查询流程实例和执行(executions)</p>
<blockquote>
<p>Executions are a representation of the 'token' concept of BPMN 2.0.
执行是指向流程实例当前所在位置的指针</p>
</blockquote></li>
<li><p>只要流程实例正在等待外部触发器并且流程需要继续，就会使用
RuntimeService</p></li>
<li><p>流程实例可以有各种等待状态，并且该服务包含各种操作以向实例发出“信号”，即接收到外部触发器并且流程实例可以继续</p></li>
</ul>
<p>需要由系统的人类用户执行的任务是BPM引擎（如Floable）的核心，围绕任务的所有内容都在TaskService中进行分组</p>
<ul>
<li>查询分配给用户或组的任务</li>
<li>创建新的独立任务（与流程实例无关）</li>
<li>任务被分配给哪个用户或哪些用户，以及让这些用户以某种方式参与该任务</li>
<li>要求并完成一项任务，声明意味着某人决定成为该任务的受让人<strong>assignee</strong></li>
</ul>
<p>IdentityService支持组和用户的管理（创建、更新、删除、查询）</p>
<p>FormService是可选服务，引入了启动表单（<strong>start
form</strong>）和任务表单(<strong>a task form</strong>)的概念</p>
<blockquote>
<p><strong>HistoryService</strong>公开了 Flowable
引擎收集的所有历史数据。在执行流程时，引擎可以保留很多数据（这是可配置的），例如流程实例的启动时间，谁做了哪些任务，完成任务花了多长时间，每个流程实例中遵循的路径，等等。</p>
</blockquote>
<p>使用Flowable
编写自定义应用程序时，通常不需要<strong>ManagementService
。</strong>它允许检索有关数据库表和表元数据的信息。此外，它还公开了作业的查询功能和管理操作</p>
<p><strong>DynamicBpmnService</strong>可用于更改流程定义的一部分，而无需重新部署它。例如，您可以更改流程定义中用户任务的受理人定义，或更改服务任务的类名。</p>
<h3 id="异常策略">异常策略</h3>
<p>Flowable 中的基本异常是 org.flowable.engine.FlowableException</p>
<p>Flowable的一些异常子类</p>
<ul>
<li>FlowableWrongDbException：当 Flowable
引擎发现数据库架构版本和引擎版本不匹配时抛出。</li>
<li>FlowableOptimisticLockingException：当并发访问同一数据条目导致数据存储发生乐观锁定时抛出。</li>
<li>FlowableClassLoadingException：当请求加载的类未找到或加载时发生错误时抛出（例如
JavaDelegates、TaskListeners ......）。</li>
<li>FlowableObjectNotFoundException：当请求或操作的对象不存在时抛出。</li>
<li>FlowableIllegalArgumentException：异常表明在 Flowable API
调用中提供了非法参数，在引擎配置中配置了非法值，或者提供了非法值，或者在流程定义中使用了非法值。</li>
<li>FlowableTaskAlreadyClaimedException：当任务已被声明时抛出，当
taskService.claim(...) 被调用时</li>
</ul>
<h3 id="查询接口">查询接口</h3>
<p>引擎查询数据有两种方式：the query API and native queries</p>
<ul>
<li><p>queryAPi允许使用fluent API编写完全类型安全的查询，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Task&gt; tasks = taskService.createTaskQuery()</span><br><span class="line">    .taskAssignee(<span class="string">&quot;kermit&quot;</span>)</span><br><span class="line">    .processVariableValueEquals(<span class="string">&quot;orderId&quot;</span>, <span class="string">&quot;0815&quot;</span>)</span><br><span class="line">    .orderByDueDate().asc()</span><br><span class="line">    .list();</span><br></pre></td></tr></table></figure></li>
<li><p>native queries
（返回类型由您使用的查询对象定义，数据映射到正确的对象[比如任务、流程实例、执行等，且您必须使用在数据库中定义的表明和列名]）。如下，可以通过api检索表名等，使依赖关系尽可能小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Task&gt; tasks = taskService.createNativeTaskQuery()</span><br><span class="line">  .sql(<span class="string">&quot;SELECT count(*) FROM &quot;</span> + managementService.getTableName(Task.class) +</span><br><span class="line">      <span class="string">&quot; T WHERE T.NAME_ = #&#123;taskName&#125;&quot;</span>)</span><br><span class="line">  .parameter(<span class="string">&quot;taskName&quot;</span>, <span class="string">&quot;gonzoTask&quot;</span>)</span><br><span class="line">  .list();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> taskService.createNativeTaskQuery()</span><br><span class="line">  .sql(<span class="string">&quot;SELECT count(*) FROM &quot;</span> + managementService.getTableName(Task.class) + <span class="string">&quot; T1, &quot;</span> +</span><br><span class="line">      managementService.getTableName(VariableInstanceEntity.class) + <span class="string">&quot; V1 WHERE V1.TASK_ID_ = T1.ID_&quot;</span>)</span><br><span class="line">  .count();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="变量">变量</h3>
<ul>
<li><p>每个流程实例都需要并使用数据来执行其组成的步骤。在 Flowable
中，这些数据称为<em>变量</em>，存储在数据库中</p></li>
<li><p>流程实例可以有变量（称为<em>流程变量</em>），也可以有<em>执</em>行（指向流程处于活动状态的特定指针）。用户任务也可以有变量，变量存储在ACT_RU_VARIABLE数据库表中</p></li>
<li><p>所有<em>startProcessInstanceXXX</em>方法都有一个可选参数，用于在创建和启动流程实例时提供变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProcessInstance <span class="title function_">startProcessInstanceByKey</span><span class="params">(String processDefinitionKey, Map&lt;String, Object&gt; variables)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>可以在流程执行期间添加变量。例如，（<em>RuntimeService</em>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setVariable</span><span class="params">(String executionId, String variableName, Object value)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setVariableLocal</span><span class="params">(String executionId, String variableName, Object value)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setVariables</span><span class="params">(String executionId, Map&lt;String, ? extends Object&gt; variables)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setVariablesLocal</span><span class="params">(String executionId, Map&lt;String, ? extends Object&gt; variables)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>检索变量
<em>TaskService</em>上存在类似的方法。这意味着任务（如执行）可以具有仅在任务期间“活动”的局部变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; <span class="title function_">getVariables</span><span class="params">(String executionId)</span>;</span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getVariablesLocal</span><span class="params">(String executionId)</span>;</span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getVariables</span><span class="params">(String executionId, Collection&lt;String&gt; variableNames)</span>;</span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getVariablesLocal</span><span class="params">(String executionId, Collection&lt;String&gt; variableNames)</span>;</span><br><span class="line">Object <span class="title function_">getVariable</span><span class="params">(String executionId, String variableName)</span>;</span><br><span class="line">&lt;T&gt; T <span class="title function_">getVariable</span><span class="params">(String executionId, String variableName, Class&lt;T&gt; variableClass)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>当前<strong><em>执行</em></strong>或<strong><em>任务</em></strong>对象是可用的，它可以用于变量设置和/或检索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution.getVariables();</span><br><span class="line">execution.getVariables(Collection&lt;String&gt; variableNames);</span><br><span class="line">execution.getVariable(String variableName);</span><br><span class="line"></span><br><span class="line">execution.setVariables(Map&lt;String, object&gt; variables);</span><br><span class="line">execution.setVariable(String variableName, Object value);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>在执行上述任何调用时，所有</strong>变量都会在后台从数据库中获取。这意味着，如果您有
10
个变量，但只能通过<em>getVariable("myVariable")</em>获得一个，那么在幕后将获取并缓存其他
9 个</p></li>
<li><p>接上述，可以设置是否缓存所有变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; <span class="title function_">getVariables</span><span class="params">(Collection&lt;String&gt; variableNames, <span class="type">boolean</span> fetchAllVariables)</span>;</span><br><span class="line">Object <span class="title function_">getVariable</span><span class="params">(String variableName, <span class="type">boolean</span> fetchAllVariables)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setVariable</span><span class="params">(String variableName, Object value, <span class="type">boolean</span> fetchAllVariables)</span>;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="瞬态变量">瞬态变量</h3>
<p>瞬态变量是行为类似于常规变量但不持久的变量。通常，瞬态变量用于高级用例</p>
<ul>
<li>对于瞬态变量，根本没有存储历史记录。</li>
<li>与<em>常规</em>变量一样，瞬态变量在设置时放在<em>最高父</em>级。这意味着在执行时设置变量时，瞬态变量实际上存储在流程实例执行中。与常规变量一样，如果在特定执行或任务上设置变量，则存在方法的<em>局部变体。</em></li>
<li>只能在流程定义中的下一个“等待状态”之前访问瞬态变量。在那之后，他们就走了。在这里，等待状态是指流程实例中它被持久化到数据存储中的点。请注意，在此定义中，<em>异步</em>活动也是“等待状态”！</li>
<li>瞬态变量只能由<em>setTransientVariable(name,
value)</em>设置，但调用<em>getVariable(name)</em>时也会返回瞬态变量（也存在一个<em>getTransientVariable(name)</em>，它只检查瞬态变量）。这样做的原因是使表达式的编写变得容易，并且使用变量的现有逻辑适用于这两种类型。</li>
<li>瞬态变量会<em>隐藏</em>同名的持久变量。这意味着当在流程实例上同时设置持久变量和瞬态变量并<em>调用
getVariable("someVariable")</em>时，将返回瞬态变量值。</li>
</ul>
<p>可以在大多数地方设置和获取瞬态变量</p>
<ul>
<li><p>关于<em>JavaDelegate</em>实现中的<em>DelegateExecution</em></p></li>
<li><p>关于<em>ExecutionListener</em>实现中的DelegateExecution<em>和</em>关于<em>TaskListener</em>实现的<em>DelegateTask</em></p></li>
<li><p><em>通过执行</em>对象在脚本任务中</p></li>
<li><p>通过运行时服务启动流程实例时</p></li>
<li><p>完成任务时</p></li>
<li><p>调用<em>runtimeService.trigger</em>方法时</p></li>
<li><p>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setTransientVariable</span><span class="params">(String variableName, Object variableValue)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setTransientVariableLocal</span><span class="params">(String variableName, Object variableValue)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setTransientVariables</span><span class="params">(Map&lt;String, Object&gt; transientVariables)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setTransientVariablesLocal</span><span class="params">(Map&lt;String, Object&gt; transientVariables)</span>;</span><br><span class="line"></span><br><span class="line">Object <span class="title function_">getTransientVariable</span><span class="params">(String variableName)</span>;</span><br><span class="line">Object <span class="title function_">getTransientVariableLocal</span><span class="params">(String variableName)</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getTransientVariables</span><span class="params">()</span>;</span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getTransientVariablesLocal</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeTransientVariable</span><span class="params">(String variableName)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeTransientVariableLocal</span><span class="params">(String variableName)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>典型示例 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/api.transient.variable.example.png"
alt="api.transient.variable.example" /></p></li>
<li><p>瞬态变量传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ProcessInstance</span> <span class="variable">processInstance</span> <span class="operator">=</span> runtimeService.createProcessInstanceBuilder()</span><br><span class="line">       .processDefinitionKey(<span class="string">&quot;someKey&quot;</span>)</span><br><span class="line">       .transientVariable(<span class="string">&quot;configParam01&quot;</span>, <span class="string">&quot;A&quot;</span>)</span><br><span class="line">       .transientVariable(<span class="string">&quot;configParam02&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">       .transientVariable(<span class="string">&quot;configParam03&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">       .start();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>获取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FetchDataServiceTask</span> <span class="keyword">implements</span> <span class="title class_">JavaDelegate</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(DelegateExecution execution)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">configParam01</span> <span class="operator">=</span> (String) execution.getVariable(configParam01);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">RestResponse</span> <span class="variable">restResponse</span> <span class="operator">=</span> executeRestCall();</span><br><span class="line">    execution.setTransientVariable(<span class="string">&quot;response&quot;</span>, restResponse.getBody());</span><br><span class="line">    execution.setTransientVariable(<span class="string">&quot;status&quot;</span>, restResponse.getStatus());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>离开独占网关的序列流的条件不知道使用的是持久变量还是瞬态变量（在本例中为<em>状态</em>瞬态变量）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">conditionExpression</span> <span class="attr">xsi:type</span>=<span class="string">&quot;tFormalExpression&quot;</span>&gt;</span>$&#123;status == 200&#125;<span class="tag">&lt;/<span class="name">conditionExpression</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="表达式">表达式</h3>
<p>Flowable使用UEL进行表达式解析，UEL代表统一表达式语言，是EE6规范的一部分。两种类型的表达式（值表达式和方法表达式），都可以在需要表达式的地方使用</p>
<ul>
<li><p>值表达式，解析为一个值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;myVar&#125;</span><br><span class="line">$&#123;myBean.myProperty&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法表达式：调用带或不带参数的方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$&#123;printer.print()&#125;</span><br><span class="line">$&#123;myBean.addNewOrder(&#x27;orderName&#x27;)&#125;</span><br><span class="line">$&#123;myBean.doSomething(myVar, execution)&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="表达式函数">表达式函数</h3>
<p>一些开箱即用的函数</p>
<ul>
<li><strong>variables:get(varName)</strong>：检索变量的值。与直接在表达式中写变量名的主要区别在于，当变量不存在时，使用这个函数不会抛出异常。例如，如果<em>myVariable</em>不存在，<em><span
class="math inline">\({myVariable ==
&quot;hello&quot;}*会抛出异常，但*\)</span>{var:get(myVariable) ==
'hello'}</em>会正常工作。</li>
<li><strong>variables:getOrDefault(varName,
defaultValue)</strong>：类似于<em>get</em>，但可以选择提供默认值，当变量未设置或值为<em>null</em>时返回。</li>
<li><strong>variables:exists(varName)</strong>
：如果变量具有非空值，则返回<em>true 。</em></li>
<li><strong>variables:isEmpty(varName)</strong> (alias <em>:empty</em> )
: 检查变量值是否不为空。根据变量类型，行为如下：
<ul>
<li>对于字符串变量，如果变量是空字符串，则认为该变量为空。</li>
<li>对于 java.util.Collection 变量，如果集合没有元素，则返回<em>true
。</em></li>
<li>对于 ArrayNode 变量，如果没有元素则返回<em>true</em></li>
<li>如果变量为<em>null</em>，则始终返回<em>true</em></li>
</ul></li>
<li><strong>variables:isNotEmpty(varName)</strong> (alias <em>:
notEmpty) :</em> <em>isEmpty</em>的逆运算。</li>
<li><strong>variables:equals(varName,
value)</strong>（别名<em>:eq</em>）：检查变量是否等于给定值。这是表达式的简写函数，否则将被写为<em>${execution.getVariable("varName")
!= null &amp;&amp; execution.getVariable("varName") == value}</em>。
<ul>
<li>如果变量值为 null，则返回 false（除非与 null 比较）。</li>
</ul></li>
<li><strong>variables:notEquals(varName, value)</strong>（别名<em>:ne
）：</em> <em>equals</em>的反向比较。</li>
<li><strong>variables:contains(varName, value1, value2,
...)</strong>：检查提供的<strong>所有</strong>值是否包含在变量中。根据变量类型，行为如下：
<ul>
<li>对于字符串变量，传递的值用作需要成为变量一部分的子字符串</li>
<li>对于 java.util.Collection
变量，所有传递的值都需要是集合的一个元素（正则<em>包含</em>语义）。</li>
<li>对于 ArrayNode 变量：支持检查 arraynode
是否包含作为变量类型支持的类型的 JsonNode</li>
<li>当变量值为 null 时，在所有情况下都返回
false。当变量值不为null，且实例类型不是上述类型之一时，会返回false。</li>
</ul></li>
<li><strong>variables:containsAny(varName, value1, value2,
...)</strong>：类似于<em>contains</em>函数，但如果<strong>任何</strong>（而非全部）传递的值包含在变量中，则将返回<em>true
。</em></li>
<li><strong>variables:base64(varName)</strong>：将二进制或字符串变量转换为
Base64 字符串</li>
<li>比较器功能：
<ul>
<li><strong>variables:lowerThan(varName, value)</strong>
(别名<em>:lessThan</em>或<em>:lt</em> ) :
<em>${execution.getVariable("varName") != null &amp;&amp;
execution.getVariable("varName") &lt; value}的简写</em></li>
<li><strong>变量：lowerThanOrEquals(varName,
value)</strong>（别名<em>:lessThanOrEquals</em>或<em>:lte</em>）：类似，但现在用于<em>&lt;
=</em></li>
<li><strong>variables:greaterThan(varName, value)</strong> (alias
<em>:gt</em> ) : 类似，但现在用于<em>&gt;</em></li>
<li><strong>variables:greaterThanOrEquals(varName, value)</strong>
(alias <em>:gte</em> ) : 类似，但现在用于<em>&gt; =</em></li>
</ul></li>
<li></li>
</ul>
<h3 id="单元测试">单元测试</h3>
<p>使用自定义资源进行单元测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@FlowableTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBusinessProcessTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ProcessEngine processEngine;</span><br><span class="line">    <span class="keyword">private</span> RuntimeService runtimeService;</span><br><span class="line">    <span class="keyword">private</span> TaskService taskService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">(ProcessEngine processEngine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.processEngine = processEngine;</span><br><span class="line">        <span class="built_in">this</span>.runtimeService = processEngine.getRuntimeService();</span><br><span class="line">        <span class="built_in">this</span>.taskService = processEngine.getTaskService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Deployment(resources = &quot;holiday-request.bpmn20.xml&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSimpleProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; employeeInfo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        employeeInfo.put(<span class="string">&quot;employee&quot;</span>, <span class="string">&quot;wangwu1028930&quot;</span>);</span><br><span class="line">        <span class="comment">//employeeInfo.put()</span></span><br><span class="line">        runtimeService.startProcessInstanceByKey(</span><br><span class="line">                <span class="string">&quot;holidayRequest&quot;</span>, employeeInfo</span><br><span class="line">        );</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery().singleResult();</span><br><span class="line">        assertEquals(<span class="string">&quot;Approve or reject request&quot;</span>, task.getName());</span><br><span class="line">        HashMap&lt;String, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;approved&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        taskService.complete(task.getId(), hashMap);</span><br><span class="line">        assertEquals(<span class="number">1</span>, runtimeService</span><br><span class="line">                .createProcessInstanceQuery().count());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调试单元测试">调试单元测试</h3>
<h3 id="web应用程序中的流程引擎">Web应用程序中的流程引擎</h3>
<p>编写一个简单的ServletContextListener来初始化和销毁普通Servlet环境中的流程引擎</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessEnginesServletContextListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line">    ProcessEngines.init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> &#123;</span><br><span class="line">    ProcessEngines.destroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，ProcessEngines.init()将在类路径中查找flowable.cfg.xml资源文件，并为给定的配置创建一个ProcessEngine，使用下面两种方式来获取他</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProcessEngines.getDefaultProcessEngine()</span><br><span class="line"><span class="comment">//或者下面的方式</span></span><br><span class="line">ProcessEngines.getProcessEngine(<span class="string">&quot;myName&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>flowable官方</tag>
      </tags>
  </entry>
  <entry>
    <title>Flowable-04-spring</title>
    <url>/2022/04/29/study/flowable/offical/04/</url>
    <content><![CDATA[<h3 id="processenginefactorybean">ProcessEngineFactoryBean</h3>
<ul>
<li><p>将ProcessEngine配置为常规的SpringBean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.flowable.spring.SpringProcessEngineConfiguration&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngine&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.flowable.spring.ProcessEngineFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用transaction</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                             http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                             http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">                             http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.SimpleDriverDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.h2.Driver&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:h2:mem:flowable;DB_CLOSE_DELAY=1000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sa&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.flowable.spring.SpringProcessEngineConfiguration&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;transactionManager&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseSchemaUpdate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;asyncExecutorActivate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngine&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.flowable.spring.ProcessEngineFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;repositoryService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;processEngine&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getRepositoryService&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;runtimeService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;processEngine&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getRuntimeService&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;taskService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;processEngine&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getTaskService&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;historyService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;processEngine&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getHistoryService&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;managementService&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;processEngine&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getManagementService&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>还包括了其他的一些bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;tx:annotation-driven transaction-manager=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;bean id=<span class="string">&quot;userBean&quot;</span> class=<span class="string">&quot;org.flowable.spring.test.UserBean&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;runtimeService&quot;</span> ref=<span class="string">&quot;runtimeService&quot;</span> /&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">  &lt;bean id=<span class="string">&quot;printer&quot;</span> class=<span class="string">&quot;org.flowable.spring.test.Printer&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<ul>
<li><p>使用XML资源方式类配置Spring应用程序上下文</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(</span><br><span class="line">    <span class="string">&quot;org/flowable/examples/spring/SpringTransactionIntegrationTest-context.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>或者添加注解</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(</span></span><br><span class="line"><span class="meta"> &quot;classpath:org/flowable/spring/test/transaction/SpringTransactionIntegrationTest-context.xml&quot;)</span></span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>获取服务bean并进行部署流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RepositoryService</span> <span class="variable">repositoryService</span> <span class="operator">=</span></span><br><span class="line">  (RepositoryService) applicationContext.getBean(<span class="string">&quot;repositoryService&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">deploymentId</span> <span class="operator">=</span> repositoryService</span><br><span class="line">  .createDeployment()</span><br><span class="line">  .addClasspathResource(<span class="string">&quot;org/flowable/spring/test/hello.bpmn20.xml&quot;</span>)</span><br><span class="line">  .deploy()</span><br><span class="line">  .getId();</span><br></pre></td></tr></table></figure></li>
<li><p>下面看userBean类，使用了Transaction事务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserBean</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** injected by Spring */</span></span><br><span class="line">  <span class="keyword">private</span> RuntimeService runtimeService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// here you can do transactional stuff in your domain model</span></span><br><span class="line">    <span class="comment">// and it will be combined in the same transaction as</span></span><br><span class="line">    <span class="comment">// the startProcessInstanceByKey to the Flowable RuntimeService</span></span><br><span class="line">    runtimeService.startProcessInstanceByKey(<span class="string">&quot;helloProcess&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRuntimeService</span><span class="params">(RuntimeService runtimeService)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.runtimeService = runtimeService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用userBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserBean</span> <span class="variable">userBean</span> <span class="operator">=</span> (UserBean) applicationContext.getBean(<span class="string">&quot;userBean&quot;</span>);</span><br><span class="line">userBean.hello();</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="表达式">表达式</h3>
<ul>
<li><p>BPMN 流程中的所有<a
href="https://www.flowable.com/open-source/docs/bpmn/ch04-API#expressions">表达式</a>也将默认“看到”所有
Spring bean</p></li>
<li><p><strong>要完全不暴露任何 bean，只需将一个空列表作为
SpringProcessEngineConfiguration 上的“beans”属性传递。当没有设置 'beans'
属性时，上下文中的所有 Spring beans 都将可用</strong></p></li>
<li><p>如下，可以设置暴露的bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.flowable.spring.SpringProcessEngineConfiguration&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beans&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;printer&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;printer&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;printer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.flowable.examples.spring.Printer&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>现在的bean进行公开了，在.bpmn20.xml中可以使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">definitions</span> <span class="attr">id</span>=<span class="string">&quot;definitions&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">process</span> <span class="attr">id</span>=<span class="string">&quot;helloProcess&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">startEvent</span> <span class="attr">id</span>=<span class="string">&quot;start&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;flow1&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;start&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;print&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">serviceTask</span> <span class="attr">id</span>=<span class="string">&quot;print&quot;</span> <span class="attr">flowable:expression</span>=<span class="string">&quot;#&#123;printer.printMessage()&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sequenceFlow</span> <span class="attr">id</span>=<span class="string">&quot;flow2&quot;</span> <span class="attr">sourceRef</span>=<span class="string">&quot;print&quot;</span> <span class="attr">targetRef</span>=<span class="string">&quot;end&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">endEvent</span> <span class="attr">id</span>=<span class="string">&quot;end&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">process</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">definitions</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Print类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>spring配置bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;printer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.flowable.examples.spring.Printer&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自动资源部署">自动资源部署</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.flowable.spring.SpringProcessEngineConfiguration&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;deploymentResources&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">&quot;classpath*:/org/flowable/spring/test/autodeployment/autodeploy.*.bpmn20.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;processEngine&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.flowable.spring.ProcessEngineFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;processEngineConfiguration&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="单元测试">单元测试</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(FlowableSpringExtension.class)</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringJunitJupiterTest.TestConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBusinessProcessTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RuntimeService runtimeService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> TaskService taskService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="meta">@Deployment</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">simpleProcessTest</span><span class="params">()</span> &#123;</span><br><span class="line">    runtimeService.startProcessInstanceByKey(<span class="string">&quot;simpleProcess&quot;</span>);</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> taskService.createTaskQuery().singleResult();</span><br><span class="line">    assertEquals(<span class="string">&quot;My Task&quot;</span>, task.getName());</span><br><span class="line"></span><br><span class="line">    taskService.complete(task.getId());</span><br><span class="line">    assertEquals(<span class="number">0</span>, runtimeService.createProcessInstanceQuery().count());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>flowable官方</tag>
      </tags>
  </entry>
  <entry>
    <title>Flowable-05-spring-boot</title>
    <url>/2022/04/29/study/flowable/offical/05/</url>
    <content><![CDATA[<h3 id="入门">入门</h3>
<p>需要两个依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">flowable.version</span>&gt;</span>6.7.2<span class="tag">&lt;/<span class="name">flowable.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.flowable<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flowable-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flowable.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.h2database/h2 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.212<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>结合Spring：</p>
<p>只需将依赖项添加到类路径并使用<em><span class="citation"
data-cites="SpringBootApplication">@SpringBootApplication</span></em>注释，幕后就会发生很多事情：</p>
<ul>
<li><p>自动创建内存数据源（因为 H2 驱动程序位于类路径中）并传递给
Flowable 流程引擎配置</p></li>
<li><p>已创建并公开了 Flowable
ProcessEngine、CmmnEngine、DmnEngine、FormEngine、ContentEngine 和
IdmEngine bean</p></li>
<li><p>所有 Flowable 服务都暴露为 Spring bean</p></li>
<li><p>Spring Job Executor 已创建</p></li>
<li><p>将自动部署<em>流程</em>文件夹中的任何 BPMN 2.0
流程定义。创建一个文件夹<em>processes</em>并将一个虚拟进程定义（名为<em>one-task-process.bpmn20.xml</em>）添加到此文件夹。该文件的内容如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;definitions</span><br><span class="line">        xmlns=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span></span><br><span class="line">        xmlns:flowable=<span class="string">&quot;http://flowable.org/bpmn&quot;</span></span><br><span class="line">        targetNamespace=<span class="string">&quot;Examples&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;process id=<span class="string">&quot;oneTaskProcess&quot;</span> name=<span class="string">&quot;The One Task Process&quot;</span>&gt;</span><br><span class="line">        &lt;startEvent id=<span class="string">&quot;theStart&quot;</span> /&gt;</span><br><span class="line">        &lt;sequenceFlow id=<span class="string">&quot;flow1&quot;</span> sourceRef=<span class="string">&quot;theStart&quot;</span> targetRef=<span class="string">&quot;theTask&quot;</span> /&gt;</span><br><span class="line">        &lt;userTask id=<span class="string">&quot;theTask&quot;</span> name=<span class="string">&quot;my task&quot;</span> flowable:assignee=<span class="string">&quot;kermit&quot;</span> /&gt;</span><br><span class="line">        &lt;sequenceFlow id=<span class="string">&quot;flow2&quot;</span> sourceRef=<span class="string">&quot;theTask&quot;</span> targetRef=<span class="string">&quot;theEnd&quot;</span> /&gt;</span><br><span class="line">        &lt;endEvent id=<span class="string">&quot;theEnd&quot;</span> /&gt;</span><br><span class="line">    &lt;/process&gt;</span><br><span class="line"></span><br><span class="line">&lt;/definitions&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><em>案例</em>文件夹中的任何 CMMN 1.1
案例定义都将自动部署。</p></li>
<li><p>将自动部署<em>dmn</em>文件夹中的任何 DMN 1.1 dmn 定义。</p></li>
<li><p><em>表单</em>文件夹中的任何表单定义都将自动部署。</p></li>
</ul>
<p>java代码 在项目服务启动的时候就去加载一些数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CommandLineRunner <span class="title function_">init</span><span class="params">(<span class="keyword">final</span> RepositoryService repositoryService,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">final</span> RuntimeService runtimeService,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">final</span> TaskService taskService)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//该bean在项目服务启动的时候就去加载一些数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommandLineRunner</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">//有几个流程定义</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Number of process definitions : &quot;</span></span><br><span class="line">                        + repositoryService.createProcessDefinitionQuery().count());</span><br><span class="line">                <span class="comment">//有多少个任务</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Number of tasks : &quot;</span> + taskService.createTaskQuery().count());</span><br><span class="line">                runtimeService.startProcessInstanceByKey(<span class="string">&quot;oneTaskProcess&quot;</span>);</span><br><span class="line">                <span class="comment">//开启流程后有多少个任务（+1）</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Number of tasks after process start: &quot;</span></span><br><span class="line">                        + taskService.createTaskQuery().count());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更改数据库">更改数据库</h3>
<ul>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>application.yml中添加配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/flowable-spring-boot?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;nullCatalogMeansCurrent=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="rest支持">Rest支持</h3>
<ul>
<li><p>web支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>使用Service启动流程及获取给定受让人的任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RuntimeService runtimeService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TaskService taskService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        runtimeService.startProcessInstanceByKey(<span class="string">&quot;oneTaskProcess&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Task&gt; <span class="title function_">getTasks</span><span class="params">(String assignee)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> taskService.createTaskQuery().taskAssignee(assignee).list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建REST端点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value=&quot;/process&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startProcessInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        myService.startProcess();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/tasks&quot;, method= RequestMethod.GET, produces=MediaType.APPLICATION_JSON_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;TaskRepresentation&gt; <span class="title function_">getTasks</span><span class="params">(<span class="meta">@RequestParam</span> String assignee)</span> &#123;</span><br><span class="line">        List&lt;Task&gt; tasks = myService.getTasks(assignee);</span><br><span class="line">        List&lt;TaskRepresentation&gt; dtos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TaskRepresentation&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Task task : tasks) &#123;</span><br><span class="line">            dtos.add(<span class="keyword">new</span> <span class="title class_">TaskRepresentation</span>(task.getId(), task.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dtos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TaskRepresentation</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TaskRepresentation</span><span class="params">(String id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用下面语句进行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8080/tasks?assignee=kermit</span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line">curl -X POST  http://localhost:8080/process</span><br><span class="line"></span><br><span class="line">curl http://localhost:8080/tasks?assignee=kermit</span><br><span class="line">[&#123;&quot;id&quot;:&quot;10004&quot;,&quot;name&quot;:&quot;my task&quot;&#125;]</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="jpa支持">JPA支持</h4>
<ul>
<li><p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birthDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String username, String firstName, String lastName, Date birthDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="built_in">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstName</span><span class="params">(String firstName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getBirthDate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> birthDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirthDate</span><span class="params">(Date birthDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthDate = birthDate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>属性文件添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.jpa.hibernate.ddl-auto=update</span><br></pre></td></tr></table></figure></li>
<li><p>添加Repository类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Person, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Person <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代码</p>
<ul>
<li><p>添加事务</p></li>
<li><p>startProcess现在修改成：获取传入的受理人用户名，查找Person，并将PersonJPA对象作为流程变量放入流程实例中</p></li>
<li><p>在CommandLineRunner中初始化时创建用户</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RuntimeService runtimeService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TaskService taskService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startProcess</span><span class="params">(String assignee)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personRepository.findByUsername(assignee);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; variables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        variables.put(<span class="string">&quot;person&quot;</span>, person);</span><br><span class="line">        runtimeService.startProcessInstanceByKey(<span class="string">&quot;oneTaskProcess&quot;</span>, variables);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Task&gt; <span class="title function_">getTasks</span><span class="params">(String assignee)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> taskService.createTaskQuery().taskAssignee(assignee).list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createDemoUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (personRepository.findAll().size() == <span class="number">0</span>) &#123;</span><br><span class="line">            personRepository.save(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jbarrez&quot;</span>, <span class="string">&quot;Joram&quot;</span>, <span class="string">&quot;Barrez&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">            personRepository.save(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;trademakers&quot;</span>, <span class="string">&quot;Tijs&quot;</span>, <span class="string">&quot;Rademakers&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>CommandRunner修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CommandLineRunner <span class="title function_">init</span><span class="params">(<span class="keyword">final</span> MyService myService)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommandLineRunner</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            myService.createDemoUsers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>RestController修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value=&quot;/process&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startProcessInstance</span><span class="params">(<span class="meta">@RequestBody</span> StartProcessRepresentation startProcessRepresentation)</span> &#123;</span><br><span class="line">        myService.startProcess(startProcessRepresentation.getAssignee());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StartProcessRepresentation</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String assignee;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getAssignee</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> assignee;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAssignee</span><span class="params">(String assignee)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.assignee = assignee;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改流程定义</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">userTask</span> <span class="attr">id</span>=<span class="string">&quot;theTask&quot;</span> <span class="attr">name</span>=<span class="string">&quot;my task&quot;</span> <span class="attr">flowable:assignee</span>=<span class="string">&quot;$&#123;person.id&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<ul>
<li><p>启动spring boot之后person表会有两条数据</p></li>
<li><p>启动流程实例</p>
<p>此时会把从数据库查找到的person传入流程图(变量)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;assignee&quot; : &quot;jbarrez&quot;&#125;&#x27; http://localhost:8080/process</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用id获取任务列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://localhost:8080/tasks?assignee=1</span><br><span class="line"></span><br><span class="line">[&#123;&quot;id&quot;:&quot;12505&quot;,&quot;name&quot;:&quot;my task&quot;&#125;]</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ul>
<h3 id="可流动的执行器端点">可流动的执行器端点</h3>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>flowable官方</tag>
      </tags>
  </entry>
  <entry>
    <title>zsx_flowable_design01</title>
    <url>/2022/05/23/study/flowable/zsx_design/01/</url>
    <content><![CDATA[<ul>
<li><p>模型设计完后，下面三个表有变化</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220523171949603.png"
alt="image-20220523171949603" />
<figcaption aria-hidden="true">image-20220523171949603</figcaption>
</figure>
<ul>
<li>act_cio_model <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220523172131614.png"
alt="image-20220523172131614" /></li>
<li>act_cio_model_module_rel <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220523172159869.png"
alt="image-20220523172159869" /></li>
<li>act_ge_bytearray <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220523172239714.png"
alt="image-20220523172239714" /></li>
</ul></li>
<li><p>部署之后，四个表有变化 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220523172615648.png"
alt="image-20220523172615648" /></p>
<ul>
<li><p>act_cio_deployment 多了39条记录 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220523172836324.png"
alt="image-20220523172836324" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220523172821450.png"
alt="image-20220523172821450" />
<figcaption aria-hidden="true">image-20220523172821450</figcaption>
</figure></li>
<li><p>act_ge_bytearray 多了两条记录 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220523172936205.png"
alt="image-20220523172936205" /></p></li>
<li><p>act_re_deployment 多了一条记录 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220523173031162.png"
alt="image-20220523173031162" /></p></li>
<li><p>act_re_procdef 多了一条记录 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220523173141905.png"
alt="image-20220523173141905" /></p></li>
</ul></li>
<li><p>流程开始运行</p>
<ul>
<li>下面只写上主要的几个表</li>
<li>送审时这个结点只能选一个 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220523173557679.png"
alt="image-20220523173557679" /></li>
<li>流程运行时变量表 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220523174011670.png"
alt="image-20220523174011670" /></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>zsx_flowable设计</tag>
      </tags>
  </entry>
  <entry>
    <title>01-08_git_尚硅谷</title>
    <url>/2022/07/20/study/git/git_sgg/01-08/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<h2 id="课程介绍">课程介绍</h2>
<ol type="1">
<li>Git - git介绍--分布式版本控制+集中式版本控制 -
git安装--基于官网，2.31.1 windows - 基于开发案例 详细讲解常用命令 -
git分支---特性、创建、转换、合并、代码合并冲突解决 - idea集成git</li>
<li>Github
<ul>
<li>如何创建远程库</li>
<li>推送 push</li>
<li>拉取 pull</li>
<li>克隆 clone</li>
<li>ssh免密登录</li>
<li>idea github集成</li>
</ul></li>
<li>Gitee码云
<ul>
<li>码云创建远程库</li>
<li>Idea集成Gitee</li>
</ul></li>
<li>Gitlab
<ul>
<li>gitlab服务器的搭建和部署</li>
<li>idea集成gitlab</li>
</ul></li>
<li>课程目标：五个小时，熟练掌握git、github、gitee</li>
</ol>
<h2 id="官网介绍">官网介绍</h2>
<ol type="1">
<li>git是免费的开源的分布式版本控制系统</li>
<li>廉价的本地库</li>
<li>分支功能 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220721213708758.png"
alt="image-20220721213708758" /></li>
<li>Everything is local</li>
</ol>
<h2 id="版本控制介绍">版本控制介绍</h2>
<ol type="1">
<li>记录文件内容变化，以便将来查阅特定版本修订记录的系统</li>
<li>如果没有git <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220721213950707.png"
alt="image-20220721213950707" /></li>
<li>为什么需要版本控制（从个人开发过渡到团队合作） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220721214338521.png"
alt="image-20220721214338521" /></li>
</ol>
<h2
id="分布式版本控制vs集中式版本控制">分布式版本控制VS集中式版本控制</h2>
<ol type="1">
<li>SVN，单一的集中管理的服务器，保存所有文件的修订版本。其他人都先连到这个中央服务器上获取最新处理是否冲突
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220721231138140.png"
alt="image-20220721231138140" /></li>
</ol>
<ul>
<li>缺点，单点故障，如果某段时间内故障了，那么就没法提交</li>
</ul>
<ol start="2" type="1">
<li>Git，每台电脑都是代码库 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220721231509683.png"
alt="image-20220721231509683" />
<ul>
<li>如果远程库挂了，本地还是可以做版本控制的，只不过不能做代码推送而已</li>
<li>每个客户端保存的都是完整的项目（包括历史记录）</li>
</ul></li>
</ol>
<h2 id="发展历史">发展历史</h2>
<ol type="1">
<li>linux系统版本控制历史
<ul>
<li>1991-2002 手动合并</li>
<li>2002 BitKeeper授权Linux社区免费使用（版本控制系统）
<ul>
<li>社区将其破解</li>
</ul></li>
<li>2005 用C语言开发了一个分布式版本控制系统：Git 两周开发时间</li>
<li>2008年 GitHub上线</li>
</ul></li>
</ol>
<h2 id="工作机制和代码托管中心">工作机制和代码托管中心</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220721232308526.png"
alt="image-20220721232308526" />
<figcaption aria-hidden="true">image-20220721232308526</figcaption>
</figure>
<ol type="1">
<li><p>工作机制</p>
<ul>
<li>如果git commit
，会生成对应的历史版本，那么这里的历史版本是删不掉的</li>
<li>如果只是在工作区，或者添加到了暂存区，那么是可以恢复(删掉（操作记录）)的</li>
<li>git add (让git知道有这个文件) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723091448949.png"
alt="image-20220723091448949" />
如果只有v1,v2,v3，V3版本是删不掉的，如果要恢复成v2，只能再提交一次版本</li>
</ul></li>
<li><p>远程库-- 代码托管中心是基于网络服务器的远程代码仓库，简称为远程库
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723091726956.png"
alt="image-20220723091726956" /></p>
<ul>
<li><p>局域网 GitLab</p></li>
<li><p>互联网 GitHub Gitee 码云</p></li>
</ul></li>
</ol>
<h1 id="安装">安装</h1>
<ol type="1">
<li><p>git安装、客户端使用(windows)</p>
<ul>
<li><p>git安装位置 任意 非中文、无空格</p></li>
<li><p>选项配置 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723092103420.png"
alt="image-20220723092103420" /></p></li>
<li><p>编辑器选择 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723092214293.png"
alt="image-20220723092214293" /></p></li>
<li><p>是否修改初始化分支的名字--默认master <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723092243222.png"
alt="image-20220723092243222" /></p></li>
<li><p>默认第二个，这里选择第一个，只能在git bash里面使用 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723092335836.png"
alt="image-20220723092335836" /></p></li>
<li><p>后台客户端协议 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723092421411.png"
alt="image-20220723092421411" /></p></li>
<li><p>配置行末换行符 windows--CRLF linux--LF</p>
<p>默认，让git根据系统自动转换<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723092452460.png"
alt="image-20220723092452460" /></p></li>
</ul></li>
</ol>
<ul>
<li><p>从远程拉取代码时，模式--用默认 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723092620029.png"
alt="image-20220723092620029" /></p>
<ul>
<li><p>凭据管理器 记录登陆行为，不用每次登录 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723092645389.png"
alt="image-20220723092645389" /></p></li>
<li><p>其他配置 软链接文件 缓存 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723092729653.png"
alt="image-20220723092729653" /></p></li>
<li><p>再git bash里运行第三方程序</p></li>
</ul>
<p>安装成功---视频里面是2.31 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723092855691.png"
alt="image-20220723092855691" /></p></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git_尚硅谷</tag>
      </tags>
  </entry>
  <entry>
    <title>09-18_git_尚硅谷</title>
    <url>/2022/07/23/study/git/git_sgg/09-18/</url>
    <content><![CDATA[<h1 id="命令">命令</h1>
<ol type="1">
<li><p>命令-设置用户签名</p>
<ul>
<li>查看 <code>git config user.name</code>
<code>git config user.email</code></li>
<li>设置 <code>git config --global user.name ly001</code>
<code>git config --global user.email xxx@xx.com</code></li>
<li>git的配置文件查看 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723213819948.png"
alt="image-20220723213819948" /></li>
<li>作用：区分不同操作者身份，跟后面登陆的账号没有关系</li>
</ul></li>
<li><p>初始化本地库</p>
<ul>
<li><p><code>git init</code></p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723221535272.png"
alt="image-20220723221535272" /> 多出一个文件夹 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723221752414.png"
alt="image-20220723221752414" /></p></li>
</ul></li>
<li><p>查看本地库状态</p>
<ul>
<li><code>git status</code> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220723221936215.png"
alt="image-20220723221936215" /> 默认在master分支</li>
<li>新增一个文件 <code>vim hello.txt</code> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724094610700.png"
alt="image-20220724094610700" /></li>
<li>此时查看本地库的状态 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724094729991.png"
alt="image-20220724094729991" /> untracketd files
未被追踪的文件，也就是这个文件还在工作区</li>
</ul></li>
<li><p>添加暂存区</p>
<ul>
<li><p><code>git add hello.txt</code> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724095104535.png"
alt="image-20220724095104535" /> LF 将会被替换成
CRLF，windows里面是CRLF，也就是说</p>
<blockquote>
<p>这个<code>换行符自动转换</code>会把自动把你代码里
与你当前操作系统不相同的换行的方式
转换成当前系统的换行方式（即<code>LF</code>和<code>CRLF</code>
之间的转换）</p>
</blockquote>
<p>这是因为这个hello.txt是使用<code>vm hello.txt</code>在git
bash里面添加的，如果直接在windows文件管理器添加一个文件（hello2.txt)，就会发现没有这个警告，因为他已经是CRLF了
（为了和视频保持一致，git rm --cached hello2.txt 后删除这个文件） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724100600978.png"
alt="image-20220724100600978" /></p></li>
<li><p>查看当前状态，绿色表示git已经追踪到了这个文件</p>
<p>文件已经存在于暂存区 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724095955869.png"
alt="image-20220724095955869" /></p></li>
<li><p>使用<code>git rm --cached hello.txt</code>可以将文件从暂存区删除
使用后，文件又出现在工作区了（未添加） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724100308401.png"
alt="image-20220724100308401" /></p></li>
<li></li>
</ul></li>
<li><p>提交本地库</p>
<ul>
<li><p><code>git commit -m "first commit" hello.txt</code>
会出现一些警告，以及此时提交的修改和生成的版本号（前七位） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724100937599.png"
alt="image-20220724100937599" /> <code>git status</code> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724101043687.png"
alt="image-20220724101043687" /></p></li>
<li><p>使用git reflog查看引用日志信息 git log 查看详细日志信息 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724101139028.png"
alt="image-20220724101139028" /></p></li>
</ul></li>
<li><p>修改命令</p>
<ul>
<li><p>前提，修改了文件 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724101329134.png"
alt="image-20220724101329134" /></p></li>
<li><p>git status</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724101355054.png"
alt="image-20220724101355054" />红色表示git还没有追踪到这个修改，如果此时commit
，会提示没有需要commit的 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724101505483.png"
alt="image-20220724101505483" /></p></li>
<li><p>使用git add hello.txt 将文件修改添加到暂存区 之后git status <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724102125244.png"
alt="image-20220724102125244" /></p>
<ul>
<li><p>注意，这里如果提交到暂存区之后，使用git
restore是无法恢复文件的</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724102234835.png"
alt="image-20220724102234835" />
<figcaption aria-hidden="true">image-20220724102234835</figcaption>
</figure></li>
<li><p>git restore --staged <file>..." to unstage
使用这个命令丢弃这个文件的commit操作</p>
<blockquote>
<p>几个命令的区别：</p>
<ul>
<li>git restore file
的命令是丢弃你在工作区修改的内容,(修改的内容会丢失)</li>
<li>git restore --staged file 丢弃你在工作区的修改不被<a
href="https://so.csdn.net/so/search?q=commit&amp;spm=1001.2101.3001.7020">commit</a>
。但是你的修改依然在工作区。</li>
<li>git rm --cached file和git restore --staged file
效果好像一样，这里不做更进一步的分析</li>
</ul>
</blockquote></li>
</ul></li>
<li><p>回到最初，这里主要是为了看修改，如最上面，将第一行后面添加了22222</p>
<p>commit 之后的提示，删除了一行，添加了一行（修改的另一种说法） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724102949971.png"
alt="image-20220724102949971" /></p></li>
<li><p>如果，HEAD -&gt; master ，指针指向了第二个版本 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724103127996.png"
alt="image-20220724103127996" /></p></li>
<li><p>这里再做第三次修改，并add 及commit <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724103303974.png"
alt="image-20220724103303974" /></p></li>
<li><p>查看工作区，永远只有最后那次修改的文件 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724103332836.png"
alt="image-20220724103332836" /></p></li>
</ul></li>
<li><p>版本穿梭</p>
<ul>
<li><p>git reflog和git log <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724103443297.png"
alt="image-20220724103443297" /></p></li>
<li><p>回顾：hello.txt先是5行，然后第一行加了2，之后第二行加了3</p></li>
<li><p>使用git reset --hard
版本号进行穿梭，这里多了一行，是因为我复制的时候复制粗了版本号</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724103935566.png"
alt="image-20220724103935566" />
<figcaption aria-hidden="true">image-20220724103935566</figcaption>
</figure>
<p>使用cat 查看，发现文件已经在另一个版本 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724104008811.png"
alt="image-20220724104008811" /></p></li>
<li><p>查看.git的一些文件 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724104132475.png"
alt="image-20220724104132475" /> 说明目前是在master这个版本上
下面这个文件 .git/refs/heads/master 记录了指向master分支的哪个版本号
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724104310287.png"
alt="image-20220724104310287" /></p></li>
<li><p>这里将文件指向最初的版本 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724104528829.png"
alt="image-20220724104528829" /></p>
<ul>
<li>此时查看刚才说的那个记录某个分支当前指向版本的文件，已经做了更新
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724104638810.png"
alt="image-20220724104638810" /></li>
</ul></li>
<li><figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724104706066.png"
alt="image-20220724104706066" />
<figcaption aria-hidden="true">image-20220724104706066</figcaption>
</figure></li>
<li><p>再穿梭为后面的版本 git reset --hard file <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724104819678.png"
alt="image-20220724104819678" /></p></li>
<li><p>图片解释 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724104910442.png"
alt="image-20220724104910442" /> master指针指向first,second,third
head永远都是指向master（当前分支，目前只有master，所以不变）</p></li>
</ul></li>
</ol>
<h1 id="分支">分支</h1>
<ol type="1">
<li><p>概述和优点 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724132914166.png"
alt="image-20220724132914166" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724134235798.png"
alt="image-20220724134235798" /></p></li>
<li><p>查看&amp;创建&amp;切换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch 分支名    #创建分支</span><br><span class="line">git branch -v       #查看分支</span><br><span class="line">git checkout 分支名  #切换分支</span><br><span class="line">git merge 分支名     #把指定的分支合并到当前分支上</span><br></pre></td></tr></table></figure>
<ul>
<li><p>查看分支并显示当前分支指向的版本 git branch -v <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724161017521.png"
alt="image-20220724161017521" /></p></li>
<li><p>创建分支 git branch hot-fix git branch #再次查看 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724161127755.png"
alt="image-20220724161127755" /></p></li>
<li><p>切换分支</p>
<p>git branch hot-fix 此时修改一个文件并提交 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724161340416.png"
alt="image-20220724161340416" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724161444200.png"
alt="image-20220724161444200" />
查看.git/head文件，会发现现在它指向hot-fix分支 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724161600603.png"
alt="image-20220724161600603" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724161757944.png"
alt="image-20220724161757944" /></p></li>
</ul></li>
<li><p>合并分支（正常合并）</p>
<ul>
<li><p>切换分支 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724161934736.png"
alt="image-20220724161934736" /></p></li>
<li><p>将某分支xx合并到当前分支 git merge 分支名</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724162147318.png"
alt="image-20220724162147318" /> 如图，合并成功
以后面那个分支的修改为主</p></li>
</ul></li>
<li><p>合并分支（冲突合并）</p>
<ul>
<li><p>前提，现在master分支倒数第二行修改并添加和提交 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724162554933.png"
alt="image-20220724162554933" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724162642482.png"
alt="image-20220724162642482" /></p></li>
<li><p>此时切换到hot-fix分支 修改倒数第一行 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724162857236.png"
alt="image-20220724162857236" />
将文件从工作区添加到暂存区并提交到本地库 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724163014554.png"
alt="image-20220724163014554" /></p></li>
<li><p>此时再切回master</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge hot-fix</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724163154164.png"
alt="image-20220724163154164" />
<figcaption aria-hidden="true">image-20220724163154164</figcaption>
</figure></li>
<li><p>提示出错了，而且所有有异常的文件，都以下面的形式标注 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724163343835.png"
alt="image-20220724163343835" /> 按dd进行删除某一行 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724163547658.png"
alt="image-20220724163547658" /> 改完了之后，保存并提交即可 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724163849114.png"
alt="image-20220724163849114" />
切回之后查看hot-fix分支，发现这里的文件是没有变化的 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724164010559.png"
alt="image-20220724164010559" /></p></li>
<li><p>原理 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724164111179.png"
alt="image-20220724164111179" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724164209633.png"
alt="image-20220724164209633" /></p></li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git_尚硅谷</tag>
      </tags>
  </entry>
  <entry>
    <title>19-26_git_尚硅谷</title>
    <url>/2022/07/24/study/git/git_sgg/19-26/</url>
    <content><![CDATA[<h1 id="介绍">介绍</h1>
<p>使用代码托管中心（远程服务器） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724170726396.png"
alt="image-20220724170726396" /></p>
<ul>
<li>团队内写作 push--clone--push--- --pull <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724204533485.png"
alt="image-20220724204533485" /></li>
<li>跨团队写作 fork（到自己的远程库）---clone <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724204930503.png"
alt="image-20220724204930503" /></li>
</ul>
<h1 id="创建远程库创建别名">创建远程库&amp;创建别名</h1>
<ul>
<li>官网：https://github.com</li>
<li>现在yuebuqun注册一个账号 创建一个远程库git-demo，创建成功 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724211410556.png"
alt="image-20220724211410556" /></li>
<li>创建远程库别名 git remote -v （查看别名） 为远程库创建别名
<code>git remote add git-demo https://github.com/lwmfjc/git-demo.git</code>
别名创建成功 fetch和push都可以使用别名 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220724211655584.png"
alt="image-20220724211655584" /></li>
</ul>
<h1 id="推送本地库到远程库">推送本地库到远程库</h1>
<ul>
<li>推送master分支 切换<code>git checkout master</code></li>
<li>推送 git push git-demo master <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727202645908.png"
alt="image-20220727202645908" /></li>
</ul>
<h1 id="拉取远程库到本地库">拉取远程库到本地库</h1>
<ul>
<li><code>git pull git-demo master</code> 结果 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727203004350.png"
alt="image-20220727203004350" /></li>
</ul>
<h1 id="克隆远程库到本地">克隆远程库到本地</h1>
<ul>
<li>git clone xxxxxxx/git-demo.git <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727203532719.png"
alt="image-20220727203532719" />
clone之后有默认的别名，且已经初始化了本地库</li>
</ul>
<h1 id="团队内写作">团队内写作</h1>
<ul>
<li>lhc修改了git-demo下的hello.txt</li>
<li>之后进行git add hello.txt</li>
<li>git commit -m "lhc-commit " hello.txt</li>
<li>现在进行push git push origin master 出错了 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727203924432.png"
alt="image-20220727203924432" /></li>
<li>使用ybq，对库进行设置，管理成员 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727204017197.png"
alt="image-20220727204017197" /></li>
<li>添加成员即可 输入账号名 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727204040960.png"
alt="image-20220727204040960" /></li>
<li>将邀请函 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727204110304.png"
alt="image-20220727204110304" /> 发送给lhc <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727204126988.png"
alt="image-20220727204126988" /></li>
<li>现在再次推送，则推送成功 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727204229743.png"
alt="image-20220727204229743" /></li>
</ul>
<h1 id="团队外合作">团队外合作</h1>
<ul>
<li><p>先把别人的项目fork下来 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727205710975.png"
alt="image-20220727205710975" /></p></li>
<li><p>之后进行修改并且commit <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727204508432.png"
alt="image-20220727204508432" /></p></li>
<li><p>pull request (拉取请求) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727204551005.png"
alt="image-20220727204551005" /></p>
<ul>
<li><p>请求 东方不败：<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727204646055.png"
alt="image-20220727204646055" /></p></li>
<li><p>岳不群：看到别人发过来的请求 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727205511903.png"
alt="image-20220727205511903" /></p>
<p>可以同意 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727204751179.png"
alt="image-20220727204751179" /> 合并申请 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727204859648.png"
alt="image-20220727204859648" /></p></li>
</ul></li>
</ul>
<h1 id="ssh免密登录">SSH免密登录</h1>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727204931707.png"
alt="image-20220727204931707" />
<figcaption aria-hidden="true">image-20220727204931707</figcaption>
</figure>
<ul>
<li><p>ssh免密公钥添加 删除~/.ssh 使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa  -C xxxx@xx.com</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次到~/.ssh 查看</span></span><br><span class="line">cat id_rsa  私钥</span><br></pre></td></tr></table></figure></li>
<li><p>把私钥复制到 账号--设置--ssh and gpgkeys</p></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220727205152327.png"
alt="image-20220727205152327" />
<figcaption aria-hidden="true">image-20220727205152327</figcaption>
</figure>
<ul>
<li>测试是否成功</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git_尚硅谷</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_韩老师_01-06</title>
    <url>/2022/01/25/study/linux/hanshunping/01-06/</url>
    <content><![CDATA[<h2 id="基础介绍">基础介绍</h2>
<ul>
<li><p>本套课程内容<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1643095663069.png" /></p>
<ul>
<li>基础篇: linux入门、vm和Linux的安装、linux目录结构</li>
<li>实操篇
<ul>
<li>远程登录（xshell，xftp）、实用指令、进程管理、用户管理</li>
<li>vi和vim编辑器、定时任务调度、RPM和YUM</li>
<li>开机、重启和用户登录注销、磁盘分区及挂载、网络配置</li>
</ul></li>
</ul></li>
<li><p>linux使用的地方</p>
<ul>
<li>在linux下开发项目(需要把javaee项目部署到linux下运行)</li>
<li>linux运维工程师(服务器规划、优化、监控等)</li>
<li>linux嵌入式工程师(linux下驱动开发[c,c++])</li>
</ul></li>
<li><p>linux应用领域</p>
<ul>
<li>个人桌面</li>
<li>服务器(免费稳定高效)</li>
<li>嵌入式领域(对软件裁剪，内核最小可达几百kb等) ## linux介绍</li>
</ul></li>
<li><p>linux是一个开源免费操作系统</p></li>
<li><p>linux吉祥物<br />
tux(/tu'ks/唾可si)，没找到音标，将就一下<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1643096979670.png" /></p></li>
<li><p>linux之父，linus，也是git的创作者<br />
主要发行版：<strong>Ubuntu、RedHat，Centos</strong>，Debian等<br />
RedHat和Centos使用同样的源码，但是RedHat收费</p></li>
<li><p>Linux和Unix的关系<br />
unix也是一个操作系统，贝尔实验室。做一个多用户分时操作系统，
multics，但是没完成。其中一个后来在这基础上，完成的操作系统为unix
（原本是B语言写的），后面和另一个人用unix用c语言改写了。<br />
unix源码是公开的，后面商业公司拿来包装做成自己的系统，
后面有个人提倡自由时代用户应该对源码享有读写权利而非垄断<br />
后面RichardStallman发起GNU计划（开源计划），Linus参加该计划，并共享出linux内核，于是大家在此基础上开发出各种软件。linux又称GNU/linux<br />
</p></li>
<li><p>Linux和Unix关系<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1643098018271.png" />
## VMWare安装Centos7.6 在windows中安装Linux系统<br />
</p></li>
<li><p>VM和Linux系统在pc中的关系<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1643098209668.png" /></p></li>
<li><p>安装过程中，网络模式使用NAT模式</p></li>
<li><p>选择最小安装，且选择CompatibilityLibraries和DevelopmentTools<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1643100381319.png" /></p></li>
<li><p>linux分区<br />
一般分为三个<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1643100444776.png" /><br />
一般boot1G,swap分区一般跟内存大小一致，这里是2G，所以根分区就是剩下的，也就是20-1-2=17G<br />
如图，boot，/，swap都是标准分区。且boot和/是ext4的文件格式，swap是swap的文件格式<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1643100873342.png" /><br />
</p></li>
<li><p>修改主机名<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1643101039503.png" /></p></li>
<li><p>修改密码及增加除root外的普通用户</p></li>
<li><p>修改网络为固定ip(NAT模式下)</p>
<ul>
<li>先在VM里面把子网ip改了，这里改成 192.168.200.0<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1643101673327.png" /></li>
<li>然后改网关为192.168.200.200<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1643101741006.png" /></li>
<li>使用yum install -y vim 安装文本编辑工具</li>
<li>最后在linux中改配置文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure></li>
<li>其中先修改BOOTPROTO="static"</li>
<li>然后设置ip地址、网关和DNS，
下面是添加到上面的ifcfg-ens33后面，不是直接执行代码 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPADDR=192.168.200.200</span><br><span class="line">GATEWAY=192.168.200.2</span><br><span class="line">DNS1=192.168.200.2</span><br></pre></td></tr></table></figure></li>
<li>使用命令重启网络<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service network restart </span><br><span class="line"># 或者直接重启电脑 reboot</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>这里顺便装一下zsx<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure></p></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux_韩老师</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_韩老师_07-11</title>
    <url>/2022/05/10/study/linux/hanshunping/07-11/</url>
    <content><![CDATA[<h2 id="网络连接">网络连接</h2>
<ul>
<li>网络连接的三种模式 同一个教室的三个主机 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510204902224.png"
alt="image-20220510204902224" /> 此时三个同学可以正常通讯
<ul>
<li>桥接模式 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510205004081.png"
alt="image-20220510205004081" />
这是张三的虚拟机和外部互通；但是如果这样设置，ip会不够用；</li>
<li>NAT模式 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510205245256.png"
alt="image-20220510205245256" />
如图，虚拟机可以跟虚拟的网卡(192.168.100.99)互通，且通过这个虚拟网卡，及（192.168.0.50代理），与外界(192.168.0.X)互通
<strong>NAT模式，网络地址转换模式</strong>，虚拟系统和外部系统通讯，不造成IP冲突
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510205620317.png"
alt="image-20220510205620317" />
注意，这里外部其他主机(除0.50和100.99)是访问不到100.88的</li>
<li>主机模式：独立的系统</li>
</ul></li>
</ul>
<h2 id="虚拟机克隆">虚拟机克隆</h2>
<ul>
<li>方式1，直接拷贝整个文件夹 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510210154549.png"
alt="image-20220510210154549" /></li>
<li>方式2，使用VMWare 克隆前先把克隆目标关闭
克隆虚拟机当前状态--创建完整克隆</li>
</ul>
<h2 id="虚拟机快照">虚拟机快照</h2>
<ul>
<li><p>为什么需要虚拟机快照 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510210527420.png"
alt="image-20220510210527420" /></p></li>
<li><p>快照a <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510210626085.png"
alt="image-20220510210626085" /> 之后创建了文件夹hello 然后拍摄快照b
之后创建了文件夹hello2 然后拍摄快照c</p></li>
<li><p>目前 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510210820396.png" /></p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510210750325.png" /></p></li>
<li><p>回到快照A <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510210948723.png"
alt="image-20220510210948723" />
之后会重启，效果（两个文件夹都没有了)</p></li>
<li><p>如果恢复到B，然后再创建一个快照，就会变成 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510211106691.png"
alt="image-20220510211106691" /></p></li>
</ul>
<h2 id="虚拟机迁移">虚拟机迁移</h2>
<ul>
<li>直接剪切、删除，即可 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510211233012.png"
alt="image-20220510211233012" /></li>
</ul>
<h2 id="vmtools工具">vmtools工具</h2>
<ul>
<li>如下步骤，注意，这里只是在有界面的情况下进行安装 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510211404957.png"
alt="image-20220510211404957" /></li>
<li>安装完毕后
<ul>
<li>在vm上面设置 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510211547484.png"
alt="image-20220510211547484" /></li>
<li>共享文件夹在linux中的路径 /mnt/hgfs/myshare</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux_韩老师</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_韩老师_12-20</title>
    <url>/2022/05/10/study/linux/hanshunping/12-20/</url>
    <content><![CDATA[<h2 id="目录结构">目录结构</h2>
<ul>
<li><p>目录结构很重要</p>
<ul>
<li><p>windows下 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522000912102.png"
alt="image-20220522000912102" /></p></li>
<li><p>linux下，从根目录开始分支 /，/root （root用户），/home
（创建的用户的目录），/bin（常用的指令），/etc（环境配置）</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522001122602.png"
alt="image-20220522001122602" />
<figcaption aria-hidden="true">image-20220522001122602</figcaption>
</figure></li>
<li><p>在linux世界里，一切皆文件</p>
<ul>
<li><p>cpu被映射成文件</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522001224676.png"
alt="image-20220522001224676" />
<figcaption aria-hidden="true">image-20220522001224676</figcaption>
</figure></li>
<li><p>硬盘 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522001301074.png"
alt="image-20220522001301074" /></p></li>
</ul></li>
</ul></li>
<li><p>具体的目录结构</p>
<ul>
<li><p>/bin 常用，binary的缩写，存放常用的命令
(/usr/bin、/usr/local/bin) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522075228619.png"
alt="image-20220522075228619" /></p></li>
<li><p>/sbin （/usr/sbin、/usr/local/sbin）
SuperUser，存放的是系统管理员使用的系统管理程序</p></li>
<li><p>/home 存放普通用户的主目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd jack</span><br></pre></td></tr></table></figure>
<ul>
<li>之后看该目录 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522075446031.png"
alt="image-20220522075446031" /></li>
<li>删掉 <code>userdel -r jack</code> 目录消失</li>
</ul></li>
<li><p>/root 该目录为系统管理员，也称超级管理员的用户的主目录</p></li>
<li><p>/lib
系统开机所需要的最基本的动态连接共享库，其作用类似于windows里的DLL，几乎所有的应用程序都需要用到这些共享库</p></li>
<li><p>lost+found 一般为空，非法关机后会存放文件</p></li>
<li><p>/etc
系统管理所需要的配置文件和子目录，比如mysql的my.conf</p></li>
<li><p>/usr 用户的应用程序和文件，类似windows的program files</p></li>
<li><p>/boot 启动Linux时使用的核心文件（破坏则无法启动）</p></li>
<li><p><strong>/proc （不能动）</strong>
虚拟目录，系统内存的映射，访问这个目录获取系统信息</p></li>
<li><p><strong>/srv （不能动）</strong>
service的缩写，存放服务启动之后需要提取的数据</p></li>
<li><p><strong>/sys （不能动）</strong> 安装了2.6内核中新出现的文件系统
sysfs</p></li>
<li><p>/tmp 这个目录用来存放一些临时文件</p></li>
<li><p>/dev 类似windows设备管理器，将硬件映射成文件</p></li>
<li><p>/media
linux系统会自动识别一些设备，u盘、光驱，将识别的设备映射到该目录下</p></li>
<li><p>/mnt
为了让用户挂载别的文件系统，比如将外部的存储<em>挂载</em>到该目录 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522081548378.png"
alt="image-20220522081548378" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522081602965.png"
alt="image-20220522081602965" /></p></li>
<li><p>/opt 给主机额外安装软件所存放的目录</p></li>
<li><p>/usr/local
给主机额外安装软件所安装的目录，一般通过编译源码方式安装的程序</p></li>
<li><p>/var 日志，不断扩充的东西 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522081810597.png"
alt="image-20220522081810597" /></p></li>
<li><p>/selinux [security-enhanced linux]
安全子系统，控制程序只能访问特定文件 (启用之后才能看到)</p></li>
</ul></li>
</ul>
<h2 id="远程登陆">远程登陆</h2>
<ul>
<li>背景
<ul>
<li>linux服务器开发小组共享</li>
<li>正式上线项目运行在公网，所以需要远程开发部署</li>
<li>图解 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522082218860.png"
alt="image-20220522082218860" /></li>
</ul></li>
<li>软件 xshell 和xftp https://www.xshell.com/zh/free-for-home-school/
<ul>
<li>使用ifconfig 查看ip 先添加网络工具包
<code>yum install net-tools -y</code></li>
<li>使用 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522082707244.png"
alt="image-20220522082707244" /></li>
</ul></li>
<li>在客户端打开cmd，并使用<code>ping</code>命令</li>
<li>xshell中配置并进行连接 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522082829668.png"
alt="image-20220522082829668" /></li>
<li>按住ctrl+鼠标滚轴可以放大字体</li>
</ul>
<h2 id="远程文件传输">远程文件传输</h2>
<ul>
<li>xtfp6 person安装</li>
<li>新建连接配置 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522120211846.png"
alt="image-20220522120211846" /></li>
<li>文件夹 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522120249203.png"
alt="image-20220522120249203" /></li>
<li>可以在这里直接复制上传</li>
<li>图解 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522120426746.png"
alt="image-20220522120426746" /></li>
<li>解决乱码问题 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522120511107.png"
alt="image-20220522120511107" /></li>
<li>reboot <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522120554457.png"
alt="image-20220522120554457" /></li>
</ul>
<h2 id="vim快捷键">vim快捷键</h2>
<ul>
<li><p>vi ：linux内置vi文本编辑器
vim是vi的增强版本，有丰富的字体颜色</p></li>
<li><p>常用的三种模式</p>
<ul>
<li>正常模式，使用上下左右、复制粘贴</li>
<li>插入模式 正常模式--&gt;插入模式 按下i I o O a A r R（一般用i）</li>
<li>命令行模式 插入模式--&gt;命令行 输入输入esc表示退出，然后输入:
<ul>
<li>输入wq表示保存并退出</li>
</ul></li>
</ul></li>
<li><p>编辑，重新vim Hello.java 下面，这时候按tab可以自动补全 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522121244481.png"
alt="image-20220522121244481" /></p></li>
<li><p>命令 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522121433794.png"
alt="image-20220522121433794" /></p></li>
<li><p>快捷键使用</p>
<ul>
<li><p>正常模式下</p>
<ul>
<li><p>输入yy，拷贝当前行。p进行粘贴
4yy，拷贝当前行(包括)往下4行</p></li>
<li><p>输入dd，删除当前行 4dd，删除当前行（包括）往下4行</p></li>
<li><p>定位到首行(gg)或者末行G</p></li>
<li><p>使用u，撤回刚才的输入(lalala将被撤回) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522123547550.png"
alt="image-20220522123547550" /></p></li>
<li><p>定位到20行 （20+shift+g）【其实是20+G】</p></li>
</ul></li>
<li><p>命令模式 ：切换到命令行)</p>
<ul>
<li><p>命令行模式下（：下），输入 /搜索内容</p>
<p>或者（/）下，直接输入搜索内容</p></li>
<li><p>再次输入 / ，就会清空前面的搜索</p></li>
<li><p>设置文件行号（：下） <code>set nu</code>
设置；<code>set nonu</code> 取消 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522122502460.png"
alt="image-20220522122502460" /></p></li>
</ul></li>
</ul></li>
<li><p>如果修改太多，需要先拷贝到windows下，然后再传上来</p></li>
<li><p>vim/vi 快捷键 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522123941924.png"
alt="image-20220522123941924" /></p></li>
</ul>
<h2 id="关机重启">关机重启</h2>
<ul>
<li><p>命令 halt 停止</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">shutdown -h now  #立刻关机</span><br><span class="line">shutdown -h 1 #给出提示并关机</span><br><span class="line">shutdown -r now #现在重启计算机</span><br><span class="line">halt #立刻关机(虚拟机好像只是把cpu关闭？)</span><br><span class="line">reboot #立刻重启</span><br><span class="line">sync #将内存的数据同步到磁盘</span><br></pre></td></tr></table></figure>
<ul>
<li><figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522124227911.png"
alt="image-20220522124227911" />
<figcaption aria-hidden="true">image-20220522124227911</figcaption>
</figure></li>
<li><p><code>sync #将内存的数据同步到磁盘</code> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522124509158.png"
alt="image-20220522124509158" /></p>
<ul>
<li>shutdown/reboot/halt等命令都会在执行前执行sync</li>
</ul></li>
</ul></li>
</ul>
<h2 id="登录注销">登录注销</h2>
<ul>
<li><p>尽量不要用root账号登录</p></li>
<li><p>普通用户登陆后，用su - 用户名 切换成系统管理员身份 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522125607501.png"
alt="image-20220522125607501" /></p></li>
<li><p>logout 注销用户（图形页面没效果） 在运行级别3下有效 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522125622253.png"
alt="image-20220522125622253" /></p></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux_韩老师</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_韩老师_21-33</title>
    <url>/2022/05/22/study/linux/hanshunping/21-27/</url>
    <content><![CDATA[<h2 id="用户管理">用户管理</h2>
<ul>
<li><p>使用<code>ssh root@192.168.200.201</code>进行服务器连接 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522180504499.png"
alt="image-20220522180504499" /></p></li>
<li><p>xshell中 ctr+shift+r 用来重新连接</p></li>
<li><p>用户解释图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522165637734.png"
alt="image-20220522165637734" /></p></li>
<li><p>添加一个用户milan，会自动创建该用户的家目录milan</p>
<ul>
<li>当登录该用户时，会自动切换到家目录下 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522170347364.png"
alt="image-20220522170347364" /></li>
</ul></li>
<li><p>指定家目录 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522170437591.png"
alt="image-20220522170437591" /></p></li>
<li><p>指定密码 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522170608319.png"
alt="image-20220522170608319" /></p></li>
<li><p>用milan登录，自动切换到/home/milan pwd:显示当前用户所在的目录</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522170757392.png"
alt="image-20220522170757392" />
<figcaption aria-hidden="true">image-20220522170757392</figcaption>
</figure></li>
<li><p>用户删除</p>
<ul>
<li>删除用户但保留家目录
<ul>
<li>需要用超级管理员才能删除 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522171044636.png"
alt="image-20220522171044636" />
使用<code>su -u root</code>切换到超级管理员</li>
<li>先logout然后再删除 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522171722606.png"
alt="image-20220522171722606" /></li>
</ul></li>
<li>删除用户及家目录 <code>userdel -r milan</code></li>
<li>建议保留家目录</li>
</ul></li>
<li><p>查询root用户信息</p>
<ul>
<li>使用<code>id xx</code> 查询 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522173031872.png"
alt="image-20220522173031872" /></li>
</ul></li>
<li><p>切换用户 <code>su - xx</code></p>
<ul>
<li>从权限高切换到权限低的用户不需要密码；反之需要 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522173624726.png"
alt="image-20220522173624726" /></li>
<li>使用logout（exit也行），从root用户回到jack</li>
</ul></li>
<li><p>查看当前用户 <code>who am i</code> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522173754140.png"
alt="image-20220522173754140" />
即使切换了用户，返回的还是root（第一次登录时的用户) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522173907316.png"
alt="image-20220522173907316" /></p></li>
<li><p>用户组（角色）</p>
<ul>
<li><p>增加、删除组</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd wudang</span><br><span class="line">groupdel wudang</span><br></pre></td></tr></table></figure></p>
<p>如果添加用户的时候没有指定组，那么会创建一个跟用户名一样的名字的组
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522180913637.png"
alt="image-20220522180913637" /> id是1002，组为king</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522181001626.png"
alt="image-20220522181001626" />
<figcaption aria-hidden="true">image-20220522181001626</figcaption>
</figure></li>
<li><p>添加用户zwj，添加组wudang，并将zwj添加到wudang组里面</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd wudang</span><br><span class="line">useradd -g wudang zwj</span><br></pre></td></tr></table></figure></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522181322509.png"
alt="image-20220522181322509" />
<figcaption aria-hidden="true">image-20220522181322509</figcaption>
</figure></li>
<li><p>修改用户所在组</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd mojiao</span><br><span class="line">usermod -g mojiao zwj</span><br></pre></td></tr></table></figure></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522181459120.png"
alt="image-20220522181459120" />
<figcaption aria-hidden="true">image-20220522181459120</figcaption>
</figure></li>
</ul></li>
<li><p>关于用户和组相关的文件</p>
<ul>
<li><p>/etc/passwd 每行的含义 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522181730546.png"
alt="image-20220522181730546" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522182046280.png"
alt="image-20220522182046280" />
<figcaption aria-hidden="true">image-20220522182046280</figcaption>
</figure>
<ul>
<li><p>shell 解释和翻译指令 一般用bash，还有其他，很多</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522181937954.png"
alt="image-20220522181937954" />
<figcaption aria-hidden="true">image-20220522181937954</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522182605848.png"
alt="image-20220522182605848" />
<figcaption aria-hidden="true">image-20220522182605848</figcaption>
</figure></li>
</ul></li>
<li><p>/etc/shadow 口令配置文件</p>
<p>每行的含义 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522182244186.png"
alt="image-20220522182244186" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522182201123.png"
alt="image-20220522182201123" />
<figcaption aria-hidden="true">image-20220522182201123</figcaption>
</figure></li>
<li><p>/etc/group 记录组的信息 组名：口令：组标识号：组内用户列表</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522182432698.png"
alt="image-20220522182432698" />
<figcaption aria-hidden="true">image-20220522182432698</figcaption>
</figure></li>
</ul></li>
</ul>
<h2 id="运行级别">运行级别</h2>
<ul>
<li><p>基本介绍</p>
<ul>
<li>0 关机</li>
<li>1 单用户（找回密码）</li>
<li>2 多用户状态没有网络服务</li>
<li>3 多用户状态有网络服务</li>
<li>4系统未使用保留给用户</li>
<li>5 图形界面</li>
<li>6 系统重启</li>
</ul></li>
<li><p>在图形界面输入<code>init 3</code> 会直接进入终端界面</p>
<ul>
<li>之后输入<code>init 5</code> 会重新进入图形界面</li>
</ul></li>
<li><p><code>init 0</code>会直接关机</p></li>
<li><p>指定默认级别 centosOS7之前，在/etc/inittab文件中
之后进行了简化，如下 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522210857114.png"
alt="image-20220522210857114" /></p></li>
<li><p>查看默认级别</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl get-default</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">multi-user.target</span> </span><br></pre></td></tr></table></figure></li>
<li><p>设置默认级别</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="找回root密码">找回root密码</h2>
<ul>
<li><p>这里讲的是centos os7之后</p></li>
<li><p>重启后，立马按e</p></li>
<li><p>然后光标往下滑 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522211551545.png"
alt="image-20220522211551545" /></p>
<ul>
<li><p>在utf-8后面，加入 init=/bin/sh （进入单用户实例，注意
这里不要加入空格）</p></li>
<li><p>然后ctrl+x 表示启动</p></li>
<li><p>然后输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -o remount,rw /</span><br><span class="line">passwd</span><br></pre></td></tr></table></figure></li>
<li><p>修改成功 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522212928883.png"
alt="image-20220522212928883" /></p></li>
<li><p>然后再输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch /.autorelabel </span><br><span class="line">exec /sbin/init</span><br></pre></td></tr></table></figure></li>
<li><p><code>exec /sbin/init</code>之后时间比较长，等待一会，密码则生效</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522213539781.png"
alt="image-20220522213539781" />(卡住两三分钟)</p></li>
<li><p>ssh root@192.168.200.201 登录成功</p></li>
</ul></li>
</ul>
<h2 id="帮助指令">帮助指令</h2>
<ul>
<li><p>man ls <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522215502058.png"
alt="image-20220522215502058" /></p>
<ul>
<li>linux中，隐藏文件以 . 开头（以点开头）</li>
<li>输入q退出man</li>
<li>ls选项可以组合使用</li>
<li>ls -l 单列输出(use a long listing format)，信息最全 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522215644598.png"
alt="image-20220522215644598" /></li>
<li><code>ls -la</code> 单列输出，包括隐藏文件 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522215823025.png"
alt="image-20220522215823025" /></li>
<li><code>ls -al /root</code> 显示/root目录下的内容</li>
</ul></li>
<li><p>help 内置命令的帮助信息</p>
<ul>
<li>该命令在zsh下不能用，所以使用下面指令切换 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/bash #zsh切换到bash，重启后生效</span><br><span class="line">chsh -s /bin/zsh #bash切换到zsh，重启后生效</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p><code>help cd</code> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220522220929771.png"
alt="image-20220522220929771" /></p>
<ul>
<li>End</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux_韩老师</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_韩老师_28-39</title>
    <url>/2022/05/22/study/linux/hanshunping/28-39/</url>
    <content><![CDATA[<h2 id="文件目录">文件目录</h2>
<ul>
<li><p>用来定位绝对路径或相对路径 cd ~ 用来定位家目录 cd .. 返回上一级
cd - 返回上一次目录</p></li>
<li><p>mkdir 用于创建目录 mkdir -p hello/l1/l2 多级目录创建</p></li>
<li><p>recursion 递归 rm -rf 要删除的目录 #递归删除</p></li>
<li><p>使用cp进行复制，加上 -r 进行递归复制</p></li>
<li><p>rm 删除某个文件（带提示）</p>
<ul>
<li>rm -f 删除文件（不带提示）</li>
<li>rm -rf 强制删除递归文件（夹）</li>
</ul></li>
<li><p>mv 用来重命名（移动到同一目录下）、（或者移动文件）</p></li>
<li><p>注意，下面的命令，是将hello移动到hello2下，并改名为a（而不是hello2下的a目录）
<code>mv Hello.java hello2/a</code></p>
<ul>
<li><code>mv Hello.java hello2/a/</code>
移动到hello2下的a目录下(最后有一个斜杠)</li>
</ul></li>
<li><p>移动目录</p>
<ul>
<li><p><code>mv hello2 hello1/AB</code> 或者
<code>mv hello2/ hello1/AB</code></p>
<p>或者 <code>mv hello2/ hello1/AB/</code></p>
<p>会把整个hello2文件夹（包括hello2）移动到AB下</p></li>
<li><p>同样是上面的指令，如果AB不存在，那么就会将hello2移动到hello1下，并将hello2文件夹，改名为AB</p></li>
</ul></li>
<li><p>cat 指令</p>
<ul>
<li>cat -p /etc/profile 浏览并显示文件</li>
<li>管道命令 cat -p /etc/profile | more 把前面的结果再交给more处理
（输入enter查看下一行，空格查看下一页）</li>
</ul></li>
<li><p>less指令</p>
<ul>
<li><code>less /etc/profile</code></li>
<li>less指令显示的时候，是按需加载内容，效率较高, q退出</li>
</ul></li>
<li><p>echo 输出到控制台</p>
<ul>
<li><code>echo $HOSTNAME</code> 输出环境变量</li>
</ul></li>
<li><p>head 文件前几行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">head -3 /etc/profile #查看文件前三行</span><br></pre></td></tr></table></figure></li>
<li><p>tail 文件后几行</p>
<ul>
<li>实时监控 <code>tail -f mydate.txt</code></li>
<li>覆盖 echo "hello" &gt; mydate.txt</li>
<li>追加 echo "hi" &gt;&gt; mydate.txt</li>
<li><code>cal &gt; mydate.txt</code> 将日志添加到文件后</li>
</ul></li>
<li><p>ln指令 <code>ln -s /root/ /home/myroot</code>
在home下创建一个软链接，名为myroot，连接到root <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625111839310.png"
alt="image-20220625111839310" /></p>
<ul>
<li>此时cd myroot，就会进入root文件夹</li>
<li>使用rm -f 删除软连接</li>
<li>动态链接库 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625112225096.png"
alt="image-20220625112225096" /></li>
</ul></li>
<li><p>history 查看曾经执行过的命令 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625112304045.png"
alt="image-20220625112304045" /></p></li>
<li><p>! + 数字，执行曾经执行过的指令 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625112404167.png"
alt="image-20220625112404167" /></p></li>
</ul>
<h2 id="时间日期">时间日期</h2>
<ul>
<li>date指令-- 显示当前日期
<ul>
<li>date <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625115448968.png"
alt="image-20220625115448968" /></li>
<li>date +%Y 年份</li>
<li>date +%m 月份</li>
<li>date +%d 哪一天</li>
<li>date "+%Y-%m-%d %H:%M:%S" 年月日时分秒</li>
</ul></li>
<li>cal 2020 #2020年所有日历</li>
</ul>
<h2 id="查找指令">查找指令</h2>
<ul>
<li><p>find /home -name hello.txt 在/home目录下，按名字查找hello.txt
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625171329905.png"
alt="image-20220625171329905" /></p></li>
<li><p>find /home -user tom 按拥有者查找</p></li>
<li><p>find / -size -10M | more 查找小于10M的文件 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625171702139.png"
alt="image-20220625171702139" /></p></li>
<li><p>ls -lh (h,以更符合人类查看的的方式显示) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625171829876.png"
alt="image-20220625171829876" /></p></li>
<li><p>locate 搜索文件 （locate之前要使用updatedb指令创建） (先使用yum
install -y mlocate 进行安装)</p></li>
<li><p>进行查找 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625172105001.png"
alt="image-20220625172105001" /></p></li>
<li><p>which ls 查看ls在哪个目录下 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625172523337.png"
alt="image-20220625172523337" /></p></li>
<li><p>grep 过滤查找，管道符，"|"
表示将前一个命令的处理结果输出传递给后面的命令处理</p>
<p>cat /etc/profile | grep 22 -n -i <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625173029491.png"
alt="image-20220625173029491" /></p></li>
</ul>
<h2 id="压缩和解压">压缩和解压</h2>
<ul>
<li>使用gzip 和 gunzip <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625174456544.png"
alt="image-20220625174456544" /></li>
<li>tar 用来压缩或者解压 压缩后的格式 .tar.gz</li>
<li>选项说明
<ul>
<li>-c 产生.tar打包文件</li>
<li>-v 显示详情信息</li>
<li>-f 指定压缩后的文件名</li>
<li>-z 打包同时压缩</li>
<li>-x 解包.tar文件</li>
</ul></li>
<li>使用
<code>tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt</code></li>
<li>解压 tar -zxvf pc.tar.gz</li>
<li>解压到指定的目录 <code>tar -zxvf pc.tar.gz -C tom/</code></li>
</ul>
<h2 id="section"></h2>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux_韩老师</tag>
      </tags>
  </entry>
  <entry>
    <title>linux_韩老师_40-51</title>
    <url>/2022/06/25/study/linux/hanshunping/40-51/</url>
    <content><![CDATA[<h2 id="组介绍">组介绍</h2>
<ul>
<li>每个用户必定属于某个组</li>
<li>每个文件有几个概念：所有者、所在组、其他组
tom创建了hello.txt，则所有者为tom，默认所在组为tom组
除了所在组，就是其他组</li>
<li>ls -ahl （h更友好，a隐藏，l列表）</li>
<li></li>
</ul>
<h2 id="所有者">所有者</h2>
<ul>
<li>使用chown root helo.java 修改，效果如下 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625210209090.png"
alt="image-20220625210209090" /></li>
</ul>
<h2 id="所在组修改">所在组修改</h2>
<ul>
<li>组的创建 groupadd monster</li>
<li>创建一个用户并让他属于该组 useradd -g monster fox</li>
<li>注意逻辑，此时使用fox创建文件 passwd fox 给fox创建密码</li>
<li>如图，创建一个文件 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625211309539.png"
alt="image-20220625211309539" /></li>
<li>使用chgrp fruit orange.txt 修改文件的所在组 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625211606756.png"
alt="image-20220625211606756" /></li>
<li>改变某个用户所在组 usermod -g fruit fox <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220625211830725.png"
alt="image-20220625211830725" /></li>
<li>使用 cat /etc/group 查看所有的组</li>
<li>当一个用户属于多个组的时候，groups会出现多个组名</li>
</ul>
<h2 id="rwx权限">rwx权限</h2>
<p>rwxrwxrwx 第一列有十位，第0位确认文件类型
-普通文件，l是链接；d是目录；c是字符设备文件、鼠标、键盘；b块设备
1-3表示文件所有者拥有的权限；4-6是文件所在组所拥有的权限，7-9
其他组所拥有的权限</p>
<ul>
<li><p>rwx作用到文件，r代表可读可查看，w代表可修改（如果是删除权限，则必须在该文件所在的目录有写权限，才能删除），x代表可执行</p></li>
<li><p>rwx作用到目录，r表示可以读取(ls可查看目录内容)，w表示可写（可以在目录内创建、删除、重命名目录），x表示可以进入该目录</p></li>
<li><p>rwx分别用数字表示，4，2，1。当拥有所有权限，则为7</p></li>
<li><figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626113838606.png"
alt="image-20220626113838606" />
<figcaption aria-hidden="true">image-20220626113838606</figcaption>
</figure>
<ul>
<li>最后面的数字，代表连接数（或者子目录数）</li>
<li>1213 文件大小（字节），如果是文件夹则显示4096</li>
<li>最后abc表示文件名，蓝色表示是目录</li>
</ul></li>
</ul>
<h2 id="修改权限">修改权限</h2>
<ul>
<li>chmod 修改权限，u：所有者，g：所有组，o：其他人，a
所有（ugo总和）</li>
<li>chmod u=rwx,g=rw,o=x 文件/目录名 这里等号表示直接给权限</li>
<li>chmod o+w 文件/目录名 这里加表示+权限</li>
<li>chmod a-x 文件/目录名</li>
<li>chmod u=rwx,g=rx,o=rx abc 给文件添加执行权限（会变成绿色的）</li>
<li>使用数字
<ul>
<li>将abc.txt文件权限修改成rwxr-xr-x使用数字实现 chmod 755 abc</li>
<li></li>
</ul></li>
</ul>
<h2 id="修改所有者和所在组">修改所有者和所在组</h2>
<ul>
<li>chown tom abc #修改文件所有者为tom</li>
<li>chown -R tom abc #修改文件夹及其所有子目录所有者为tom</li>
<li>chgrp -R fruit kkk #修改文件夹所在组为fruit</li>
</ul>
<h2 id="权限管理应用实例">权限管理应用实例</h2>
<ul>
<li><p>警察和土匪的游戏</p>
<p>前提，有police和bandit两个组，</p>
<p>jack，jerry属于警察组</p>
<p>xh，xq属于土匪组</p>
<ul>
<li><pre class="shell"><code>  groupadd police
  groupadd bandit
  useradd -g police jack
  useradd -g police jerry
  useradd -g bandit xh
  useradd -g bandit xq</code></pre></li>
</ul></li>
<li><p>chmod 640 jack.txt</p></li>
<li><p>chmod o=r,g=rw jack.txt</p></li>
<li><p>如果要对目录内操作，那么先有改目录相应权限</p>
<ul>
<li>chmod 770 jack 放开jack目录权限</li>
</ul></li>
<li></li>
</ul>
<p>题目 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626135938689.png"
alt="image-20220626135938689" /></p>
<p>对一个目录不能ls(没有读权限)，但是是可以直接读写目录中的文件的（有权限的情况下）</p>
<h2 id="section"></h2>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux_韩老师</tag>
      </tags>
  </entry>
  <entry>
    <title>52-X</title>
    <url>/2022/06/26/study/linux/hanshunping/52-X/</url>
    <content><![CDATA[<h2 id="crond快速入门">crond快速入门</h2>
<ul>
<li><p>使用命令 crontab -e 创建一个定时任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*/1 * * * * ls -l /etc/ &gt; /tmp/to.txt</span><br></pre></td></tr></table></figure></li>
<li><p>特殊符号 ，代表不连续 -破折号 表示连续 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626213003228.png"
alt="image-20220626213003228" /></p></li>
<li><p>其他 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626213032958.png"
alt="image-20220626213032958" /></p></li>
<li><p>定时调用脚本</p>
<ul>
<li><p>编辑脚本 my.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date &gt;&gt; /home/mycal</span><br><span class="line">date &gt;&gt; /home/mycal</span><br></pre></td></tr></table></figure></li>
<li><p>给脚本赋予x权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod u+x my.sh</span><br></pre></td></tr></table></figure></li>
<li><p>crontab -e</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*/1 * * * * my.sh</span><br></pre></td></tr></table></figure></li>
<li><p>数据库备份 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626213947157.png"
alt="image-20220626213947157" /></p></li>
<li><p>crontab -r 删除</p></li>
<li><p>crontab -l 列出</p></li>
<li><p>crontab -e 编辑任务</p></li>
</ul></li>
<li><p>atd 是否在运行 yum install -y atd systemctl start atd</p></li>
<li><p>job队列 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626215635347.png"
alt="image-20220626215635347" /></p></li>
<li><p>at选项 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626215716700.png"
alt="image-20220626215716700" /></p></li>
<li><p>at指定时间 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626215801620.png"
alt="image-20220626215801620" /></p></li>
<li><p>添加任务 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626215928419.png"
alt="image-20220626215928419" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626220003771.png"
alt="image-20220626220003771" /></p></li>
<li><p>at 5pm tomorrow 明天下午5点</p></li>
<li><p>at now + 2 minutes 2分钟后</p></li>
<li><p>atrm 5 删除5号</p></li>
<li><p>两分钟后执行某个脚本 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626220501514.png"
alt="image-20220626220501514" /></p></li>
</ul>
<h2 id="磁盘分区">磁盘分区</h2>
<ul>
<li>分区跟文件系统的关系 (挂载) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626222050964.png"
alt="image-20220626222050964" />
<ul>
<li>将一个分区挂载到某个目录，用户进入到某个目录，就相当于访问到某个分区了</li>
</ul></li>
<li>lsblk <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626222256630.png"
alt="image-20220626222256630" /></li>
<li>linux分IDE硬盘和SCSI硬盘 目前基本是SCSI硬盘</li>
<li>sdx~ x代表abcd，~表示数字 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626222510701.png"
alt="image-20220626222510701" /></li>
<li>lsblk -f <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626222614058.png"
alt="image-20220626222614058" />
<ul>
<li>文件类型，唯一标识符</li>
</ul></li>
<li>现在挂载一个分区
<ul>
<li>如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626222807308.png"
alt="image-20220626222807308" /></li>
<li>给虚拟机，添加一个硬盘 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626223028438.png"
alt="image-20220626223028438" /></li>
<li>重启后，使用lsblk <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626223150450.png"
alt="image-20220626223150450" /></li>
<li>进行分区
<ul>
<li>fdisk /dev/sdb <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626223337715.png"
alt="image-20220626223337715" /></li>
<li>之后输入p，</li>
<li>输入分区数（这里是1）</li>
<li>最后一步，输入w ，写入分区并退出</li>
<li>查看 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626223525243.png"
alt="image-20220626223525243" /></li>
</ul></li>
<li>将分区格式化 mkfs -t ext4 /dev/sdb1
<ul>
<li>查看 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626223655104.png"
alt="image-20220626223655104" /></li>
</ul></li>
<li>进行挂载 mount /dev/sdb1 /newdisk/ <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626223904432.png"
alt="image-20220626223904432" /></li>
<li>umount /dev/sdb1 卸载 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626224039049.png"
alt="image-20220626224039049" /></li>
<li>用命令行挂载的指令，重启后挂载关系会消失 永久挂载：修改/etc/fstab
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626224212404.png"
alt="image-20220626224212404" />
<ul>
<li><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626224503064.png"
title="fig:" alt="image-20220626224503064" /></li>
</ul></li>
</ul></li>
<li>df -h 查看磁盘使用情况 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220626224736953.png"
alt="image-20220626224736953" /></li>
<li>du -h --max-depth=1 /opt</li>
<li>ls -l /opt | grep "^-" | wc -l 使用正则，并统计数量</li>
<li>ls -lR /opt 注意，这里加了R，将递归显示</li>
<li>使用yum install -y tree <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627211916834.png"
alt="image-20220627211916834" /></li>
</ul>
<h2 id="网络配置">网络配置</h2>
<ul>
<li><p>ifconfig 查看ip</p></li>
<li><p>网络的互通 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627214540151.png"
alt="image-20220627214540151" /></p></li>
<li><p>虚拟网络编辑器 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627214641445.png"
alt="image-20220627214641445" /></p></li>
<li><p>使用ping判断主机间是否互通</p></li>
<li><p>vi /etc/sysconfig/network-scripts/ifcfg-ens33 编辑ip</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;8c2741af-382a-44a6-b161-aed16a29875d&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line"></span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">IPADDR=192.168.200.160</span><br><span class="line">GATEWAY=192.168.200.2</span><br><span class="line">DNS1=192.168.200.2</span><br></pre></td></tr></table></figure>
<ul>
<li>注意最后五行</li>
</ul></li>
<li><p>修改hostname vim /etc/hostname</p></li>
</ul>
<h2 id="进程">进程</h2>
<ul>
<li>每一个执行的程序被称为一个进程，每一个进程都分配一个ID号-</li>
<li>每个进程都可以以前台/后台方式运行</li>
<li>一半系统服务以后台进程方式存在的</li>
<li>使用ps显示进程 ps -aux</li>
<li>一些参数解释 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627215758624.png"
alt="image-20220627215758624" /></li>
<li>使用grep过滤 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627215851994.png"
alt="image-20220627215851994" /></li>
<li>进程的父进程 ps -ef <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627220040122.png"
alt="image-20220627220040122" />
<ul>
<li>由systemd生成启动其他进程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627220109916.png"
alt="image-20220627220109916" /></li>
<li><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627220212058.png"
title="fig:" alt="image-20220627220212058" /></li>
</ul></li>
<li>子进程之间关系 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627220313798.png"
alt="image-20220627220313798" /></li>
<li>进程的终止 kill / killall
<ul>
<li>killall 将子进程一起杀死 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627220428882.png"
alt="image-20220627220428882" /></li>
<li>kill -9 强制终止 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627220734955.png"
alt="image-20220627220734955" /></li>
<li>如果把sshd杀死，那就再也连不上了 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627220924098.png"
alt="image-20220627220924098" /></li>
<li>重新启动sshd /bin/systemctl start sshd.service <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627221018337.png"
alt="image-20220627221018337" /></li>
<li>yum -y install psmisc</li>
<li>pstree -u 带上用户</li>
<li>pstree -p 带上进程号</li>
</ul></li>
</ul>
<h2 id="服务管理">服务管理</h2>
<ul>
<li>服务，本质上就是进程</li>
<li>service 服务名 start|stop|restart|reload|status</li>
<li>centos7.0之后，主要用systemctl</li>
<li>还使用service的命令 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627221640674.png"
alt="image-20220627221640674" /></li>
<li>网络连接查看 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627221719767.png"
alt="image-20220627221719767" /></li>
<li>服务的运行级别 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627221837794.png"
alt="image-20220627221837794" /></li>
<li><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220627221921940.png"
alt="image-20220627221921940" /> systemctl set-default graphical.target
//默认进入图形化界面</li>
<li></li>
</ul>
<h2 id="rpm管理">rpm管理</h2>
<h2 id="软件包管理">软件包管理</h2>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux_韩老师</tag>
      </tags>
  </entry>
  <entry>
    <title>01-21 maven多模块管理_动力节点</title>
    <url>/2022/07/17/study/maven/advance_dljd/01-21/</url>
    <content><![CDATA[<h2 id="场景介绍">场景介绍</h2>
<ul>
<li>业务依赖 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717111347798.png"
alt="image-20220717111347798" /></li>
<li>多模块管理 版本管理 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717111541819.png"
alt="image-20220717111541819" /></li>
</ul>
<h2 id="第1种方式">第1种方式</h2>
<h3 id="创建父工程">创建父工程</h3>
<ul>
<li><p>先创建一个空项目 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717114553244.png"
alt="image-20220717114553244" /></p></li>
<li><p>在这个空项目下，创建一个module当作maven父工程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717115140216.png"
alt="image-20220717115140216" /></p></li>
<li><p>结构 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717115232222.png"
alt="image-20220717115232222" /></p></li>
<li><p>pom文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>001-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     packaging 标签指定打包方式，默认为jar</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        maven父工程必须遵守以下两点要求</span></span><br><span class="line"><span class="comment">        1、packaging标签的文本内容必须设置为pom</span></span><br><span class="line"><span class="comment">        2、把src删除</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="介绍pom文件">介绍pom文件</h3>
<p>pom 项目对象模型，project object model，该文件可以子工程被继承
maven多模块管理，其实就是让它的子模块的pom文件来继承父工程的pom</p>
<h3 id="创建maven-java子工程">创建maven java子工程</h3>
<ul>
<li><p>新建一个module</p>
<p>注意路径，002在IDEA-maven的目录下 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717212253387.png"
alt="image-20220717212253387" /></p></li>
<li><p>查看pom文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指向父工程的gav坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>001-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--相对路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../001-maven-parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>002-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="创建maven-web子工程">创建maven web子工程</h3>
<ul>
<li><p>创建新模块 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220718230918949.png"
alt="image-20220718230918949" /></p></li>
<li><p>查看pom</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>001-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../001-maven-parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>003-maven-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="修改子工程为父工程">修改子工程为父工程</h3>
<p>​ 1 父工程的pom.xml种的packaging标签的文本内容必须设置pom</p>
<p>​ 2 删除src目录</p>
<ul>
<li><p>如图，比如这里修改002-maven-java为父工程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719211746353.png"
alt="image-20220719211746353" /></p></li>
<li><p>添加004为002的子工程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719212412870.png"
alt="image-20220719212412870" /></p></li>
<li><p>查看pom文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>002-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../002-maven-java/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>004-maven-java-1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3
id="手动修改maven工程为子工程非idea中">手动修改Maven工程为子工程(非idea中)</h3>
<ul>
<li><p>这里说的是，创建子工程的时候，没有选择父工程
创建完之后的pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>005-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改（添加parent标签即可）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>001-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../001-maven-parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>005-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719214101482.png"
alt="image-20220719214101482" /></p></li>
</ul>
<h3 id="子模块继承父工程所有依赖">子模块继承父工程所有依赖</h3>
<ul>
<li><p>比如在父工程添加这块依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>如下 父工程添加的依赖，所有子模块会无条件继承</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719221547553.png"
alt="image-20220719221547553" />
<figcaption aria-hidden="true">image-20220719221547553</figcaption>
</figure></li>
</ul>
<h3 id="父工程管理依赖">父工程管理依赖</h3>
<ul>
<li><p>依赖冗余的问题 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719221717734.png"
alt="image-20220719221717734" /></p></li>
<li><p>加强管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加强管理--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>结果，依赖都没有了 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719221905519.png"
alt="image-20220719221905519" /></p></li>
</ul>
<h3 id="子工程声明式继承父工程依赖">子工程声明式继承父工程依赖</h3>
<ul>
<li><p>比如002-maven-java（子模块，但又是004的父工程）需要mysql</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>效果 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719222137863.png"
alt="image-20220719222137863" /></p>
<ul>
<li>子模块依赖的版本号继承父工程依赖的版本号</li>
<li>如果子模块指定以来的版本号，那就不会继承父工程依赖的版本号</li>
</ul></li>
</ul>
<h3 id="父工程管理依赖版本号">父工程管理依赖版本号</h3>
<ul>
<li><p>使用properties变量</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--自定义标签名称--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--约定：通常管理依赖版本号的标签名：项目名称-字段version，</span></span><br><span class="line"><span class="comment">		项目名称.字段version--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit-version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit-version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql-connector-java-version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">mysql-connector-java-version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo-version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">dubbo-version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--加强管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector-java-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;dubbo-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="回顾第1种实现方式">回顾第1种实现方式</h3>
<ul>
<li>父工程的要求</li>
<li>子工程的添加</li>
<li>子工程改为父工程</li>
<li>子工程和父工程是平级的 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719224335202.png"
alt="image-20220719224335202" /></li>
<li>父工程加强管理
<code>&lt;dependencyManagement&gt;&lt;/&lt;dependencyManagement&gt;</code></li>
<li>注意，第一种方法父工程的pom.xml中，这个也应该是必须的 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719231834807.png"
alt="image-20220719231834807" /></li>
</ul>
<h2 id="第2种方式">第2种方式</h2>
<h3 id="创建父工程-1">创建父工程</h3>
<ul>
<li><p>最顶层创建一个工程（父工程） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719230455080.png"
alt="image-20220719230455080" /></p></li>
<li><p>pom文件（未处理）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>目录结构(未处理) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719230730707.png"
alt="image-20220719230730707" /></li>
</ul></li>
<li><p>处理后 pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    1.packaging标签文本内容必须设置为pom</span></span><br><span class="line"><span class="comment">    2.删除src目录</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>结构 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719231025823.png"
alt="image-20220719231025823" /></li>
</ul></li>
</ul>
<h3 id="创建子工程">创建子工程</h3>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719231137679.png"
alt="image-20220719231137679" />
<figcaption aria-hidden="true">image-20220719231137679</figcaption>
</figure>
<ul>
<li><p>子工程的pom.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;!--指向父工程--&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;maven-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.bjpowernode.maven&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">        &lt;!--注意，这里不需要找pom.xml，因为该子工程和父工程的pom.xml同级--&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;maven-java-001&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>父工程的pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!--父工程包含的所有子模块--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven-java-001<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    1.packaging标签文本内容必须设置为pom</span></span><br><span class="line"><span class="comment">    2.删除src目录</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>第二个子模块</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-web-001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>父工程pom.xml的变化 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719232239555.png"
alt="image-20220719232239555" /></li>
</ul></li>
</ul>
<h3 id="创建子工程的子工程">创建子工程的子工程</h3>
<ul>
<li><p>父工程必须遵循</p>
<ul>
<li>packaging标签文本内容设置为pom</li>
<li>删除src目录</li>
</ul></li>
<li><p>创建子工程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220719232610617.png"
alt="image-20220719232610617" /></p></li>
<li><p>maven-java-001的pom.xml查看</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指向父工程--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注意，这里不需要找pom.xml，因为该子工程和父工程的pom.xml同级--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-java-001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>maven-java-0101<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>子模块的pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-java-001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-java-0101<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="父工程管理依赖-1">父工程管理依赖</h3>
<ul>
<li>父工程的pom文件 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220720213456439.png"
alt="image-20220720213456439" /></li>
<li>子模块也一起继承了 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220720213519201.png"
alt="image-20220720213519201" /></li>
<li>父工程管理所有依赖 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220720213626025.png"
alt="image-20220720213626025" /></li>
<li>如果子工程需要，则使用声明式依赖 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220720213729734.png"
alt="image-20220720213729734" />
<ul>
<li>也可以自己指定版本号</li>
</ul></li>
</ul>
<h3 id="父工程管理依赖的版本号">父工程管理依赖的版本号</h3>
<ul>
<li>使用properties管理版本号，和第一种方式一样</li>
</ul>
<h3 id="子工程继承父工程编译插件">子工程继承父工程编译插件</h3>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220720213929453.png"
alt="image-20220720213929453" />
<figcaption aria-hidden="true">image-20220720213929453</figcaption>
</figure>
<p>修改之后，这里为了看效果，改成1.6</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220720214213184.png"
alt="image-20220720214213184" />
<figcaption aria-hidden="true">image-20220720214213184</figcaption>
</figure>
<h2 id="第3种方式">第3种方式</h2>
<p>前面两种混合使用</p>
<p>先创建一个空项目 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220720214447646.png"
alt="image-20220720214447646" /></p>
<p>然后假设有三个父工程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220720214902446.png"
alt="image-20220720214902446" /></p>
<p>然后每个父工程又都有子模块 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220720215038101.png"
alt="image-20220720215038101" /></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>maven多模块管理_动力节点</tag>
      </tags>
  </entry>
  <entry>
    <title>01-16 maven基础_动力节点</title>
    <url>/2022/07/02/study/maven/base_dljd/01-16/</url>
    <content><![CDATA[<h2 id="课程介绍">课程介绍</h2>
<ul>
<li>maven 自动化构建--&gt;开发--编译--运行-测试--打包--部署 （m ei '
ven）</li>
</ul>
<h2 id="maven的作用">maven的作用</h2>
<ul>
<li>软件是一个<strong>工程</strong></li>
<li>软件中重复的操作（开发阶段）
<ul>
<li>需求分析</li>
<li>设计阶段</li>
<li>开发阶段（编码），编译，测试</li>
<li>测试阶段（专业测试），测试报告</li>
<li>项目打包，发布，给客户安装项目</li>
</ul></li>
<li>maven
<ul>
<li>项目自动构建，清理、编译、测试、打包、安装、部署</li>
<li>管理依赖：项目中需要使用的其他资源</li>
</ul></li>
</ul>
<h2 id="maven中的概念">Maven中的概念</h2>
<ul>
<li>没有使用maven，管理jar，手动处理jar，以及jar之间的依赖</li>
<li>maven是apache 【əˈpætʃi】基金会的开源项目，使用java语法开发</li>
<li>maven是项目的自动化构建工具，管理项目依赖</li>
<li>maven中的概念
<ul>
<li>POM</li>
<li>约定的目录</li>
<li>坐标</li>
<li>依赖管理</li>
<li>仓库管理</li>
<li>生命周期</li>
<li>插件和目标</li>
<li>继承 （高级内容）</li>
<li>聚合 （高级内容）</li>
</ul></li>
</ul>
<h2 id="maven资源的获取与安装测试">Maven资源的获取与安装，测试</h2>
<ul>
<li><p>https://maven.apache.org/index.html</p>
<ul>
<li><p>各种内容 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703125536130.png"
alt="image-20220703125536130" /></p></li>
<li><p>要求 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703125601251.png"
alt="image-20220703125601251" /></p></li>
<li><p>视频用的3.6.3 ，这里下载3.8.6
（最新的，不要和电脑原配置冲突，方便学习，后续改回3.8.4）</p>
<ul>
<li><p>检查java home <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703130221750.png"
alt="image-20220703130221750" /></p>
<ul>
<li>如果没有需要进行配置 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703130338025.png"
alt="image-20220703130338025" /></li>
<li><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703130544132.png"
title="fig:" alt="image-20220703130544132" /></li>
</ul></li>
<li><p>将maven的bin目录配置到path环境变量下（这里使用的是下一节的方法，视频中没有用MAVEN_HOME，而是直接将maven的bin目录路径加到path中）
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703130145290.png"
alt="image-20220703130145290" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703130115851.png"
alt="image-20220703130115851" />
<figcaption aria-hidden="true">image-20220703130115851</figcaption>
</figure></li>
</ul></li>
</ul></li>
<li><p>maven解压后的目录结构 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703130727240.png"
alt="image-20220703130727240" /></p></li>
</ul>
<h2 id="另一种安装方式">另一种安装方式</h2>
<ul>
<li>确定JAVA_HOME是否有效</li>
<li>创建M2_HOME(MAVEN_HOME)，值为maven的安装目录</li>
<li>在path环境中，加入%M2_HOME%</li>
<li>测试maven安装 mvn -v</li>
</ul>
<h2 id="约定的目录结构">约定的目录结构</h2>
<ul>
<li><p>大多数人遵守的目录结构</p>
<ul>
<li><p>一个maven项目对应一个文件夹，比如Hello</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">	\src</span><br><span class="line">		\main			叫做主程序目录（完成项目功能的代码和配置文件）</span><br><span class="line">			\java		源代码（包和相关的类定义）</span><br><span class="line">			\resources  配置文件</span><br><span class="line">		\test			放置测试程序代码（开发人员自己写的测试代码）</span><br><span class="line">			\java		测试代码（junit）</span><br><span class="line">			\resources  测试程序的配置文件</span><br><span class="line">	\pom.xml			maven的配置文件</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="hello的maven项目">Hello的Maven项目</h2>
<ul>
<li><p>maven可以独立使用：创建项目、编译代码、测试程序、打包、部署等</p></li>
<li><p>和idea一起使用，实现编码、测试、打包</p></li>
<li><p>pom.xml基本模板</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ch01-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span> </span><br></pre></td></tr></table></figure></li>
<li><p>目录创建 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703160344622.png"
alt="image-20220703160344622" /></p></li>
<li><p>在main下创建一个com.bjpowernode的包，以及一个java文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloMaven</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addNumber</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">&quot;hello maven -addNumber&quot;</span>);</span><br><span class="line"> 	<span class="keyword">return</span> n1+n2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">  	HelloMaven hello=<span class="keyword">new</span> <span class="title class_">HelloMaven</span>();</span><br><span class="line">  	<span class="type">int</span> res=hello.addNumber(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">  	System.out.println(<span class="string">&quot;在main方法中，执行hello的方法=&quot;</span>+res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在Hello目录下，进行编译 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703160827325.png"
alt="image-20220703160827325" /></p></li>
<li><p>使用<code>mvn compile</code>进行编译 第一次会下载一些东西 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703161351385.png"
alt="image-20220703161351385" /></p></li>
<li><p>查看target文件 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703161017403.png"
alt="image-20220703161017403" /></p></li>
<li><p>进入classes执行java程序</p>
<p><code>java com.bjpowernode.HelloMaven</code> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703161429075.png"
alt="image-20220703161429075" /></p></li>
</ul>
<h2 id="pom-modelversion">pom-modelVersion</h2>
<ul>
<li><p>pom--Project Object Model 项目对象模型</p></li>
<li><p>Maven把一个项目的结构和内容抽象成一个模型，在xml文件中进行声明，以方便进行构建和描述</p></li>
<li><p>pom文件解释</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--project是根标签，后面的是约束文件 (maven-v4_0_0.xsd)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">&lt;!--pom模型版本,4.0.0--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ch01-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span> </span><br></pre></td></tr></table></figure></li>
</ul>
<h2
id="pom-groupidartifactidversion">pom-groupId，artifactId，version</h2>
<ul>
<li>坐标组成，groupid,artifactId,version <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703180442092.png"
alt="image-20220703180442092" /></li>
<li>作用：资源的唯一标识，maven中每个资源都是坐标，简称gav</li>
<li>groupId：组织名称，代码。公司或单位标识，常使用公司域名的倒写
<ul>
<li>如果规模大，可以是 域名倒写+大项目名称 例如百度无人车项目 ：
com.baidu.appollo</li>
</ul></li>
<li>artifactId：项目名称，如果groupId中有项目，此时当前的值就是子项目名，项目名称是唯一的</li>
<li>versionId：项目版本号，使用数字，推荐三位 例如
主版本号.次版本号.小版本号 例如 5.2.5
<ul>
<li>带快照的版本，以-SNAPSHOT结尾，即非稳定版本</li>
</ul></li>
</ul>
<h2 id="pom-gav作用">pom-gav作用</h2>
<ul>
<li>每个maven项目都有自己的gav</li>
<li>管理依赖，使用其他jar包，也用gav标识</li>
<li>坐标 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703181221145.png"
alt="image-20220703181221145" /></li>
<li>坐标值的获取 https://mvnrepository.com/ <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703181311395.png"
alt="image-20220703181311395" />
<ul>
<li>例如mysql <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703181414505.png"
alt="image-20220703181414505" /></li>
<li><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703181441331.png"
title="fig:" alt="image-20220703181441331" /></li>
</ul></li>
</ul>
<h2 id="pom-依赖的使用">pom-依赖的使用</h2>
<ul>
<li><p>依赖dependency 项目中使用的其他资源（jar）
需要使用maven来表示依赖、管理依赖，通过使用dependencies、dependency和gav完成依赖的使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--maven使用gav标识，从互联网下载依赖的jar，下载到本机中，由maven管理项目使用的这些jar--&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>完整</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--project是根标签，后面的是约束文件 (maven-v4_0_0.xsd)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">&lt;!--pom模型版本,4.0.0--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ch01-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--maven使用gav标识，从互联网下载依赖的jar，下载到本机中，由maven管理项目使用的这些jar--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--packaging 项目打包类型---&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span> </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="pom-打包类型">pom-打包类型</h2>
<p><packaging> 项目打包类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--project是根标签，后面的是约束文件 (maven-v4_0_0.xsd)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">&lt;!--pom模型版本,4.0.0--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--坐标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ch01-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li>其他 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220703182223670.png"
alt="image-20220703182223670" /></li>
</ul>
<h2 id="pom-继承和聚合">pom-继承和聚合</h2>
<ul>
<li>继承 parent</li>
<li>聚合 modules</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>maven_基础动力节点</tag>
      </tags>
  </entry>
  <entry>
    <title>17-30 maven基础_动力节点</title>
    <url>/2022/07/03/study/maven/base_dljd/17-30/</url>
    <content><![CDATA[<h2 id="本地仓库的设置">本地仓库的设置</h2>
<ul>
<li><p>远程仓库--&gt;本地仓库</p></li>
<li><p>maven仓库</p>
<ul>
<li>存放maven工具自己的jar包</li>
<li>第三方jar，比如mysql驱动</li>
<li>自己写的程序，可以打包为jar，存放到仓库</li>
</ul></li>
<li><p>分类</p>
<ul>
<li>本地仓库（本机）：位于自己计算机中，磁盘中某个目录
<ul>
<li><p>默认位置 登录操作系统的账号目录/.m2/repository C:.m2</p></li>
<li><p>可修改 比如放在d盘中</p>
<p>英[rɪˈpɒzətri] D:-maven-3.8.6 备份并编辑 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709111345399.png"
alt="image-20220709111345399" /> 改成左斜杠的方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.2.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.2.0 https://maven.apache.org/xsd/settings-1.2.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">   | The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">   |</span></span><br><span class="line"><span class="comment">   | Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">  &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:/software/apache-maven-3.8.6/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>把之前user下的repository的文件都拷贝到
D:/software/apache-maven-3.8.6/repository 下 然后再对Hello项目进行编译
<code>mvn compile</code>
发现不会下载任何文件，且user下的repository也不会再进行下载</p></li>
<li><p>下面的资源是从maven中下载，或者用maven打包的 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709112015535.png"
alt="image-20220709112015535" /></p></li>
</ul></li>
<li>pom.xml来说明某个项目需要怎么处理代码、项目结构</li>
</ul>
<p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ch01-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    				<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span> </span><br></pre></td></tr></table></figure></p>
<ul>
<li>mvn命令需要在pom.xml所在的目录下执行 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709112759294.png"
alt="image-20220709112759294" /></li>
</ul></li>
</ul>
<h2 id="仓库的工作方式">仓库的工作方式</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709112814643.png"
alt="image-20220709112814643" />
<figcaption aria-hidden="true">image-20220709112814643</figcaption>
</figure>
<h2 id="生命周期插件命令">生命周期插件命令</h2>
<ul>
<li>包括
清理（删除target文件，但是不处理已经install的jar）、编译（当前目录生成target目录，放置编译主程序之后生成的字节码）、测试（生成surefire-reports，保存测试结果）、报告、打包（打包主程序[编译、编译测试、测试，并按照pom.xml配置把主程序打包成jar包或war包]）、安装（把本工程打包，并按照工程坐标保存到本地仓库中）、部署(打包，保存到本地仓库，并保存到私服中，且自动把项目部署到web容器中)</li>
<li>插件：要完成构建项目的各个阶段，要使用maven的命令，执行命令的功能，是通过插件完成的
插件就是jar，一些类</li>
<li>命令：执行maven功能，通过命令发出，比如mvn
compile（编译时由相关的类来操作）</li>
</ul>
<h2 id="junit使用">junit使用</h2>
<ul>
<li><p>单元测试 junit：单元测试的工具，java中经常使用
单元，java中指的是方法，方法就是一个单元，方法是测试的最小单位</p></li>
<li><p>作用，使用junit去测试方法是否完成了要求，开发人员自测</p></li>
<li><p>使用单元测试</p>
<ul>
<li><p>加入junit的依赖（需要用他的类和方法）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12&gt;</span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在src/test/java目录中创建测试类文件，写测试代码</p>
<ul>
<li>测试类的定义，名称一般是Test+要测试的类名称</li>
<li>测试它的包名和要测试的类包名一样</li>
<li>在类中定义方法，要测试的代码</li>
<li>方法定义：public方法，没有返回值，名称自定义（建议Test+测试的方法名称）
方法没有参数</li>
<li>测试类中的方法，可以单独执行，测试类也可以单独执行</li>
<li>在该方法上面加入注解<code>@Test</code></li>
</ul></li>
<li><p>注意：mvn compile的时候，会下载3.8.2的jar包 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709170257384.png"
alt="image-20220709170257384" /></p></li>
</ul></li>
</ul>
<h2 id="创建测试类和测试方法">创建测试类和测试方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode;</span><br><span class="line"><span class="comment">//导入包</span></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHelloMaven</span>&#123;</span><br><span class="line">	<span class="comment">//定义多个独立的测试方法，每个方法都是独立的</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddNumber</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;执行了测试方法testAddNumber&quot;</span>);</span><br><span class="line">		HelloMaven hello=<span class="keyword">new</span> <span class="title class_">HelloMaven</span>();</span><br><span class="line">		<span class="type">int</span> res=hello.addNumber(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">		<span class="comment">//把计算结果res交给junit判断</span></span><br><span class="line">		<span class="comment">//期望值，实际值</span></span><br><span class="line">		Assert.assertEquals(<span class="number">30</span>,res);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相关命令">相关命令</h2>
<ul>
<li><p>mvn clean ，清理，删除以前生成的数据（删除target目录） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709165910300.png"
alt="image-20220709165910300" /></p>
<ul>
<li><p>插件及版本 maven-clean-plugin:2.5</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">d:\Users\ly\Documents\git\mavenwork\Hello&gt;mvn clean</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ---------------------&lt; com.bjpowernode:ch01-maven &gt;---------------------</span><br><span class="line">[INFO] Building ch01-maven 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ ch01-maven ---</span><br><span class="line">[INFO] Deleting d:\Users\ly\Documents\git\mavenwork\Hello\target</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  0.354 s</span><br><span class="line">[INFO] Finished at: 2022-07-09T17:03:46+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>代码的编译 mvn compile：编译命令，把src/main/java
目录中的java代码编译为class文件
同时把class文件拷贝到target/classes目录，这个目录classes是存放类文件的根目录（也叫做类路径，classpath）</p>
<ul>
<li><p>编译后放到target 插件：maven-compiler-plugin:3.1 编译代码
maven-resources-plugin:2.6:resources
资源插件，作用是把src/main/resources目录中的文件拷贝到target/classes
目录中</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ mvn compile</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ---------------------&lt; com.bjpowernode:ch01-maven &gt;---------------------</span><br><span class="line">[INFO] Building ch01-maven 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ ch01-maven ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 1 resource</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ ch01-maven ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[WARNING] File encoding has not been set, using platform encoding GBK, i.e. build is platform dependent!</span><br><span class="line">[INFO] Compiling 1 source file to D:\Users\ly\Documents\git\mavenwork\Hello\target\classes</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  3.164 s</span><br><span class="line">[INFO] Finished at: 2022-07-09T17:20:30+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></p></li>
<li><p>测试resources插件 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709172307477.png"
alt="image-20220709172307477" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709172332617.png"
alt="image-20220709172332617" /></p></li>
</ul></li>
<li><p>mvn test-compile:编译命令，编译src/test/java
目录中的源文件，把生成的class拷贝到target/test-classes目录中，同时把src/test/resources目录中的文件拷贝到test-classes目录
命令执行前 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709172752580.png"
alt="image-20220709172752580" /> 执行后 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709172841433.png"
alt="image-20220709172841433" /></p>
<ul>
<li><p>插件 maven-resources-plugin:2.6:resources
maven-compiler-plugin:3.1:compile
maven-resources-plugin:2.6:testResources
maven-compiler-plugin:3.1:testCompile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">λ mvn test-compile</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ---------------------&lt; com.bjpowernode:ch01-maven &gt;---------------------</span><br><span class="line">[INFO] Building ch01-maven 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">Downloading from central: https://repo.maven.apache.org/maven2/junit/junit/4.12/junit-4.12.jar</span><br><span class="line">Downloading from central: https://repo.maven.apache.org/maven2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar</span><br><span class="line">Downloaded from central: https://repo.maven.apache.org/maven2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar (45 kB at 24 kB/s)</span><br><span class="line">Downloaded from central: https://repo.maven.apache.org/maven2/junit/junit/4.12/junit-4.12.jar (315 kB at 118 kB/s)</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ ch01-maven ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 2 resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ ch01-maven ---</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ ch01-maven ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 1 resource</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ ch01-maven ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[WARNING] File encoding has not been set, using platform encoding GBK, i.e. build is platform dependent!</span><br><span class="line">[INFO] Compiling 1 source file to D:\Users\ly\Documents\git\mavenwork\Hello\target\test-classes</span><br><span class="line">[WARNING] /D:/Users/ly/Documents/git/mavenwork/Hello/src/test/java/com/bjpowernode/TestHelloMaven.java:[2,7]</span><br><span class="line">编码GBK的不可映射字符</span><br><span class="line">[WARNING] /D:/Users/ly/Documents/git/mavenwork/Hello/src/test/java/com/bjpowernode/TestHelloMaven.java:[8,42] 编码GBK的不可映射字符</span><br><span class="line">[WARNING] /D:/Users/ly/Documents/git/mavenwork/Hello/src/test/java/com/bjpowernode/TestHelloMaven.java:[14,29] 编码GBK的不可映射字符</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  8.085 s</span><br><span class="line">[INFO] Finished at: 2022-07-09T17:28:14+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>mvn test
测试命令，执行test-classes目录的程序，测试src/main/java目录中的主程序是否符合要求
注意，这里还是会用到编译插件和资源插件，从 T E S T S 开始测试
结果Results :</p>
<p>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0 测试插件
maven-surefire-plugin:2.12.4</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ mvn test</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ---------------------&lt; com.bjpowernode:ch01-maven &gt;---------------------</span><br><span class="line">[INFO] Building ch01-maven 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ ch01-maven ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 2 resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ ch01-maven ---</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ ch01-maven ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 1 resource</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ ch01-maven ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[WARNING] File encoding has not been set, using platform encoding GBK, i.e. build is platform dependent!</span><br><span class="line">[INFO] Compiling 1 source file to D:\Users\ly\Documents\git\mavenwork\Hello\target\test-classes</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ ch01-maven ---</span><br><span class="line">[INFO] Surefire report directory: D:\Users\ly\Documents\git\mavenwork\Hello\target\surefire-reports</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Running com.bjpowernode.TestHelloMaven</span><br><span class="line">执行了测试方法testAddNumber</span><br><span class="line">hello maven -addNumber</span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.131 sec</span><br><span class="line"></span><br><span class="line">Results :</span><br><span class="line"></span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</span><br><span class="line"></span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  4.630 s</span><br><span class="line">[INFO] Finished at: 2022-07-09T17:32:49+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>测试报告 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709173436937.png"
alt="image-20220709173436937" /></p>
<ul>
<li><p>测试失败的情况 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709173514572.png"
alt="image-20220709173514572" /></p>
<ul>
<li><p>结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ mvn test</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ---------------------&lt; com.bjpowernode:ch01-maven &gt;---------------------</span><br><span class="line">[INFO] Building ch01-maven 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ ch01-maven ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 2 resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ ch01-maven ---</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ ch01-maven ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 1 resource</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ ch01-maven ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[WARNING] File encoding has not been set, using platform encoding GBK, i.e. build is platform dependent!</span><br><span class="line">[INFO] Compiling 1 source file to D:\Users\ly\Documents\git\mavenwork\Hello\target\test-classes</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ ch01-maven ---</span><br><span class="line">[INFO] Surefire report directory: D:\Users\ly\Documents\git\mavenwork\Hello\target\surefire-reports</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Running com.bjpowernode.TestHelloMaven</span><br><span class="line">执行了测试方法testAddNumber</span><br><span class="line">hello maven -addNumber</span><br><span class="line">Tests run: 1, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.217 sec &lt;&lt;&lt; FAILURE!</span><br><span class="line">testAddNumber(com.bjpowernode.TestHelloMaven)  Time elapsed: 0.043 sec  &lt;&lt;&lt; FAILURE!</span><br><span class="line">java.lang.AssertionError: expected:&lt;60&gt; but was:&lt;30&gt;</span><br><span class="line">        at org.junit.Assert.fail(Assert.java:88)</span><br><span class="line">        at org.junit.Assert.failNotEquals(Assert.java:834)</span><br><span class="line">        at org.junit.Assert.assertEquals(Assert.java:645)</span><br><span class="line">        at org.junit.Assert.assertEquals(Assert.java:631)</span><br><span class="line">        at com.bjpowernode.TestHelloMaven.testAddNumber(TestHelloMaven.java:15)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">        at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</span><br><span class="line">        at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</span><br><span class="line">        at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</span><br><span class="line">        at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</span><br><span class="line">        at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)</span><br><span class="line">        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)</span><br><span class="line">        at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)</span><br><span class="line">        at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)</span><br><span class="line">        at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)</span><br><span class="line">        at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)</span><br><span class="line">        at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)</span><br><span class="line">        at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)</span><br><span class="line">        at org.junit.runners.ParentRunner.run(ParentRunner.java:363)</span><br><span class="line">        at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)</span><br><span class="line">        at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)</span><br><span class="line">        at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">        at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)</span><br><span class="line">        at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)</span><br><span class="line">        at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)</span><br><span class="line">        at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)</span><br><span class="line">        at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Results :</span><br><span class="line"></span><br><span class="line">Failed tests:   testAddNumber(com.bjpowernode.TestHelloMaven): expected:&lt;60&gt; but was:&lt;30&gt;</span><br><span class="line"></span><br><span class="line">Tests run: 1, Failures: 1, Errors: 0, Skipped: 0</span><br><span class="line"></span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD FAILURE</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  8.018 s</span><br><span class="line">[INFO] Finished at: 2022-07-09T17:35:38+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.12.4:test (default-test) on project ch01-maven: There are test failures.</span><br><span class="line">[ERROR]</span><br><span class="line">[ERROR] Please refer to D:\Users\ly\Documents\git\mavenwork\Hello\target\surefire-reports for the individual test results.</span><br><span class="line">[ERROR] -&gt; [Help 1]</span><br><span class="line">[ERROR]</span><br><span class="line">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class="line">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class="line">[ERROR]</span><br><span class="line">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span><br><span class="line">[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>mvn package
打包，作用是把项目中的资源class文件和配置文件，都放到一个压缩包中，默认压缩文件是jar类型，web应用是war类型，扩展名jar/war
这里进行了编译、测试、打包 [INFO] Building jar:
D:-maven-1.0-SNAPSHOT.jar 打包插件 maven-jar-plugin:2.4:jar
(default-jar) @ ch01-maven
maven-jar-plugin:2.4用来执行打包，会生成jar扩展名文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ mvn package</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ---------------------&lt; com.bjpowernode:ch01-maven &gt;---------------------</span><br><span class="line">[INFO] Building ch01-maven 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ ch01-maven ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!</span><br><span class="line">[INFO] Copying 2 resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ ch01-maven ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[WARNING] File encoding has not been set, using platform encoding GBK, i.e. build is platform dependent!</span><br><span class="line">[INFO] Compiling 1 source file to D:\Users\ly\Documents\git\mavenwork\Hello\target\classes</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ ch01-maven ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!</span><br><span class="line">[INFO] Copying 1 resource</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ ch01-maven ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[WARNING] File encoding has not been set, using platform encoding GBK, i.e. build is platform dependent!</span><br><span class="line">[INFO] Compiling 1 source file to D:\Users\ly\Documents\git\mavenwork\Hello\target\test-classes</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ ch01-maven ---</span><br><span class="line">[INFO] Surefire report directory: D:\Users\ly\Documents\git\mavenwork\Hello\target\surefire-reports</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Running com.bjpowernode.TestHelloMaven</span><br><span class="line">执行了测试方法testAddNumber</span><br><span class="line">hello maven -addNumber</span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.135 sec</span><br><span class="line"></span><br><span class="line">Results :</span><br><span class="line"></span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</span><br><span class="line"></span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ ch01-maven ---</span><br><span class="line">[INFO] Building jar: D:\Users\ly\Documents\git\mavenwork\Hello\target\ch01-maven-1.0-SNAPSHOT.jar</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  5.624 s</span><br><span class="line">[INFO] Finished at: 2022-07-09T17:40:44+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<ul>
<li><p>生成ch01-maven-1.0-SNAPSHOT.jar 坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ch01-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打包的文件名 artifactId-version.packaging 查看jar <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709174531640.png"
alt="image-20220709174531640" /></p>
<p>打包的文件中，包括src/main目录中所有的生成的class文件和配置文件（resources下），和测试test无关</p></li>
</ul></li>
<li><p>mvn install 把生成的打包文件（jar）安装到maven仓库中
插件：maven-install-plugin-2.4</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ mvn install</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ---------------------&lt; com.bjpowernode:ch01-maven &gt;---------------------</span><br><span class="line">[INFO] Building ch01-maven 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ ch01-maven ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!</span><br><span class="line">[INFO] Copying 2 resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ ch01-maven ---</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ ch01-maven ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!</span><br><span class="line">[INFO] Copying 1 resource</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ ch01-maven ---</span><br><span class="line">[INFO] Nothing to compile - all classes are up to date</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ ch01-maven ---</span><br><span class="line">[INFO] Surefire report directory: D:\Users\ly\Documents\git\mavenwork\Hello\target\surefire-reports</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> T E S T S</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Running com.bjpowernode.TestHelloMaven</span><br><span class="line">执行了测试方法testAddNumber</span><br><span class="line">hello maven -addNumber</span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.162 sec</span><br><span class="line"></span><br><span class="line">Results :</span><br><span class="line"></span><br><span class="line">Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</span><br><span class="line"></span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ ch01-maven ---</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-install-plugin:2.4:install (default-install) @ ch01-maven ---</span><br><span class="line">[INFO] Installing D:\Users\ly\Documents\git\mavenwork\Hello\target\ch01-maven-1.0-SNAPSHOT.jar to D:\software\apache-maven-3.8.6\repository\com\bjpowernode\ch01-maven\1.0-SNAPSHOT\ch01-maven-1.0-SNAPSHOT.jar</span><br><span class="line">[INFO] Installing D:\Users\ly\Documents\git\mavenwork\Hello\pom.xml to D:\software\apache-maven-3.8.6\repository\com\bjpowernode\ch01-maven\1.0-SNAPSHOT\ch01-maven-1.0-SNAPSHOT.pom</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  5.063 s</span><br><span class="line">[INFO] Finished at: 2022-07-09T17:48:43+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>如上，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Installing D:\Users\ly\Documents\git\mavenwork\Hello\target\ch01-maven-1.0-SNAPSHOT.jar to D:\software\apache-maven-3.8.6\repository\com\bjpowernode\ch01-maven\1.0-SNAPSHOT\ch01-maven-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>路径 com-maven\1.0-SNAPSHOT ，如下，跟坐标有关</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ch01-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--groupId出现点，则使用\（文件夹）分割</span></span><br><span class="line"><span class="comment">	artifactId 独立文件夹</span></span><br><span class="line"><span class="comment">	version 独立文件夹</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709175553540.png"
alt="image-20220709175553540" /></p></li>
<li><p>部署 mvn deploy
部署主程序（把本工程打包，按照本工程的坐标保存到本地仓库中，并且保存到私服仓库中，还会自动把项目部署到web容器中</p></li>
<li><p>以上命令是可以组合着用的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">λ mvn clean compile</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ---------------------&lt; com.bjpowernode:ch01-maven &gt;---------------------</span><br><span class="line">[INFO] Building ch01-maven 1.0-SNAPSHOT</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ ch01-maven ---</span><br><span class="line">[INFO] Deleting D:\Users\ly\Documents\git\mavenwork\Hello\target</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ ch01-maven ---</span><br><span class="line">[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!</span><br><span class="line">[INFO] Copying 2 resources</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ ch01-maven ---</span><br><span class="line">[INFO] Changes detected - recompiling the module!</span><br><span class="line">[WARNING] File encoding has not been set, using platform encoding GBK, i.e. build is platform dependent!</span><br><span class="line">[INFO] Compiling 1 source file to D:\Users\ly\Documents\git\mavenwork\Hello\target\classes</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  2.725 s</span><br><span class="line">[INFO] Finished at: 2022-07-09T17:53:36+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="配置插件">配置插件</h2>
<ul>
<li><p>常用插件设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>先看一下，目前的版本 maven-compiler-plugin:3.1:compile</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>maven_基础动力节点</tag>
      </tags>
  </entry>
  <entry>
    <title>31-43 maven基础_动力节点</title>
    <url>/2022/07/09/study/maven/base_dljd/31-43/</url>
    <content><![CDATA[<h2 id="idea中设置maven">idea中设置maven</h2>
<ul>
<li>和idea集成maven <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220709184037929.png"
alt="image-20220709184037929" /></li>
<li></li>
</ul>
<h2 id="创建普通的j2se项目">创建普通的j2se项目</h2>
<ul>
<li><p>使用idea创建空白项目 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713231150543.png"
alt="image-20220713231150543" /></p></li>
<li><p>新建一个module <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713231850412.png"
alt="image-20220713231850412" /></p></li>
<li><p>使用模板创建普通java项目 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713232000630.png"
alt="image-20220713232000630" /></p></li>
<li><p>输入gav <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713232134765.png"
alt="image-20220713232134765" /></p></li>
<li><p>设置maven信息 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713232207269.png"
alt="image-20220713232207269" /></p></li>
<li><p>标准的maven工程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713232439707.png"
alt="image-20220713232439707" /></p>
<ul>
<li><p>与创建网站有关，删掉即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ch01-maven-j2se<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--设置网站，注释掉即可--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  &lt;name&gt;ch01-maven-j2se&lt;/name&gt;</span></span><br><span class="line"><span class="comment">  &lt;!– FIXME change it to the project&#x27;s website –&gt;</span></span><br><span class="line"><span class="comment">  &lt;url&gt;http://www.example.com&lt;/url&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span> <span class="comment">&lt;!--maven常用设置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插件版本的配置，无特殊指定则删除--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="单元测试">单元测试</h2>
<ul>
<li><p>关于idea颜色 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713232946902.png"
alt="image-20220713232946902" /></p></li>
<li><p>编写java程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloMaven</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addNumber</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n1+n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HelloMaven helloMaven=<span class="keyword">new</span> <span class="title class_">HelloMaven</span>();</span><br><span class="line">        <span class="type">int</span> res=helloMaven.addNumber(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;res = &quot;</span>+res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713233208694.png"
alt="image-20220713233208694" />
<figcaption aria-hidden="true">image-20220713233208694</figcaption>
</figure></li>
<li><p>测试使用 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713233421209.png"
alt="image-20220713233421209" /></p></li>
</ul>
<h2 id="idea中maven工具窗口">idea中maven工具窗口</h2>
<ul>
<li><p>Maven生成的目录 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713233546497.png"
alt="image-20220713233546497" /></p></li>
<li><p>使用<code>mvn clean</code>进行清理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ mvn clean</span><br><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] ------------------&lt; com.bjpowernode:ch01-maven-j2se &gt;-------------------</span><br><span class="line">[INFO] Building ch01-maven-j2se 1.0</span><br><span class="line">[INFO] --------------------------------[ jar ]---------------------------------</span><br><span class="line">[INFO]</span><br><span class="line">[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ ch01-maven-j2se ---</span><br><span class="line">[INFO] Deleting D:\Users\ly\Documents\git\mavenwork\04-project\ch01-maven-j2se\target [INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time:  0.438 s</span><br><span class="line">[INFO] Finished at: 2022-07-13T23:39:03+08:00</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></li>
<li><p>窗口 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713234020275.png"
alt="image-20220713234020275" /></p></li>
<li><figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713234115836.png"
alt="image-20220713234115836" />
<figcaption aria-hidden="true">image-20220713234115836</figcaption>
</figure></li>
<li><p>单元测试 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713234210200.png"
alt="image-20220713234210200" /></p></li>
<li><p>打包 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713234248469.png"
alt="image-20220713234248469" /></p></li>
<li><p>install安装 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713234334901.png"
alt="image-20220713234334901" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713234400027.png"
alt="image-20220713234400027" /></p></li>
<li><p>其他 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713234517215.png"
alt="image-20220713234517215" /></p></li>
<li><p>重新更新依赖项 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220713234714252.png"
alt="image-20220713234714252" /></p></li>
</ul>
<h2 id="创建web项目加入servlet依赖">创建web项目加入servlet依赖</h2>
<ul>
<li><figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220716111633675.png"
alt="image-20220716111633675" />
<figcaption aria-hidden="true">image-20220716111633675</figcaption>
</figure></li>
<li><p>结构 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220716112315076.png"
alt="image-20220716112315076" /></p></li>
<li><p>创建java文件夹和资源文件夹 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220716112520421.png"
alt="image-20220716112520421" /></p></li>
<li><p>pom文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjpowernode<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ch02-maven-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>ch02-maven-web Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--servlet依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--jsp依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>和上面进行对比</li>
</ul></li>
</ul>
<h2 id="创建servlet">创建servlet</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220716180646161.png"
alt="image-20220716180646161" />
<figcaption aria-hidden="true">image-20220716180646161</figcaption>
</figure>
<ul>
<li><p>创建完之后</p>
<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>web.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE web-app PUBLIC</span><br><span class="line"> &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span><br><span class="line"> &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.bjpowernode.controller.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>添加mapping</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE web-app PUBLIC</span><br><span class="line"> &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span><br><span class="line"> &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;web-app&gt;</span><br><span class="line">  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;</span><br><span class="line">  &lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.bjpowernode.controller.HelloServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;/servlet&gt;</span><br><span class="line">  &lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;</span><br><span class="line">  &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>添加jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: ly</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">7</span>/<span class="number">16</span></span><br><span class="line">  Time: <span class="number">18</span>:<span class="number">10</span></span><br><span class="line">  To change <span class="built_in">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;index&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;hello&quot;</span> &gt;访问&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>设置转发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.bjpowernode.controller;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;收到请求了&quot;);</span><br><span class="line">        //转发到show</span><br><span class="line">        request.getRequestDispatcher(&quot;/show.jsp&quot;)</span><br><span class="line">                .forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>设置tomcat并发布</p>
<p>idea出现not found for the web module. <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220716183849344.png"
alt="image-20220716183849344" /></p>
<ul>
<li><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220716183934847.png"
title="fig:" alt="image-20220716183934847" /></li>
</ul></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220716184050846.png"
alt="image-20220716184050846" />
<figcaption aria-hidden="true">image-20220716184050846</figcaption>
</figure>
<h2 id="复习核心的概念">复习核心的概念</h2>
<ul>
<li>约定的目录结构 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717084635706.png"
alt="image-20220717084635706" /></li>
<li>pom 项目对象模型，groupId,artifactId,version gav</li>
<li>仓库
<ul>
<li>本地仓库 ...../.m2/repository</li>
<li>远程仓库</li>
</ul></li>
<li>生命周期，clean，compile，test-compile，test，package，install</li>
<li>maven和idea集成
<ul>
<li>设置maven安装目录和配置文件</li>
<li>设置Runner，创建maven时速度快 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717085102707.png"
alt="image-20220717085102707" /></li>
<li>使用模板创建 se和web <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717085138267.png"
alt="image-20220717085138267" /></li>
</ul></li>
</ul>
<h2 id="导入模块到idea">导入模块到idea</h2>
<ul>
<li><p>导入02这个项目 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717085259283.png"
alt="image-20220717085259283" /></p></li>
<li><figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717085358306.png"
alt="image-20220717085358306" />
<figcaption aria-hidden="true">image-20220717085358306</figcaption>
</figure></li>
<li><figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717085416212.png"
alt="image-20220717085416212" />
<figcaption aria-hidden="true">image-20220717085416212</figcaption>
</figure></li>
<li><p>结果 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717085509110.png"
alt="image-20220717085509110" /></p></li>
<li><p>当磁盘中文件夹名字和项目名不一样时 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717085628061.png"
alt="image-20220717085628061" /></p></li>
<li><p>如果导入后颜色不对，则需要右键 mark as <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717085702320.png"
alt="image-20220717085702320" /></p></li>
</ul>
<h2 id="scope依赖范围">scope依赖范围</h2>
<ul>
<li><p>scope标签</p></li>
<li><p>依赖范围：scope标签，这个依赖在项目构建的哪个阶段起作用</p>
<ul>
<li>值：compile，默认，参与构建项目的所有阶段；
test：测试，在测试阶段使用，比如执行mvn test 会使用junit
provided：提供者，项目在部署到服务器时，不需要提供这个依赖的jar，而是由服务器提供这个以来的jar包</li>
</ul></li>
<li><p>打包时只有mysql <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717090458970.png"
alt="image-20220717090458970" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717090436168.png"
alt="image-20220717090436168" />
<figcaption aria-hidden="true">image-20220717090436168</figcaption>
</figure></li>
<li><p>war文件 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717090640802.png"
alt="image-20220717090640802" /></p>
<ul>
<li>给服务器，即放到tomcat的webapps中 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717090754979.png"
alt="image-20220717090754979" /></li>
<li>启动tomcat之后，会自动解压 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717090900826.png"
alt="image-20220717090900826" /></li>
</ul></li>
<li><p>访问 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717090923610.png"
alt="image-20220717090923610" /></p></li>
</ul>
<h2 id="自定义变量">自定义变量</h2>
<ul>
<li>properties标签，常用设置 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717091221438.png"
alt="image-20220717091221438" />
<ul>
<li>test报告 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717091319419.png"
alt="image-20220717091319419" /></li>
</ul></li>
<li><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717091648938.png"
alt="image-20220717091648938" /> 这种需要将文件夹删除，然后reimport</li>
<li>全局变量，比如依赖版本号
<ul>
<li>重复的问题 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717091505986.png"
alt="image-20220717091505986" /></li>
<li>在properties里面定义即可 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717091750991.png"
alt="image-20220717091750991" /></li>
<li>使用全局变量 ${变量名} <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717091837955.png"
alt="image-20220717091837955" /></li>
</ul></li>
</ul>
<h2 id="处理文件的默认规则">处理文件的默认规则</h2>
<ul>
<li>使用资源插件</li>
<li>例子
<ul>
<li><p>放置三个文件</p></li>
<li><figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717092936963.png"
alt="image-20220717092936963" />
<figcaption aria-hidden="true">image-20220717092936963</figcaption>
</figure></li>
<li><p>进行四个操作，会生成资源文件（src/resources）拷贝到target/classes目录下
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717093410508.png"
alt="image-20220717093410508" /></p></li>
</ul></li>
<li>如果在java下的包中放资源文件 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717093525542.png"
alt="image-20220717093525542" />
<ul>
<li>没有拷贝 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717093549635.png"
alt="image-20220717093549635" /></li>
<li>即maven只处理src/main/java目录下的.java文件，把这些编译成class，拷贝到target/classes目录中，不处理其他文件</li>
</ul></li>
</ul>
<h2 id="资源插件">资源插件</h2>
<p>build下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--资源插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--所在的目录--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--包括properties及xml后缀文件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.txt<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--不使用过滤器，*.xml已经起到过滤作用了--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220717094642979.png"
alt="image-20220717094642979" /></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>maven_基础动力节点</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus-sgg-01-11</title>
    <url>/2022/06/03/study/mybatis_plus/bl_sgg/01-11/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>MyBatis-Plus是一个MyBatis的<strong>增强工具</strong>，在MyBatis的基础上<strong>只做增强不做改变</strong>，为<strong>简化开发、提高效率</strong>而生</li>
<li>这里以MySQL数据库为案例，以Idea作为IDE，使用Maven作为构建工具，使用SpringBoot完成各种功能</li>
<li>课程主要内容 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220603073359351.png"
alt="image-20220603073359351" /></li>
<li>特性 润物无声、效率至上、丰富功能</li>
<li>支持的数据库 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220603074051884.png"
alt="image-20220603074051884" /></li>
<li>框架结构 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220603074111318.png"
alt="image-20220603074111318" />
<ul>
<li>左边：扫描实体，从实体抽取属性猜测数据库字段</li>
<li>通过默认提供的方法使用sql语句，然后注入mybatis容器</li>
</ul></li>
</ul>
<h2 id="开发环境">开发环境</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220603074238643.png"
alt="image-20220603074238643" />
<figcaption aria-hidden="true">image-20220603074238643</figcaption>
</figure>
<h2 id="测试数据库和表">测试数据库和表</h2>
<ul>
<li><p>这里创建数据库mybatis_plus</p></li>
<li><p>然后创建表user</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS user;</span><br><span class="line"></span><br><span class="line">CREATE TABLE user</span><br><span class="line">(</span><br><span class="line">    id BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;,</span><br><span class="line">    name VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">    age INT(11) NULL DEFAULT NULL COMMENT &#x27;年龄&#x27;,</span><br><span class="line">    email VARCHAR(50) NULL DEFAULT NULL COMMENT &#x27;邮箱&#x27;,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>插入默认数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM user;</span><br><span class="line"></span><br><span class="line">INSERT INTO user (id, name, age, email) VALUES</span><br><span class="line">(1, &#x27;Jone&#x27;, 18, &#x27;test1@baomidou.com&#x27;),</span><br><span class="line">(2, &#x27;Jack&#x27;, 20, &#x27;test2@baomidou.com&#x27;),</span><br><span class="line">(3, &#x27;Tom&#x27;, 28, &#x27;test3@baomidou.com&#x27;),</span><br><span class="line">(4, &#x27;Sandy&#x27;, 21, &#x27;test4@baomidou.com&#x27;),</span><br><span class="line">(5, &#x27;Billie&#x27;, 24, &#x27;test5@baomidou.com&#x27;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="spring-boot工程">Spring Boot工程</h2>
<p>添加依赖，并install Lombok 插件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-generator --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="基础配置">基础配置</h2>
<ul>
<li><p>创建spring boot启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MybatisPlusApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置resources/application.yml文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置数据源</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#配置数据源类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="comment">#配置数据源各个信息</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个时候启动会直接结束，因为我们没有使用springboot-web 包</li>
</ul></li>
<li><p>实体类的创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.mybatisplus.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于get set 无参构造器 hashCode()和equals()、toString()方法重写</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>mapper的创建 mapper/UserMapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.mybatisplus.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.ly.mybatisplus.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将这个类标记成持久层组件 处理测试类中红色下划线的问题</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>设置mapper接口所在的包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ly.mybatisplus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//扫描指定包下的mapper接口</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.ly.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MybatisPlusApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="测试">测试</h2>
<ul>
<li><p>测试类的创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.ly.mybatisplus.MybatisPlusApplication;</span><br><span class="line"><span class="keyword">import</span> com.ly.mybatisplus.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.ly.mybatisplus.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可能是由于没有使用web包依赖，这里要加入classes指定启动类</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = MybatisPlusApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//通过条件构造器查询list集合 null表示没有条件</span></span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="加入日志功能">加入日志功能</h2>
<ul>
<li><p>配置application.yml加入日志</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#日志</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></li>
<li><p>效果 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220603081229650.png"
alt="image-20220603081229650" /></p>
<ul>
<li>如上图，查询的字段名来自于实体类属性</li>
<li><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220603081319437.png"
title="fig:" alt="image-20220603081319437" /></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>mybatis-plus 尚硅谷</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus-sgg-12-18</title>
    <url>/2022/06/03/study/mybatis_plus/bl_sgg/12-18/</url>
    <content><![CDATA[<h2 id="basemapper">BaseMapper</h2>
<ul>
<li><p>注：使用 <code>mvn dependency:resolve -Dclassifier=sources</code>
来获得mapper源码</p></li>
<li><p>一些接口介绍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入一条记录</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 ID 删除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 主键ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据实体(ID)删除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.4.4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(T entity)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> columnMap 表字段 map 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除（根据ID或实体 批量删除）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> idList 主键ID列表或实体列表(不能为 null 以及 empty)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;?&gt; idList)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 ID 修改</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 whereEntity 条件，更新记录</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> entity        实体对象 (set 条件值,可以为 null)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 ID 查询</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 主键ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> idList 主键ID列表(不能为 null 以及 empty)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> columnMap 表字段 map 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 entity 条件，查询一条记录</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;查询一条记录，例如 qw.last(&quot;limit 1&quot;) 限制取一条记录, 注意：多条数据会报异常&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">    List&lt;T&gt; ts = <span class="built_in">this</span>.selectList(queryWrapper);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(ts)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ts.size() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtils.mpe(<span class="string">&quot;One record is expected, but the query result is multiple records&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ts.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 Wrapper 条件，判断是否存在记录</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.selectCount(queryWrapper);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> != count &amp;&amp; count &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Long <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 entity 条件，查询全部记录</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;注意： 只返回第一个字段的值&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page         分页查询条件（可以为 RowBounds.DEFAULT）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;P <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; P <span class="title function_">selectPage</span><span class="params">(P page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page         分页查询条件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;P <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; P <span class="title function_">selectMapsPage</span><span class="params">(P page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>BaseMapper测试</p>
<ul>
<li><p>新增</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">11</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;xx@163.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">insertNum</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+insertNum);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>sql日志输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: INSERT INTO user ( id, name, age, email ) VALUES ( ?, ?, ?, ? )</span><br><span class="line">==&gt; Parameters: 1532542803866394625(Long), 小明(String), 11(Integer), xx@163.com(String)</span><br><span class="line">&lt;==    Updates: 1</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>删除</p>
<ul>
<li><p>id删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">1532542803866394625L</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: DELETE FROM user WHERE id=?</span><br><span class="line">==&gt; Parameters: 1532542803866394625(Long)</span><br><span class="line">&lt;==    Updates: 1</span><br></pre></td></tr></table></figure></li>
<li><p>Map删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; hash=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    hash.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Sandy&quot;</span>);</span><br><span class="line">    hash.put(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteByMap(hash);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: DELETE FROM user WHERE name = ? AND age = ?</span><br><span class="line">==&gt; Parameters: Sandy(String), 1234(String)</span><br><span class="line">&lt;==    Updates: 0</span><br></pre></td></tr></table></figure></li>
<li><p>批量删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByIds</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Long&gt; ids = Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">5L</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteBatchIds(ids);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: DELETE FROM user WHERE id <span class="title function_">IN</span> <span class="params">( ? , ? , ? )</span></span><br><span class="line">==&gt; Parameters: <span class="number">1</span>(Long), <span class="number">2</span>(Long), <span class="number">5</span>(Long)</span><br><span class="line">&lt;==    Updates: <span class="number">3</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>修改</p>
<ul>
<li><p>根据id修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateById</span> <span class="params">()</span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">5L</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;email被修改了&quot;</span> );</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE user SET email=? WHERE id=?</span><br><span class="line">==&gt; Parameters: email被修改了(String), <span class="number">5</span>(Long)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>注意，这里不会修改另一个字段name的值</p></li>
</ul></li>
<li><p>查询</p>
<ul>
<li><p>通过id查询用户信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectById</span> <span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">3</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,name,age,email FROM user WHERE id=?</span><br><span class="line">==&gt; Parameters: 3(Integer)</span><br><span class="line">&lt;==    Columns: id, name, age, email</span><br><span class="line">&lt;==        Row: 3, Tom, 28, test3@baomidou.com</span><br><span class="line">&lt;==      Total: 1</span><br></pre></td></tr></table></figure></li>
<li><p>通过id集合查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectByIds</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">5L</span>));</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,name,age,email FROM user WHERE id IN ( ? , ? , ? )</span><br><span class="line">==&gt; Parameters: 1(Long), 2(Long), 5(Long)</span><br><span class="line">&lt;==    Columns: id, name, age, email</span><br><span class="line">&lt;==        Row: 1, Jone, 18, test1@baomidou.com</span><br><span class="line">&lt;==        Row: 2, Jack, 20, test2@baomidou.com</span><br><span class="line">&lt;==        Row: 5, Billie, 24, email被修改了</span><br><span class="line">&lt;==      Total: 3</span><br></pre></td></tr></table></figure></li>
<li><p>通过map查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    hashMap.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Jon&quot;</span>);</span><br><span class="line">    hashMap.put(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(hashMap);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,name,age,email FROM user WHERE name = ? AND age = ?</span><br><span class="line">==&gt; Parameters: Tom(String), 18(Integer)</span><br><span class="line">&lt;==    Columns: id, name, age, email</span><br><span class="line">&lt;==        Row: 3, Tom, 18, test3@baomidou.com</span><br><span class="line">&lt;==      Total: 1</span><br></pre></td></tr></table></figure></li>
<li><p>查询所有数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectAll</span><span class="params">()</span> &#123; </span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,name,age,email FROM user</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: id, name, age, email</span><br><span class="line">&lt;==        Row: 1, Jone, 18, test1@baomidou.com</span><br><span class="line">&lt;==        Row: 2, Jack, 20, test2@baomidou.com</span><br><span class="line">&lt;==        Row: 3, Tom, 18, test3@baomidou.com</span><br><span class="line">&lt;==        Row: 4, Sandy, 21, test4@baomidou.com</span><br><span class="line">&lt;==        Row: 5, Billie, 24, email被修改了</span><br><span class="line">&lt;==      Total: 5</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ul>
<h2 id="自定义功能">自定义功能</h2>
<ul>
<li><p>mapper映射文件默认位置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">mapper-locations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">classpath:/mapper/**/*.xml</span> <span class="comment">#默认位置</span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220603103731707.png"
alt="image-20220603103731707" />
<figcaption aria-hidden="true">image-20220603103731707</figcaption>
</figure></li>
<li><p>映射文件配置 /mapper/UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ly.mybatisplus.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMapById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        select id,name,age,email from user</span><br><span class="line">        where id = #&#123;id&#125; and 1=1 </span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>代码执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectCustom</span><span class="params">()</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = userMapper.selectMapById(<span class="number">2L</span>);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: select id,name,age,email from user <span class="type">where</span> <span class="variable">id</span> <span class="operator">=</span> ? and <span class="number">1</span>=<span class="number">1</span></span><br><span class="line">==&gt; Parameters: <span class="number">2</span>(Long)</span><br><span class="line">&lt;==    Columns: id, name, age, email</span><br><span class="line">&lt;==        Row: <span class="number">2</span>, Jack, <span class="number">20</span>, test2<span class="meta">@baomidou</span>.com</span><br><span class="line">&lt;==      Total: <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="通用service接口">通用Service接口</h2>
<ul>
<li><p>和通用Mapper的方法名有区分 Service CRUD中</p>
<ul>
<li>使用get查询【mapper-select】</li>
<li>remove删除 【mapper-delete】</li>
<li>list查询集合</li>
<li>page分页</li>
</ul></li>
<li><p>IService源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顶级 Service</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hubin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018-06-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IService</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认批次提交数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">DEFAULT_BATCH_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().insert(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入（批量）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> saveBatch(entityList, DEFAULT_BATCH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入（批量）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize  插入批次数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量修改插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> saveOrUpdateBatch(entityList, DEFAULT_BATCH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量修改插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize  每次的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().deleteById(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id      主键(类型必须与实体类型字段保持一致)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> useFill 是否启用填充(为true的情况,会将入参转换实体进行delete删除)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id, <span class="type">boolean</span> useFill)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持的方法!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实体(ID)删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.4.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().deleteById(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMap 表字段 map 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span> &#123;</span><br><span class="line">        Assert.notEmpty(columnMap, <span class="string">&quot;error: columnMap must not be empty&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().deleteByMap(columnMap));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体包装类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().delete(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 主键ID或实体列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;?&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().deleteBatchIds(list));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list    主键ID或实体列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> useFill 是否填充(为true的情况,会将入参转换实体进行delete删除)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;?&gt; list, <span class="type">boolean</span> useFill)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (useFill) &#123;</span><br><span class="line">            <span class="keyword">return</span> removeBatchByIds(list, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().deleteBatchIds(list));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除(jdbc批量提交)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 主键ID或实体列表(主键ID类型必须与实体类型字段保持一致)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeBatchByIds</span><span class="params">(Collection&lt;?&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeBatchByIds(list, DEFAULT_BATCH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除(jdbc批量提交)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list    主键ID或实体列表(主键ID类型必须与实体类型字段保持一致)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> useFill 是否启用填充(为true的情况,会将入参转换实体进行delete删除)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeBatchByIds</span><span class="params">(Collection&lt;?&gt; list, <span class="type">boolean</span> useFill)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> removeBatchByIds(list, DEFAULT_BATCH_SIZE, useFill);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除(jdbc批量提交)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list      主键ID或实体列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize 批次大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeBatchByIds</span><span class="params">(Collection&lt;?&gt; list, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持的方法!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除(jdbc批量提交)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list      主键ID或实体列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize 批次大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> useFill   是否启用填充(为true的情况,会将入参转换实体进行delete删除)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 删除结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeBatchByIds</span><span class="params">(Collection&lt;?&gt; list, <span class="type">int</span> batchSize, <span class="type">boolean</span> useFill)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持的方法!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 选择修改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().updateById(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 whereEntity 条件，更新记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity        实体对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(getBaseMapper().update(entity, updateWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID 批量更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> updateBatchById(entityList, DEFAULT_BATCH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID 批量更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize  更新批次数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> T <span class="title function_">getById</span><span class="params">(Serializable id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idList 主键ID列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectBatchIds(idList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMap 表字段 map 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectByMap(columnMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper，查询一条记录 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getOne(queryWrapper, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwEx      有多个 result 是否抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapper       转换函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询总记录数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count(Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retCount(getBaseMapper().selectCount(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectList(queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list(Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻页查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         翻页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; E <span class="title function_">page</span><span class="params">(E page, Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectPage(page, queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无条件翻页查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page 翻页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; E <span class="title function_">page</span><span class="params">(E page)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> page(page, Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectMaps(queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listMaps(Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询全部记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listObjs(Function.identity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapper 转换函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listObjs(Wrappers.emptyWrapper(), mapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listObjs(queryWrapper, Function.identity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapper       转换函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectObjs(queryWrapper).stream().filter(Objects::nonNull).map(mapper).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻页查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         翻页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; E <span class="title function_">pageMaps</span><span class="params">(E page, Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getBaseMapper().selectMapsPage(page, queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无条件翻页查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page 翻页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; E <span class="title function_">pageMaps</span><span class="params">(E page)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pageMaps(page, Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取对应 entity 的 BaseMapper</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> BaseMapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BaseMapper&lt;T&gt; <span class="title function_">getBaseMapper</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 entity 的 class</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Class&lt;T&gt;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;T&gt; <span class="title function_">getEntityClass</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下的方法使用介绍:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 一. 名称介绍</span></span><br><span class="line"><span class="comment">     * 1. 方法名带有 query 的为对数据的查询操作, 方法名带有 update 的为对数据的修改操作</span></span><br><span class="line"><span class="comment">     * 2. 方法名带有 lambda 的为内部方法入参 column 支持函数式的</span></span><br><span class="line"><span class="comment">     * 二. 支持介绍</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 方法名带有 query 的支持以 &#123;<span class="doctag">@link</span> ChainQuery&#125; 内部的方法名结尾进行数据查询操作</span></span><br><span class="line"><span class="comment">     * 2. 方法名带有 update 的支持以 &#123;<span class="doctag">@link</span> ChainUpdate&#125; 内部的方法名为结尾进行数据修改操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 三. 使用示例,只用不带 lambda 的方法各展示一个例子,其他类推</span></span><br><span class="line"><span class="comment">     * 1. 根据条件获取一条数据: `query().eq(&quot;column&quot;, value).one()`</span></span><br><span class="line"><span class="comment">     * 2. 根据条件删除一条数据: `update().eq(&quot;column&quot;, value).remove()`</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式查询 普通</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> QueryWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> QueryChainWrapper&lt;T&gt; <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.queryChain(getBaseMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式查询 lambda 式</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;注意：不支持 Kotlin &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LambdaQueryWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> LambdaQueryChainWrapper&lt;T&gt; <span class="title function_">lambdaQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.lambdaQueryChain(getBaseMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式查询 lambda 式</span></span><br><span class="line"><span class="comment">     * kotlin 使用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> KtQueryWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> KtQueryChainWrapper&lt;T&gt; <span class="title function_">ktQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.ktQueryChain(getBaseMapper(), getEntityClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式查询 lambda 式</span></span><br><span class="line"><span class="comment">     * kotlin 使用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> KtQueryWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> KtUpdateChainWrapper&lt;T&gt; <span class="title function_">ktUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.ktUpdateChain(getBaseMapper(), getEntityClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式更改 普通</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> UpdateWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> UpdateChainWrapper&lt;T&gt; <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.updateChain(getBaseMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式更改 lambda 式</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;注意：不支持 Kotlin &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LambdaUpdateWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> LambdaUpdateChainWrapper&lt;T&gt; <span class="title function_">lambdaUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.lambdaUpdateChain(getBaseMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="comment">     * 此次修改主要是减少了此项业务代码的代码量（存在性验证之后的saveOrUpdate操作）</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> update(entity, updateWrapper) || saveOrUpdate(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IService有一个实现类：ServiceImpl</p></li>
<li><p>自定义一个业务Service接口，继承IService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>编写一个实现类，实现UserService接口，并继承ServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这样既可以使用自定义的功能，也可以使用MybatisPlus提供的功能</p></li>
</ul></li>
</ul>
<h2 id="section"></h2>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>mybatis-plus 尚硅谷</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus-sgg-19-39</title>
    <url>/2022/06/03/study/mybatis_plus/bl_sgg/19-39/</url>
    <content><![CDATA[<h2 id="通用service应用">通用Service应用</h2>
<ul>
<li><p>这里会出现 publicKey is now allowed
，在数据库连接语句后面加上这句话即可 allowPublicKeyRetrieval=true</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置数据源</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#配置数据源类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="comment">#配置数据源各个信息</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;&amp;useSSL=false&amp;&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure></li>
<li><p>查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//List&lt;User&gt; list = userService.list();</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userService.count();</span><br><span class="line">    System.out.println(<span class="string">&quot;总条数：&quot;</span>+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SQL执行语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT COUNT( * ) FROM user</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: COUNT( * )</span><br><span class="line">&lt;==        Row: 5</span><br><span class="line">&lt;==      Total: 1</span><br></pre></td></tr></table></figure></li>
<li><p>批量添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;User&gt; users=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;name&quot;</span>+i);</span><br><span class="line">        user.setEmail(<span class="string">&quot;email&quot;</span>+i);</span><br><span class="line">        users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> userService.saveBatch(users);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: INSERT INTO <span class="title function_">user</span> <span class="params">( id, name, email )</span> VALUES ( ?, ?, ? )</span><br><span class="line">==&gt; Parameters: <span class="number">1532579686881243138</span>(Long), name0(String), email0(String)</span><br><span class="line">==&gt; Parameters: <span class="number">1532579687124512770</span>(Long), name1(String), email1(String)</span><br><span class="line">==&gt; Parameters: <span class="number">1532579687128707074</span>(Long), name2(String), email2(String)</span><br><span class="line">==&gt; Parameters: <span class="number">1532579687128707075</span>(Long), name3(String), email3(String)</span><br><span class="line">==&gt; Parameters: <span class="number">1532579687132901377</span>(Long), name4(String), email4(String)</span><br><span class="line">==&gt; Parameters: <span class="number">1532579687137095681</span>(Long), name5(String), email5(String)</span><br><span class="line">==&gt; Parameters: <span class="number">1532579687137095682</span>(Long), name6(String), email6(String)</span><br><span class="line">==&gt; Parameters: <span class="number">1532579687141289985</span>(Long), name7(String), email7(String)</span><br><span class="line">==&gt; Parameters: <span class="number">1532579687145484289</span>(Long), name8(String), email8(String)</span><br><span class="line">==&gt; Parameters: <span class="number">1532579687145484290</span>(Long), name9(String), email9(String)</span><br><span class="line">result:<span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意，这里是一个个的insert into
，而不是一条(单个的sql语句进行循环添加)</p></li>
</ul>
<h2 id="mybatis-plus常用注解1">MyBatis-Plus常用注解1</h2>
<ul>
<li><p>现在将mysql数据库表user名改为t_user 会提示下面的报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cause: java.sql.BatchUpdateException: Table &#x27;mybatis_plus.user&#x27; doesn&#x27;t exist</span><br></pre></td></tr></table></figure>
<p>说明mybatis plus查询的时候会去找实体类名一样的表</p></li>
<li><p>使用@TableName("t_user") 设置实体类对应的表名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修改后执行成功</li>
</ul></li>
<li><p>统一添加</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br></pre></td></tr></table></figure></li>
<li><p>指定主键名
假设现在把数据库列名和bean的属性名id改为uid,此时新增一条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Field &#x27;uid&#x27; doesn&#x27;t have a default value</span><br><span class="line">; Field &#x27;uid&#x27; doesn&#x27;t have a default value; nested exception is java.sql.SQLException: Field &#x27;uid&#x27; doesn&#x27;t have a default value</span><br></pre></td></tr></table></figure>
<ul>
<li>说明此时没有为uid赋值</li>
</ul></li>
<li><p>使用@TableId告诉mybatis-plus那个字段为主键，让mybatis-plus为他赋默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long uid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: INSERT INTO t_user ( uid, name, age ) VALUES ( ?, ?, ? )</span><br><span class="line">==&gt; Parameters: 1532582462671618050(Long), 张三(String), 18(Integer)</span><br><span class="line">&lt;==    Updates: 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="tableid的value属性"><span class="citation"
data-cites="TableId的value属性">@TableId的value属性</span></h2>
<ul>
<li><p>用于指定绑定的主键的字段
假设此时将bean的主键属性名为id，数据库主键名是uid</p></li>
<li><p>此时运行，会提示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">### SQL: INSERT INTO <span class="title function_">t_user</span>  <span class="params">( id, name, age )</span>  VALUES  ( ?, ?, ? )</span><br><span class="line">### Cause: java.sql.SQLSyntaxErrorException: Unknown column <span class="string">&#x27;id&#x27;</span> in <span class="string">&#x27;field list&#x27;</span></span><br></pre></td></tr></table></figure>
<p>他会拿bean的属性来生成sql语句</p></li>
<li><p>加上@TableId(value="uid")后运行正常</p></li>
</ul>
<h2 id="tableid的value属性-1"><span class="citation"
data-cites="TableId的value属性">@TableId的value属性</span></h2>
<ul>
<li><p>```java</p>
<p>/**</p>
<ul>
<li><p>生成ID类型枚举类</p></li>
<li></li>
<li><p><span class="citation" data-cites="author">@author</span>
hubin</p></li>
<li><p><span class="citation" data-cites="since">@since</span>
2015-11-10 */ <span class="citation" data-cites="Getter">@Getter</span>
public enum IdType { /**</p>
<ul>
<li>数据库ID自增</li>
<li><p>
该类型请确保数据库设置了 ID自增 否则无效
</p>
*/ AUTO(0), /**</li>
<li>该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT) */
NONE(1), /**</li>
<li>用户输入ID</li>
<li><p>
该类型可以通过自己注册自动填充插件进行填充
</p>
*/ INPUT(2),</li>
</ul>
<p>/* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */ /**</p>
<ul>
<li>分配ID (主键类型为number或string）,</li>
<li>默认实现类 {<span class="citation" data-cites="link">@link</span>
com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(雪花算法)</li>
<li></li>
<li><span class="citation" data-cites="since">@since</span> 3.3.0 */
ASSIGN_ID(3), /**</li>
<li>分配UUID (主键类型为 string)</li>
<li>默认实现类 {<span class="citation" data-cites="link">@link</span>
com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator}(UUID.replace("-",""))
*/ ASSIGN_UUID(4);</li>
</ul>
<p>private final int key;</p>
<p>IdType(int key) { this.key = key; } } <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  //使用自增</span><br><span class="line">  @TableId(value=&quot;uid&quot;,type = IdType.AUTO )</span><br><span class="line">      private Long id;</span><br><span class="line">     </span><br></pre></td></tr></table></figure></p></li>
</ul></li>
<li><p>然后将数据库主键设置为自动递增</p></li>
<li><p>新增后id为6</p></li>
</ul>
<h2 id="通过全局属性设置主键生成策略">通过全局属性设置主键生成策略</h2>
<ul>
<li><p>全局配置设置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> </span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span> </span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="雪花算法">雪花算法</h2>
<ul>
<li>数据库扩展方式：主从复制、业务分库、数据库分表</li>
<li>数据库拆分：水平拆分、垂直拆分</li>
<li>水平分表相对垂直分表，会引入更多的复杂性，比如要求唯一的数据id该怎么处理
<ul>
<li>可以给每个分表都给定一个范围大小，但是这样分段大小不好取</li>
<li>可以取模，但是如果增加了机器，原来的值主键（怎么处理是个问题</li>
<li>雪花算法，由Twitter公布的分布式主键生成算法
能够保证不同表的主键的不重复性，以及相同表的主键的有序性</li>
<li>核心思想 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220603182604230.png"
alt="image-20220603182604230" /></li>
<li></li>
</ul></li>
</ul>
<h2 id="mybatis-plus常用注解2">MyBatis-Plus常用注解2</h2>
<ul>
<li><p>此时数据库字段名为name，如果现在实体类的名字改为userName，那么会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO t_user  ( user_name, age )  VALUES  ( ?, ? )</span><br></pre></td></tr></table></figure>
<p>又一次证明了MyBatis-plus通过实体类属性猜测数据库表的相关字段</p>
<ul>
<li><p>使用@TableFiled来指定对应的字段名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField(value = &quot;name&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br></pre></td></tr></table></figure></li>
<li><p>查询</p>
<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(<span class="number">5L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;结果:&quot;</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>sql执行语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT uid AS id,name AS userName,age,email,is_deleted_ly FROM t_user WHERE uid=? AND is_deleted_ly=0</span><br><span class="line">==&gt; Parameters: 5(Long)</span><br><span class="line">&lt;==    Columns: id, userName, age, email, is_deleted_ly</span><br><span class="line">&lt;==        Row: 5, Billie, 24, email被修改了, 0</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@5e048149]</span><br><span class="line">结果:User(id=5, userName=Billie, age=24, email=email被修改了, isDeletedLy=0)</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>逻辑删除(主要是允许数据的恢复)
这里增加一个isDeletedLy字段（这里为了测试，一般是isDeleted）</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220603234839526.png"
alt="image-20220603234839526" />
<figcaption aria-hidden="true">image-20220603234839526</figcaption>
</figure>
<ul>
<li><p>在User类添加下面的字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="keyword">private</span> Integer isDeletedLy;</span><br></pre></td></tr></table></figure></li>
<li><p>逻辑删除</p>
<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteLogic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> userService.removeBatchByIds(Arrays.asList(<span class="number">1L</span>,<span class="number">2L</span>,<span class="number">3L</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;结果:&quot;</span> + save);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql执行语句
<strong>注意，这里使用了is_deleted_ly=0是因为在下面的步骤加入了逻辑删除注解</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE t_user SET is_deleted_ly=1 WHERE uid=? AND is_deleted_ly=0</span><br><span class="line">==&gt; Parameters: 1(Long)</span><br><span class="line">==&gt; Parameters: 2(Long)</span><br><span class="line">==&gt; Parameters: 3(Long)</span><br></pre></td></tr></table></figure></li>
<li><p>结果 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220603235258702.png"
alt="image-20220603235258702" /></p></li>
</ul></li>
</ul></li>
</ul>
<h2 id="条件构造器">条件构造器</h2>
<ul>
<li><p>结构 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220603235853815.png"
alt="image-20220603235853815" /></p>
<ul>
<li>解释 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220603235924382.png"
alt="image-20220603235924382" /></li>
</ul></li>
<li><p>查看BaseWrapper源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mapper 继承该接口后，无需编写 mapper.xml 文件，即可获得CRUD功能</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;这个 Mapper 支持 id 泛型&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hubin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2016-01-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseMapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实体(ID)删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.4.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMap 表字段 map 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除（根据ID或实体 批量删除）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idList 主键ID列表或实体列表(不能为 null 以及 empty)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;?&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 修改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 whereEntity 条件，更新记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity        实体对象 (set 条件值,可以为 null)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idList 主键ID列表(不能为 null 以及 empty)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMap 表字段 map 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，查询一条记录</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;查询一条记录，例如 qw.last(&quot;limit 1&quot;) 限制取一条记录, 注意：多条数据会报异常&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        List&lt;T&gt; ts = <span class="built_in">this</span>.selectList(queryWrapper);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(ts)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ts.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ExceptionUtils.mpe(<span class="string">&quot;One record is expected, but the query result is multiple records&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ts.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，判断是否存在记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.selectCount(queryWrapper);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> != count &amp;&amp; count &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Long <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;注意： 只返回第一个字段的值&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         分页查询条件（可以为 RowBounds.DEFAULT）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;P <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; P <span class="title function_">selectPage</span><span class="params">(P page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         分页查询条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;P <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; P <span class="title function_">selectMapsPage</span><span class="params">(P page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Wrapper条件组装 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604110742317.png"
alt="image-20220604110742317" /></p>
<ul>
<li><p>queryWrapper测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; userQueryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//链式结构调用</span></span><br><span class="line">    userQueryWrapper.like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">            .between(<span class="string">&quot;age&quot;</span>, <span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line">            .isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(userQueryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>sql日志打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意，这里出现了逻辑删除条件</span></span><br><span class="line">==&gt;  Preparing: SELECT uid AS id,name AS userName,age,email,is_deleted_ly FROM t_user WHERE is_deleted_ly=<span class="number">0</span> AND (name LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)</span><br><span class="line">==&gt; Parameters: %a%(String), <span class="number">10</span>(Integer), <span class="number">30</span>(Integer)</span><br><span class="line">&lt;==    Columns: id, userName, age, email, is_deleted_ly</span><br><span class="line">&lt;==        Row: <span class="number">4</span>, Sandy, <span class="number">21</span>, test4<span class="meta">@baomidou</span>.com, <span class="number">0</span></span><br><span class="line">&lt;==        Row: <span class="number">5</span>, Billiea, <span class="number">24</span>, email被修改了, <span class="number">0</span></span><br><span class="line">&lt;==      Total: <span class="number">2</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@19650aa6]</span><br><span class="line">User(id=<span class="number">4</span>, userName=Sandy, age=<span class="number">21</span>, email=test4<span class="meta">@baomidou</span>.com, isDeletedLy=<span class="number">0</span>)</span><br><span class="line">User(id=<span class="number">5</span>, userName=Billiea, age=<span class="number">24</span>, email=email被修改了, isDeletedLy=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>使用排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; userQueryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">     userQueryWrapper.orderByDesc(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">             .orderByAsc(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(userQueryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>sql日志打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT uid AS id,name AS userName,age,email,is_deleted_ly FROM t_user WHERE is_deleted_ly=0 ORDER BY age DESC,uid ASC</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: id, userName, age, email, is_deleted_ly</span><br><span class="line">&lt;==        Row: 7, 张三6, 38, test6@baomidou.com, 0</span><br><span class="line">&lt;==        Row: 5, Billiea, 24, email被修改了, 0</span><br><span class="line">&lt;==        Row: 4, Sandy, 21, test4@baomidou.com, 0</span><br><span class="line">&lt;==        Row: 6, 张三5, 18, test5@baomidou.com, 0</span><br><span class="line">&lt;==        Row: 8, 张三a, 18, null, 0</span><br><span class="line">&lt;==      Total: 5</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@7158daf2]</span><br><span class="line">User(id=7, userName=张三6, age=38, email=test6@baomidou.com, isDeletedLy=0)</span><br><span class="line">User(id=5, userName=Billiea, age=24, email=email被修改了, isDeletedLy=0)</span><br><span class="line">User(id=4, userName=Sandy, age=21, email=test4@baomidou.com, isDeletedLy=0)</span><br><span class="line">User(id=6, userName=张三5, age=18, email=test5@baomidou.com, isDeletedLy=0)</span><br><span class="line">User(id=8, userName=张三a, age=18, email=null, isDeletedLy=0)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>条件逻辑删除</p>
<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; userQueryWrapper=<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    userQueryWrapper.isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">deleted</span> <span class="operator">=</span> userMapper.delete(userQueryWrapper);</span><br><span class="line">    System.out.println(deleted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE t_user SET is_deleted_ly=1 WHERE is_deleted_ly=0 AND (email IS NULL)</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Updates: 1</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; userQueryWrapper=<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//(age&gt;23且用户名包含a)  或 (邮箱为null)</span></span><br><span class="line">    userQueryWrapper.gt(<span class="string">&quot;age&quot;</span>,<span class="number">23</span>)</span><br><span class="line">            .like(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">            .or()</span><br><span class="line">            .isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUserName(<span class="string">&quot;被修改了&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">deleted</span> <span class="operator">=</span> userMapper.update(user,userQueryWrapper);</span><br><span class="line">    System.out.println(deleted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE t_user SET name=? WHERE is_deleted_ly=0 AND (age &gt; ? AND name LIKE ? OR email IS NULL)</span><br><span class="line">==&gt; Parameters: 被修改了(String), 23(Integer), %a%(String)</span><br><span class="line">&lt;==    Updates: 1</span><br></pre></td></tr></table></figure></li>
<li><p>条件优先级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; userQueryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//(age&gt;23且用户名包含a)  或 (邮箱为null)</span></span><br><span class="line">    userQueryWrapper</span><br><span class="line">            .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">            <span class="comment">//and里面是一个条件构造器</span></span><br><span class="line">            .and(</span><br><span class="line">                    userQueryWrapper1 -&gt;</span><br><span class="line">                            userQueryWrapper1.gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">                                    .or()</span><br><span class="line">                                    .isNull(<span class="string">&quot;email&quot;</span>)</span><br><span class="line">            );</span><br><span class="line">    </span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUserName(<span class="string">&quot;被修改了&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">deleted</span> <span class="operator">=</span> userMapper.update(user, userQueryWrapper);</span><br><span class="line">    System.out.println(deleted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE t_user SET name=? WHERE is_deleted_ly=0 AND (name LIKE ? AND (age &gt; ? OR email IS NULL))</span><br><span class="line">==&gt; Parameters: 被修改了(String), %a%(String), 20(Integer)</span><br><span class="line">&lt;==    Updates: 1</span><br></pre></td></tr></table></figure></li>
<li><p>注意 or也有优先级的参数 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604112732422.png"
alt="image-20220604112732422" /></p></li>
</ul></li>
<li><p>只查询某些字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; userQueryWrapper</span><br><span class="line">            =<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    userQueryWrapper.select(<span class="string">&quot;uid&quot;</span>,<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(userQueryWrapper);</span><br><span class="line">    System.out.println(maps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT uid,name FROM t_user WHERE is_deleted_ly=0</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: uid, name</span><br><span class="line">&lt;==        Row: 4, 被修改了</span><br><span class="line">&lt;==        Row: 5, 被修改了</span><br><span class="line">&lt;==        Row: 6, 张三5</span><br><span class="line">&lt;==        Row: 7, 张三6</span><br><span class="line">&lt;==      Total: 4</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>子查询 假设需要完整下面的sql查询 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604113152896.png"
alt="image-20220604113152896" /></p>
<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//查询id小于等于100</span></span><br><span class="line">    QueryWrapper&lt;User&gt;</span><br><span class="line">            userQueryWrapper=<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    userQueryWrapper.inSql(<span class="string">&quot;uid&quot;</span>,</span><br><span class="line">            <span class="string">&quot;select uid from t_user where uid &lt;= 100&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(userQueryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT uid AS id,name AS userName,age,email,is_deleted_ly FROM t_user WHERE is_deleted_ly=0 AND (uid IN (select uid from t_user where uid &lt;= 100))</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: id, userName, age, email, is_deleted_ly</span><br><span class="line">&lt;==        Row: 4, 被修改了, 21, test4@baomidou.com, 0</span><br><span class="line">&lt;==        Row: 5, 被修改了, 24, email被修改了, 0</span><br><span class="line">&lt;==        Row: 6, 张三5, 18, test5@baomidou.com, 0</span><br><span class="line">&lt;==        Row: 7, 张三6, 38, test6@baomidou.com, 0</span><br><span class="line">&lt;==      Total: 4</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>UpdateWrapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test8</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//(age&gt;23且用户名包含a)  或 (邮箱为null)</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; updateWrapper=<span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.like(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">            .and(userUpdateWrapper -&gt;</span><br><span class="line">                    userUpdateWrapper.gt(<span class="string">&quot;age&quot;</span>,<span class="number">23</span>).or().isNotNull(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">    updateWrapper.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小黑&quot;</span>).set(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;abc@ly.com&quot;</span>);</span><br><span class="line">    userMapper.update(<span class="literal">null</span>,updateWrapper);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE t_user SET name=?,email=? WHERE is_deleted_ly=<span class="number">0</span> AND (name LIKE ? AND (age &gt; ? OR email IS NOT NULL))</span><br><span class="line">==&gt; Parameters: 小黑(String), abc<span class="meta">@ly</span>.com(String), %a%(String), <span class="number">23</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>模拟用户操作组装条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test9</span><span class="params">()</span>&#123;</span><br><span class="line">    String username=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    Integer ageBegin=<span class="literal">null</span>;</span><br><span class="line">    Integer ageEnd=<span class="number">30</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper=<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(username))&#123;</span><br><span class="line">        queryWrapper.like(<span class="string">&quot;user_name&quot;</span>,username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( ageBegin!=<span class="literal">null</span>)&#123;</span><br><span class="line">        queryWrapper.gt(<span class="string">&quot;age&quot;</span>,ageBegin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( ageEnd!=<span class="literal">null</span>)&#123;</span><br><span class="line">        queryWrapper.le(<span class="string">&quot;age&quot;</span>,ageEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    userMapper.selectList(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT uid AS id,name AS userName,age,email,is_deleted_ly FROM t_user WHERE is_deleted_ly=0 AND (age &lt;= ?)</span><br><span class="line">==&gt; Parameters: 30(Integer)</span><br><span class="line">&lt;==    Columns: id, userName, age, email, is_deleted_ly</span><br><span class="line">&lt;==        Row: 4, 被修改了, 21, test4@baomidou.com, 0</span><br><span class="line">&lt;==        Row: 5, 被修改了, 24, email被修改了, 0</span><br><span class="line">&lt;==        Row: 6, 张三5, 18, test5@baomidou.com, 0</span><br><span class="line">&lt;==      Total: 3</span><br></pre></td></tr></table></figure></li>
<li><p>使用condition处理条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">  </span><br><span class="line">    String username=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    Integer ageBegin=<span class="literal">null</span>;</span><br><span class="line">    Integer ageEnd=<span class="number">30</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper=<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(StringUtils.isNotBlank(username),<span class="string">&quot;name&quot;</span>,username)</span><br><span class="line">            .ge(ageBegin!=<span class="literal">null</span>,<span class="string">&quot;age&quot;</span>,ageBegin);</span><br><span class="line">    userMapper.selectList(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT uid AS id,name AS userName,age,email,is_deleted_ly FROM t_user WHERE is_deleted_ly=0 AND (name LIKE ?)</span><br><span class="line">==&gt; Parameters: %abc%(String)</span><br><span class="line">&lt;==      Total: 0</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>mybatis-plus 尚硅谷</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis-plus-sgg-40-57</title>
    <url>/2022/06/04/study/mybatis_plus/bl_sgg/40-57/</url>
    <content><![CDATA[<h2 id="lambdaxxxwrapper">LambdaXxxWrapper</h2>
<ul>
<li><p>LambdaQueryWrapper主要是为了防止字段名写错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">  </span><br><span class="line">     String username=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">     Integer ageBegin=<span class="literal">null</span>;</span><br><span class="line">     Integer ageEnd=<span class="number">30</span>;</span><br><span class="line">     LambdaQueryWrapper&lt;User&gt; queryWrapper=<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">     queryWrapper.like(StringUtils.isNotBlank(username),User::getUserName,username)</span><br><span class="line">             .ge(ageBegin!=<span class="literal">null</span>,User::getAge,ageBegin);</span><br><span class="line">     userMapper.selectList(queryWrapper);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>sql日志打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT uid AS id,name AS userName,age,email,is_deleted_ly FROM t_user WHERE is_deleted_ly=0 AND (name LIKE ?)</span><br><span class="line">==&gt; Parameters: %abc%(String)</span><br><span class="line">&lt;==      Total: 0</span><br></pre></td></tr></table></figure></li>
<li><p>LambdaUpdateWrapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test12</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//(age&gt;23且用户名包含a)  或 (邮箱为null)</span></span><br><span class="line">    LambdaUpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.like(User::getUserName, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">            .and(userUpdateWrapper -&gt;</span><br><span class="line">                    userUpdateWrapper.gt(User::getAge, <span class="number">23</span>).or().isNotNull(User::getEmail));</span><br><span class="line">    updateWrapper.set(User::getUserName, <span class="string">&quot;小黑&quot;</span>).set(User::getEmail, <span class="string">&quot;abc@ly.com&quot;</span>);</span><br><span class="line">    userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE t_user SET name=?,email=? WHERE is_deleted_ly=<span class="number">0</span> AND (name LIKE ? AND (age &gt; ? OR email IS NOT NULL))</span><br><span class="line">==&gt; Parameters: 小黑(String), abc<span class="meta">@ly</span>.com(String), %a%(String), <span class="number">23</span>(Integer)</span><br><span class="line">&lt;==    Updates: <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="mybatis分页">MyBatis分页</h2>
<ul>
<li><p>先使用配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.ly.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        MybatisPlusInterceptor mybatisPlusInterceptor=<span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span> &#123;</span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line">    page.setCurrent(<span class="number">2</span>);<span class="comment">//当前页页码</span></span><br><span class="line">    page.setSize(<span class="number">3</span>);<span class="comment">//每页条数</span></span><br><span class="line">    Page&lt;User&gt; userPage = userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(userPage.getRecords() + <span class="string">&quot;----\n&quot;</span></span><br><span class="line">            + userPage.getPages() + <span class="string">&quot;----\n&quot;</span></span><br><span class="line">            + userPage.getTotal() + <span class="string">&quot;---\n&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT uid AS id,name AS userName,age,email,is_deleted_ly FROM t_user WHERE is_deleted_ly=0 LIMIT ?,?</span><br><span class="line">==&gt; Parameters: 3(Long), 3(Long)</span><br><span class="line">&lt;==    Columns: id, userName, age, email, is_deleted_ly</span><br><span class="line">&lt;==        Row: 4, 被修改了, 21, test4@baomidou.com, 0</span><br><span class="line">&lt;==        Row: 5, 被修改了, 24, email被修改了, 0</span><br><span class="line">&lt;==        Row: 6, 张三5, 18, test5@baomidou.com, 0</span><br><span class="line">&lt;==      Total: 3</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结果Page对象的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[User(id=4, userName=被修改了, age=21, email=test4@baomidou.com, isDeletedLy=0), User(id=5, userName=被修改了, age=24, email=email被修改了, isDeletedLy=0), User(id=6, userName=张三5, age=18, email=test5@baomidou.com, isDeletedLy=0)]----</span><br><span class="line">3----</span><br><span class="line">8---</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>自定义分页功能</p>
<ul>
<li><p>首先，设置类型别名所在的包</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> </span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.ly.mybatisplus.pojo</span></span><br></pre></td></tr></table></figure></li>
<li><p>在Mapper类中编写接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过年龄查询并分页</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page mybatis-plus提供的，必须存在且在第一个位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Page&lt;User&gt; <span class="title function_">selectPageVO</span><span class="params">(Page&lt;User&gt; page,Integer age)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意第一个参数</p></li>
<li><p>在Mapper.xml中编写语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPageVO&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select uid,name,email from t_user where age &gt; #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageCustom</span><span class="params">()</span> &#123;</span><br><span class="line">     Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;();</span><br><span class="line">     page.setCurrent(<span class="number">3</span>);<span class="comment">//当前页页码</span></span><br><span class="line">     page.setSize(<span class="number">5</span>);<span class="comment">//每页条数</span></span><br><span class="line">     Page&lt;User&gt; userPage = userMapper.selectPageVO(page, <span class="number">12</span>);</span><br><span class="line">     System.out.println(userPage.getRecords() + <span class="string">&quot;----\n&quot;</span></span><br><span class="line">             + userPage.getPages() + <span class="string">&quot;----\n&quot;</span></span><br><span class="line">             + userPage.getTotal() + <span class="string">&quot;---\n&quot;</span>)</span><br><span class="line">     ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>sql日志输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT COUNT(*) AS total FROM t_user WHERE age &gt; ?</span><br><span class="line">==&gt; Parameters: 12(Integer)</span><br><span class="line">&lt;==    Columns: total</span><br><span class="line">&lt;==        Row: 20</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">//从第10行开始（不包括第10行），取5条记录</span><br><span class="line">==&gt;  Preparing: select uid,name,email from t_user where age &gt; ? LIMIT ?,?</span><br><span class="line">==&gt; Parameters: 12(Integer), 10(Long), 5(Long)</span><br><span class="line">&lt;==    Columns: uid, name, email</span><br><span class="line">&lt;==        Row: 11, a, null</span><br><span class="line">&lt;==        Row: 12, a, null</span><br><span class="line">&lt;==        Row: 13, a, null</span><br><span class="line">&lt;==        Row: 14, a, null</span><br><span class="line">&lt;==        Row: 15, a, null</span><br><span class="line">&lt;==      Total: 5</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@706fe5c6]</span><br><span class="line">[null, null, null, null, null]----</span><br><span class="line">4----</span><br><span class="line">20---</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意上面那个sql，他会先查询条数，如果条数&lt;=0，那么就不会执行下面的数据搜索了</p></li>
</ul></li>
</ul>
<h2 id="悲观锁和乐观锁">悲观锁和乐观锁</h2>
<ul>
<li><p>场景 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604141320188.png"
alt="image-20220604141320188" /></p></li>
<li><p>乐观锁根据版本号使用 version</p></li>
<li><p>乐观锁实现流程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604141615175.png"
alt="image-20220604141615175" /></p></li>
</ul>
<h2 id="模拟冲突">模拟冲突</h2>
<ul>
<li><p>表创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_product (</span><br><span class="line">	id BIGINT ( 20 ) NOT NULL COMMENT &#x27;主键id&#x27;,</span><br><span class="line">	NAME VARCHAR ( 30 ) null DEFAULT NULL COMMENT &#x27;商品名称&#x27;,</span><br><span class="line">	price INT ( 11 ) DEFAULT 0 COMMENT &#x27;价格&#x27;,</span><br><span class="line">	version INT ( 11 ) DEFAULT 0 COMMENT &#x27;乐观锁版本号&#x27;,</span><br><span class="line">    PRIMARY KEY ( id ) </span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>创建ProductMapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Product&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数据库数据 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604142342514.png"
alt="image-20220604142342514" /></p></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testModel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//小李查询商品</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productLi</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//小王查询商品</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productWang</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//小李将商品加50</span></span><br><span class="line">    productLi.setPrice(productLi.getPrice()+<span class="number">50</span>);</span><br><span class="line">    productMapper.updateById(productLi);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//小王将价格降低30</span></span><br><span class="line">    productWang.setPrice(productWang.getPrice()-<span class="number">30</span>);</span><br><span class="line">    productMapper.updateById(productWang);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE t_product SET name=?, price=?, version=? WHERE id=?</span><br><span class="line">==&gt; Parameters: 外星人(String), <span class="number">150</span>(Integer), <span class="number">0</span>(Integer), <span class="number">1</span>(Long)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6325f352]</span><br><span class="line">Creating a <span class="keyword">new</span> <span class="title class_">SqlSession</span></span><br><span class="line">SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@70730db] was not registered <span class="keyword">for</span> synchronization because synchronization is not active</span><br><span class="line">JDBC Connection [HikariProxyConnection@<span class="number">91831175</span> wrapping com.mysql.cj.jdbc.ConnectionImpl@74ea46e2] will not be managed <span class="type">by</span> <span class="variable">Spring</span></span><br><span class="line"><span class="operator">=</span>=&gt;  Preparing: UPDATE t_product SET name=?, price=?, version=? WHERE id=?</span><br><span class="line">==&gt; Parameters: 外星人(String), <span class="number">70</span>(Integer), <span class="number">0</span>(Integer), <span class="number">1</span>(Long)</span><br><span class="line">&lt;==    Updates: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>//最终结果为70</p></li>
</ul>
<h2 id="乐观锁插件">乐观锁插件</h2>
<ul>
<li><p>在实体类中使用@Version注解表示乐观锁版本号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure></li>
<li><p>配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    MybatisPlusInterceptor mybatisPlusInterceptor=<span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">    <span class="comment">//添加乐观锁插件</span></span><br><span class="line">    mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>再次运行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testModel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//小李查询商品</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productLi</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//小王查询商品</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productWang</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//小李将商品加50</span></span><br><span class="line">    productLi.setPrice(productLi.getPrice()+<span class="number">50</span>);</span><br><span class="line">    productMapper.updateById(productLi);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//小王将价格降低30</span></span><br><span class="line">    productWang.setPrice(productWang.getPrice()-<span class="number">30</span>);</span><br><span class="line">    productMapper.updateById(productWang);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</span><br><span class="line">==&gt; Parameters: 外星人(String), 120(Integer), 1(Integer), 1(Long), 0(Integer)</span><br><span class="line">&lt;==    Updates: 1</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2d64160c]</span><br><span class="line">Creating a new SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@33063f5b] was not registered for synchronization because synchronization is not active</span><br><span class="line">JDBC Connection [HikariProxyConnection@356539350 wrapping com.mysql.cj.jdbc.ConnectionImpl@127a7272] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</span><br><span class="line">==&gt; Parameters: 外星人(String), 40(Integer), 1(Integer), 1(Long), 0(Integer)</span><br><span class="line">&lt;==    Updates: 0</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="优化修改流程">优化修改流程</h2>
<ul>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testModel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//小李查询商品</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productLi</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//小王查询商品</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productWang</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//小李将商品加50</span></span><br><span class="line">    productLi.setPrice(productLi.getPrice() + <span class="number">50</span>);</span><br><span class="line">    productMapper.updateById(productLi);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//小王将价格降低30</span></span><br><span class="line">    productWang.setPrice(productWang.getPrice() - <span class="number">30</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> productMapper.updateById(productWang);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//如果小王操作失败,再获取一次</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">        product.setPrice(product.getPrice() - <span class="number">30</span>);</span><br><span class="line">        productMapper.updateById(product);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sql日志打印</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</span><br><span class="line">==&gt; Parameters: 外星人(String), 150(Integer), 6(Integer), 1(Long), 5(Integer)</span><br><span class="line">&lt;==    Updates: 1</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@544e8149]</span><br><span class="line">Creating a new SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@48a0c8aa] was not registered for synchronization because synchronization is not active</span><br><span class="line">JDBC Connection [HikariProxyConnection@1637000661 wrapping com.mysql.cj.jdbc.ConnectionImpl@5f481b73] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</span><br><span class="line">==&gt; Parameters: 外星人(String), 70(Integer), 6(Integer), 1(Long), 5(Integer)</span><br><span class="line">&lt;==    Updates: 0</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@48a0c8aa]</span><br><span class="line">Creating a new SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4cbc2e3b] was not registered for synchronization because synchronization is not active</span><br><span class="line">JDBC Connection [HikariProxyConnection@43473566 wrapping com.mysql.cj.jdbc.ConnectionImpl@5f481b73] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: SELECT id,name,price,version FROM t_product WHERE id=?</span><br><span class="line">==&gt; Parameters: 1(Long)</span><br><span class="line">&lt;==    Columns: id, name, price, version</span><br><span class="line">&lt;==        Row: 1, 外星人, 150, 6</span><br><span class="line">&lt;==      Total: 1</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@4cbc2e3b]</span><br><span class="line">Creating a new SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@57562473] was not registered for synchronization because synchronization is not active</span><br><span class="line">JDBC Connection [HikariProxyConnection@2050360660 wrapping com.mysql.cj.jdbc.ConnectionImpl@5f481b73] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: UPDATE t_product SET name=?, price=?, version=? WHERE id=? AND version=?</span><br><span class="line">==&gt; Parameters: 外星人(String), 120(Integer), 7(Integer), 1(Long), 6(Integer)</span><br><span class="line">&lt;==    Updates: 1</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@57562473]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="通用枚举">通用枚举</h2>
<ul>
<li><p>添加一个enum类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SexEnum</span> &#123;</span><br><span class="line">    MALE(<span class="number">1</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">    FEMALE(<span class="number">2</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br><span class="line">    <span class="keyword">private</span> String sexName;</span><br><span class="line"></span><br><span class="line">    SexEnum(Integer sex, String sexName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.sexName = sexName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数据库增加一个sex 字段，实体类增加一个sex属性 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604163208649.png"
alt="image-20220604163208649" /></p>
<ul>
<li><p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SexEnum sex;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>进行添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testEnum</span><span class="params">()</span>&#123;</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUserName(<span class="string">&quot;enum - 测试名字&quot;</span>);</span><br><span class="line">    user.setSexEnum(SexEnum.MALE);</span><br><span class="line">    <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    System.out.println(insert);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注意看sql日志，有报错信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: INSERT INTO t_user ( name, sex ) VALUES ( ?, ? )</span><br><span class="line">==&gt; Parameters: enum - 测试名字(String), MALE(String)</span><br><span class="line"></span><br><span class="line">### SQL: INSERT INTO t_user  ( name,    sex )  VALUES  ( ?,    ? )</span><br><span class="line">### Cause: java.sql.SQLException: Incorrect integer value: &#x27;MALE&#x27; for column &#x27;sex&#x27; at row 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>插入了非数字</p></li>
<li><p>修正，enum类添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnumValue</span> <span class="comment">//将注解所标识的属性的值设置到数据库</span></span><br><span class="line">    <span class="keyword">private</span> Integer sex;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>扫描通用枚举的包 application.yml中</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> </span><br><span class="line">  <span class="attr">type-enums-package:</span> <span class="string">com.ly.mybatisplus.enums</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>运行测试类并查看日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: INSERT INTO t_user ( name, sex ) VALUES ( ?, ? )</span><br><span class="line">==&gt; Parameters: enum - 测试名字(String), 1(Integer)</span><br><span class="line">&lt;==    Updates: 1</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="代码生成器">代码生成器</h2>
<a href="/2022/05/20/study/mybatis_plus/official/hello/" title="hello-world">在28%进度的地方</a>
<ul>
<li><p>mybatis-plus 代码自动生成</p>
<ul>
<li><p>maven 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">      </span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-generator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.velocity/velocity-engine-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在测试类中编写程序让其自动生成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.FastAutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.jdbc.ScriptRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 快速生成</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lanjerry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-09-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastAutoGeneratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行初始化数据库脚本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DATA_SOURCE_CONFIG.build().getConn();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> FastAutoGeneratorTest.class.getResourceAsStream(<span class="string">&quot;/db/schema-mysql.sql&quot;</span>);</span><br><span class="line">        <span class="type">ScriptRunner</span> <span class="variable">scriptRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptRunner</span>(conn);</span><br><span class="line">        scriptRunner.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">        scriptRunner.runScript(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据源配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DataSourceConfig.<span class="type">Builder</span> <span class="variable">DATA_SOURCE_CONFIG</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span></span><br><span class="line">            .Builder(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis_plus_demo?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;nullCatalogMeansCurrent=true&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 run</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        before();</span><br><span class="line">        FastAutoGenerator.create(DATA_SOURCE_CONFIG)</span><br><span class="line">                <span class="comment">// 全局配置</span></span><br><span class="line">                .globalConfig((scanner, builder) -&gt; builder.author(scanner.apply(<span class="string">&quot;请输入作者名称&quot;</span>)))</span><br><span class="line">                <span class="comment">// 包配置</span></span><br><span class="line">                .packageConfig((scanner, builder) -&gt; builder.parent(scanner.apply(<span class="string">&quot;请输入包名&quot;</span>)))</span><br><span class="line">                <span class="comment">// 策略配置</span></span><br><span class="line">                .strategyConfig((scanner, builder) -&gt; builder.addInclude(scanner.apply(<span class="string">&quot;请输入表名，多个表名用,隔开&quot;</span>)))</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    模板引擎配置，默认 Velocity 可选模板引擎 Beetl 或 Freemarker</span></span><br><span class="line"><span class="comment">                   .templateEngine(new BeetlTemplateEngine())</span></span><br><span class="line"><span class="comment">                   .templateEngine(new FreemarkerTemplateEngine())</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>shang gui gu 配置 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604165408694.png"
alt="image-20220604165408694" /></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604165451088.png"
alt="image-20220604165451088" />
<figcaption aria-hidden="true">image-20220604165451088</figcaption>
</figure></li>
<li></li>
</ul></li>
</ul>
<h2 id="模拟多数据源环境">模拟多数据源环境</h2>
<ul>
<li><p>新建一个mybatis-plus数据库和表 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604170202852.png"
alt="image-20220604170202852" /></p></li>
<li><p>maven依赖添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/dynamic-datasource-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>前提 使用mybatis_plus中的t_product表
及mybatis_plus1中的t_product1表</p></li>
<li><p>yml配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">master</span> <span class="comment">#设置默认的数据源或者数据源组,默认值即为master</span></span><br><span class="line">      <span class="attr">strict:</span> <span class="literal">false</span> <span class="comment">#严格匹配数据源,默认false. true未匹配到指定数据源时抛异常,false使用默认数据源</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">master:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;&amp;useSSL=false&amp;&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span> <span class="comment"># 3.2.0开始支持SPI可省略此配置</span></span><br><span class="line">        <span class="attr">slave_1:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&amp;&amp;useSSL=false&amp;&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="comment">#slave_2:</span></span><br><span class="line">        <span class="comment">#  url: ENC(xxxxx) # 内置加密,使用请查看详细文档</span></span><br><span class="line">        <span class="comment">#  username: ENC(xxxxx)</span></span><br><span class="line">        <span class="comment">#  password: ENC(xxxxx)</span></span><br><span class="line">       <span class="comment">#   driver-class-name: com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="comment">#......省略</span></span><br><span class="line">        <span class="comment">#以上会配置一个默认库master，一个组slave下有两个子库slave_1,slave_2</span></span><br></pre></td></tr></table></figure></li>
<li><p>代码</p>
<ul>
<li>结构 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604173324836.png"
alt="image-20220604173324836" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604173357652.png"
alt="image-20220604173357652" /></li>
</ul></li>
</ul>
<h2 id="安装mybatisx插件">安装MyBatisX插件</h2>
<ul>
<li>插件市场 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604173502957.png"
alt="image-20220604173502957" /></li>
<li>自动定位 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604173533155.png"
alt="image-20220604173533155" /></li>
</ul>
<h2 id="mybatis代码快速生成">MyBatis代码快速生成</h2>
<ul>
<li><p>配置 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604173606015.png"
alt="image-20220604173606015" /></p></li>
<li><p>url及密码配置 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604173630815.png"
alt="image-20220604173630815" /></p></li>
<li><p>使用 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604173659189.png"
alt="image-20220604173659189" /></p></li>
<li><figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604173710148.png"
alt="image-20220604173710148" />
<figcaption aria-hidden="true">image-20220604173710148</figcaption>
</figure></li>
<li><p>自动生成 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604173748997.png"
alt="image-20220604173748997" /></p></li>
<li><figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220604173807772.png"
alt="image-20220604173807772" />
<figcaption aria-hidden="true">image-20220604173807772</figcaption>
</figure></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>mybatis-plus 尚硅谷</tag>
      </tags>
  </entry>
  <entry>
    <title>hello-world</title>
    <url>/2022/05/20/study/mybatis_plus/official/hello/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>MyBatis-Plus (opens new window)（简称 MP）是一个 MyBatis (opens new
window)的增强工具，在 MyBatis
的基础上只做增强不做改变，为简化开发、提高效率而生。</li>
</ul>
<h2 id="快速开始">快速开始</h2>
<ul>
<li><p>数据库的Schema脚本 resources/db/schema-mysql.sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS user;</span><br><span class="line"></span><br><span class="line">CREATE TABLE user</span><br><span class="line">(</span><br><span class="line">    id BIGINT(20) NOT NULL COMMENT &#x27;主键ID&#x27;,</span><br><span class="line">    name VARCHAR(30) NULL DEFAULT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">    age INT(11) NULL DEFAULT NULL COMMENT &#x27;年龄&#x27;,</span><br><span class="line">    email VARCHAR(50) NULL DEFAULT NULL COMMENT &#x27;邮箱&#x27;,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p>数据库Data脚本 resources/db/data-mysql.sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM user;</span><br><span class="line"></span><br><span class="line">INSERT INTO user (id, name, age, email) VALUES</span><br><span class="line">(1, &#x27;Jone&#x27;, 18, &#x27;test1@baomidou.com&#x27;),</span><br><span class="line">(2, &#x27;Jack&#x27;, 20, &#x27;test2@baomidou.com&#x27;),</span><br><span class="line">(3, &#x27;Tom&#x27;, 28, &#x27;test3@baomidou.com&#x27;),</span><br><span class="line">(4, &#x27;Sandy&#x27;, 21, &#x27;test4@baomidou.com&#x27;),</span><br><span class="line">(5, &#x27;Billie&#x27;, 24, &#x27;test5@baomidou.com&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个spring boot工程（使用maven）</p>
<ul>
<li><p>父工程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>springboot 相关仓库及mybatis-plus、mysql、Lombok相关仓库引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置resources/application.yml文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus_demo?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;nullCatalogMeansCurrent=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">sql:</span></span><br><span class="line">    <span class="attr">init:</span></span><br><span class="line">      <span class="attr">schema-locations:</span> <span class="string">classpath:db/schema-mysql.sql</span></span><br><span class="line">      <span class="attr">data-locations:</span> <span class="string">classpath:db/data-mysql.sql</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure></li>
<li><p>entity类和mapper类的处理</p>
<ul>
<li><p>entity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>mapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.samples.quickstart.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.samples.quickstart.Application;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.samples.quickstart.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.samples.quickstart.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Assertions;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest(classes = &#123;Application.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println((<span class="string">&quot;----- selectAll method test ------&quot;</span>));</span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        Assertions.assertEquals(<span class="number">5</span>, userList.size());</span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="mybatis-plus-代码自动生成">mybatis-plus 代码自动生成</h3>
<ul>
<li><p>maven 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-generator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.velocity/velocity-engine-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在测试类中编写程序让其自动生成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.FastAutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.jdbc.ScriptRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 快速生成</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lanjerry</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-09-16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastAutoGeneratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行初始化数据库脚本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DATA_SOURCE_CONFIG.build().getConn();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> FastAutoGeneratorTest.class.getResourceAsStream(<span class="string">&quot;/db/schema-mysql.sql&quot;</span>);</span><br><span class="line">        <span class="type">ScriptRunner</span> <span class="variable">scriptRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScriptRunner</span>(conn);</span><br><span class="line">        scriptRunner.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">        scriptRunner.runScript(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据源配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DataSourceConfig.<span class="type">Builder</span> <span class="variable">DATA_SOURCE_CONFIG</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span></span><br><span class="line">            .Builder(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis_plus_demo?useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;nullCatalogMeansCurrent=true&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 run</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        before();</span><br><span class="line">        FastAutoGenerator.create(DATA_SOURCE_CONFIG)</span><br><span class="line">                <span class="comment">// 全局配置</span></span><br><span class="line">                .globalConfig((scanner, builder) -&gt; builder.author(scanner.apply(<span class="string">&quot;请输入作者名称&quot;</span>)))</span><br><span class="line">                <span class="comment">// 包配置</span></span><br><span class="line">                .packageConfig((scanner, builder) -&gt; builder.parent(scanner.apply(<span class="string">&quot;请输入包名&quot;</span>)))</span><br><span class="line">                <span class="comment">// 策略配置</span></span><br><span class="line">                .strategyConfig((scanner, builder) -&gt; builder.addInclude(scanner.apply(<span class="string">&quot;请输入表名，多个表名用,隔开&quot;</span>)))</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    模板引擎配置，默认 Velocity 可选模板引擎 Beetl 或 Freemarker</span></span><br><span class="line"><span class="comment">                   .templateEngine(new BeetlTemplateEngine())</span></span><br><span class="line"><span class="comment">                   .templateEngine(new FreemarkerTemplateEngine())</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                .execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用mybats-x插件自动生成代码</p>
<ul>
<li><p>操作 <img
src="C:\Users\ztx11\AppData\Roaming\Typora\typora-user-images\image-20220526151137850.png"
alt="image-20220526151137850" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220526151155505.png" />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220526151232408.png"
alt="image-20220526151232408" /></p></li>
<li><p>编写controller确定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;findAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; list = userService.list();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.baomidou.mybatisplus.samples.quickstart.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.baomidou.mybatisplus.samples.quickstart.entity.User&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">        id,name,age,</span><br><span class="line">        email</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>entity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@TableName</span> user</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableName(value =&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 年龄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮箱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 年龄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 年龄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮箱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮箱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object that)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == that) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (that == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != that.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">User</span> <span class="variable">other</span> <span class="operator">=</span> (User) that;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span>.getId() == <span class="literal">null</span> ? other.getId() == <span class="literal">null</span> : <span class="built_in">this</span>.getId().equals(other.getId()))</span><br><span class="line">            &amp;&amp; (<span class="built_in">this</span>.getName() == <span class="literal">null</span> ? other.getName() == <span class="literal">null</span> : <span class="built_in">this</span>.getName().equals(other.getName()))</span><br><span class="line">            &amp;&amp; (<span class="built_in">this</span>.getAge() == <span class="literal">null</span> ? other.getAge() == <span class="literal">null</span> : <span class="built_in">this</span>.getAge().equals(other.getAge()))</span><br><span class="line">            &amp;&amp; (<span class="built_in">this</span>.getEmail() == <span class="literal">null</span> ? other.getEmail() == <span class="literal">null</span> : <span class="built_in">this</span>.getEmail().equals(other.getEmail()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        result = prime * result + ((getId() == <span class="literal">null</span>) ? <span class="number">0</span> : getId().hashCode());</span><br><span class="line">        result = prime * result + ((getName() == <span class="literal">null</span>) ? <span class="number">0</span> : getName().hashCode());</span><br><span class="line">        result = prime * result + ((getAge() == <span class="literal">null</span>) ? <span class="number">0</span> : getAge().hashCode());</span><br><span class="line">        result = prime * result + ((getEmail() == <span class="literal">null</span>) ? <span class="number">0</span> : getEmail().hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(getClass().getSimpleName());</span><br><span class="line">        sb.append(<span class="string">&quot; [&quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;Hash = &quot;</span>).append(hashCode());</span><br><span class="line">        sb.append(<span class="string">&quot;, id=&quot;</span>).append(id);</span><br><span class="line">        sb.append(<span class="string">&quot;, name=&quot;</span>).append(name);</span><br><span class="line">        sb.append(<span class="string">&quot;, age=&quot;</span>).append(age);</span><br><span class="line">        sb.append(<span class="string">&quot;, email=&quot;</span>).append(email);</span><br><span class="line">        sb.append(<span class="string">&quot;, serialVersionUID=&quot;</span>).append(serialVersionUID);</span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>service接口类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>serviceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public interface UserMapper extends BaseMapper<span class="tag">&lt;<span class="name">User</span>&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>controller测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;findAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; list = userService.list();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>测试 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220526151658557.png"
alt="image-20220526151658557" /></p></li>
</ul></li>
<li><p>使用mybatis-x 插件（idea）</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220526153005432.png"
alt="image-20220526153005432" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220526152906823.png"
alt="image-20220526152906823" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220526152939073.png"
alt="image-20220526152939073" />
<figcaption aria-hidden="true">image-20220526152939073</figcaption>
</figure></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>mybatis-plus official</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql高阶_sgg 96-00</title>
    <url>/2022/06/15/study/mysql/bl_sgg/96-00/</url>
    <content><![CDATA[<h1 id="章节概述">章节概述</h1>
<ul>
<li><p>架构篇</p>
<ul>
<li>1-3 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615212744595.png"
alt="image-20220615212744595" /></li>
<li>4 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615213049475.png"
alt="image-20220615213049475" /></li>
<li>5 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615213116434.png"
alt="image-20220615213116434" /></li>
<li>6 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615213214227.png"
alt="image-20220615213214227" /></li>
</ul></li>
<li><p>索引及调优篇</p>
<ul>
<li><p>01 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615213343380.png"
alt="image-20220615213343380" /></p></li>
<li><p>02-03</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615213548130.png"
alt="image-20220615213548130" />
<figcaption aria-hidden="true">image-20220615213548130</figcaption>
</figure></li>
<li><p>04-05</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615213705843.png"
alt="image-20220615213705843" />
<figcaption aria-hidden="true">image-20220615213705843</figcaption>
</figure></li>
<li><p>06 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615213812595.png"
alt="image-20220615213812595" /></p></li>
</ul></li>
<li><p>事务篇</p>
<ul>
<li>01-02 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615213841661.png"
alt="image-20220615213841661" /></li>
<li>03 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615213918419.png"
alt="image-20220615213918419" /></li>
<li>04 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615213941383.png"
alt="image-20220615213941383" /></li>
</ul></li>
<li><p>日志与备份篇</p>
<ul>
<li>01 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615214005636.png"
alt="image-20220615214005636" /></li>
<li>02 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615214017149.png"
alt="image-20220615214017149" /></li>
<li>03 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615214035941.png"
alt="image-20220615214035941" /></li>
</ul></li>
</ul>
<h1 id="centos环境准备">CentOS环境准备</h1>
<ul>
<li>这里主要是做了克隆，并没有讲到CentOS的安装，所以笔记不记录了</li>
</ul>
<h1 id="mysql的卸载">MySQL的卸载</h1>
<ul>
<li><p>查找当前系统已经装了哪些
<code>rpm -qa |grep mysql</code></p></li>
<li><p>查找mysql服务运行状态
<code>systemctl status mysql</code></p></li>
<li><p>停止mysql服务 <code>systemctl stop mysql</code></p></li>
<li><p>删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove mysql-community-client-plugins-8.0.29-1.el7.x86_64</span><br><span class="line">yum remove mysql-community-common-8.0.29-1.el7.x86_64</span><br></pre></td></tr></table></figure></li>
<li><p>查找带mysql名字的文件夹 <code>find / -name mysql</code></p></li>
<li><p>进行删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /usr/lib64/mysql</span><br><span class="line">rm -rf /usr/share/mysql</span><br><span class="line">rm -rf /etc/selinux/targeted/active/modules/100/mysql</span><br><span class="line">rm -rf /etc/my.cnf</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="linux下安装mysql8.0与5.7版本">Linux下安装MySQL8.0与5.7版本</h1>
<ul>
<li><p>版本介绍 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615215503286.png"
alt="image-20220615215503286" /></p></li>
<li><p>下载地址 : https://www.mysql.com/downloads/ <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615215700151.png"
alt="image-20220615215700151" /></p>
<ul>
<li>进入 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615215748407.png"
alt="image-20220615215748407" /> 即
https://dev.mysql.com/downloads/mysql/</li>
</ul></li>
<li><p>版本选择 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615220106821.png"
alt="image-20220615220106821" /></p>
<ul>
<li><p>下载最大的那个，离线版 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615220208380.png"
alt="image-20220615220208380" /></p></li>
<li><p>下载后解压，并将下面六个放进linux中</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615230622301.png"
alt="image-20220615230622301" />
<figcaption aria-hidden="true">image-20220615230622301</figcaption>
</figure></li>
</ul></li>
<li><p>如果是5.7，则需要进入
https://downloads.mysql.com/archives/community/</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615220835226.png"
alt="image-20220615220835226" />
<figcaption aria-hidden="true">image-20220615220835226</figcaption>
</figure>
<ul>
<li>下载后解压 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615221052718.png"
alt="image-20220615221052718" /></li>
<li>拷贝进linux</li>
</ul></li>
<li><p>安装前，给/tmp临时目录权限</p>
<ul>
<li><p><code>chmod -R 777 /tmp</code></p></li>
<li><p>检查依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa |grep libaio</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#libaio-0.3.109-13.el7.x86_64</span></span></span><br><span class="line">rpm -qa |grep net-tools</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#net-tools-2.0-0.24.20131004git.el7.x86_64</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>确保目录下已经存在5（4）个文件并<strong>严格</strong>按顺序执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-8.0.29-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.29-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-libs-8.0.29-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-client-8.0.29-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-icu-data-files-8.0.29-1.el7.x86_64.rpm</span><br><span class="line">rpm -ivh mysql-community-server-8.0.29-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
<ul>
<li><p>安装libs的时候，会报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">error: Failed dependencies:</span><br><span class="line">	mariadb-libs is obsoleted by mysql-community-libs-8.0.29-1.el7.x86_64</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用下面命令，视频的方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove mysql-libs</span><br></pre></td></tr></table></figure></li>
<li><p>使用下面命令，卸载mariadb (这是我自己的方法)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep mariadb</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment"># 查找到对应的版本 mariadb-libs-5.5.60-1.el7_5.x86_64</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment"># 下面卸载查找出来的版本</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment"># yum remove mariadb-libs-5.5.60-1.el7_5.x86_64</span></span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>再次执行后安装成功</p></li>
</ul></li>
</ul></li>
<li><p>服务初始化 <code>mysqld --initialize --user=mysql</code></p></li>
<li><p>查看默认生成的密码 <code>cat /var/log/mysqld.log</code> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615230843532.png"
alt="image-20220615230843532" /></p></li>
<li><p>判断mysql是否启动 <code>systemctl status mysqld</code></p></li>
<li><p>启动服务<code>systemctl start mysqld</code>
再次判断，发现已经启动 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615231006026.png"
alt="image-20220615231006026" /></p></li>
<li><p>设置为自动启动</p>
<ul>
<li>查看当前是否开机自启动
<code>systemctl list-unit-files|grep mysqld.service</code> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615231116185.png"
alt="image-20220615231116185" /></li>
<li>如果是disable，则可以使用下面命令开机自启动
<code>systemctl enable mysqld.service</code></li>
</ul></li>
<li><p>进行登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>用刚才的密码</p>
<ul>
<li><p>使用查询，提示需要重置密码 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220615231707178.png"
alt="image-20220615231707178" /></p></li>
<li><p>密码更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">quit</span><br><span class="line"># 退出重新登录</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>5.7的安装
赋予权限并检查包，这里发现缺少了libaio，所以<code>yum install libaio</code></p></li>
</ul>
<h1
id="sqlyog实现mysql8.0和5.7的远程连接">SQLyog实现MySQL8.0和5.7的远程连接</h1>
<ul>
<li><p>sqlyog下载
https://github.com/webyog/sqlyog-community/wiki/Downloads</p></li>
<li><p>默认情况下会有连接出错 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220616000229899.png"
alt="image-20220616000229899" /></p></li>
<li><p>先测试ip及端口号 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220616000453564.png"
alt="image-20220616000453564" /></p>
<ul>
<li>此时linux端口号并没有开放
使用<code>systemctl status firewalld</code>发现防火墙开启 （active)
使用<code>systemctl stop firewalld</code>将防火墙关闭</li>
<li>开机时关闭防火墙<code>systemctl disable firewalld</code></li>
<li>此时还是报错 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220616001041497.png"
alt="image-20220616001041497" /></li>
</ul></li>
<li><p>这是由于root不允许被远程连接</p>
<ul>
<li><p>查看user表，发现只允许本地登录 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220616001151783.png"
alt="image-20220616001151783" /></p></li>
<li><p>修改并更新权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update user set host = &#x27;192.168.1.%&#x27; where user= &#x27;root&#x27;;</span><br><span class="line">#或者</span><br><span class="line">update user set host = &#x27;%&#x27; where user= &#x27;root&#x27;;</span><br><span class="line">#更新权限</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></li>
<li><p>之后如果出现下面的问题（视频中有，我没遇到） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220616001512943.png"
alt="image-20220616001512943" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后就可以连接了</li>
</ul></li>
<li><p>命令行进行远程连接
<code>mysql -u root -h 192.168.200.150 -P3306 -p</code></p></li>
</ul></li>
<li></li>
</ul>
<h1 id="字符集的修改与底层原理说明">字符集的修改与底层原理说明</h1>
<h1
id="比较规则_请求到响应过程中的编码与解码过程">比较规则_请求到响应过程中的编码与解码过程</h1>
<h1
id="sql大小写规范与sql_model的设置">SQL大小写规范与sql_model的设置</h1>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>mysql高级篇-尚硅谷</tag>
      </tags>
  </entry>
  <entry>
    <title>redis_尚硅谷_01-05</title>
    <url>/2021/12/27/study/redis/shangguigu_BV1Rv41177Af/01-05/</url>
    <content><![CDATA[<h2 id="课程简介">课程简介</h2>
<p>NoSQL数据库简介、Redis概述与安装、常用五大数据结构、配置文件详解、发布与订阅、Redis6新数据类型、Redis与spring
boot整合、事务操作、持久化之RDB、持久化之AOF、主从复制及集群、Redis6应用问题(缓存穿透、击穿、雪崩以及分布式锁)、Redis6新增功能
## NoSQL数据库简介 * Redis属于NoSQL数据库 * 技术分为三大类 *
解决功能性问题：Java、Jsp、RDBMS、Tomcat、Linux、JDBC、SVN *
解决扩展性问题：Struts、Spring、SpringMVC、Hibernate、Mybatis *
解决性能问题：NoSQL、Java线程、Nginx、MQ、ElasticSearch *
缓存数据库的好处 * 完全在内存中，速度快，结构简单 *
作为缓存数据库：减少io的读操作<br />
* NoSQL＝Not Only SQL,不仅仅是SQL，泛指<strong>非泛型数据库</strong> *
不支持ACID(但是NoSQL支持事务) * 选超于SQL的性能 * NoSQL适用场景 *
对数据高并发的读写 * 海量数据的读写 * 对数据高可扩展性 *
NoSQL不适用的场景 * 需要事务支持 * 基于sql的结构化查询存储 *
多种NoSQL数据库介绍 * Memcache
不支持持久化，数据类型单一，一般作为辅助持久化的数据库 * Redis
支持持久化，除了k-v模式还有其他多种数据结构，一般作为辅助持久化的数据库
*
MongoDB，是文档型数据类型；k-v模型，但是对value提供了丰富的查询功能；支持二进制数据及大型对象；替代RDBMS，成为独立数据库
* 大数据时代（行式数据库、列式数据库） * 行式数据库<br />
查询某一块数据的时候效率高<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1640929802056.png" /><br />
* 列式数据库<br />
查询某一列统计信息快<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1640929838300.png" /><br />
* 其他<br />
Hbase，Cassandra，图关系数据库(比如社会关系，公共交通网等)<br />
* 小计<br />
NoSQL数据库是为提高性能而产生的非关系型数据库<br />
## Redis概述与安装<br />
* 简单概述<br />
* Redis是一个开源的kv存储系统<br />
*
相比Mencached，支持存储的数据类型更多，包括string，list，set，zset以及hash，这些类型都支持(pop、add/remove及取交并集和差集等)，操作都是原子性的<br />
* Redis数据都是缓存在内存中 *
Redis会周期性地把数据写入磁盘或修改操作写入追加的记录文件 *
能在此基础上实现master-slave(主从)同步 * Redis功能 *
配合关系型数据库做高速缓存 * Redis具有多样的数据结构存储持久化数据 *
其他部分功能<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1640929869759.png" /><br />
* Redis安装<br />
* 从官网中下载redis-6.xx.tar.gz包(该教程在linux中使用redis6教学) *
编译redis需要gcc环境 * 使用gcc --version查看服务器是否有gcc环境 *
如果没有需要进行安装 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install -y gcc</span><br><span class="line">或者</span><br><span class="line">yum install -y gcc</span><br></pre></td></tr></table></figure> * 将redis压缩文件进行解压
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-6xx.tar.gz</span><br></pre></td></tr></table></figure> * 进入解压后的文件夹，并使用make命令进行编译<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure> * 如果报错了，需要先用下面命令清理，之后再进行编译
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make distclean</span><br></pre></td></tr></table></figure> * 安装redis <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure> *
进入/usr/local/bin目录，查看目录<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1640939791651.png" />
* Redis启动 * 前台启动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server </span><br></pre></td></tr></table></figure> * 后台启动 *
在刚才解压的文件夹中，拷贝出redis.conf文件(这里拷贝到/etc/目录下)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp redis.conf /etc/redis.conf</span><br></pre></td></tr></table></figure> * 到etc中修改redis.conf文件<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/redis.conf</span><br><span class="line"># 进入编辑器后使用下面命令进行搜索并回车</span><br><span class="line">/daemonize no</span><br></pre></td></tr></table></figure> 将no改为yes并保存 * 进入/usr/local/bin目录启动redis
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server /etc/redis.conf </span><br></pre></td></tr></table></figure> * 查看进程，发现redis已经启动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure> *
使用redis-cli 客户端连接redis <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">keys * </span><br></pre></td></tr></table></figure> ## 相关知识<br />
* Redis6379的由来 * 人名Merz 在九宫格对应的数字就是6379<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1641283251602.png" />
* Redis默认有15个库，默认数据都在数据库0中，所有库的密码都是相同的 *
Redis是单线程+多路复用技术<br />
* Redis是串行操作<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1641283379975.png" />
* 火车站的例子<br />
当1，2，3没有票的时候，不用一直等待买票，可以继续做自己的事情，黄牛买到票就会通知123进行取票<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1641283510456.png" />
* Memcached和Redis区别<br />
* Memcached支持单一数据类型，Redis支持多数据类型 *
Memcached不支持持久化<br />
* Memcached用的多线程+锁的机制，Redis用的是单线程+多路复用程序 ##
End</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>redis_尚硅谷</tag>
      </tags>
  </entry>
  <entry>
    <title>redis_尚硅谷_06-11</title>
    <url>/2022/01/04/study/redis/shangguigu_BV1Rv41177Af/06-11/</url>
    <content><![CDATA[<h2 id="redis针对key的基本操作">Redis针对key的基本操作</h2>
<ul>
<li>常用命令<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keys * #查找当前库所有库</span><br><span class="line">exists key1 #key1是否存在 1存在；0不存在</span><br><span class="line">type key2 #key2的类型</span><br><span class="line">del key3 #删除key3</span><br><span class="line">unlink key3 #删除key3(选择非阻塞删除。会先从元数据删除，而真正删除是异步删除)</span><br><span class="line">expire key1 10 #设置key1的过期时间，单位秒</span><br><span class="line">ttl key1 #获取key1的剩余存活时间，-2表示key已过期或不存在，-1表示永不过期</span><br><span class="line">select 1 #切换到1号库(redis中有15个库，默认在库1)</span><br><span class="line">dbsize #查找当前redis库中有多少个key</span><br><span class="line">flushdb #清空当前库</span><br><span class="line">flushall #清空所有库</span><br></pre></td></tr></table></figure> ## Redis中常用数据类型 ### 字符串（String）</li>
<li>String是二进制安全的，可以包含jpg图片或序列化的对象</li>
<li>一个Redis中字符串value最多可以只能是512M</li>
<li>常用命令<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set key1 value1</span><br><span class="line">get key1 </span><br><span class="line">set key1 value11 #将覆盖上一个值</span><br><span class="line">append key1 abc #在key1的值追加&quot;abc&quot;</span><br><span class="line">strlen key1 #key值的长度</span><br><span class="line">setnx key1 value #当key不存在时才设置key</span><br><span class="line">incr n1 #将n1的值加一,,如果n1不存在则会创建key n1 并改为1(0+1)</span><br><span class="line">decr n1 #将n1的值减一,如果n1不存在则会创建key n1 并改为-1(0-1)</span><br><span class="line">incrby n1 20 #将n1的值加20，其他同上</span><br><span class="line">decrby n1 20 #将n1的值减20，其他同上</span><br></pre></td></tr></table></figure></li>
<li>redis原子性<br />
incr具有原子性操作<br />
java中的i++不是原子操作<br />
</li>
<li>其他命令<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mset k1 v1 k2 v2</span><br><span class="line">mget k1 k2 </span><br><span class="line">msetnx k1 v1 k2 v2 #仅当所有的key都不存在时才会进行设置</span><br><span class="line">getrange name 0 3 #截断字符串[0,3]</span><br><span class="line">setrange name 3 123 #从下标[3]开始替换字符串（换成123）</span><br><span class="line">setex k1 20 v1 #设置过期时间为20s</span><br><span class="line">expire k1 30 #设置过期时间为30s</span><br><span class="line">getset k1 123 #获取旧值，并设置一个新值</span><br></pre></td></tr></table></figure></li>
<li>数据结构，SimpleDynamicString，SDS，简单动态字符串，内部结构类似Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642384642245.png" /><br />
### 列表 (List)<br />
</li>
<li>单键多值<br />
</li>
<li>底层是双向链表<br />
</li>
<li>从左放 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpush k1 v1 v2 v3 #从左边放(从左往右推)</span><br><span class="line">lrange k1 0 -1 #从左边取(v3 v2 v1)</span><br></pre></td></tr></table></figure></li>
<li>lpush:<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642384992243.png" /><br />
</li>
<li>从右放<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpush k2 v1 v2 v3 </span><br></pre></td></tr></table></figure></li>
<li>brpush:<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642385552581.png" /><br />
</li>
<li>lpop/rpop<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpop k2 #从左边弹出一个值</span><br><span class="line">lpop k2 2 #从左边弹出两个值，当键没有包含值时，键被删除</span><br></pre></td></tr></table></figure></li>
<li>rpoplpush<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lpush a a1 a2 a3</span><br><span class="line">rpush b b1 b2 b3</span><br><span class="line">rpoplpush a b #此时a:a1 a2，b:a3 b1 b2 b3</span><br></pre></td></tr></table></figure></li>
<li>lrange <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lrange b 1 2 #获取b中下标[1,2]的所有值</span><br><span class="line">lrange b 1 -1 #获取所有值[1,最大下标]的所有值</span><br></pre></td></tr></table></figure></li>
<li>lindex,llen <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lindex b 1 #直接取第一个下标的元素</span><br><span class="line">llen b #获取列表的长度</span><br></pre></td></tr></table></figure></li>
<li>linsert <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linsert b before b2 myinsert</span><br><span class="line">linsert b after b2 myinsert</span><br><span class="line">#在某个列表的值(如果重复取第一个)的位置之前/之后插入值</span><br></pre></td></tr></table></figure> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642405713546.png" /></li>
<li>lrem,lset <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lrem b 2 a #从b列表中，删除两个a（从左往右）</span><br><span class="line">lset b 2 AA #把下标2的值设置为AA</span><br></pre></td></tr></table></figure></li>
<li>list数据结构是一个快速列表，quicklist<br />
当元素较少的时候，会使用连续的内存存储，结构时ziplist，即压缩列表；当数据多的时候会有多个压缩列表，然后会链接到一起(使用双向指针)<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642405814686.png" />
### 集合(Set)</li>
<li>特点：无序，不重复<br />
</li>
<li>Set:string类型的无序集合，底层是一个value为null的hash表；添加/删除时间复杂度为O(1)</li>
<li>常用命令<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sadd k1 v1 v2 v3 v2 v2 v1 #设置集合中的值</span><br><span class="line">smembers k1 #取出集合中的值</span><br><span class="line">sismember k1 v3 #k1是否存在v3，存在返回1，不存在返回0</span><br><span class="line">scard k1 #返回集合中元素的个数</span><br><span class="line">srem k1 v2 v3 #删除集合中的v2和v3</span><br><span class="line">spop k1 #从k1中随机取出一个值</span><br><span class="line">srandmember k1 2 #从k1中随机取出2个值</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smove a k a1 #从a中将a1移动到k中</span><br><span class="line">sinter a k #取a，k的交集</span><br><span class="line">sunion a k #取a，k的并集</span><br><span class="line">sdiff a k #返回两个集合的差集（从集合a中，去除存在集合k中的元素，即a-k）</span><br></pre></td></tr></table></figure></li>
<li>Set数据结构时dict字典，字典使用哈希表实现的 ### 哈希（Hash)</li>
<li>是String类型的field和value的映射表，用来存储对象,类似java中的Map&lt;String,Object&gt;<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642405567709.png" /><br />
</li>
<li>常用命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hset user:1001 id 1 #设置(对象)user:1001的id属性值</span><br><span class="line">hset user:1001 name zhangsan </span><br><span class="line">hget user:1001 name #取出user:1001的name</span><br><span class="line">hmset user:1001 id 1 name zhangsan #批量设置（现在hset也可以批量设置了，hmset已弃用）</span><br><span class="line">hexists user:1001 id 1 #判断属性id是否存在</span><br><span class="line">hkeys user:1001 #查看hash结构中的所有filed</span><br><span class="line">hvals user:1001 #查看hash结构中所有value</span><br><span class="line">hincrby user:1001 age 2 #给hash结构的age属性值加2</span><br><span class="line">hsetnx user:1001 age 10 #给hash结构的age属性设置值为10（如果age属性不存在）</span><br></pre></td></tr></table></figure></li>
<li>hash类型数据结构，当field-value长度较短时用的是ziplist，否则使用的是hashtable
### 有序集合(ZSet)</li>
<li>与set很相似，但是是有序的</li>
<li>有序集合的所有元素（成员）都关联一个评分(score)，score用来从最低到最高方式进行排序，成员唯一但评分是重复的</li>
<li>常用命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zadd topn 100 xiaoming 120 xiaohong 60 xiaochen #添加key并为每个成员添加评分</span><br><span class="line">zadd topn xiaoli 200 </span><br><span class="line">zrange topn 0 -1 #查找出所有成员(按排名由小到大)</span><br><span class="line">zrange topn 0 -1 withscores #从小到大查找所有成员并显示分数</span><br><span class="line">zrangebyscore topn 130 200 #查找所有在130-200的成员</span><br><span class="line">zrevrangebyscore topn 200 130 #从大到小查找所有成员（注意，从大到小时第一个值必须大于等于第二个）</span><br><span class="line">zincrby topn 15 xiaohong #给小红添加15分</span><br><span class="line">zrem topn xiaohong #删除元素</span><br><span class="line">zcount topn 10 200 #统计该集合，分数区间内的元素个数</span><br><span class="line">zrank topn xiaohong #xiaohong的排名，从0开始</span><br></pre></td></tr></table></figure></li>
<li>zset底层数据结构
<ul>
<li>hash结构<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642408140352.png" /></li>
<li>跳跃表 给元素value排序，根据score的范围获取元素列表</li>
<li>对比有序链表和跳跃表
<ul>
<li>查找51元素<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642408284497.png" /></li>
<li>跳跃表<br />
按图中的顺序查找，查找四次就能找到<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642408430332.png" /></li>
</ul></li>
</ul></li>
<li>End</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>redis_尚硅谷</tag>
      </tags>
  </entry>
  <entry>
    <title>redis_尚硅谷_12-17</title>
    <url>/2022/01/18/study/redis/shangguigu_BV1Rv41177Af/12-17/</url>
    <content><![CDATA[<h2 id="redis配置文件">Redis配置文件</h2>
<ul>
<li>redis中单位的设置，支持k,kb,m,mb,g,gb，且不区分大小写<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642470299824.png" /></li>
<li>include (包含其他文件，比如公共部分)<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642471413477.png" /><br />
</li>
<li>bind <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1 ::1 #listens on loopback IPv4 and IPv6 </span><br></pre></td></tr></table></figure>
<ul>
<li>后面这个::1，相当于ipv6版的127.0.0.1。在redis配置文件中，整句表示只允许本地网卡的某个ip连接(但是它并不能指定某个主机连接到redis中。比如本机有两个网卡，两个ip，可以限定只有其中一个ip可以连接)</li>
<li>如果注释掉了/或者bind 0.0.0.0，表示允许所有主机连接</li>
</ul></li>
<li>protected-mode <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected-mode yes </span><br></pre></td></tr></table></figure>
<ul>
<li>设置保护模式为yes，protected是redis本身的一个安全层，这个安全层在同时满足下面三个条件的时候会开启，开启后只有本机可以访问redis
<ul>
<li>protected-mode yes</li>
<li>没有bind指令(bind 0.0.0.0不属于这个条件)</li>
<li>没有设置密码 (没有设置requirepass password)<br />
</li>
</ul></li>
<li>只要上面一个条件不满足，就不会开启保护模式。换言之，只要设置了bind
0.0.0.0或者没有设置bind，且不满足上面三个条件之一，就能够进行远程访问(当然，linux/windows的6379端口要开放)</li>
</ul></li>
<li>tcp-backlog 表示未连接队列总和<br />
</li>
<li>timeout 秒为单位，时间内没操作则断开连接</li>
<li>tcp-keepalive 300 心跳检测，每隔300s检测连接是否存在</li>
<li>pidfile /var/run/redis_6379.pid 将进程号保存到文件中</li>
<li>loglevel
表示日志的级别/debug/verbose/<strong>notice</strong>/warning</li>
<li>logfile "" 设置日志的路径</li>
<li>database 16 默认有16个库</li>
<li>requirepass password 设置密码</li>
<li>maxclients 设置最大连接数</li>
<li>maxmemory 设置最大内存量，达到则会根据移除策略进行移除操作 ##
Redis的发布和订阅</li>
<li>发布订阅，pub/sub，是一种消息通信模式：发送者pub发送消息，订阅器sub接收消息</li>
<li>发布者能发布消息，订阅者可以订阅/接收消息<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642496809416.png" /><br />
</li>
<li>操作<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subscribe channel1 #客户端A订阅频道 </span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publish channel1 helloly #向频道发送消息</span><br></pre></td></tr></table></figure>
此时订阅channel1频道的客户端就会接收到消息<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642557791117.png" />
## redis新数据类型<br />
### Bitmaps
<ul>
<li><p>进行二进制操作</p></li>
<li><p>可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在Bitmaps中叫做<strong>偏移量</strong><br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642560262874.png" /><br />
</p></li>
<li><p>bitcount:统计字符串被设置为1的bit数，这里结果是5</p></li>
<li><p>bitcount u1 0 1 #统计字符串第0个字节到第1个字节1的bit数<br />
(1,6,11,15,19bit值为1)[也就是统计第0到第15位的1的个数]<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setbit u1 1 1</span><br><span class="line">setbit u1 2 1</span><br><span class="line">setbit u1 5 1</span><br><span class="line">setbit u1 9 1</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setbit u2 0 1</span><br><span class="line">setbit u2 1 1</span><br><span class="line">setbit u2 4 1</span><br><span class="line">setbit u2 9 1</span><br></pre></td></tr></table></figure></p></li>
<li><p>获取u1，u2共同位为1的个数，如上1,9都是1，所以返回2，且 bitcount
u1--u2的值为2（第1和第9位为1），其实就是<strong>u1和u2进行&amp;操作</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bitop and u1-and-u2 u1 u2 </span><br></pre></td></tr></table></figure></p></li>
<li><p>获取u1或u2存在值为1的位的个数，如上结果为8-2=6，结果存在u1-or-u2中，即1，2，5，9，0，4的位
值为1(的字符串)，其实就是<strong>u1和u2进行或操作</strong><br />
</p></li>
<li><p>性能比较，假设有一亿个用户，用户id数值递增，需求是存储每个用户是否活跃。下面是使用hashMap和bitmaps的比较<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1642562600909.png" /></p></li>
<li><p>bitmaps主要用来进行位操作计算 ### HyperLogLog</p></li>
</ul></li>
<li>解决基数问题<br />
从{1,3,5,5,7,8,8,7,9}找出基数：基数为5，即不重复元素的个数</li>
<li>解决方案
<ul>
<li>mysql中可以用distinct count</li>
<li>redis中可以用hash,set,bitmaps</li>
</ul></li>
<li>使用 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pfadd a 1 2 3 4 3 3 3 2 1 6 7</span><br><span class="line">pfcount a #得到基数 6 </span><br><span class="line">pfadd b 1 10 7 15 #基数4</span><br><span class="line">pfmerge c a b #将a，b合并到c</span><br><span class="line">pfcount c #得到基数8</span><br></pre></td></tr></table></figure> ### GEO类型 (geographic)<br />
</li>
<li>基本命令<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geoadd china:city 121.47 31.43 shanghai</span><br><span class="line">geoadd china:city 166.50 29.53 chongqing 114.05 22.52  shenzhen</span><br><span class="line">geoadd china:city 16.38 39.90 beijing </span><br></pre></td></tr></table></figure></li>
<li>不支持南北极，所以有效经度在-180到180度，有效纬度从-85.05xxx度到85.05xxx度</li>
<li>获取坐标值及直线距离 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geopos china:city beijing #获取beijing经纬度</span><br><span class="line">geodist china:city beijing shenzhen km #获取beijing到shenzhen的直线距离</span><br><span class="line"># 单位有m,km,ft,mi</span><br></pre></td></tr></table></figure></li>
<li>以给定的经纬度为中心，找出某一半径内的元素<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">georadius china:city 110 30 1000 km</span><br></pre></td></tr></table></figure> ## End</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>redis_尚硅谷</tag>
      </tags>
  </entry>
  <entry>
    <title>redis_尚硅谷_18</title>
    <url>/2022/01/19/study/redis/shangguigu_BV1Rv41177Af/18/</url>
    <content><![CDATA[<h2 id="jedis操作redis6">Jedis操作Redis6</h2>
<ul>
<li>插曲:本地项目关联github远程库 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">#-m表示强制重命名</span><br><span class="line">git branch -M main</span><br><span class="line">#使用别名</span><br><span class="line">git remote add origin git@github.com:lwmfjc/jedis_demo.git</span><br><span class="line">#用了-u之后以后可以直接用git push替代整行 </span><br><span class="line">git push -u origin main </span><br></pre></td></tr></table></figure></li>
<li>jedis pom依赖 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li>jedis使用 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//设置密码</span></span><br><span class="line">        DefaultJedisClientConfig.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> </span><br><span class="line">        DefaultJedisClientConfig.builder()</span><br><span class="line">                .password(<span class="string">&quot;hello.lwm&quot;</span>);</span><br><span class="line">        <span class="type">DefaultJedisClientConfig</span> <span class="variable">config</span> <span class="operator">=</span> builder.build();</span><br><span class="line"></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.200.200&quot;</span>, <span class="number">6379</span>, config);</span><br><span class="line">        <span class="comment">//ping</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">//返回所有key</span></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;key count: &quot;</span> +</span><br><span class="line">                keys.size());</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;key--:%s---value:%s\n&quot;</span>, </span><br><span class="line">        key, jedis.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;操作list&quot;</span>);</span><br><span class="line">        <span class="comment">//操作list</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;ly-list&quot;</span>, <span class="string">&quot;java&quot;</span>, <span class="string">&quot;c++&quot;</span>, <span class="string">&quot;css&quot;</span>);</span><br><span class="line">        List&lt;String&gt; lrange = jedis.lrange(<span class="string">&quot;ly-list&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String v : lrange) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;value:&quot;</span> + v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作set</span></span><br><span class="line">        System.out.println(<span class="string">&quot;操作set&quot;</span>);</span><br><span class="line">        jedis.sadd(<span class="string">&quot;ly-set&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>,</span><br><span class="line">                <span class="string">&quot;5&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; smembers = jedis.smembers(<span class="string">&quot;ly-set&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String v : smembers) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;value:&quot;</span> + v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//操作hash</span></span><br><span class="line">        System.out.println(<span class="string">&quot;操作hash&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;ly-hash&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;lidian&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;ly-hash&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;30&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;ly-hash&quot;</span>, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;man&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; lyHash = jedis.hgetAll(<span class="string">&quot;ly-hash&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : lyHash.keySet()) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;:&quot;</span> + lyHash.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//操作zset</span></span><br><span class="line">        System.out.println(<span class="string">&quot;操作zset&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;person&quot;</span>, <span class="number">100</span>, <span class="string">&quot;xiaohong&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;person&quot;</span>, <span class="number">80</span>, <span class="string">&quot;xiaoli&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;person&quot;</span>, <span class="number">90</span>, <span class="string">&quot;xiaochen&quot;</span>);</span><br><span class="line">        List&lt;String&gt; person = jedis.zrange(<span class="string">&quot;person&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : person) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束操作</span></span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>redis_尚硅谷</tag>
      </tags>
  </entry>
  <entry>
    <title>redis_尚硅谷_19-A</title>
    <url>/2022/01/19/study/redis/shangguigu_BV1Rv41177Af/19-A/</url>
    <content><![CDATA[<h2 id="验证码模拟">验证码模拟</h2>
<ul>
<li>首先需要一个MyRedis单例类 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyRedis单例类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJedis</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Jedis myJedis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果是空则进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (myJedis == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//由于synchronized同步是在条件判断内，所以同步</span></span><br><span class="line">            <span class="comment">//并不会一直都执行，增加了效率</span></span><br><span class="line">            <span class="keyword">synchronized</span> (MyJedis.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (myJedis == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置密码</span></span><br><span class="line">                    DefaultJedisClientConfig.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> DefaultJedisClientConfig.builder()</span><br><span class="line">                            .password(<span class="string">&quot;hello.lwm&quot;</span>);</span><br><span class="line">                    <span class="type">DefaultJedisClientConfig</span> <span class="variable">config</span> <span class="operator">=</span> builder.build();</span><br><span class="line"></span><br><span class="line">                    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">redis</span>.clients.jedis.Jedis(<span class="string">&quot;192.168.200.200&quot;</span>, <span class="number">6379</span>, config);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> jedis;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myJedis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>redis_尚硅谷</tag>
      </tags>
  </entry>
  <entry>
    <title>基础</title>
    <url>/2022/10/27/study/springCloud/bl_zhouyang/base/</url>
    <content><![CDATA[<ul>
<li>springCloud涉及到的技术有哪些 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221027164807178.png"
alt="image-20221027164807178" /></li>
<li>约定 &gt; 配置 &gt; 编码</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习--SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>p1-</title>
    <url>/2022/05/04/study/yixue/yi-jing-za-shuo/p1-/</url>
    <content><![CDATA[<h2 id="敲门砖">敲门砖</h2>
<ul>
<li>有人说"《易经》是经典中之经典，哲学中之哲学，智慧中之智慧"，这是站在本位文化的立场来推崇《易经》的看法。</li>
<li>在这里先要使大家知道怎样去读《易经》这部书，先从怎样去认识它、怎样去了解它开始。这里提供的仅仅是一块敲门砖而已</li>
</ul>
<h2 id="洁净精微">洁净精微</h2>
<ul>
<li>《礼记》的《五经解》中，提到《易经》这门学问时说：“洁净精微，易教也。”
<ul>
<li>洁净，包括了宗教、哲学的含义，也就是说学了《易经》，他的心理、思想、情绪无论在任何情况下，都会非常宁静，澄洁。</li>
<li>精微，则是科学的，无比的细密精确，所以学易的人，要头脑非常冷静</li>
</ul></li>
<li>”闲坐小窗读周易，不知春去已多时“</li>
<li>《五经解》中说《易经》的流弊：”其失也，贼“：读了易经的人，如不走正路，旁门左道，就贼头贼脑，拿来造反</li>
<li>虞世南：不读《易》不可为将相</li>
</ul>
<h2 id="三易">三易</h2>
<ul>
<li>《周易》是周文王在羑里[yǒu
lǐ]坐牢的时候，研究《易经》的心得记录</li>
<li>一切中国的文化，都源于《易经》</li>
<li>还有另外两种《易经》，为《连山易》和《归藏易》( <strong>guī
cáng/zang 四声，没查到，好像读音都有，暂取cang 二声</strong>)</li>
<li></li>
</ul>
<h2 id="易经的三原则">易经的三原则</h2>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>《易经杂说》-南怀瑾</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2022/12/26/review/java_guide/cs_basics/data-structure/graph/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<ul>
<li>图是一种较为复杂的<strong>非线性</strong>结构</li>
<li><strong>线性</strong>数据结构的元素满足唯一的线性关系，<strong>每个元素</strong>（除第一个和最后一个外）只有一个<strong>直接前驱</strong>和一个<strong>直接后继</strong></li>
<li><strong>树形</strong>数据结构的元素之间有着明显的<strong>层级关系</strong></li>
<li><strong>图形</strong>结构的元素之间的关系是任意的
<ul>
<li>图就是由<strong>顶点</strong>的<strong>有穷非空集合</strong>和顶点之间的<strong>边</strong>组成的集合，通常表示为：<strong>G（V，E）</strong>，其中，G表示一个图，V表示顶点的集合，E表示边的集合</li>
<li>下面显示的即<strong>图</strong>这种数据结构，而且还是一张<strong>有向图</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221226215910568.png"
alt="image-20221226215910568" /></li>
</ul></li>
</ul>
<h1 id="图的基本概念">图的基本概念</h1>
<h2 id="顶点">顶点</h2>
<ul>
<li>图中的<strong>数据元素</strong>，我们称之为<strong>顶点</strong>，图至少有一个<strong>顶点</strong>（<strong>有穷非空</strong>集合）</li>
<li>对应到好友关系图，<strong>每一个用户</strong>就代表<strong>一个顶点</strong></li>
</ul>
<h2 id="边">边</h2>
<ul>
<li>顶点之间的<strong>关系</strong>用<strong>边</strong>表示</li>
<li>对应到好友关系图，两个用户是好友的话，那两者之间就存在一条<strong>边</strong></li>
</ul>
<h2 id="度">度</h2>
<ul>
<li>度表示一个顶点包含多少条边</li>
<li>有向图中，分为<strong>出度</strong>和<strong>入度</strong>，出度表示<strong>从该顶点出去的边</strong>的条数，入度表示<strong>从进入该顶点的边</strong>的条数</li>
<li>对应到好友关系图，度就代表了某个人的<strong>好友数量</strong></li>
</ul>
<h2 id="无向图和有向图">无向图和有向图</h2>
<p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用<strong>不带箭头的边</strong>表示，这样的图就是<strong>无向图</strong>。</p>
<p>有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用<strong>带箭头的边</strong>表示二者的关系，这样的图就是<strong>有向图</strong>。</p>
<h2 id="无权图和带权图">无权图和带权图</h2>
<p>对于一个关系，如果我们只关心关系的有无，而<strong>不关心关系有多强</strong>，那么就可以用<strong>无权图</strong>表示二者的关系。</p>
<p>对于一个关系，如果我们既<strong>关心关系的有无</strong>，也关心<strong>关系的强度</strong>，比如描述地图上<strong>两个城市的关系</strong>，需要用到<strong>距离</strong>，那么就用<strong>带权图</strong>来表示，<strong>带权图中的每一条边一个数值表示权值</strong>，代表<strong>关系的强度</strong>。</p>
<p>下图就是一个<strong>带权有向图</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230102162130607.png"
alt="image-20230102162130607" />
<figcaption aria-hidden="true">image-20230102162130607</figcaption>
</figure>
<h1 id="图的存储">图的存储</h1>
<h2 id="邻接矩阵存储">邻接矩阵存储</h2>
<ul>
<li>邻接矩阵将图用<strong>二维矩阵</strong>存储，是一种比较<strong>直观</strong>的表示方式</li>
<li>如果第i个顶点和第j个顶点<strong>有关系</strong>，且<strong>关系权值</strong>为n，则A[i]
[j] = n</li>
<li>在无向图中，我们只关心关系的有无，所以当<strong>顶点i</strong>和<strong>顶点j</strong>有关系时，A[i]
[j]=1 ; 当顶点i和顶点j没有关系时，A[i] [j] = 0 ，如下图所示<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230102165052250.png"
alt="image-20230102165052250" />
无向图的邻接矩阵是一个<strong>对称</strong>矩阵，因为在无向图中，<strong>顶点i</strong>和<strong>顶点j</strong>有关系，则<strong>顶点j</strong>和<strong>顶点i</strong>必有关系</li>
<li>有向图的邻接矩阵存储 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230105105331809.png"
alt="image-20230105105331809" />
邻接矩阵存储的方式优点是<strong>简单直接（直接使用一个二维数组即可）</strong>，并且在获取两个顶点之间的关系的时候也非常高效*直接获取指定位置的<strong>数组</strong>元素。但是这种存储方式的确定啊也比较明显<strong>即
比较浪费空间</strong></li>
</ul>
<h2 id="邻接表存储">邻接表存储</h2>
<ul>
<li><p>针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另一种存储方法--<strong>邻接表</strong></p></li>
<li><p>邻接链表使用一个<strong>链表</strong>来存储某个顶点的<strong>所有后继相邻顶点</strong>。对于图中每个顶点Vi
，把所有邻接于Vi 的顶点Vj 链接成一个<strong>单链表</strong></p>
<ul>
<li>无向图的邻接表存储 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230105111343599.png"
alt="image-20230105111343599" /></li>
<li>有向图的邻接表存储 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230105111409045.png"
alt="image-20230105111409045" /></li>
</ul></li>
<li><p>邻接表中存储的元素的个数（顶点数）以及图中<strong>边的条数</strong></p>
<ul>
<li><p>无向图中，<strong>邻接表</strong>的元素个数等于<strong>边的条数</strong>的两倍，如下图
7条边，邻接表存储的元素个数为14
（即<strong>每条边存储了两次</strong>）</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230105111343599.png"
alt="image-20230105111343599" />
<figcaption aria-hidden="true">image-20230105111343599</figcaption>
</figure></li>
<li><p>有向图中，邻接表元素个数等于边的条数，如图所示的有向图中，边的条数为8，邻接表
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230105111409045.png"
alt="image-20230105111409045" /></p></li>
</ul></li>
</ul>
<h1 id="图的搜索">图的搜索</h1>
<h2 id="广度优先搜索">广度优先搜索</h2>
<ul>
<li><p>广度优先搜索：像水面上的波纹一样，一层一层向外扩展，如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230105112011060.png"
alt="image-20230105112011060" /></p></li>
<li><p>具体实现方式，用到了<strong>队列</strong>，过程如下</p>
<ol type="1">
<li><p><strong>初始状态</strong>：将要搜索的源顶点放入队列 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230105112201827.png"
alt="image-20230105112201827" /></p></li>
<li><p>取出<strong>队首节点</strong>，输出0，将0的<strong>后继顶点（全部）（未访问过的）放入队列</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230105112302751.png"
alt="image-20230105112302751" /></p></li>
<li><p>取出<strong>队首节点</strong>，输出1，将1的后继顶点（所有）（未访问过的）放入队列
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230105112423589.png"
alt="image-20230105112423589" /></p>
<p>截止到第3步就很清楚了，就是输出<strong>最近的一个结点</strong>的<strong>全部关系节点</strong></p></li>
<li><p>取出队首节点，输出4，将4的后继顶点（未访问过的）放入队列 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230105112601860.png"
alt="image-20230105112601860" /></p></li>
<li><p>取出队首节点，输出2，将2的后继顶点（未访问过的）放入队列 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230105112650410.png"
alt="image-20230105112650410" /></p></li>
<li><p>取出队首节点，输出3，将3的后继顶点（未访问过的）放入队列，队列为空，结束
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230105112735397.png"
alt="image-20230105112735397" /></p></li>
<li><p>总结
先初始化首结点，之后不断<strong>从队列取出</strong>并将这个结点的有关系的<strong>结点</strong>
依次<strong>放入队列</strong></p></li>
</ol></li>
</ul>
<h2 id="深度优先搜索">深度优先搜索</h2>
<ul>
<li>深度优先，即一条路走到黑。从<strong>源顶点</strong>开始，一直走到<strong>后继节点</strong>，才<strong>回溯</strong>到上一顶点，然后继续<strong>一条路走到黑</strong></li>
<li>和广度优先搜索类似，深度优先搜索的具体实现，用到了另一种线性数据结构---<strong>栈</strong></li>
</ul>
<ol type="1">
<li><p>初始状态，将要搜索的<strong>源顶点</strong>放入栈中 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230106103852981.png"
alt="image-20230106103852981" /></p></li>
<li><p><strong>取出栈顶元素，输出0</strong>，将0的<strong>后继顶点（未访问过的）放入栈</strong>中
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230106103958425.png"
alt="image-20230106103958425" /></p></li>
<li><p>取出栈顶元素，输出4（因为后进先出），将4的后继顶点（未访问过的）放入栈中
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230106104122419.png" /></p></li>
<li><p>取出栈顶元素，输出3，将3的后继顶点（未访问过的）放入栈中 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230106104217788.png"
alt="image-20230106104217788" /></p>
<hr />
<p>其实到这部就非常明显了，即
<strong>前面元素的关系元素</strong>，大多都是被一直<strong>压在栈底</strong>的，会一直走走到
<strong>源顶点</strong>的<strong>直系关系</strong>顶点没有了，再往回走</p></li>
<li><p>取出栈顶元素，输出2，将2的后继顶点（为访问过的）放入栈中 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230106104458532.png"
alt="image-20230106104458532" /></p></li>
<li><p>取出栈顶元素，输出1，将1的后继顶点（未访问过的）放入栈中，栈为空，结束
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230106104538533.png"
alt="image-20230106104538533" /></p></li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/2023/01/06/review/java_guide/cs_basics/data-structure/heap/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="什么是堆">什么是堆</h1>
<ul>
<li><p>堆是<strong>满足以下条件</strong>的树
堆中每一个节点值都<strong>大于等于（或小于等于）子树中所有节点</strong>。或者说，任意一个节点的值<strong>都大于等于（或小于等于）</strong>所有子节点的值</p>
<blockquote>
<p>大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。</p>
</blockquote>
<ul>
<li><strong>堆不一定是完全二叉树</strong>，为了方便<strong>存储</strong>和<strong>索引</strong>，我们通常用完全二叉树的形式来表示堆<br />
广为人知的<strong>斐波那契堆</strong>和<strong>二项堆</strong>就不是完全二叉树，它们甚至都<strong>不是二叉树</strong></li>
<li>(二叉)堆是一个数组，它可以被看成是一个<strong>近似的完全二叉树</strong></li>
</ul></li>
<li><p>下面给出的图是否是堆（通过定义）</p>
<p>1，2是。 3不是。 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230108214044120.png"
alt="image-20230108214044120" /></p></li>
</ul>
<h1 id="堆的用途">堆的用途</h1>
<ul>
<li><p>当我们<strong>只关心</strong>所有数据中的<strong>最大值</strong>或者<strong>最小值</strong>，存在<strong>多次获取最大值</strong>或者<strong>最小值</strong>，多次插入或删除数据时，就可以使用堆。</p>
<blockquote>
<p>有小伙伴可能会想到用<strong>有序数组</strong>，初始化一个有序数组时间复杂度是
<code>O(nlog(n))</code><strong>[也就是将一堆数字乱序排序，最快是O(nlog(n))]</strong>，查找最大值或者最小值时间复杂度都是
<code>O(1)</code>，但是，涉及到更新（插入或删除）数据时，时间复杂度为
<code>O(n)</code>，即使是使用复杂度为 <code>O(log(n))</code>
的二分法找到要插入或者删除的数据，在移动数据时也需要 <code>O(n)</code>
的时间复杂度。</p>
</blockquote></li>
<li><p>相对于有序数组而言，堆的主要优势在于更新数据效率较高</p>
<ul>
<li>堆的<strong>初始化时间复杂度</strong>为O(nlog(n))，堆可以做到<strong>O(1)</strong>的时间复杂度取出<strong>最大值</strong>或者<strong>最小值</strong>，<strong>O(log(n))</strong>的时间复杂度<strong>插入或者删除</strong>数据</li>
</ul></li>
</ul>
<h1 id="堆的分类">堆的分类</h1>
<ul>
<li>堆分为<strong>最大堆</strong>和<strong>最小堆</strong>，二者的区别在于节点的<strong>排序方式</strong>
<ul>
<li>最大堆：堆中的每一个节点的值<strong>都大于</strong>子树中<strong>所有节点</strong>的值</li>
<li>最小堆：堆中的每一个节点的值<strong>都小于</strong>子树中<strong>所有节点</strong>的值</li>
</ul></li>
<li>如图，图1是最大堆，图2是最小堆 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230108221541796.png"
alt="image-20230108221541796" /></li>
</ul>
<h1 id="堆的存储">堆的存储</h1>
<ul>
<li>由于<strong>完全二叉树的优秀性质</strong>，<strong>利用数组存储二叉树</strong>即节省空间，又<strong>方便索引</strong>（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为
<code>2*i</code>，右子节点序号为 <code>2*i+1</code>）。</li>
<li>为了<strong>方便存储</strong>和<strong>索引</strong>，<strong>（二叉）堆</strong>可以用<strong>完全二叉树</strong>的形式进行存储。存储的方式如下图所示
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230108222619449.png"
alt="image-20230108222619449" /></li>
</ul>
<h1 id="堆的操作">堆的操作</h1>
<ul>
<li><p>堆的更新操作主要包括两种：<strong>插入元素</strong>和<strong>删除堆顶元素</strong></p>
<blockquote>
<p>堆是一个公平的公司，<strong>有能力的人</strong>自然会走到与他能力所匹配的位置</p>
</blockquote></li>
</ul>
<h2 id="插入元素">插入元素</h2>
<ol type="1">
<li>将要插入的元素放到<strong>最后</strong> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109103135560.png"
alt="image-20230109103135560" /></li>
<li>从底向上，如果<strong>父节点</strong>比<strong>该元素小</strong>，则该节点和父节点交换（其实就是一棵树有3个（最多）节点，与树上最大的节点比较）
直到无法交换（已经与根节点比较过） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109103340370.png"
alt="image-20230109103340370" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109103354015.png"
alt="image-20230109103354015" /></li>
</ol>
<h2 id="删除堆顶元素">删除堆顶元素</h2>
<ul>
<li><p>根据堆的性质可知，<strong>最大堆</strong>的堆盯元素为所有元素中最大的，<strong>最小堆</strong>的堆顶元素是所有元素中最小的</p></li>
<li><p>当我们需要多次查找<strong>最大元素</strong>或者<strong>最小元素</strong>的时候，可以利用堆来实现</p></li>
<li><p>删除堆顶元素后，为了保持<strong>堆的性质</strong>，需要对堆的结构进行调整，我们可以将这个过程称之为<strong>堆化</strong></p>
<ol type="1">
<li><strong>自底向上</strong>的堆化，上述的<strong>插入元素</strong>所使用的，就是自顶向上的<strong>堆化</strong>，元素从最底部向上移动</li>
<li><strong>自顶向下</strong>的堆化，元素由<strong>顶部向下</strong>移动。在讲解删除堆顶元素的方法时，我将阐述这<strong>两种操作的过程</strong></li>
</ol></li>
<li><p><strong>自底向上堆化</strong></p>
<blockquote>
<p>在堆这个公司中，会出现老大离职的现象，老大离职之后，它的位置就空出来了</p>
</blockquote>
<ol type="1">
<li><p>首先删除堆顶元素，使得数组中下标为1的位置空出 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109111425216.png"
alt="image-20230109111425216" /></p>
<blockquote>
<p>那么他的位置由谁来接替呢，当然是他的直接下属了，谁能力强就让谁上</p>
</blockquote></li>
<li><p>比较<strong>根节点（当前节点）</strong>的<strong>左子节点</strong>和<strong>右子节点</strong>，也就是下标为
2 ，3
的数组元素，将较大的元素填充到<strong>根节点（下标为1）（当前遍历节点）</strong>的位置
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109112005680.png"
alt="image-20230109112005680" /></p>
<blockquote>
<p>此时又空出一个位置了，老规矩，谁有能力谁上</p>
</blockquote></li>
<li><p>一直循环比较<strong>空出位置</strong>的<strong>左右子节点</strong>，并将较大者移至空位，直到堆的最底部
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109112121358.png"
alt="image-20230109112121358" /></p>
<blockquote>
<p>此时已经完成<strong>自顶向上</strong>的堆化，没有元素可以填补空缺。但会发现数组中出现了”气泡”，导致存户空间的浪费。</p>
<p>解决办法：自顶向下堆化</p>
</blockquote></li>
</ol></li>
<li><p>自顶向下堆化 自顶向下的堆化用一个词形容就是“石沉大海”</p>
<ol type="1">
<li>第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是<strong>堆的最后一个元素</strong>，我们<strong>将最后一个元素移动到堆顶</strong>。
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109112439473.png"
alt="image-20230109112439473" /></li>
<li>将这个石头沉入海底，不停的与<strong>左右子节点</strong>的值进行比较，和<strong>较大的子节点</strong>交换位置，直到<strong>无法交换位置</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109112535327.png"
alt="image-20230109112535327" /></li>
<li>结果 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109112624540.png"
alt="image-20230109112624540" /></li>
</ol></li>
</ul>
<h2 id="堆的操作总结">堆的操作总结</h2>
<ul>
<li><p><strong>插入元素</strong>：先将元素放置数组末尾，再<strong>自底向上</strong>堆化，将<strong>末尾元素上浮</strong></p></li>
<li><p><strong>删除堆顶元素</strong>：删除堆顶元素，<strong>将末尾元素放置堆顶</strong>，再<strong>自顶向下</strong>堆化，将<strong>堆顶元素下沉</strong>。</p>
<blockquote>
<p>也可以自底向上堆化，但是会产生<strong>气泡</strong>，浪费存储空间。不建议</p>
</blockquote></li>
</ul>
<h1 id="堆排序">堆排序</h1>
<p>堆排序的过程分两步</p>
<ol type="1">
<li>建堆，将一个<strong>无序的数组</strong>，<strong>建立成堆</strong></li>
<li>排序，[
将<strong>堆顶元素取出</strong>，然后对<strong>剩下的元素堆化</strong>
]。
<ul>
<li><strong>反复迭代</strong>，直到所有元素被取出</li>
</ul></li>
</ol>
<h2 id="建堆">建堆</h2>
<ul>
<li><p>也就是对<strong>所有非叶子结点</strong>进行自顶向下</p>
<p>如图，红色区域分别是堆的情况下。对于T，如果只<strong>自顶向下</strong>到P、L这层，被换到了这层的那个元素是不一定就比其他树大的，所以还是要依次自顶向下</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109140309966.png"
alt="image-20230109140309966" /> 这个构建堆操作的时间复杂度为O(n) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109141141591.png"
alt="image-20230109141141591" /></p></li>
<li><p>首先要了解哪些是非叶节点，<strong>最后一个结点的父节点及它（这个父节点）之前的元素</strong>，都是非叶节点。也就是说，如果<strong>节点个数为n</strong>，那么我们需要对<strong>n/2到1的节点进行自顶向下（沉底）堆化</strong></p></li>
<li><p>如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109143927351.png"
alt="image-20230109143927351" /></p>
<ol type="1">
<li>首先将初始的无序数组抽象为一棵树，图中的节点个数为6，所以4，5，6是叶子节点，1，2，3节点为非叶节点<br />
</li>
<li>对1，2，3节点进行<strong>自顶向下（沉底）</strong>堆化，注意，顺序是从后往前堆化，从3号开始，一直到1号节点。
<ul>
<li>3号节点堆化结果<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109153344935.png"
alt="image-20230109153344935" /></li>
<li>2号节点堆化结果 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109153422766.png"
alt="image-20230109153422766" /></li>
<li>1号节点堆化结果 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109153456496.png"
alt="image-20230109153456496" /></li>
</ul></li>
</ol></li>
</ul>
<h2 id="排序">排序</h2>
<ul>
<li>方法：由于堆顶元素是所有元素中最大的，所以我们<strong>重复取出堆顶元素</strong>，将这个最大的堆顶元素<strong>放至数组末尾</strong>，并<strong>对剩下的元素进行堆化</strong>即可</li>
<li>现在思考两个问题：
<ul>
<li>删除堆顶元素后需要执行<strong>自顶向下（沉底）</strong>堆化还是<strong>自底向上（上浮）</strong>堆化？</li>
<li>取出的堆顶元素存在哪，新建一个数组存？</li>
</ul></li>
<li>答案
<ol type="1">
<li>需要使用<strong>自顶向下（沉底）</strong>堆化，这个堆化一开始要<strong>将末尾元素移动至堆顶</strong>。由于这个时候末尾的位置已经空出来了由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将<strong>取出的元素放在末尾</strong>。</li>
<li>其实是做了一次<strong>交换</strong>操作，将<strong>堆顶和末尾元素调换</strong>位置，从而将<strong>取出堆顶元素</strong>和<strong>堆化的第一步(将末尾元素放至根结点位置)</strong>进行合并</li>
</ol></li>
<li>步骤
<ol type="1">
<li>取出第一个元素并堆化 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109154808329.png"
alt="image-20230109154808329" /></li>
<li>取出第2个元素并堆化 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109154830946.png"
alt="image-20230109154830946" /></li>
<li>取出第3个元素并堆化 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109154851849.png" /></li>
<li>取出第4个元素并堆化 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109155008000.png"
alt="image-20230109155008000" /></li>
<li>取出第5个元素并堆化 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109155104829.png"
alt="image-20230109155104829" /></li>
<li>取出第6个元素并堆化 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109155116813.png"
alt="image-20230109155116813" /></li>
<li>排序完成</li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title>线性数据结构</title>
    <url>/2022/12/20/review/java_guide/cs_basics/data-structure/linear-data-structure/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="数组">数组</h1>
<ul>
<li>数组（Array）是一种常见数据结构，由<strong>相同类型的元素（element）</strong>组成，并且是使用一块<strong>连续的内存</strong>来存储</li>
<li>直接可以利用元素的<strong>索引（index）</strong>可以计算出该元素对应的存储地址</li>
<li>数组的特点是：提供<strong>随机访问</strong>并且<strong>容量有限</strong></li>
</ul>
<blockquote>
<p>假设数组长度为n：<br />
访问：O(1) //访问特定位置的元素</p>
<p>插入：O(n)
//最坏的情况插入在数组的<strong>首部</strong>并需要<strong>移动所有元素</strong>时</p>
<p>删除：O(n)
//最坏的情况发生在删除数组的<strong>开头</strong>并需要移动<strong>第一元素</strong>后面所有的元素时</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221220143941212.png"
alt="image-20221220143941212" />
<figcaption aria-hidden="true">image-20221220143941212</figcaption>
</figure>
<h1 id="链表">链表</h1>
<h2 id="链表简介">链表简介</h2>
<ul>
<li><p>链表（LinkedList）虽然是一种<strong>线性表</strong>，但是并<strong>不会按线性</strong>的顺序<strong>存储</strong>数据，使用的<strong>不是</strong>连续的内存空间来<strong>存储数据</strong></p></li>
<li><p>链表的<strong>插入</strong>和<strong>删除</strong>操作的复杂度为O(1)，只需要直到目标位置元素的<strong>上一个元素</strong>即可。但是，在<strong>查找一个节点</strong>或者<strong>访问特定位置</strong>的节点的时候复杂度为<strong>O(n)</strong></p></li>
<li><p>使用链表结构可以<strong>克服数组需要预先知道数据大小</strong>的缺点，链表结构可以充分利用<strong>计算机内存空间</strong>，实现灵活的<strong>内存动态管理</strong></p>
<blockquote>
<p>但链表<strong>不会节省空间</strong>，相比于数组会<strong>占用</strong>更多空间，因为链表中<strong>每个节点</strong>存放的还有<strong>指向其他节点</strong>的指针。除此之外，链表不具有<strong>数组随机读取</strong>的优点</p>
</blockquote></li>
</ul>
<h2 id="链表分类">链表分类</h2>
<p><strong>单链表</strong>、<strong>双向链表</strong>、<strong>循环链表</strong>、<strong>双向循环链表</strong></p>
<blockquote>
<p>假设链表中有<strong>n个元素</strong><br />
访问：O(n) //访问特地给位置的元素</p>
<p>插入删除：O(1) //必须要知道插入元素的位置</p>
</blockquote>
<h3 id="单链表">单链表</h3>
<ul>
<li><strong>单链表</strong>只有一个方向，结点<strong>只有一个后继指针next</strong>指向后面的节点。因此，链表这种数据结构通常在<strong>物理内存</strong>上是<strong>不连续</strong>的</li>
<li>我们习惯性地把<strong>第一个结点</strong>叫做<strong>头结点</strong>，链表通常有一个<strong>不保存任何值的head节点</strong>（头结点），通过头结点我们可以<strong>遍历整个链表</strong>，尾结点通常<strong>指向null</strong></li>
<li>如下图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221220164125131.png"
alt="image-20221220164125131" /></li>
</ul>
<h3 id="循环链表">循环链表</h3>
<ul>
<li>循环链表是一种<strong>特殊的单链表</strong>，和单链表不同的是<strong>循环链表的尾结点</strong>不是指向null，而是<strong>指向链表的头结点</strong></li>
<li>如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221220164334567.png"
alt="image-20221220164334567" /></li>
</ul>
<h3 id="双向链表">双向链表</h3>
<ul>
<li>双向链表包含<strong>两个指针</strong>，一个<strong>prev</strong>指向<strong>前一个节点</strong>，另一个<strong>next</strong>指向</li>
<li>如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221220164450954.png"
alt="image-20221220164450954" /></li>
</ul>
<h3 id="双向循环链表">双向循环链表</h3>
<p>双向循环链表的<strong>最后一个节点的next</strong>指向head，而head的<strong>prev</strong>指向最后一个节点，构成一个环</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221220164602604.png"
alt="image-20221220164602604" />
<figcaption aria-hidden="true">image-20221220164602604</figcaption>
</figure>
<h2 id="应用场景">应用场景</h2>
<ul>
<li>如果需要支持<strong>随机访问</strong>的话，链表无法做到</li>
<li>如果需要<strong>存储的数据元素个数不确定</strong>，并且需要经常<strong>添加</strong>和<strong>删除</strong>数据的话，使用<strong>链表</strong>比较合适</li>
<li>如果需要<strong>存储的数据元素</strong>的个数确定，并且不需要<strong>经常添加</strong>和<strong>删除</strong>数据的话，使用数组比较合适</li>
</ul>
<h2 id="数组-vs-链表">数组 vs 链表</h2>
<ul>
<li>数组支持<strong>随机访问</strong>，链表不支持</li>
<li>数组使用的是<strong>连续内存空间</strong>
<strong>对CPU缓存机制</strong>友好，链表则<strong>相反</strong></li>
<li>数组的<strong>大小固定</strong>，而链表则<strong>天然支持动态扩容</strong>。如果生命的数组过小，需要另外申请一个<strong>更大的内存空间</strong>存放数组元素，然后将<strong>原数组拷贝进去</strong>，这个操作比较耗时</li>
</ul>
<h1 id="栈">栈</h1>
<h2 id="栈简介">栈简介</h2>
<ul>
<li>栈（stack）只允许在<strong>有序的线性数据集合</strong>的<strong>一端</strong>（称为栈顶top）进行<strong>加入数据（push）</strong>和<strong>移除数据（pop）</strong>。因而按照<strong>后进先出（LIFO，Last
In First Out）</strong>的原理运作。</li>
<li>栈中，<strong>push</strong>和<strong>pop</strong>的操作都发生在栈顶</li>
<li>栈常用<strong>一维数组</strong>或<strong>链表</strong>来实现，用数组实现的叫<strong>顺序栈</strong>，用链表实现的叫做<strong>链式栈</strong></li>
</ul>
<blockquote>
<p>假设堆栈中有n个元素。 访问：O（n）//最坏情况
插入删除：O（1）//顶端插入和删除元素</p>
</blockquote>
<p>如图：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221220165405830.png"
alt="image-20221220165405830" /></p>
<h2 id="栈的常见应用场景">栈的常见应用场景</h2>
<p>当我们要处理的数据，只涉及在一端<strong>插入</strong>和<strong>删除</strong>数据，并且满足<strong>后进先出（LIFO，LastInFirstOut）</strong>的特性时，我们就可以使用<strong>栈</strong>这个数据结构。</p>
<h3 id="实现浏览器的回退和前进功能">实现浏览器的回退和前进功能</h3>
<p>我们只需要使用<strong>两个栈(Stack1 和
Stack2)</strong>和就能实现这个功能。比如你按顺序查看了 1,2,3,4
这四个页面，我们<strong>依次把 1,2,3,4 这四个页面压入 Stack1</strong>
中。当你<strong>想回头看 2</strong>
这个页面的时候，你点击回退按钮，我们<strong>依次把 4,3 这两个页面从
Stack1 弹出</strong>，然后<strong>压入 Stack2</strong>
中。假如你又想<strong>回到页面
3</strong>，你点击前进按钮，我们<strong>将 3 页面从 Stack2
弹出</strong>，然后<strong>压入到 Stack1</strong> 中。示例图如下<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221220170624867.png"
alt="image-20221220170624867" /></p>
<h3 id="检查符号是否承兑出现">检查符号是否承兑出现</h3>
<blockquote>
<p>给定一个<strong>只</strong>包括
<code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code>
的字符串，判断<strong>该字符串是否有效</strong>。</p>
<p>有效字符串需满足：</p>
<ol type="1">
<li><strong>左括号必须用相同类型的右括号</strong>闭合。</li>
<li><strong>左括号必须以正确的顺序闭合</strong>。</li>
</ol>
<p>比如 "()"、"()<span></span>"、"{[]}" 都是有效字符串，而 "(]" 、"([)]"
则不是。</p>
</blockquote>
<p>这个问题实际是 Leetcode 的一道题目，我们可以<strong>利用栈
<code>Stack</code></strong> 来解决这个问题。</p>
<ol type="1">
<li>首先我们将<strong>括号间的对应规则存放在 <code>Map</code></strong>
中，这一点应该毋容置疑；</li>
<li>创建一个栈。遍历字符串，如果字符是<strong>左括号就直接加入<code>stack</code></strong>中，否则<strong>将<code>stack</code>
的栈顶元素</strong>与<strong>这个括号</strong>做比较，如果不相等就直接返回
false。遍历结束，如果<code>stack</code>为空，返回
<code>true</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="comment">// 括号之间的对应规则</span></span><br><span class="line">    HashMap&lt;Character, Character&gt; mappings = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;();</span><br><span class="line">    mappings.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    mappings.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">    mappings.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Character&gt;();</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mappings.containsKey(chars[i])) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">topElement</span> <span class="operator">=</span> stack.empty() ? <span class="string">&#x27;#&#x27;</span> : stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (topElement != mappings.get(chars[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.push(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="反转字符串">反转字符串</h3>
<p>将字符串中的每个字符<strong>先入栈再出栈</strong>就可以了。</p>
<h3 id="维护函数调用">维护函数调用</h3>
<p><strong>最后一个被调用</strong>的函数<strong>必须先完成执行</strong>，符合栈的
<strong>后进先出（LIFO, Last In First Out）</strong> 特性。</p>
<h2 id="栈的实现">栈的实现</h2>
<ul>
<li><p>栈既可以通过<strong>数组</strong>实现，也可以通过<strong>链表</strong>实现。两种情况下，<strong>入栈</strong>、<strong>出栈</strong>的时间复杂度均为O(1)</p></li>
<li><p>下面使用<strong>数组</strong>下实现栈，具有<strong>push()</strong>、<strong>pop()</strong>
（返回栈顶元素并出栈）、<strong>peek()</strong>
（返回栈顶元素不出栈）、<strong>isEmpty()</strong>
、<strong>size()</strong> 这些基本的方法</p>
<blockquote>
<p>每次入栈前先判断<strong>栈容量是否够用</strong>，如果不够用就用Arrays.copyOf()
进行扩容</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] storage;<span class="comment">//存放栈中元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;<span class="comment">//栈的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;<span class="comment">//栈中元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GROW_FACTOR</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不带初始容量的构造方法。默认容量为8</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = <span class="number">8</span>;</span><br><span class="line">        <span class="built_in">this</span>.storage=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带初始容量的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Capacity too small.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.capacity = initialCapacity;</span><br><span class="line">        <span class="built_in">this</span>.storage = <span class="keyword">new</span> <span class="title class_">int</span>[initialCapacity];</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">            ensureCapacity();</span><br><span class="line">        &#125;</span><br><span class="line">        storage[count++] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保容量大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> capacity * GROW_FACTOR;</span><br><span class="line">        storage = Arrays.copyOf(storage, newCapacity);</span><br><span class="line">        capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶元素并出栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> storage[count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶元素不出栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Stack is empty.&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> storage[count-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈中元素的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----</span></span><br><span class="line"><span class="comment">MyStack myStack = new MyStack(3);</span></span><br><span class="line"><span class="comment">myStack.push(1);</span></span><br><span class="line"><span class="comment">myStack.push(2);</span></span><br><span class="line"><span class="comment">myStack.push(3);</span></span><br><span class="line"><span class="comment">myStack.push(4);</span></span><br><span class="line"><span class="comment">myStack.push(5);</span></span><br><span class="line"><span class="comment">myStack.push(6);</span></span><br><span class="line"><span class="comment">myStack.push(7);</span></span><br><span class="line"><span class="comment">myStack.push(8);</span></span><br><span class="line"><span class="comment">System.out.println(myStack.peek());//8</span></span><br><span class="line"><span class="comment">System.out.println(myStack.size());//8</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; 8; i++) &#123;</span></span><br><span class="line"><span class="comment">    System.out.println(myStack.pop());</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">System.out.println(myStack.isEmpty());//true</span></span><br><span class="line"><span class="comment">myStack.pop();//报错：java.lang.IllegalArgumentException: Stack is empty. </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="队列">队列</h1>
<h2 id="队列简介">队列简介</h2>
<ul>
<li><p>队列是<strong>先进先出（FIFO，First In，First
Out）</strong>的线性表</p></li>
<li><p>通常用<strong>链表</strong>或<strong>数组</strong>来实现，用数组实现的队列叫做<strong>顺序队列</strong>，用<strong>链表</strong>实现的队列叫做<strong>链式队列</strong>。</p></li>
<li><p>队列只允许在<strong>后端（rear）</strong>进行插入操作也就是<strong>入队enqueue</strong>，在<strong>前端（front）</strong>进行删除操作也就是<strong>出队
dequeue</strong></p></li>
<li><p>队列的操作方式和堆栈类似，唯一的区别在于<strong>队列</strong>只允许<strong>新数据在后端</strong>进行添加（不允许在后端删除）</p>
<blockquote>
<p>假设队列中有n个元素。 访问：O（n）//最坏情况
插入删除：O（1）//后端插入前端删除元素</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/%25E9%2598%259F%25E5%2588%2597.png"
alt="队列" />
<figcaption aria-hidden="true">队列</figcaption>
</figure>
</blockquote></li>
</ul>
<h2 id="队列分类">队列分类</h2>
<h3 id="单队列">单队列</h3>
<p>这是<strong>常见</strong>的队列，每次添加元素时，都是添加到<strong>队尾</strong>。单队列又分为<strong>顺序队列（数组实现）</strong>和<strong>链式队列（链表实现）</strong></p>
<blockquote>
<p><strong>顺序队列</strong>存在<strong>假溢出</strong>：即明明有位置却不能添加</p>
</blockquote>
<p>假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素
7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear
移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是
<strong>”假溢出“</strong> 。除了假溢出问题之外，如下图所示，当添加元素 8
的时候，rear 指针移动到数组之外（越界）<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221225185308791.png"
alt="image-20221225185308791" /></p>
<blockquote>
<p>为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，<strong>front
指针指向对头元素（不是头结点）</strong>，rear
指针指向<strong>队列最后一个元素的下一个位置</strong>，这样当
<strong>front 等于 rear</strong>
时，此队列不是还剩一个元素，而是空队列。——From 《大话数据结构》<br />
<strong>（当只有一个元素时，front 指向0，rear指向1）</strong></p>
</blockquote>
<h3 id="循环队列">循环队列</h3>
<p>循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：<strong>从头开始</strong>，这样也就会形成<strong>头尾相接的循环</strong>，这也就是循环队列名字的由来。
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221225185743723.png"
alt="image-20221225185743723" />
（超出的时候，将rear指向0下标）。之后再添加时，向后移动即可</p>
<ul>
<li>顺序队列中，我们说 <code>front==rear</code>
的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种：
<ol type="1">
<li>可以设置一个标志变量 <code>flag</code>,当 <code>front==rear</code>
并且 <code>flag=0</code> 的时候队列为空，当<code>front==rear</code> 并且
<code>flag=1</code> 的时候队列为满。</li>
<li>队列为空的时候就是 <code>front==rear</code>
，<strong>队列满的时候，我们保证数组还有一个空闲的位置</strong>，rear
就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是：
<code>(rear+1) % QueueSize= front</code> 。 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221225185923759.png"
alt="image-20221225185923759" /> 其实也就是换一个定义罢了</li>
</ol></li>
</ul>
<h2 id="常见应用场景">常见应用场景</h2>
<p>当我们需要<strong>按照一定顺序</strong>来处理数据的时候可以考虑使用队列这个数据结构</p>
<ul>
<li>阻塞队列：
阻塞队列可以看成在<strong>队列基础上加了阻塞</strong>操作的队列。当<strong>队列为空</strong>的时候，<strong>出队操作阻塞</strong>，当<strong>队列满</strong>的时候，<strong>入队操作阻塞</strong>。使用阻塞队列我们可以很容易<strong>实现“生产者
- 消费者“</strong>模型</li>
<li><strong>线程池中的请求/任务队列：</strong>
<strong>线程池</strong>中<strong>没有空闲线程</strong>时，<strong>新的任务请求线程资源</strong>时，线程池该如何处理呢？答案是<strong>将这些请求放在队列</strong>中，当<strong>有空闲线程的时候，会循环中反复从队列中获取任务来执行</strong>。队列分为<strong>无界队列(基于链表)和有界队列(基于数组)</strong>。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如
：<strong><code>FixedThreadPool</code></strong> 使用无界队列
<strong><code>LinkedBlockingQueue</code></strong>。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在
Java
中的体现就是会抛出<strong><code>java.util.concurrent.RejectedExecutionException</code></strong>
异常。</li>
<li>Linux 内核进程队列（按优先级排队）</li>
<li>现实生活中的派对，播放器上的播放列表;</li>
<li>消息队列</li>
<li>等等......</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2023/01/09/review/java_guide/cs_basics/data-structure/tree/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<ul>
<li><p>树是一种类似现实生活中的树的数据结构（<strong>倒置的树</strong>）</p></li>
<li><p>任何一颗非空树<strong>只有一个根节点</strong></p></li>
<li><p>一棵树具有以下特点：</p>
<ol type="1">
<li>一棵树中的任何两个节点有且仅有唯一的一条路相通
（因为每个结点只会有一个父节点）</li>
<li>一棵树如果有n个节点，那么它一定恰好有n-1条边</li>
<li>一棵树不包括回路</li>
</ol></li>
<li><p>下面是一颗<strong>二叉树</strong> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109161939668.png"
alt="image-20230109161939668" />
深度和高度是对应的；根节点所在层为1层</p></li>
<li><p>常用概念</p>
<ol type="1">
<li><p>节点：树中每个元素都可以统称为节点</p></li>
<li><p>根节点：顶层节点，或者说没有父节点的节点。上图中A节点就是根节点</p></li>
<li><p>父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的
B 节点是 D 节点、E 节点的父节点</p></li>
<li><p>兄弟节点：具有<strong>相同父节点的节点</strong>互称为兄弟节点。上图中
D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。</p></li>
<li><p>叶子节点：<strong>没有子节点</strong>的节点。上图中的 D、F、H、I
都是叶子节点</p></li>
<li><p>节点的高度<strong>（跟叶子节点有关，同一层不一定一样）</strong>：<strong>该节点到叶子节点</strong>的<strong>最长</strong>路径<strong>所包含的</strong>边数**。</p></li>
<li><p>节点的深度<strong>（跟根节点有关，同一层是一样的）</strong>：<strong>根节点到该节点</strong>的路径所包含的<strong>边数</strong></p></li>
<li><p>节点的层数：节点的深度+1</p></li>
<li><p>树的高度：根节点的高度</p></li>
</ol></li>
</ul>
<h1 id="二叉树的分类">二叉树的分类</h1>
<ul>
<li><strong>二叉树（Binary
tree）</strong>是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构</li>
<li><strong>二叉树</strong>的分支，通常被称为<strong>左子树</strong>或<strong>右子树</strong>，并且，<strong>二叉树</strong>的分支具有左右次序，不能随意颠倒</li>
<li><strong>二叉树</strong>的第i层至多拥有<strong>2^(i-1)</strong>
个节点<br />
深度为<strong>k</strong>的二叉树至多总共有 <strong>2^(k+1) -1</strong>
个节点 （深度为k，最多k + 1 层，最多为满二叉树的情况）<br />
至少有2^(k) 个节点，即 深度为k-1的二叉树的最多的节点再加1</li>
</ul>
<blockquote>
<p>（关于节点的深度的定义国内争议比较多，我个人比较认可维基百科对<a
href="https://zh.wikipedia.org/wiki/树_(数据结构)#/术语">节点深度的定义open
in new window</a>）。 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109172027272.png"
alt="image-20230109172027272" /></p>
</blockquote>
<h2 id="满二叉树">满二叉树</h2>
<p>一个二叉树，如果每一个<strong>层</strong>的结点数都达到最大值，则这个二叉树就是
<strong>满二叉树</strong>。也就是说，如果一个<strong>二叉树的层数</strong>为
K，且结点总数是(2^k) -1 ，则它就是 <strong>满二叉树</strong>。 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230109172128330.png"
alt="image-20230109172128330" /></p>
<h2 id="完全二叉树">完全二叉树</h2>
<ul>
<li><p><strong>定义</strong>：除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是
<strong>完全二叉树</strong> 。</p></li>
<li><p>大家可以想象为一棵树从根结点开始扩展，<strong>扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层</strong>。如下图所示：<br />
从左到右，从上到下：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110095143413.png"
alt="image-20230110095143413" /></p></li>
<li><p>完全二叉树的性质：<strong>父结点</strong>和<strong>子节点</strong>的序号有着对应关系</p>
<blockquote>
<p>细心的小伙伴可能发现了，当根节点的值为 1
的情况下，若<strong>父结点的序号是
i</strong>，那么<strong>左子节点的序号就是 2i，右子节点的序号是
2i+1</strong>。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点，后续二叉树的存储会详细介绍。</p>
</blockquote></li>
</ul>
<h2 id="平衡二叉树">平衡二叉树</h2>
<ul>
<li><p><strong>平衡</strong>二叉树是一颗二叉排序树，且具有以下性质</p>
<ol type="1">
<li>可以是一棵空树</li>
<li>如果不是空树，那么<strong>左右两个子树的高度差</strong>的<strong>绝对值不超过1</strong>，并且左右两个子树都是一棵平衡二叉树</li>
</ol></li>
<li><p>平衡二叉树的常用实现方法有 <strong>红黑树</strong>、<strong>AVL
树</strong>、<strong>替罪羊树</strong>、<strong>加权平衡树</strong>、<strong>伸展树</strong>
等。</p></li>
<li><p>下面看一颗<strong>不太正常</strong>的树 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110102326007.png"
alt="image-20230110102326007" /></p>
<blockquote>
<p>这玩意儿还真叫树，只不过这棵树已经退化为一个链表了，我们管它叫
<strong>斜树</strong>。</p>
</blockquote>
<blockquote>
<ol type="1">
<li>二叉树相比于链表，由于父子节点以及兄弟节点之间往往具有某种特殊的关系，这种关系使得我们在树中对数据进行<strong>搜索</strong>和<strong>修改</strong>时，相对于链表更加快捷便利。</li>
<li>如果二叉树退化为一个链表了，那么那么树所具有的优秀性质就难以表现出来，效率也会大打折，为了避免这样的情况，我们希望每个做
“家长”（父结点） 的，都
<strong>一碗水端平</strong>，分给左儿子和分给右儿子的尽可能一样多，相差最多不超过一层，如下图所示：
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110102451581.png"
alt="image-20230110102451581" /></li>
</ol>
</blockquote></li>
</ul>
<h1 id="二叉树的存储">二叉树的存储</h1>
<ul>
<li>二叉树的存储主要分为<strong>链式存储</strong>和<strong>顺序存储</strong></li>
</ul>
<h2 id="链式存储">链式存储</h2>
<ul>
<li>和链表类似，二叉树的链式存储<strong>依靠指针</strong>将各个结点串联起来，不需要连续的存储空间</li>
<li>每个节点包括三个属性
<ol type="1">
<li><strong>数据data</strong>
data不一定是单一的数据，根据情况不同，可以是<strong>多个具有不同类型的数据</strong></li>
<li><strong>左节点指针 left</strong></li>
<li><strong>右节点指针 right</strong></li>
</ol></li>
<li>Java没有指针，而是直接<strong>引用对象</strong> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110112905083.png"
alt="image-20230110112905083" /></li>
</ul>
<h2 id="顺序存储">顺序存储</h2>
<ul>
<li>就是利用<strong>数组</strong>进行存储，数组中每一个位置仅存储<strong>结点的data</strong>，不存储左右子节点的指针，子节点的索引<strong>通过数组下标</strong>完成（类似<strong>堆</strong>）
<ul>
<li>根节点的序号为1，对于每个节点 Node，假设它存储在数组中下标为 i
的位置，那么它的左子节点就存储在 2i 的位置，它的右子节点存储在下标为
2i+1 的位置。</li>
<li>如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110113652925.png" /></li>
</ul></li>
<li>存储如下数组，会发现问题：如果要存储的二叉树不是完全二叉树，在<strong>数组中就会出现空隙，导致内存利用率降低</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110113804700.png"
alt="image-20230110113804700" /></li>
</ul>
<h1 id="二叉树的遍历">二叉树的遍历</h1>
<h2 id="先序遍历">先序遍历</h2>
<ul>
<li><p>定义：<strong>先输出根节点，再遍历左子树，最后遍历右子树。</strong>&lt;遍历左子树和右子树的时候，同样遵循先序遍历的规则&gt;。也就是说，可以使用递归实现先序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	system.out.println(root.data);</span><br><span class="line">	preOrder(root.left);</span><br><span class="line">	preOrder(root.right);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110114031370.png"
alt="image-20230110114031370" />
<figcaption aria-hidden="true">image-20230110114031370</figcaption>
</figure></li>
</ul>
<h2 id="中序遍历">中序遍历</h2>
<ul>
<li><p>定义：<strong>先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树</strong>，大家可以想象成一巴掌把树压扁，父结点被拍到了左子节点和右子节点的中间（倒影、映射）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	inOrder(root.left);</span><br><span class="line">	system.out.println(root.data);</span><br><span class="line">	inOrder(root.right);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>如图所示 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110114345712.png"
alt="image-20230110114345712" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110114356891.png"
alt="image-20230110114356891" /></p></li>
</ul>
<h2 id="后续遍历">后续遍历</h2>
<ul>
<li><p>定义：<strong>先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值</strong></p></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	postOrder(root.left);</span><br><span class="line">	postOrder(root.right);</span><br><span class="line">	system.out.println(root.data);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>如图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230110114443989.png"
alt="image-20230110114443989" /></p></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-data-structure</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句在MySQL中的执行过程</title>
    <url>/2023/01/19/review/java_guide/database/mysql/how-sql-executed-in-mysql/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
<p>原文 https://github.com/kinglaw1204 感谢作者</p>
</blockquote>
<ul>
<li>本篇文章会分析<strong>一个SQL语句</strong>在MySQL的<strong>执行流程</strong>，包括<strong>SQL的查询</strong>在MySQL内部会怎么<strong>流转</strong>，<strong>SQL语句的更新</strong>是怎么完成的</li>
<li>分析之前先看看<strong>MySQL的基础架构</strong>，知道了MySQL由<strong>哪些组件</strong>组成以及<strong>这些组件的作用</strong>是什么，可以帮助我们<strong>理解</strong>和<strong>解决</strong>这些问题</li>
</ul>
<p># MySQL基础架构分析</p>
<h2 id="mysql基本架构概览">MySQL基本架构概览</h2>
<ul>
<li>下图是MySQL的简要架构图，从下图可以看到<strong>用户的SQL语句</strong>在MySQL内部是<strong>如何执行的</strong></li>
<li>先简单介绍一个下图涉及的一些组件的基本作用 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230119113638560.png"
alt="image-20230119113638560" />
<ol type="1">
<li><strong>连接器</strong>：
<strong>身份认证</strong>和<strong>权限相关</strong>（登录MySQL的时候）</li>
<li><strong>查询缓存</strong>：执行查询语句的时候，会<strong>先查询缓存</strong>（MySQL8.0版本后移除，因为这个功能不太实用）</li>
<li><strong>分析器</strong>：<strong>没有命中</strong>缓存的话，SQL语句就会经过分析器，分析器说白了就是要<strong>先看</strong>你的SQL语句干嘛，再<strong>检查</strong>你的SQL语句<strong>语法</strong>是否正确</li>
<li><strong>优化器</strong>：按照<strong>MySQL认为最优的方案</strong>去执行</li>
<li><strong>执行器</strong>：<strong>执行语句</strong>，然后从<strong>存储引擎</strong>返回数据</li>
</ol></li>
<li>简单来说 MySQL 主要分为 Server 层和存储引擎层：
<ul>
<li><strong>Server
层</strong>：主要包括<strong>连接器</strong>、<strong>查询缓存</strong>、<strong>分析器</strong>、<strong>优化器</strong>、<strong>执行器</strong>等，所有跨存储引擎的功能都在这一层实现，比如<strong>存储过程</strong>、<strong>触发器</strong>、<strong>视图</strong>，<strong>函数</strong>等，还有一个<strong>通用的日志模块
binlog 日志模块</strong>。</li>
<li><strong>存储引擎</strong>：
主要负责数据的<strong>存储</strong>和<strong>读取</strong>，采用<strong>可以替换的插件式架构</strong>，支持
InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块
<strong>redolog 模块</strong>。<strong>现在最常用的存储引擎是
InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了</strong></li>
</ul></li>
</ul>
<h2 id="server层基本组件介绍">Server层基本组件介绍</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230119161526905.png"
alt="image-20230119161526905" />
<figcaption aria-hidden="true">image-20230119161526905</figcaption>
</figure>
<ol type="1">
<li><p><strong>连接器</strong>
连接器主要和<strong>身份认证</strong>和<strong>权限相关</strong>的功能相关，就好比一个级别很高的门卫一样</p>
<blockquote>
<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户<strong>账户密码</strong>已通过，连接器会到<strong>权限表</strong>中查询<strong>该用户的所有权限</strong>，之后在这个连接里的权限逻辑判断都是会依赖<strong>此时读取到的权限数据</strong>，也就是说，<strong>后续只要这个连接不断开</strong>，<strong>即使</strong>管理员<strong>修改</strong>了该用户的权限，该用户也是不受影响的。</p>
</blockquote></li>
<li><p><strong>查询缓存（MySQL8.0 版本后移除）</strong><br />
查询缓存<strong>主要用来缓存</strong>我们所执行的 <strong>SELECT
语句</strong>以及该<strong>语句的结果集</strong>。</p>
<blockquote>
<ul>
<li><p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个
SQL 是否执行过，以 <strong>Key-Value</strong> 的形式缓存在内存中，Key
是查询预计，Value 是结果集。如果缓存 key
被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p></li>
<li><p>MySQL
查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如<strong>你对一个表更新</strong>的话，<strong>这个表上的所有的查询缓存都会被清空</strong>。对于<strong>不经常更新的数据</strong>来说，<strong>使用缓存还是可以</strong>的。所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p></li>
</ul>
</blockquote>
<p>MySQL <strong>8.0
版本后删除了缓存</strong>的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了</p></li>
<li><p><strong>分析器</strong>MySQL
没有命中缓存，那么就会进入分析器，分析器主要是用来<strong>分析 SQL
语句是来干嘛</strong>的，分析器也会分为几步：</p>
<p><strong>第一步，词法分析</strong>，一条 SQL
语句有多个字符串组成，首先要<strong>提取关键字</strong>，比如
select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
<p><strong>第二步，语法分析</strong>，主要就是判断你输入的 SQL
是否正确，<strong>是否符合 MySQL 的语法</strong>。</p>
<p>完成这 2 步之后，MySQL
就准备开始执行了，但是<strong>如何执行，怎么执行是最好的结果</strong>呢？这个时候就需要优化器上场了。</p></li>
<li><p><strong>优化器</strong><br />
优化器的作用就是<strong>它认为的最优的执行</strong>方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如<strong>多个索引</strong>的时候该如何选择索引，<strong>多表查询</strong>的时候<strong>如何选择关联顺序</strong>等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来</p></li>
<li><p><strong>执行器</strong><br />
当选择了执行方案后，MySQL
就准备开始执行了，首先<strong>执行前会校验该用户有没有权限</strong>，如果没有权限，就会返回错误信息，<strong>如果有</strong>权限，就会去<strong>调用引擎的接口</strong>，返回接口执行的结果</p></li>
</ol>
<h1 id="语句分析">语句分析</h1>
<p>SQL分为两种，一种是<strong>查询</strong>，一种是<strong>更新（增加、修改、删除）</strong></p>
<h2 id="查询语句">查询语句</h2>
<p><code>select * from tb_student  A where A.age='18' and A.name=' 张三 ';</code></p>
<p>结合上面说明，分析下面这个语句的<strong>执行流程</strong>：</p>
<ol type="1">
<li><p>先<strong>检查该语句是否有权限</strong>，如果没有权限，直接返回错误信息，如果有权限，在
MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 key
在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p></li>
<li><p>通过<strong>分析器</strong>进行<strong>词法分析</strong>，提取
SQL 语句的关键元素，比如提取上面这个语句是查询
select，提取需要查询的表名为
tb_student，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个
SQL
语句是否有<strong>语法错误</strong>，比如关键词是否正确等等，如果检查没问题就执行下一步。</p></li>
<li><p>接下来就是优化器进行确定执行方案，上面的 SQL
语句，可以有两种执行方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</span><br><span class="line">b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。</span><br></pre></td></tr></table></figure>
<p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（<strong>优化器认为，有时候不一定最好</strong>）。那么确认了执行计划后就准备开始执行了</p></li>
<li><p>进行<strong>权限校验</strong>，如果没有权限就会返回错误信息，如果有权限就会调用<strong>数据库引擎接口</strong>，<strong>返回引擎的执行结果</strong></p></li>
</ol>
<h2 id="更新语句">更新语句</h2>
<p>以上就是一条查询 SQL
的执行流程，那么接下来我们看看一条更新语句如何执行的呢？SQL
语句如下：<br />
<code>update tb_student A set A.age='19' where A.name=' 张三 ';</code></p>
<blockquote>
<ul>
<li>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的</li>
<li>其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会<strong>引入日志模块</strong>了，MySQL
自带的日志模块是 <strong>binlog（归档日志）</strong>
，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块
<strong>redo log（重做日志）</strong>，我们就以 InnoDB
模式下来探讨这个语句的执行流程</li>
</ul>
</blockquote>
<ol type="1">
<li>先<strong>查询</strong>到张三这一条数据，如果有缓存，也是会用到缓存。</li>
<li>然后拿到查询的语句，把 <strong>age 改为 19</strong>，然后调用引擎
API 接口，写入这一行数据，<strong>InnoDB
引擎把数据保存在内存</strong>中，同时<strong>记录 redo
log</strong>，此时 redo log 进入 prepare
状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后<strong>记录 binlog</strong>，然后调用引擎接口，提交
redo log 为提交状态。</li>
<li>更新完成</li>
</ol>
<p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>
<ul>
<li><p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB
引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是
MyISAM，但是我们知道 <strong>redo log 是 InnoDB
引擎特有</strong>的，其他存储引擎都没有，这就导致会没有
<strong>crash-safe</strong> 的能力(<strong>crash-safe
的能力即使数据库发生异常重启，之前提交的记录都不会丢失</strong>)，binlog
日志只能用来归档。</p></li>
<li><p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log
来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么
redo log 要引入 prepare
预提交状态？这里我们用反证法来说明下为什么要这么做？</p>
<ul>
<li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完
redo log 后，机器挂了，binlog
日志没有被写入，那么机器重启后，这台机器会通过 redo log
恢复数据，但是这个时候 binlog
并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>
<li><strong>先写 binlog，然后写 redo log</strong>，假设写完了
binlog，机器异常重启了，由于没有 redo
log，本机是无法恢复这一条记录的，但是 binlog
又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>
</ul></li>
<li><p>如果采用 redo log 两阶段提交的方式就不一样了，<strong>写完 binlog
后，然后再提交 redo log</strong>
就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设
<strong>redo log 处于预提交状态，binlog
也已经写完</strong>了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于
<strong>MySQL 的处理机制</strong>了，MySQL 的处理过程如下：</p>
<ul>
<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>
<li>如果 <strong>redo log 只是预提交但不是 commit
状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log,
不完整就回滚事务</strong>。</li>
</ul></li>
</ul>
<p>这样就解决了数据一致性的问题</p>
<h1 id="总结">总结</h1>
<ul>
<li><p>MySQL 主要分为 <strong>Server
层</strong>和<strong>引擎层</strong>，Server
层主要包括<strong>连接器</strong>、<strong>查询缓存</strong>、分析器、<strong>优化器</strong>、<strong>执行器</strong>，同时还有一个<strong>日志模块（binlog）</strong>，这个日志模块所有执行引擎都可以共用，<strong>redolog
只有 InnoDB 有</strong>。</p></li>
<li><p>引擎层是插件式的，目前主要包括，<strong>MyISAM</strong>,<strong>InnoDB</strong>,<strong>Memory</strong>
等。</p></li>
<li><p><strong>查询</strong>语句的执行流程如下：<strong>权限校验（如果命中缓存）---&gt;查询缓存---&gt;分析器---&gt;优化器---&gt;权限校验---&gt;执行器---&gt;引擎</strong></p>
<p><strong>更新</strong>语句执行流程如下：<strong>分析器----&gt;权限校验----&gt;执行器---&gt;引擎---redo
log(prepare 状态)---&gt;binlog---&gt;redo
log(commit状态</strong></p></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-database</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的隐式转换造成的索引失效</title>
    <url>/2023/01/19/review/java_guide/database/mysql/index-invalidation-caused-by-implicit-conversion/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
<p>本篇文章基于MySQL
5.7.26，原文：https://www.guitu18.com/post/2019/11/24/61.html</p>
</blockquote>
<h1 id="前言">前言</h1>
<ul>
<li>关于<strong>数据库优化</strong>，最常见的莫过于<strong>索引失效</strong>，数据量多的时候比较明显，处理不及时会造成<strong>雪球效应</strong>，最终导致<strong>数据库卡死甚至瘫痪</strong>。</li>
<li>这里说的是<strong>隐式转换造成的索引失效</strong></li>
</ul>
<h1 id="数据准备">数据准备</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建测试数据表</span><br><span class="line">DROP TABLE IF EXISTS test1;</span><br><span class="line">CREATE TABLE `test1` (</span><br><span class="line">    `id` int(11) NOT NULL,</span><br><span class="line">    `num1` int(11) NOT NULL DEFAULT &#x27;0&#x27;,</span><br><span class="line">    `num2` varchar(11) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">    `type1` int(4) NOT NULL DEFAULT &#x27;0&#x27;,</span><br><span class="line">    `type2` int(4) NOT NULL DEFAULT &#x27;0&#x27;,</span><br><span class="line">    `str1` varchar(100) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">    `str2` varchar(100) DEFAULT NULL,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    KEY `num1` (`num1`),</span><br><span class="line">    KEY `num2` (`num2`),</span><br><span class="line">    KEY `type1` (`type1`),</span><br><span class="line">    KEY `str1` (`str1`),</span><br><span class="line">    KEY `str2` (`str2`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">-- 创建存储过程</span><br><span class="line">DROP PROCEDURE IF EXISTS pre_test1;</span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE `pre_test1`()</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0;</span><br><span class="line">    WHILE i &lt; 10000000 DO</span><br><span class="line">        SET i = i + 1;</span><br><span class="line">        SET @str1 = SUBSTRING(MD5(RAND()),1,20);</span><br><span class="line">        -- 每100条数据str2产生一个null值</span><br><span class="line">        IF i % 100 = 0 THEN</span><br><span class="line">            SET @str2 = NULL;</span><br><span class="line">        ELSE</span><br><span class="line">            SET @str2 = @str1;</span><br><span class="line">        END IF;</span><br><span class="line">        INSERT INTO test1 (`id`, `num1`, `num2`,</span><br><span class="line">        `type1`, `type2`, `str1`, `str2`)</span><br><span class="line">        VALUES (CONCAT(&#x27;&#x27;, i), CONCAT(&#x27;&#x27;, i),</span><br><span class="line">        CONCAT(&#x27;&#x27;, i), i%5, i%5, @str1, @str2);</span><br><span class="line">        -- 事务优化，每一万条数据提交一次事务</span><br><span class="line">        IF i % 10000 = 0 THEN</span><br><span class="line">            COMMIT;</span><br><span class="line">        END IF;</span><br><span class="line">    END WHILE;</span><br><span class="line">END;</span><br><span class="line">// DELIMITER ;</span><br><span class="line">-- 执行存储过程</span><br><span class="line">CALL pre_test1(); </span><br></pre></td></tr></table></figure>
<p>其中，七个字段，首先使用存储过程生成 1000 万条测试数据，
测试表一共建立了 7
个字段（包括主键），<strong><code>num1</code></strong>和<strong><code>num2</code></strong>保存的是和<code>ID</code>一样的顺序数字，其中<strong><code>num2</code>是字符串类型</strong>。
<strong><code>type1</code></strong>和<strong><code>type2</code></strong>保存的都是主键对
5 的取模，目的是模拟实际应用中常用<strong>类似 type
类型</strong>的数据，但是<strong><code>type2</code>是没有建立索引</strong>的。
<code>str1</code>和<code>str2</code>都是保存了一个 <strong>20
位长度的随机字符串</strong>，<strong><code>str1</code>不能为<code>NULL</code>，<code>str2</code>允许为<code>NULL</code></strong>，相应的生成测试数据的时候我也会<strong>在<code>str2</code>字段生产少量<code>NULL</code>值</strong>（每
100 条数据产生一个<code>NULL</code>值）。</p>
<p>数据量比较大，还涉及使用<code>MD5</code>生成随机字符串，所以速度有点慢，稍安勿躁，耐心等待即可。</p>
<p>1000 万条数据，我用了 33
分钟才跑完（实际时间跟你电脑硬件配置有关）。这里贴几条生成的数据，大致长这样。
数据如下所示：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/mysqlindex-invalidation-caused-by-implicit-conversion-01.png"
alt="img" /></p>
<h1 id="sql测试">SQL测试</h1>
<p>注：num1是int类型，num2是varchar类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1: SELECT * FROM `test1` WHERE num1 = 10000;</span><br><span class="line">2: SELECT * FROM `test1` WHERE num1 = &#x27;10000&#x27;;</span><br><span class="line">3: SELECT * FROM `test1` WHERE num2 = 10000;</span><br><span class="line">4: SELECT * FROM `test1` WHERE num2 = &#x27;10000&#x27;; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>这四条 SQL 都是有针对性写的，12 查询的字段是 int 类型，34
查询的字段是<code>varchar</code>类型。12 或 34
查询的字段虽然都相同，但是一个条件是数字，一个条件是用引号引起来的字符串。这样做有什么区别呢？先不看下边的测试结果你能猜出这四条
SQL 的效率顺序吗？</p>
<p>经测试这四条 SQL 最后的执行结果却相差很大，其中 <strong>124 三条 SQL
基本都是瞬间出结果</strong>，大概在 0.001~0.005
秒，在千万级的数据量下这样的结果可以判定这三条 SQL
性能基本没差别了。但是<strong>第三条 SQL</strong>，多次测试耗时基本在
4.5~4.8 秒之间</p>
<p><strong>也就是说 左int
右字符不影响效率；而左字符右int则影响效率，后面会解释</strong></p>
</blockquote>
<p>下面看1234的执行计划<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/mysqlindex-invalidation-caused-by-implicit-conversion-02.png"
alt="img" /></p>
<ol type="1">
<li><p>可以看到，<strong>124 三条 SQL
都能使用到索引</strong>，连接<strong>类型都为<code>ref</code></strong>，扫描行数都为
1，所以效率非常高。再看看<strong>第三条
SQL，没有用上索引</strong>，所以为<strong>全表扫描</strong>，<code>rows</code>直接到达
1000 万了，所以性能差别才那么大</p>
<blockquote>
<p>34 两条 SQL
查询的字段<code>num2</code>是<code>varchar</code>类型的，查询条件等号右边加引号的第
4 条 SQL
是用到索引的，那么是查询的数据类型和字段数据类型不一致造成的吗？如果是这样那
12 两条 SQL 查询的字段<code>num1</code>是<code>int</code>类型，但是第 2
条 SQL 查询条件右边加了引号为什么还能用上索引呢。 官方文档： <a
href="https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html?spm=5176.100239.blogcont47339.5.1FTben">12.2
Type Conversion in Expression Evaluationopen in new window</a></p>
<p>当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。某些转换是隐式发生的。例如，MySQL
会<strong>根据需要自动将字符串转换为数字，反之亦然</strong>。以下规则描述了比较操作的转换方式：</p>
<ol type="1">
<li>两个参数至少有一个是<code>NULL</code>时，比较的结果也是<code>NULL</code>，特殊的情况是使用<code>&lt;=&gt;</code>对两个<code>NULL</code>做比较时会返回<code>1</code>，这两种情况都不需要做类型转换</li>
<li>两个参数都是字符串，会按照字符串来比较，不做类型转换</li>
<li>两个参数都是整数，按照整数来比较，不做类型转换</li>
<li>十六进制的值和非数字做比较时，会被当做二进制串</li>
<li>有一个参数是<code>TIMESTAMP</code>或<code>DATETIME</code>，并且另外一个参数是常量，常量会被转换为<code>timestamp</code></li>
<li>有一个参数是<code>decimal</code>类型，如果另外一个参数是<code>decimal</code>或者整数，会将整数转换为<code>decimal</code>后进行比较，如果另外一个参数是浮点数，则会把<code>decimal</code>转换为浮点数进行比较</li>
<li><strong>所有其他情况下，两个参数都会被转换为浮点数再进行比较</strong></li>
</ol>
</blockquote></li>
<li><p>根据官方文档的描述，我们的第 23 两条 SQL 都发生了隐式转换，第 2
条 SQL
的查询条件<code>num1 = '10000'</code>，左边是<code>int</code>类型右边是字符串，第
3 条 SQL 相反，那么根据官方转换规则第 7
条，<strong>左右两边都会转换为浮点数</strong>再进行比较</p></li>
<li><p>★★</p>
<ol type="1">
<li><p>先看第 2 条
SQL：<code>SELECT * FROM</code>test1<code>WHERE num1 = '10000';</code><strong>左边为
int
类型</strong><code>10000</code>，转换为浮点数还是<code>10000</code>，右边字符串类型<code>'10000'</code>，转换为浮点数也是<code>10000</code>。两边的转换结果都是唯一确定的，所以不影响使用索引</p>
<blockquote>
<p>也就是说，只要我能用10000去查索引，查到了就一定是结果</p>
</blockquote></li>
<li><p>第 3 条
SQL：<code>SELECT * FROM</code>test1<code>WHERE num2 = 10000;</code><strong>左边是字符串类型</strong><code>'10000'</code>，转浮点数为
10000
是唯一的，右边<code>int</code>类型<code>10000</code>转换结果也是唯一的。但是，<strong>因为左边是检索条件，<code>'10000'</code>转到<code>10000</code>虽然是唯一，但是其他字符串也可以转换为<code>10000</code></strong>，比如<code>'10000a'</code>，<code>'010000'</code>，<code>'10000'</code>等等都能转为浮点数<code>10000</code>，这样的情况下，是不能用到索引的。</p>
<blockquote>
<p>也就是说，如果我把10000当作索引去查，是不行的。因为正确结果应该是把
'10000a'，'10000-'这种都查出来。而如果使用索引，也只能查出'10000'，结果不对。所以肯定会用上全表扫描</p>
</blockquote></li>
<li><p>对第二点的后半部分再做解释</p>
<blockquote>
<p>关于这个<strong>隐式转换</strong>我们可以通过查询测试验证一下，先插入几条数据，其中<code>num2='10000a'</code>、<code>'010000'</code>和<code>'10000'</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `num1`, `num2`, `type1`, `type2`, `str1`, `str2`) <span class="keyword">VALUES</span> (<span class="string">&#x27;10000001&#x27;</span>, <span class="string">&#x27;10000&#x27;</span>, <span class="string">&#x27;10000a&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;2df3d9465ty2e4hd523&#x27;</span>, <span class="string">&#x27;2df3d9465ty2e4hd523&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `num1`, `num2`, `type1`, `type2`, `str1`, `str2`) <span class="keyword">VALUES</span> (<span class="string">&#x27;10000002&#x27;</span>, <span class="string">&#x27;10000&#x27;</span>, <span class="string">&#x27;010000&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;2df3d9465ty2e4hd523&#x27;</span>, <span class="string">&#x27;2df3d9465ty2e4hd523&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test1` (`id`, `num1`, `num2`, `type1`, `type2`, `str1`, `str2`) <span class="keyword">VALUES</span> (<span class="string">&#x27;10000003&#x27;</span>, <span class="string">&#x27;10000&#x27;</span>, <span class="string">&#x27; 10000&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;2df3d9465ty2e4hd523&#x27;</span>, <span class="string">&#x27;2df3d9465ty2e4hd523&#x27;</span>); </span><br></pre></td></tr></table></figure>
<p>然后使用第三条 SQL
语句<code>SELECT * FROM</code>test1<code>WHERE num2 = 10000;</code>进行查询：</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/mysqlindex-invalidation-caused-by-implicit-conversion-03.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
</blockquote>
<p>从结果可以看到，后面插入的三条数据也都匹配上了。那么这个字符串隐式转换的规则是什么呢？为什么<code>num2='10000a'</code>、<code>'010000'</code>和<code>'10000'</code>这三种情形都能匹配上呢？查阅相关资料发现规则如下：</p>
<ol type="1">
<li><strong>不以数字开头</strong>的字符串都将转换为<code>0</code>。如<code>'abc'</code>、<code>'a123bc'</code>、<code>'abc123'</code>都会转化为<code>0</code>；</li>
<li><strong>以数字开头的</strong>字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如<code>'123abc'</code>会转换为<code>123</code>，<code>'012abc'</code>会转换为<code>012</code>也就是<code>12</code>，<code>'5.3a66b78c'</code>会转换为<code>5.3</code>，其他同理。</li>
</ol>
<p>现对以上规则做如下测试验证：</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/mysqlindex-invalidation-caused-by-implicit-conversion-04.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>如此也就印证了之前的查询结果了</p></li>
</ol></li>
<li><p>再次写一条 SQL 查询 str1
字段：<code>SELECT * FROM</code>test1<code>WHERE str1 = 1234;</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/mysqlindex-invalidation-caused-by-implicit-conversion-05.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
</ol>
<h1 id="分析和总结">分析和总结</h1>
<p>通过上面的测试我们发现 MySQL 使用操作符的一些特性：</p>
<ol type="1">
<li>当操作符<strong>左右两边的数据类型不一致</strong>时，会发生<strong>隐式转换</strong>。</li>
<li>当 where
查询操作符<strong>左边为数值类型</strong>时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。</li>
<li>当 where
查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</li>
<li>字符串转换为数值类型时，非数字开头的字符串会转化为<code>0</code>，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。</li>
</ol>
<p>所以，我们在写 SQL
时一定要养成良好的习惯，查询的字段是什么类型，等号右边的条件就写成对应的类型。特别当查询的字段是字符串时，等号右边的条件一定要用引号引起来标明这是一个字符串，否则会造成索引失效触发全表扫描</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-database</tag>
      </tags>
  </entry>
  <entry>
    <title>innodb引擎对MVCC的实现</title>
    <url>/2023/01/16/review/java_guide/database/mysql/innodb-implementation-of-mvcc/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="一致性非锁定读和锁定读">一致性非锁定读和锁定读</h1>
<h2 id="一致性非锁定读">一致性非锁定读</h2>
<p>★★非锁定★★</p>
<ul>
<li>对于<strong>一致性非锁定读（Consistent Nonlocking
Reads）</strong>的实现，通常做法是<strong>加一个版本号</strong>或者<strong>时间戳</strong>字段，在更新数据的同时<strong>版本号+1</strong>或者<strong>更新时间戳</strong>。查询时，将<strong>当前可见的版本号</strong>与<strong>对应记录的版本号</strong>进行比对，如果<strong>记录的版本</strong>小于<strong>可见版本</strong>，则表示<strong>该记录可见</strong></li>
<li><strong>InnoDB</strong>存储引擎中，<strong>多版本控制（multi
versioning）</strong>即使非锁定读的实现。如果读取的行<strong>正在执行DELETE</strong>或<strong>UPDATE</strong>操作，这时读取操作<strong>不会去等待行上</strong>
<strong>锁的释放</strong>.相反地，Inn哦DB存储引擎会去读取<strong>行的一个快照数据</strong>，对于这种<strong>读取历史数据</strong>的方式，我们叫它<strong>快照读（snapshot
read）</strong>。<br />
</li>
<li>在 <strong><code>Repeatable Read</code></strong> 和
<strong><code>Read Committed</code></strong>
两个隔离级别下，如果是执行普通的 <code>select</code>
语句（<strong>不包括 <code>select ... lock in share mode</code>
,<code>select ... for update</code></strong>）则会使用
<strong><code>一致性非锁定读（MVCC）</code></strong>。并且在
<strong><code>Repeatable Read</code> 下 <code>MVCC</code>
实现了可重复读和防止部分幻读</strong></li>
</ul>
<h2 id="锁定读">锁定读</h2>
<ul>
<li><p>如果执行的是下列语句，就是<strong>锁定读（Locking
Reads）</strong></p>
<ol type="1">
<li><code>select ... lock in share</code></li>
<li><code>select ... for update</code></li>
<li><code>insert</code>、<code>upate</code>、<code>delete</code></li>
</ol></li>
<li><p>锁定读下，读取的是数据的最新版本，这种读也被称为<strong>当前读current
read</strong>。<strong>锁定读</strong>会对读取到的记录加锁</p>
<ol type="1">
<li><code>select ... lock in share mode</code>：对(读取到的)记录加<strong>S锁</strong>，其他事务也可以加S锁，如果加X锁则会被阻塞</li>
<li><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加<strong>X锁</strong>，且其他事务不能加任何锁</li>
</ol></li>
<li><p>在一致性非锁定读下，即使读取的记录<strong>已被其他事务加上X锁</strong>，这时记录也是可以被读取的，即读取的<strong>快照数据</strong>。</p>
<ol type="1">
<li>在<strong>RepeatableRead</strong>下MVCC<strong>防止了部分幻读</strong>，这边的“<strong>部分”</strong>是指在<strong>一致性非锁定读</strong>情况下，只能读取到第一次查询之前所插入的数据（<strong>根据ReadView判断数据可见性，ReadView在第一次查询时生成</strong>），但如果是<strong>当前读</strong>，每次读取的都是<strong>最新数据</strong>，这时如果两次查询中间有其他事务插入数据，就会<strong>产生幻读</strong></li>
<li>所以，InnoDB在实现RepeatableRead时，如果执行的是<strong>当前读</strong>，则会对读取的记录使用<strong>Next-key
Lock</strong>，来防止其他事务在<strong>间隙间插入数据</strong>。</li>
</ol>
<blockquote>
<p><strong>RR产生幻读的另一个场景</strong></p>
<ul>
<li><p>假设有这样一张表<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/7f9df142b3594daeaaca495abb7133f5.png"
alt="img" /></p></li>
<li><p>事务 A 执行查询 id = 5
的记录，此时表中是没有该记录的，所以查询不出来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">事务 A</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">begin;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">select * from t_stu <span class="built_in">where</span> <span class="built_in">id</span> = 5;</span></span><br><span class="line">Empty set (0.01 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>然后事务 B 插入一条 id = 5 的记录，并且提交了事务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">事务 B</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">begin;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">insert into t_stu values(5, <span class="string">&#x27;小美&#x27;</span>, 18);</span></span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">commit;</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>此时，<strong>事务 A 更新 id = 5 这条记录，对没错，事务 A 看不到
id = 5 这条记录，但是他去更新了这条记录，这场景确实很违和，然后再次查询
id = 5 的记录，事务 A 就能看到事务 B
插入的纪录了，幻读就是发生在这种违和的场景</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">事务 A</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">update t_stu <span class="built_in">set</span> name = <span class="string">&#x27;小林coding&#x27;</span> <span class="built_in">where</span> <span class="built_in">id</span> = 5;</span></span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">select * from t_stu <span class="built_in">where</span> <span class="built_in">id</span> = 5;</span></span><br><span class="line">+----+--------------+------+</span><br><span class="line">| id | name         | age  |</span><br><span class="line">+----+--------------+------+</span><br><span class="line">|  5 | 小林coding   |   18 |</span><br><span class="line">+----+--------------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>时序图如下<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/%25E5%25B9%25BB%25E8%25AF%25BB%25E5%258F%2591%25E7%2594%259F.drawio.png"
alt="img" /></p></li>
<li><p>在可重复读隔离级别下，事务 A 第一次执行普通的 select
语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5
的记录并提交。接着，事务 A 对 id = 5
这条记录进行了更新操作，在这个时刻，<strong>这条新记录的 trx_id
隐藏列的值</strong>就<strong>变成了事务 A 的事务 id</strong>，之后事务 A
再使用普通 select
语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p>
<p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC
并不能完全避免幻读现象</strong>。</p></li>
</ul>
</blockquote></li>
</ul>
<h1 id="innodb对mvcc的实现">InnoDB对MVCC的实现</h1>
<ul>
<li>MVCC的实现依赖于：<strong>隐藏字段（每条记录的）</strong>、<strong>ReadView（当前事务生成的）</strong>、<strong>undo
log（当前事务执行时，为每个操作（记录）生成的）</strong></li>
<li><strong>内部实现</strong>中，InnoDB通过数据行的<strong>DB_TRX_ID</strong>和<strong>Read
View</strong>来判断数据的可见性，如不可见，则通过<strong>数据行的DB_ROLL_PTR</strong>找到<strong>undo
log</strong>中的历史版本。<strong>因此</strong>，每个事务读到的<strong>数据版本</strong>可能是不一样的，<strong>在同一个事务中</strong>，用户只能看到<strong>该事务创建ReadView</strong>之前<strong>（其实这个说法不太准确，m_up_limit_id不一定大于当前事务id）</strong>已经提交的修改和<strong>该事务本身做的修改</strong></li>
</ul>
<h2 id="隐藏字段">隐藏字段</h2>
<ul>
<li><strong>内部</strong>，<strong>InnoDB</strong>存储引擎为<strong>每行数据</strong>添加了<strong>三个隐藏字段</strong>：
<ol type="1">
<li><strong>DB_TRX_ID(6字节)</strong>：表示<strong>最后一次插入</strong>或<strong>更新该行</strong>的<strong>事务id</strong>。此外，<strong>delete</strong>操作在内部被视为更新，只不过会在<strong>记录头Record
header</strong>中的<strong>deleted_flag</strong>字段将其标记为<strong>已删除</strong><br />
</li>
<li><strong>DB_ROLL_PTR(7字节)</strong>：回滚指针，指向<strong>该行的undo
log</strong>。如果该行<strong>违背更新</strong>，则为<strong>空</strong></li>
<li><strong>DB_ROW_ID(6字节)</strong>：如果<strong>没有设置主键</strong>且<strong>该表没有唯一非空索引</strong>时，InnoDB会使用该id来<strong>生成聚簇索引</strong></li>
</ol></li>
</ul>
<h2 id="readview">ReadView</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadView</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  trx_id_t m_low_limit_id;      <span class="comment">/* 大于等于这个 ID 的事务均不可见 */</span></span><br><span class="line"></span><br><span class="line">  trx_id_t m_up_limit_id;       <span class="comment">/* 小于这个 ID 的事务均可见 */</span></span><br><span class="line"></span><br><span class="line">  trx_id_t m_creator_trx_id;    <span class="comment">/* 创建该 Read View 的事务ID */</span></span><br><span class="line"></span><br><span class="line">  trx_id_t m_low_limit_no;      <span class="comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span> </span><br><span class="line"></span><br><span class="line">  ids_t m_ids;                  <span class="comment">/* 创建 Read View 时的活跃事务列表 */</span></span><br><span class="line"></span><br><span class="line">  m_closed;                     <span class="comment">/* 标记 Read View 是否 close */</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>Read View</strong>
主要是用来做<strong>可见性</strong>判断，里面保存了
“<strong>当前对本事务不可见的其他活跃事务</strong>”</p></li>
<li><p>ReadView主要有以下字段</p>
<ol type="1">
<li><code>m_low_limit_id</code>：<strong>目前出现过的最大的事务
ID+1</strong>，即下一个将被分配的事务 ID。大于等于这个 ID
的数据版本均不可见</li>
<li><code>m_up_limit_id</code>：<strong>活跃事务列表 <code>m_ids</code>
中最小的事务 ID</strong>，如果 <code>m_ids</code> 为空，则
<code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID
的数据版本均可见</li>
<li><code>m_ids</code>：<strong><code>Read View</code>
创建时其他未提交的活跃事务 ID 列表</strong>。创建
<code>Read View</code>时，将当前未提交事务 ID
记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code>
不包括当前事务自己和已提交的事务（正在内存中）</li>
<li><code>m_creator_trx_id</code>：<strong>创建该 <code>Read View</code>
的事务 ID</strong></li>
</ol></li>
<li><p><strong>事务可见性</strong>示意图（这个图容易理解）：</p>
<blockquote>
<p>为什么不是分<strong>大于m_low_limit_id</strong>和<strong>在小于m_low_limit_id里过滤存在于活跃事务列表</strong>，应该和算法有关吧</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230118155617419.png"
alt="image-20230118155617419" />
<figcaption aria-hidden="true">image-20230118155617419</figcaption>
</figure></li>
</ul>
<h2 id="undo-log">undo-log</h2>
<ul>
<li><p>undo log主要有两个作用</p>
<ol type="1">
<li>当<strong>事务回滚时用于将数据恢复</strong>到修改前的样子</li>
<li>用于<strong>MVCC</strong>，读取记录时，若该记录被其他事务<strong>占用</strong>或当前版本<strong>对该事务不可见</strong>，则可以<strong>通过</strong>undo
log 读取之前的版本数据，以此实现<strong>非锁定读</strong></li>
</ol></li>
<li><p><strong>InnoDB</strong>存储引擎中<strong>undo
log</strong>分为两种：<strong>insert undo log</strong>和<strong>update
undo log</strong></p>
<ol type="1">
<li><p><strong>insert undo
log</strong>：指在<strong>insert</strong>操作中产生的<strong>undo
log</strong>，因为<strong>insert</strong>操作的记录只对事务本身可见，对其他事务不可见，故<strong>该undo
log</strong>可以在<strong>事务提交后直接删除</strong>。不需要进行<strong>purge</strong>操作（purge：清洗）</p>
<p><strong>insert</strong>时的数据初始状态：(DB_ROLL_PTR为空)<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230119092412325.png"
alt="image-20230119092412325" /></p></li>
<li><p><strong>update undo
log</strong>：<strong>undate</strong>或<strong>delete</strong>操作产生的undo
log。该undo log
可能需要<strong>提供给MVCC机制</strong>，因此不能在事务提交时就进行删除。提交时放入undo
log链表，等待<strong>purge线程</strong>进行最后的删除</p></li>
</ol></li>
<li><p>数据第一次修改时<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230119092627138.png"
alt="image-20230119092627138" /></p></li>
<li><p>数据第二次被修改时<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230119092833856.png"
alt="image-20230119092833856" />
<strong>不同事务</strong>或者<strong>相同事务</strong>的<strong>对同一记录行的修改</strong>，会使<strong>该记录行</strong>的
<strong><code>undo log</code>
成为一条链表</strong>，<strong>链首</strong>就是<strong>最新</strong>的记录，<strong>链尾</strong>就是<strong>最早</strong>的旧记录。</p></li>
</ul>
<h2 id="数据可见性算法">数据可见性算法</h2>
<ul>
<li><p>在 <code>InnoDB</code>
存储引擎中，创建一个新事务后，<strong>执行每个 <code>select</code>
语句前(RC下是)</strong>，都会创建一个快照（<strong>Read
View</strong>），<strong>快照中保存了当前数据库系统中正处于活跃（没有
commit）的事务的 ID
号</strong>。其实简单的说保存的是系统中<strong>当前不应该被本事务看到的其他事务
ID 列表（即
m_ids）</strong>。当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code>
会将该<strong>记录行的 <code>DB_TRX_ID</code></strong> 与
<strong><code>Read View</code> 中的一些变量</strong>及<strong>当前事务
ID</strong> 进行比较，判断是否满足可见性条件</p></li>
<li><p>具体的比较算法<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/8778836b-34a8-480b-b8c7-654fe207a8c2.3d84010e.png"
alt="img" /></p>
<ol type="1">
<li>如果<strong>记录 DB_TRX_ID &lt;
m_up_limit_id</strong>，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是<strong>可见</strong>的</li>
<li>如果 <strong>DB_TRX_ID &gt;=
m_low_limit_id</strong>，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务<strong>不可见</strong>。跳到步骤
5</li>
<li><strong>m_ids 为空（且DB_TRX_ID &lt;
m_low_limit_id）</strong>，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值<strong>对当前事务是可见</strong>的</li>
<li>如果 <strong>m_up_limit_id &lt;= DB_TRX_ID &lt;
m_low_limit_id</strong>，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表
m_ids 进行查找（源码中是用的二分查找，因为是有序的）
<ul>
<li>如果<strong>在活跃事务列表 m_ids 中能找到
DB_TRX_ID</strong>，表明：①
在当前事务<strong>创建快照前</strong>，该记录行的值被事务 ID 为
DB_TRX_ID 的事务<strong>修改了，但没有提交</strong>；或者 ②
在<strong>当前事务创建快照后</strong>，该记录行的值<strong>被事务 ID 为
DB_TRX_ID
的事务修改</strong>了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤
5</li>
<li>在活跃事务列表中<strong>找不到</strong>，则表明“id 为 trx_id
的事务”在修改“该记录行的值”后，在<strong>“当前事务”创建快照前就已经提交</strong>了，所以记录行对当前事务可见</li>
</ul></li>
<li><strong>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code>
取出快照记录</strong>，用快照记录的 DB_TRX_ID 跳到步骤 1
重新开始判断，直到找到满足的快照版本或返回空</li>
</ol></li>
</ul>
<h1 id="rc-和-rr-隔离级别下-mvcc-的差异">RC 和 RR 隔离级别下 MVCC
的差异</h1>
<p>在事务隔离级别 <strong><code>RC</code> 和 <code>RR</code></strong>
（InnoDB 存储引擎的默认事务隔离级别）下，<strong><code>InnoDB</code>
存储引擎使用
<code>MVCC</code>（非锁定一致性读）</strong>，但它们<strong>生成
<code>Read View</code> 的时机却不同</strong> 【<strong>RC：Read Commit
读已提交，RR：Repeatable Read 可重复读</strong>】</p>
<ul>
<li>在 RC 隔离级别下的 <strong><code>每次select</code></strong>
查询前都生成一个<code>Read View</code> (m_ids 列表)</li>
<li>在 RR 隔离级别下只在事务开始后
<strong><code>第一次select</code></strong>
数据前生成一个<code>Read View</code>（m_ids 列表）</li>
</ul>
<h1 id="mvcc解决不可重复读问题">MVCC解决不可重复读问题</h1>
<p>虽然 RC 和 RR 都通过 <code>MVCC</code> 来读取快照数据，但由于
<strong>生成 Read View 时机不同</strong>，从而在 <strong>RR
级别下实现可重复读</strong></p>
<p>举例： （Tn 表示时间线）<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/6fb2b9a1-5f14-4dec-a797-e4cf388ed413.ea9e47d7.png"
alt="img" /></p>
<h2 id="在rc下readview生成情况">在RC下ReadView生成情况</h2>
<p><strong>1. 假设时间线来到 T4 ，那么此时数据行 id = 1
的版本链为：</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/a3fd1ec6-8f37-42fa-b090-7446d488fd04.bf41f07c.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>由于 RC 级别下每次查询都会生成<code>Read View</code> ，并且事务
101、102 并未提交，此时 <code>103</code> 事务生成的
<code>Read View</code> 中活跃的事务 <strong><code>m_ids</code>
为：[101,102]</strong>
，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code>
为：103</p>
<ul>
<li>此时最新记录的 <code>DB_TRX_ID</code> 为 101，m_up_limit_id &lt;=
101 &lt; m_low_limit_id，所以要在 <strong><code>m_ids</code>
列表中查找</strong>，发现 <strong><code>DB_TRX_ID</code>
存在列表</strong>中，那么这个记录不可见</li>
<li><strong>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code>
中的上一版本记录</strong>，上一条记录的 <code>DB_TRX_ID</code> 还是
101，不可见</li>
<li>继续找<strong>上一条 <code>DB_TRX_ID</code>为 1</strong>，满足
<strong>1 &lt; m_up_limit_id，可见</strong>，所以事务 103 查询到数据为
<code>name = 菜花</code></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/6fb2b9a1-5f14-4dec-a797-e4cf388ed413.ea9e47d7.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>2. 时间线来到 T6 ，数据的版本链为：</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/528559e9-dae8-4d14-b78d-a5b657c88391.2ff79120.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>因为在 RC 级别下，重新生成 <code>Read View</code>，这时事务
<strong>101 已经提交，102 并未提交</strong>，所以此时
<code>Read View</code> 中活跃的事务
<strong><code>m_ids</code>：[102]</strong>
，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：102，<code>m_creator_trx_id</code>为：103</p>
<ul>
<li>此时最新记录的 <strong><code>DB_TRX_ID</code> 为
102</strong>，m_up_limit_id &lt;= 102 &lt;
m_low_limit_id，所以要<strong>在 <code>m_ids</code>
列表中查找</strong>，发现 <code>DB_TRX_ID</code>
存在列表中，那么这个记录不可见</li>
<li>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code>
中的上一版本记录，<strong>上一条记录的 <code>DB_TRX_ID</code> 为
101，满足 101 &lt; m_up_limit_id</strong>，记录可见，所以在
<code>T6</code> 时间点查询到数据为 <code>name = 李四</code>，与时间 T4
查询到的结果不一致，不可重复读！</li>
</ul>
<p><strong>3. 时间线来到 T9 ，数据的版本链为：</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/6f82703c-36a1-4458-90fe-d7f4edbac71a.c8de5ed7.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>重新生成 <code>Read View</code>， 这时<strong>事务 101 和 102
都已经提交，所以 m_ids 为空</strong>，则 m_up_limit_id = m_low_limit_id
= 104，最新版本事务 ID 为 102，满足 102 &lt;
m_low_limit_id，可见，查询结果为 <code>name = 赵六</code></p>
<blockquote>
<p><strong>总结：</strong> <strong>在 RC
隔离级别下，事务在每次查询开始时都会生成并设置新的 Read
View，所以导致不可重复读</strong></p>
</blockquote>
<h2 id="在rr下readview生成情况">在RR下ReadView生成情况</h2>
<p>在可重复读级别下，只会在事务开始后<strong>第一次读取数据时生成一个
Read View（m_ids 列表）</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/6fb2b9a1-5f14-4dec-a797-e4cf388ed413.ea9e47d7.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>1. 在 T4 情况下的版本链为：</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/0e906b95-c916-4f30-beda-9cb3e49746bf.3a363d10.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>在当前执行 <code>select</code> 语句时生成一个
<code>Read View</code>，此时
<strong><code>m_ids</code>：[101,102]</strong>
，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code>
为：103</p>
<p>此时和 RC 级别下一样：</p>
<ul>
<li>最新记录的 <code>DB_TRX_ID</code> 为 101，m_up_limit_id &lt;= 101
&lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现
<code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</li>
<li>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code>
中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是
101，不可见</li>
<li>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt;
m_up_limit_id，可见，所以事务 103 查询到数据为
<code>name = 菜花</code></li>
</ul>
<p><strong>2. 时间点 T6 情况下：</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/79ed6142-7664-4e0b-9023-cf546586aa39.9c5cd303.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>在 RR 级别下只会生成一次<code>Read View</code>，所以此时依然沿用
<strong><code>m_ids</code> ：[101,102]</strong>
，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code>
为：103</p>
<ul>
<li><strong>最新记录的 <code>DB_TRX_ID</code> 为
102</strong>，m_up_limit_id &lt;= 102 &lt; m_low_limit_id，所以要在
<code>m_ids</code> 列表中查找，<strong>发现 <code>DB_TRX_ID</code>
存在列表中，那么这个记录不可见</strong></li>
<li>根据 <strong><code>DB_ROLL_PTR</code> 找到 <code>undo log</code>
中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 为
101，不可见</strong> 【<strong>从这步开始就跟T4一样了</strong>】</li>
<li>继续根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code>
中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是
101，不可见</li>
<li>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt;
m_up_limit_id，可见，所以事务 103 查询到数据为
<code>name = 菜花</code></li>
</ul>
<p><strong>3. 时间点 T9 情况下：</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/cbbedbc5-0e3c-4711-aafd-7f3d68a4ed4e.7b4a86c0.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>此时情况跟 T6 完全一样，由于已经生成了
<code>Read View</code>，此时依然沿用 <strong><code>m_ids</code>
：[101,102]</strong> ，所以查询结果依然是 <code>name = 菜花</code></p>
<h1 id="mvccnext-key--lock防止幻读">MVCC+Next-key -Lock防止幻读</h1>
<p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和
<code>Next-key Lock</code> 来解决幻读问题：</p>
<p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code>
快照读的方式读取数据</strong></p>
<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成
<code>Read View</code> ，并使用至事务提交。所以在生成
<strong><code>Read View</code>
之后其它事务所做的更新、插入记录版本对当前事务并不可见</strong>，实现了<strong>可重复读</strong>和<strong>防止快照读下的
“幻读”</strong></p>
<p><strong>2、执行 select...for update/lock in share
mode、insert、update、delete 等当前读</strong></p>
<ul>
<li><p>在当前读下，读取的都是<strong>最新</strong>的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！</p></li>
<li><p><code>InnoDB</code> 使用 <a
href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks">Next-key
Lockopen in new window</a>
来防止这种情况。当执行当前读时，会<strong>锁定读取到的记录的同时，锁定它们的间隙</strong>，防止<strong>其它事务在查询范围内插入数据</strong>。只要我<strong>不让你插入，就不会发生幻读</strong></p></li>
</ul>
<blockquote>
<p>Next-Key* Lock(临键锁) 是<strong>Record Lock(记录锁) 和Gap*
Lock(间隙锁)</strong> 的结合</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-database</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL高性能优化规范建议总结</title>
    <url>/2023/01/20/review/java_guide/database/mysql/mysql-high-performance-optimization-specification-recommendations/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="数据库命名规范">数据库命名规范</h1>
<ul>
<li>所有<strong>数据库对象</strong>名称必须使用<strong>小写字母</strong>并用<strong>下划线分割</strong></li>
<li>所有数据库对象名称<strong>禁止使用 MySQL
保留关键字</strong>（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>
<li>数据库对象的命名要能做到<strong>见名识意</strong>，并且最好<strong>不要超过
32 个</strong>字符</li>
<li><strong>临时库表</strong>必须<strong>以 <code>tmp_</code>
为前缀</strong>并以日期为后缀，<strong>备份表</strong>必须<strong>以
<code>bak_</code> 为前缀</strong>并<strong>以日期 (时间戳)
为后缀</strong></li>
<li>所有<strong>存储相同数据的列名和列类型</strong>必须一致（<strong>一般作为关联列</strong>，如果查询时关联列<strong>类型不一致会自动进行数据类型隐式转换</strong>，会<strong>造成列上的索引失效</strong>，导致查询效率降低）</li>
</ul>
<h1 id="数据库基本设计规范">数据库基本设计规范</h1>
<h2 id="所有表必须使用innodb存储引擎">所有表必须使用InnoDB存储引擎</h2>
<ul>
<li>没有特殊要求（即 InnoDB
无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用
InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为
InnoDB）。</li>
<li>InnoDB
支持<strong>事务</strong>，支持<strong>行级锁</strong>，更好的<strong>恢复性</strong>，<strong>高并发</strong>下性能更好</li>
</ul>
<h2
id="数据库和表的字符集统一使用utf-8">数据库和表的字符集统一使用UTF-8</h2>
<p><strong>兼容性</strong>更好，<strong>统一字符集</strong>可以避免由于字符集转换产生的<strong>乱码</strong>，不同的字符集进行比较前需要进行转换会造成<strong>索引失效</strong>，如果数据库中有<strong>存储
emoji 表情</strong>的需要，字符集需要采用 <strong>utf8mb4</strong>
字符集。</p>
<p>参考文章：</p>
<ul>
<li><a
href="https://blog.csdn.net/horses/article/details/107243447">MySQL
字符集不一致导致索引失效的一个真实案例open in new window</a></li>
<li>[MySQL 字符集详解</li>
</ul>
<h2 id="所有表和字段都需要添加注释">所有表和字段都需要添加注释</h2>
<p>使用 <strong>comment
从句添加表</strong>和<strong>列的备注</strong>，从一开始就进行数据字典的维护</p>
<h2
id="尽量控制单表数据量的大小建议控制在500万以内">尽量控制单表数据量的大小，建议控制在500万以内</h2>
<ul>
<li><p>500 万并不是 MySQL
数据库的限制，<strong>过大会造成修改表结构</strong>，<strong>备份</strong>，<strong>恢复</strong>都会有很大的问题。</p></li>
<li><p>可以用<strong>历史数据归档（应用于日志数据）</strong>，<strong>分库分表（应用于业务数据）</strong>等手段来控制数据量大小</p></li>
</ul>
<h2 id="谨慎使用mysql分区表">谨慎使用MySQL分区表</h2>
<ul>
<li><p>分区表在<strong>物理上表现为多个文件</strong>，在<strong>逻辑上表现为一个表</strong>；</p></li>
<li><p>谨慎选择分区键，<strong>跨分区查询效率可能更低</strong>；</p></li>
<li><p>建议采用<strong>物理分表的方式管理大数据</strong>。</p></li>
</ul>
<h2 id="经常一起使用的列放到一个表中">经常一起使用的列放到一个表中</h2>
<p>避免更多的关联操作。</p>
<h2 id="禁止在表中建立预留字段">禁止在表中建立预留字段</h2>
<ul>
<li>预留字段的命名<strong>很难做到见名识义</strong>。</li>
<li>预留字段<strong>无法确认存储的数据类型</strong>，所以<strong>无法选择合适的类型</strong>。</li>
<li><strong>对预留字段类型的修改，会对表进行锁定</strong></li>
</ul>
<h2
id="禁止在数据库中存储文本比如图片这类大的二进制数据">禁止在数据库中存储文本（比如图片）这类大的二进制数据</h2>
<ul>
<li><p>在数据库中存储文件会严重<strong>影响数据库性能</strong>，<strong>消耗过多存储空间</strong>。</p></li>
<li><p>文件（比如图片）这类大的二进制数据<strong>通常存储于文件服务器</strong>，数据库<strong>只存储文件地址信息</strong>。</p></li>
</ul>
<h2 id="不要被数据库范式所束缚">不要被数据库范式所束缚</h2>
<p>一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在<strong>进行查询时需要对多张表进行关联查询</strong>，有时为了<strong>提高查询效率</strong>，会<strong>降低范式的要求</strong>，在表中<strong>保存一定的冗余</strong>信息，也叫做<strong>反范式</strong>。但要注意反范式一定要适度。</p>
<h2 id="禁止在线上做数据库压力测试">禁止在线上做数据库压力测试</h2>
<h2
id="禁止从开发环境测试环境直接连接生产环境数据库">禁止从开发环境、测试环境，直接连接生产环境数据库</h2>
<p><strong>安全隐患极大，要对生产环境抱有敬畏之心！</strong></p>
<h1 id="数据库字段设计规范">数据库字段设计规范</h1>
<h2
id="优先选择符合存储需要的最小数据类型">优先选择符合存储需要的最小数据类型</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230123123412164.png"
alt="image-20230123123412164" />
<figcaption aria-hidden="true">image-20230123123412164</figcaption>
</figure>
<p>存储字节越小，<strong>占用也就空间越小</strong>，<strong>性能也越好</strong>。</p>
<p><strong>a.某些字符串可以转换成数字类型存储比如可以将 IP
地址转换成整型数据。</strong></p>
<p>数字是连续的，性能更好，占用空间也更小。</p>
<p>MySQL 提供了两个方法来<strong>处理 ip 地址</strong></p>
<ul>
<li><code>INET_ATON()</code> ： 把 ip 转为<strong>无符号整型</strong>
(4-8 位)</li>
<li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li>
</ul>
<p>插入数据前，先用 <code>INET_ATON()</code> 把 ip
地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip
地址转为地址显示即可。</p>
<p><strong>b.对于非负型的数据 (如自增 ID,整型 IP，年龄)
来说,要优先使用无符号整型来存储。</strong></p>
<p>无符号相对于有符号可以多出一倍的存储空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SIGNED <span class="type">INT</span> <span class="number">-2147483648</span><span class="operator">~</span><span class="number">2147483647</span></span><br><span class="line">UNSIGNED <span class="type">INT</span> <span class="number">0</span><span class="operator">~</span><span class="number">4294967295</span></span><br></pre></td></tr></table></figure>
<p><strong>c.小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT
类型。</strong></p>
<h2
id="避免使用textblob数据类型最常见的text类型可以存储64k的数据">避免使用TEXT、BLOB数据类型，最常见的TEXT类型可以存储64k的数据</h2>
<p><strong>a. 建议把 BLOB 或是 TEXT
列分离到单独的扩展表中。</strong></p>
<p>MySQL <strong>内存临时表不支持 TEXT、BLOB
这样的大数据类型</strong>，如果查询中包含这样的数据，在<strong>排序</strong>等操作时，就<strong>不能使用内存临时表</strong>，必须<strong>使用磁盘临时表</strong>进行。而且对于这种数据，MySQL
还是要进行<strong>二次查询</strong>，会使 sql
性能变得很差，但是不是说一定不能使用这样的数据类型。</p>
<p>如果一定要使用，建议<strong>把 BLOB 或是 TEXT
列分离到单独的扩展表</strong>中，查询时一定不要使用
<code>select *</code>而<strong>只需要取出必要的列</strong>，<strong>不需要
TEXT 列的数据时不要对该列进行查询</strong>。</p>
<p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p>
<p>因为 <strong>MySQL 对索引字段长度是有限制</strong>的，所以
<strong>TEXT 类型只能使用前缀索引</strong>，并且 <strong>TEXT
列上是不能有默认值</strong>的</p>
<h2 id="避免使用enum类型">避免使用ENUM类型</h2>
<p><strong>原因</strong>：</p>
<ul>
<li>修改 ENUM 值需要使用 <strong>ALTER 语句</strong>；</li>
<li>ENUM 类型的 <strong>ORDER BY
操作效率低</strong>，需要额外操作；</li>
<li>ENUM 数据类型<strong>存在一些限制比如建议不要使用数值作为 ENUM
的枚举值</strong>。</li>
</ul>
<p>相关阅读：<a
href="https://www.zhihu.com/question/404422255/answer/1661698499">是否推荐使用
MySQL 的 enum 类型？ - 架构文摘 - 知乎open in new window</a></p>
<h2 id="尽可能把所有的列定义为not-null">尽可能把所有的列定义为NOT
NULL</h2>
<p>除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。</p>
<ul>
<li><strong>索引 NULL
列需要额外的空间</strong>来保存，所以要占用更多的空间；</li>
<li>进行<strong>比较和计算时要对 NULL 值做特别的处理</strong>。</li>
</ul>
<p>相关阅读：<a
href="https://opensource.actionsky.com/20190710-mysql/">技术分享 | MySQL
默认值选型（是空，还是 NULL）open in new window</a> 。</p>
<h2
id="使用timestamp4个字节或datetime类型8个字节存储时间">使用TIMESTAMP(4个字节)或DATETIME类型（8个字节）存储时间</h2>
<ul>
<li><p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~
2038-01-19-03:14:07</p></li>
<li><p><strong>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT
可读性高</strong></p></li>
<li><p><strong>超出 TIMESTAMP 取值范围的使用 DATETIME
类型</strong>存储</p></li>
</ul>
<p><strong>反之</strong>，
经常会有人用字符串存储日期型的数据<strong>（不正确的做法）</strong></p>
<ul>
<li>缺点
1：<strong>无法用日期函数</strong>进行<strong>计算</strong>和<strong>比较</strong></li>
<li>缺点 2：用<strong>字符串存储日期要占用更多</strong>的空间</li>
</ul>
<h2
id="同财务相关的金额类数据必须使用decimal类型">同财务相关的金额类数据必须使用decimal类型</h2>
<ul>
<li><strong>非精准浮点</strong> ：float,double</li>
<li><strong>精准浮点</strong> ：decimal</li>
</ul>
<p><strong>decimal</strong>
类型为精准浮点数，在<strong>计算时不会丢失精度</strong>。<strong>占用空间由定义的宽度决定</strong>，<strong>每
4 个字节可以存储 9
位数字</strong>，并且<strong>小数点要占用一个字节</strong>。并且，<strong>decimal
可用于存储比 bigint 更大的整型数据</strong></p>
<p>不过， 由于 decimal
需要<strong>额外的空间</strong>和<strong>计算开销</strong>，应该<strong>尽量</strong>只在需要对数据进行<strong>精确计算</strong>时才使用
decimal 。</p>
<h2 id="单表不要包含过多字段">单表不要包含过多字段</h2>
<p>如果一个表包含过多字段的话，可以考虑将其<strong>分解成多个表</strong>，必要时<strong>增加中间表进行关联</strong>。</p>
<h1 id="索引设计规范">索引设计规范</h1>
<h2
id="限制每张表上的索引数量建议单张表索引不超过5个">限制每张表上的索引数量，建议单张表索引不超过5个</h2>
<ul>
<li><p>索引并不是越多越好！索引可以<strong>提高效率</strong>同样可以<strong>降低效率</strong>。</p></li>
<li><p>索引可以增加查询效率，但同样也会<strong>降低插入</strong>和<strong>更新</strong>的效率，甚至有些情况下会<strong>降低查询效率</strong>。</p>
<blockquote>
<p>因为 MySQL
优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会<strong>增加
MySQL
优化器生成执行计划的时间</strong>，同样会<strong>降低查询性能</strong>。</p>
</blockquote></li>
</ul>
<h2 id="禁止使用全文索引">禁止使用全文索引</h2>
<p>全文索引不适用于 OLTP 场景。</p>
<blockquote>
<p>On-Line Transaction
Processing联机事务处理过程(<em>OLTP</em>)，也称为面向交易的处理过程</p>
</blockquote>
<h2
id="禁止给表中的每一列都建立单独的索引">禁止给表中的每一列都建立单独的索引</h2>
<p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6
以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个<strong>联合索引</strong>的查询方式好</p>
<blockquote>
<p>尽量使用<strong>联合索引</strong></p>
</blockquote>
<h2 id="每个innodb表必须有个主键">每个InnoDB表必须有个主键</h2>
<ul>
<li>InnoDB
是一种<strong>索引组织表</strong>：数据的<strong>存储的逻辑顺序</strong>和<strong>索引的顺序</strong>是相同的。每个表都可以有多个索引，但是<strong>表的存储顺序只能有一种</strong>。</li>
<li>InnoDB 是按照<strong>主键索引的顺序</strong>来组织表的
<ul>
<li><strong>不要使用更新频繁的列</strong>作为主键，<strong>不适用多列主键</strong>（相当于联合索引）</li>
<li>不要使用
<strong>UUID,MD5,HASH,字符串</strong>列作为主键（无法保证数据的<strong>顺序增长</strong>）</li>
<li>主键<strong>建议使用自增 ID</strong> 值</li>
</ul></li>
</ul>
<h2 id="常见索引列建议">常见索引列建议</h2>
<ul>
<li><p>出现在 <strong>SELECT、UPDATE、DELETE</strong> 语句的
<strong>WHERE 从句中的列</strong></p></li>
<li><p>包含在 <strong>ORDER BY</strong>、<strong>GROUP
BY</strong>、<strong>DISTINCT</strong> 中的字段</p></li>
<li><p>并不要将符合 1 和 2 中的字段的列都建立一个索引， <strong>通常将
1、2 中的字段建立联合索引</strong>效果更好</p></li>
<li><p><strong>多表 join 的关联列</strong></p></li>
</ul>
<h2 id="如何选择索引列的顺序">如何选择索引列的顺序</h2>
<p>建立<strong>索引的目的</strong>是：希望<strong>通过索引进行数据查找</strong>，<strong>减少随机
IO</strong>，<strong>增加查询性能</strong>
，索引能<strong>过滤出越少</strong>的数据，则<strong>从磁盘中读入的数据也就越少</strong>。</p>
<ul>
<li><strong>区分度最高</strong>的放在联合索引的<strong>最左侧</strong>（区分度=<strong>列中不同值的数量</strong>/列的总行数）</li>
<li>尽量把字段长度小的列放在联合索引的最左侧（因为<strong>字段长度越小</strong>，<strong>一页能存储的数据量越大</strong>，<strong>IO
性能也就越好</strong>）</li>
<li>使用<strong>最频繁的列</strong>放到联合索引的左侧（这样可以比较少的建立一些索引）</li>
</ul>
<h2
id="避免建立冗余索引和重复索引增加了查询优化器生成执行计划的时间">避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h2>
<ul>
<li><strong>重复索</strong>引示例：primary key(id)、index(id)、unique
index(id)</li>
<li><strong>冗余索引</strong>示例：index(a,b,c)、index(a,b)、index(a)</li>
</ul>
<h2
id="对于频繁的查询有优先考虑使用覆盖索引">对于频繁的查询有优先考虑使用覆盖索引</h2>
<blockquote>
<p><strong>覆盖索引</strong>：就是<strong>包含了所有查询字段</strong>
(where,select,order by,group by 包含的字段) 的索引</p>
</blockquote>
<p><strong>覆盖索引的好处：</strong></p>
<ul>
<li><strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB
是以聚集索引的顺序来存储的，对于 InnoDB
来说，<strong>二级索引在叶子节点中所保存的是行的主键信息</strong>，如果是用二级索引查询数据的话，在查找到相应的键值后，<strong>还要通过主键进行二次查询</strong>才能获取我们真实所需要的数据。而在<strong>覆盖索引中，二级索引的键值中可以获取所有的数据</strong>，避免了对主键的二次查询
，减少了 IO 操作，提升了查询效率。</li>
<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong>
由于覆盖索引是<strong>按键值的顺序存储</strong>的，对于 IO
密集型的<strong>范围查找</strong>来说，对比随机从磁盘读取每一行的数据
<strong>IO
要少的多</strong>，因此利用覆盖索引在访问时也可以<strong>把磁盘的随机读取的
IO</strong> 转变成<strong>索引查找的顺序 IO</strong>。</li>
</ul>
<h2 id="索引set规范">索引SET规范</h2>
<p><strong>尽量避免使用外键约束</strong></p>
<ul>
<li><strong>不建议使用外键约束（foreign
key）</strong>，但一定要在表与表之间的<strong>关联键上建立索引</strong></li>
<li>外键可用于<strong>保证数据的参照完整性</strong>，但建议<strong>在业务端实现</strong></li>
<li>外键会<strong>影响父表和子表的写操作</strong>从而降低性能</li>
</ul>
<h1 id="数据库sql开发规范">数据库SQL开发规范</h1>
<h2 id="优化对性能影响较大的sql语句">优化对性能影响较大的SQL语句</h2>
<p>要找到<strong>最需要优化</strong>的 SQL
语句。要么是<strong>使用最频繁</strong>的语句，要么是<strong>优化后提高最明显</strong>的语句，可以通过<strong>查询
MySQL 的慢查询日志</strong>来发现需要进行优化的 SQL 语句；</p>
<h2 id="充分利用表上已经存在的索引">充分利用表上已经存在的索引</h2>
<ul>
<li><p>避免使用双%号的查询条件。如：<code>a like '%123%'</code>，（<strong>如果无前置%,只有后置%，是可以用到列上的索引的</strong>）</p></li>
<li><p>一个 SQL
只能利用到<strong>复合索引中的一列</strong>进行<strong>范围</strong>查询。如：有
a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c
列上的索引将不会被用到。</p>
<blockquote>
<p>https://blog.csdn.net/qq_33589510/article/details/123038988<br />
(a=1 b=1 c=1) (a=1 b=2 c=1) (a=1 b=2 c=3)<br />
(a=2 b=2 c=3) (a=2 b=2 c=5) (a=2 b=5 c=1) (a=2 b=5 c=2)<br />
(a=3 b=0 c=1) (a=3 b=3 c=5) (a=3 b=8 c=6)<br />
假设有一条SQL为<code>select a,b,c from table where a = 2 and b &gt;1 and c = 2</code>，那么索引c就用不到了，因为有可能b查找后c是无序的了</p>
</blockquote></li>
<li><p>在定义联合索引时，如果 a
列要用到<strong>范围查找</strong>的话，就要把 <strong>a
列放到联合索引的右侧</strong>，使用 <strong>left join</strong> 或
<strong>not exists</strong> 来优化 not in 操作，因为 <strong>not in
也通常会使用索引失效</strong>。</p>
<blockquote>
<p>这个的意思是，如果有两个列，b，a都是索引<br />
SELECT * FROM table WHERE a &gt; 1 and b = 2;<br />
对于上面这句，如果建立(a，b)，那么只有a会用得到。而如果建立(b，a)，则都能用上<br />
（<strong>如果没有b= 2，那么（b，a）索引就用不上了</strong>）</p>
</blockquote></li>
</ul>
<h2 id="禁止使用select-必须使用select-查询">禁止使用SELECT *
必须使用SELECT <字段列表> 查询</h2>
<ul>
<li><code>SELECT *</code> 消耗<strong>更多的 CPU</strong> 和
<strong>IO</strong> 以网络带宽资源</li>
<li><code>SELECT *</code> <strong>无法使用覆盖索引</strong></li>
<li><code>SELECT &lt;字段列表&gt;</code>
可<strong>减少表结构变更带来的影响</strong></li>
</ul>
<h2
id="禁止使用不含字段列表的insert语句">禁止使用不含字段列表的INSERT语句</h2>
<p>如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>应使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c1,c2,c3) <span class="keyword">values</span> (<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2
id="建议使用预编译语句进行数据库操作">建议使用预编译语句进行数据库操作</h2>
<p>（这里应该是针对jdbc，不是指mybatis的情况）</p>
<blockquote>
<p>例子：</p>
<ol type="1">
<li><p>MySQL执行预编译分为如三步：</p>
<blockquote>
<ul>
<li><p>执行预编译语句，例如：prepare myfun from 'select * from t_book
where bid=?'</p></li>
<li><p>设置变量，例如：set <span class="citation"
data-cites="str">@str</span>='b1'</p></li>
<li><p>执行语句，例如：execute myfun using <span class="citation"
data-cites="str">@str</span></p></li>
</ul>
<p>如果需要再次执行myfun，那么就不再需要第一步，即不需要再编译语句了：</p>
<ul>
<li>设置变量，例如：set <span class="citation"
data-cites="str">@str</span>='b2'</li>
<li>执行语句，例如：execute myfun using <span class="citation"
data-cites="str">@str</span></li>
</ul>
<p>通过查看MySQL日志可以看到执行的过程：</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/202074104855490.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
</blockquote></li>
<li><p><strong>使用Statement执行预编译</strong><br />
<strong>使用Statement执行预编译就是把上面的SQL语句执行一次。
</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> con.createStatement();</span><br><span class="line">stmt.executeUpdate(<span class="string">&quot;prepare myfun from &#x27;select * from t_book where bid=?&#x27;&quot;</span>);</span><br><span class="line">stmt.executeUpdate(<span class="string">&quot;set @str=&#x27;b1&#x27;&quot;</span>);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;execute myfun using @str&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">  System.out.print(rs.getString(<span class="number">1</span>) + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  System.out.print(rs.getString(<span class="number">2</span>) + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  System.out.print(rs.getString(<span class="number">3</span>) + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  System.out.println(rs.getString(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">stmt.executeUpdate(<span class="string">&quot;set @str=&#x27;b2&#x27;&quot;</span>);</span><br><span class="line">rs = stmt.executeQuery(<span class="string">&quot;execute myfun using @str&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">  System.out.print(rs.getString(<span class="number">1</span>) + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  System.out.print(rs.getString(<span class="number">2</span>) + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  System.out.print(rs.getString(<span class="number">3</span>) + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">  System.out.println(rs.getString(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">rs.close();</span><br><span class="line">stmt.close();</span><br><span class="line">con.close();</span><br></pre></td></tr></table></figure></li>
<li><p>useServerPrepStmts参数<br />
默认使用PreparedStatement是不能执行预编译的，这需要在url中给出useServerPrepStmts=true参数（MySQL
Server
4.1之前的版本是不支持预编译的，而Connector/J在5.0.5以后的版本，默认是没有开启预编译功能的）。</p>
<p>例如：jdbc:mysql://localhost:3306/test?useServerPrepStmts=true</p></li>
</ol>
</blockquote>
<ul>
<li><p>预编译语句可以<strong>重复使用这些计划，减少 SQL
编译所需要的时间</strong>，还可以解决动态 SQL 所带来的 SQL
注入的问题。</p></li>
<li><p><strong>只传参数，比传递 SQL 语句更高效</strong>。</p></li>
<li><p><strong>相同语句可以一次解析，多次使</strong>用，提高处理效率。</p></li>
</ul>
<h2 id="避免数据类型的隐式转换">避免数据类型的隐式转换</h2>
<p>隐式转换会导致索引失效如:
这里id应该不是字符型(<strong>但是这个好像是例外，如果字段是数字，而查询的是字符，索引还是有效的</strong>)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,phone <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="string">&#x27;111&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>详细解读可以看：<a
href="https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html">MySQL
中的隐式转换造成的索引失效</a> 这篇文章</p>
<h2
id="避免使用子查询可以把子查询优化为join操作">避免使用子查询，可以把子查询优化为join操作</h2>
<ul>
<li><p>通常<strong>子查询在 in 子句中</strong>，且<strong>子查询中为简单
SQL</strong>(不包含 union、group by、order by、limit 从句)
时,<strong>才可以把子查询转化为关联查询进行优化</strong>。</p>
<p><strong>子查询性能差的原因：</strong>
子查询的结果集无法使用索引，通常<strong>子查询的结果集会被存储到临时表</strong>中，不论是<strong>内存临时表还是磁盘临时表都不会存在索引</strong>，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会<strong>消耗过多的
CPU 和 IO 资源</strong>，产生大量的慢查询。</p></li>
</ul>
<h2 id="避免join关联太多的表">避免JOIN关联太多的表</h2>
<ul>
<li><p>对于 MySQL
来说，是存在<strong>关联缓存</strong>的，<strong>缓存的大小可以由
join_buffer_size</strong> 参数进行设置。</p></li>
<li><p>在 MySQL 中，对于同一个 SQL
<strong>多关联（join）一个表</strong>，就会<strong>多分配一个关联缓存</strong>，如果在一个
SQL 中关联的表越多，所占用的内存也就越大。</p></li>
<li><p>如果程序中<strong>大量的使用了多表关联</strong>的操作，同时
<strong>join_buffer_size
设置的也不合理</strong>的情况下，就容易造成<strong>服务器内存溢出</strong>的情况，就会<strong>影响到服务器数据库性能的稳定</strong>性。</p></li>
<li><p>同时对于关联操作来说，会产生临时表操作，影响查询效率，<strong>MySQL
最多允许关联 61 个表</strong>，<strong>建议不超过 5
个</strong>。</p></li>
</ul>
<h2 id="减少同数据库的交互次数">减少同数据库的交互次数</h2>
<p>数据库<strong>更适合处理批量</strong>操作，<strong>合并多个相同的操作到一起</strong>，可以提高处理效率。</p>
<h2
id="对应同一列进行or判断时使用in代替or">对应同一列进行or判断时，使用in代替or</h2>
<p>in 的值不要超过 500 个，<strong>in
操作可以更有效的利用索引</strong>，<strong>or
大多数情况下很少能利用到索引</strong>。</p>
<h2 id="禁止使用order-by-rand-进行随机排序">禁止使用order by rand()
进行随机排序</h2>
<ul>
<li><p>order by rand()
会把表中<strong>所有符合条件的数据装载到内存</strong>中，然后<strong>在内存中对所有数据根据随机生成的值进行排序</strong>，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会<strong>消耗大量的
CPU 和 IO 及内存资源</strong>。</p></li>
<li><p>推荐<strong>在程序中获取一个随机值</strong>，然后<strong>从数据库中获取数据</strong>的方式。</p></li>
</ul>
<h2
id="where从句中禁止对列进行函数转换和计算">WHERE从句中禁止对列进行函数转换和计算</h2>
<p><strong>对列进行函数转换或计算</strong>时会导致无法使用索引</p>
<p><strong>不推荐：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="type">date</span>(create_time)<span class="operator">=</span><span class="string">&#x27;20190101&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>推荐：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span> create_time <span class="operator">&gt;=</span> <span class="string">&#x27;20190101&#x27;</span> <span class="keyword">and</span> create_time <span class="operator">&lt;</span> <span class="string">&#x27;20190102&#x27;</span></span><br></pre></td></tr></table></figure>
<h2
id="在明显不会有重复值时使用union-all-而不是-union">在明显不会有重复值时使用UNION
ALL 而不是 UNION</h2>
<ul>
<li>UNION
会把两个结果集的所有数据放到临时表中后<strong>再进行去重</strong>操作</li>
<li><strong>UNION ALL 不会再对结果集进行去重</strong>操作</li>
</ul>
<h2 id="拆分复杂的大sql为多个小sql">拆分复杂的大SQL为多个小SQL</h2>
<ul>
<li><strong>大 SQL 逻辑上比较复杂</strong>，需要<strong>占用大量 CPU
进行计算</strong>的 SQL</li>
<li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li>
<li><strong>SQL 拆分后可以通过并行执行</strong>来提高处理效率</li>
</ul>
<h2
id="程序连接不同的数据库使用不同的账号禁止跨库查询">程序连接不同的数据库使用不同的账号，禁止跨库查询</h2>
<ul>
<li>为数据库<strong>迁移</strong>和<strong>分库分表</strong>留出余地</li>
<li><strong>降低业务耦合度</strong></li>
<li><strong>避免权限过大而产生的安全风险</strong></li>
</ul>
<h1 id="数据库操作行为规范">数据库操作行为规范</h1>
<h2
id="超-100-万行的批量写-updatedeleteinsert-操作要分批多次进行操作">超
100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h2>
<ol type="1">
<li><p><strong>大批量操作可能会造成严重的主从延迟</strong></p>
<p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p></li>
<li><p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p>
<p>大批量写操作会产生大量日志，特别是对于 <strong>row
格式二进制数据</strong>而言，由于在 row
格式中会<strong>记录每一行数据的修</strong>改，我们一次修改的数据越多，产生的日志量也就会越多，<strong>日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟</strong>的一个原因</p></li>
<li><p><strong>避免产生大事务操作</strong></p>
<p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对
MySQL 的性能产生非常大的影响。</p>
<p>特别是<strong>长时间的阻塞会占满所有数据库的可用连接</strong>，这会使<strong>生产环境中的其他应用无法连接到数据库</strong>，因此一定要注意大批量写操作要进行<strong>分批</strong></p></li>
</ol>
<h2 id="对于大表使用-pt-online-schema-change-修改表结构">对于大表使用
pt-online-schema-change 修改表结构</h2>
<ul>
<li>避免<strong>大表修改产生的主从延迟</strong></li>
<li>避免在<strong>对表字段进行修改时进行锁表</strong></li>
</ul>
<p>对<strong>大表数据结构的修改</strong>一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p>
<p><strong>pt-online-schema-change</strong>
它会首先建立一个与原表结构相同的新表，并且<strong>在新表上进行表结构的修改</strong>，然后<strong>再把原表中的数据复制到新表</strong>中，并在<strong>原表中增加一些触发器</strong>。把原表中新增的数据也复制到新表中，在<strong>行所有数据复制完成之后，把新表命名成原表</strong>，并把原来的表删除掉。</p>
<blockquote>
<p>把原来一个 DDL 操作，<strong>分解成多个小的批次</strong>进行。</p>
</blockquote>
<h2 id="禁止为程序使用的账号赋予-super-权限">禁止为程序使用的账号赋予
super 权限</h2>
<ul>
<li>当<strong>达到最大连接数</strong>限制时，<strong>还运行 1 个有 super
权限的用户</strong>连接</li>
<li>super 权限只能<strong>留给 DBA 处理问题的账号</strong>使用</li>
</ul>
<h2
id="对于程序连接数据库账号遵循权限最小原则">对于程序连接数据库账号,遵循权限最小原则</h2>
<ul>
<li><strong>程序使用数据库账号</strong>只能在<strong>一个 DB</strong>
下使用，不准跨库</li>
<li><strong>程序使用的账号</strong>原则上<strong>不准有 drop</strong>
权限</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-database</tag>
      </tags>
  </entry>
  <entry>
    <title>索引</title>
    <url>/2023/01/10/review/java_guide/database/mysql/mysql-index/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="索引介绍">索引介绍</h1>
<ul>
<li><p>索引是一种用于<strong>快速查询</strong>和<strong>检索数据</strong>的数据结构，其本质可以看成是一种<strong>排序好</strong>的数据结构</p>
<blockquote>
<p>索引的作用就相当于书的目录。打个比方:
我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了</p>
</blockquote></li>
<li><p>索引底层数据结构存在很多种类型，常见的索引结构有：<strong>B树</strong>，<strong>B+树</strong>和<strong>Hash</strong>、<strong>红黑树</strong>。在MySQL中，无论是Innodb还是MyIsam，都使用了B+树作为索引结构</p></li>
</ul>
<h1 id="索引的优缺点">索引的优缺点</h1>
<p><strong>优点：</strong></p>
<ul>
<li>使用索引可以大大<strong>加快</strong>
数据的检索速度（大大<strong>减少检索的数据量</strong>）,
这也是创建索引的最主要的原因。</li>
<li>通过创建<strong>唯一性索引</strong>，可以保证数据库表中<strong>每一行数据的唯一性</strong>。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>创建索引</strong>和<strong>维护索引</strong>需要<strong>耗费许多</strong>时间。当对表中的数据进行<strong>增删改</strong>的时候，如果数据有索引，那么<strong>索引也需要动态的修改</strong>，会<strong>降低
SQL 执行效率</strong>。</li>
<li>索引需要使用<strong>物理文件存储</strong>，也会<strong>耗费一定空间</strong></li>
</ul>
<p><strong>索引一定会提高查询性能吗</strong></p>
<ul>
<li>多数情况下，<strong>索引查询</strong>都是比<strong>全表扫描</strong>要快的。但是如果数据库的<strong>数据量不大</strong>，那么使用<strong>索引也不一定能够带来很大提升</strong></li>
</ul>
<h1 id="索引的底层数据结构">索引的底层数据结构</h1>
<h2 id="hash表">Hash表</h2>
<ul>
<li><p>哈希表是键值对的集合，通过<strong>键（key）</strong>即可<strong>快速取出对应的值（value）</strong>，因此哈希表可以<strong>快速检索数据（接近O(1))</strong></p></li>
<li><p>为何能够通过key快速取出value呢？原因在于<strong>哈希算法（也叫散列算法）</strong>。通过哈希算法，我们可以<strong>快速找到key对应的index</strong>，找到了index也就找到了对应的value</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash = hashfunc(key)</span><br><span class="line">index = hash % array_size</span><br></pre></td></tr></table></figure>
<p>注意，图中keys是<strong>字符串</strong>，<strong>不是什么莫名其妙的人</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230111105843993.png"
alt="image-20230111105843993" /></p></li>
<li><p>哈希算法有个 <strong>Hash 冲突</strong>
问题，也就是说<strong>多个不同的 key 最后得到的 index
相同</strong>。通常情况下，我们常用的解决办法是
<strong>链地址法</strong>。链地址法就是<strong>将哈希冲突数据存放在链表中</strong>。就比如
JDK1.8 之前 <code>HashMap</code>
就是通过<strong>链地址法来解决哈希冲突</strong>的。不过，JDK1.8
以后<code>HashMap</code><strong>为了减少链表过长</strong>的时候搜索时间过长引入了<strong>红黑树</strong>。</p></li>
<li><p>为了减<strong>少 Hash
冲突</strong>的发生，一个<strong>好的哈希函数</strong>应该<strong>“均匀地”将数据分布</strong>在整个可能的哈希值集合中</p></li>
<li><p>由于<strong>Hash索引</strong>不支持<strong>顺序</strong>和<strong>范围查询</strong>，假如要对表中的数据进行<strong>排序</strong>或者<strong>进行范围查询</strong>，那<strong>Hash索引</strong>就不行了，并且，<strong>每次IO</strong>只能取一个</p>
<blockquote>
<p>例如： <code>SELECT * FROM tb1 WHERE id &lt; 500 ;</code></p>
<ul>
<li>这种范围查询中，B+树 优势非常大 直接遍历比500小的叶子节点即可</li>
<li>如果使用Hash索引，由于<strong>Hash索引</strong>是根据hash算法来定位的，难不成把1
~499
（小于500）的数据都进行一次hash计算来定位吗？这就是Hash最大的缺点</li>
</ul>
</blockquote></li>
</ul>
<h2 id="b树-b-树">B树&amp; B+ 树</h2>
<ul>
<li><p>B树也称B-树，全称为<strong>多路平衡查找树</strong>，B+树是<strong>B树的一种变体</strong></p></li>
<li><p>B树和B+树中的B是Balanced（平衡）的意思</p></li>
<li><p>目前<strong>大部分数据库</strong>以及<strong>文件系统</strong>都采用B-Tree或者其变种<strong>B+Tree</strong>作为索引结构</p></li>
<li><p>B树&amp;B+树两者有何异同呢</p>
<ol type="1">
<li>B树的所有结点<strong>既存放键（key）</strong>也存放<strong>数据（data）</strong>，而B+树<strong>只有叶子结点</strong>存放key和data，其他<strong>内节点</strong>只存放key</li>
<li>B树的叶子节点都是独立的；B+树的<strong>叶子节点有一条引用链指向与它相邻的叶子节点</strong></li>
<li>B树的检索的过程相当于<strong>对范围内的每个结点的关键字做二分查找</strong>，可能还没有到达叶子节点，检索就结束了。而<strong>B+树</strong>的检索效率比较稳定，任何查找都是从根节点到叶子节点的过程，叶子结点的顺序检索很明显</li>
<li>如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230111144258302.png"
alt="image-20230111144258302" /></li>
</ol></li>
<li><p>在MySQL中，<strong>MyISAM引擎</strong>和<strong>InnoDB引擎</strong>都是使用B+Tree作为索引结构，但是，两者的实现方式有点不太一样</p>
<blockquote>
<ol type="1">
<li>MyISAM 引擎中，<strong>B+Tree 叶节点</strong>的 data
域存放的是<strong>数据记录的地址</strong>。在索引检索的时候，首先<strong>按照
B+Tree 搜索算法</strong>搜索索引，如果指定的 Key 存在，则<strong>取出其
data 域的值</strong>，然后<strong>以 data
域的值为地址读取相应的数据记录</strong>。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</li>
<li>InnoDB 引擎中，其<strong>数据文件本身就是索引文件</strong>。
<strong>MyISAM</strong> 的
索引文件和数据文件是分离的，而<strong>InnoDB引擎</strong>中其表数据文件本身就是按
B+Tree 组织的一个索引结构，<strong>树的叶节点 data
域保存了完整的数据记录</strong>。这个<strong>索引的 key
是数据表的主键（而非地址）</strong>，因此 InnoDB
表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为
<strong>辅助索引</strong> ，辅助索引的 data
域存储相应记录主键的值而不是地址，这也是和 MyISAM
不同的地方。在<strong>根据主索引搜索时，直接找到 key
所在的节点即可取出数据</strong>；在<strong>根据辅助索引查找时</strong>，则<strong>需要先取出主键的值，再走一遍主索引</strong>。</li>
<li>在设计表的时候，<strong>不建议使用过长的字段作为主键</strong>，也<strong>不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂</strong>。<br />
原因：
<ul>
<li>InnoDB的辅助索引data域存储相应记录主键的值而不是地址。所以不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大
<strong>(不建议使用过长的字段作为主键)</strong></li>
<li>InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效。<strong>(不建议使用非单调的字段作为主键)</strong></li>
</ul></li>
</ol>
</blockquote></li>
</ul>
<h1 id="索引类型">索引类型</h1>
<h2 id="主键索引primary-key">主键索引（Primary Key）</h2>
<ul>
<li>数据<strong>表的主键列</strong>，使用的就是<strong>主键索引</strong></li>
<li>一张数据表只能有<strong>一个主键</strong>，并且主键不能为null，不能重复</li>
<li>在 MySQL 的 InnoDB
的表中，当<strong>没有显示的指定表的主键时</strong>，InnoDB
会自动先检查表中<strong>是否有唯一索引</strong>且<strong>不允许存在 null
值</strong>的字段，如果有，则选择该字段为默认的主键，否则 InnoDB
将会自动创建一个 6Byte 的自增主键</li>
<li>如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230111155549265.png"
alt="image-20230111155549265" /></li>
</ul>
<h2 id="二级索引辅助索引">二级索引（辅助索引）</h2>
<ul>
<li>二级索引又称为辅助索引，是因为<strong>二级索引的叶子结点存储的数据是主键</strong>。也就是说，通过二级索引，可以定位<strong>主键</strong>的位置（<strong>还有值</strong>）</li>
<li>唯一索引、普通索引、前缀索引等索引都属于二级索引
<ol type="1">
<li><p><strong>唯一索引 Unique
Key</strong>：是一种约束，该索引的属性列<strong>不能出现重复的数据</strong>，但是<strong>允许数据为NULL</strong>，一张表允许创建<strong>多个唯一索引</strong>。建立唯一索引的目的多是为了<strong>该属性列的数据的唯一性</strong>，而不是为了查询效率</p></li>
<li><p><strong>普通索引
Index</strong>：普通索引的唯一作用就是为了<strong>快速查询</strong>数据，一张表允许创建<strong>多个普通索引</strong>，并允许<strong>数据重复</strong>和<strong>NULL</strong></p></li>
<li><p><strong>前缀索引
Prefix</strong>：前缀索引只适用于<strong>字符串类型</strong>的数据。前缀索引是对<strong>文本的前几个字符创建索引</strong>，相<strong>比普通索引建立的数据更小</strong>，因为<strong>只取前几个</strong>字符</p></li>
<li><p><strong>全文索引Full
Text</strong>：全文索引主要是为了检索<strong>大文本数据中的关键字</strong>的信息，是目前搜索引擎数据库使用的一种技术。</p>
<blockquote>
<p>Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB
也支持了全文索引。</p>
</blockquote></li>
</ol></li>
<li>二级索引： <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230112085212547.png"
alt="image-20230112085212547" /></li>
</ul>
<h1 id="聚簇索引与非聚簇索引">聚簇索引与非聚簇索引</h1>
<h2 id="聚簇索引聚集索引">聚簇索引（聚集索引）</h2>
<ul>
<li>聚簇索引介绍
<ol type="1">
<li>聚簇索引即<strong>索引结构和数据一起存放</strong>的索引，并<strong>不是一种单独的索引类型</strong>。InnoDB中的<strong>主键索引</strong>就属于<strong>聚簇索引</strong></li>
<li>MySQL中<strong>InnoDB引擎的表</strong>的<strong>.ibd
文件</strong>就包含了<strong>该表的索引</strong>和<strong>数据</strong>，对于InnoDB引擎表来说，该表的<strong>索引（B+树）</strong>的<strong>每个非叶子节点存储索引</strong>，叶子结点存储<strong>索引</strong>和<strong>索引对应的数据</strong></li>
</ol></li>
<li>聚簇索引的优缺点
<ul>
<li>优点
<ol type="1">
<li><strong>查询速度非常快</strong>：聚簇索引的<strong>查询速度</strong>非常的<strong>快</strong>，因为<strong>整个B+树</strong>本身就<strong>是一颗多差平衡树</strong>，<strong>叶子节点</strong>也都是<strong>有序</strong>的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引，聚簇索引<strong>少了一次读取数据的IO操作</strong></li>
<li><strong>对排序查找和范围查找优化</strong>：聚簇索引对于逐渐的排序查找和范围查找速度非常快</li>
</ol></li>
<li>缺点
<ol type="1">
<li><strong>依赖于有序的数据</strong>：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在<strong>插入时排序</strong>。如果数据是整型还好，否则<strong>类似于字符串或UUID这种又长有难比较的数据</strong>，<strong>插入</strong>或<strong>查找</strong>的<strong>速度较慢</strong></li>
<li><strong>更新代价大</strong>：如果对<strong>索引列的数据被修改</strong>时，那么<strong>对应的索引也将会被修改</strong>，而且<strong>聚簇索引的叶子节点还存放着数据</strong>，修改代价肯定是较大的，所以对于主键索引来说，<strong>主键一般都是不可被修改</strong>的</li>
</ol></li>
</ul></li>
</ul>
<h2 id="非聚簇索引非聚集索引">非聚簇索引（非聚集索引）</h2>
<p><strong>优点</strong>：</p>
<p><strong>更新代价比聚簇索引要小</strong>。因为<strong>非聚簇索引的叶子节点</strong>是不存放数据的</p>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>依赖于有序数据</strong>：跟聚簇索引一样，非聚簇索引也依赖于有序数据</li>
<li><strong>可能会二次查询（回表）</strong>：这应该是非聚簇索引<strong>最大的缺点</strong>了。
当<strong>查到索引对应的指针或主键</strong>后，可能还需要<strong>根据指针或主键</strong>再<strong>到数据文件或表中查询</strong></li>
</ul>
<p><strong>MySQL的表的文件截图</strong>： <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230113212438093.png"
alt="image-20230113212438093" /></p>
<p><strong>聚簇索引和非聚簇索引</strong>：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230113212558682.png"
alt="image-20230113212558682" /></p>
<p><strong>聚簇索引一定回表查询吗(覆盖索引)</strong></p>
<p><strong>非聚簇索引不一定回表查询</strong></p>
<blockquote>
<p>试想一种情况，用户准备使用 SQL
查询用户名，而用户名字段正好建立了索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;guang19&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>那么这个索引的 key 本身就是 name，查到对应的 name
直接返回就行了，无需回表查询。</p>
<p>即使是 MYISAM 也是这样，虽然 MYISAM
的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！<strong>如果
SQL 查的就是主键呢?</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>主键索引本身的 key
就是主键，查到返回就行了。这种情况就称之为覆盖索引了</p>
</blockquote>
<h1 id="覆盖索引和联合索引">覆盖索引和联合索引</h1>
<h2 id="覆盖索引">覆盖索引</h2>
<ul>
<li><p>如果一个<strong>索引包含（或者说覆盖）所有需要查询的字段的值</strong>，我们就称之为“覆盖索引”。（<strong>也就是不用回表</strong>）</p>
<blockquote>
<p>我们知道在 InnoDB
存储引擎中，如果不是<strong>主键索引（叶子节点存储的是主键+列值）</strong>，最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
</blockquote></li>
<li><p><strong>覆盖索引</strong>即需要<strong>查询的字段正好事索引的字段</strong>，那么直接根据该索引，就可以查到数据了，而无需回表查询</p>
<blockquote>
<p>如主键索引，如果一条 SQL
需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，
那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote></li>
<li><p>我觉得覆盖索引要在联合索引上体现的话功能会比较突出</p></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114170030609.png"
alt="image-20230114170030609" />
<figcaption aria-hidden="true">image-20230114170030609</figcaption>
</figure>
<h2 id="联合索引">联合索引</h2>
<p>使用<strong>表中的多个字段创建索引</strong>，也就是<strong>联合索引</strong>，也叫<strong>组合索引</strong>，或<strong>复合索引</strong></p>
<h2 id="最左前缀匹配原则">最左前缀匹配原则</h2>
<ul>
<li>最左前缀匹配原则指的是，在使用<strong>联合索引</strong>时，<strong>MySQL</strong>
会根据<strong>联合索引中的字段顺序</strong>，<strong>从左到右依次到查询条件中去匹配</strong>，如果查询条件中<strong>存在与联合索引中最左侧字段相匹配</strong>的字段，则就会使用<strong>该字段过滤一批数据</strong>，<strong>直至联合索引中全部字段</strong>匹配完成，或者在<strong>执行过程中遇到范围查询</strong>，如
<strong><code>&gt;</code></strong>、<strong><code>&lt;</code></strong>、<strong><code>between</code></strong>
和 <strong><code>以%开头的like查询</code></strong>
等条件，才会停止匹配。</li>
<li>所以，我们在使用联合索引时，可以将<strong>区分度高的字段放在最左边</strong>，这也可以过滤更多数据</li>
</ul>
<h1 id="索引下推">索引下推</h1>
<p><strong>索引下推（Index Condition Pushdown）</strong> 是
<strong>MySQL 5.6</strong>
版本中提供的一项<strong>索引优化</strong>功能，可以在<strong>非聚簇索引遍历过程</strong>中，对（即<strong>能用索引先用索引</strong>）<strong>索引中包含的字段先做判断</strong>，<strong>过滤掉不符合条件的记录</strong>，减少回表次数。</p>
<blockquote>
<p>例子：<br />
对于<code>SELECT * from user where  name like '陈%' and age=20</code>这条语句<br />
其中主要几个字段有：id、name、age、address。建立联合索引（name，age）</p>
<blockquote>
<p>最关键的一点：
<strong>组合索引满足最左匹配，但是遇到非等值判断时匹配停止。</strong>
<strong>name like '陈%' 不是等值匹配，所以 age = 20 这里就用不上
(name,age) 组合索引了</strong>。如果没有索引下推，组合索引只能用到
name，age 的判定就需要回表才能做了。5.6之后有了索引下推，age = 20
可以直接在组合索引里判定。</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114171107653.png"
alt="image-20230114171107653" />
<figcaption aria-hidden="true">image-20230114171107653</figcaption>
</figure>
<ol type="1">
<li>5.6之前的版本是没有索引下推这个优化的，会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要<strong>回表两次</strong></li>
<li>5.6版本添加了索引下推这个优化 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114171144075.png"
alt="image-20230114171144075" />
InnoDB并没有忽略age这个字段，而是<strong>在索引内部就判断了age是否等于20</strong>，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次</li>
</ol>
</blockquote>
<h1 id="争取使用索引的一些建议">争取使用索引的一些建议</h1>
<h2 id="选择合适的字段创建索引">选择合适的字段创建索引</h2>
<ul>
<li><strong>不为 NULL 的字段</strong>
：索引字段的数据应该<strong>尽量不为
NULL</strong>，因为<strong>对于数据为 NULL
的字段，数据库较难优化</strong>。如果字段频繁被查询，但又避免不了为
NULL，建议使用 0,1,true,false
这样语义较为清晰的<strong>短值或短字符</strong>作为替代。</li>
<li><strong>被频繁查询的字段</strong>
：我们创建索引的字段应该是<strong>查询操作非常频繁</strong>的字段。</li>
<li><strong>被作为条件查询的字段</strong> ：被作为 <strong>WHERE
条件查询的字段</strong>，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong>
：索引已经排序，这样查询可以利用索引的排序，<strong>加快排序查询时间</strong>。</li>
<li><strong>被经常频繁用于连接的字段</strong>
：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列<strong>涉及到表与表的关系</strong>。对于频繁被连接查询的字段，可以考虑建立索引，<strong>提高多表连接查询的效率</strong></li>
</ul>
<h2
id="被频繁更新的字段应该慎重建索引">被频繁更新的字段应该慎重建索引</h2>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。
如果一个字段<strong>不被经常查询，反而被经常修改</strong>，那么就更<strong>不应该</strong>在这种字段上建立索引了。</p>
<h2
id="尽可能地考虑建立联合索引而不是单列索引">尽可能地考虑建立联合索引而不是单列索引</h2>
<p>因为索引是需要占用磁盘空间的，可以简单理解为<strong>每个索引都对应着一颗
B+树</strong>。如果一个表的字段过多，<strong>索引过多</strong>，那么当这个表的数据达到一个体量后，<strong>索引占用的空间也是很多</strong>的，且<strong>修改索引</strong>时，<strong>耗费的时间也是较多</strong>的。如果是联合索引，<strong>多个字段在一个索引上</strong>，那么将会<strong>节约很大磁盘空间</strong>，且<strong>修改数据的操作效率也会提升</strong>。</p>
<h2 id="注意避免冗余索引">注意避免冗余索引</h2>
<ul>
<li><p>冗余索引指的是<strong>索引的功能相同</strong>，能够命中索引(a,
b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引</p>
<blockquote>
<p>（name,city ）和（name
）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的
在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引</p>
</blockquote></li>
</ul>
<h2
id="考虑在字符串类型的字段上使用前缀索引代替普通索引">考虑在字符串类型的字段上使用前缀索引代替普通索引</h2>
<p><strong>前缀索引仅限于字符串</strong>类型，较普通索引会占用更小的空间，所以可以考虑使用<strong>前缀索引带替普通索引</strong>。</p>
<h2 id="避免索引失效">避免索引失效</h2>
<ul>
<li><p>使用 <code>SELECT *</code> 进行查询;</p></li>
<li><p>创建了<strong>组合索引</strong>，但查询条件<strong>未准守最左匹配</strong>原则;</p></li>
<li><p>在索引列上进行计算、函数、类型转换等操作;</p></li>
<li><p>以 % 开头的 LIKE 查询比如 <code>like '%abc';</code>;</p></li>
<li><p>查询条件中使用 or，<strong>且 or
的前后</strong>条件中<strong>有一个列没有索引</strong>，<strong>涉及的索引都不会被使用到</strong>(也就是说，反正都是要全表扫描，所以就不用索引了)</p></li>
</ul>
<h2 id="删除长期未使用的索引">删除长期未使用的索引</h2>
<ul>
<li><p>删除长期未使用的索引，<strong>不用的索引的存在会造成不必要的性能损耗</strong></p></li>
<li><p>MySQL 5.7 可以通过查询 <strong>sys 库的
schema_unused_indexes</strong> 视图来查询哪些索引从未被使用</p></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-database</tag>
      </tags>
  </entry>
  <entry>
    <title>日志</title>
    <url>/2023/01/14/review/java_guide/database/mysql/mysql-logs/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="前言">前言</h1>
<ul>
<li><p>首先要了解一个东西 ：WAL，全称 Write-Ahead
Logging<code>，它的关键点就是</code>先写日志，再写磁盘</p>
<blockquote>
<p>在概念上，innodb通过*<strong>force log at
commit*</strong>机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo
log file和undo log file中进行持久化</p>
</blockquote>
<blockquote>
<ol type="1">
<li><p>WAL
机制的原理也很简单：<strong>修改并不直接写入到数据库文件中，而是写入到另外一个称为
WAL 的文件中；如果事务失败，WAL
中的记录会被忽略，撤销修改；如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改</strong></p></li>
<li><p>使用 WAL 的数据库系统不会再每新增一条 WAL
日志就将其刷入数据库文件中，一般<strong>积累一定的量然后批量写入，通常使用页为单位，这是磁盘的写入单位</strong>。
同步 <strong>WAL 文件和数据库文件的行为被称为
checkpoint（检查点）</strong>，一般在 WAL
文件积累到一定页数修改的时候；当然，有些系统也可以手动执行
checkpoint。执行 checkpoint 之后，WAL 文件可以被清空，这样可以保证 WAL
文件不会因为太大而性能下降。</p>
<p>有些数据库系统读取请求也可以使用 WAL，通过读取 WAL
最新日志就可以获取到数据的最新状态</p>
<blockquote>
<p>关于checkpoint：https://www.cnblogs.com/chenpingzhao/p/5107480.html<strong>思考一下这个场景</strong>：如果重做日志可以无限地增大，同时缓冲池也足够大
，那么是不需要将缓冲池中页的新版本刷新回磁盘。因为当发生宕机时，完全可以通过重做日志来恢复整个数据库系统中的数据到宕机发生的时刻。但是这需要两个前提条件：1、缓冲池可以缓存数据库中所有的数据；2、重做日志可以无限增大</p>
<p>因此Checkpoint（检查点）技术就诞生了，目的是解决以下几个问题：1、<strong>缩短数据库的恢复时间</strong>；2、<strong>缓冲池不够用时，将脏页刷新到磁盘</strong>；3、<strong>重做日志不可用时，刷新脏页</strong>。</p>
<ul>
<li>当数据库发生宕机时，数据库<strong>不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘</strong>。数据库只需对Checkpoint后的重做日志进行恢复，这样就大大缩短了恢复的时间。</li>
<li>当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。</li>
<li>当重做日志出现不可用时，因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大的，重做日志可以被重用的部分是指这些重做日志已经不再需要，当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，因此这部分就可以被覆盖重用。如果重做日志还需要使用，那么必须强制Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。</li>
</ul>
</blockquote></li>
<li><p>mysql 的 WAL，大家可能都比较熟悉。mysql 通过 redo、undo 日志实现
WAL。redo log
称为重做日志，每当有操作时，在<strong>数据变更之前将操作写入 redo
log</strong>，这样当发生掉电之类的情况时系统可以在重启后继续操作。undo
log
称为撤销日志，当一些变更执行到一半无法完成时，可以根据撤销日志恢复到变更之间的状态。mysql
中用 redo log 来在系统 Crash
重启之类的情况时修复数据（事务的持久性），而 undo log
来保证事务的原子性。</p></li>
</ol>
</blockquote></li>
<li><p><code>MySQL</code> 日志
主要包括<strong>错误日志</strong>、<strong>查询日志</strong>、<strong>慢查询日志</strong>、<strong>事务日志</strong>、<strong>二进制日志</strong>几大类</p></li>
<li><p>比较重要的</p>
<ol type="1">
<li>二进制日志： <strong>binlog（归档日志）</strong>【server层】</li>
<li>事务日志：<strong>redo log（重做日志）</strong>和<strong>undo
log（回滚日志）</strong> 【引擎层】</li>
<li>redo log是记录物理上的改变；<br />
undo log是从逻辑上恢复，<strong>产生时机：事务开始之前</strong></li>
<li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong>
保证事务的<strong>持久性</strong>，使用 <strong>undo
log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li>
</ol></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114174517643.png"
alt="image-20230114174517643" />
<figcaption aria-hidden="true">image-20230114174517643</figcaption>
</figure>
<h1 id="redo-log">redo log</h1>
<ul>
<li><p>redo
log（重做日志）是<strong>InnoDB</strong>存储引擎独有的，它让MySQL拥有了<strong>崩溃恢复</strong>的能力</p>
<blockquote>
<p>比如 <code>MySQL</code>
实例<strong>挂了或宕机</strong>了，<strong>重启</strong>时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的<strong>持久性</strong>与<strong>完整性</strong>。</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114185737370.png"
alt="image-20230114185737370" />
<figcaption aria-hidden="true">image-20230114185737370</figcaption>
</figure></li>
</ul>
<ol type="1">
<li><p>MySQL中数据是以<strong>页（这个很重要，重点是针对页）</strong>为单位，你查询一条记录，会<strong>从硬盘把一页的数据加载出来</strong>，加载出来的数据叫<strong>数据页</strong>，会放到<strong>Buffer
Pool</strong>中 (这个时候 如果更新，buffer pool
中的数据页就与磁盘上的数据页<strong>内容不一致</strong>，我们称 buffer
pool 的数据页为 <strong>dirty page 脏数据</strong>)</p>
<blockquote>
<p>以页为单位：<br />
页是InnoDB 管理存储空间的基本单位，一个页的大小一般是16KB
。可以理解为创建一个表时，会创建一个大小为16KB大小的空间，也就是数据页。新增数据时会往该页中User
Records中添加数据，如果页的大小不够使用了继续创建新的页。也就是说一般情况下一次最少从磁盘读取16kb的内容到内存，一次最少把16kb的内容刷新到磁盘中，其作用有点缓存行的意思
原文链接：https://blog.csdn.net/qq_31142237/article/details/125447413</p>
</blockquote>
<blockquote>
<ul>
<li><p>后续的查询都是先从 <code>Buffer Pool</code>
中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code>
开销，提升性能。</p></li>
<li><p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code>
里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新</p></li>
</ul>
</blockquote></li>
<li><p>把“<strong>在某个数据页上做了什么修改</strong>”记录到<strong>重做日志缓存</strong>（<code>redo log buffer</code>）里，接着<strong>刷盘到
<code>redo log</code> 文件</strong>里<br />
即 从 硬盘上db数据文件 --&gt; BufferPool --&gt; redo log buffer --&gt;
redo log <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114190158828.png"
alt="image-20230114190158828" /></p></li>
<li><p>理想情况，事务<strong>一提交就会进行刷盘</strong>操作，但<strong>实际上</strong>，刷盘的时机是<strong>根据策略</strong></p>
<blockquote>
<p>每条redo记录由<strong>”表空间号+数据页号+偏移量+修改数据长度+具体修改的数据“</strong>组成</p>
</blockquote></li>
</ol>
<h2 id="刷盘时机">刷盘时机</h2>
<ul>
<li><p><code>InnoDB</code> 存储<strong>引擎为 <code>redo log</code>
的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code>
参数</strong>，它支持三种策略<br />
<strong>0</strong>：设置为0时，表示每次<strong>事务提交时不进行刷盘</strong>操作<br />
<strong>1</strong>：设置为1时，表示每次<strong>事务提交时都将进行刷盘</strong>操作（默认值）<br />
<strong>2</strong>：设置为2时，表示每次<strong>事务提交时都只把redo log
buffer内容写入page cache(系统缓存)</strong></p></li>
<li><p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1
，也就是说当事务提交时会<strong>调用 <code>fsync</code> 对 redo log
进行刷盘</strong></p></li>
<li><p><code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code>
秒，就会把 <code>redo log buffer</code>
中的内容写到文件系统缓存（<code>page cache</code>），然后调用
<code>fsync</code> 刷盘。(★★重要★★即<strong>没有提交事务的redo
log记录，也有可能会刷盘，因为在事务执行过程 <code>redo log</code>
记录是会写入<code>redo log buffer</code> 中，这些 <code>redo log</code>
记录会被后台线程刷盘。</strong>)</p>
<blockquote>
<p>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当
<code>redo log buffer</code> 占用的空间即将达到
<code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘</p>
</blockquote></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114210732904.png"
alt="image-20230114210732904" />
<figcaption aria-hidden="true">image-20230114210732904</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114211124499.png"
alt="image-20230114211124499" />
<figcaption aria-hidden="true">image-20230114211124499</figcaption>
</figure>
<p><strong>不同刷盘策略的流程图</strong></p>
<ul>
<li><h4
id="innodb_flush_log_at_trx_commit0不对是否刷盘做出处理">innodb_flush_log_at_trx_commit=0（不对是否刷盘做出处理）</h4>
<blockquote>
<p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。<br />
（<strong>由于事务提交成功也不会主动写入page cache，所以即使只有MySQL
挂了，没有宕机，也会丢失。</strong>）</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114211255976.png"
alt="image-20230114211255976" />
<figcaption aria-hidden="true">image-20230114211255976</figcaption>
</figure></li>
<li><h4
id="innodb_flush_log_at_trx_commit1">innodb_flush_log_at_trx_commit=1</h4>
<blockquote>
<p>为<code>1</code>时，
<strong>只要事务提交成功</strong>，<strong><code>redo log</code>记录就一定在硬盘里</strong>，不会有任何数据丢失。如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114211419216.png"
alt="image-20230114211419216" />
<figcaption aria-hidden="true">image-20230114211419216</figcaption>
</figure></li>
<li><h4
id="innodb_flush_log_at_trx_commit2">innodb_flush_log_at_trx_commit=2</h4>
<blockquote>
<ul>
<li><p>为<code>2</code>时，
只要<strong>事务提交成功</strong>，<code>redo log buffer</code>中的内容<strong>只写入文件系统缓存</strong>（<code>page cache</code>）。</p></li>
<li><p>如果仅仅<strong>只是<code>MySQL</code>挂了不会有任何数据丢失</strong>，但是<strong>宕机可能会有<code>1</code>秒数据的丢失</strong>。</p></li>
</ul>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114211535295.png"
alt="image-20230114211535295" />
<figcaption aria-hidden="true">image-20230114211535295</figcaption>
</figure></li>
</ul>
<h2 id="日志文件组">日志文件组</h2>
<ul>
<li><p>硬盘上存储的 <strong><code>redo log</code>
日志文件不只一个</strong>，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的</p>
<blockquote>
<p>比如可以配置为一组<strong><code>4</code>个文件</strong>，<strong>每个</strong>文件的大小是
<strong><code>1GB</code></strong>，整个 <code>redo log</code>
日志文件组可以记录<strong><code>4G</code></strong>的内容</p>
</blockquote></li>
<li><p>它采用的是<strong>环形数组形式</strong>，从头开始写，写到末尾又回到头循环写，如下图所示<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114213913913.png"
alt="image-20230114213913913" /></p></li>
<li><p>在一个<strong>日志文件组</strong>中还有两个重要的属性，分别是
<code>write pos、checkpoint</code></p>
<ol type="1">
<li><strong>write pos</strong>
是<strong>当前记录</strong>的位置，一边写一边后移</li>
<li><strong>checkpoint</strong>
是当前要<strong>擦除</strong>的位置，也是往后推移</li>
</ol>
<p><code>write pos</code> 和 <code>checkpoint</code>
之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录。<br />
<strong>ly: 我的理解是有个缓冲带</strong></p>
<blockquote>
<p>如果 <code>write pos</code> 追上 <code>checkpoint</code> (ly:
没有可以擦除的地方了），表示<strong>日志文件组</strong>满了，这时候不能再写入新的
<code>redo log</code> 记录，<code>MySQL</code>
得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p>
</blockquote></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114214450281.png"
alt="image-20230114214450281" />
<figcaption aria-hidden="true">image-20230114214450281</figcaption>
</figure>
<h2 id="redo-log-小结">redo log 小结</h2>
<blockquote>
<ol type="1">
<li>★★这里有个很重要的问题，就是为什么允许擦除★★<br />
因为redo log记录的是数据页上的修改，如果Buffer
Pool中数据页已经刷磁盘（这里说的磁盘是数据库数据吧）后，那这些记录就失效了，新日志会将这些失效的记录进行覆盖擦除。</li>
<li>redo
log日志满了，在擦除之前，需要确保这些要<strong>被擦除记录对应在内存中的数据页都已经刷到磁盘中</strong>了。擦除旧记录腾出新空间这段期间，是不能再接收新的更新请求的，此刻MySQL的性能会下降。所以在并发量大的情况下，合理调整redo
log的文件大小非常重要。</li>
</ol>
</blockquote>
<p>那为什么要绕这么一圈呢，<strong>只要每次把修改后的数据页直接刷盘不就好了，还有
<code>redo log</code> 什么事？</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230114221955537.png"
alt="image-20230114221955537" />
<figcaption aria-hidden="true">image-20230114221955537</figcaption>
</figure>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> Byte = 8bit</span><br><span class="line"><span class="number">1</span> KB = <span class="number">1024</span> Byte</span><br><span class="line"><span class="number">1</span> MB = <span class="number">1024</span> KB</span><br><span class="line"><span class="number">1</span> GB = <span class="number">1024</span> MB</span><br><span class="line"><span class="number">1</span> TB = <span class="number">1024</span> GB</span><br></pre></td></tr></table></figure>
</blockquote>
<ol type="1">
<li><p>实际上，数据页是16KB，刷盘比较耗时，有时候可能就修改了数据页里的几Byte数据，有必要把完整的数据页刷盘吗</p></li>
<li><p>数据页刷盘是随机写，因为<strong>一个数据页对应的位置可能在硬盘文件的随机位置</strong>，所以性能是很差</p>
<blockquote>
<p>一个数据页对应的位置可能在硬盘文件的随机位置，即1页是16KB，这16KB，可能是在<strong>某个硬盘文件的某个偏移量到某个偏移量之间</strong></p>
</blockquote></li>
<li><p>如果是写 <code>redo log</code>，一行记录可能就占几十
<code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移
量、更新值，再加上是<strong>顺序写</strong>，所以刷盘速度很快。</p>
<blockquote>
<p>其实内存的数据页在一定时机也会刷盘，我们把这称为页合并，讲
<code>Buffer Pool</code>的时候会对这块细说</p>
</blockquote></li>
</ol>
<h1 id="binlog">binlog</h1>
<ul>
<li><p><strong>redo
log</strong>是<strong>物理</strong>日志，记录内容是<strong>“在某个数据页上做了什么修改”</strong>，属于<strong>InnoDB
存储引擎</strong>；而<strong>bin
log</strong>是逻辑日志，记录内容是<strong>语句的原始逻辑</strong>，类似于
“给ID = 2 这一行的 c 字段加1”，属于<strong>MYSQL Server</strong>层</p>
<blockquote>
<p>无论用什么存储引擎，主要<strong>发生了表数据更新</strong>，都会产生于binlog
日志</p>
</blockquote></li>
<li><p>MySQL的数据库的<strong>数据备份</strong>、<strong>主备</strong>、<strong>主主</strong>、<strong>主从</strong>都离不开binlog，需要依靠binlog来<strong>同步数据</strong>，<strong>保证数据一致性</strong>。
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230115212733316.png"
alt="image-20230115212733316" /></p></li>
<li><p>binlog会记录所有<strong>涉及更新数据的逻辑操作</strong>，而且是<strong>顺序写</strong></p></li>
</ul>
<h2 id="记录格式">记录格式</h2>
<ul>
<li><code>binlog</code>
日志有<strong>三种格式</strong>，可以通过<strong><code>binlog_format</code></strong>参数指定。
<ol type="1">
<li><strong>statement</strong></li>
<li><strong>row</strong></li>
<li><strong>mixed</strong></li>
</ol></li>
</ul>
<ol type="1">
<li><p>指定<strong><code>statement</code></strong>，记录的内容是<strong><code>SQL</code>语句原文</strong>，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230115213035257.png"
alt="image-20230115213035257" /></p>
<blockquote>
<p>同步数据时会执行记录的SQL语句，但有个问题，<strong>update_time =
now()
</strong>会获取当前系统时间，直接执行会导致<strong>与原库的数据不一致</strong></p>
</blockquote></li>
<li><p>为了解决上面问题，需要指定<strong>row</strong>，记录的不是简单的SQL语句，还包括<strong>操作的具体数据</strong>，记录内容如下</p>
<blockquote>
<ul>
<li>row格式的记录内容看不到详细信息，需要用<strong>mysqlbinlog</strong>工具解析出来</li>
<li><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、<span
class="citation" data-cites="2">@2</span>、<span class="citation"
data-cites="3">@3</span> 都是该行数据第 1 个~3
个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）</li>
</ul>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230115213231813.png"
alt="image-20230115213231813" />
<figcaption aria-hidden="true">image-20230115213231813</figcaption>
</figure>
<p>这样就能保证同步数据的一致性，通常情况下都是指定row，可以为<strong>数据库的恢复与同步</strong>带来更好的<strong>可靠性</strong></p></li>
<li><p>但是由于row需要更大的容量来记录，比较<strong>占用空间</strong>，<strong>恢复与同步更消耗IO</strong>资源，<strong>影响执行速度</strong>。
折中方案，指定为<strong>mixed</strong>，记录内容为两者混合：MySQL会判断这条SQL语句是否引起数据不一致，如果是就用<strong>row</strong>格式，否则就使用<strong>statement</strong>格式</p></li>
</ol>
<h2 id="写入机制">写入机制</h2>
<ul>
<li><p>binlog的写入时机：<strong>事务执行过程</strong>中，先把日志写到<strong>binlog
cache</strong>，<strong>事务提交的时候（这个很重要，他不像redo
log，binlog只有提交的时候才会刷盘）</strong>，再把<strong>binlog
cache</strong>写到binlog文件中</p>
<blockquote>
<p>因为一个事务的<strong><code>binlog</code>不能被拆开</strong>，无论这个事务多大，也要确保<strong>一次性写入</strong>，所以系统会<strong>给每个线程分配一个块内存作为<code>binlog cache</code></strong></p>
</blockquote></li>
<li><p>我们可以通过<code>binlog_cache_size</code>参数控制<strong>单个线程
binlog cache
大小</strong>，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）：<br />
binlog日志刷盘流程如下<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230115215957574.png"
alt="image-20230115215957574" /></p>
<blockquote>
<ul>
<li>上图的 write，是指把日志写入到文件系统的 <strong>page
cache</strong>，并没有把数据持久化到磁盘，所以速度比较快</li>
<li>上图的
<strong>fsync</strong>，才是<strong>将数据持久化到磁盘</strong>的操作</li>
</ul>
</blockquote></li>
<li><p>write和fsync的时机，由<strong>sync_binlog</strong>控制，默认为0</p>
<ol type="1">
<li><p>为<strong>0</strong>时，表示每次提交的事务都只<strong>write</strong>，由系统自行判断什么时候执行fsync
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230115220404168.png"
alt="image-20230115220404168" /></p>
<blockquote>
<p>虽然性能会提升，但是如果机器宕机，<strong>page
cache</strong>里面的binlog会<strong>丢失</strong></p>
</blockquote></li>
<li><p>设置为<strong>1</strong>，表示<strong>每次提交事务</strong>都会fsync
，就如同<strong>redo log日志刷盘流程</strong> 一样</p></li>
<li><p>折中，可以设置为<strong>N(N&gt;1)</strong>，表示每次提交事物都write，但累积<strong>N</strong>个事务之后才<strong>fsync</strong><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230115220338819.png"
alt="image-20230115220338819" />
在出现<strong>IO</strong>瓶颈的场景里，将<strong>sync_binlog</strong>设置成一个较大的值，可以<strong>提升性能</strong><br />
同理，如果机器宕机，会<strong>丢失最近N个事务的binlog日志</strong></p></li>
</ol></li>
</ul>
<h1 id="两阶段提交">两阶段提交</h1>
<ol type="1">
<li><strong>redo
log（重做日志）</strong>让InnoDB存储引擎拥有了<strong>崩溃恢复</strong>的能力</li>
<li><strong>binlog（归档日志）</strong>保证了MySQL<strong>集群架构的数据一致性</strong></li>
</ol>
<p>两者都属于<strong>持久性</strong>的保证，但<strong>侧重点不同</strong></p>
<ul>
<li><p>更新语句过程，会记录<strong>redo
log</strong>和<strong>binlog</strong>两块日志，以基本的事务为单位</p></li>
<li><p><strong>redo
log</strong>在事务执行过程中可以<strong>不断地写入</strong>，而<strong>binlog</strong>只有在<strong>提交事务时</strong>才写入，所以<strong>redo
log</strong>和<strong>binlog</strong>写入时机不一样</p></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230115221716772.png"
alt="image-20230115221716772" />
<figcaption aria-hidden="true">image-20230115221716772</figcaption>
</figure>
<p><strong>redo log</strong>与<strong>binlog</strong>
两份日志之间的逻辑不一样，会出现什么问题？</p>
<ul>
<li><p>以<code>update</code>语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段<code>c</code>值更新成<code>1</code>，<code>SQL</code>语句为<code>update T set c=1 where id= 2</code></p></li>
<li><p>假设执行过程中<strong>写完redo
log</strong>日志后，<strong>binlog日志写期间发生了异常</strong>，会出现什么情况
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230115222416227.png"
alt="image-20230115222416227" /></p>
<blockquote>
<p>由于<code>binlog</code>没写完就异常，这时候<strong><code>binlog</code>里面没有对应的修改记录</strong>。因此，之后用<strong><code>binlog</code>日志恢复数据</strong>时，就会少这一次更新，恢复出来的这一行<code>c</code>值是<code>0</code>，而<strong>原库因为<code>redo log</code>日志恢复，这一行<code>c</code>值是<code>1</code>，最终数据不一致</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/03-20220305235104445.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
</blockquote></li>
<li><p>为了解决<strong>两份日志之间的逻辑一致</strong>问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案
即将redo
log的写入拆成了两个步骤<strong>prepare</strong>和<strong>commit</strong>，这就是<strong>两阶段提交</strong>（<strong>其实就是等binlog正式写入后redo
log才正式提交</strong>） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230115222722278.png"
alt="image-20230115222722278" /></p>
<blockquote>
<p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<strong><code>MySQL</code>根据<code>redo log</code>日志恢复数据</strong>时，<strong>发现<code>redo log</code>还处于<code>prepare</code>阶段（也就是下图的<code>非commit阶段</code>）</strong>，并且<strong>没有对应<code>binlog</code>日志</strong>，就会<strong>回滚该事务</strong>。</p>
<p>其实下图中，<strong>是否存在对应的binlog</strong>，就是想知道<strong>binlog是否是完整的</strong>，如果完整的话
redolog就可以提交
（箭头前面<strong>是否commit阶段</strong>，是的话就表示binlog写入期间没有出错，即binlog完整）
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230115222906325.png"
alt="image-20230115222906325" /></p>
<p>还有个问题，<strong><code>redo log</code>设置<code>commit</code>阶段发生异常</strong>，那会不会回滚事务呢？<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230115223656461.png"
alt="image-20230115223656461" /></p>
<blockquote>
<p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是<strong>能通过事务<code>id</code>找到对应的<code>binlog</code>日志</strong>，所以<strong><code>MySQL</code>认为(binlog)是完整的</strong>，就会<strong>提交事务恢复数据</strong>。</p>
</blockquote>
</blockquote></li>
</ul>
<h1 id="undo-log">undo log</h1>
<ul>
<li>如果想要保证<strong>事务的原子性</strong>，就需要在<strong>异常发生</strong>时，对已经执行的操作进行<strong>回滚</strong>，在
MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong>
实现的，<strong>所有事务进行的修改都会先记录到这个回滚日志</strong>中，<strong>然后再执行相关的操作</strong></li>
<li>如果<strong>执行过程中遇到异常</strong>的话，我们直接利用
<strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！</li>
<li>回滚日志会<strong>先于数据（数据库数据）持久化到磁盘</strong>上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还<strong>能够通过查询回滚日志来回滚将之前未完成的事务</strong>。</li>
</ul>
<p>关于undo log：</p>
<blockquote>
<p>参考https://blog.csdn.net/Weixiaohuai/article/details/117867353</p>
<ol type="1">
<li><p>undo
log是<strong>逻辑日志</strong>，而且记录的是<strong>相反的语句</strong></p></li>
<li><p>undo
log日志里面不仅存放着数据更新前的记录，还记录着RowID、事务ID、回滚指针。其中事务ID每次递增，回滚指针第一次如果是insert语句的话，回滚指针为NULL<strong>，第二次update之后的undo
log的回滚指针就会指向刚刚那一条undo
log日志</strong>，依次类推，就会形成一条undo
log的回滚链，方便找到该条记录的历史版本</p></li>
<li><p><strong>更新数据之前</strong>，MySQL会<strong>提前生成undo
log日志</strong>，当事务提交的时候，并不会立即删除undo
log，因为后面可能需要进行回滚操作，要执行回滚（rollback）操作时，从缓存中读取数据。undo
log日志的删除是通过通过后台purge线程进行回收处理的。</p></li>
<li><p>举例</p>
<blockquote>
<p>假设有A、B两个数据，值分别为1,2。</p>
<p>A. 事务开始<br />
B. 记录A=1到undo log中<br />
C. 修改A=3<br />
D. 记录B=2到undo log中<br />
E. 修改B=4<br />
F. 将undo log写到磁盘 -------undo log持久化<br />
G. 将数据写到磁盘 -------数据持久化<br />
H. 事务提交 -------提交事务</p>
</blockquote></li>
<li><p>由于以下特点，所以能保证原子性和持久化</p>
<ol type="1">
<li>更新数据前记录undo log。<br />
</li>
<li>为了保证持久性，必须将数据在事务提交前写到磁盘，只要事务成功提交，数据必然已经持久化到磁盘。</li>
<li><strong>undo
log必须先于数据持久化到磁盘</strong>。如果在G,H之间发生系统崩溃，undo
log是完整的，可以用来回滚。</li>
<li>如果在A -
F之间发生系统崩溃，因为数据没有持久化到磁盘，所以磁盘上的数据还是保持在事务开始前的状态。</li>
</ol></li>
</ol>
</blockquote>
<blockquote>
<p>参考https://developer.aliyun.com/article/1009683</p>
<p>https://www.cnblogs.com/defectfixer/p/15835714.html</p>
<p><strong>MySQL 的 InnoDB 存储引擎使用“Write-Ahead
Log”日志方案实现本地事务的原子性、持久性。</strong></p>
<p><strong>“提前写入”（Write-Ahead），就是在事务提交之前，允许将变动数据写入磁盘。与“提前写入”相反的就是，在事务提交之前，不允许将变动数据写入磁盘，而是等到事务提交之后再写入。</strong></p>
<p><strong>“提前写入”的好处是：有利于利用空闲 I/O
资源。但“提前写入”同时也引入了新的问题：在事务提交之前就有部分变动数据被写入磁盘，那么如果事务要回滚，或者发生了崩溃，这些提前写入的变动数据就都成了错误。“Write-Ahead
Log”日志方案给出的解决办法是：增加了一种被称为 Undo Log
的日志，用于进行事务回滚。</strong></p>
<p><strong>变动数据写入磁盘前，必须先记录 Undo Log，Undo Log
中存储了回滚需要的数据。在事务回滚或者崩溃恢复时，根据 Undo Log
中的信息对提前写入的数据变动进行擦除。</strong></p>
<h2
id="更新一条语句的执行过程ly根据多方资料验证这个是对的事务提交前并不会持久化到db磁盘数据库文件中">更新一条语句的执行过程(ly:根据多方资料验证，这个是对的，事务提交前并不会持久化到db磁盘数据库文件中)</h2>
<blockquote>
<p>回答题主的问题，对MySQL数据库来说，事务提交之前，操作的数据存储在数据库在内存区域中的缓冲池中，即写的是内存缓冲池中的页(page
cache)，同时会在缓冲池中写undolog(用于回滚)和redolog、binlog(用于故障恢复，保证数据持久化的一致性)，事务提交后，有数据变更的页，即脏页，会被持久化到物理磁盘。</p>
<p>作者：王同学
链接：https://www.zhihu.com/question/278643174/answer/1998207141
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>执行后的几个步骤</p>
<ol type="1">
<li><strong>事务开始</strong></li>
<li>申请加锁：表锁、MDL 锁、行锁、索引区间锁（看情况加哪几种锁）</li>
<li><strong>执行器找存储引擎</strong>取数据。</li>
<li><ol type="1">
<li>如果记录所在的数据页本来就在内存（innodb_buffer_cache）中，存储引擎就直接返回给执行器；</li>
<li>否则，存储引擎需要先将该数据页<strong>从磁盘读取到内存</strong>，然后再返回给执行器。</li>
</ol></li>
<li><strong>执行器拿到存储引擎给的行数据</strong>，<strong>进行更新</strong>操作后，<strong>再调用存储引擎接口写入这行新数据(6
- 9)</strong>。</li>
<li>存储引擎将回滚需要的数据记录到 Undo Log，并将这个更新操作记录到 Redo
Log，此时 Redo Log 处于 prepare
状态。并将这行新数据更新到内存（innodb_buffer_cache）中。同时，然后告知执行器执行完成了，随时可以提交事务。</li>
<li><strong>手动事务 commit</strong>：执行器生成这个操作的 Binary
Log，并把 Binary Log 写入磁盘。</li>
<li>执行器调用存储引擎的提交事务接口，存储引擎把刚刚写入的 Redo Log 改成
commit 状态。</li>
<li><strong>事务结束</strong></li>
</ol>
</blockquote>
<h2 id="mvcc">MVCC</h2>
<ul>
<li><p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo
log</strong>。</p></li>
<li><p>内部实现中，<code>InnoDB</code> 通过数据行的
<strong><code>DB_TRX_ID</code></strong> 和
<strong><code>Read View</code></strong>
来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code>
找到 <code>undo log</code> 中的历史版本。</p>
<blockquote>
<p>每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建
<code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>
</blockquote></li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong>
保证事务的<strong>持久性</strong>，使用 <strong>undo
log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li>
<li><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</li>
<li>三大日志大概的流程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230116002657069.png"
alt="image-20230116002657069" /></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-database</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常见面试题总结</title>
    <url>/2023/01/20/review/java_guide/database/mysql/mysql-questions-01/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!====</p>
</blockquote>
<h1 id="mysql基础">MySQL基础</h1>
<h2 id="关系型数据库介绍">关系型数据库介绍</h2>
<ul>
<li><strong>关系型数据库</strong>，建立在<strong>关系模型</strong>的基础上的数据库。表明数据库中所<strong>存储</strong>的数据之间的<strong>联系</strong>（一对一、一对多、多对多）</li>
<li>关系型数据库中，我们的数据都被<strong>存放在各种表</strong>中（比如用户表），表中的<strong>每一行</strong>存放着<strong>一条数据（比如一个用户的信息）</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png"
alt="关系型数据库表关系" /></li>
<li>大部分关系型数据库都使用<strong>SQL</strong>来操作数据库中的数据，并且大部分<strong>关系型数据库</strong>都支持<strong>事务</strong>的<strong>四大特性（ACID）</strong></li>
</ul>
<p><strong>常见的关系型数据库</strong><br />
<strong>MySQL</strong>、<strong>PostgreSQL</strong>、<strong>Oracle</strong>、<strong>SQL
Server</strong>、<strong>SQLite</strong>（<strong>微信本地的聊天记录</strong>的存储就是用的
SQLite） ......</p>
<h2 id="mysql介绍">MySQL介绍</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/20210327143351823.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li><p>MySQL是一种<strong>关系型数据库</strong>，主要用于<strong>持久化存储</strong>我们系统中的一些数据比如<strong>用户信息</strong></p></li>
<li><p>由于 MySQL
是<strong>开源</strong>免费并且比较<strong>成熟</strong>的数据库，因此，MySQL
被大量使用在各种系统中。任何人都可以在 <strong>GPL(General Public
License 通用性公开许可证)</strong>
的许可下下载并根据<strong>个性化的需要</strong>对其进行<strong>修改</strong>。MySQL
的默认端口号是<strong>3306</strong>。</p></li>
</ul>
<h1 id="mysql基础架构">MySQL基础架构</h1>
<ul>
<li>MySQL的一个<strong>简要机构图</strong>，客户端的一条<strong>SQL语句</strong>在MySQL内部如何执行
<img
src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/13526879-3037b144ed09eb88.png"
alt="img" /></li>
<li>MySQL主要由几部门构成
<ol type="1">
<li><strong>连接器</strong>：<strong>身份认证</strong>和<strong>权限相关</strong>（登录MySQL的时候）</li>
<li><strong>查询缓存</strong>：执行<strong>查询</strong>语句的时候，会先<strong>查询缓存</strong>（MySQL8.0版本后<strong>移除</strong>，因为这个功能不太实用）</li>
<li><strong>分析器</strong>：<strong>没有命中缓存</strong>的话，SQL语句就会经过分析器，分析器说白了就是要先看你的SQL语句<strong>要干嘛</strong>，再检查你的<strong>SQL语句语法</strong>是否正确</li>
<li><strong>优化器</strong>：按照<strong>MySQL认为最优的方案</strong>去执行</li>
<li><strong>执行器</strong>：<strong>执行</strong>语句，然后从<strong>存储引擎返回</strong>数据。执行语句之前会<strong>先判断是否有权限</strong>，如果没有权限，就会报错</li>
<li><strong>插件式存储引擎</strong>：主要负责<strong>数据</strong>的<strong>存储</strong>和<strong>读取</strong>，采用的是<strong>插件式架构</strong>，支持<strong>InnoDB</strong>、<strong>MyISAM</strong>、<strong>Memory</strong>等多种存储引擎</li>
</ol></li>
</ul>
<h1 id="mysql存储引擎">MySQL存储引擎</h1>
<p>MySQL<strong>核心</strong>在于<strong>存储引擎</strong></p>
<h2
id="mysql支持哪些存储引擎默认使用哪个">MySQL支持哪些存储引擎？默认使用哪个？</h2>
<ul>
<li><p>MySQL支持<strong>多种存储引擎</strong>，可以通过<code>show engines</code>命令来<strong>查看MySQL支持的所有存储引擎</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510105408703.png"
alt="查看 MySQL 提供的所有存储引擎" /></p></li>
<li><p><strong>默认</strong>存储引擎为InnoDB，并且，所有存储引擎中<strong>只有InnoDB是事务性存储引擎</strong>，也就是说<strong>只有InnoDB支持事务</strong></p></li>
<li><p><strong>这里使用MySQL 8.x</strong> MySQL
5.5.5之前，MyISAM是MySQL的默认存储引擎；5.5.5之后，InnoDB是MySQL的默认存储疫情，可以通过<code>select version()</code>命令查看你的MySQL版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+-----------+</span><br><span class="line">| version() |</span><br><span class="line">+-----------+</span><br><span class="line">| 8.0.27    |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec) </span><br></pre></td></tr></table></figure>
<p>使用<code>show variables like %storage_engine%</code>命令直接查看MySQL<strong>当前默认的存储引擎</strong><br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510105837786.png"
alt="查看 MySQL 当前默认的存储引擎" /></p>
<p>如果只想<strong>查看数据库中某个表使用的存储引擎</strong>的话，可以使用<code>show table status from db_name where name = 'table_name'</code>命令<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510110549140.png"
alt="查看表的存储引擎" /></p></li>
</ul>
<blockquote>
<p>如果你想要深入了解每个存储引擎以及它们之间的区别，推荐你去阅读以下
MySQL 官方文档对应的介绍(面试不会问这么细，了解即可)：</p>
<ul>
<li>InnoDB
存储引擎详细介绍：https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html
。</li>
<li>其他存储引擎详细介绍：https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html
。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510155143458.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
</blockquote>
<h2 id="mysql存储引擎架构了解吗">MySQL存储引擎架构了解吗？</h2>
<ul>
<li>MySQL
存储引擎采用的是<strong>插件式架构</strong>，支持<strong>多种存储引擎</strong>，我们甚至可以<strong>为不同的数据库表设置不同的存储引擎</strong>以<strong>适应不同场景的需要</strong>。存储引擎是<strong>基于表</strong>的，<strong>而不是数据库</strong></li>
<li>可以<strong>根据 MySQL
定义的存储引擎实现标准接口</strong>来编写一个<strong>属于自己的存储引擎</strong>。这些<strong>非官方提供的存储引擎</strong>可以称为<strong>第三方存储引擎</strong>，<strong>区别于官方存储引擎</strong></li>
</ul>
<blockquote>
<p>像目前最常用的 InnoDB
其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle
直接收购了。</p>
<p>MySQL
官方文档也有介绍到如何编写一个自定义存储引擎，地址：https://dev.mysql.com/doc/internals/en/custom-engine.html</p>
</blockquote>
<h2 id="myisam和innodb的区别是什么">MyISAM和InnoDB的区别是什么？</h2>
<ul>
<li>ISAM全称：<strong>Indexed Sequential Access Method</strong>(索引
顺序 访问 方法)</li>
<li>虽然，MyISAM
的性能还行，各种特性也还不错（比如<strong>全文索引</strong>、<strong>压缩</strong>、<strong>空间函数</strong>等）。但是，<strong>MyISAM
不支持事务</strong>和<strong>行级锁</strong>，而且最大的缺陷就是<strong>崩溃后无法安全恢复</strong></li>
</ul>
<ol type="1">
<li><p><strong>是否支持行级锁</strong> <strong>MyISAM</strong>
只有<strong>表级锁(table-level locking)</strong>，而
<strong>InnoDB</strong> 支持<strong>行级锁(row-level
locking)</strong>和<strong>表级锁</strong>,<strong>默认为行级锁</strong>。</p>
<blockquote>
<p>MyISAM
一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么
InnoDB 在并发写的时候，性能更牛皮了！</p>
</blockquote></li>
<li><p><strong>是否支持事务</strong></p>
<p>MyISAM不支持事务，InnoDB提供事务支持</p>
<ul>
<li>InnoDB实现了SQL标准，定义了<strong>四个隔离级别</strong>，具有<strong>提交（commit）</strong>和<strong>回滚（rollback）事务</strong>的能力</li>
<li>InnoDB默认使用的<strong>REPEATABLE-READ(可重复读)</strong>隔离级别是可以解决<strong>幻读问题发生的（部分幻读）</strong>，基于<strong>MVCC</strong>和<strong>Next-Key
Lock（间隙锁）</strong></li>
</ul>
<p>详细可以查看<strong>MySQL 事务隔离级别详解</strong></p></li>
<li><p><strong>是否支持外键</strong></p>
<p>MyISAM不支持，而InnoDB支持</p>
<blockquote>
<p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p>
<p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220510090309427.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定</p>
</blockquote>
<ul>
<li>一般我们也是<strong>不建议在数据库层面使用外键</strong>的，<strong>应用层面可以解决</strong>。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定</li>
</ul></li>
<li><p><strong>是否支持数据库异常崩溃后的安全恢复</strong> MyISAM
不支持，而 InnoDB 支持。</p>
<ul>
<li>使用 InnoDB
的数据库在异常崩溃后，数据库重新启动的时候会<strong>保证数据库恢复到崩溃前的状态</strong>。这个<strong>恢复的过程依赖于
<code>redo log</code></strong></li>
</ul></li>
<li><p><strong>是否支持MVCC</strong> MyISAM 不支持，而 InnoDB 支持。</p>
<ul>
<li>MyISAM 连行级锁都不支持。<strong>MVCC
可以看作是行级锁的一个升级</strong>，可以有效<strong>减少加锁</strong>操作，<strong>提高性能</strong>。</li>
</ul></li>
<li><p><strong>索引实现不一样</strong></p>
<ul>
<li>虽然 <strong>MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree</strong>
作为索引结构，但是两者的<strong>实现方式不太一样</strong>。</li>
<li>InnoDB 引擎中，其<strong>数据文件本身就是索引文件</strong>。而
<strong>MyISAM中，索引文件和数据文件是分离</strong>的</li>
<li>InnoDB引擎中，表数据文件本身就是按 B+Tree
组织的一个索引结构，<strong>树的叶节点 data
域保存了完整的数据记录</strong>。</li>
</ul></li>
</ol>
<p>详细区别，推荐 ： MySQL 索引详解</p>
<h2 id="myisam和innodb-如何选择">MyISAM和InnoDB 如何选择</h2>
<ul>
<li><p>大多数时候我们使用的都是 <strong>InnoDB
存储引擎</strong>，在某些<strong>读密集的情况</strong>下，使用 MyISAM
也是合适的。不过，前提是你的项目<strong>不介意 MyISAM
不支持事务</strong>、<strong>崩溃恢复等缺点</strong>（可是~我们一般都会介意啊！）</p></li>
<li><p>《MySQL 高性能》上面有一句话这样写到:</p>
<blockquote>
<p>不要轻易相信“MyISAM 比 InnoDB
快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB
的速度都可以让 MyISAM
望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p>
</blockquote></li>
<li><p>一般情况下我们选择 InnoDB
都是没有问题的，但是某些情况下你并不在乎<strong>可扩展能力</strong>和<strong>并发能力</strong>，也不需要<strong>事务支持</strong>，也不在乎<strong>崩溃后的安全恢复问题</strong>的话，选择
MyISAM
也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p></li>
<li><p>对于咱们日常开发的业务系统来说，你几乎<strong>找不到什么理由再使用
MyISAM</strong> 作为自己的 MySQL 数据库的存储引擎</p></li>
</ul>
<h1 id="mysql-索引">MySQL 索引</h1>
<p>MySQL
索引相关的问题比较多，对于面试和工作都比较重要，于是，我<strong>单独抽了一篇文章</strong>专门来总结
MySQL 索引相关的知识点和问题： MySQL 索引详解]</p>
<h1 id="mysql查询缓存">MySQL查询缓存</h1>
<p>执行查询语句的时候，会<strong>先查询缓存</strong>。不过<strong>，MySQL
8.0 版本后移除</strong>，因为这个功能不太实用</p>
<ul>
<li><p><code>my.cnf</code> 加入以下配置，重启 MySQL
<strong>开启查询缓存</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">query_cache_type</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">query_cache_size</span>=<span class="string">600000</span></span><br></pre></td></tr></table></figure></li>
<li><p>执行以下命令也可以<strong>开启查询缓存</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global  query_cache_type=1;</span><br><span class="line">set global  query_cache_size=600000;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>：</p>
<blockquote>
<p>查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息</p>
</blockquote>
<p><strong>查询缓存不命中的情况</strong>：</p>
<ol type="1">
<li>任何两个查询在<strong>任何字符上的不同</strong>都会导致缓存不命中</li>
<li>如果查询中包含任何<strong>用户自定义函数</strong>、<strong>存储函数</strong>、<strong>用户变量</strong>、<strong>临时表</strong>、<strong>MySQL
库中的系统表</strong>，其查询结果也不会被缓存</li>
<li><strong>缓存建立之后</strong>，MySQL
的<strong>查询缓存系统会跟踪查询中涉及的每张表</strong>，如果<strong>这些表（数据或结构）发生变化</strong>，那么和这张表相关的所有缓存数据都将失效</li>
</ol>
<p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong>
因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十
MB 比较合适。此外，**还可以通过 sql_cache 和 sql_no_cache
来控制某个查询语句是否需要缓存</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sql_no_cache <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> usr;</span><br></pre></td></tr></table></figure>
<h1 id="mysql事务">MySQL事务</h1>
<h2 id="何谓事务">何谓事务</h2>
<blockquote>
<p>我们设想一个场景，这个场景中我们需要插入<strong>多条相关联</strong>的数据到数据库，不幸的是，这个<strong>过程</strong>可能会遇到下面这些问题：</p>
<ul>
<li>数据库中途突然因为某些原因挂掉了。</li>
<li>客户端突然因为网络原因连接不上数据库了。</li>
<li>并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。</li>
<li>......</li>
</ul>
<p>上面的任何一个问题都可能会<strong>导致数据的不一致性</strong>。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的<strong>首选机制</strong>。<strong>事务的概念起源于数据库</strong>，目前，已经成为一个比较广泛的概念</p>
</blockquote>
<ul>
<li><p>事务是<strong>逻辑上的一组操作</strong>，要么<strong>都执行</strong>，要么<strong>都不执行</strong></p></li>
<li><p>最经典的就是<strong>转账</strong>，假如小明要给小红转账1000元，这个转账涉及到<strong>两个关键操作</strong>，这两个操作必须<strong>都成功</strong>或者<strong>都失败</strong></p>
<ol type="1">
<li>将小明的余额减少1000元</li>
<li>将小红的余额增加1000元</li>
</ol>
<p>事务会把两个操作看成<strong>逻辑上的一个整体</strong>，这个整体包含的操作<strong>要么都成功</strong>，<strong>要么都失败</strong>。这样就不会出现<strong>小明余额减少</strong>而<strong>小红余额却没有增加</strong>的情况<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230122204340552.png"
alt="image-20230122204340552" /></p></li>
</ul>
<h2 id="何谓数据库事务">何谓数据库事务</h2>
<ul>
<li><p>多数情况下，我们谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的是<strong>数据库事务</strong></p></li>
<li><p><strong>数据库事务</strong>在日常开发中<strong>接触最多</strong>，如果项目属于<strong>单体架构</strong>，接触的往往就是<strong>数据库事务</strong></p></li>
<li><p>数据库事务的作用<br />
可以保证<strong>多个对数据库的操作（也就是SQL语句）构成一个逻辑上的整体</strong>，构成这个逻辑上整体的这些数据库操作遵循：<strong>要么全部执行成功，要么全部不执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启一个事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line"># 多条 SQL 语句</span><br><span class="line">SQL1,SQL2...</span><br><span class="line">## 提交事务</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230122210451626.png"
alt="image-20230122210451626" />
<figcaption aria-hidden="true">image-20230122210451626</figcaption>
</figure></li>
<li><p><strong>关系型数据库</strong>（比如MySQL、SQLServer、Oracle等）事务都有<strong>ACID</strong>特性<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230122210606135.png"
alt="image-20230122210606135" /></p>
<ol type="1">
<li><strong>原子性</strong>（<code>Atomicity</code>） ：
事务是<strong>最小的执行单位</strong>，<strong>不允许分割</strong>。事务的原子性确保动作<strong>要么全部完成</strong>，要么<strong>完全不起作用</strong>；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）：
执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；（<strong>其实一致性是结果</strong>）</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）：
<strong>并发访问数据库</strong>时，一个用户的事务不被其他事务所干扰，<strong>各并发事务之间数据库是独立的</strong>；</li>
<li><strong>持久性</strong>（<code>Durability</code>）：
一个<strong>事务被提交之后</strong>。它<strong>对数据库中数据的改变是持久的</strong>，<strong>即使数据库发生故障</strong>也不应该对其有任何影响。</li>
</ol>
<p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说
A、I、D 是手段，C 是目的！</strong> 想必大家也和我一样，被 ACID
这个概念被误导了很久! 我也是看周志明老师的公开课<a
href="https://time.geekbang.org/opencourse/intro/100064201">《周志明的软件架构课》open
in new window</a>才搞清楚的（多看好书！！）<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230122210804705.png"
alt="image-20230122210804705" /></p></li>
<li><p>另外，DDIA 也就是 <a
href="https://book.douban.com/subject/30329536/">《Designing
Data-Intensive Application（数据密集型应用系统设计）》open in new
window</a> 的作者在他的这本书中如是说：</p>
<blockquote>
<p>Atomicity, isolation, and durability are properties of the database,
whereas consis‐ tency (in the ACID sense) is a property of the
application. The application may rely on the database’s atomicity and
isolation properties in order to achieve consistency, but it’s not up to
the database alone.</p>
<p>翻译过来的意思是：<strong>原子性</strong>，<strong>隔离性</strong>和<strong>持久性</strong>是<strong>数据库的属性</strong>，而<strong>一致性（在
ACID
意义上）是应用程序的属性</strong>。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母
C 不属于 ACID 《Designing Data-Intensive
Application（数据密集型应用系统设计）》这本书强推一波，值得读很多遍！豆瓣有接近
90% 的人看了这本书之后给了五星好评。另外，中文翻译版本已经在 Github
开源，地址：<a
href="https://github.com/Vonng/ddia">https://github.com/Vonng/ddiaopen
in new window</a></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/20210526162552353.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
</blockquote></li>
</ul>
<h2 id="并发事务带来了哪些问题">并发事务带来了哪些问题</h2>
<p>典型应用程序中，<strong>多个事务并发运行</strong>，经常会<strong>操作相同数据</strong>来完成<strong>各自任务</strong>(多个用户对统一数据进行操作)。<strong>并发</strong>虽然是必须的，但是会导致一下的问题</p>
<ol type="1">
<li><p><strong>脏读（Dirty read） </strong><br />
一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的(<strong>其实就是读未提交</strong>），即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致<strong>数据并没有被提交到数据库，那第二个事务读取到的就是脏数据</strong>，这也就是脏读的由来。</p>
<blockquote>
<p>例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到
A = 19,事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230122212942771.png"
alt="image-20230122212942771" /></p>
</blockquote></li>
<li><p><strong>丢失修改（Lost to modify）</strong>
在一个事务读取一个数据时，另外一个事务也访问了该数据，那么<strong>在第一个事务中修改了这个数据后，第二个事务也修改了这个数据</strong>。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>
<blockquote>
<p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改
A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
(这里例子举得不好，用<strong>事务2进行了A = A - 2
操作</strong>会比较明显) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230122213205474.png"
alt="image-20230122213205474" /></p>
</blockquote></li>
<li><p><strong>不可重复读（Unrepeatable read)</strong><br />
指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于<strong>第二个事务的修改导致第一个事务两次读取的数据可能不太一样</strong>。这就发生了在<strong>一个事务内两次读到的数据是不一样</strong>的情况，因此称为<strong>不可重复读</strong>。</p>
<blockquote>
<p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改
A=A-1，事务 2 再次读取 A
=19，此时读取的结果和第一次读取的结果不同。<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230122213841034.png"
alt="image-20230122213841034" /></p>
</blockquote></li>
<li><p><strong>幻读</strong><br />
幻读与不可重复读类似。它发生在一个事务读取了<strong>几行</strong>数据，接着另一个并发事务<strong>插入</strong>了一些数据时。在随后的查询中，第一个事务就会发现多了一些<strong>原本不存在的记录</strong>，就好像发生了幻觉一样，所以称为<strong>幻读</strong>。</p>
<blockquote>
<p>例如：事务 2 读取某个范围的数据，事务 1
在这个范围插入了新的数据，事务 1
再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230122214041891.png"
alt="image-20230122214041891" /></p>
</blockquote></li>
</ol>
<h2 id="不可重复读和幻读有什么区别">不可重复读和幻读有什么区别</h2>
<ul>
<li><p>不可重复读的重点是<strong>内容修改</strong>或者<strong>记录减少</strong>。比如多次读取一条记录发现其中<strong>某些记录的值被修改</strong>；</p></li>
<li><p>幻读的重点在于<strong>记录新增</strong>比如多次执行同一条查询语句（DQL）时，发现查到的<strong>记录增加</strong>了。</p></li>
<li><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是<strong>解决幻读</strong>和<strong>不可重复读</strong>的方案不一样。</p>
<blockquote>
<ol type="1">
<li>举个例子：执行 <code>delete</code> 和 <code>update</code>
操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code>
操作的时候，由于记录锁（Record
Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap
Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖
<strong>Next-Key Lock（Record Lock+Gap Lock）</strong>
进行加锁来<strong>保证不出现幻读</strong>。
(<strong>这里说的是完全解决幻读，其实也可以依靠MVCC部分解决幻读</strong>)</li>
<li>使用MVCC机制（只<strong>在事务第一次select的时候生成ReadView解决不可重复读的问题</strong>）</li>
</ol>
</blockquote></li>
</ul>
<h2
id="sql标准定义了哪些事务隔离级别">SQL标准定义了哪些事务隔离级别</h2>
<p>SQL标准定义了<strong>四个隔离级别 </strong></p>
<ol type="1">
<li><strong>READ-UNCOMMITTED(读取未提交)</strong> ：
最低的隔离级别，允许读取尚未提交的数据变更，可能会<strong>导致脏读</strong>、<strong>幻读</strong>或<strong>不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)</strong> ：
允许<strong>读取并发事务已经提交</strong>的数据，可以<strong>阻止脏读</strong>，但是<strong>幻读</strong>或不可重复读仍有可能发生。</li>
<li><strong>REPEATABLE-READ(可重复读)</strong> ：
对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以<strong>阻止脏读和不可重复读</strong>，但<strong>幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从
ACID
的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以<strong>防止脏读、不可重复读以及幻读</strong>。</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">隔离级别</th>
<th style="text-align: center;">脏读</th>
<th style="text-align: center;">不可重复读</th>
<th style="text-align: center;">幻读</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">READ-UNCOMMITTED</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
</tr>
<tr class="even">
<td style="text-align: center;">READ-COMMITTED</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
</tr>
<tr class="odd">
<td style="text-align: center;">REPEATABLE-READ</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">√</td>
</tr>
<tr class="even">
<td style="text-align: center;">SERIALIZABLE</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table>
<h2
id="mysql的隔离级别是基于锁实现的吗">MySQL的隔离级别是基于锁实现的吗</h2>
<p>MySQL 的隔离级别基于<strong>锁</strong>和 <strong>MVCC</strong>
机制共同实现的。</p>
<ul>
<li><strong>SERIALIZABLE</strong>
隔离级别，是<strong>通过锁</strong>来实现的。<strong>除了
SERIALIZABLE</strong> 隔离级别，<strong>其他的隔离级别都是基于
MVCC</strong> 实现。</li>
<li>不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如
<strong>REPEATABLE-READ
在当前读情况下需要使用加锁读来保证不会出现幻读</strong>（这就是MVCC不能解决幻读的例外之一）。</li>
</ul>
<h2 id="mysql的默认隔离级别是什么">MySQL的默认隔离级别是什么</h2>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是
<strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<strong><code>SELECT @@tx_isolation;</code></strong>命令来查看，MySQL
8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">------ </span><br></pre></td></tr></table></figure>
<p>关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章： MySQL
事务隔离级别详解</p>
<h1 id="mysql锁">MySQL锁</h1>
<h2
id="表级锁和行级锁了解吗有什么区别">表级锁和行级锁了解吗？有什么区别</h2>
<ul>
<li>MyISAM 仅仅支持<strong>表级锁(table-level
locking)</strong>，一锁就<strong>锁整张表</strong>，这在<strong>并发写的情况下性非常差</strong>。</li>
<li>InnoDB 不光<strong>支持表级锁(table-level
locking)</strong>，还<strong>支持行级锁(row-level
locking)</strong>，<strong>默认为行级锁</strong>。行级锁的粒度更小，<strong>仅对相关的记录上锁</strong>即可（对一行或者多行记录加锁），所以<strong>对于并发写入</strong>操作来说，
<strong>InnoDB 的性能更高</strong>。</li>
</ul>
<p><strong>表级锁和行级锁对比</strong> ：</p>
<ul>
<li><p><strong>表级锁：</strong> MySQL
中<strong>锁定粒度最大的一种锁（全局锁除外）</strong>，是<strong>针对非索引字段</strong>加的锁，对当前操作的<strong>整张表加锁</strong>，实现简单，<strong>资源消耗也比较少</strong>，<strong>加锁快，不会出现死锁</strong>。其锁定粒度最大，<strong>触发锁冲突的概率最高，并发度最低</strong>，MyISAM
和 InnoDB 引擎都支持表级锁。</p></li>
<li><p><strong>行级锁：</strong> MySQL
中<strong>锁定粒度最小</strong>的一种锁，是<strong>针对索引字段加的锁</strong>，<strong>只针对当前操作的行记录进行加锁</strong>。
行级锁能<strong>大大减少数据库操作的冲突</strong>。其加锁粒度最小，<strong>并发度高</strong>，但<strong>加锁的开销也最大，加锁慢，会出现死锁</strong>。</p></li>
</ul>
<h2 id="行级锁的使用有什么注意事项">行级锁的使用有什么注意事项</h2>
<ul>
<li><p>InnoDB
的行锁是<strong>针对索引</strong>字段加的锁，表级锁是<strong>针对非索引</strong>字段加的锁。</p>
<p>当我们执行 <code>UPDATE</code>、<code>DELETE</code>
语句时，<strong>如果
<code>WHERE</code>条件中字段没有命中唯一索引</strong>或者<strong>索引失效</strong>的话，就会<strong>导致扫描全表对表中的所有行记录进行加锁</strong>。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p></li>
<li><p>不过，很多时候即使用了索引也有可能会走全表扫描，这是<strong>因为
MySQL 优化器</strong>的原因。</p></li>
</ul>
<h2 id="共享锁和排他锁">共享锁和排他锁</h2>
<p><strong>不论是表级锁还是行级锁</strong>，都存在<strong>共享锁（Share
Lock，S 锁）</strong>和<strong>排他锁（Exclusive Lock，X
锁）</strong>这两类</p>
<ul>
<li><strong>共享锁（S 锁）</strong>
：又称读锁，事务在<strong>读取记录的时候获取共享锁</strong>，允许<strong>多个事务同时获取（锁兼容）</strong>。</li>
<li><strong>排他锁（X 锁）</strong>
：又称<strong>写锁/独占锁</strong>，事务在<strong>修改记录的时候获取排他锁</strong>，<strong>不允许多个事务同时获取</strong>。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁<strong>（锁不兼容）</strong>。</li>
</ul>
<p><strong>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">S 锁</th>
<th style="text-align: left;">X 锁</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">S 锁</td>
<td style="text-align: left;">不冲突</td>
<td style="text-align: left;">冲突</td>
</tr>
<tr class="even">
<td style="text-align: left;">X 锁</td>
<td style="text-align: left;">冲突</td>
<td style="text-align: left;">冲突</td>
</tr>
</tbody>
</table>
<p><strong>由于 MVCC</strong> 的存在，对于<strong>一般的
<code>SELECT</code> 语句，InnoDB 不会加任何锁</strong>。不过，
你可以通过以下语句<strong>显式加共享锁</strong>或<strong>排他锁</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 共享锁</span><br><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br><span class="line"># 排他锁</span><br><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>
<h2 id="意向锁有什么作用">意向锁有什么作用</h2>
<p>★★ <strong>重点</strong>
：<strong>如果需要用到表锁的话，如何判断表中的记录没有行锁</strong>呢？一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做<strong>意向锁</strong>的东东<strong>来快速判断是否可以对某个表使用表锁</strong>。</p>
<ul>
<li><p><strong>意向锁是表级锁（这句话很重要，意向锁是描述某个表的某个属性（这个表是否有记录加了共享锁/或者排他锁））</strong>，共有两种：</p>
<ul>
<li><p><strong>意向共享锁（Intention Shared Lock，IS
锁）</strong>：事务有意向对表中的某些记录加共享锁（S
锁），加共享锁前必须<strong>先取得该表的 IS 锁</strong>。</p></li>
<li><p><strong>意向排他锁（Intention Exclusive Lock，IX
锁）</strong>：事务有意向对表中的某些记录加排他锁（X
锁），加排他锁之前必须<strong>先取得该表的 IX 锁</strong>。</p>
<blockquote>
<p>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在<strong>为数据行加共享
/ 排他锁之前</strong>，InooDB
会<strong>先获取（如果获取到了，其实就是“加了锁”）该数据行所在在数据表的对应意向锁</strong>。</p>
</blockquote></li>
</ul></li>
<li><p>意向锁之间是互相兼容的 ：</p>
<blockquote>
<p>理由很简单，表里某一条记录加了排他锁（即这个表加了意向排他锁），不代表不能操作其他记录</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>IS 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr class="even">
<td>IX 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody>
</table></li>
<li><p>意向锁和共享锁和排它锁互斥（这里指的是<strong>表级别</strong>的共享锁和排他锁，意向锁不会与<strong>行级</strong>的共享锁和排他锁互斥，★★括号里这句话极其重要，要不然就看不懂下面的表了）。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>S 锁</td>
<td>兼容</td>
<td>互斥</td>
</tr>
<tr class="even">
<td>X 锁</td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody>
</table>
<blockquote>
<p>《MySQL 技术内幕 InnoDB
存储引擎》这本书对应的描述应该是笔误了。<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220511171419081.png"
alt="img" /></p>
</blockquote></li>
</ul>
<h2 id="innodb-有哪几类行锁">InnoDB 有哪几类行锁</h2>
<p><strong>MySQL InnoDB 支持三种行锁定方式</strong>：</p>
<ul>
<li><strong>记录锁（Record Lock）</strong>
：也被称为记录锁，属于<strong>单个行记录上的锁</strong>。</li>
<li><strong>间隙锁（Gap Lock）</strong>
：<strong>锁定一个范围，不包括记录本身</strong>。</li>
<li><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap
Lock，<strong>锁定一个范围，包含记录本身</strong>。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p>InnoDB 的<strong>默认隔离级别
RR（可重读）是可以解决幻读</strong>问题发生的，主要有下面两种情况：</p>
<ul>
<li><strong>快照读</strong>（<strong>一致性非锁定读</strong>） ：由
<strong>MVCC 机制</strong>来保证不出现幻读。</li>
<li><strong>当前读</strong> （<strong>一致性锁定读</strong>）： 使用
<strong>Next-Key Lock</strong> 进行加锁来保证不出现幻读。</li>
</ul>
<h2 id="当前读和快照读有什么区别">当前读和快照读有什么区别</h2>
<ul>
<li><p><strong>快照读</strong>（一致性非锁定读）就是<strong>单纯的
<code>SELECT</code> 语句</strong>，但不包括下面这两类
<code>SELECT</code> 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... FOR UPDATE</span><br><span class="line">SELECT ... LOCK IN SHARE MODE</span><br></pre></td></tr></table></figure>
<p>快照即<strong>记录的历史版本</strong>，每行记录可能存在<strong>多个历史版本</strong>（多版本技术）。</p>
<p>快照读的情况下，<strong>如果读取的记录正在执行 UPDATE/DELETE
操作，读取操作不会因此去等待记录上 X
锁的释放，而是会去读取行的一个快照</strong>。</p>
<p>只有在<strong>事务隔离级别 RC(读取已提交，ReadCommit)</strong> 和
<strong>RR（可重读，RepeatableCommit）</strong>下，InnoDB
才会使用一致性非锁定读：</p>
<ul>
<li>在 RC
级别下，对于快照数据，一致性非锁定读<strong>总是读取被锁定行的最新一份（可见）快照</strong>数据。</li>
<li>在 RR
级别下，对于快照数据，一致性非锁定读总是读取<strong>本事务开始时的行数据版本</strong>。</li>
</ul>
<p>快照读比较适合对于<strong>数据一致性要求不是特别高</strong>且<strong>追求极致性能</strong>的业务场景。</p></li>
<li><p><strong>当前读</strong> （一致性锁定读）就是<strong>给行记录加 X
锁</strong>或 <strong>S
锁</strong>。（使用当前读的话在RR级别下就无法解决幻读）</p>
<p>当前读的一些常见 SQL 语句类型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 对读的记录加一个X锁</span><br><span class="line">SELECT...FOR UPDATE</span><br><span class="line"># 对读的记录加一个S锁</span><br><span class="line">SELECT...LOCK IN SHARE MODE</span><br><span class="line"># 对修改的记录加一个X锁</span><br><span class="line">INSERT...</span><br><span class="line">UPDATE...</span><br><span class="line">DELETE... </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="mysql-性能优化">MySQL 性能优化</h1>
<p>关于 MySQL 性能优化的建议总结，请看这篇文章： MySQL
高性能优化规范建议总结</p>
<h2
id="能用mysql直接存储文件比如图片吗">能用MySQL直接存储文件（比如图片）吗</h2>
<ul>
<li><p>可以是可以，直接存储文件对应的<strong>二进制数据</strong>即可。不过，还是建议不要在数据库中存储文件，会<strong>严重影响数据库性能</strong>，<strong>消耗过多存储空间</strong>。</p></li>
<li><p><strong>数据库只存储文件地址信息，文件由文件存储服务负责存储。</strong></p>
<ul>
<li><p>可以选择使用<strong>云服务厂商提供的开箱即用的文件存储服务</strong>，成熟稳定，价格也比较低。
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/oss-search.png"
alt="img" /></p></li>
<li><p>也可以选择<strong>自建文件存储服务</strong>，实现起来也不难，基于
<strong>FastDFS</strong>、<strong>MinIO（推荐）</strong>
等开源项目就可以实现<strong>分布式文件服务</strong>。</p>
<blockquote>
<p>相关阅读：<a href="https://www.51cto.com/article/716978.html">Spring
Boot 整合 MinIO 实现分布式文件服务</a></p>
</blockquote></li>
</ul></li>
</ul>
<h2 id="mysql如何存储ip-地址">MySQL如何存储IP 地址</h2>
<ul>
<li><p>可以<strong>将 IP
地址转换成整形数据</strong>存储，<strong>性能更好</strong>，<strong>占用空间也更小</strong>。</p></li>
<li><p>MySQL 提供了两个方法来<strong>处理 ip 地址</strong></p>
<ul>
<li><code>INET_ATON()</code> ： 把 <strong>ip 转为无符号整型</strong>
(4-8 位)</li>
<li><code>INET_NTOA()</code> :把<strong>整型的 ip 转为地址</strong></li>
</ul></li>
<li><p><strong>插入数据前</strong>，先用 <code>INET_ATON()</code> 把 ip
地址转为整型，<strong>显示数据时</strong>，使用 <code>INET_NTOA()</code>
把整型的 ip 地址转为地址显示即可</p></li>
</ul>
<h2 id="有哪些常见的sql优化手段吗">有哪些常见的SQL优化手段吗</h2>
<blockquote>
<p><a
href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7">《Java
面试指北》open in new window</a>
的「技术面试题篇」有一篇文章详细介绍了常见的 SQL
优化手段，非常全面，清晰易懂！</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/javamianshizhibei-sql-optimization.png"
alt="常见的 SQL 优化手段" />
<figcaption aria-hidden="true">常见的 SQL 优化手段</figcaption>
</figure>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-database</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库时间类型数据存储建议</title>
    <url>/2023/01/19/review/java_guide/database/mysql/some-thoughts-on-database-storage-time/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="不要用字符串存储日期">不要用字符串存储日期</h1>
<ul>
<li>优点：简单直白</li>
<li>缺点
<ol type="1">
<li>字符串<strong>占有的空间更大</strong></li>
<li>字符串存储的日期<strong>效率比较低</strong>（逐个字符进行比较），<strong>无法用日期相关的API</strong>进行计算和比较</li>
</ol></li>
</ul>
<h1 id="datetime和timestamp之间抉择">Datetime和Timestamp之间抉择</h1>
<p>Datetime 和 Timestamp 是 MySQL
提供的两种<strong>比较相似</strong>的保存时间的数据类型。他们两者究竟该如何选择呢？</p>
<p><strong>通常我们都会首选 Timestamp</strong></p>
<h2 id="datetime类型没有时区信息">Datetime类型没有时区信息</h2>
<ol type="1">
<li><strong>DateTime 类型是没有时区信息的（时区无关）</strong>
，DateTime
类型保存的时间都是当前会话所设置的时区对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。不要小看这个问题，很多系统就是因为这个问题闹出了很多笑话。</li>
<li><strong>Timestamp 和时区有关</strong>。Timestamp
类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是<strong>在不同时区</strong>，<strong>查询到同一个条记录此字段的值会不一样</strong></li>
</ol>
<p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 建表</span><br><span class="line">CREATE TABLE `time_zone_test` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `date_time` datetime DEFAULT NULL,</span><br><span class="line">  `time_stamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8; </span><br><span class="line"></span><br><span class="line">-- 插入数据</span><br><span class="line">INSERT INTO time_zone_test(date_time,time_stamp) VALUES(NOW(),NOW());</span><br><span class="line">-- 查看数据</span><br><span class="line">select date_time,time_stamp from time_zone_test;</span><br><span class="line">-- 结果</span><br><span class="line">/*</span><br><span class="line"> +---------------------+---------------------+</span><br><span class="line">| date_time           | time_stamp          |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| 2020-01-11 09:53:32 | 2020-01-11 09:53:32 |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">------ </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>修改时区并查看数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set time_zone=&#x27;+8:00&#x27;;</span><br><span class="line">/*</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| date_time           | time_stamp          |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| 2020-01-11 09:53:32 | 2020-01-11 17:53:32 |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">------ </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>关于MySQL时区设置的一个<strong>常用sql命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看当前会话时区</span><br><span class="line">SELECT @@session.time_zone;</span><br><span class="line"># 设置当前会话时区</span><br><span class="line">SET time_zone = &#x27;Europe/Helsinki&#x27;;</span><br><span class="line">SET time_zone = &quot;+00:00&quot;;</span><br><span class="line"># 数据库全局时区设置</span><br><span class="line">SELECT @@global.time_zone;</span><br><span class="line"># 设置全局时区</span><br><span class="line">SET GLOBAL time_zone = &#x27;+8:00&#x27;;</span><br><span class="line">SET GLOBAL time_zone = &#x27;Europe/Helsinki&#x27;; </span><br></pre></td></tr></table></figure>
<h2 id="datetime类型耗费空间更大">DateTime类型耗费空间更大</h2>
<p>Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8
个字节的存储空间。但是，这样同样造成了一个问题，<strong>Timestamp
表示的时间范围更小</strong>。</p>
<ul>
<li>DateTime ：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>
<li>Timestamp： 1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li>
</ul>
<blockquote>
<p>Timestamp 在不同版本的 MySQL 中有细微差别。</p>
</blockquote>
<h1 id="再看mysql日期类型存储空间">再看MySQL日期类型存储空间</h1>
<ul>
<li>MySQL 5.6 版本中日期类型所占的存储空间 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/FhRGUVHFK0ujRPNA75f6CuOXQHTE.jpeg"
alt="img" /></li>
</ul>
<ol type="1">
<li>可以看出 5.6.4 之后的 MySQL 多出了一个需要 <strong>0 ～ 3
字节</strong>的小数位。DateTime 和 Timestamp
会有几种不同的存储空间占用。</li>
<li>为了方便，本文我们还是默认 <strong>Timestamp 只需要使用 4
个字节</strong>的存储空间，但是 <strong>DateTime</strong>
需要<strong>耗费 8 个字节</strong>的存储空间</li>
</ol>
<h1 id="数值型时间戳是更好的选择吗">数值型时间戳是更好的选择吗</h1>
<p>使用<strong>int</strong>或者<strong>bigint</strong>类型数值，即时间戳来表示时间</p>
<ol type="1">
<li>优点：使用它进行<strong>日期排序</strong>以及<strong>对比</strong>等操作效率更高，跨系统也方便</li>
<li>缺点：可读性差</li>
</ol>
<p>时间戳的定义</p>
<blockquote>
<p>时间戳的定义是从一个基准时间开始算起，这个基准时间是「1970-1-1
00:00:00
+0:00」，从这个时间开始，用整数表示，以秒计时，随着时间的流逝这个时间整数不断增加。这样一来，我只需要一个数值，就可以完美地表示时间了，而且这个数值是一个绝对数值，即无论的身处地球的任何角落，这个表示时间的时间戳，都是一样的，生成的数值都是一样的，并且没有时区的概念，所以在系统的中时间的传输中，都不需要进行额外的转换了，只有在显示给用户的时候，才转换为字符串格式的本地时间</p>
</blockquote>
<p>实际操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select UNIX_TIMESTAMP(&#x27;2020-01-11 09:53:32&#x27;);</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| UNIX_TIMESTAMP(&#x27;2020-01-11 09:53:32&#x27;) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">|                            1578707612 |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select FROM_UNIXTIME(1578707612);</span><br><span class="line">+---------------------------+</span><br><span class="line">| FROM_UNIXTIME(1578707612) |</span><br><span class="line">+---------------------------+</span><br><span class="line">| 2020-01-11 09:53:32       |</span><br><span class="line">+---------------------------+</span><br><span class="line">1 row in set (0.01 sec) </span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<ul>
<li>推荐使用《高性能MySQL》<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230119230831365.png"
alt="image-20230119230831365" /></li>
<li>对比<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230119230841378.png"
alt="image-20230119230841378" /></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-database</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务隔离级别详解</title>
    <url>/2023/01/16/review/java_guide/database/mysql/transaction-isolation-level/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="事务隔离级别总结">事务隔离级别总结</h1>
<ul>
<li><p>SQL标准定义了<strong>四个隔离级别</strong></p>
<ol type="1">
<li><strong>READ-UNCOMMITTED(读取未提交)</strong>：<strong>最低</strong>的隔离级别，允许读取<strong>尚未提交的数据</strong>变更，可能会导致<strong>脏读、幻读或不可重复读</strong></li>
<li><strong>READ-COMMITED(读取已提交)</strong>：允许读取<strong>并发事务</strong>
<strong>已经提交</strong>的数据，可以阻止<strong>脏读</strong>，但是<strong>幻读</strong>或<strong>不可重复读</strong>仍有可能发生</li>
<li><strong>REPEATABLE-READ(可重复读)</strong>：对<strong>同一字段的多次读取</strong>结果都是一致的，除非数据是被<strong>本身事务自己</strong>所修改，可以<strong>阻止脏读</strong>和<strong>不可重复读</strong>，但<strong>幻读</strong>仍有可能发生</li>
<li><strong>SERIALIZABLE(可串行化)</strong>：<strong>最高</strong>的隔离级别，<strong>完全服从ACID</strong>的隔离级别。所有的<strong>事务依次逐个</strong>执行，这样事务之间就<strong>完全不可能产生干扰</strong>，也就是说，该级别可以防止<strong>脏读</strong>、<strong>不可重复读</strong>以及<strong>幻读</strong>。</li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">隔离级别</th>
<th style="text-align: center;">脏读</th>
<th style="text-align: center;">不可重复读</th>
<th style="text-align: center;">幻读</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">READ-UNCOMMITTED</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
</tr>
<tr class="even">
<td style="text-align: center;">READ-COMMITTED</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
</tr>
<tr class="odd">
<td style="text-align: center;">REPEATABLE-READ</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">√</td>
</tr>
<tr class="even">
<td style="text-align: center;">SERIALIZABLE</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
<td style="text-align: center;">×</td>
</tr>
</tbody>
</table></li>
<li><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是
<strong>REPEATABLE-READ（可重读）</strong></p>
<blockquote>
<p>使用命令查看，通过<code>SELECT @@tx_isolation;</code>。<br />
MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">MySQL&gt; </span><span class="language-bash">SELECT @@tx_isolation;</span></span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+ </span><br></pre></td></tr></table></figure>
</blockquote></li>
<li><p>从上面对SQL标准定义了<strong>四个隔离级别</strong>的介绍可以看出，标准的SQL隔离级别里，<strong>REPEATABLE-READ(可重复读)</strong>是不可以防止幻读的。但是，<strong>InnoDB实现的REPEATABLE-READ</strong>
隔离级别其实是可以<strong>解决幻读</strong>问题发生的，分两种情况</p>
<ol type="1">
<li><strong>快照读</strong>：由<strong>MVCC</strong>机制来保证不出现幻读</li>
<li><strong>当前读</strong>：使用<strong>Next-Key
Lock</strong>进行加锁来保证不出现幻读，Next-Key
Lock是<strong>行锁（Record Lock ）和间隙锁（Gap
Lock）的结合</strong>，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖<strong>间隙锁</strong>
(<strong>只用间隙锁不行，因为间隙锁是 &gt; 或 &lt;
，不包括等于，所以再可重复读下原记录可能会被删掉</strong>)</li>
</ol>
<p>因为<strong>隔离级别越低，事务请求的锁越少</strong>，所以大部分数据库系统的隔离级别都是
<strong>READ-COMMITTED</strong> ，但是你要知道的是 InnoDB
存储引擎默认使用 <strong>REPEATABLE-READ</strong>
并不会有任何性能损失。</p></li>
<li><p>InnoDB 存储引擎在<strong>分布式事务</strong>的情况下一般会用到
<strong>SERIALIZABLE 隔离级别</strong></p>
<ol type="1">
<li>InnoDB 存储引擎提供了对 <strong>XA
事务</strong>的支持，并<strong>通过 XA
事务来支持分布式事务</strong>的实现。</li>
<li>分布式事务指的是允许<strong>多个独立的事务资源（transactional
resources）</strong>参与到<strong>一个全局的事务</strong>中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。<strong>全局事务</strong>要求在其中的<strong>所有参与的事务要么都提交</strong>，要么<strong>都回滚</strong>，这对于事务原有的
ACID 要求又有了提高。</li>
<li>在<strong>使用分布式事务时</strong>，InnoDB
存储引擎的<strong>事务隔离级别必须设置为 SERIALIZABLE</strong>。</li>
</ol></li>
</ul>
<h1 id="实际情况演示">实际情况演示</h1>
<ul>
<li><p>下面会使用2个命令行MySQL，模拟多线程（多事务）对同一份数据的(脏读等)问题</p>
<blockquote>
<p>MySQL 命令行的默认配置中事务都是自动提交的，即执行 SQL
语句后就会马上执行 COMMIT
操作。如果要显式地开启一个事务需要使用命令：<strong><code>START TRANSACTION</code></strong></p>
</blockquote></li>
<li><p>通过下面的命令来设置隔离级别 session
：更改只有本次会话有效；global：更改在<strong>所有会话都有效，且不会影响已开启的session</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE] </span><br></pre></td></tr></table></figure></li>
<li><p>实际操作中使用到的一些并发控制的语句</p>
<ol type="1">
<li><code>START TRANSACTION | BEGIN</code>：显示地<strong>开启一个事务</strong>
（begin也能开启一个事务）</li>
<li><code>COMMIT</code>：<strong>提交事务</strong>，使得对数据库做的所有<strong>修改成为永久性</strong></li>
<li><code>ROLLBACK</code>：<strong>回滚</strong>，会<strong>结束用户的事务</strong>，并<strong>撤销正在进行的所有未提交</strong>的修改</li>
</ol></li>
</ul>
<h2 id="脏读读未提交">脏读（读未提交）</h2>
<ol type="1">
<li><p>事务1 设置为<strong>读未提交</strong>级别
<code>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></p>
<p>事务1开启事务并查看数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">SELECT salary FROM employ WHERE id = 1;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果</span></span><br><span class="line">+--------+</span><br><span class="line">| salary |</span><br><span class="line">+--------+</span><br><span class="line">|   5000 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure></li>
<li><p>开启新连接，事务2 开启事务并更新数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE employ SET salary = 4500 ;</span><br></pre></td></tr></table></figure></li>
<li><p>事务1查看
<code>SELECT salary FROM employ WHERE id = 1;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+--------+</span><br><span class="line">| salary |</span><br><span class="line">+--------+</span><br><span class="line">|   4500 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure></li>
<li><p>此时事务2 进行回滚 <code>ROLLBACK;</code> 使用事务1再次查看
<code>SELECT salary FROM employ WHERE id = 1;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+--------+</span><br><span class="line">| salary |</span><br><span class="line">+--------+</span><br><span class="line">|   5000 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure>
<p>事务二进行了回滚，但是之前事务1却读取到了4500（是个脏数据）</p></li>
</ol>
<h2 id="避免脏读读已提交">避免脏读（读已提交）</h2>
<p><strong>不要在上面的连接里继续</strong></p>
<ol type="1">
<li><p>事务1
设置为读已提交<code>SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></p>
<p>事务1 开启事务并查询数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">SELECT salary FROM employ WHERE id = 1;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果</span></span><br><span class="line">+--------+</span><br><span class="line">| salary |</span><br><span class="line">+--------+</span><br><span class="line">|   5000 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure></li>
<li><p>事务2 开启并修改数据(未提交)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line"> UPDATE employ SET salary =  4500 ;</span><br></pre></td></tr></table></figure></li>
<li><p>事务1查看数据 `` SELECT salary FROM employ WHERE id = 1;```
因为事务隔离级别为<strong>读已提交</strong>，所以不会发生脏读</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果</span></span><br><span class="line">+--------+</span><br><span class="line">| salary |</span><br><span class="line">+--------+</span><br><span class="line">|   5000 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure></li>
<li><p>事务2提交 <code>COMMIT;</code>后，事务1再次读取数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SELECT salary FROM employ WHERE id = 1;</span><br><span class="line">+--------+ </span><br><span class="line">| salary | </span><br><span class="line">+--------+ </span><br><span class="line">|   4500 | </span><br><span class="line">+--------+ </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="不可重复读">不可重复读</h2>
<p>还是刚才<strong>读已提交</strong>的那些步骤，重复操作可以知道
虽然<strong>避免了读未提交</strong>，但是出现了，<strong>一个事务还没结束</strong>，就发生了<strong>不可重复读</strong>问题</p>
<blockquote>
<p>同一个数据，在同一事务内读取多次但值不一样</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230116150215200.png"
alt="image-20230116150215200" />
<figcaption aria-hidden="true">image-20230116150215200</figcaption>
</figure>
<h2 id="可重复读">可重复读</h2>
<p>断开连接后重新连接MySQL，默认就是<strong>REPEATABLE-READ</strong>
可重复读</p>
<ol type="1">
<li><p>事务1查看当前事务隔离级别 <code>select @@tx_isolation;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>
<p>事务1 开启事务并查询数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">SELECT salary FROM employ WHERE id = 1;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">结果</span></span><br><span class="line">+--------+</span><br><span class="line">| salary |</span><br><span class="line">+--------+</span><br><span class="line">|   5000 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure></li>
<li><p>事务2 开启事务并更新数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE employ SET salary = 4500 WHERE id = 1;</span><br></pre></td></tr></table></figure></li>
<li><p>事务1 读取数据（结果仍不变，避免了读未提交的问题）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SELECT salary FROM employ WHERE id = 1;</span><br><span class="line">+--------+</span><br><span class="line">| salary |</span><br><span class="line">+--------+</span><br><span class="line">|   5000 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure></li>
<li><p>事务2提交事务 <code>COMMIT ;</code></p></li>
<li><p>提交后事务1再次读取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> SELECT salary FROM employ WHERE id = 1;</span><br><span class="line">+--------+</span><br><span class="line">| salary |</span><br><span class="line">+--------+</span><br><span class="line">|   5000 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure></li>
<li><p>与MySQL建立新连接并查询数据（发现数据确实是已经更新了的）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SELECT salary FROM employ WHERE id = 1;</span><br><span class="line">+--------+</span><br><span class="line">| salary |</span><br><span class="line">+--------+</span><br><span class="line">|   4500 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="幻读">幻读</h2>
<p><strong>接下来测试一下该隔离策略下是否幻读</strong>
这里是在<strong>可重复读下</strong></p>
<ol type="1">
<li><p>先查看一下当前数据库表的数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | salary |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 |   8000 |</span><br><span class="line">|  6 |   500 |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure></li>
<li><p><code>use lydb;</code> ---&gt; 事务1和事务2都开启事务
<code>START TRANSACTION;</code></p></li>
<li><p>事务2插入一条薪资为500的数据并提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INSERT INTO test(salary) values (500);</span><br><span class="line">COMMIT;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此时数据库已经有两条500的数据了(事务2)</span></span><br><span class="line"> select * from test;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | salary |</span><br><span class="line">+----+--------+</span><br><span class="line">|  1 |   8000 |</span><br><span class="line">|  6 |   500 |</span><br><span class="line">|  10 |   500 |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure></li>
<li><p>事务1查询500的数据(<strong>★★如果在事务2提交之前查询 SELECT *
FROM test WHERE salary = 500; 或者 SELECT * FROM test;
那么这里[快照读]就只会查出一条，但是不管怎么样
[当前读]都会查出两条</strong>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">---------------- <span class="comment"># 快照读------------------</span></span></span><br><span class="line">SELECT * FROM test WHERE salary = 500;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | salary |</span><br><span class="line">+----+--------+</span><br><span class="line">|  6 |    500 | </span><br><span class="line">+----+--------+</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">----------------<span class="comment"># 当前读------------------</span></span></span><br><span class="line">SELECT * FROM test WHERE salary = 500 FOR UPDATE;</span><br><span class="line">+----+--------+</span><br><span class="line">| id | salary |</span><br><span class="line">+----+--------+</span><br><span class="line">|  6 |    500 |</span><br><span class="line">| 11 |    500 |</span><br><span class="line">+----+--------+</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>SQL 事务1 在第一次查询工资为 500 的记录时只有一条，SQL 事务2
插入了一条工资为 500 的记录，提交之后；SQL 事务1
在同一个事务中再次使用当前读查询发现出现了两条工资为 500
的记录这种就是幻读。</p></li>
</ol>
<blockquote>
<p>这里说明一下<strong>当前读</strong>和<strong>快照读</strong>：</p>
<ol type="1">
<li>MySQL
里除了普通查询是<strong>快照读</strong>，其他都是<strong>当前读</strong>，比如
update、insert、delete，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作</li>
<li>【为什么上面要先进行查询的原因】可重复读隔离级是由
MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin
语句后），在执行第一个查询语句后，会创建一个 Read
View，<strong>后续的查询语句利用这个 Read View，通过这个 Read View
就可以在 undo log
版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</strong>，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
</ol>
</blockquote>
<h2 id="解决幻读的方法">解决幻读的方法</h2>
<p>解决幻读的方式有很多，但是它们的核心思想就是<strong>一个事务在操作某张表数据</strong>的时候，另外一个事务<strong>不允许新增或者删除这张表中的数据</strong>了。解决幻读的方式主要有以下几种：<strong>（由重到轻）</strong></p>
<ol type="1">
<li>将事务隔离级别调整为 <code>SERIALIZABLE</code> 。</li>
<li>在<strong>可重复读</strong>的事务级别下，给<strong>事务操作的这张表添加表锁</strong>。</li>
<li>在<strong>可重复读</strong>的事务级别下，给<strong>事务操作的这张表添加
<code>Next-key Lock（Record Lock+Gap Lock）</code></strong>。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-database</tag>
      </tags>
  </entry>
  <entry>
    <title>big_decimal</title>
    <url>/2022/10/10/review/java_guide/java/basic/big_decimal/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h3 id="精度的丢失">精度的丢失</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么会有精度丢失的风险</p>
<p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示</p>
</blockquote>
<p>使用BigDecimal来定义浮点数的值，然后再进行浮点数的运算操作即可</p>
<h3 id="bigdecimal常见方法">BigDecimal常见方法</h3>
<ul>
<li><p>我们在使用 <code>BigDecimal</code>
时，为了防止精度丢失，推荐使用它的<code>BigDecimal(String val)</code>构造方法或者
<code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象</p></li>
<li><p>加减乘除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.add(b));<span class="comment">// 1.9</span></span><br><span class="line">System.out.println(a.subtract(b));<span class="comment">// 0.1</span></span><br><span class="line">System.out.println(a.multiply(b));<span class="comment">// 0.90</span></span><br><span class="line">System.out.println(a.divide(b));<span class="comment">// 无法除尽，抛出 ArithmeticException 异常</span></span><br><span class="line">System.out.println(a.divide(b, <span class="number">2</span>, RoundingMode.HALF_UP));<span class="comment">// 1.11</span></span><br></pre></td></tr></table></figure>
<p>使用divide方法的时候，尽量使用3个参数版本（roundingMode.oldMode)</p></li>
<li><p>保留规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RoundingMode</span> &#123;</span><br><span class="line">   <span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">			 UP(BigDecimal.ROUND_UP),</span><br><span class="line">   <span class="comment">// 2.5 -&gt; 2 , 1.6 -&gt; 1</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -1 , -2.5 -&gt; -2</span></span><br><span class="line">			 DOWN(BigDecimal.ROUND_DOWN),</span><br><span class="line">			 <span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -1 , -2.5 -&gt; -2</span></span><br><span class="line">			 CEILING(BigDecimal.ROUND_CEILING),</span><br><span class="line">			 <span class="comment">// 2.5 -&gt; 2 , 1.6 -&gt; 1</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">			 FLOOR(BigDecimal.ROUND_FLOOR),</span><br><span class="line">   	<span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2</span></span><br><span class="line">   <span class="comment">// -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">			 HALF_UP(BigDecimal.ROUND_HALF_UP),</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>大小比较<br />
使用compareTo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
<li><p>保留几位小数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.255433&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">n</span> <span class="operator">=</span> m.setScale(<span class="number">3</span>,RoundingMode.HALF_DOWN);</span><br><span class="line">System.out.println(n);<span class="comment">// 1.255</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用compareTo替换equals方法，equals不止会比较直，还会比较精度
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221010170727552.png" /></p></li>
<li><p>BigDecimal工具类分享 (用来操作double算术)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简化BigDecimal计算的小工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimalUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认除法运算精度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEF_DIV_SCALE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BigDecimalUtil</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的加法运算。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 被加数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 加数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.add(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的减法运算。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 被减数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 减数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的差</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">subtract</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.subtract(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的乘法运算。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 被乘数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 乘数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的积</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">multiply</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.multiply(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到</span></span><br><span class="line"><span class="comment">     * 小数点以后10位，以后的数字四舍五入。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 被除数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 除数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的商</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">divide</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> divide(v1, v2, DEF_DIV_SCALE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指</span></span><br><span class="line"><span class="comment">     * 定精度，以后的数字四舍五入。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1    被除数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2    除数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scale 表示表示需要精确到小数点以后几位。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 两个参数的商</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">divide</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2, <span class="type">int</span> scale)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (scale &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;The scale must be a positive integer or zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.divide(b2, scale, RoundingMode.HALF_UP).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的小数位四舍五入处理。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v     需要四舍五入的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scale 小数点后保留几位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 四舍五入后的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> v, <span class="type">int</span> scale)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (scale &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;The scale must be a positive integer or zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> BigDecimal.valueOf(v);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的类型转换(Float)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 需要被转换的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回转换结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">convertToFloat</span><span class="params">(<span class="type">double</span> v)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v);</span><br><span class="line">        <span class="keyword">return</span> b.floatValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的类型转换(Int)不进行四舍五入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 需要被转换的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回转换结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">convertsToInt</span><span class="params">(<span class="type">double</span> v)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v);</span><br><span class="line">        <span class="keyword">return</span> b.intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供精确的类型转换(Long)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 需要被转换的数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回转换结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">convertsToLong</span><span class="params">(<span class="type">double</span> v)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v);</span><br><span class="line">        <span class="keyword">return</span> b.longValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两个数中大的一个值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 需要被对比的第一个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 需要被对比的第二个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回两个数中大的一个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">returnMax</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.max(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两个数中小的一个值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 需要被对比的第一个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 需要被对比的第二个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回两个数中小的一个值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">returnMin</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.min(b2).doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 精确对比两个数字</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 需要被对比的第一个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 需要被对比的第二个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(<span class="type">double</span> v1, <span class="type">double</span> v2)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b1</span> <span class="operator">=</span> BigDecimal.valueOf(v1);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">b2</span> <span class="operator">=</span> BigDecimal.valueOf(v2);</span><br><span class="line">        <span class="keyword">return</span> b1.compareTo(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>javaGuide基础1</title>
    <url>/2022/09/28/review/java_guide/java/basic/java_guide_basic_1/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="基础概念及常识">基础概念及常识</h2>
<ul>
<li><p>Java语言特点</p>
<ul>
<li>面向对象（封装、继承、多态）</li>
<li>平台无关性（Java虚拟机）</li>
<li>等等</li>
</ul></li>
<li><p>JVM并非只有一种，只要满足JVM规范，可以开发自己专属JVM</p></li>
<li><p>JDK与JRE</p>
<ul>
<li>JDK，JavaDevelopmentKit，包含JRE，还有编译器（javac）和工具（如javadoc、jdb）。能够创建和编译程序</li>
<li>JRE，Java运行时环境，包括Java虚拟机、Java类库，及Java命令等。但是不能创建新程序</li>
</ul></li>
<li><p>字节码，采用字节码的好处</p>
<ul>
<li>Java中，JVM可以理解的代码称为字节码（.class文件)，不面向任何处理器，只面向虚拟机</li>
<li>Java程序从源代码到运行的过程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220928110902410.png"
alt="image-20220928110902410" />
java代码必须先编译为字节码，之后呢，.class--&gt;机器码，这里JVM类加载器先加载字节码文件，然后通过解释器进行解释执行（也就是字节码需要由Java解释器来解释执行）</li>
</ul></li>
<li><p>编译与解释并存</p>
<ul>
<li>编译型：通过编译器将源代码一次性翻译成可被该平台执行的机器码，执行快、开发效率低</li>
<li>解释型：通过解释器一句一句的将代码解释成机器代码后执行，执行慢，开发效率高</li>
<li>如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220928110844996.png"
alt="image-20220928110844996" /></li>
</ul></li>
<li><p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p>
<p>这是因为 Java
语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java
程序要经过<strong>先编译，后解释</strong>两个步骤，由 Java
编写的程序需要先经过编译步骤，生成字节码（<code>.class</code>
文件），<strong>这种字节码必须由 Java
解释器来解释执行</strong>。</p></li>
<li><p>Java与C++区别</p>
<ul>
<li>没学过C++，Java不提供指针直接访问内存</li>
<li>Java为单继承；但是Java支持继承多接口</li>
<li>Java有自动内存管理垃圾回收机制（GC），不需要程序员手动释放无用内存</li>
</ul></li>
<li><p>注释分为 单行注释、多行注释、文档注释 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220928111257144.png"
alt="image-20220928111257144" /></p></li>
<li><p>标识符与关键字
标识符即名字，关键字则是被赋予特殊含义的标识符</p></li>
<li><p>自增自减运算符 当 <code>b = ++a</code> 时，先自增（自己增加
1），再赋值（赋值给 b）；当 <code>b = a++</code> 时，先赋值(赋值给
b)，再自增（自己增加 1）</p></li>
<li><p>continue/break/return</p>
<ul>
<li><code>continue</code>
：指跳出当前的这一次循环，继续下一次循环。</li>
<li><code>break</code> ：指跳出整个循环体，继续执行循环下面的语句。</li>
<li><code>return</code> 用于跳出所在方法，结束该方法的运行。</li>
</ul></li>
<li><p>变量</p>
<ul>
<li>成员变量和局部变量
<ul>
<li>成员变量可以被
<code>public</code>,<code>private</code>,<code>static</code>
等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code>
所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰</li>
<li>从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code>
修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code>
修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡（即方法栈弹出后消亡）。</li>
<li>final必须显示赋初始值，其他都自动以类型默认值赋值</li>
</ul></li>
<li>静态变量：被类所有实例共享</li>
</ul></li>
<li><p>字符型常量与字符串常量区别</p>
<ul>
<li><strong>形式</strong> :
字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0
个或若干个字符。</li>
<li><strong>含义</strong> : 字符常量相当于一个整型值( ASCII
值),可以参加表达式运算;
字符串常量代表一个地址值(该字符串在内存中存放位置)。</li>
<li><strong>占内存大小</strong> ： 字符常量只占 2 个字节;
字符串常量占若干个字节。</li>
</ul></li>
<li><p>静态方法为什么不能调用非静态成员?</p>
<ul>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ul></li>
<li><p>调用方式</p>
<ul>
<li>使用类名.方法名 调用静态方法，或者对象.方法名 （不建议）
调用静态方法可以无需创建对象</li>
</ul></li>
<li><p>重载</p>
<ul>
<li>发生在同一个类中（或者父类与子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同、方法返回值和访问修饰符<strong>可以不同</strong><br />
不允许存在（只有返回值不同的两个方法(方法名和参数个数及类型相同))</li>
<li>重载就是同一个类中<strong>多个同名方法根据不同的传参来执行不同的逻辑</strong>处理。</li>
</ul></li>
<li><p>重写</p>
<ul>
<li><p><strong>发生在运行期</strong>，子类<strong>对父类的允许访问的方法实现过程进行重新编写</strong></p>
<ul>
<li><p>方法名、参数列表必须相同，<strong>子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。【注意，这里只针对方法，类属性则没有这个限制】</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaguide; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestParent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> AParent <span class="title function_">x</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AParent</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestChild</span> <span class="keyword">extends</span> <span class="title class_">TestParent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回类型有误，没有比父类更具体</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">/* protected AParentParent x() &#123;</span></span><br><span class="line"><span class="comment">        return new AChild();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">protected</span> AChild <span class="title function_">x</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AChild</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抛异常类型有误 没有比父类更具体</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*protected void b() throws Throwable &#123;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果父类方法访问修饰符为 <code>private/final/static</code>
则子类就不能重写该方法，但是被 <code>static</code>
修饰的方法能够被再次声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestChild</span> <span class="keyword">extends</span> <span class="title class_">TestParent</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ab</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestParent</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ab</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>构造方法无法被重写</p></li>
</ul></li>
</ul></li>
<li><p>可变长参数</p>
<ul>
<li><p>代码 可变参数只能作为函数的最后一个参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(String arg1, String... args)</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p>
<p>答案是会优先匹配固定参数的方法</p>
<p>Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的
<code>class</code>文件就可以看出来了。</p></li>
<li><p>Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的
<code>class</code>文件就可以看出来了。</p></li>
</ul></li>
<li><p>基本数据类型，8种</p>
<ul>
<li>6种数字类型，1种字符类型，1种布尔值
<ul>
<li>byte,short,int,long ; float,double ;<br />
</li>
<li>char</li>
<li>boolean</li>
</ul></li>
<li>1个字节8位，其中
<ul>
<li>byte 1字节，short 2字节，int 4字节 ，long 8字节</li>
<li>float 4字节，double 8 字节</li>
<li>char 2字节，boolean 1位</li>
</ul></li>
</ul></li>
<li><p>基本数据类型和包装类型的区别</p>
<ul>
<li>包装类型可用于泛型，而基本类型不可以</li>
<li>对于<strong>基本数据类型</strong>，<strong>局部变量</strong>会存放在Java虚拟机<strong>栈中的局部变量表</strong>中，<strong>成员变量</strong>（未被static修饰）存放在<strong>Java虚拟机堆</strong>中。<br />
包装类型属于对象类型，几乎所有对象实例都存在于堆中</li>
<li>相比对象类型，基本数据类型占用空间非常小</li>
<li>"基本数据类型存放在栈中"
这句话是错的，<strong>基本数据类型的成员变量</strong>如果没有被static修饰的话（不建议这么用，应该使用基本数据类型对应的包装类型），就存放在堆中。<br />
（<strong>如果被static修饰了，如果1.7则在方法区，1.7及以上移到了
Java堆中</strong>）</li>
</ul></li>
<li><p>包装类型的缓存机制
Byte，Short，Integer，Long这4中包装类默认创建了数值[-128,127]的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean直接返回True
or False</p>
<ul>
<li><p>Integer缓存代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Character缓存代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">      <span class="keyword">return</span> CharacterCache.cache[(<span class="type">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Character</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CharacterCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">CharacterCache</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> <span class="title class_">Character</span>[<span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">            cache[i] = <span class="keyword">new</span> <span class="title class_">Character</span>((<span class="type">char</span>)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Boolean缓存代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意Float和Double没有使用缓存机制，且
<strong>只有调用valueOf（或者自动装箱）才会使用缓存</strong>，当使用new的时候是直接创建新对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      Boolean t=<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line">      Boolean f=<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line">      System.out.println(t==f); <span class="comment">//false</span></span><br><span class="line">      System.out.println(t.equals(f)); <span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">      Boolean t1=Boolean.valueOf(<span class="literal">true</span>);</span><br><span class="line">      Boolean f1=Boolean.valueOf(<span class="literal">true</span>);</span><br><span class="line">      System.out.println(t1==f1); <span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">      System.out.println(Boolean.TRUE==Boolean.TRUE); <span class="comment">//true</span></span><br><span class="line">      <span class="comment">//============================================//</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">33</span>; <span class="comment">//这里发生了自动装箱，相当于Integer.valueOf(30)</span></span><br><span class="line">      <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">33</span>;</span><br><span class="line">      System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line">    </span><br><span class="line">      <span class="type">Float</span> <span class="variable">i11</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line">      <span class="type">Float</span> <span class="variable">i22</span> <span class="operator">=</span> <span class="number">333f</span>;</span><br><span class="line">      System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line">    </span><br><span class="line">      <span class="type">Double</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">      <span class="type">Double</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line">      System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">//===========================================//</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">      System.out.println(i1==i2);</span><br></pre></td></tr></table></figure></li>
<li><p>如上，所有整型包装类对象之间值的比较，应该全部使用equals方法比较
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220929092643596.png"
alt="image-20220929092643596" /></p></li>
<li><p>什么是自动装箱和拆箱</p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul></li>
<li><p>举例说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> ;<span class="comment">//装箱 相当于Integer.valueOf(10)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i ;<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>
<p>对应的字节码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L1</span><br><span class="line">    </span><br><span class="line"> LINENUMBER 8 L1</span><br><span class="line">    </span><br><span class="line"> ALOAD 0</span><br><span class="line">    </span><br><span class="line"> BIPUSH 10</span><br><span class="line">    </span><br><span class="line"> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;</span><br><span class="line">    </span><br><span class="line"> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line">    </span><br><span class="line">L2</span><br><span class="line">    </span><br><span class="line"> LINENUMBER 9 L2</span><br><span class="line">    </span><br><span class="line"> ALOAD 0</span><br><span class="line">    </span><br><span class="line"> ALOAD 0</span><br><span class="line">    </span><br><span class="line"> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;</span><br><span class="line">    </span><br><span class="line"> INVOKEVIRTUAL java/lang/Integer.intValue ()I</span><br><span class="line">    </span><br><span class="line"> PUTFIELD AutoBoxTest.n : I</span><br><span class="line">    </span><br><span class="line"> RETURN</span><br></pre></td></tr></table></figure>
<p>如图，Integer i = 10 等价于Integer i = Integer.valueOf(10)</p>
<p>int n= i 等价于 int n= i.intValue();</p>
<p>频繁拆装箱会严重影响系统行呢个</p></li>
<li><p>浮点数运算的时候会有精度丢失的风险</p>
<blockquote>
<p>这个和计算机保存浮点数的机制有很大关系。我们知道<strong>计算机是二进制</strong>的，而且<strong>计算机在表示一个数字时，宽度是有限的</strong>，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
</blockquote>
<p>十进制下的0.2无法精确转换成二进制小数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span><br><span class="line">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span><br><span class="line">0.2 * 2 = 0.4 -&gt; 0</span><br><span class="line">0.4 * 2 = 0.8 -&gt; 0</span><br><span class="line">0.8 * 2 = 1.6 -&gt; 1</span><br><span class="line">0.6 * 2 = 1.2 -&gt; 1</span><br><span class="line">0.2 * 2 = 0.4 -&gt; 0（发生循环）</span><br></pre></td></tr></table></figure></li>
<li><p>使用BigDecimal解决上面的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(y); <span class="comment">/* 0.1 */</span></span><br><span class="line">System.out.println(Objects.equals(x, y)); <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure></li>
<li><p>超过long整形的数据，使用BigInteger</p>
<p>Java中，64位long整型是最大的整数类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>); <span class="comment">// -9223372036854775808</span></span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//BigInteger内部使用int[] 数组来存储任意大小的整型数据</span></span><br><span class="line"><span class="comment">//对于常规整数类型，使用BigInteger运算的效率会降低</span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220929093558353.png"
alt="image-20220929093558353" />
<figcaption aria-hidden="true">image-20220929093558353</figcaption>
</figure></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>javaGuide基础2</title>
    <url>/2022/09/29/review/java_guide/java/basic/java_guide_basic_2/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="面向对象基础">面向对象基础</h2>
<ul>
<li><p>区别</p>
<ul>
<li>面向<strong>过程</strong>把解决问题的<strong>过程拆成一个个方法</strong>，通过一个个方法的执行解决问题。</li>
<li>面向对象会<strong>先抽象出对象</strong>，然后<strong>用对象执行方法</strong>的方式解决问题。</li>
<li>面向对象编程
<strong>易维护</strong>、<strong>易复用</strong>、<strong>易扩展</strong></li>
</ul></li>
<li><p>对象实体与对象引用的不同<br />
new 运算符，new
创建对象实例（<strong>对象实例在堆</strong>内存中），对象引用指向对象实例（<strong>对象引用存放在栈</strong>内存中）。</p>
<p>一个对象引用可以指向 0 个或 1
个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n
个引用指向它（可以用 n 条绳子系住一个气球）。</p></li>
<li><p>对象的相等一般比较的是<strong>内存中存放的内容</strong>是否相等；引用相等一般比较的是他们指向的<strong>内存地址是否相等</strong></p></li>
<li><p>如果一个类没有声明构造方法，该程序能正确执行吗?
如果我们自己添加了类的构造方法（无论是否有参），Java
就不会再添加默认的无参数的构造方法了</p>
<ul>
<li>构造方法特点：名字与类名相同；没有返回值但不能用void生命构造函数；生成类的对象时自动执行</li>
<li>构造方法<strong>不能重写override</strong>，但<strong>能重载</strong>
overload</li>
</ul></li>
<li><p>面向对象三大特征</p>
<ul>
<li><p>封装<br />
把一个对象的状态信息(属性)<strong>隐藏在对象内部</strong>，<strong>不允许直接访问</strong>，但提供可以被外界访问的方法来操作属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//id属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//name属性私有化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取id的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置id的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取name的方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置name的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>继承<br />
不通类型的对象，相互之间有一定数量的共同点，同时每个对象定义了额外的特性使得他们与众不同。继承是<strong>使用已存在的类的定义作为基础</strong>建立新类的技术</p>
<ul>
<li><strong>父类中的私有属性</strong>和方法<strong>子类无法访问</strong>，只是拥有</li>
<li>子类可以拥有自己的属性、方法，即对父类进行<strong>拓展</strong></li>
<li>子类可以用<strong>自己的方式实现父类的方法（重写）</strong></li>
</ul></li>
<li><p>多态</p>
<ul>
<li><strong>对象类型</strong>和<strong>引用类型</strong>之间具有继承(类)/实现(接口)的关系</li>
<li><strong>引用类型变量</strong>发出的<strong>方法具体调用哪个类的方法</strong>，只有<strong>程序运行期间才能确定</strong></li>
<li>多态不能调用“<strong>只在子类存在而父类不存在</strong>”的方法</li>
<li>如果子类重写了父类的方法，<strong>真正执行的是子类覆盖的方法</strong>，如果子类没有覆盖父类的方法，执行的是父类的方法</li>
</ul></li>
</ul></li>
<li><p>接口和抽象类有什么共同点和区别</p>
<ul>
<li>共同：都不能被实例化；<strong>都可以包含抽象方法</strong>；都<strong>可以有默认实现</strong>的方法。</li>
<li>区别
<ul>
<li>接口主要用于对<strong>类的行为</strong>进行约束；抽象类主要用于<strong>代码复用</strong>（强调所属）</li>
<li>类只能继承<strong>一个类</strong>，但能实现<strong>多个接口</strong></li>
<li>接口中的成员只能是<code>public static final</code><strong>不能被修改且具有初始值</strong>；而抽象类的成员变量<strong>默认default</strong>
，<strong>可在子类重新定义或重新赋值</strong></li>
</ul></li>
</ul></li>
<li><p>深拷贝和浅拷贝的区别？什么是引用拷贝</p>
<ul>
<li><p>浅拷贝：浅拷贝会在堆上创建新对象，但是如果原对象内部的属性是引用类型的话，<strong>浅拷贝会复制内部对象的引用地址</strong>，即<strong>拷贝对象和原对象共用</strong>一个内部对象</p></li>
<li><p>深拷贝，会完全复制整个对象，包括对象内包含的内部对象</p></li>
<li><p>例子</p>
<ul>
<li><p>浅拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="keyword">return</span> person;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------测试--------------------</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure></li>
<li><p>深拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改了Person类的clone()方法进行修改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------测试-------</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;武汉&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">person1Copy</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">System.out.println(person1.getAddress() == person1Copy.getAddress());</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>引用拷贝，即两个不同的引用指向同一个对象</p></li>
<li><p>如图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221006140951954.png"
alt="image-20221006140951954" /></p></li>
</ul></li>
</ul>
<h2 id="java常见类">Java常见类</h2>
<h3 id="object">Object</h3>
<ul>
<li><p>常见方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>== 和 equals() 区别</p>
<ul>
<li>对于基本类型来说，== 比较的是值</li>
<li>对于引用类型，== 比较的是对象的内存地址</li>
<li><strong>Java是值传递</strong>，所以本质上比较的都是值，只是<strong>引用类型变量存的值是对象地址</strong></li>
</ul></li>
<li><p>equals不能用于判断基本数据类型的变量，且只存在于Object类中，而Object类是所有类的直接或间接父类<br />
<strong>equals默认实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果类没有重写该方法，则如上</p></li>
<li><p>如果重写了，则<strong>一般</strong>都是重写equals方法来比较对象中的属性是否相等</p>
<blockquote>
<p>关于String 和 new String 的区别： String a = "xxx"
始终返回的是<strong>常量池中的引用</strong>；而new String
始终返回的是<strong>堆中的引用</strong></p>
<ul>
<li><p>对于String a = "xxx"
，先到常量池中查找是否存在值为"xxx"的字符串，如果存在，直接将常量池中该值对应的引用返回，如果不存在，则在常量池中创建该对象，并返回引用。</p></li>
<li><p>对于new
String("xxx")，先到常量池中查找是否存在值为"xxx"的字符串，如果存在，则直接在堆中创建对象，并返回堆中的索引；如果不存在，则先在常量池中创建对象(值为xxx)，然后再在堆中创建对象，并返回堆中该对象的引用地址</p></li>
</ul>
<blockquote>
<p>来自
https://blog.csdn.net/weixin_44844089/article/details/103648448</p>
</blockquote>
</blockquote>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">System.out.println(aa == bb);<span class="comment">// true</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">42</span> == <span class="number">42.0</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>String 类重写了equals()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>hashCode()有什么用<br />
hashCode()的作用是<strong>获取哈希码(int整数)</strong>，也称为<strong>散列码</strong>，作用是确定<strong>该对象在哈希表中的索引位置</strong>。函数定义在Object类中，且为本地方法，通常用来<strong>将对象的内存地址转换为整数之后返回</strong>；散列表存储的是键值对(key-value)，<strong>根据“键”快速检索出“值”</strong>，其中利用了散列码</p></li>
<li><p>为什么需要hashCode</p>
<blockquote>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code>
会先计算对象的 <strong><code>hashCode</code>
值来判断对象加入的位置</strong>，同时也会<strong>与其他已经加入的对象的
<code>hashCode</code> 值作比较</strong>，如果没有相符的
<code>hashCode</code>，<code>HashSet</code>
会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code>
值的对象，这时会调用 <code>equals()</code> 方法来检查
<code>hashCode</code>
相等的对象是否真的相同。如果两者相同，<code>HashSet</code>
就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置【注意，我觉得这里应该是使用拉链法，说成散列到其他位置貌似有点不对】。这样我们就大大<strong>减少了
<code>equals</code> 的次数</strong>，相应就大大提高了执行速度。</p>
</blockquote></li>
<li><p>hashCode()和equals()都用于比较两个对象是否相等，为什么要同时提供两个方法（因为在一些容器中，如<strong>HashMap、HashSet</strong>中，判断元素是否在容器中<strong>效率更高</strong>)</p>
<ul>
<li>两个对象的hashCode值相等并不代表两个对象就相等</li>
<li>因为hashCode所使用的哈希算法也许会让多个对象传回相同哈希值，取决于哈希算法</li>
</ul></li>
<li><p>总结</p>
<ul>
<li>如果两个对象的<code>hashCode</code>
值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code>
值相等并且<code>equals()</code>方法也返回
<code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<strong><code>hashCode</code>
值不相等</strong>，我们就可以<strong>直接认为这两个对象不相等</strong>。</li>
</ul></li>
</ul>
<h3 id="string">String</h3>
<ul>
<li><p>String、StringBuffer，StringBuilder区别
String是不可变的，StringBuffer和StringBuilder都继承自AbstractStringBuilder类，是可变的（提供了<strong>修改字符串</strong>的方法）</p></li>
<li><p>String中的变量<strong>不可变，所以是线程安全</strong>的，而StringBuffer对方法加了<strong>同步锁</strong>，所以是线程安全的；而S<strong>tringBuilder是线程不安全</strong>的</p></li>
<li><p>三者使用建议</p>
<ul>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用
<code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用
<code>StringBuffer</code></li>
</ul></li>
<li><p>String 为什么是不可变的</p>
<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如上，保存字符串的数组被<strong>final</strong>修饰且为<strong>私有</strong>，并且String类<strong>没有提供暴露修改该字符串</strong>的方法</li>
<li>String类被修饰为final修饰导致不能被继承，避免子类破坏</li>
</ul></li>
<li><p>Java9</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">// @Stable 注解表示变量最多被修改一次，称为“稳定的”。</span></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><blockquote>
<p>Java9为何String底层实现由<strong>char[] 改成了 byte[]</strong> 新版的
String 其实支持两个编码方案： <strong>Latin-1</strong> 和
<strong>UTF-16</strong>。如果字符串中包含的<strong>汉字没有超过
Latin-1</strong> 可表示范围内的字符，那就会使用 <strong>Latin-1</strong>
作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8
位)，<code>char</code> 占用 2 个字节（16），<strong><code>byte</code>
相较 <code>char</code> 节省一半的内存空间</strong>。</p>
<p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。<br />
<code>[ˈlætɪn]</code></p>
</blockquote></li>
</ul></li>
</ul></li>
<li><p>字符串使用“+” 还是 Stringbuilder Java本身不支持运算符重载，但 “ +
” 和 “+=” 是专门为String重载过的运算符，Java中仅有的两个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;he&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;llo&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2 + str3;</span><br></pre></td></tr></table></figure>
<p>对应的字节码：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221008114449075.png"
alt="image-20221008114449075" /></p>
<p>字符串对象通过“+”的字符串拼接方式，实际上是通过
<code>StringBuilder</code> 调用 <code>append()</code>
方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个
<code>String</code>
对象。因此这里就会产生问题，如下代码，会<strong>产生过多的StringBuilder对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    s += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>会<strong>循环创建StringBuilder</strong>对象，建议自己创建一个新的StringBuilder并使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span> (String value : arr) &#123;</span><br><span class="line">    s.append(value);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(s);</span><br></pre></td></tr></table></figure></li>
<li><p>String#equals()和Object#equals()有何区别
String的equals被重写过，比较的是<strong>字符串的值是否相等</strong>，而<strong>Object的equals</strong>比较的是<strong>对象的内存地址</strong></p></li>
<li><p>字符串常量池<br />
是JVM为了提升性能和减少内存消耗针对字符串（String类）专门开辟的一块区域，主要目的是为了<strong>避免字符串的重复创建</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“ (这里也可以说是在常量池中创建对象)</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用(常量池中的饮用)保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="string-s1-new-stringabc这句话创建了几个字符串对象">String s1
= new String("abc");这句话创建了几个字符串对象？</h4>
<p>会创建 1 或 2 个字符串对象。
如果常量池中存在值为"abc"的对象，则直接在堆中创建一个对象，并且返回该对象的引用；如果不存在，则先在常量池中创建该对象，然后再在堆中创建该对象，并且返回该对象（堆中）的引用</p>
<p>下面这个解释，说明<strong>常量池存储的是引用</strong>（堆中某一块区域的）<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221008144055351.png"
alt="image-20221008144055351" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串常量池中已存在字符串对象“abc”的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="comment">// 下面这段代码只会在堆中创建 1 个字符串对象“abc”</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>intern方法的作用，是一个native方法，作用是将指定的<strong>字符串对象的引用</strong>保存在<strong>字符串常量池</strong>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Java&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>问题：String 类型的变量和常量做“+”运算时发生了什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>常量折叠<br />
对于 <code>String str3 = "str" + "ing";</code> 编译器会给你优化成
<code>String str3 = "string";</code> 。</p>
<p>并不是所有的常量都会进行折叠，只有<strong>编译器在程序编译期就可以确定值</strong>的常量才可以：</p>
<ul>
<li>基本数据类型(
<code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过
“+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;
）</li>
</ul></li>
</ul></li>
<li><p>引用的值在程序编译期间是无法确认的，无法对其优化</p></li>
<li><p>对象引用和“+”的字符串拼接方式，实际上是通过
<code>StringBuilder</code> 调用 <code>append()</code>
方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个
<code>String</code> 对象 。
如上面代码<code>String str4 = str1 + str2;</code>
但是如果使用了final关键字声明之后，就可以让编译器当作常量来处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是如果编译器在<strong>运行时才能知道</strong>其确切值的话，就无法对其优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> getStr();  <span class="comment">//str2只有在运行时才能确定其值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>javaGuide基础3</title>
    <url>/2022/10/08/review/java_guide/java/basic/java_guide_basic_3/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="异常">异常</h2>
<ul>
<li><p>unchecked exceptions (运行时异常)<br />
checked exceptions (非运行时异常，编译异常）</p></li>
<li><p>Java异常类层次结构图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/Exception.png"
alt="Exception" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221008163827798.png"
alt="image-20221008163827798" />
<figcaption aria-hidden="true">image-20221008163827798</figcaption>
</figure></li>
<li><p>Exception和Error有什么区别</p>
<ul>
<li><p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常</p></li>
<li><p>Exception : 程序本身可以处理的异常（可通过catch捕获）</p>
<ul>
<li><p>Checked Exception ，受检查异常，必须处理(<strong>catch 或者
throws ，否则编译器通过不了</strong>)
IOException，ClassNotFoundException，SQLException，FileNotFoundException</p></li>
<li><p>Unchecked Exception ， 不受检查异常 ， 可以不处理</p></li>
</ul></li>
</ul></li>
</ul>
<p>（算数异常，类型转换异常，不合法的线程状态异常，下标超出异常，空指针异常，参数类型异常，数字格式异常，不支持操作异常）
ArithmeticException，ClassCastException，IllegalThreadStateException，IndexOutOfBoundsException</p>
<pre><code>  NullPointerException，IllegalArgumentException，NumberFormatException，SecurityException，UnsupportedOperationException 


  ```illegal 英[ɪˈliːɡl] 非法的```  
  ```Arithmetic 英[əˈrɪθmətɪk] 算术```</code></pre>
<ul>
<li><p>Error： <strong>程序无法处理</strong>的错误 ，不建议通过catch
捕获，已办错误发生时JVM会选择线程终止<br />
OutOfMemoryError （堆，Java heap
space），VirtualMachineError，StackOverFlowError，AssertionError
（断言），IOError</p></li>
<li><p>Throwable类常用方法</p>
<ul>
<li>String getMessage() //简要描述</li>
<li>String toString() //详细</li>
<li>String getLocalizedMessage()
//本地化信息，如果子类(Throwable的子类)没有覆盖该方法，则与gtMessage()
结果一样</li>
<li>void printStackTrace() //打印Throwable对象封装的异常信息</li>
</ul></li>
<li><p>try-catch-finally如何使用
try后面必须要有catch或者finally；无论是否捕获异常，finally都会执行；当在
<code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code>
语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p>
<ul>
<li><p><strong>不要在 finally 语句块中使用 return!</strong> 当 try
语句和 finally 语句中都有 return 语句时，<strong>try 语句块中的 return
语句会被忽略</strong>。这是因为 try 语句中的 return
返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return
之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      System.out.println(f(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> value * value;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*  </span></span><br><span class="line"><span class="comment">   0</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>finally中的代码不一定执行（如果finally之前虚拟机就已经被终止了）</p>
<ul>
<li>另外两种情况，程序所在的线程死亡；关闭CPU；都会导致代码不执行</li>
</ul></li>
<li><p>使用try-with-resources代替try-catch-finally</p>
<ul>
<li><p>适用范围：任何实现<code>java.lang.AutoCloseable</code>或者<code>java.io.Closeable</code>的对象【比如InputStream、OutputStream、Scanner、PrintWriter等需要调用close()方法的资源】</p></li>
<li><p>在try-with-resources中，任何<strong>catch或finally块在声明的资源关闭后运行</strong></p></li>
<li><p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>改造后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try (Scanner scanner = new Scanner(new File(&quot;test.txt&quot;))) &#123;</span><br><span class="line">    while (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以使用分隔符来分割</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">     <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        bout.write(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>需要注意的地方</p>
<ul>
<li>不要把异常定义为静态变量，因为这样会导致<strong>异常栈信息错乱</strong>。每次手动抛出异常，我们都需要<strong>手动
new 一个异常对象抛出</strong>。</li>
<li>抛出的<strong>异常信息一定要有意义</strong>。</li>
<li>建议抛出<strong>更加具体的异常</strong>比如字符串转换为数字格式错误的时候应该抛出<code>NumberFormatException</code>而不是其父类<code>IllegalArgumentException</code>。</li>
<li>使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。</li>
</ul></li>
</ul>
<h2 id="泛型">泛型</h2>
<ul>
<li><p>什么是泛型？有什么作用
Java泛型（Generics）JDK5中引入的一个新特性，使用泛型参数，可以<strong>增强代码的可读性</strong>以及<strong>稳定性</strong></p></li>
<li><p>编译器可以<strong>对泛型参数进行检测，并通过泛型参数可以指定传入的对象类型</strong>，比如<code>ArrayList&lt;Person&gt; persons=new ArrayList&lt;Person&gt;()</code>这行代码指明该ArrayList对象只能传入Person对象，若传入其他类型的对象则会报错</p>
<ul>
<li>原生List返回类型为Object，需要手动转换类型才能使用，<strong>使用泛型后编译器自动转换</strong></li>
</ul></li>
<li><p>泛型使用方式</p>
<ul>
<li><p>泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>泛型接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不指定类型使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>指定类型使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>泛型方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">   &#123;</span><br><span class="line">         <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">            System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面称为静态方法，Java中泛型只是一个占位符，必须在传递类型后才能使用，类在实例化时才能传递类型参数，而类型方法的加载优先于类的实例化，静态泛型方法是<strong>没有办法使用类上声明的泛型（即上面的第二点中类名旁边的T）</strong>的，只能使用自己声明的<E></p></li>
<li><p>也可以是非静态的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="type">int</span>  <span class="title function_">geA</span><span class="params">(E e)</span>&#123;</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用,其中 &lt;Object&gt; 可以省略</span></span><br><span class="line">    a.&lt;Object&gt;geA(<span class="keyword">new</span> <span class="title class_">Object</span>()); </span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="反射">反射</h2>
<ul>
<li><p>反射赋予了我们在<strong>运行时分析类</strong>以及<strong>执行类中方法</strong>的能力，通过反射可以<strong>获取任意一个类的所有属性和方法</strong></p></li>
<li><p>反射<strong>增加（导致）了安全问题</strong>，可以<strong>无视泛型参数的安全检查</strong>（<strong>泛型参数的安全检查发生在编译期</strong>），不过其对于框架来说实际是影响不大的</p></li>
<li><p>应用场景<br />
一般用于框架中，框架中大量使用了<strong>动态代理</strong>，而<strong>动态代理的实现也依赖于反射</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args); <span class="comment">//通过反射调用方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解也使用到了反射，比如Spring上的@Component注解。
可以<strong>基于反射分析类</strong>，然后<strong>获取到类/属性/方法/方法的参数上的注解</strong>，<strong>获取注解后，做进一步的处理</strong></p></li>
</ul>
<h2 id="注解">注解</h2>
<ul>
<li><p>注解，Java5引入，用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注解本质上是一个继承了Annotation的特殊接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注解只有被解析后才会生效</p>
<ul>
<li><strong>编译期直接扫描</strong> ：编译器在编译 Java
代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code>
注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring
框架的 <code>@Value</code>
、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ul></li>
</ul>
<h2 id="spi">SPI</h2>
<ul>
<li>介绍
<ul>
<li>Service Provider Interface ，服务提供者的接口 ，
专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口</li>
<li>SPI
将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</li>
<li>很多框架都使用了 Java 的 SPI 机制，比如：Spring
框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</li>
<li>SPI扩展实现 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221009101411097.png"
alt="image-20221009101411097" /></li>
</ul></li>
<li>API和SPI区别 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221009101546801.png"
alt="image-20221009101546801" />
<ul>
<li>模块之间通过接口进行通讯，在服务调用方和服务实现方(服务提供者)之间引入一个“接口”
<ul>
<li>当接口和实现，都是放在实现方的时候，这就是API</li>
<li>当接口存在于调用方，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务，即SPI</li>
</ul></li>
</ul></li>
<li>提供了接口设计的灵活性，缺点：
<ul>
<li>需要遍历加载所有的实现类，不能做到按需加载，效率较低</li>
<li>当多个ServiceLoader同时load时，会有并发问题</li>
</ul></li>
</ul>
<h2 id="io">I/O</h2>
<ul>
<li><p>序列化和反序列化</p>
<ul>
<li>序列化：将数据结构或对象换成二级制字节流的过程</li>
<li>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
<li>对于Java，序列化的都是对象（Object），即实例化后的类（Class）</li>
</ul></li>
<li><p>维基</p>
<blockquote>
<p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p>
</blockquote></li>
<li><p>序列化的目的，通过网络传输对象，或者说是将对象存储到文件系统、数据库、内存中
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221009102741094.png"
alt="image-20221009102741094" /></p></li>
<li><p>被<code>transient</code>修饰的变量，不进行序列化：即当对象被反序列化时，被<code>transient</code>修饰的变量值不会被持久化和恢复
<code>transient 英[ˈtrænziənt]</code></p>
<ul>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
<li><code>transient</code>
修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰
<code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li>
<li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有
<code>transient</code> 关键字修饰，均不会被序列化。</li>
</ul></li>
<li><p>JavaIO流</p>
<blockquote>
<p>IO 即
<code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为
IO 流。IO 流在 Java
中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
</blockquote></li>
<li><p>JavaIO流的类都是从如下4个抽象类基类中派生出来的</p>
<ul>
<li><code>InputStream</code>/<code>Reader</code>:
所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream</code>/<code>Writer</code>:
所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul></li>
<li><p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么I/O流操作要分为字节流操作和字符流操作</p>
<ul>
<li>字符流由Java虚拟机将字节转换得到，过程较为耗时</li>
<li>如果不知道编码类型的过，使用字节流的过程中很容易出现乱码</li>
</ul></li>
</ul>
<h2 id="语法糖">语法糖</h2>
<figure class="highlight plaintext"><figcaption><span>英[sɪnˈtæktɪk]``` 句法的</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">指的是为了方便程序员开发程序而设计的一种特殊语法，对编程语言的功能并没有影响，语法糖写出来的代码往往更简单简洁且容易阅读，比如```for-each```，原理：基于普通的for循环和迭代器</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">String[] strs = &#123;&quot;JavaGuide&quot;, &quot;公众号：JavaGuide&quot;, &quot;博客：https://javaguide.cn/&quot;&#125;;</span><br><span class="line">for (String s : strs) &#123;</span><br><span class="line">  	System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JVM 其实并不能识别语法糖，Java
语法糖要想被正确执行，需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成
JVM 认识的基本语法。这也侧面说明，Java 中真正支持语法糖的是 Java
编译器而不是
JVM。如果你去看<code>com.sun.tools.javac.main.JavaCompiler</code>的源码，你会发现在<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的。</p>
</blockquote>
<p>Java中常见的语法糖：<br />
泛型、自动拆装箱、变长参数、枚举、内部类、增强 for
循环、try-with-resources 语法、lambda 表达式等</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java_spi</title>
    <url>/2022/10/12/review/java_guide/java/basic/java_spi/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h3 id="简介">简介</h3>
<p>为了实现在模块装配的时候不用再程序里面动态指明，这就需要一种服务发现机制。JavaSPI就是提供了这样的一个机制：为某个接口寻找服务实现的机制。有点类似IoC的思想，将装配的控制权交到了程序之外</p>
<h3 id="spi介绍">SPI介绍</h3>
<p>SPI，ServiceProviderInterface
使用SPI：Spring框架、数据库加载驱动、日志接口、以及Dubbo的扩展实现</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221012105156504.png"
alt="image-20221012105156504" />
<figcaption aria-hidden="true">image-20221012105156504</figcaption>
</figure>
<p>感觉下面这个图不太对，被调用方应该
一般模块之间都是通过接口进行通讯，</p>
<blockquote>
<p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是
API ，这种接口和实现都是放在实现方的。</p>
<p>当接口存在于调用方这边时，就是 SPI
，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p>
<p>我的理解：被调用方（提供接口的人），调用方（使用接口的人），但是其实这里只把调用方--&gt;使用接口的人
这个关系是对的。</p>
<p>也就是说，正常情况下由被调用方自己提供接口和实现，即API。而现在，由调用方（这里的调用方其实可以理解成上面的被调用方），提供了接口还使用了接口，而由被调用方进行接口实现</p>
</blockquote>
<h3 id="实战演示">实战演示</h3>
<p>SLF4J只是一个日志门面（接口），但是SLF4J的具体实现可以有多种，如：Logback/Log4j/Log4j2等等</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221012160549090.png"
alt="image-20221012160549090" />
<figcaption aria-hidden="true">image-20221012160549090</figcaption>
</figure>
<h4 id="简易版本">简易版本</h4>
<ul>
<li><p>ServiceProviderInterface</p></li>
<li><p>目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">│  service-provider-interface.iml</span><br><span class="line">│</span><br><span class="line">├─.idea</span><br><span class="line">│  │  .gitignore</span><br><span class="line">│  │  misc.xml</span><br><span class="line">│  │  modules.xml</span><br><span class="line">│  └─ workspace.xml</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">    └─edu</span><br><span class="line">        └─jiangxuan</span><br><span class="line">            └─up</span><br><span class="line">                └─spi</span><br><span class="line">                        Logger.java</span><br><span class="line">                        LoggerService.java</span><br><span class="line">                        Main.class</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Logger接口，即SPI
服务提供者接口，后面的服务提供者要针对这个接口进行实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msg)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>LoggerService类，主要是为服务使用者（调用方）提供特定功能，这个类是实现JavaSPI机制的关键所在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LoggerService</span> <span class="variable">SERVICE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggerService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Logger&gt; loggerList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LoggerService</span><span class="params">()</span> &#123;</span><br><span class="line">        ServiceLoader&lt;Logger&gt; loader = ServiceLoader.load(Logger.class);</span><br><span class="line">        List&lt;Logger&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Logger log : loader) &#123;</span><br><span class="line">            list.add(log);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// LoggerList 是所有 ServiceProvider</span></span><br><span class="line">        loggerList = list;</span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// Logger 只取一个</span></span><br><span class="line">            logger = list.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单单例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LoggerService <span class="title function_">getService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SERVICE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;info 中没有发现 Logger 服务提供者&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (loggerList.isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;debug 中没有发现 Logger 服务提供者&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        loggerList.forEach(log -&gt; log.debug(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Main类（服务使用者，调用方）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.spi.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LoggerService</span> <span class="variable">service</span> <span class="operator">=</span> LoggerService.getService();</span><br><span class="line"></span><br><span class="line">        service.info(<span class="string">&quot;Hello SPI&quot;</span>);</span><br><span class="line">        service.debug(<span class="string">&quot;Hello SPI&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 结果</span></span><br><span class="line"><span class="comment">info 中没有发现 Logger 服务提供者 debug 中没有发现 Logger 服务提供者</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>新的项目，来实现Logger接口<br />
项目结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">│  service-provider.iml</span><br><span class="line">│</span><br><span class="line">├─.idea</span><br><span class="line">│  │  .gitignore</span><br><span class="line">│  │  misc.xml</span><br><span class="line">│  │  modules.xml</span><br><span class="line">│  └─ workspace.xml</span><br><span class="line">│</span><br><span class="line">├─lib</span><br><span class="line">│      service-provider-interface.jar</span><br><span class="line">|</span><br><span class="line">└─src</span><br><span class="line">    ├─edu</span><br><span class="line">    │  └─jiangxuan</span><br><span class="line">    │      └─up</span><br><span class="line">    │          └─spi</span><br><span class="line">    │              └─service</span><br><span class="line">    │                      Logback.java</span><br><span class="line">    │</span><br><span class="line">    └─META-INF</span><br><span class="line">        └─services</span><br><span class="line">                edu.jiangxuan.up.spi.Logger</span><br></pre></td></tr></table></figure>
<ul>
<li><p>首先需要有一个实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.spi.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.jiangxuan.up.spi.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logback</span> <span class="keyword">implements</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logback info 打印日志：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logback debug 打印日志：&quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将之前项目打包的jar导入项目中</p></li>
<li><p>之后要<code>src</code> 目录下新建 <code>META-INF/services</code>
文件夹，然后新建文件 <code>edu.jiangxuan.up.spi.Logger</code> （SPI
的全类名），文件里面的内容是：<code>edu.jiangxuan.up.spi.service.Logback</code>
（Logback 的全类名，即 SPI 的实现类的包名 + 类名）</p></li>
</ul></li>
<li><p><strong>这是 JDK SPI 机制 ServiceLoader
约定好的标准。</strong></p>
<blockquote>
<p>Java 中的 SPI 机制就是在每次类加载的时候会先去找到 class 相对目录下的
<code>META-INF</code> 文件夹下的 services
文件夹下的文件，将这个文件夹下面的所有文件先加载到内存中，然后根据这些文件的文件名和里面的文件内容找到相应接口的具体实现类，找到实现类后就可以通过反射去生成对应的对象，保存在一个
list
列表里面，所以可以通过迭代或者遍历的方式拿到对应的实例对象，生成不同的实现。</p>
<p>即：文件名一定要是接口的全类名，然后里面的内容一定要是实现类的全类名，实现类可以有多个，直接换行就好了，多个实现类的时候，会一个一个的迭代加载。</p>
</blockquote>
<ul>
<li>接下来同样将 <code>service-provider</code> 项目打包成 jar 包，这个
jar 包就是服务提供方的实现。通常我们导入 maven 的 pom
依赖就有点类似这种，只不过我们现在没有将这个 jar 包发布到 maven
公共仓库中，所以在需要使用的地方只能手动的添加到项目中</li>
</ul></li>
<li><p>效果展示 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221012171251890.png"
alt="image-20221012171251890" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> edu.jiangxuan.up.spi.LoggerService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJavaSPI</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LoggerService</span> <span class="variable">loggerService</span> <span class="operator">=</span> LoggerService.getService();</span><br><span class="line">        loggerService.info(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        loggerService.debug(<span class="string">&quot;测试Java SPI 机制&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过使用 SPI 机制，可以看出服务（<code>LoggerService</code>）和
服务提供者两者之间的耦合度非常低，如果说我们想要换一种实现，那么其实只需要修改
<code>service-provider</code> 项目中针对 <code>Logger</code>
接口的具体实现就可以了，只需要换一个 jar
包即可，也可以有在一个项目里面有多个实现，这不就是 SLF4J
原理吗？</p></li>
</ul>
<h3 id="serviceloader">ServiceLoader</h3>
<p>JDK 官方给的注释：<strong>一种加载服务实现的工具。</strong></p>
<h4 id="具体实现">具体实现</h4>
<h4 id="自己实现">自己实现</h4>
<p>//个人简易版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> edu.jiangxuan.up.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceLoader</span>&lt;S&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应的接口 Class 模板</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应实现类的 可以有多个，用 List 进行封装</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;S&gt; providers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴露给外部使用的方法，通过调用这个方法可以开始加载自己定制的实现流程。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; MyServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyServiceLoader</span>&lt;&gt;(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">MyServiceLoader</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.service = service;</span><br><span class="line">        <span class="built_in">this</span>.classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        doLoad();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键方法，加载具体实现类的逻辑</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doLoad</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取所有 jar 包里面 META-INF/services 包下面的文件，这个文件名就是接口名，然后文件里面的内容就是具体的实现类的路径加全类名</span></span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader.getResources(<span class="string">&quot;META-INF/services/&quot;</span> + service.getName());</span><br><span class="line">            <span class="comment">// 挨个遍历取到的文件</span></span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                <span class="comment">// 取出当前的文件</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">                System.out.println(<span class="string">&quot;File = &quot;</span> + url.getPath());</span><br><span class="line">                <span class="comment">// 建立链接</span></span><br><span class="line">                <span class="type">URLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> url.openConnection();</span><br><span class="line">                urlConnection.setUseCaches(<span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 获取文件输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line">                <span class="comment">// 从文件输入流获取缓存</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">                <span class="comment">// 从文件内容里面得到实现类的全类名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (className != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 通过反射拿到实现类的实例</span></span><br><span class="line">                    Class&lt;?&gt; clazz = Class.forName(className, <span class="literal">false</span>, classLoader);</span><br><span class="line">                    <span class="comment">// 如果声明的接口跟这个具体的实现类是属于同一类型，（可以理解为Java的一种多态，接口跟实现类、父类和子类等等这种关系。）则构造实例</span></span><br><span class="line">                    <span class="keyword">if</span> (service.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">S</span>&gt; constructor = (Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">S</span>&gt;) clazz.getConstructor();</span><br><span class="line">                        <span class="type">S</span> <span class="variable">instance</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">                        <span class="comment">// 把当前构造的实例对象添加到 Provider的列表里面</span></span><br><span class="line">                        providers.add(instance);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 继续读取下一行的实现类，可以有多个实现类，只需要换行就可以了。</span></span><br><span class="line">                    className = bufferedReader.readLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;读取文件异常。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回spi接口对应的具体实现类列表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;S&gt; <span class="title function_">getProviders</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> providers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过 URL 工具类从 jar 包的 /META-INF/services 目录下面找到对应的文件，</span><br><span class="line">读取这个文件的名称找到对应的 spi 接口，</span><br><span class="line">通过 InputStream 流将文件里面的具体实现类的全类名读取出来，</span><br><span class="line">根据获取到的全类名，先判断跟 spi 接口是否为同一类型，如果是的，那么就通过反射的机制构造对应的实例对象，</span><br><span class="line">将构造出来的实例对象添加到 Providers 的列表中。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么Java中只有值传递</title>
    <url>/2022/10/09/review/java_guide/java/basic/passByValue/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<ul>
<li><p>形参&amp;&amp;实参</p>
<ul>
<li><p>形参(形式参数)，用于传递给函数/方法的参数，必须有确定的值</p></li>
<li><p>实参(实际参数)，用于定义函数/方法，接收实参，不需要有确定的值</p></li>
<li><p>```java String hello = "Hello!"; // hello 为实参 sayHello(hello);
// str 为形参 void sayHello(String str) { System.out.println(str); }
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 值传递&amp;&amp;引用传递</span><br><span class="line"></span><br><span class="line">  - 程序设计将实参传递给方法的方式分为两种，值传递：方法接收实参值的拷贝，会创建副本；引用传递：方法接受的是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参</span><br><span class="line"></span><br><span class="line">- Java中只有值传递，原因：</span><br><span class="line"></span><br><span class="line">  - 传递基本类型参数</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int num1 = 10;</span><br><span class="line">        int num2 = 20;</span><br><span class="line">        swap(num1, num2);</span><br><span class="line">        System.out.println(&quot;num1 = &quot; + num1);</span><br><span class="line">        System.out.println(&quot;num2 = &quot; + num2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void swap(int a, int b) &#123;</span><br><span class="line">        int temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">        System.out.println(&quot;a = &quot; + a);</span><br><span class="line">        System.out.println(&quot;b = &quot; + b);</span><br><span class="line">    &#125;</span><br><span class="line">    //输出</span><br><span class="line">    a = 20</span><br><span class="line">    b = 10</span><br><span class="line">    num1 = 10</span><br><span class="line">    num2 = 20</span><br></pre></td></tr></table></figure></p></li>
<li><p>传递引用类型参数 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">      System.out.println(arr[<span class="number">0</span>]); <span class="comment">//1</span></span><br><span class="line">      change(arr);</span><br><span class="line">      System.out.println(arr[<span class="number">0</span>]);<span class="comment">//0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>change方法的参数，拷贝的是arr(实参)的地址，所以array和arr指向的是同一个数组对象
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221010103143086.png"
alt="image-20221010103143086" /></p></li>
<li><p>传递引用类型参数2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="comment">// 省略构造函数、Getter&amp;Setter方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoZhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小张&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoLi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">    swap(xiaoZhang, xiaoLi);</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaoZhang:&quot;</span> + xiaoZhang.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaoLi:&quot;</span> + xiaoLi.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Person person1, Person person2)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">temp</span> <span class="operator">=</span> person1;</span><br><span class="line">    person1 = person2;</span><br><span class="line">    person2 = temp;</span><br><span class="line">    System.out.println(<span class="string">&quot;person1:&quot;</span> + person1.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;person2:&quot;</span> + person2.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">person1:小李</span><br><span class="line">person2:小张</span><br><span class="line">xiaoZhang:小张</span><br><span class="line">xiaoLi:小李</span><br></pre></td></tr></table></figure>
<p>这里并不会交换xiaoZhang和xiaoLi，只会交换swap方法栈里的person1和person2</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221010103522823.png"
alt="image-20221010103522823" />
<figcaption aria-hidden="true">image-20221010103522823</figcaption>
</figure></li>
</ul></li>
<li><p>小结 Java 中将实参传递给方法（或函数）的方式是
<strong>值传递</strong> ：</p>
<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java代理模式</title>
    <url>/2022/10/10/review/java_guide/java/basic/proxy_pattern/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h3 id="代理模式">代理模式</h3>
<p>使用代理对象来代替对真实对象的访问，就可以在不修改原目标对象的前提下提供额外的功能操作，扩展目标对象的功能，即在目标对象的某个方法执行前后可以增加一些自定义的操作</p>
<h3 id="静态代理">静态代理</h3>
<blockquote>
<p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（*后面会具体演示代码*），非常不灵活（*比如接口一旦新增加方法，目标对象和代理对象都要进行修改*）且麻烦(*需要对每个目标类都单独写一个代理类*）。</strong>
实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说，
<strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的
class 文件。</strong></p>
</blockquote>
<ol type="1">
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义发送短信的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现发送短信的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建代理类并同样实现发送短信的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsProxy</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmsProxy</span><span class="params">(SmsService smsService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method send()&quot;</span>);</span><br><span class="line">        smsService.send(message);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method send()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>();</span><br><span class="line">        <span class="type">SmsProxy</span> <span class="variable">smsProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmsProxy</span>(smsService);</span><br><span class="line">        smsProxy.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">before method <span class="title function_">send</span><span class="params">()</span></span><br><span class="line">send message:java</span><br><span class="line">after method <span class="title function_">send</span><span class="params">()</span></span><br></pre></td></tr></table></figure>
<h3 id="动态代理">动态代理</h3>
<p>从JVM角度来说，动态代理是在<strong>运行时动态生成类字节码</strong>，并<strong>加载到JVM中的</strong>。
SpringAOP和RPC等框架都实现了动态代理</p>
<h4 id="jdk动态代理">JDK动态代理</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义并发送短信的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    String <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JDK动态代理类</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类中的真实对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DebugInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们的动态代理对象调用原方法时，实际上调用的invoke()，然后invoke代替我们调用了被代理对象的原生方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工厂类及实际使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 目标类的类加载器</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">DebugInvocationHandler</span>(target)   <span class="comment">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际使用</span></span><br><span class="line"><span class="type">SmsService</span> <span class="variable">smsService</span> <span class="operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="keyword">new</span> <span class="title class_">SmsServiceImpl</span>());</span><br><span class="line">smsService.send(<span class="string">&quot;java&quot;</span>);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">before method send</span><br><span class="line">send message:java</span><br><span class="line">after method send</span><br></pre></td></tr></table></figure>
<h4 id="cglib动态代理机制">CGLIB动态代理机制</h4>
<p>JDK动态代理问题：只能代理实现了接口的类Spring
的AOP中，如果使用了接口，则使用JDK动态代理；否则采用CGLB</p>
<p>继承</p>
<p>核心是Enhancer类及MethodInterceptor接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Callback</span>&#123;</span><br><span class="line">    <span class="comment">// 拦截被代理类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象，被拦截方法，参数，调用原始方法</p>
<ul>
<li><p>实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个类，及方法拦截器</span></span><br><span class="line"><span class="keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliSmsService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send message:&quot;</span> + message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MethodInterceptor （方法拦截器）</span></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义MethodInterceptor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DebugMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o           代理对象（增强的对象）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args        方法入参</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 用于调用原始方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//调用方法之前，我们可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="comment">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建动态代理增强类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载器</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">DebugMethodInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际使用</span></span><br><span class="line"><span class="type">AliSmsService</span> <span class="variable">aliSmsService</span> <span class="operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class="line">aliSmsService.send(<span class="string">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="对比">对比</h3>
<p>动态代理更为灵活，且不需要实现接口，可以直接代理实现类，并且不需要针对每个对象都创建代理类；一旦添加方法，动态代理类不需要修改；</p>
<p>静态代理：静态代理在编译时就将接口、实现类变成实际的class对象，即运行时生成动态类字节码，并加载到JVM中</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java-reflex</title>
    <url>/2022/10/10/review/java_guide/java/basic/reflex/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h3 id="何为反射">何为反射</h3>
<p>赋予了我们在运行时分析类以及执行类中方法的能力；运行中获取任意一个类的所有属性和方法，以及调用这些方法和属性</p>
<h3 id="应用场景">应用场景</h3>
<p>Spring/Spring Boot 、MyBatis等框架都用了大量反射机制，以下为</p>
<ul>
<li><p>JDK动态代理</p>
<ul>
<li><p>接口及实现类</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarImpl</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;car running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>代理类 及main方法使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line">  <span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line">  <span class="comment">//JDK动态代理代理类 </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">      <span class="comment">//真实类的对象</span></span><br><span class="line">      <span class="keyword">private</span> Object car;</span><br><span class="line">      <span class="comment">//构造方法赋值给真实的类</span></span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">CarHandler</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.car = obj;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//代理类执行方法时，调用的是这个方法</span></span><br><span class="line">      <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">          <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(car, args);</span><br><span class="line">          System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//main方法使用</span></span><br><span class="line">  <span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">CarImpl</span> <span class="variable">carImpl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarImpl</span>();</span><br><span class="line">          <span class="type">CarHandler</span> <span class="variable">carHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CarHandler</span>(carImpl);</span><br><span class="line">          <span class="type">Car</span> <span class="variable">proxy</span> <span class="operator">=</span> (Car)Proxy.newProxyInstance(</span><br><span class="line">                  main.class.getClassLoader(), <span class="comment">//第一个参数，获取ClassLoader</span></span><br><span class="line">                  carImpl.getClass().getInterfaces(), <span class="comment">//第二个参数，获取被代理类的接口</span></span><br><span class="line">                  carHandler);<span class="comment">//第三个参数，一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</span></span><br><span class="line">          proxy.run();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">before</span><br><span class="line">car running</span><br><span class="line">after</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>Cglib动态代理（没有实现接口的Car</p>
<ul>
<li><p>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CarNoInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;car running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>cglib代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object car;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 创建代理对象 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(Object object)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.car = object;  </span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();  </span><br><span class="line">        enhancer.setSuperclass(<span class="built_in">this</span>.car.getClass());  </span><br><span class="line">        <span class="comment">// 回调方法  </span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);  </span><br><span class="line">        <span class="comment">// 创建代理对象  </span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args,MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;事物开始&quot;</span>);  </span><br><span class="line">        proxy.invokeSuper(obj, args);  </span><br><span class="line">        System.out.println(<span class="string">&quot;事物结束&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line">        <span class="type">CglibProxy</span> <span class="variable">cglibProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CglibProxy</span>();</span><br><span class="line">        <span class="type">CarNoInterface</span> <span class="variable">carNoInterface</span> <span class="operator">=</span> (CarNoInterface)cglibProxy.getInstance(<span class="keyword">new</span> <span class="title class_">CarNoInterface</span>());</span><br><span class="line">        carNoInterface.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">事物开始</span><br><span class="line">car running</span><br><span class="line">事物结束</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>我们可以基于反射分析类，然后获取到类/属性/方法/方法参数上的注解，之后做进一步的处理</p></li>
<li><p>反射机制的优缺点</p>
<ul>
<li>优点<br />
让代码更加灵活</li>
<li>确定，增加安全问题，可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时，且性能较差）</li>
</ul></li>
<li><p>反射实战</p>
<ul>
<li><p>获取Class对象的几种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class;<span class="comment">//第一种</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);<span class="comment">//第二种</span></span><br><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass(); <span class="comment">//第三种</span></span><br><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>); <span class="comment">//第4种，通过类加载器获取Class对象不会进行初始化，意味着不进行包括初始化等一系列操作，静态代码块和静态对象不会得到执行</span></span><br></pre></td></tr></table></figure></li>
<li><p>反射的基本操作 例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TargetObject</span><span class="params">()</span> &#123;</span><br><span class="line">        value = <span class="string">&quot;JavaGuide&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I love &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;value is &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过反射操作这个类的方法以及参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.javaguide;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; targetClass = Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br><span class="line">        <span class="type">TargetObject</span> <span class="variable">targetObject</span> <span class="operator">=</span> (TargetObject) targetClass.newInstance();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取 TargetObject 类中定义的所有方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Method[] methods = targetClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定方法并调用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">publicMethod</span> <span class="operator">=</span> targetClass.getDeclaredMethod(<span class="string">&quot;publicMethod&quot;</span>,</span><br><span class="line">                String.class);</span><br><span class="line"></span><br><span class="line">        publicMethod.invoke(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定参数并对参数进行修改</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> targetClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">//为了对类中的参数进行修改我们取消安全检查</span></span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(targetObject, <span class="string">&quot;JavaGuide&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用 private 方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">privateMethod</span> <span class="operator">=</span> targetClass.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">        <span class="comment">//为了调用private方法我们取消安全检查</span></span><br><span class="line">        privateMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        privateMethod.invoke(targetObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">publicMethod</span><br><span class="line">privateMethod</span><br><span class="line">I love JavaGuide</span><br><span class="line">value is JavaGuide</span><br></pre></td></tr></table></figure></li>
<li></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java序列化详解</title>
    <url>/2022/10/10/review/java_guide/java/basic/serialize/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h3 id="什么是序列化什么是反序列化">什么是序列化？什么是反序列化</h3>
<p>当需要持久化Java对象，比如将Java对象保存在文件中、或者在网络中传输Java对象，这些场景都需要用到序列化</p>
<p>即：</p>
<ul>
<li>序列化：将数据结构/对象，转换成二进制字节流</li>
<li>反序列化：将在序列化过程中所生成的二进制字节流的过程，转换成数据结构或者对象的过程</li>
</ul>
<p>对于Java，序列化的是对象(Object)，也就是实例化后的类(Class)</p>
<p>序列化的目的，是通过网络传输对象，或者说是将对象存储到文件系统、数据库、内存中，如图：
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221010105218691.png"
alt="image-20221010105218691" /></p>
<h3 id="实际场景">实际场景</h3>
<ul>
<li>对象在<strong><u>进行网络传输（比如远程方法调用 RPC
的时候）之前</u></strong>需要先被序列化，<u><strong>接收到</strong></u>序列化的对象<u><strong>之后</strong></u>需要再进行<u><strong>反序列化</strong></u>；</li>
<li>将对象<u><strong>存储到文件中</strong></u>的时候需要进行序列化，将对象从文件中读取出来需要进行反序列化。</li>
<li>将<strong><u>对象存储到缓存数据库（如
Redis）时需要用到序列化</u></strong>，将对象<strong><u>从缓存数据库中读取</u></strong>出来需要反序列化</li>
</ul>
<h3 id="序列化协议对于tcpip-4层模型的哪一层">序列化协议对于TCP/IP
4层模型的哪一层</h3>
<p>4层包括，网络接口层，网络层，传输层，应用层 如下图所示：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221010110650054.png"
alt="image-20221010110650054" /></p>
<p>OSI七层协议模型中，表示层就是对应用层的用户数据，进行处理转换成二进制流；反过来的话，就是将二进制流转换成应用层的用户数据，即序列化和反序列化，所以<strong>序列化协议属于应用层</strong></p>
<h3 id="常见序列化协议对比">常见序列化协议对比</h3>
<p>kryo 英音 [k'rɪəʊ]
，除了JDK自带的序列化，还有hessian、kryo、protostuff</p>
<ul>
<li><p>JDK自带的序列化，只需要实现java.io.Serializable接口即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1905122041950251207L</span>;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">    <span class="keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>serialVersionUID用于版本控制，会被写入二进制序列，反序列化如果发现和当前类不一致则会抛出InvalidClassException异常。一般不使用JDK自带序列化，1
不支持跨语言调用 2 性能差，序列化之后字节数组体积过大</p></li>
<li><p>Kryo
由于变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小字节码体积，代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年05月13日 19:29:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(Object obj) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">             <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(byteArrayOutputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// Object-&gt;byte:将对象序列化为byte数组</span></span><br><span class="line">            kryo.writeObject(output, obj);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Serialization failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">             <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(byteArrayInputStream)) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// byte-&gt;Object:从byte数组中反序列化出对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> clazz.cast(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Deserialization failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Protobuf 出自google</p></li>
<li><p>ProtoStuff，更为易用</p></li>
<li><p>hessian，轻量级的自定义描述的二进制RPC协议，跨语言，hessian2，为阿里修改过的hessian
lite，是dubbo RPC默认启用的序列化方式</p></li>
<li><p>总结</p>
<ul>
<li>如果不需要跨语言可以考虑Kryo</li>
<li>Protobuf，ProtoStuff，hessian支持跨语言</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>语法糖</title>
    <url>/2022/10/12/review/java_guide/java/basic/syntactic_sugar/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="简介">简介</h2>
<p>语法糖（Syntactic
Sugar）也称糖衣语法，指的是在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用，简而言之，让程序更加简洁，有更高的可读性</p>
<h2 id="java中有哪些语法糖">Java中有哪些语法糖</h2>
<p>Java虚拟机并不支持这些语法糖，这些语法糖在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖</p>
<ul>
<li><code>javac</code>命令可以将后缀为<code>.java</code>的源文件编译为后缀名为<code>.class</code>的可以运行于Java虚拟机的字节码。其中，<code>com.sun.tools.javac.main.JavaCompiler</code>的源码中，<code>compile()</code>中有一个步骤就是调用<code>desugar()</code>，这个方法就是负责解语法糖的实现的</li>
<li>Java中的语法糖，包括
泛型、变长参数、条件编译、自动拆装箱、内部类等</li>
</ul>
<h3 id="switch支持string与枚举">switch支持String与枚举</h3>
<p>switch本身原本只支持基本类型，如char、byte、short、int及其封装类，以及String、enum
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221013110105262.png"
alt="image-20221013110105262" /></p>
<p>int是数值，而char转ascii码，所以其实对于编译器来说，都是int类型(整型)
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221013111130070.png"
alt="image-20221013111130070" /></p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221013111255889.png"
alt="image-20221013111255889" /> 而对于enum类型，<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221013111642816.png"
alt="image-20221013111642816" /></p>
<p>对于switch中使用String，则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">switchDemoString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反编译之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">switchDemoString</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">switchDemoString</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">switch</span>((s = str).hashCode())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">113318802</span>:</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;world&quot;</span>))</span><br><span class="line">                System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即switch判断是通过equals()和hashCode()方法来实现的</p>
<p>equals()检查是必要的，因为有可能发生碰撞，所以性能没有直接使用枚举进行switch或纯整数常量性能高</p>
<h3 id="泛型">泛型</h3>
<p>编译器处理泛型有两种方式：<code>Code specialization</code>和<code>Code sharing</code>。C++和
C#是使用<code>Code specialization</code>的处理机制，而 Java
使用的是<code>Code sharing</code>的机制</p>
<blockquote>
<p>Code sharing
方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（<code>type erasue</code>）实现的。</p>
</blockquote>
<p>两个例子</p>
<ul>
<li><p>Map擦除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hollis&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wechat&quot;</span>, <span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;blog&quot;</span>, <span class="string">&quot;www.hollischuang.com&quot;</span>);</span><br><span class="line"><span class="comment">//解语法糖之后</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;hollis&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;wechat&quot;</span>, <span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;blog&quot;</span>, <span class="string">&quot;www.hollischuang.com&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>其他擦除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;A <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;A&gt;&gt; A <span class="title function_">max</span><span class="params">(Collection&lt;A&gt; xs)</span> &#123;</span><br><span class="line">    Iterator&lt;A&gt; xi = xs.iterator();</span><br><span class="line">    <span class="type">A</span> <span class="variable">w</span> <span class="operator">=</span> xi.next();</span><br><span class="line">    <span class="keyword">while</span> (xi.hasNext()) &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">x</span> <span class="operator">=</span> xi.next();</span><br><span class="line">        <span class="keyword">if</span> (w.compareTo(x) &lt; <span class="number">0</span>)</span><br><span class="line">            w = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//擦除后变成</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Comparable <span class="title function_">max</span><span class="params">(Collection xs)</span>&#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">xi</span> <span class="operator">=</span> xs.iterator();</span><br><span class="line">    <span class="type">Comparable</span> <span class="variable">w</span> <span class="operator">=</span> (Comparable)xi.next();</span><br><span class="line">    <span class="keyword">while</span>(xi.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">x</span> <span class="operator">=</span> (Comparable)xi.next();</span><br><span class="line">        <span class="keyword">if</span>(w.compareTo(x) &lt; <span class="number">0</span>)</span><br><span class="line">            w = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>小结</p>
<ul>
<li>虚拟机中并不存在泛型，泛型类没有自己独有的Class类对象，即不存在List<String>.class
或是 List<Integer>.class ，而只有List.class</li>
<li>虚拟机中，只有普通类和普通方法，所有泛型类的类型参数，在编译时都会被擦除</li>
</ul></li>
</ul>
<h3 id="自动装箱与拆箱">自动装箱与拆箱</h3>
<ul>
<li><p>装箱过程，通过调用<strong>包装器的valueOf</strong>方法实现的，而拆箱过程，则是通过调用<strong>包装器的xxxValue</strong>方法实现的</p></li>
<li><p>自动装箱</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反编译后的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> Integer.valueOf(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自动拆箱</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反编译后的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i.intValue(); <span class="comment">//注意，是intValue，不是initValue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="可变长参数">可变长参数</h3>
<p>variable arguments，是在Java
1.5中引入的一个特性，允许一个方法把任意数量的值作为参数，代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">&quot;Holis&quot;</span>, <span class="string">&quot;公众号:Hollis&quot;</span>, <span class="string">&quot;博客：www.hollischuang.com&quot;</span>, <span class="string">&quot;QQ：907607222&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... strs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反编译后代码</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;</span><br><span class="line">        <span class="string">&quot;Holis&quot;</span>, <span class="string">&quot;\u516C\u4F17\u53F7:Hollis&quot;</span>, <span class="string">&quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;</span>, <span class="string">&quot;QQ\uFF1A907607222&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String strs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++)</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，可变参数在被使用的时候，会创建一个数组，数组的长度，就是调用该方法的传递的实参的个数，然后再把参数值全部放到这个数组当中，最后把这个数组作为参数传递到被调用的方法中</p>
<h3 id="枚举">枚举</h3>
<p>关键字<code>enum</code>可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能</p>
<p>写一个enum类进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    SPRING,SUMMER;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反编译之后</span></span><br><span class="line"><span class="comment">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span></span><br><span class="line"><span class="comment">// Jad home page: http://www.kpdus.com/jad.html</span></span><br><span class="line"><span class="comment">// Decompiler options: packimports(3) </span></span><br><span class="line"><span class="comment">// Source File Name:   T.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.ly.review.base;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Enum</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    下面这个和博客不太一样,博客里面是这样的</span></span><br><span class="line"><span class="comment">//    ENUM$VALUES是博客编译后的数组名</span></span><br><span class="line"><span class="comment">    public static T[] values()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        T at[];</span></span><br><span class="line"><span class="comment">        int i;</span></span><br><span class="line"><span class="comment">        T at1[];</span></span><br><span class="line"><span class="comment">        System.arraycopy(at = ENUM$VALUES, 0, at1 = new T[i = at.length], 0, i);</span></span><br><span class="line"><span class="comment">        return at1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T <span class="title function_">valueOf</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (T)Enum.valueOf(com/ly/review/base/T, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">T</span><span class="params">(String s, <span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T Spring;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> T SUMMER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> T $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Spring = <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;Spring&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        SUMMER = <span class="keyword">new</span> <span class="title class_">T</span>(<span class="string">&quot;SUMMER&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> <span class="title class_">T</span>[] &#123;</span><br><span class="line">            Spring, SUMMER</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重要代码：</p>
<ol type="1">
<li><p><code>public final class T extends Enum</code>
说明该类不可继承</p></li>
<li><p>```java public static final T Spring; public static final T
SUMMER; <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   说明枚举类型不可修改</span><br><span class="line"></span><br><span class="line">### 内部类</span><br><span class="line"></span><br><span class="line">内部类又称为嵌套类，可以把内部类理解成外部类的一个普通成员</span><br><span class="line">**内部类之所以也是语法糖，是因为它仅仅是一个编译时的概念，`outer.java`里面定义了一个内部类`inner`，一旦编译成功，就会生成两个完全不同的`.class`文件了，分别是`outer.class`和`outer$inner.class`。所以内部类的名字完全可以和它的外部类名字相同。**</span><br><span class="line"></span><br><span class="line">代码如下：  </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class OutterClass &#123;</span><br><span class="line">    private String userName;</span><br><span class="line"></span><br><span class="line">    public String getUserName() &#123;</span><br><span class="line">        return userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class InnerClass&#123;</span><br><span class="line">        private String name;</span><br><span class="line"></span><br><span class="line">        public String getName() &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setName(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>编译之后，会生成两个class文件OutterClass.class和OutterClass<span
class="math inline">\(InnerClass.class。所以内部类是可以跟外部类完全一样的名字的
如果要对OutterClass.class进行反编译，那么他会把OutterClass\)</span>InnerClass.class也一起进行反编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutterClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">final</span> OutterClass <span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        InnerClass()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span> = OutterClass.<span class="built_in">this</span>;</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OutterClass</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserName</span><span class="params">(String userName)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args1[])</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件编译">条件编译</h3>
<p>—般情况下，程序中的每一行代码都要参加编译。但有时候出于<strong>对程序代码优化的考虑</strong>，希望只对其中一部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionalCompilation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">DEBUG</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(DEBUG) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, DEBUG!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">ONLINE</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ONLINE)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, ONLINE!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反编译之后如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionalCompilation</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConditionalCompilation</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">DEBUG</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, DEBUG!&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ONLINE</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Java 语法的条件编译，是通过判断条件为常量的 if
语句实现的。其原理也是 Java 语言的语法糖。根据 if
判断条件的真假，编译器直接把分支为 false
的代码块消除。通过该方式实现的条件编译，必须在方法体内实现，而无法在正整个
Java 类的结构或者类的属性上进行条件编译</strong></p>
<h3 id="断言">断言</h3>
<p>Java
在执行的时候默认是不启动断言检查的（这个时候，所有的断言语句都将忽略！），如果要开启断言检查，则需要用开关<code>-enableassertions</code>或<code>-ea</code>来开启</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssertTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">assert</span> <span class="variable">a</span> <span class="operator">=</span>= b;</span><br><span class="line">        System.out.println(<span class="string">&quot;公众号：Hollis&quot;</span>);</span><br><span class="line">        <span class="keyword">assert</span> a != b : <span class="string">&quot;Hollis&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;博客：www.hollischuang.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反编译之后代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AssertTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">AssertTest</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!$assertionsDisabled &amp;&amp; a != b)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!$assertionsDisabled &amp;&amp; a == b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">&quot;Hollis&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">$assertionsDisabled</span> <span class="operator">=</span> !com/hollis/suguar/AssertTest.desiredAssertionStatus();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>断言的底层是if语言，如果断言为true，则什么都不做；如果断言为false，则程序抛出AssertError来打断程序执行</li>
<li>-enableassertions会设置$assertionsDisabled字段的值</li>
</ul>
<h3 id="数值字面量">数值字面量</h3>
<p>java7中，字面量允许在数字之间插入任意多个下划线，不会对字面值产生影响，可以方便阅读</p>
<p>源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10_000</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反编译后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-each">for-each</h3>
<p>源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    String[] strs = &#123;<span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;公众号：Hollis&quot;</span>, <span class="string">&quot;博客：www.hollischuang.com&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; strList = ImmutableList.of(<span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;公众号：Hollis&quot;</span>, <span class="string">&quot;博客：www.hollischuang.com&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : strList) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反编译之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    String strs[] = &#123;</span><br><span class="line">        <span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;</span>, <span class="string">&quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    String args1[] = strs;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> args1.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> args1[j];</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">List</span> <span class="variable">strList</span> <span class="operator">=</span> ImmutableList.of(<span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;\u516C\u4F17\u53F7\uFF1AHollis&quot;</span>, <span class="string">&quot;\u535A\u5BA2\uFF1Awww.hollischuang.com&quot;</span>);</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> strList.iterator(); iterator.hasNext(); System.out.println(s))</span><br><span class="line">        s = (String)iterator.next();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会改成普通的for语句循环，或者使用迭代器</p>
<h3 id="try-with-resource">try-with-resource</h3>
<p>关闭资源的方式，就是再finally块里释放，即调用close方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正常使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String line;</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:\\hollischuang.xml&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK7之后提供的关闭资源的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:\\ hollischuang.xml&quot;</span>))) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        BufferedReader br;</span><br><span class="line">        Throwable throwable;</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:\\ hollischuang.xml&quot;</span>));</span><br><span class="line">        throwable = <span class="literal">null</span>;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)</span><br><span class="line">                System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Throwable throwable2)</span><br><span class="line">        &#123;</span><br><span class="line">            throwable = throwable2;</span><br><span class="line">            <span class="keyword">throw</span> throwable2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(br != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">if</span>(throwable != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(Throwable throwable1)</span><br><span class="line">                &#123;</span><br><span class="line">                    throwable.addSuppressed(throwable1);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                br.close();</span><br><span class="line">            <span class="keyword">break</span> MISSING_BLOCK_LABEL_113;</span><br><span class="line">            Exception exception;</span><br><span class="line">            exception;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">if</span>(throwable != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        br.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span>(Throwable throwable3)</span><br><span class="line">                      &#123;</span><br><span class="line">                        throwable.addSuppressed(throwable3);</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    br.close();</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">        IOException ioexception;</span><br><span class="line">        ioexception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是我们没有做关闭的操作，编译器都帮我们做了</p>
<h3 id="lambda表达">Lambda表达</h3>
<ul>
<li><p>使用lambda表达式便利list</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; strList = ImmutableList.of(<span class="string">&quot;Hollis&quot;</span>, <span class="string">&quot;公众号：Hollis&quot;</span>, <span class="string">&quot;博客：www.hollischuang.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    strList.forEach( s -&gt; &#123; System.out.println(s); &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">/* varargs */</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String ... args)</span> &#123;</span><br><span class="line">    <span class="type">ImmutableList</span> <span class="variable">strList</span> <span class="operator">=</span> ImmutableList.of((Object)<span class="string">&quot;Hollis&quot;</span>, (Object)<span class="string">&quot;\u516c\u4f17\u53f7\uff1aHollis&quot;</span>, (Object)<span class="string">&quot;\u535a\u5ba2\uff1awww.hollischuang.com&quot;</span>);</span><br><span class="line">    strList.forEach((Consumer&lt;String&gt;)LambdaMetafactory.metafactory(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, (Ljava/lang/Object;)V, lambda$main$<span class="number">0</span>(java.lang.String ), (Ljava/lang/String;)V)());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="keyword">void</span> lambda$main$<span class="number">0</span>(String s) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>lambda表达式的实现其实是依赖了一些底层的api，在编译阶段，会把lambda表达式进行解糖，转换成调用内部api的方式</p></li>
</ul>
<h2 id="可能遇到的坑">可能遇到的坑</h2>
<h3 id="泛型-1">泛型</h3>
<ul>
<li><p>泛型的类型参数不能用在 Java 异常处理的 catch
语句中。因为异常处理是由 JVM 在运行时刻来进行的。由于类型信息被擦除，JVM
是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的</p></li>
<li><p>泛型类的所有静态变量是共享的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        GT&lt;Integer&gt; gti = <span class="keyword">new</span> <span class="title class_">GT</span>&lt;Integer&gt;();</span><br><span class="line">        gti.<span class="keyword">var</span>=<span class="number">1</span>;</span><br><span class="line">        GT&lt;String&gt; gts = <span class="keyword">new</span> <span class="title class_">GT</span>&lt;String&gt;();</span><br><span class="line">        gts.<span class="keyword">var</span>=<span class="number">2</span>;</span><br><span class="line">        System.out.println(gti.<span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GT</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="keyword">var</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nothing</span><span class="params">(T x)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自动装箱与拆箱-1">自动装箱与拆箱</h3>
<p>对于自动装箱，整形对象通过使用相同的缓存和重用，适用于整数值区间 [
-128，+127 ]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;a == b is &quot;</span> + (a == b));</span><br><span class="line">    System.out.println((<span class="string">&quot;c == d is &quot;</span> + (c == d)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">a == b is <span class="type">false</span></span><br><span class="line"><span class="variable">c</span> <span class="operator">=</span>= d is <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="增强for循环">增强for循环</h3>
<p>遍历时不要使用list的remove方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Student stu : students) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stu.getId() == <span class="number">2</span>)</span><br><span class="line">        students.remove(stu);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会报ConcurrentModificationException异常，Iterator在工作的时候不允许被迭代的对象被改变，但可以使用Iterator本身的remove()来删除对象，会在删除当前对象的同时，维护索引的一致性</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>unsafe类</title>
    <url>/2022/10/10/review/java_guide/java/basic/unsafe_class/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<p><code>sun.misc.Unsafe</code></p>
<p>提供执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，效率快，但由于有了操作内存空间的能力，会增加指针问题风险。且这些功能的实现依赖于本地方法，Java代码中只是声明方法头，具体实现规则交给本地代码
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221010172203732.png"
alt="image-20221010172203732" /></p>
<h3 id="为什么要使用本地方法">为什么要使用本地方法</h3>
<ul>
<li>需要用到Java中不具备的依赖于操作系统的特性，跨平台的同时要实现对底层控制</li>
<li>对于其他语言已经完成的现成功能，可以使用Java调用</li>
<li>对时间敏感/性能要求非常高，有必要使用更为底层的语言</li>
</ul>
<p>对于同一本地方法，不同的操作系统可能通过不同的方式来实现的</p>
<h3 id="unsafe创建">Unsafe创建</h3>
<p>sun.misc.Unsafe部分源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line">  <span class="comment">// 单例对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//Sensitive : 敏感的 英[ˈsensətɪv]</span></span><br><span class="line">  <span class="meta">@CallerSensitive</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 仅在引导类加载器`BootstrapClassLoader`加载时才合法</span></span><br><span class="line">    <span class="keyword">if</span>(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会先判断当前类是否由Bootstrap
classloader加载。即只有启动类加载器加载的类才能够调用Unsafe类中的方法</p>
<p>如何使用<code>Unsafe</code>这个类</p>
<ol type="1">
<li><p>利用反射获得Unsafe类中已经实例化完成的单例对象<code>theUnsafe</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title function_">reflectGetUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">      field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(e.getMessage(), e);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过Java命令行命令<code>-Xbootclasspath/a</code>把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -Xbootclasspath/a: $&#123;path&#125;   <span class="comment">// 其中path为调用Unsafe相关方法的类所在jar包路径</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="unsafe功能">Unsafe功能</h3>
<p>内存操作、内存屏障、对象操作、数据操作、CAS操作、线程调度、Class操作、系统信息</p>
<h4 id="内存操作">内存操作</h4>
<p>相关方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分配新的本地空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">allocateMemory</span><span class="params">(<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//重新调整内存空间的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">reallocateMemory</span><span class="params">(<span class="type">long</span> address, <span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//将内存设置为指定值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> bytes, <span class="type">byte</span> value)</span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">copyMemory</span><span class="params">(Object srcBase, <span class="type">long</span> srcOffset,Object destBase, <span class="type">long</span> destOffset,<span class="type">long</span> bytes)</span>;</span><br><span class="line"><span class="comment">//清除内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">freeMemory</span><span class="params">(<span class="type">long</span> address)</span>;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">memoryTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">addr</span> <span class="operator">=</span> unsafe.allocateMemory(size);</span><br><span class="line">    <span class="type">long</span> <span class="variable">addr3</span> <span class="operator">=</span> unsafe.reallocateMemory(addr, size * <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;addr: &quot;</span>+addr);</span><br><span class="line">    System.out.println(<span class="string">&quot;addr3: &quot;</span>+addr3);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//向每个字节，写入1 首先使用allocateMemory方法申请 4 字节长度的内存空间，在循环中调用setMemory方法向每个字节写入内容为byte类型的 1</span></span><br><span class="line">        unsafe.setMemory(<span class="literal">null</span>,addr ,size,(<span class="type">byte</span>)<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            unsafe.copyMemory(<span class="literal">null</span>,addr,<span class="literal">null</span>,addr3+size*i,<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(unsafe.getInt(addr));</span><br><span class="line">        System.out.println(unsafe.getLong(addr3));</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        unsafe.freeMemory(addr);</span><br><span class="line">        unsafe.freeMemory(addr3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">addr: <span class="number">2433733895744</span></span><br><span class="line">addr3: <span class="number">2433733894944</span></span><br><span class="line"><span class="number">16843009</span></span><br><span class="line"><span class="number">72340172838076673</span></span><br></pre></td></tr></table></figure>
<p>对于setMemory的解释 <a
href="https://www.cnblogs.com/throwable/p/9139947.html">来源</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> bytes, <span class="type">byte</span> value)</span>; 将给定内存块中的所有字节设置为固定值(通常是<span class="number">0</span>)。内存块的地址由对象引用o和偏移地址共同决定，如果对象引用o为<span class="literal">null</span>，offset就是绝对地址。第三个参数就是内存块的大小，如果使用allocateMemory进行内存开辟的话，这里的值应该和allocateMemory的参数一致。value就是设置的固定值，一般为<span class="number">0</span>(这里可以参考netty的DirectByteBuffer)。一般而言，o为<span class="literal">null</span>，所有有个重载方法是<span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(<span class="type">long</span> offset, <span class="type">long</span> bytes, <span class="type">byte</span> value)</span>;，等效于setMemory(<span class="literal">null</span>, <span class="type">long</span> offset, <span class="type">long</span> bytes, <span class="type">byte</span> value);。</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<blockquote>
<p>分析一下运行结果，首先使用<code>allocateMemory</code>方法申请 4
字节长度的内存空间，在循环中调用<code>setMemory</code>方法向每个字节写入内容为<code>byte</code>类型的
1，当使用 Unsafe
调用<code>getInt</code>方法时，因为一个<code>int</code>型变量占 4
个字节，会一次性读取 4
个字节，组成一个<code>int</code>的值，对应的十进制结果为 16843009。</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221011114456296.png"
alt="image-20221011114456296" />
<figcaption aria-hidden="true">image-20221011114456296</figcaption>
</figure>
<p>对于reallocateMemory方法：</p>
<blockquote>
<p>在代码中调用<code>reallocateMemory</code>方法重新分配了一块 8
字节长度的内存空间，通过比较<code>addr</code>和<code>addr3</code>可以看到和之前申请的内存地址是不同的。在代码中的第二个
for
循环里，调用<code>copyMemory</code>方法进行了两次内存的拷贝，每次拷贝内存地址<code>addr</code>开始的
4
个字节，分别拷贝到以<code>addr3</code>和<code>addr3+4</code>开始的内存空间上：</p>
<p>拷贝完成后，使用<code>getLong</code>方法一次性读取8个字节，得到long类型的值</p>
<p>这种分配属于堆外内存，无法进行垃圾回收，需要我们把这些内存当作资源去手动调用freeMemory方法进行释放，否则会产生内存泄漏。通常是try-finally进行内存释放</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221011141135430.png"
alt="image-20221011141135430" />
<figcaption aria-hidden="true">image-20221011141135430</figcaption>
</figure>
<ul>
<li><p>为什么使用堆外内存</p>
<ul>
<li>对垃圾回收停顿的改善，堆外内存直接受操作系统管理而不是JVM</li>
<li>提升程序I/O操作的性能。通常I/O通信过程中，存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间的数据拷贝且生命周期较短的暂存数据，建议都存储到堆外内存</li>
</ul></li>
<li><p>典型应用
DirectByteBuffer，Java用于实现堆外内存的重要类，对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DirectByteBuffer类源</span></span><br><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 分配内存并返回基地址</span></span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内存初始化</span></span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跟踪 DirectByteBuffer 对象的垃圾回收，以实现堆外内存释放</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap));</span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="内存屏障">内存屏障</h4>
<ul>
<li><p>介绍</p>
<ul>
<li>编译器和 CPU
会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能</li>
<li>后果是，导致 CPU 的高速缓存和内存中数据的不一致</li>
<li>内存屏障（<code>Memory Barrier</code>）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况</li>
</ul></li>
<li><p>Unsafe提供了三个内存屏障相关方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>以loadFence方法为例，会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载
在某个线程修改Runnable中的flag</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChangeThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">/**volatile**/</span> <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;subThread change flag to:&quot;</span> + flag);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主线程的while循环中，加入内存屏障，测试是否能感知到flag的修改变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">ChangeThread</span> <span class="variable">changeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangeThread</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(changeThread).start();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> changeThread.isFlag();</span><br><span class="line">        unsafe.loadFence(); <span class="comment">//加入读内存屏障</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;detected flag changed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;main thread end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">subThread change flag to:<span class="literal">false</span></span><br><span class="line">detected flag changed</span><br><span class="line">main thread end</span><br></pre></td></tr></table></figure></li>
<li><p>如果删除上面的loadFence()方法，就会出现下面的情况，主线程无法感知flag发生的变化，会一直在while中循环
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221011163035365.png"
alt="image-20221011163035365" /></p></li>
<li><p>典型应用
Java8新引入的锁---<code>StampedLock</code>，乐观锁，类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少的”饥饿“现象。由于StampedLock提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存load到线程工作内存时，存在数据不一致的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validate</span><span class="params">(<span class="type">long</span> stamp)</span> &#123;</span><br><span class="line">   U.loadFence();</span><br><span class="line">   <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="对象操作">对象操作</h4>
<ul>
<li><p>对象属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在对象的指定偏移地址获取一个对象引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">getObject</span><span class="params">(Object o, <span class="type">long</span> offset)</span>;</span><br><span class="line"><span class="comment">//在对象指定偏移地址写入一个对象引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">putObject</span><span class="params">(Object o, <span class="type">long</span> offset, Object x)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>对象实例化 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b =<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">objTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    A a1=<span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    System.out.println(a1.getB());</span><br><span class="line">    <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> A.class.newInstance();</span><br><span class="line">    System.out.println(a2.getB());</span><br><span class="line">    A a3= (A) unsafe.allocateInstance(A.class);</span><br><span class="line">    System.out.println(a3.getB());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>打印结果分别为
1、1、0，说明通过<code>allocateInstance</code>方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了<code>Class</code>对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将
A
类的构造函数改为<code>private</code>类型，将无法通过构造函数和反射创建对象，但<code>allocateInstance</code>方法仍然有效。</p>
</blockquote></li>
<li><p>典型应用</p>
<ul>
<li>常规对象实例化方式，从本质上来说，都是通过new机制来实现对象的创建</li>
<li>非常规的实例化方式：Unsafe中提供allocateInstance方法，仅通过Class对象就可以创建此类的实例对象</li>
</ul></li>
</ul>
<h4 id="数组操作">数组操作</h4>
<ul>
<li><p>介绍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面两个方法配置使用，即可定位数组中每个元素在内存中的位置</span></span><br><span class="line"><span class="comment">//返回数组中第一个元素的偏移地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">arrayBaseOffset</span><span class="params">(Class&lt;?&gt; arrayClass)</span>;</span><br><span class="line"><span class="comment">//返回数组中一个元素占用的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">arrayIndexScale</span><span class="params">(Class&lt;?&gt; arrayClass)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>典型应用</p></li>
</ul>
<h4 id="cas操作">CAS操作</h4>
<ul>
<li><p>相关操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	*  CAS</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> o         包含要修改field的对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> offset    对象中某field的偏移量</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> expected  期望值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> update    更新值</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>          true | false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset,  Object expected, Object update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected,<span class="type">int</span> update)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> update)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>CAS，AS 即比较并替换（Compare And
Swap)，是实现并发算法时常用到的一种技术。CAS
操作包含三个操作数——内存位置、预期原值及新值。执行 CAS
操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS
是一条 CPU 的原子指令（cmpxchg
指令），不会造成所谓的数据不一致问题，<code>Unsafe</code> 提供的 CAS
方法（如 <code>compareAndSwapXXX</code>）底层实现即为 CPU 指令
<code>cmpxchg</code></p></li>
<li><p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> a;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      CasTest casTest=<span class="keyword">new</span> <span class="title class_">CasTest</span>();</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">              casTest.increment(i);</span><br><span class="line">              System.out.print(casTest.a+<span class="string">&quot; &quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span> ; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">              casTest.increment(i);</span><br><span class="line">              System.out.print(casTest.a+<span class="string">&quot; &quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="type">long</span> <span class="variable">fieldOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(CasTest.class.getDeclaredField(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">              <span class="keyword">if</span> (unsafe.compareAndSwapInt(<span class="built_in">this</span>,fieldOffset,x-<span class="number">1</span>,x))</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>使用两个线程去修改int型属性a的值，并且只有在a的值等于传入的参数x减一时，才会将a的值变为x，也就是实现对a的加一的操作
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221011184828760.png"
alt="image-20221011184828760" /></p></li>
</ul>
<h4 id="线程调度多线程问题">线程调度(多线程问题)</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Unsafe类提供的相关方法</span></span><br><span class="line"><span class="comment">//取消阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Object thread)</span>;</span><br><span class="line"><span class="comment">//阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">boolean</span> isAbsolute, <span class="type">long</span> time)</span>;</span><br><span class="line"><span class="comment">//获得对象锁（可重入锁）</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorEnter</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorExit</span><span class="params">(Object o)</span>;</span><br><span class="line"><span class="comment">//尝试获取对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">tryMonitorEnter</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></figure>
<p>方法 <code>park</code>、<code>unpark</code>
即可实现线程的挂起与恢复，将一个线程进行挂起是通过 <code>park</code>
方法实现的，调用 <code>park</code>
方法后，线程将一直阻塞直到超时或者中断等条件出现；<code>unpark</code>
可以终止一个挂起的线程，使其恢复正常。</p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 此外，<code>Unsafe</code>
源码中<code>monitor</code>相关的三个方法已经被标记为<code>deprecated</code>，不建议被使用：
======= Unsafe源码中monitor相关的方法被标记为deprecated
&gt;&gt;&gt;&gt;&gt;&gt;&gt;
01db5084445cfa1dd668fb907ec8e453c9136e03</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorEnter</span><span class="params">(Object var1)</span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">monitorExit</span><span class="params">(Object var1)</span>;</span><br><span class="line"><span class="comment">//尝试获得对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">tryMonitorEnter</span><span class="params">(Object var1)</span>;</span><br></pre></td></tr></table></figure>
<p><code>monitorEnter</code>方法用于获得对象锁，<code>monitorExit</code>用于释放对象锁，如果对一个没有被<code>monitorEnter</code>加锁的对象执行此方法，会抛出<code>IllegalMonitorStateException</code>异常。<code>tryMonitorEnter</code>方法尝试获取对象锁，如果成功则返回<code>true</code>，反之返回<code>false</code>。
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h4 id="class操作">Class操作</h4>
<p>=======</p>
<p>代码应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">mainThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;subThread try to unpark mainThread&quot;</span>);</span><br><span class="line">            unsafe.unpark(mainThread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;park main mainThread&quot;</span>);</span><br><span class="line">    unsafe.park(<span class="literal">false</span>,<span class="number">0L</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;unpark mainThread success&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">park main mainThread</span><br><span class="line">subThread <span class="keyword">try</span> to unpark mainThread</span><br><span class="line">unpark mainThread success</span><br></pre></td></tr></table></figure>
<p>流程图如下：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221012090743240.png"
alt="image-20221012090743240" /></p>
<h4 id="class操作-1">Class操作</h4>
<p>Unsafe对class的相关操作主要包括类加载和静态变量的操作方法</p>
<ul>
<li><p>静态属性读取相关的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取静态属性的偏移量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">staticFieldOffset</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//获取静态属性的对象指针---另一说,获取静态变量所属的类在方法区的首地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title function_">staticFieldBase</span><span class="params">(Field f)</span>;</span><br><span class="line"><span class="comment">//判断类是否需要实例化（用于获取类的静态属性前进行检测）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String name=<span class="string">&quot;Hydra&quot;</span>;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">staticTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    System.out.println(unsafe.shouldBeInitialized(User.class));</span><br><span class="line">    <span class="type">Field</span> <span class="variable">sexField</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">fieldOffset</span> <span class="operator">=</span> unsafe.staticFieldOffset(sexField);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">fieldBase</span> <span class="operator">=</span> unsafe.staticFieldBase(sexField);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> unsafe.getObject(fieldBase, fieldOffset);</span><br><span class="line">    System.out.println(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 运行结果:falseHydra</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在 <code>Unsafe</code>
的对象操作中，我们学习了通过<code>objectFieldOffset</code>方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用<code>staticFieldOffset</code>方法。在上面的代码中，只有在获取<code>Field</code>对象的过程中依赖到了<code>Class</code>，而获取静态变量的属性时不再依赖于<code>Class</code>。</p>
<p>在上面的代码中首先创建一个<code>User</code>对象，这是因为如果一个类没有被实例化，那么它的静态属性也不会被初始化，最后获取的字段属性将是<code>null</code>。所以在获取静态属性前，需要调用<code>shouldBeInitialized</code>方法，判断在获取前是否需要初始化这个类。如果删除创建
User 对象的语句，运行结果会变为：<code>truenull</code></p></li>
<li><p><code>defineClass</code>方法允许程序在运行时动态创建一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len, ClassLoader loader,ProtectionDomain protectionDomain);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>利用class类字节码文件，动态创建一个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">defineTest</span><span class="params">()</span> &#123;</span><br><span class="line">    String fileName=<span class="string">&quot;F:\\workspace\\unsafe-test\\target\\classes\\com\\cn\\model\\User.class&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileName);</span><br><span class="line">    <span class="keyword">try</span>(<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">        <span class="type">byte</span>[] content=<span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)file.length()];</span><br><span class="line">        fis.read(content);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> unsafe.defineClass(<span class="literal">null</span>, content, <span class="number">0</span>, content.length, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">age</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getAge&quot;</span>).invoke(o, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="系统信息">系统信息</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取系统相关信息 </span></span><br><span class="line"><span class="comment">//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">addressSize</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//内存页的大小，此值为2的幂次方。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">pageSize</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-基础</tag>
      </tags>
  </entry>
  <entry>
    <title>集合_1</title>
    <url>/2022/10/17/review/java_guide/java/collection/collection_1/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2
id="集合包括collection和mapcollection-存放单一元素map-存放键值对">集合包括<code>Collection</code>和<code>Map</code>，Collection
存放单一元素。Map 存放键值对</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221017103340847.png"
alt="image-20221017103340847" />
<figcaption aria-hidden="true">image-20221017103340847</figcaption>
</figure>
<h2 id="listsetqueuemap区别">List，Set，Queue，Map区别</h2>
<ul>
<li><code>List</code>(对付顺序的好帮手):
存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质):
存储的元素是无序的、不可重复的。</li>
<li><code>Queue</code>(实现排队功能的叫号机):
按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><code>Map</code>(用 key 来搜索的专家):
使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，"x" 代表
key，"y" 代表 value，key 是无序的、不可重复的，value
是无序的、可重复的，每个键最多映射到一个值。 ##
各种集合框架--底层数据结构
<ul>
<li>List
<ul>
<li>ArrayList、Vector ----&gt; Object[] 数组</li>
<li>LinkedList 双向链表 (jdk 1.6 之前为循环链表, 1.7 取消了循环)</li>
</ul></li>
<li>Set
<ul>
<li>HashSet （无序，唯一），且<strong>基于HashMap</strong></li>
<li>LinkedHashSet 是HashSet的子类，基于<strong>LinkedHashMap</strong>
(LinkedHashMap内部基于HashMap实现)</li>
<li>TreeSet(有序，唯一) ：红黑树（自平衡的排序二叉树）</li>
</ul></li>
<li>Queue (队列)
<ul>
<li>PriorityQueue：Object[] 数组来实现二叉堆</li>
<li>ArrayQueue：Object[] 数组+ 双指针</li>
</ul></li>
<li>Map
<ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code>
由数组+链表组成的，数组是 <code>HashMap</code>
的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8
以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为
8）（将链表转换成红黑树前会判断，如果当前数组的长度小于
64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自
<code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code>
在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是
<code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul></li>
</ul></li>
</ul>
<h2 id="如何选用集合">如何选用集合</h2>
<ul>
<li>当我们只需要存放元素值时，就选择实现<code>Collection</code>
接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如
<code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现
<code>List</code> 接口的比如 <code>ArrayList</code> 或
<code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用</li>
<li>需要根据键值获取到元素值时就选用 <code>Map</code>
接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择
<code>HashMap</code>,需要保证线程安全就选用
<code>ConcurrentHashMap</code>。</li>
</ul>
<h2 id="为什么需要集合">为什么需要集合</h2>
<ul>
<li>当需要保存一组类型相同的数据时，需要容器来保存，即数组，但实际中存储的类型多样，数组一旦声明则不可变长，且数组数据类型也确定、数组有序可重复</li>
<li>集合可以存储不同类型不同数量的对象，还可以保存具有映射关系的数据</li>
</ul>
<h2 id="collection-子接口">Collection 子接口</h2>
<h3 id="list">List</h3>
<ul>
<li><p>ArrayList和Vector区别：ArrayList是List主要实现类，底层使用Object[]存储线程不安全（synchronized关键字）；Vector是List古老实现类，底层使用Object[]存储，线程安全</p></li>
<li><p>ArrayList与LinkedList：</p>
<ul>
<li>都是线程不安全</li>
<li>ArrayList底层使用Object数组，LinkedList底层使用双向链表结构（JDK7以后非循环链表）</li>
<li>ArrayList采用数组存储，所以插入和删除元素的时间复杂度受位置印象；LinkedList采用链表，所以在头尾插入或者删除元素不受元素位置影响，而如果需要插入或者删除中间指定位置，则时间复杂度为O(n)
[主要是因为要遍历]</li>
<li>LinkedList不支持高效的随机元素访问，而ArrayList支持（即通过元素的序号快速获取元素对象）</li>
<li>内存空间占用：ArrayList的空间浪费主要体现在List结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（存放直接后继、直接前驱及数据）</li>
</ul></li>
<li><p>实际项目中不怎么使用LinkedList，因为ArrayList性能通常会更好，LinkedList仅仅在头尾插入或者删除元素的时间时间复杂度近似O(1)</p></li>
<li><p>双向链表与双向循环链表</p>
<ul>
<li>双向链表，首尾相连 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221017145140450.png"
alt="image-20221017145140450" /></li>
<li>双向循环链表，首尾相连（头节点的前驱=尾结点，尾结点的后继=头节点）</li>
</ul></li>
<li><p>补充：RandomAccess接口，这个接口只是用来<strong>标识</strong>：<strong>实现这个接口的类，具有随机访问功能</strong>，但并不是说因为实现了该接口才具有的快速随机访问机制</p>
<ul>
<li><p>Collections里面有这样一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ArrayList实现了RandomAccess方法，而LinkedList没有。是由于ArrayList底层是数组，支持快速随机访问，时间复杂度为O(1)，而LinkedList底层是链表，不支持快速随机访问，时间复杂度为O(n)</p></li>
</ul></li>
</ul>
<h3 id="set">Set</h3>
<ul>
<li><p>Coparable和Comparator的区别</p>
<ul>
<li>Comparable实际出自<code>java.lang</code>包，有一个compareTo(Object
obj)方法用来排序</li>
<li>Comparator实际出自<code>java.util</code>包，有一个compare(Object
obj1,Object obj2)方法用来排序</li>
</ul></li>
<li><p><code>Collections.sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>默认是正序，T必须实现了Comparable，且<code>Arrays.sort()</code>方法中的部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用插入排序</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=low; i&lt;high; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;low &amp;&amp; c.compare(dest[j-<span class="number">1</span>], dest[j])&gt;<span class="number">0</span>; j--) <span class="comment">//如果前一个数跟后面的数相比大于零，则进行交换，即大的排后面</span></span><br><span class="line">                    swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//当比较结果&gt;0时，调换数组前后两个元素的值，也就是后面的一定要比前面的大，即</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面这段代码，按照年龄降序（默认是升序）</span></span><br><span class="line">        Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="comment">//如果结果大于0，则两个数对调 </span></span><br><span class="line">                <span class="comment">//如果返回o2.compareTo(o1)，就是当o2&gt;01时，两个结果对换，也就是降序</span></span><br><span class="line">                <span class="comment">//如果返回o1.compareTo(o2)，就是当o1&gt;o2时，两个结果对换，也就是升序   也就是当和参数顺序一致时，是升序；反之，则是降序</span></span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1); </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//上面这段代码，标识</span></span><br></pre></td></tr></table></figure></li>
<li><p>无序性和不可重复性</p>
<ul>
<li>无序性，指存储的数据，在底层数据结构中，并非按照数组索引的书顺序添加（而是根据数据的哈希值决定）</li>
<li>不可重复性：指添加的元素按照equals()判断时，返回false。需同时填写equals()方法和hashCode()
方法</li>
</ul></li>
<li><p>比较HashSet、LinkedHashSet和TreeSet三者异同</p>
<ul>
<li>都是Set实现类，保证元素唯一，且非线程安全</li>
<li>三者底层数据结构不同，HashSet底层为哈希表（HashMap）;
LinkedHashSet底层为链表+哈希表
，元素的插入和取出顺序满足FIFO。TreeSet底层为红黑树，元素有序，排序方式有自然排序和定制排序
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221017170434986.png"
alt="image-20221017170434986" /></li>
</ul></li>
</ul>
<h2 id="queue">Queue</h2>
<h3 id="queue和deque的区别">Queue和Deque的区别</h3>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221017170659204.png"
alt="image-20221017170659204" />
<figcaption aria-hidden="true">image-20221017170659204</figcaption>
</figure>
<ul>
<li>Queue
<ul>
<li>Queue为单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循<strong>先进先出（FIFO）</strong>规则【Dequeue为双端队列，在队列两端均可插入或删除元素】</li>
<li>Queue扩展了Collection接口，根据<strong>因容量问题而导致操作失败后的处理方式不同</strong>分两类，操作失败后<strong>抛异常</strong>或<strong>返回特殊值</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221017172811954.png"
alt="image-20221017172811954" /></li>
<li>Dequeue，双端队列，在队列两端均可插入或删除元素，也会根据失败后处理方式分两类
Deque还有push()和pop()等其他方法，可用于模拟栈 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221017173058398.png"
alt="image-20221017173058398" /></li>
</ul></li>
</ul>
<h3 id="arraydeque与linkedlist区别">ArrayDeque与LinkedList区别</h3>
<ul>
<li>ArrayDeque和LinkedList都实现了Deque接口，两者都具有队列功能</li>
<li>ArrayDeque基于可变长的数组和双指针来实现，而LinkedList则通过链表来实现</li>
<li>ArrayDeque不支持存储NULL数据，但LinkedList支持</li>
<li>ArrayDeque是后面（JDK1.6)引入的，而LinkedList在JDK1.2就存在</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程,
不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code>
不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>总的来说，ArrayDeque来实现队列要比Linked更好，此外，ArrayDeque也可以用于实现栈</p>
<h3 id="说一说priorityqueue">说一说PriorityQueue</h3>
<p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与
<code>Queue</code>
的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code>
利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn)
的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是非线程安全的，且不支持存储
<code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个
<code>Comparator</code>
作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<blockquote>
<p>大部分转自https://github.com/Snailclimb/JavaGuide</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-集合</tag>
      </tags>
  </entry>
  <entry>
    <title>集合_2</title>
    <url>/2022/10/18/review/java_guide/java/collection/collection_2/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="map">Map</h2>
<ul>
<li><p>HashMap和Hashtable的区别</p>
<ul>
<li>HashMap是非线程安全的，Hashtable是线程安全的，因为Hashtable内部方法都经过synchronized修饰（不过要保证线程安全一般用ConcurrentHashMap）</li>
<li>由于加了synchronized修饰，HashTable效率没有HashMap高</li>
<li>HashMap可以存储null的key和value，但null作为key的键只能由一个；HashTable不允许有null键和null值</li>
<li>初始容量及每次扩容
<ul>
<li>Hashtable默认初始大小11，之后扩容为2n+1;HashMap初始大小16，之后扩容2n</li>
<li>如果指定初始大小，HashTable直接使用初始大小<br />
而HashMap使用2的幂作为哈希表的大小（我猜是大于初始大小的最小2的n次方）<strong>Returns
a power of two size for the given target capacity.</strong></li>
</ul></li>
<li>底层数据结构
<ul>
<li>JDK1.8之后HashMap解决哈希冲突时，当链表大于阈值（默认8）时，将链表转为红黑树（转换前判断，如果当前数组长度小于64，则先进行数组扩容，而不转成红黑树），以减少搜索时间</li>
</ul></li>
</ul></li>
<li><p>HashMap和hashSet区别</p>
<ul>
<li>HashSet底层就是HashMap实现的</li>
<li>HashMap：实现了Map接口；存储键值对；调用put()向map中添加元素；<strong>HashMap使用键（key）计算</strong></li>
<li>HashSet：实现Set接口；仅存储对象；调用add()方法向Set中添加元素；HashSet使用成员对象计算hashCode，对于不相等两个对象来说
hashcode也可能相同，所以还要再借助equals()方法判断对象相等性</li>
</ul></li>
<li><p>HashMap和TreeMap navigable 英[ˈnævɪɡəbl] 通航的，可航行的<br />
HashMap和TreeMap都继承自AbstractMap<br />
TreeMap还实现了NavigableMap
（<strong>对集合内元素搜索</strong>）和SortedMap（对集合内元素<strong>根据键排序</strong>，默认key升序，可指定排序的比较器）接口<br />
示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年06月15日 17:02:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeMap&lt;Person, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person person1, Person person2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> person1.getAge() - person2.getAge();</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(num, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">3</span>), <span class="string">&quot;person1&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>), <span class="string">&quot;person2&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">35</span>), <span class="string">&quot;person3&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">16</span>), <span class="string">&quot;person4&quot;</span>);</span><br><span class="line">        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;</span><br><span class="line">            System.out.println(personStringEntry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">/**person1</span></span><br><span class="line"><span class="comment">person4</span></span><br><span class="line"><span class="comment">person2</span></span><br><span class="line"><span class="comment">person3</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></li>
<li><p>HashSet如何检查重复</p>
<ul>
<li><p>当在HashSet加入对象时，先计算对象hashcode值判断加入位置，同时与其他加入对象的hashcode值比较，如果没有相同的，会假设对象没有重复出现；如果发现有相同的hashcode值的对象，则调用equals()方法检查hashcode相等的对象是否真的相等，如果相等则不会加入</p></li>
<li><p>JDK1.8中，HashSet的add()方法调用了HashMap的put()方法，并判断是否有重复元素（返回值是否null)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns: true if this set did not already contain the specified element</span></span><br><span class="line"><span class="comment">// 返回值：当 set 中没有包含 add 的元素时返回真</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面为HashMap的源代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns : previous value, or null if none</span></span><br><span class="line"><span class="comment">// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>HashMap底层实现</p>
<ul>
<li><p>JDK1.8之前，底层是数组和链表结合在一起使用，即链表散列。通过key的hashcode经过扰动函数处理后得到hash值，并通过
(n-1) &amp; hash 判断当前元素存放的位置
（n为数组长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，<strong>如果相同则覆盖，不同则通过拉链法解决冲突</strong>
扰动函数指的是HashMap的hash方法，是为了防止一些实现比较差的hashCode方法，减少碰撞
JDK1.8的hash：如果key为null则返回空，否则使用 (key的hash值) 与
(hash值右移16位) 做异或操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK1.7扰动次数更多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拉链法即链表和数组结合，也就是创建一个链表数组，数组每一格为一个链表，如果发生哈希冲突，就将冲突的值添加到链表中即可</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221019143906992.png"
alt="image-20221019143906992" />
<figcaption aria-hidden="true">image-20221019143906992</figcaption>
</figure></li>
<li><p>JDK8之后，解决冲突发生了较大变化，当链表长度大于阈值（默认是8）（如果数组小于64，则只会进行扩容；如果不是，才转成红黑树）时，将链表转换成红黑树，以减少搜索时间
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221019144049952.png"
alt="image-20221019144049952" />
二叉查找树，在某些情况下会退化成线性结构，时间复杂度为n
，而红黑树趋于log n
。TreeMap、TreeSet以及1.8之后的HashMap都用到了红黑树</p></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当链表长度大于8时，执行treeifyBin（转换红黑树）</span></span><br><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">    <span class="comment">// 遍历到链表最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">// 红黑树转换（并不会直接转换成红黑树）</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    p = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否会转成红黑树</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 判断当前数组的长度是否小于 64</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">// 如果当前数组的长度小于 64，那么会选择先进行数组扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 否则才将列表转换为红黑树</span></span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>HashMap的长度为为什么是2的幂次方</p>
<ul>
<li>Hash值范围是-2147483648 到 2147483647
，大概是40亿映射空间，如果哈希函数映射均匀则很难发生碰撞，但一个40亿长度的数组内存放不下，所以用之前得对数组长度进行取模，然后得到的余数存放的位置才是对应的数组下标，下标计算方法
(n-1) &amp;&amp; hash 为什么不是取余数，因为 hash &amp; (length -1) 比
hash%length效率高，当length为2的n次方时两侧相等，而
使用二进制位操作&amp; 能够提高效率</li>
</ul></li>
<li><p>HashMap多线程操作导致死循环问题
多线程下不建议使用HashMap，1.8之前并发下进行Rehash会造成元素之间形成循环链表，1.8之后还有其他问题（数据丢失），建议使用concurrentHashMap</p></li>
<li><p>HashMap有哪几种常见的遍历方式</p>
<blockquote>
<p>https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw</p>
</blockquote></li>
<li><p>ConcurrentHashMap和Hashtable</p>
<ul>
<li><p>主要体现在，实现线程安全的方式上不同</p></li>
<li><p>底层数据结构</p>
<ul>
<li>ConcurrentHashMap：JDK1.7
底层采用<strong>分段数组+链表</strong>，JDK1.8
则是<strong>数组+链表/红黑二叉树（红黑树是1.8之后才出现的）</strong></li>
<li>HashTable采用 数组 (应该不是分段数组) + 链表</li>
</ul></li>
<li><p>实现线程安全的方式</p>
<ul>
<li>ConcurrentHashMap JDK1.7
时对整个桶数进行分割分段(Segment，分段锁)，每一把锁只锁容器其中一部分数据，当访问不同数据段的数据就不会存在锁竞争</li>
<li>ConcurrentHashMap
JDK1.8摒弃Segment概念，直接用Node数组+链表+红黑树，并发控制使用synchronized和CAS操作</li>
<li>而Hashtable则是同一把锁，使用synchronized保证线程安全，效率低下。问题：当一个线程访问同步方式时，其他线程也访问同步方法，则可能进入阻塞/轮询状态，即如使用put添加元素另一个线程不能使用put和get</li>
</ul></li>
<li><p>底层数据结构图</p>
<ul>
<li><p>HashTable：数组+链表 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221019162845607.png"
alt="image-20221019162845607" /></p></li>
<li><p>JDK1.7 的
ConcurrentHashMap（Segment数组，HashEntry数组，链表）</p>
<p>Segment是用来加锁的 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221019163009141.png"
alt="image-20221019163009141" /> JDK1.8
的ConcurrentHashMap则是Node数组+链表/红黑树，不过红黑树时，不用Node，而是用TreeNode</p></li>
<li><p>TreeNode，存储红黑树节点，被TreeBin包装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">root 维护红黑树根节点；waiter维护当前使用这颗红黑树的线程，防止其他线程进入</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> lockState;</span><br><span class="line">        <span class="comment">// values for lockState</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WRITER</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">WAITER</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READER</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>ConcurrentHashMap线程安全的<strong>具体实现方式/底层具体实现</strong></p>
<ul>
<li><p>JDK1.8之前的ConcurrentHashMap</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221019164531847.png"
alt="image-20221019164531847" /><code>Segment</code> 继承了
<code>ReentrantLock</code>,所以 <code>Segment</code>
是一种可重入锁，扮演锁的角色。<code>HashEntry</code>
用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code>
数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。
<code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16
个线程并发写。 <code>Segment</code> 的结构和 <code>HashMap</code>
类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个
<code>HashEntry</code> 数组，每个 <code>HashEntry</code>
是一个链表结构的元素，每个 <code>Segment</code> 守护着一个
<code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code>
数组的数据进行修改时，必须首先获得对应的 <code>Segment</code>
的锁。也就是说，对同一 <code>Segment</code> 的并发写入会被阻塞，不同
<code>Segment</code> 的写入是可以并发执行的。</p></li>
<li><p>JDK 1.8 之后 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221019165516462.png"
alt="image-20221019165516462" />
使用Node数组+链表/红黑树，几乎重写了ConcurrentHashMap，使用<code>Node+CAS+Synchronized</code>保证并发安全，数据结构跟HashMap1.8类似，超过一定阈值（默认8）将链表【O(N)】转成红黑树【O(log
(N) )】
JDK8中，只锁定当前链表/红黑二叉树的首节点，这样只要hash不冲突就不会产生并发，不影响其他Node的读写，提高效率</p></li>
</ul></li>
</ul>
<h2 id="collections工具类不重要">Collections工具类（不重要）</h2>
<p>包括 排序/查找/替换</p>
<ul>
<li><p>排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List list, <span class="type">int</span> i , <span class="type">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List list, <span class="type">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span><br></pre></td></tr></table></figure></li>
<li><p>查找/替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span><br></pre></td></tr></table></figure></li>
<li><p>同步控制，Collections提供了多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而解决并发问题。
其中，<strong>HashSet、TreeSet、ArrayList、LinkedList、HashMap、TreeMap</strong>都是线程不安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不推荐，因为效率极低 建议使用JUC包下的并发集合</span></span><br><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持</span></span><br><span class="line">的同步（线程安全的）collection。</span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>大部分转自https://github.com/Snailclimb/JavaGuide</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-集合</tag>
      </tags>
  </entry>
  <entry>
    <title>集合使用注意事项</title>
    <url>/2022/10/19/review/java_guide/java/collection/collections-precautions-for-use/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="集合判空">集合判空</h2>
<blockquote>
<p>//阿里巴巴开发手册</p>
<p><strong>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code>
方法，而不是 <code>size()==0</code> 的方式。</strong></p>
</blockquote>
<ul>
<li><p>isEmpty()可读性更好，且绝大部分情况下时间复杂度为O(1)</p></li>
<li><p>ConcurrentHashMap的size()和isEmpty() 时间复杂度均不是O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="type">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sumCount() &lt;= <span class="number">0L</span>; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="集合转map">集合转Map</h2>
<blockquote>
<p>//阿里巴巴开发手册</p>
<p><strong>在使用 <code>java.util.stream.Collectors</code> 类的
<code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当
value 为 null 时会抛 NPE 异常。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line">     <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; bookList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;18163138123&quot;</span>));</span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;martin&quot;</span>,<span class="literal">null</span>));</span><br><span class="line"><span class="comment">// 空指针异常</span></span><br><span class="line">bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));</span><br></pre></td></tr></table></figure>
<p>java.util.stream.Collections类的toMap()
，里面使用到了Map接口的merge()方法,
调用了Objects.requireNonNull()方法判断value是否为空</p>
<h2 id="集合遍历">集合遍历</h2>
<blockquote>
<p>//阿里巴巴开发手册</p>
<p><strong>不要在 foreach 循环里进行元素的 <code>remove/add</code>
操作。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对
<code>Iterator</code> 对象加锁。</strong></p>
</blockquote>
<ul>
<li><p>foreach语法底层依赖于Iterator （foreach是语法糖），不过remove/add
则是直接调用集合的方法，而不是Iterator的；
所以此时Iterator莫名发现自己元素被remove/add，就会抛出一个ConcurrentModificationException来提示用户发生了并发修改异常，即单线程状态下产生的fail-fast机制</p></li>
<li><p>java8开始，可以使用Collection#removeIf()方法删除满足特定条件的元素，例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span></span><br></pre></td></tr></table></figure></li>
<li><p>其他的遍历数组的方法（注意是遍历，不是增加/删除）</p>
<ul>
<li><p>使用普通for循环</p></li>
<li><p>使用fail-safe集合类，java.util包下面的所有集合类都是fail-fast，而java.util.concurrent包下面的所有类是fail-safe</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ConcurrentHashMap源码</span></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable &#123;&#125;</span><br><span class="line"><span class="comment">//List类源码</span></span><br><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="集合去重">集合去重</h2>
<blockquote>
<p>//阿里巴巴开发手册</p>
<p><strong>可以利用 <code>Set</code>
元素唯一的特性，可以快速对一个集合进行去重操作，避免使用
<code>List</code> 的 <code>contains()</code>
进行遍历去重或者判断包含操作。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set 去重代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">removeDuplicateBySet</span><span class="params">(List&lt;T&gt; data)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 去重代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">removeDuplicateByList</span><span class="params">(List&lt;T&gt; data)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(data.size());</span><br><span class="line">    <span class="keyword">for</span> (T current : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.contains(current)) &#123;</span><br><span class="line">            result.add(current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Set时间复杂度为 1 * n ，而List时间复杂度为 n * n</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Set的Contains，底层依赖于HashMap,时间复杂度为 1 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ArrayList的Contains，底层则是遍历,时间复杂度为O(n)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合转数组">集合转数组</h2>
<blockquote>
<p>//阿里巴巴开发手册</p>
<p><strong>使用集合转数组的方法，必须使用集合的
<code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0
的空数组。</strong></p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221020152445082.png"
alt="image-20221020152445082" />
<figcaption aria-hidden="true">image-20221020152445082</figcaption>
</figure>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line"><span class="comment">//没有指定类型的话会报错</span></span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>于 JVM
优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0
是为了节省空间，因为它只是为了说明返回的类型</p>
</blockquote>
<h2 id="数组转集合">数组转集合</h2>
<blockquote>
<p>//阿里巴巴开发手册</p>
<p><strong>使用工具类 <code>Arrays.asList()</code>
把数组转换成集合时，不能使用其修改集合相关的方法， 它的
<code>add/remove/clear</code> 方法会抛出
<code>UnsupportedOperationException</code> 异常。</strong></p>
</blockquote>
<p>例子及源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] myArray = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//JDK源码说明[返回由指定数组支持的固定大小的列表]</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，</span></span><br><span class="line"><span class="comment">  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li><p><strong>1、<code>Arrays.asList()</code>是泛型方法，传递的数组必须是对象数组，而不是基本类型。</strong>
如果把原生数据类型数组传入，则传入的不是数组的元素，而是数组对象本身，可以使用包装类数组解决这个问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">int</span>[] array = (<span class="type">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure></li>
<li><p>2、使用集合的修改方法add()，remove()，clear()会抛出异常UnsupportedOperationException
java.util.Arrays$ArrayList
（Arrays里面有一个ArrayList类，该类继承了AbstractList）</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    add(size(), e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    removeRange(<span class="number">0</span>, size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, n=toIndex-fromIndex; i&lt;n; i++) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221020154648530.png"
alt="image-20221020154648530" />
<figcaption aria-hidden="true">image-20221020154648530</figcaption>
</figure></li>
<li><p>如何转换成正常的ArraysList呢</p>
<ol type="1">
<li><p>手动实现工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用泛型</span></span><br><span class="line"><span class="comment">//JDK1.5+</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">arrayToList</span><span class="params">(<span class="keyword">final</span> T[] array)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;T&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;(array.length);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> T s : array) &#123;</span><br><span class="line">    l.add(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">System.out.println(arrayToList(myArray).getClass());<span class="comment">//class java.util.ArrayList</span></span><br></pre></td></tr></table></figure></li>
<li><p>便捷的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//再转一次</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用Java8的Stream（推荐），包括基本类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="type">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li>
<li><p>使用Apache Commons Colletions</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">CollectionUtils.addAll(list, str);</span><br></pre></td></tr></table></figure></li>
<li><p>使用Java9的List.of()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ul>
<blockquote>
<p>大部分转自https://github.com/Snailclimb/JavaGuide</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-集合</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码</title>
    <url>/2022/10/20/review/java_guide/java/collection/source-code-ArrayList/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="简介">简介</h2>
<ul>
<li><p>底层是数组队列，相当于动态数组，能动态增长，可以在添加大量元素前先使用ensureCapacity来增加ArrayList容量，减少递增式再分配的数量
源码：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">              <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>Random
Access，标志接口，表明这个接口的List集合支持<strong>快速随机访问</strong>，这里是指可通过元素序号快速访问</li>
<li>实现Cloneable接口，能被克隆</li>
<li>实现java.io.Serializable，支持序列化</li>
</ol></li>
<li><p>ArrayList和Vector区别</p>
<ul>
<li>ArrayList和Vector都是List的实现类，Vector出现的比较早，底层都是Object[]
存储</li>
<li>ArrayList线程不安全（效率低所以适合频繁查找 ）</li>
<li>Vector 线程安全的</li>
</ul></li>
<li><p>ArrayList与LinkedList区别</p>
<ul>
<li><p>都是不同步的，即不保证线程安全</p></li>
<li><p>ArrayList底层为Object数组；LinkedList底层使用双向链表数据结构(1.6之前为循环链表，1.7取消了循环)</p></li>
<li><p>插入和删除是否受元素位置影响</p>
<ul>
<li><p>ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置影响[
默认增加到末尾，O(1) ; 在指定位置，则O(n) , 要往后移动]</p></li>
<li><p>LinkedList采用链表存储，所以对于add(E
e)方法，还是O(1)；如果是在指定位置插入和删除，则为O(n)
因为需要遍历将指针移动到指定位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LinkedList默认添加到最后</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>LinkedList不支持搞笑随机元素访问，而ArrayList支持（通过get(int
index))</p></li>
<li><p>内存空间占用
ArrayList的空间浪费主要体现在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费在，每个元素都需要比ArrayList更多空间（要存放直接前驱和直接后继以及(当前)数据)</p></li>
</ul></li>
</ul></li>
</ul>
<h2 id="扩容机制分析-jdk8">3. 扩容机制分析 ( JDK8 )</h2>
<ol type="1">
<li><p>ArrayList的构造函数</p>
<ul>
<li>三种方式初始化，构造方法源码</li>
<li>空参，指定大小，指定集合
（如果集合类型非Object[].class，则使用Arrays.copyOf转为Object[].class)</li>
<li>以无参构造方式创建ArrayList时，实际上初始化赋值的是空数组；当真正操作时才分配容量，即添加第一个元素时扩容为10</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认初始容量大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">           <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">           <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">           <span class="comment">//创建空数组</span></span><br><span class="line">           <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">   *如果指定的集合为null，throws NullPointerException。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">       elementData = c.toArray();</span><br><span class="line">       <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">           <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">               elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// replace with empty array.</span></span><br><span class="line">           <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以无参构造参数函数为例</p>
<p>得到最小扩容量( 如果空数组则为10，否则原数组大小+1
)---&gt;确定是否扩容【<strong>minCapacity &gt;
此时的数组大小</strong>】---&gt; 真实进行扩容 【 grow(int minCapacity)
】</p>
<ul>
<li><p>扩容的前提是 数组最小扩容 &gt; 数组实际大小</p></li>
<li><p>几个名词：oldCapacity，newCapacity (oldCapacity * 1.5
)，minCapacity，MAX_ARRAY_SIZE ,INT_MAX</p>
<blockquote>
<p>对于MAX_ARRAY_SIZE的解释：<br />
/** 要分配的数组的最大大小。 一些 VM 在数组中保留一些标题字。
尝试分配更大的数组可能会导致 OutOfMemoryError：请求的数组大小超过 VM
限制**/ Integer.MAX_VALUE = Ingeger.MAX_VALUE - 8 ;</p>
</blockquote>
<p><code>capacity 英[kəˈpæsəti]</code>
这个方法最后是要用newCapacity扩容的，所以要给他更新可用的值，也就是：</p>
<ol type="1">
<li><p>如果扩容后还比minCapacity
小，那就把newCapacity更新为minCapacity的值</p></li>
<li><p>如果比MAX_ARRAY_SIZE还大，那就超过范围了</p>
<p>得通过hugeCapacity(minCapcacity)
，即minCapacity和MAX_ARRAY_SIZE来设置newCapacity</p></li>
<li><p>-&gt;
这里有点绕，看了也记不住-----其实前面第1步，就是说我至少需要minCapcacity的数，但是如果newCapacity
(1.5 * oldCapacity )比MAX_ARRAY_SIZE：如果实际需要的容量 (miniCapacity
&gt; MAX_ARRAY_SIZE , 那就直接取Integer.MAX_VALUE
；如果没有，那就取MAX_ARRAY_SIZE )</p></li>
</ol></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//add方法，先扩容，再赋值（实际元素长度最后）</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">   <span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!  //jdk11 移除了该方法，第一次进入时size为0</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ensureCapacityInternal,if语句说明第一次add时，取当前容量和默认容量的最大值作为扩容量</span></span><br><span class="line">   <span class="comment">//**得到最小扩容量**</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取默认的容量和传入参数的较大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ensureExplicitCapacity 判断是否扩容</span></span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> if语句表示，当minCapacity（数组实际元素数量的大小）大于实际容量则进行扩容</span></span><br><span class="line"><span class="comment"> 添加第1个元素的时候，会进入grow方法，直到添加第10个元素</span></span><br><span class="line"><span class="comment"> 当添加第11个元素时，minCapacity(11)比elementData.length(10)大，进入扩容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">       <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span></span><br><span class="line">       <span class="comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 进入真正的扩容</span></span><br><span class="line"><span class="comment">int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数；右移运算会比普通运算符快很多</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>扩展</p>
<ul>
<li>java 中的
<code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了
length 这个属性.</li>
<li>java 中的 <code>length()</code>
方法是针对字符串说的,如果想看这个字符串的长度则用到
<code>length()</code> 这个方法.</li>
<li>java 中的 <code>size()</code>
方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>
</ul></li>
<li><p>hugeCapacity
当新容量超过MAX_ARRAY_SIZE时，<code>if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</code>
进入该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span></span><br><span class="line">    <span class="comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>System.arraycopy() 和 Arrays.copyOf()</p>
<ul>
<li><p>```java //System.arraycopy() 是一个native方法 // 我们发现
arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义 /** *
复制数组 * <span class="citation" data-cites="param">@param</span> src
源数组 * <span class="citation" data-cites="param">@param</span> srcPos
源数组中的起始位置 * <span class="citation"
data-cites="param">@param</span> dest 目标数组 * <span class="citation"
data-cites="param">@param</span> destPos 目标数组中的起始位置 * <span
class="citation" data-cites="param">@param</span> length
要复制的数组元素的数量 */ public static native void arraycopy(Object
src, int srcPos, Object dest, int destPos, int length);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">例子：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class ArraycopyTest &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO Auto-generated method stub</span><br><span class="line">		int[] a = new int[10];</span><br><span class="line">		a[0] = 0;</span><br><span class="line">		a[1] = 1;</span><br><span class="line">		a[2] = 2;</span><br><span class="line">		a[3] = 3;</span><br><span class="line">		System.arraycopy(a, 2, a, 3, 3);</span><br><span class="line">		a[2]=99;</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			System.out.print(a[i] + &quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//结果</span><br><span class="line">0 1 99 2 3 0 0 0 0 0</span><br></pre></td></tr></table></figure></p></li>
<li><p>Arrays.copyOf() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">    	<span class="comment">// 申请一个新的数组</span></span><br><span class="line">        <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];</span><br><span class="line">	<span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span></span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//场景</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="comment">//elementData：要复制的数组；size：要复制的长度</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Arrays.copypf() ： 用来扩容，或者缩短</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayscopyOfTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">		a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		a[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span>[] b = Arrays.copyOf(a, <span class="number">10</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;b.length&quot;</span>+b.length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果： 10</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>联系及区别</p></li>
</ol>
<ul>
<li>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了
<code>System.arraycopy()</code> 方法</li>
<li>arraycopy 更能实现自 定义</li>
</ul>
<ol start="7" type="1">
<li>ensureCapacity 方法 最好在向 <code>ArrayList</code>
添加大量元素之前用 <code>ensureCapacity</code>
方法，以减少增量重新分配的次数 向 <code>ArrayList</code>
添加大量元素之前使用<code>ensureCapacity</code>
方法可以提升性能。不过，这个性能差距几乎可以忽略不计。而且，实际项目根本也不可能往
<code>ArrayList</code> 里面添加这么多元素</li>
</ol>
<h2 id="核心源码解读">2. 核心源码解读</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">      <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存ArrayList数据的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认无参构造函数</span></span><br><span class="line"><span class="comment">     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">                <span class="comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span></span><br><span class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minExpand</span> <span class="operator">=</span> (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line">        <span class="comment">//如果最小容量大于已有的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//1.得到最小扩容量</span></span><br><span class="line">   <span class="comment">//2.通过最小容量扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">              <span class="comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中的元素数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//注意=和==的区别</span></span><br><span class="line">        <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="comment">//equals()方法比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">            <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span></span><br><span class="line"><span class="comment">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span></span><br><span class="line"><span class="comment">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span></span><br><span class="line"><span class="comment">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span></span><br><span class="line"><span class="comment">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">            <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的元素替换此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        <span class="comment">//对index进行界限检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回原来在这个位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定的元素。</span></span><br><span class="line"><span class="comment">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">      <span class="comment">//从列表中删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">     *返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组中所有的元素的值设为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class="line"><span class="comment">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> newSize; i &lt; size; i++) &#123;</span><br><span class="line">            elementData[i] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">outOfBoundsMsg</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除指定集合中包含的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="comment">//如果此列表被修改则返回true</span></span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class="line"><span class="comment">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回列表中的列表迭代器（按适当的顺序）。</span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ListItr</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序返回该列表中的元素的迭代器。</span></span><br><span class="line"><span class="comment">     *返回的迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大部分转自https://github.com/Snailclimb/JavaGuide</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-集合</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码</title>
    <url>/2022/10/21/review/java_guide/java/collection/source-code-HashMap/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="hashmap简介">HashMap简介</h2>
<ul>
<li>HashMap用来存放键值对，基于哈希表的Map接口实现，是非线程安全的</li>
<li>可以存储null的key和value，但null作为键只能有一个</li>
<li>JDK8之前，HashMap由数组和链表组成，链表是为了解决哈希冲突而存在；JDK8之后，当链表大于阈值（默认8），则会选择转为红黑树（当数组长度大于64则进行转换，否则只是扩容），以减少搜索时间</li>
<li>HashMap默认初始化大小为16，每次扩容为原容量2倍，且总是使用2的幂作为哈希表的大小</li>
</ul>
<h2 id="底层数据结构分析">底层数据结构分析</h2>
<ul>
<li><p>JDK8之前，HashMap底层是数组和链表，即<strong>链表散列</strong>；通过key的hashCode，经过扰动函数，获得hash值，然后再通过(n-1)
&amp; hash
判断当前元素存放位置（n指的是数组长度），如果当前位置存在元素，就判断元素与要存入的元素的hash值以及key是否相同，相同则覆盖，否则通过拉链法解决</p>
<ul>
<li><p>扰动函数，即hash(Object key)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK1.8  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="type">int</span> h;</span><br><span class="line">      <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">      <span class="comment">// ^ ：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>JDK1.7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK1.7 , 则扰动了4次，性能较差</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>JDK1.8，当大于阈值时（默认8），会调用treefyBin()，根据HashMap数组决定是否转换为红黑树，只有当数组长度大于或等于64才转换为红黑树，减少搜索时间，否则只是调用resize()方法扩容</p></li>
<li><p>HashMap一些属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值(容量*填充因子) 当实际大小超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>LoadFactory 加载因子
控制数组存放数据的疏密程度，<strong>趋于1，说明存放的数据越集中（即链表越长）</strong>；<strong>趋于0，数组中存放的数据少，即越稀疏</strong>。即如果太大则导致元素效率低，太小则数组利用率低（这里的低指的是每个数组存放的元素太少）；默认为0.75</li>
<li>threshold <code>threshold 英[ˈθreʃhəʊld]</code> <strong>threshold =
capacity * loadFactor</strong>，即存放的元素Size 如果 &gt; threshold
，即capacity * 0.75的时候，就要考虑扩容了</li>
</ul></li>
<li><p>Node类结点源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树节点类源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="type">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">root</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="built_in">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="hashmap源码分析">HashMap源码分析</h2>
<ul>
<li><p>构造方法(4个，空参/Map/指定容量大小/容量大小及加载因子)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">         putMapEntries(m, <span class="literal">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">         <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">             initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">         <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">         <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">         <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//putMapEntries方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>put方法（对外只提供put，没有putVal) putVal方法添加元素分析</p>
<ul>
<li><p>如果定位到的数组位置没有元素直接插入</p></li>
<li><p>如果有，则比较key，如果key相同则覆盖，不同则判断是否时树节点，如果是，使用putTreeVal插入；如果不是，则遍历链表插入(链表尾部)
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221022181648277.png"
alt="image-20221022181648277" /></p>
<ul>
<li><p>注意事项1：直接覆盖则return，不会有后续操作</p></li>
<li><p>当链表长度大于8且HashMap数组长度大于64才会执行链表转红黑树，否则只是对数组扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素（处理hash冲突）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 判断table[i]中的元素是否与插入的key一样，若相同那就直接使用插入的值p替换掉旧的值e。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// 判断插入的是否是红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 不是红黑树节点则说明为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span></span><br><span class="line">                    <span class="comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span></span><br><span class="line">                    <span class="comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>1.7中的put方法</p>
<ul>
<li><p>① 如果定位到的数组位置没有元素 就直接插入。</p></li>
<li><p>②
如果定位到的数组位置有元素，遍历<strong>以这个元素为头结点的链表</strong>，依次和插入的
key 比较，如果 key
相同就直接覆盖，不同就<strong>采用头插法插入元素</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123; <span class="comment">// 先遍历</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);  <span class="comment">// 再插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>get方法
//先算hash值，然后算出key在数组中的index下标，然后就要在数组中取值了（先判断第一个结点(链表/树))。如果相等，则返回，如果不相等则分两种情况：在树中get或者
<strong>链表中get（需要遍历）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>resize方法
每次扩容，都会进行一次重新hash分配，且会遍历所有元素（非常耗时）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ? (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="hashmap常用方法测试">HashMap常用方法测试</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 键不能重复，值可以重复</span></span><br><span class="line">        map.put(<span class="string">&quot;san&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wu&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;wang&quot;</span>, <span class="string">&quot;老王2&quot;</span>);<span class="comment">// 老王被覆盖</span></span><br><span class="line">        map.put(<span class="string">&quot;lao&quot;</span>, <span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------直接输出hashmap:-------&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历HashMap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.获取Map中的所有键</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的键:------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.print(key+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 2.获取Map中所有值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------foreach获取Map中所有的值:------&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">            System.out.print(value+<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------得到key的值的同时得到key所对应的值:-------&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys2) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot;：&quot;</span> + map.get(key)+<span class="string">&quot;   &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span></span><br><span class="line"><span class="comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class="line">        <span class="comment">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class="line">        <span class="comment">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class="line">        <span class="comment">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class="line">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;--&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashMap其他常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after map.size()：&quot;</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.isEmpty()：&quot;</span>+map.isEmpty());</span><br><span class="line">        System.out.println(map.remove(<span class="string">&quot;san&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.remove()：&quot;</span>+map);</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.get(si)：&quot;</span>+map.get(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.containsKey(si)：&quot;</span>+map.containsKey(<span class="string">&quot;si&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after containsValue(李四)：&quot;</span>+map.containsValue(<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">        System.out.println(map.replace(<span class="string">&quot;si&quot;</span>, <span class="string">&quot;李四2&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;after map.replace(si, 李四2):&quot;</span>+map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>大部分转自https://github.com/Snailclimb/JavaGuide</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-集合</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap源码</title>
    <url>/2022/10/22/review/java_guide/java/collection/source-code-concurrentHashMap/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>Java7 中 <code>ConcurrentHashMap</code> 使用的分段锁，也就是每一个
Segment 上同时只有一个线程可以操作，每一个 <code>Segment</code>
都是一个类似 <code>HashMap</code>
数组的结构，它可以扩容，它的冲突会转化为链表。但是 <code>Segment</code>
的个数一但初始化就不能改变。</p>
<p>Java8 中的 <code>ConcurrentHashMap</code> 使用的
<code>Synchronized</code> 锁加 CAS 的机制。结构也由 Java7 中的
<strong><code>Segment</code> 数组 + <code>HashEntry</code> 数组 +
链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node
是类似于一个 HashEntry
的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>
<h2 id="源码-略过">源码 （略过）</h2>
<h2 id="concurrenthashmap1.7">ConcurrentHashMap1.7</h2>
<ul>
<li>存储结构
<ul>
<li>Segment数组（该数组用来加锁，每个数组元素是一个HashEntry数组（该数组可能包含链表）</li>
<li>如图，ConcurrentHashMap由多个Segment组合，每一个Segment是一个类似HashMap的结构，每一个HashMap内部可以扩容，但是Segment个数初始化后不能改变，默认16个（即默认支持16个线程并发）
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221023124636646.png"
alt="image-20221023124636646" /></li>
</ul></li>
</ul>
<h2 id="concurrenthashmap1.8">ConcurrentHashMap1.8</h2>
<ul>
<li><p>存储结构 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221023124708670.png"
alt="image-20221023124708670" /> 可以发现 Java8 的 ConcurrentHashMap
相对于 Java7 来说变化比较大，不再是之前的 <strong>Segment 数组 +
HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 /
红黑树</strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p></li>
<li><p>初始化 initTable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 让出 CPU 使用权</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>是通过自旋和CAS操作完成的，注意的变量是sizeCtl，它的值决定着当前的初始化状态</p>
<blockquote>
<ol type="1">
<li>-1 说明正在初始化</li>
<li>-N 说明有N-1个线程正在进行扩容</li>
<li>表示 table 初始化大小，如果 table 没有初始化</li>
<li>表示 table 容量，如果 table　已经初始化。</li>
</ol>
</blockquote></li>
</ul></li>
<li><p>put</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">根据 key 计算出 hashcode 。</span><br><span class="line"></span><br><span class="line">判断是否需要进行初始化。</span><br><span class="line"></span><br><span class="line">即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</span><br><span class="line"></span><br><span class="line">如果当前位置的 hashcode == MOVED == -<span class="number">1</span>,则需要进行扩容。</span><br><span class="line"></span><br><span class="line">如果都不满足，则利用 <span class="keyword">synchronized</span> 锁写入数据。</span><br><span class="line"></span><br><span class="line">如果数量大于 TREEIFY_THRESHOLD 则要执行树化方法，在 treeifyBin 中会首先判断当前数组长度≥<span class="number">64</span>时才会将链表转换为红黑树。</span><br></pre></td></tr></table></figure></li>
<li><p>get 流程比较简单</p>
<ol type="1">
<li>根据 hash 值计算位置。</li>
<li>查找到指定位置，如果头节点就是要找的，直接返回它的 value.</li>
<li>如果头节点 hash 值小于 0 ，说明正在扩容或者是红黑树，查找之。</li>
<li>如果是链表，遍历查找之。</li>
</ol></li>
</ul>
<blockquote>
<p>大部分转自https://github.com/Snailclimb/JavaGuide</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-集合</tag>
      </tags>
  </entry>
  <entry>
    <title>aqs详解</title>
    <url>/2022/11/30/review/java_guide/java/concurrent/aqs-details/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<p><code>Semaphore  [ˈseməfɔː(r)]</code></p>
<blockquote>
<ul>
<li>何为 AQS？AQS 原理了解吗？</li>
<li><code>CountDownLatch</code> 和 <code>CyclicBarrier</code>
了解吗？两者的区别是什么？</li>
<li>用过 <code>Semaphore</code> 吗？应用场景了解吗？</li>
<li>......</li>
</ul>
</blockquote>
<h1 id="aqs简单介绍">AQS简单介绍</h1>
<p>AQS,AbstractQueueSyschronizer，即抽象队列同步器，这个类在java.util.concurrent.locks包下面</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221130154309546.png"
alt="image-20221130154309546" />
<figcaption aria-hidden="true">image-20221130154309546</figcaption>
</figure>
<p>AQS是一个抽象类，主要用来构建锁和同步器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>AQS
<strong>为构建锁和同步器提供了一些通用功能</strong>的是实现，因此，使用
AQS
能简单且高效地<strong>构造出应用广泛的大量的同步器</strong>，比如我们提到的
<strong><code>ReentrantLock</code></strong>，<strong><code>Semaphore</code></strong>，其他的诸如
<code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code>(jdk1.7)
等等皆是基于 AQS 的。</p>
<h1 id="aqs原理">AQS原理</h1>
<p><strong>面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来</strong></p>
<p>AQS
核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制
AQS 是用 <strong>CLH
队列锁</strong>实现的，即<strong>将暂时获取不到锁的线程加入到队列</strong>中。</p>
<blockquote>
<p>CLH(Craig,Landin and
Hagersten)队列是一个<strong>虚拟的双向队列</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS
是<strong>将每条请求共享资源的线程封装成一个 CLH
锁队列的一个结点</strong>（Node）来实现锁的分配。
搜索了一下，CLH好像是人名</p>
</blockquote>
<ul>
<li><p>AQS（AbstractQueuedSynchronized）原理图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221120193141243.png"
alt="image-20221120193141243" /></p>
<p>AQS使用一个<strong>int成员变量来表示同步状态</strong>，通过内置的FIFO队列来获取资源线程的排队工作。AQS<strong>使用CAS对同步状态进行原子操作</strong>并实现对其值的修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>
<p>状态信息的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AQS对资源的共享方式</p>
<ul>
<li><p>包括Exclusive（独占）和Share（共享）</p></li>
<li><p>Exclusive（独占）
<strong>只有一个线程能执行，如ReentrantLock，又分为公平锁和非公平锁</strong>，Reentrant同时支持两种所，定义：</p>
<ul>
<li><p>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tt</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Lock reLock=<span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="comment">//reLock.lock();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                reLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;线程标志&quot;</span>+finalI+<span class="string">&quot;即将停止5s&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                    log.info(<span class="string">&quot;线程标志&quot;</span>+finalI+<span class="string">&quot;停止结束&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                reLock.unlock();</span><br><span class="line">            &#125;).start();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">2022-11-30 17:27:31 下午 [Thread: Thread-1] </span></span><br><span class="line"><span class="comment">INFO:线程标志0即将停止10s</span></span><br><span class="line"><span class="comment">2022-11-30 17:27:41 下午 [Threa2022-12-01 10:19:50 上午 [Thread: Thread-1] </span></span><br><span class="line"><span class="comment">INFO:线程标志0即将停止5s</span></span><br><span class="line"><span class="comment">2022-12-01 10:19:55 上午 [Thread: Thread-1] </span></span><br><span class="line"><span class="comment">INFO:线程标志0停止结束</span></span><br><span class="line"><span class="comment">2022-12-01 10:19:55 上午 [Thread: Thread-2] </span></span><br><span class="line"><span class="comment">INFO:线程标志1即将停止5s</span></span><br><span class="line"><span class="comment">2022-12-01 10:20:00 上午 [Thread: Thread-2] </span></span><br><span class="line"><span class="comment">INFO:线程标志1停止结束</span></span><br><span class="line"><span class="comment">2022-12-01 10:20:00 上午 [Thread: Thread-3] </span></span><br><span class="line"><span class="comment">INFO:线程标志2即将停止5s</span></span><br><span class="line"><span class="comment">2022-12-01 10:20:05 上午 [Thread: Thread-3] </span></span><br><span class="line"><span class="comment">INFO:线程标志2停止结束</span></span><br><span class="line"><span class="comment">2022-12-01 10:20:05 上午 [Thread: Thread-4] </span></span><br><span class="line"><span class="comment">INFO:线程标志3即将停止5s</span></span><br><span class="line"><span class="comment">2022-12-01 10:20:10 上午 [Thread: Thread-4] </span></span><br><span class="line"><span class="comment">INFO:线程标志3停止结束</span></span><br><span class="line"><span class="comment">2022-12-01 10:20:10 上午 [Thread: Thread-5] </span></span><br><span class="line"><span class="comment">INFO:线程标志4即将停止5s</span></span><br><span class="line"><span class="comment">2022-12-01 10:20:15 上午 [Thread: Thread-5] </span></span><br><span class="line"><span class="comment">INFO:线程标志4停止结束</span></span><br><span class="line"><span class="comment">2022-12-01 10:20:15 上午 [Thread: Thread-6] </span></span><br><span class="line"><span class="comment">INFO:线程标志5即将停止5s</span></span><br><span class="line"><span class="comment">2022-12-01 10:20:20 上午 [Thread: Thread-6] </span></span><br><span class="line"><span class="comment">INFO:线程标志5停止结束</span></span><br><span class="line"><span class="comment">2022-12-01 10:20:20 上午 [Thread: Thread-7] </span></span><br><span class="line"><span class="comment">INFO:线程标志6即将停止5s</span></span><br><span class="line"><span class="comment">2022-12-01 10:20:25 上午 [Thread: Thread-7] </span></span><br><span class="line"><span class="comment">INFO:线程标志6停止结束</span></span><br><span class="line"><span class="comment">2022-12-01 10:20:25 上午 [Thread: Thread-8] </span></span><br><span class="line"><span class="comment">INFO:线程标志7即将停止5s</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>非公平锁：当线程要获取锁时，<strong>先通过两次CAS操作去抢锁</strong>，如果没抢到，当前线程<strong>再加入到队列</strong>中等待唤醒
<strong>注意这个逻辑，所以其实不好测试</strong></p></li>
</ul></li>
<li><p><strong><code>ReentrantLock</code> 中相关的源代码</strong>
ReentrantLock默认采用非公平锁，考虑获得更好的性能，通过boolean决定是否用公平锁（传入true用公平锁）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">      sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">      sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>ReentrantLock中公平锁的lock方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock中非公平锁的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>公平锁和非公平锁的两处不同:</strong></p>
<ol type="1">
<li><strong>非公平锁</strong>在调用 <strong>lock
后</strong>，首先就会<strong>调用 CAS
进行一次抢锁</strong>，如果这个时候<strong>恰巧锁没有被占用，那么直接就获取到锁返回</strong>了。</li>
<li><strong>非公平锁</strong>在 <strong>CAS
失败</strong>后，和公平锁一样都会进入到
<strong><code>tryAcquire</code></strong> 方法，在
<code>tryAcquire</code>
方法中，<strong>如果发现锁这个时候被释放了（state == 0），非公平锁会直接
CAS
抢锁</strong>，但是<strong>公平锁会判断等待队列是否有线程处于等待状态</strong>，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
<p><strong>关键字：非公平锁，公平锁，CAS，等待队列</strong>
也就是说，非公平锁有一次必须的CAS和(进入acquire)一次非必须的<strong>CAS（锁已经释放则进行）</strong>。而公平锁是直接进入acquire方法，其中先判断state
是否为0，非公平锁直接CAS，若失败则进入队列；而公平锁则会检测等待队列是否有线程处于等待</p>
<blockquote>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
</blockquote></li>
<li><p>Share(共享)
多个线程同时执行，如Semaphore/CountDownLatch。Semaphore，CountDownLatch，CyclicBarrier，ReadWriteLock后面会讲
<code>ReentrantReadWriteLock</code> 可以看成是组合式，因为
<strong><code>ReentrantReadWriteLock</code>
也就是读写锁允许多个线程同时对某一资源进行读</strong>。(时而独占，时而共享)</p></li>
</ul>
<p>不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源
state
的获取与释放方式即可</strong>，至于<strong>具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS
已经在上层已经帮我们实现</strong>好了。</p></li>
<li><p>AQS底层使用了模板方法模式 使用方式</p>
<ol type="1">
<li><p>使用者继承AbstractQueueSynchronizer并重写指定方法（<strong>无非是对于共享资源state的获取和释放</strong>）</p></li>
<li><p>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而<strong>这些模板方法会调用使用者重写的方法</strong></p></li>
<li><p>自定义同步器时，需要重写下面几个AQS提供的钩子方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。 </span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>什么是钩子方法呢？</strong>
钩子方法是一种被声明在抽象类中的方法，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式<strong>通过钩子方法控制固定步骤的实现</strong>。AQS类中除了钩子方法，其他方法都是final</p></li>
</ol>
<blockquote>
<p>重点：以 <code>ReentrantLock</code> 为例，state 初始化为
0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用
<code>tryAcquire()</code> 独占该锁并将 <code>state+1</code>
。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程
<code>unlock()</code> 到
<code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A
线程自己是可以重复获取此锁的（state
会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证
state 是能回到零态的。</p>
<p>再以 <code>CountDownLatch</code> 以例，任务分为 N
个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N
个子线程是并行执行的，每个子线程执行完后<code>countDown()</code>
一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即
<code>state=0</code> )，会 <code>unpark()</code>
主调用线程，然后主调用线程就会从 <code>await()</code>
函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但
AQS
也支持自定义同步器<strong>同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</strong></p>
</blockquote></li>
</ul>
<h1 id="semaphore">Semaphore</h1>
<p>Semaphore（信号量）可以指定多个线程同时访问某个资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Snailclimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年9月30日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 需要一次性拿一个许可的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample1</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 一次只能允许执行的线程数量。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//通行证发了20个之后，就不能再发放了</span></span><br><span class="line">          semaphore.acquire();<span class="comment">// 获取一个许可，所以可运行线程数量为20/1=20</span></span><br><span class="line">          test(threadnum);</span><br><span class="line">          semaphore.release();<span class="comment">// 释放一个许可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//拿了通行证之后，处理2s钟后才释放</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>//另一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        AtomicInteger atomicInteger=<span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        Semaphore semaphore=<span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            executorService.submit(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> atomicInteger.incrementAndGet();</span><br><span class="line">                    log.info(<span class="string">&quot;获取一个通行证&quot;</span>+ finalI); </span><br><span class="line">                    TimeUnit.SECONDS.sleep(finalI+<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;通行证&quot;</span>+ finalI +<span class="string">&quot;释放完毕&quot;</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;全部获取完毕&quot;</span>);</span><br><span class="line">        <span class="comment">//这个方法不会导致线程立即结束</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">&quot;线程池shutdown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:31 下午 [Thread: pool-1-thread-3] </span></span><br><span class="line"><span class="comment">INFO:获取一个通行证2</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:31 下午 [Thread: main] </span></span><br><span class="line"><span class="comment">INFO:全部获取完毕</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:31 下午 [Thread: main] </span></span><br><span class="line"><span class="comment">INFO:线程池shutdown</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:31 下午 [Thread: pool-1-thread-2] </span></span><br><span class="line"><span class="comment">INFO:获取一个通行证1</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:31 下午 [Thread: pool-1-thread-1] </span></span><br><span class="line"><span class="comment">INFO:获取一个通行证0</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:32 下午 [Thread: pool-1-thread-1] </span></span><br><span class="line"><span class="comment">INFO:通行证0释放完毕</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:32 下午 [Thread: pool-1-thread-4] </span></span><br><span class="line"><span class="comment">INFO:获取一个通行证3</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:33 下午 [Thread: pool-1-thread-2] </span></span><br><span class="line"><span class="comment">INFO:通行证1释放完毕</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:33 下午 [Thread: pool-1-thread-5] </span></span><br><span class="line"><span class="comment">INFO:获取一个通行证4</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:34 下午 [Thread: pool-1-thread-3] </span></span><br><span class="line"><span class="comment">INFO:通行证2释放完毕</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:34 下午 [Thread: pool-1-thread-6] </span></span><br><span class="line"><span class="comment">INFO:获取一个通行证5</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:36 下午 [Thread: pool-1-thread-4] </span></span><br><span class="line"><span class="comment">INFO:通行证3释放完毕</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:36 下午 [Thread: pool-1-thread-7] </span></span><br><span class="line"><span class="comment">INFO:获取一个通行证6</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:38 下午 [Thread: pool-1-thread-5] </span></span><br><span class="line"><span class="comment">INFO:通行证4释放完毕</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:38 下午 [Thread: pool-1-thread-8] </span></span><br><span class="line"><span class="comment">INFO:获取一个通行证7</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:40 下午 [Thread: pool-1-thread-6] </span></span><br><span class="line"><span class="comment">INFO:通行证5释放完毕</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:43 下午 [Thread: pool-1-thread-7] </span></span><br><span class="line"><span class="comment">INFO:通行证6释放完毕</span></span><br><span class="line"><span class="comment">2022-12-01 14:21:46 下午 [Thread: pool-1-thread-8] </span></span><br><span class="line"><span class="comment">INFO:通行证7释放完毕</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Process finished with exit code 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如上所示，先是获取了210，之后释放一个获取一个(最多获取3个)，</span></span><br><span class="line"><span class="comment">3+n*2 =10 ，之后陆续释放0获取3，释放1获取4，释放2获取5</span></span><br><span class="line"><span class="comment">之后 释放3获取6，释放4获取7；</span></span><br><span class="line"><span class="comment">这是还有5,7,6拿着通行证</span></span><br><span class="line"><span class="comment">之后随机将5，7，6释放掉即可。 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>//如上，shutdown不会立即停止，而是：</p>
<ol type="1">
<li><p>线程池shutdown之后不再接收新任务</p></li>
<li><p>sutdown只是将线程池的状态设置为SHUTWDOWN状态，正在执行的任务会继续执行下去，没有被执行的则中断。而shutdownNow则是将线程池的状态设置为STOP，正在执行的任务则被停止，没被执行任务的则返回。如果是shutdownNow,则会报这个问题</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">  	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">  	at java.lang.Thread.sleep(Thread.java:<span class="number">340</span>)</span><br><span class="line">  	at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class="number">386</span>)</span><br><span class="line">  	at com.ly.SemaphoreExample2.lambda$main$<span class="number">0</span>(SemaphoreExample2.java:<span class="number">45</span>)</span><br><span class="line">  	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)</span><br><span class="line">  	at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">  	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">  	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">  	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br></pre></td></tr></table></figure></p>
<p>解释最上面的例子：</p>
<ol type="1">
<li>执行acquire()方法会导致阻塞，知道有一个许可证可以获得然后拿走一个许可证</li>
<li>每个release()方法增加一个许可证，这可能会释放一个阻塞的acquire()方法</li>
<li>Semaphore只是维持了一个可以获得许可证的数量，<strong>没有实际的许可证这个对象</strong></li>
<li>Semaphore经常用于<strong>限制获取某种资源的线程数量</strong></li>
</ol>
<blockquote>
<p>可以一次性获取或释放多个许可，不过没必要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">semaphore.acquire(<span class="number">5</span>);<span class="comment">// 获取5个许可，所以可运行线程数量为20/5=4</span></span><br><span class="line">test(threadnum);</span><br><span class="line">semaphore.release(<span class="number">5</span>);<span class="comment">// 释放5个许可</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>对应的使用tryAcquire，如果获取不到许可就立即返回false</p></li>
</ol>
<p>Semaphore有两种模式，<strong>公平模式</strong>和<strong>非公平模式</strong></p>
<ul>
<li>公平模式：调用acquire()方法的顺序，就是获取许可证的顺序，遵循FIFO</li>
<li>非公平模式：抢占式的</li>
</ul>
<p>两个构造函数，<strong>必须提供许可数量</strong>，第二个构造方法可以指定是公平模式还是非公平模式，<strong>默认非公平模式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">     sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">     sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(permits) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Semaphore</code> 与 <code>CountDownLatch</code>
一样，也是共享锁的一种实现。它<strong>默认构造 AQS 的 state 为
<code>permits</code></strong>。当执行任务的线程<strong>数量超出
<code>permits</code>，那么多余的线程将会被放入阻塞队列 Park,并自旋判断
state 是否大于 0。只有当 state 大于 0
的时候，阻塞的线程才能继续执行</strong>,此时先前执行任务的线程继续执行
<code>release()</code> 方法，<strong><code>release()</code> 方法使得
state 的变量会加 1，那么自旋的线程便会判断成功</strong>。
如此，每次只有最多不超过 <code>permits</code>
数量的线程能自旋成功，便限制了执行任务线程的数量。</p>
</blockquote>
<h1 id="countdownlatch倒计时">CountDownLatch(倒计时)</h1>
<ul>
<li><code>翻译：闭锁(倒计时锁)</code></li>
<li>允许count个线程阻塞在一个地方，直至所有线程的任务都执行完毕</li>
<li>CountDownLatch是共享锁的一种实现（<strong>我的理解是await的时候，其他线程可以执行，而不是lock，所以是"共享"</strong>），默认构造AQS的state值为count。当线程使用countDown()方法时，其实是使用了tryReleaseShared方法以CAS操作来减少state，直至state为0</li>
<li>当调用await()方法时，如果state不为0，那就证明任务还没有执行完毕,await()方法会一直阻塞，即await()方法之后的语句不会被执行。<strong>之后</strong>CountDownLatch会自旋CAS判断state==0，如果state
== 0就会释放所有等待线程，await()方法之后的语句得到执行</li>
</ul>
<h2 id="countdownlatch的两种典型用法">CountDownLatch的两种典型用法</h2>
<ol type="1">
<li><p>某线程在开始运行前等待n个线程执行完毕</p>
<blockquote>
<p>将 <code>CountDownLatch</code> 的计数器初始化为 n
（<strong><code>new CountDownLatch(n)</code></strong>），每<strong>当一个任务线程执行完毕</strong>，就将计数器减
1
（<strong><code>countdownlatch.countDown()</code></strong>），当计数器的值<strong>变为
0</strong> 时，在 <strong><code>CountDownLatch 上 await()</code>
的线程就会被唤醒</strong>。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p>
</blockquote></li>
<li><p>实现多个线程开始执行任务的<strong>最大并行性</strong>
<strong>为什么是最大呢，我觉得是因为即使线程已经start，但是不一定就全部启动了，有可能cpu调度并没有真正启动它</strong>（概率极小）</p>
<blockquote>
<p>注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的
<code>CountDownLatch</code> 对象，将其计数器初始化为 1
（<code>new CountDownLatch(1)</code>），多个线程在开始执行任务前首先
<code>coundownlatch.await()</code>，当主线程调用
<code>countDown()</code> 时，计数器变为 0，多个线程同时被唤醒。</p>
</blockquote></li>
</ol>
<p>CountDownLatch使用示例</p>
<p>300个线程，550个请求（及count =
550）。启动线程后，主线程阻塞。当所有请求都countDown，主线程恢复运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SnailClimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月1日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: CountDownLatch 使用方法示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadnum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          countDownLatch.countDown();<span class="comment">// 表示一个请求已经被完成</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li><p>与CountDownLatch的第一次交互是主线程等待其他线程</p></li>
<li><p>主线程必须在启动其他线程后立即调用CountDownLatch.await()方法，这样主线程的操作就会在这个方法阻塞，直到其他线程完成各自任务</p></li>
<li><p>其他N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象
--已经完成各自任务（通过countDown()），每调用一次该方法count值减1</p></li>
<li><p>当count值为0时，主线程就能通过await()方法恢复执行自己的任务</p></li>
<li><p>如果使用不当会造成死锁（count始终不为0），导致一直等待</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount-<span class="number">1</span>; i++) &#123;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="countdownlatch-的不足">CountDownLatch 的不足</h2>
<p><strong><code>CountDownLatch</code>
是一次性的</strong>，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当
<code>CountDownLatch</code>
<strong>使用完毕后，它不能再次被使用</strong>。</p>
<h2 id="countdownlatch-相常见面试题">CountDownLatch 相常见面试题</h2>
<ul>
<li><code>CountDownLatch</code> 怎么用？应用场景是什么？</li>
<li><code>CountDownLatch</code> 和 <code>CyclicBarrier</code>
的不同之处？</li>
<li><code>CountDownLatch</code> 类中主要的方法？</li>
</ul>
<h1 id="cyclicbarrier">CyclicBarrier</h1>
<ul>
<li>CyclicBarrier和CountDownLatch类似，可以实现线程间的技术等待，主要应用场景和CountDownLatch类似，但更复杂强大</li>
<li>CountDownLatch基于AQS，而CycliBarrier基于ReentrantLock（ReentrantLock属于AQS同步器）和Condition</li>
<li><code>CyclicBarrier</code>
的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让<strong>一组线程(中的一个)到达一个屏障（也可以叫同步点）时</strong>被阻塞，直到<strong>最后一个线程到达屏障</strong>时，<strong>屏障才会开门</strong>，所有被屏障拦截的线程才会继续干活。</li>
<li><code>CyclicBarrier</code> 默认的构造方法是
<code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用
<code>await()</code> 方法<strong>告诉 <code>CyclicBarrier</code>
我已经到达了屏障，然后当前线程被阻塞</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Snailclimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月1日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 测试 CyclicBarrier 类中带参数的 await() 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample2</span> &#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">550</span>;</span><br><span class="line">  <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> i;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>); <span class="comment">///注意这行</span></span><br><span class="line">      threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadNum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is ready&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/**等待60秒，保证子线程完全执行结束*/</span></span><br><span class="line">      <span class="comment">//如果等待的时间，超过了60秒，那么就会抛出异常，而且还会进行重置(变为0个线程再等待)</span></span><br><span class="line">      cyclicBarrier.await(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">      <span class="comment">//最后一个(第5个到达后，count会重置为0)</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;-----CyclicBarrierException------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum + <span class="string">&quot;is finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment"> threadnum:0is ready</span></span><br><span class="line"><span class="comment">threadnum:1is ready</span></span><br><span class="line"><span class="comment">threadnum:2is ready</span></span><br><span class="line"><span class="comment">threadnum:3is ready</span></span><br><span class="line"><span class="comment">threadnum:4is ready</span></span><br><span class="line"><span class="comment">threadnum:4is finish</span></span><br><span class="line"><span class="comment">threadnum:0is finish</span></span><br><span class="line"><span class="comment">threadnum:1is finish</span></span><br><span class="line"><span class="comment">threadnum:2is finish</span></span><br><span class="line"><span class="comment">threadnum:3is finish</span></span><br><span class="line"><span class="comment">threadnum:5is ready</span></span><br><span class="line"><span class="comment">threadnum:6is ready</span></span><br><span class="line"><span class="comment">threadnum:7is ready</span></span><br><span class="line"><span class="comment">threadnum:8is ready</span></span><br><span class="line"><span class="comment">threadnum:9is ready</span></span><br><span class="line"><span class="comment">threadnum:9is finish</span></span><br><span class="line"><span class="comment">threadnum:5is finish</span></span><br><span class="line"><span class="comment">threadnum:8is finish</span></span><br><span class="line"><span class="comment">threadnum:7is finish</span></span><br><span class="line"><span class="comment">threadnum:6is finish</span></span><br><span class="line"><span class="comment">...... </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里，如果把Thread.sleep(1000)去掉，顺序(情况之一)为：</span></span><br><span class="line"><span class="comment">//也就是说，上面的代码，导致的现象：所有的ready都挤在一起了(而且不分先后，随时执行，而某5个的finish，会等待那5个的ready执行完才会执行，且finish没有顺序的)</span></span><br><span class="line"><span class="comment">//★如上，ready也是没有顺序的</span></span><br><span class="line"><span class="comment">/*threadnum:0is ready</span></span><br><span class="line"><span class="comment">threadnum:5is ready</span></span><br><span class="line"><span class="comment">threadnum:9is ready</span></span><br><span class="line"><span class="comment">threadnum:7is ready</span></span><br><span class="line"><span class="comment">threadnum:3is ready</span></span><br><span class="line"><span class="comment">threadnum:8is ready</span></span><br><span class="line"><span class="comment">threadnum:4is ready</span></span><br><span class="line"><span class="comment">threadnum:2is ready</span></span><br><span class="line"><span class="comment">threadnum:1is ready</span></span><br><span class="line"><span class="comment">threadnum:6is ready</span></span><br><span class="line"><span class="comment">------当线程数达到之后，优先执行------</span></span><br><span class="line"><span class="comment">threadnum:3is finish</span></span><br><span class="line"><span class="comment">threadnum:10is ready</span></span><br><span class="line"><span class="comment">------当线程数达到之后，优先执行------</span></span><br><span class="line"><span class="comment">threadnum:10is finish</span></span><br><span class="line"><span class="comment">threadnum:11is ready</span></span><br><span class="line"><span class="comment">threadnum:0is finish</span></span><br><span class="line"><span class="comment">threadnum:5is finish</span></span><br><span class="line"><span class="comment">threadnum:4is finish</span></span><br><span class="line"><span class="comment">threadnum:1is finish</span></span><br><span class="line"><span class="comment">threadnum:8is finish</span></span><br><span class="line"><span class="comment">threadnum:12is ready</span></span><br><span class="line"><span class="comment">threadnum:9is finish</span></span><br><span class="line"><span class="comment">threadnum:7is finish</span></span><br><span class="line"><span class="comment">threadnum:16is ready</span></span><br><span class="line"><span class="comment">threadnum:15is ready</span></span><br><span class="line"><span class="comment">------当线程数达到之后，优先执行------</span></span><br><span class="line"><span class="comment">threadnum:14is ready</span></span><br><span class="line"><span class="comment">threadnum:6is finish</span></span><br><span class="line"><span class="comment">threadnum:13is ready</span></span><br><span class="line"><span class="comment">threadnum:2is finish</span></span><br><span class="line"><span class="comment">threadnum:19is ready</span></span><br><span class="line"><span class="comment">threadnum:16is finish</span></span><br><span class="line"><span class="comment">threadnum:12is finish</span></span><br><span class="line"><span class="comment">threadnum:18is ready</span></span><br><span class="line"><span class="comment">threadnum:11is finish</span></span><br><span class="line"><span class="comment">threadnum:23is ready</span></span><br><span class="line"><span class="comment">------当线程数达到之后，优先执行------</span></span><br><span class="line"><span class="comment">threadnum:17is ready</span></span><br><span class="line"><span class="comment">threadnum:19is finish</span></span><br><span class="line"><span class="comment">threadnum:15is finish</span></span><br><span class="line"><span class="comment">threadnum:25is ready</span></span><br><span class="line"><span class="comment">threadnum:24is ready</span></span><br><span class="line"><span class="comment">threadnum:18is finish</span></span><br><span class="line"><span class="comment">threadnum:26is ready</span></span><br><span class="line"><span class="comment">threadnum:13is finish</span></span><br><span class="line"><span class="comment">threadnum:14is finish</span></span><br><span class="line"><span class="comment">threadnum:23is finish</span></span><br><span class="line"><span class="comment">threadnum:22is ready</span></span><br><span class="line"><span class="comment">threadnum:21is ready</span></span><br><span class="line"><span class="comment">threadnum:20is ready</span></span><br><span class="line"><span class="comment">------当线程数达到之后，优先执行------</span></span><br><span class="line"><span class="comment">threadnum:29is ready</span></span><br><span class="line"><span class="comment">threadnum:28is ready</span></span><br><span class="line"><span class="comment">threadnum:27is ready</span></span><br><span class="line"><span class="comment">threadnum:22is finish</span></span><br><span class="line"><span class="comment">threadnum:24is finish</span></span><br><span class="line"><span class="comment">threadnum:25is finish</span></span><br><span class="line"><span class="comment">threadnum:32is ready</span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BarrierTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException, BrokenBarrierException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cyclicBarrier.await( );</span><br><span class="line">                System.out.println(<span class="string">&quot;数量11====&quot;</span>+cyclicBarrier.getNumberWaiting());</span><br><span class="line">                System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数量异常1111===&quot;</span>+cyclicBarrier.getNumberWaiting());</span><br><span class="line">                <span class="comment">// e.printStackTrace();</span></span><br><span class="line">                System.out.println(<span class="string">&quot;报错1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数量2222====&quot;</span>+cyclicBarrier.getNumberWaiting());</span><br><span class="line">                cyclicBarrier.await(<span class="number">111</span>,TimeUnit.SECONDS);</span><br><span class="line">                System.out.println(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数量异常2222====&quot;</span>+cyclicBarrier.getNumberWaiting());</span><br><span class="line">                System.out.println(<span class="string">&quot;报错2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数量33 await前====&quot;</span>+cyclicBarrier.getNumberWaiting());</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;数量33 await后====&quot;</span>+cyclicBarrier.getNumberWaiting());</span><br><span class="line">                System.out.println(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数量异常333====&quot;</span>+cyclicBarrier.getNumberWaiting());</span><br><span class="line">                System.out.println(<span class="string">&quot;报错3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 数量2222====1</span></span><br><span class="line"><span class="comment">数量33 await前====2</span></span><br><span class="line"><span class="comment">数量33 await后====0</span></span><br><span class="line"><span class="comment">333</span></span><br><span class="line"><span class="comment">数量11====0</span></span><br><span class="line"><span class="comment">111</span></span><br><span class="line"><span class="comment">222</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="cyclicbarrier源码分析">CyclicBarrier源码分析</h1>
<ul>
<li><p>当调用CyclicBarrier对象调用await()
方法时，实际上调用的是dowait(false,0L )方法【主要用到false】</p>
<blockquote>
<p><code>await()</code>
方法就像树立起一个栅栏的行为一样，将线程挡住了，当拦住的线程数量达到
<code>parties</code> 的值时，栅栏才会打开，线程才得以通过执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">   	 <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>dowait(false,0L)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当线程数量或者请求数量达到 count 时 await 之后的方法才会被执行。上面的示例中 count 的值就为 5。</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">     <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">            TimeoutException &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">     <span class="comment">// 锁住</span></span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">  </span><br><span class="line">         <span class="keyword">if</span> (g.broken)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line">  </span><br><span class="line">         <span class="comment">// 如果线程中断了，抛出异常</span></span><br><span class="line">         <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">             breakBarrier();</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// cout减1  //★前面锁住了，所以不需要CAS</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">         <span class="comment">//★★ 当 count 数量减为 0 之后说明最后一个线程已经到达栅栏了，也就是达到了可以执行await 方法之后的条件</span></span><br><span class="line">         <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">             <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                 <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                     command.run();</span><br><span class="line">                 ranAction = <span class="literal">true</span>;</span><br><span class="line">                 <span class="comment">// 将 count 重置为 parties 属性的初始化值</span></span><br><span class="line">                 <span class="comment">// 唤醒之前等待的线程</span></span><br><span class="line">                 <span class="comment">// 下一波执行开始</span></span><br><span class="line">                 nextGeneration();</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                     breakBarrier();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">  </span><br><span class="line">         <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (!timed)</span><br><span class="line">                     trip.await();</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                     nanos = trip.awaitNanos(nanos);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                     breakBarrier();</span><br><span class="line">                     <span class="keyword">throw</span> ie;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                     <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                     <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                     Thread.currentThread().interrupt();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">  </span><br><span class="line">             <span class="keyword">if</span> (g.broken)</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line">  </span><br><span class="line">             <span class="keyword">if</span> (g != generation)</span><br><span class="line">                 <span class="keyword">return</span> index;</span><br><span class="line">  </span><br><span class="line">             <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                 breakBarrier();</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结：<code>CyclicBarrier</code> 内部通过一个 count
变量作为计数器，count 的初始值为 parties
属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果
count 值为 0
了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务</p>
<hr />
<p>著作权归所有
原文链接：https://javaguide.cn/java/concurrent/aqs.html</p>
</blockquote></li>
</ul>
<h1
id="cyclicbarrier和countdownlatch区别">CyclicBarrier和CountDownLatch区别</h1>
<ol type="1">
<li><p><code>CountDownLatch</code> 是计数器，只能使用一次，而
<code>CyclicBarrier</code> 的计数器提供 <code>reset</code>
功能，可以多次使用。</p></li>
<li><p>从jdk作者设计的目的来看，javadoc是这么描述他们的</p>
<blockquote>
<p>CountDownLatch: A synchronization aid that allows one or more threads
to wait until a set of operations being performed in other threads
completes.(CountDownLatch:
一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；)
CyclicBarrier : A synchronization aid that allows a set of threads to
all wait for each other to reach a common barrier point.(CyclicBarrier :
多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p>
<p><strong>需要结合上面的代码示例，CyclicBarrier示例是这个意思</strong></p>
</blockquote></li>
<li><p>对于 <code>CountDownLatch</code>
来说，重点是“一个线程（多个线程）等待”，而其他的 N
个线程在完成“某件事情”之后，可以终止，也可以等待。【强调的是某个(组)等另一组线程完成】<br />
而对于
<code>CyclicBarrier</code>，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。【强调的是互相】</p></li>
<li><p><code>CountDownLatch</code>
是<strong>计数器</strong>，线程完成一个记录一个，只不过计数不是递增而是递减，而
<code>CyclicBarrier</code>
更像是一个<strong>阀门</strong>，需要所有线程都到达，阀门才能打开，然后继续执行。</p></li>
</ol>
<h1
id="reentrantlock和reentrantreadwritelock">ReentrantLock和ReentrantReadWriteLock</h1>
<p>读写锁 <code>ReentrantReadWriteLock</code>
可以保证<strong>多个线程可以同时读</strong>，所以在<strong>读操作远大于写操作的时候</strong>，读写锁就非常有用了。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Atomic原子类介绍</title>
    <url>/2022/12/05/review/java_guide/java/concurrent/atomic-classes/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="原子类介绍">原子类介绍</h1>
<ul>
<li>在化学上，原子是构成一般物质的最小单位，化学反应中是不可分割的，Atomic指<strong>一个操作是不可中断的</strong>，即使在多个线程一起执行时，一个操作一旦开始就<strong>不会被其他线程干扰</strong></li>
<li>原子类--&gt;具有原子/原子操作特征的类</li>
<li>并发包java.util.concurrent
的原子类都放着<code>java.util.concurrent.atomic</code>中 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221205094229003.png"
alt="image-20221205094229003" /></li>
<li>根据操作的数据类型，可以将JUC包中的原子类分为4类（基本类型、数组类型、引用类型、对象的属性修改类型）
<ul>
<li><p>基本类型 使用原子方式更新基本类型，包括<strong>AtomicInteger
整型原子类</strong>，<strong>AtomicLong
长整型原子类</strong>，AtomicBoolean 布尔型原子类</p></li>
<li><p>数组类型
使用原子方式更新数组里某个元素，包括<strong>AtomicIntegerArray
整型数组原子类</strong>，<strong>AtomicLongArray
长整型数组原子类</strong>，<strong>AtomicReferenceArray
引用类型数组原子类</strong></p></li>
<li><p>引用类型 <strong>AtomicReference
引用类型原子类</strong>，AtomicMarkableReference
原子更新带<strong>有标记</strong>的引用类型，该类将boolean标记与引用关联（<strong>不可解决CAS进行原子操作出现的ABA问题</strong>），<strong>AtomicStampedReference</strong>
原子更新带有版本号的引用类型
该类将整数值与引用关联，可用于解决原子更新<strong>数据和数据的版本号(解决使用CAS进行原子更新时可能出现的ABA问题)</strong></p></li>
<li><p>对象的属性修改类型 <strong>AtomicIntegerFieldUpdater
原子更新整型字段的更新器</strong>，<strong>AtomicLongFieldUpdater
原子更新长整型字段的更新器</strong>，
<strong>AtomicReferenceFieldUpdater
原子更新引用类型里的字段</strong></p></li>
<li><p><code>AtomicMarkableReference</code> 不能解决 ABA 问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SolveABAByAtomicMarkableReference</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicMarkableReference</span> <span class="variable">atomicMarkableReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>(<span class="number">100</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">refT1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicMarkableReference.isMarked(), !atomicMarkableReference.isMarked());</span><br><span class="line">            atomicMarkableReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicMarkableReference.isMarked(), !atomicMarkableReference.isMarked());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">refT2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取原来的marked标记(false)</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">marked</span> <span class="operator">=</span> atomicMarkableReference.isMarked();</span><br><span class="line">            <span class="comment">//2s之后进行替换,不应该替换成功</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">c3</span> <span class="operator">=</span> atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, marked, !marked);</span><br><span class="line">            System.out.println(c3); <span class="comment">// 返回true,实际应该返回false</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        refT1.start();</span><br><span class="line">        refT2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>CAS ABA问题</p>
<blockquote>
<p>描述: 第一个线程取到了变量 x 的值
A，然后巴拉巴拉干别的事，总之就是只拿到了变量 x 的值
A。这段时间内第二个线程也取到了变量 x 的值 A，然后把变量 x 的值改为
B，然后巴拉巴拉干别的事，最后又把变量 x 的值变为 A
（相当于还原了）。在这之后第一个线程终于进行了变量 x
的操作，但是此时变量 x 的值还是 A，所以 compareAndSet 操作是成功。</p>
<hr />
<p>也就是说，线程一无法保证自己操作期间，该值被修改了</p>
</blockquote></li>
<li><p>例子描述(可能不太合适，但好理解):
年初，现金为零，然后通过正常劳动赚了三百万，之后正常消费了（比如买房子）三百万。年末，虽然现金零收入（可能变成其他形式了），但是赚了钱是事实，还是得交税的！</p></li>
<li><p>代码描述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerDefectDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        defectOfABA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">defectOfABA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">coreThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">currentValue</span> <span class="operator">=</span> atomicInteger.get();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ------ currentValue=&quot;</span> + currentValue);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这段目的：模拟处理其他业务花费的时间</span></span><br><span class="line">                    <span class="comment">//也就是说，在差值300-100=200ms内，值被操作了两次(但又改回去了)，然后线程coreThread并没有感知到，当作没有修改过来处理</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">casResult</span> <span class="operator">=</span> atomicInteger.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot; ------ currentValue=&quot;</span> + currentValue</span><br><span class="line">                            + <span class="string">&quot;, finalValue=&quot;</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">&quot;, compareAndSet Result=&quot;</span> + casResult);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        coreThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这段目的：为了让 coreThread 线程先跑起来</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">amateurThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">currentValue</span> <span class="operator">=</span> atomicInteger.get();</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">casResult</span> <span class="operator">=</span> atomicInteger.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot; ------ currentValue=&quot;</span> + currentValue</span><br><span class="line">                            + <span class="string">&quot;, finalValue=&quot;</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">&quot;, compareAndSet Result=&quot;</span> + casResult);</span><br><span class="line"></span><br><span class="line">                    currentValue = atomicInteger.get();</span><br><span class="line">                    casResult = atomicInteger.compareAndSet(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot; ------ currentValue=&quot;</span> + currentValue</span><br><span class="line">                            + <span class="string">&quot;, finalValue=&quot;</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">&quot;, compareAndSet Result=&quot;</span> + casResult);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        amateurThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*输出内容</span></span><br><span class="line"><span class="comment"> Thread-0 ------ currentValue=1</span></span><br><span class="line"><span class="comment">Thread-1 ------ currentValue=1, finalValue=2, compareAndSet Result=true</span></span><br><span class="line"><span class="comment">Thread-1 ------ currentValue=2, finalValue=1, compareAndSet Result=true</span></span><br><span class="line"><span class="comment">Thread-0 ------ currentValue=1, finalValue=2, compareAndSet Result=true </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h1 id="基本类型原子类">基本类型原子类</h1>
<ul>
<li><p>使用原子方式更新基本类型：AtomicInteger 整型原子类，AtomicLong
长整型原子类 ，AtomicBoolean
布尔型原子类，下文以AtomicInteger为例子来介绍 常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>
<p>常见方法使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">temvalue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">		temvalue = i.getAndSet(<span class="number">3</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);<span class="comment">//temvalue:0;  i:3</span></span><br><span class="line">		temvalue = i.getAndIncrement();</span><br><span class="line">		System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);<span class="comment">//temvalue:3;  i:4</span></span><br><span class="line">		temvalue = i.getAndAdd(<span class="number">5</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);<span class="comment">//temvalue:4;  i:9</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>基本数据类型原子类的优势</p>
<ul>
<li><p>多线程环境不使用原子类保证线程安全（基本数据类型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//若要线程安全执行执行count++，需要加锁</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">                  count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>多线程环境使用原子类保证线程安全(基本数据类型)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    </span><br><span class="line">	    <span class="comment">//使用AtomicInteger之后，不需要加锁，也可以实现线程安全。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">                  count.incrementAndGet();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>AtomicInteger线程安全原理简单分析 部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/ setup to use Unsafe.compareAndSwapInt <span class="keyword">for</span> updates（更新操作时提供“比较并替换”的作用）</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value; </span><br></pre></td></tr></table></figure>
<ol type="1">
<li>AtomicInteger类主要利用CAS（compare and swap) + volatile 和
native方法来保证原子操作，从而避免synchronized高开销，提高执行效率</li>
<li>CAS的原理是拿期望的值和原本的值做比较，如果相同则更新成新值
UnSafe类的objectFieldOffset()方法是一个本地方法，这个方法用来拿到<strong>"原来的值"的内存地址</strong></li>
<li>value是一个volatile变量，在内存中可见，因此JVM可以保证任何时刻任何线程总能拿到该变量的最新值</li>
</ol></li>
</ul></li>
</ul>
<h1 id="数组类型原子类">数组类型原子类</h1>
<p>使用原子的方式更新数组里的某个元素</p>
<p>AtomicIntegerArray 整型数组原子类，AtomicLongArray
长整型数组原子类，AtomicReferenceArray 引用类型数组原子类</p>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> newValue)</span><span class="comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 </span></span><br></pre></td></tr></table></figure>
<p>常见方法使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerArrayTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">temvalue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">		<span class="type">AtomicIntegerArray</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(nums);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">			System.out.println(i.get(j));</span><br><span class="line">		&#125;</span><br><span class="line">		temvalue = i.getAndSet(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">		temvalue = i.getAndIncrement(<span class="number">0</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">		temvalue = i.getAndAdd(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;temvalue:&quot;</span> + temvalue + <span class="string">&quot;;  i:&quot;</span> + i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="引用类型原子类">引用类型原子类</h1>
<p>基本类型原子类只能更新一个变量，如果需要<strong>原子更新多个变量</strong>，则需要使用<strong>引用类型原子类</strong></p>
<p>AtomicReference 引用类型原子类；AtomicStampedReference
原子更新带有版本号的引用类型，该类将整数值与引用关联起来，可用于解决<strong>原子的更新数据和数据的版本号</strong>，该类将boolean标记与引用关联<strong>（注：无法解决ABA问题）</strong></p>
<p>下面以AtomicReference为例介绍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReferenceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		AtomicReference&lt;Person&gt; ar = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;Person&gt;();</span><br><span class="line">		<span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;SnailClimb&quot;</span>, <span class="number">22</span>);</span><br><span class="line">		ar.set(person);</span><br><span class="line">		<span class="type">Person</span> <span class="variable">updatePerson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Daisy&quot;</span>, <span class="number">20</span>);</span><br><span class="line">		ar.compareAndSet(person, updatePerson);</span><br><span class="line"></span><br><span class="line">		System.out.println(ar.get().getName());</span><br><span class="line">		System.out.println(ar.get().getAge());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码首先创建了一个 Person 对象，然后把 Person 对象设置进
AtomicReference 对象中，然后调用 compareAndSet 方法，该方法就是通过 CAS
操作设置 ar。如果 ar 的值为 person 的话，则将其设置为
updatePerson。实现原理与 AtomicInteger 类中的 compareAndSet
方法相同。运行上面的代码后的输出结果如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Daisy</span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>AtomicStampedReference类使用示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicStampedReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化、取当前值和 stamp 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">initialRef</span> <span class="operator">=</span> <span class="number">0</span>, initialStamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicStampedReference&lt;Integer&gt; asr = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(initialRef, initialStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference() + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare and set</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">newReference</span> <span class="operator">=</span> <span class="number">666</span>, newStamp = <span class="number">999</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">casResult</span> <span class="operator">=</span> asr.compareAndSet(initialRef, newReference, initialStamp, newStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">&quot;, casResult=&quot;</span> + casResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的值和当前的 stamp 值</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">currentValue</span> <span class="operator">=</span> asr.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">currentStamp</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + currentValue + <span class="string">&quot;, currentStamp=&quot;</span> + currentStamp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独设置 stamp 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">attemptStampResult</span> <span class="operator">=</span> asr.attemptStamp(newReference, <span class="number">88</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">&quot;, attemptStampResult=&quot;</span> + attemptStampResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新设置当前值和 stamp 值</span></span><br><span class="line">        asr.set(initialRef, initialStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference() + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [不推荐使用，除非搞清楚注释的意思了] weak compare and set</span></span><br><span class="line">        <span class="comment">// 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191]</span></span><br><span class="line">        <span class="comment">// 但是注释上写着 &quot;May fail spuriously and does not provide ordering guarantees,</span></span><br><span class="line">        <span class="comment">// so is only rarely an appropriate alternative to compareAndSet.&quot;</span></span><br><span class="line">        <span class="comment">// todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">wCasResult</span> <span class="operator">=</span> asr.weakCompareAndSet(initialRef, newReference, initialStamp, newStamp);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + asr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentStamp=&quot;</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">&quot;, wCasResult=&quot;</span> + wCasResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment"> currentValue=0, currentStamp=0</span></span><br><span class="line"><span class="comment">currentValue=666, currentStamp=999, casResult=true</span></span><br><span class="line"><span class="comment">currentValue=666, currentStamp=999</span></span><br><span class="line"><span class="comment">currentValue=666, currentStamp=88, attemptStampResult=true</span></span><br><span class="line"><span class="comment">currentValue=0, currentStamp=0</span></span><br><span class="line"><span class="comment">currentValue=666, currentStamp=999, wCasResult=true </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>AtomicMarkableReference 类使用示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicMarkableReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化、取当前值和 mark 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">initialRef</span> <span class="operator">=</span> <span class="literal">null</span>, initialMark = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicMarkableReference&lt;Boolean&gt; amr = <span class="keyword">new</span> <span class="title class_">AtomicMarkableReference</span>&lt;&gt;(initialRef, initialMark);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference() + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare and set</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">newReference1</span> <span class="operator">=</span> <span class="literal">true</span>, newMark1 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">casResult</span> <span class="operator">=</span> amr.compareAndSet(initialRef, newReference1, initialMark, newMark1);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">&quot;, casResult=&quot;</span> + casResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的值和当前的 mark 值</span></span><br><span class="line">        <span class="type">boolean</span>[] arr = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">currentValue</span> <span class="operator">=</span> amr.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">currentMark</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + currentValue + <span class="string">&quot;, currentMark=&quot;</span> + currentMark);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单独设置 mark 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">attemptMarkResult</span> <span class="operator">=</span> amr.attemptMark(newReference1, <span class="literal">false</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">&quot;, attemptMarkResult=&quot;</span> + attemptMarkResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新设置当前值和 mark 值</span></span><br><span class="line">        amr.set(initialRef, initialMark);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference() + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [不推荐使用，除非搞清楚注释的意思了] weak compare and set</span></span><br><span class="line">        <span class="comment">// 困惑！weakCompareAndSet 这个方法最终还是调用 compareAndSet 方法。[版本: jdk-8u191]</span></span><br><span class="line">        <span class="comment">// 但是注释上写着 &quot;May fail spuriously and does not provide ordering guarantees,</span></span><br><span class="line">        <span class="comment">// so is only rarely an appropriate alternative to compareAndSet.&quot;</span></span><br><span class="line">        <span class="comment">// todo 感觉有可能是 jvm 通过方法名在 native 方法里面做了转发</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">wCasResult</span> <span class="operator">=</span> amr.weakCompareAndSet(initialRef, newReference1, initialMark, newMark1);</span><br><span class="line">        System.out.println(<span class="string">&quot;currentValue=&quot;</span> + amr.getReference()</span><br><span class="line">                + <span class="string">&quot;, currentMark=&quot;</span> + amr.isMarked()</span><br><span class="line">                + <span class="string">&quot;, wCasResult=&quot;</span> + wCasResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment"> currentValue=null, currentMark=false</span></span><br><span class="line"><span class="comment">currentValue=true, currentMark=true, casResult=true</span></span><br><span class="line"><span class="comment">currentValue=true, currentMark=true</span></span><br><span class="line"><span class="comment">currentValue=true, currentMark=false, attemptMarkResult=true</span></span><br><span class="line"><span class="comment">currentValue=null, currentMark=false</span></span><br><span class="line"><span class="comment">currentValue=true, currentMark=true, wCasResult=true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="对象的属性修改类型原子类">对象的属性修改类型原子类</h1>
<p><strong>对象的属性修改类型原子类</strong>，用来原子更新某个类里的某个字段</p>
<p>包括： AtomicIntegerFieldUpdater
原子更新整型字段的更新器，AtomicLongFieldUpdater
原子更新长整型字段的更新器，AtomicReferenceFieldUpdater
原子更新引用类型里的字段的更新器</p>
<p>原子地更新对象属性需要两步骤：</p>
<ol type="1">
<li>对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法newUpdater()创建一个更新器，且<strong>设置</strong>想要更新的<strong>类</strong>和<strong>属性</strong></li>
<li>更新的对象属性必须使用<strong>public volatile</strong>修饰符</li>
</ol>
<p>下面以AtomicIntegerFieldUpdater为例子来介绍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Java&quot;</span>, <span class="number">22</span>);</span><br><span class="line">		System.out.println(a.getAndIncrement(user));<span class="comment">// 22</span></span><br><span class="line">		System.out.println(a.get(user));<span class="comment">// 23</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果</span></span><br><span class="line"><span class="comment"> 22 </span></span><br><span class="line"><span class="comment"> 33 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>completablefuture-intro</title>
    <url>/2022/12/06/review/java_guide/java/concurrent/completablefuture-intro/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<p>Java8被引入的一个非常有用恶用于异步编程的类</p>
<h1 id="简单介绍">简单介绍</h1>
<p>CompletableFuture同时实现了<strong>Future</strong>和<strong>CompletionStage</strong>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFuture</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CompletableFuture</code> 除了提供了更为好用和强大的
<code>Future</code> 特性之外，还提供了函数式编程的能力。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20210902092441434.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>Future接口有5个方法：</p>
<ul>
<li><code>boolean cancel(boolean mayInterruptIfRunning)</code>
：尝试取消执行任务。</li>
<li><code>boolean isCancelled()</code> ：判断任务是否被取消。</li>
<li><code>boolean isDone()</code> ： 判断任务是否已经被执行完成。</li>
<li><code>get()</code> ：等待任务执行完成并获取运算结果。</li>
<li><code>get(long timeout, TimeUnit unit)</code>
：多了一个超时时间。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20210902093026059.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>CompletionStage<T>
接口中的方法比较多，CompoletableFuture的函数式能力就是这个接口赋予的，大量使用<strong>Java8引入的函数式编程</strong></p>
<h1 id="常见操作">常见操作</h1>
<h2 id="创建completablefuture">创建CompletableFuture</h2>
<p>两种方法：new或静态方法</p>
<ol type="1">
<li><p>通过new关键字
这个方式，可以看作是将CompletableFuture当作Future来使用，如下：</p>
<blockquote>
<p>我们通过创建了一个结果值类型为 <code>RpcResponse&lt;Object&gt;</code>
的 <code>CompletableFuture</code>，你可以把 <code>resultFuture</code>
看作是异步运算结果的载体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; resultFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果后面某个时刻，得到了最终结果，可以调用complete()方法传入结果，表示resultFuture已经被完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// complete() 方法只能调用一次，后续调用将被忽略。</span></span><br><span class="line">resultFuture.complete(rpcResponse);</span><br></pre></td></tr></table></figure>
<p>通过isDone()检查是否完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取异步结果，使用get() ，调用get()方法的线程会阻塞
直到CompletableFuture完成运算：
<code>rpcResponse = completableFuture.get();</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">           <span class="comment">/*CompletableFuture&lt;Object&gt; resultFuture=new CompletableFuture&lt;&gt;();</span></span><br><span class="line"><span class="comment">           resultFuture.complete(&quot;hello world&quot;);</span></span><br><span class="line"><span class="comment">           System.out.println(resultFuture.get());*/</span></span><br><span class="line">           CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">           &#125;);</span><br><span class="line">           System.out.println(<span class="string">&quot;被阻塞啦----&quot;</span>);</span><br><span class="line">           <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringCompletableFuture.get();</span><br><span class="line">           System.out.println(<span class="string">&quot;结果---&quot;</span>+s); </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果已经知道结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!&quot;</span>, future.get()); </span><br><span class="line"><span class="comment">//completedFuture() 方法底层调用的是带参数的 new 方法，只不过，这个方法不对外暴露。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">completedFuture</span><span class="params">(U value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;U&gt;((value == <span class="literal">null</span>) ? NIL : value);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>基于CompletableFuture自带的静态工厂方法：runAsync()、supplyAsync()</p></li>
</ol>
<p><code>Supplier 供应商; 供货商; 供应者; 供货方;</code>
这两个方法可以帮助我们封装计算逻辑</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span>;</span><br><span class="line">   <span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line">   <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span>;</span><br><span class="line">   <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span>;</span><br><span class="line">   <span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>备注，自定义线程池使用：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221206220534852.png"
alt="image-20221206220534852" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE, <span class="comment">//5</span></span><br><span class="line">                MAX_POOL_SIZE,  <span class="comment">//10</span></span><br><span class="line">                KEEP_ALIVE_TIME, <span class="comment">//1L</span></span><br><span class="line">                TimeUnit.SECONDS, <span class="comment">//单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),<span class="comment">//100</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()); <span class="comment">//主线程中运行</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p><code>runAsync()</code> 方法接受的参数是 <code>Runnable</code>
，这是一个函数式接口，不允许返回值。当你需要异步操作且不关心返回结果的时候可以使用
<code>runAsync()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>supplyAsync()</code> 方法接受的参数是
<code>Supplier&lt;U&gt;</code>
，这也是一个函数式接口，<strong><code>U</code>
是返回结果值的类型</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>当需要异步操作且关心返回的结果时，可以使用supplyAsync()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;hello!&quot;</span>));</span><br><span class="line">future.get();<span class="comment">// 输出 &quot;hello!&quot; **注意，不是get()返回的**</span></span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!&quot;</span>, future2.get()); </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="处理异步结算的结果">处理异步结算的结果</h2>
<p>可以对异步计算的结果，进行进一步的处理，常用的方法有：<br />
<code>thenApply()</code> 接收结果 产生结果 `<code>thenAccept()</code>
接受结果不产生结果</p>
<p><code>thenRun</code> 不接受结果不产生结果 <code>whenComplete()</code>
结束时处理结果</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFutureTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;被阻塞啦----&quot;</span>);</span><br><span class="line">         stringCompletableFuture</span><br><span class="line">                 .whenComplete((s,e)-&gt;&#123;</span><br><span class="line">                     System.out.println(<span class="string">&quot;complete1----&quot;</span>+s);</span><br><span class="line">                 &#125;)</span><br><span class="line">                 .whenComplete((s,e)-&gt;&#123;</span><br><span class="line">                     System.out.println(<span class="string">&quot;complete2----&quot;</span>+s);</span><br><span class="line">                 &#125;)</span><br><span class="line">                 .thenAccept(s-&gt;&#123;</span><br><span class="line">                     System.out.println(<span class="string">&quot;打印结果&quot;</span>+s);</span><br><span class="line">                 &#125;)</span><br><span class="line">                 .thenRun(()-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;阻塞结束啦&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">         <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------</span></span><br><span class="line"><span class="comment">2022-12-07 10:16:44 上午 [Thread: main] </span></span><br><span class="line"><span class="comment">INFO:被阻塞啦----</span></span><br><span class="line"><span class="comment">2022-12-07 10:16:47 上午 [Thread: ForkJoinPool.commonPool-worker-1] </span></span><br><span class="line"><span class="comment">INFO:complete1----hello,world!</span></span><br><span class="line"><span class="comment">2022-12-07 10:16:47 上午 [Thread: ForkJoinPool.commonPool-worker-1] </span></span><br><span class="line"><span class="comment">INFO:complete2----hello,world!</span></span><br><span class="line"><span class="comment">2022-12-07 10:16:47 上午 [Thread: ForkJoinPool.commonPool-worker-1] </span></span><br><span class="line"><span class="comment">INFO:打印结果hello,world!</span></span><br><span class="line"><span class="comment">2022-12-07 10:16:47 上午 [Thread: ForkJoinPool.commonPool-worker-1] </span></span><br><span class="line"><span class="comment">INFO:阻塞结束啦</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>thenApply()方法接受Function实例，用它来处理结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 沿用上一个任务的线程池</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用默认的 ForkJoinPool 线程池（不推荐）</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(defaultExecutor(), fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniApplyStage(screenExecutor(executor), fn);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br><span class="line"><span class="comment">// 这次调用将被忽略。  //**我猜是因为只能get()一次**</span></span><br><span class="line">future.thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>流式调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!nice!&quot;</span>, future.get()); </span><br></pre></td></tr></table></figure></li>
<li><p>如果不需要从回调函数中返回结果，可以使用thenAccept()或者thenRun()
，两个方法区别在于thenRun()不能访问异步计算的结果(因为thenAccept方法的参数为
<strong>Consumer&lt;? super T&gt;</strong> )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniAcceptStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniAcceptStage(defaultExecutor(), action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action,</span></span><br><span class="line"><span class="params">                                               Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniAcceptStage(screenExecutor(executor), action);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>顾名思义，<code>Consumer</code> 属于消费型接口，它可以接收 1
个输入对象然后进行“消费”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><code>thenRun()</code> 的方法是的参数是 <code>Runnable</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniRunStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniRunStage(defaultExecutor(), action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action,</span></span><br><span class="line"><span class="params">                                            Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniRunStage(screenExecutor(executor), action);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>).thenAccept(System.out::println);<span class="comment">//hello!world!nice!  //可以接收参数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>).thenRun(() -&gt; System.out.println(<span class="string">&quot;hello!&quot;</span>));<span class="comment">//hello! </span></span><br></pre></td></tr></table></figure>
<p>whenComplete()的方法参数是BiConsumer&lt;? super T , ? super Throwable
&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(defaultExecutor(), action);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用自定义线程池(推荐)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(screenExecutor(executor), action);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>相比Consumer，BiConsumer可以接收2个输入对象然后进行"消费"</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BiConsumer</span>&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t, U u)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> BiConsumer&lt;T, U&gt; <span class="title function_">andThen</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> U&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (l, r) -&gt; &#123;</span><br><span class="line">            accept(l, r);</span><br><span class="line">            after.accept(l, r);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .whenComplete((res, ex) -&gt; &#123;</span><br><span class="line">            <span class="comment">// res 代表返回的结果</span></span><br><span class="line">            <span class="comment">// ex 的类型为 Throwable ，代表抛出的异常</span></span><br><span class="line">            System.out.println(res);</span><br><span class="line">            <span class="comment">// 这里没有抛出异常所有为 null</span></span><br><span class="line">            assertNull(ex);</span><br><span class="line">        &#125;);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!&quot;</span>, future.get()); </span><br></pre></td></tr></table></figure>
<p><strong>其他区别暂时不知道</strong></p></li>
</ol>
<h2 id="异常处理">异常处理</h2>
<p>使用handle（） 方法来处理任务执行过程中可能出现的抛出异常的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(defaultExecutor(), fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiFunction&lt;? <span class="built_in">super</span> T, Throwable, ? extends U&gt; fn, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniHandleStage(screenExecutor(executor), fn);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; future</span><br><span class="line">                = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Computation error!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line">        &#125;).handle((res, ex) -&gt; &#123;</span><br><span class="line">            <span class="comment">// res 代表返回的结果</span></span><br><span class="line">            <span class="comment">// ex 的类型为 Throwable ，代表抛出的异常</span></span><br><span class="line">            <span class="keyword">return</span> res != <span class="literal">null</span> ? res : ex.toString()+<span class="string">&quot;world!&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> future.get();</span><br><span class="line">        log.info(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">2022-12-07 11:14:44 上午 [Thread: main] </span></span><br><span class="line"><span class="comment">INFO:java.util.concurrent.CompletionException: java.lang.RuntimeException: Computation error!world!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>通过exceptionally处理异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future</span><br><span class="line">        = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Computation error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line">&#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">    System.out.println(ex.toString());<span class="comment">// CompletionException</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;world!&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">assertEquals(<span class="string">&quot;world!&quot;</span>, future.get()); </span><br></pre></td></tr></table></figure>
<p>让异步的结果直接就抛异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">completableFuture.completeExceptionally(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Calculation failed!&quot;</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">completableFuture.get(); <span class="comment">// ExecutionException </span></span><br></pre></td></tr></table></figure>
<h2 id="组合completablefuture">组合CompletableFuture</h2>
<p>使用thenCompose() 按顺序链接两个CompletableFuture对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(<span class="literal">null</span>, fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(defaultExecutor(), fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn,</span></span><br><span class="line"><span class="params">    Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniComposeStage(screenExecutor(executor), fn);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future</span><br><span class="line">        = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="string">&quot;world!&quot;</span>));</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get()); </span><br></pre></td></tr></table></figure>
<blockquote>
<p>在实际开发中，这个方法还是非常有用的。比如说，我们先要获取用户信息然后再用用户信息去做其他事情。</p>
</blockquote>
<p>和thenCompose()方法类似的还有thenCombine()方法，thenCombine()同样可以组合两个CompletableFuture对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; completableFuture</span><br><span class="line">        = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenCombine(CompletableFuture.supplyAsync(</span><br><span class="line">                () -&gt; <span class="string">&quot;world!&quot;</span>), (s1, s2) -&gt; s1 + s2)</span><br><span class="line">        .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="string">&quot;nice!&quot;</span>));</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!nice!&quot;</span>, completableFuture.get()); </span><br></pre></td></tr></table></figure>
<p>★★ thenCompose() 和 thenCombine()有什么区别呢</p>
<ul>
<li><code>thenCompose()</code> 可以两个 <code>CompletableFuture</code>
对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。</li>
<li><code>thenCombine()</code>
会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。</li>
</ul>
<h2
id="并行运行多个completablefuture">并行运行多个CompletableFuture</h2>
<p>通过CompletableFuture的allOf()这个静态方法并行运行多个CompletableFuture</p>
<blockquote>
<p>实际项目中，我们经常需要并行运行多个互不相关的任务，这些任务没有依赖关系</p>
</blockquote>
<p>比如读取处理6个文件，没有顺序依赖关系
但我们需要返回给用户的时候将这几个文件的处理结果统计整理，示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; task1 =</span><br><span class="line">  CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">  &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; task6 =</span><br><span class="line">  CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">  &#125;);</span><br><span class="line">......</span><br><span class="line"> CompletableFuture&lt;Void&gt; headerFuture=CompletableFuture.allOf(task1,.....,task6);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    headerFuture.join();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">System.out.println(<span class="string">&quot;all done. &quot;</span>); </span><br></pre></td></tr></table></figure>
<p><strong>调用join()可以让程序等future1和future2都运行完后继续执行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.allOf(future1, future2);</span><br><span class="line">completableFuture.join();</span><br><span class="line">assertTrue(completableFuture.isDone());</span><br><span class="line">System.out.println(<span class="string">&quot;all futures done...&quot;</span>); </span><br><span class="line"><span class="comment">/**---</span></span><br><span class="line"><span class="comment">future1 done...</span></span><br><span class="line"><span class="comment">future2 done...</span></span><br><span class="line"><span class="comment">all futures done...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>anyOf则其中一个执行完就立马返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Object&gt; f = CompletableFuture.anyOf(future1, future2);</span><br><span class="line">System.out.println(f.get());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">future2 done...</span></span><br><span class="line"><span class="comment">efg</span></span><br><span class="line"><span class="comment">*/</span> <span class="comment">//或</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">future1 done...</span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="后记">后记</h1>
<p>京东的aysncTool框架<br />
https://gitee.com/jd-platform-opensource/asyncTool#%E5%B9%B6%E8%A1%8C%E5%9C%BA%E6%99%AF%E4%B9%8B%E6%A0%B8%E5%BF%83%E4%BB%BB%E6%84%8F%E7%BC%96%E6%8E%92</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发01</title>
    <url>/2022/10/26/review/java_guide/java/concurrent/concurrent-01/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<ul>
<li><p>什么是进程和线程</p>
<ul>
<li><p>进程：是程序的<strong>一次执行过程</strong>，是系统运行程序的<strong>基本单位</strong>
系统运行一个程序，即一个进程从<strong>创建、运行到消亡</strong>的过程</p>
<ul>
<li>启动main函数则启动了一个JVM进程，<strong>main函数所在线程</strong>为进程中的一个线程，也称<strong>主线程</strong></li>
<li>以下为一个个的进程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221026212505577.png"
alt="image-20221026212505577" /></li>
</ul></li>
<li><p>何为线程</p>
<ul>
<li><p>线程，比进程更小的执行单位</p></li>
<li><p>同类的多个线程共享进程的<strong>堆和方法区</strong>资源，但每个线程有自己的<strong>程序计数器、虚拟机栈、本地方法栈</strong>，又被称为<strong>轻量级进程</strong></p></li>
<li><p>Java天生就是多线程程序，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThread</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 获取 Java 线程管理 MXBean</span></span><br><span class="line">	<span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line">		<span class="comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">		<span class="comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></span><br><span class="line">		<span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;[&quot;</span> + threadInfo.getThreadId() + <span class="string">&quot;] &quot;</span> + threadInfo.getThreadName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">[<span class="number">5</span>] Attach Listener <span class="comment">//添加事件</span></span><br><span class="line">[<span class="number">4</span>] Signal Dispatcher <span class="comment">// 分发处理给 JVM 信号的线程</span></span><br><span class="line">[<span class="number">3</span>] Finalizer <span class="comment">//调用对象 finalize 方法的线程</span></span><br><span class="line">[<span class="number">2</span>] Reference Handler <span class="comment">//清除 reference 线程</span></span><br><span class="line">[<span class="number">1</span>] main <span class="comment">//main 线程,程序入口</span></span><br></pre></td></tr></table></figure>
<p>也就是说，一个Java程序的运行，是main线程和多个其他线程同时运行</p></li>
</ul></li>
<li><p>请简要描述线程与进程的关系，区别及优缺点</p>
<ul>
<li>从JVM角度说明 Java内存区域 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221026213728776.png"
alt="image-20221026213728776" />
一个进程拥有多个线程，多个线程共享进程的堆和方法区（元空间），每个进程拥有自己的程序计数器、虚拟机栈、本地方法栈</li>
</ul></li>
<li><p>总结</p>
<ul>
<li>线程是进程划分成的更小运行单位</li>
<li>线程和进程最大不同在于各进程基本独立，而各线程极有可能互相影响</li>
<li>线程开销小，但不利于资源保护；进程反之</li>
</ul></li>
<li><p>程序计数器为什么是私有</p>
<ul>
<li>程序计数器的作用：<strong>字节码解释器</strong>通过<strong>改变程序计数器</strong>来一次读取指令，从而实现代码流程控制；在多线程情况下，程序计数器用于<strong>记录当前线程执行位置</strong></li>
<li>如果执行的是native方法，则程序计数器记录的是undefined地址；执行Java方法则记录的是<strong>下一条指令的地址</strong></li>
<li>私有，是为了线程切换后能恢复到正确的执行位置</li>
</ul></li>
<li><p>虚拟机栈和本地方法栈为什么私有</p>
<ul>
<li>虚拟机栈：每个Java方法执行时同时会创建一个<strong>栈帧</strong>用于<strong>存储局部变量表</strong>、<strong>操作数栈</strong>、<strong>常量池引用</strong>等信息</li>
<li>本地方法栈：和虚拟机栈类似，区别是虚拟机栈为虚拟机执行Java方法（字节码）服务，本地方法栈则为虚拟机使用到的<strong>Native</strong>方法服务。HotSpot虚拟机中和Java虚拟机栈合二为一</li>
<li>为了保证线程中局部变量不被别的线程访问到，虚拟机栈和本地方法栈是私有的</li>
</ul></li>
<li><p><strong>堆和方法区</strong>是所有线程共享的资源，<strong>堆</strong>是进程中最大一块内存，用于<strong>存放新创建的对象</strong>（几乎所有对象都在这分配内存）;
方法区则存放<strong>已被加载的 </strong>
<strong>类信息、常量、静态变量</strong>、即时编译器编译后的代码等数据</p></li>
</ul></li>
<li><p>并发与并行的区别</p>
<ul>
<li>并发：两个及两个以上的作业在<strong>同一时间段</strong>内执行（线程，同一个代码同一秒只能由一个线程访问）</li>
<li>并行：两个及两个以上的作业<strong>同一时刻</strong>执行</li>
<li>关键点：是否同时执行，只有并行才能同时执行</li>
</ul></li>
<li><p>同步和异步</p>
<ul>
<li>同步：发出调用后，没有得到结果前，该调用不能返回，一直等待</li>
<li>异步：发出调用后，不用等返回结果，该调用直接返回</li>
</ul></li>
<li><p>为什么要使用多线程</p>
<ul>
<li>从计算机底层来说：线程是<strong>轻量级进程</strong>，程序执行最小单位，线程间切换和调度<strong>成本远小于进程</strong>。多核CPU时代意味着多个线程可以同时运行，减少线程上下文切换</li>
<li>从当代互联网发展趋势：如今系统并发量大，利用多线程机制可以大大提高系统整体并发能力及性能</li>
<li>深入计算机底层
<ul>
<li>单核时代：提高单进程利用CPU和IO系统的效率。当请求IO的时候，如果Java进程中只有一个线程，此线程被IO阻塞则整个进程被阻塞，CPU和IO设备只有一个运行，系统整体效率50%；而多线程时，如果一个线程被IO阻塞，其他线程还可以继续使用CPU</li>
<li>多核时代：多核时代多线程主要是提高进程利用多核CPU的能力，如果要计算复杂任务，只有一个线程的话，不论系统几个CPU核心，都只有一个CPU核心被利用；而创建多个线程，这些线程可以被映射到底层多个CPU上执行，如果任务中的多个线程没有资源竞争，那么执行效率会显著提高</li>
</ul></li>
</ul></li>
<li><p>多线程带来的问题：内存泄漏（对象，没有释放）、死锁、线程不安全等</p></li>
<li><p>说说线程的声明周期和状态
Java线程在运行的生命周期中的指定时刻，只可能处于下面6种不同状态中的一个</p>
<ul>
<li><p>NEW：初始状态，线程被创建出来但没有调用start()</p></li>
<li><p>RUNNABLE：运行状态，线程被调用了start() 等待运行的状态</p></li>
<li><p>BLOCKED：阻塞状态，需要等待锁释放</p></li>
<li><p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）</p></li>
<li><p>TIME_WAITING：超时等待状态，在指定的时间后自行返回而不是像WAITING一直等待</p></li>
<li><p>TERMINATED：终止状态，表示该线程已经运行完毕 如图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221027094635757.png"
alt="image-20221027094635757" /> 对于该图有以下几点要注意：</p>
<ol type="1">
<li><p>线程创建后处于<strong>NEW</strong>状态，之后调用<strong>start()</strong>方法运行，此时线程处于<strong>READY</strong>，可运行的线程获得CPU时间片（timeslice）后处于<strong>RUNNING</strong>状态</p>
<blockquote>
<ul>
<li>操作系统中有READY和RUNNING两个状态，而JVM中只有RUNNABLE状态</li>
<li>现在的操作系统通常都是“时间分片“”方法进行抢占式
轮转调度“，一个线程最多只能在CPU上运行10-20ms的时间（此时处于RUNNING)状态，时间过短，时间片之后放入<strong>调度队列</strong>末尾等待再次调度（回到READY状态），太快所以不区分两种状态
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221027095421280.png"
alt="image-20221027095421280" /></li>
</ul>
</blockquote></li>
<li><p>线程执行<strong>wait()</strong>方法后，进入<strong>WAITING(等待
)</strong>状态，进入等待状态的线程需要依靠其他线程<strong>通知</strong>才能回到运行状态</p></li>
<li><p><strong>TIMED_WAITING(超时等待)</strong>状态，在<strong>等待状态的基础上</strong>增加<strong>超时限制</strong>，通过sleep(long
millis)或wait(long millis)
方法可以将线程置于<strong>TIMED_WAITING</strong>状态，超时结束后返回到<strong>RUNNABLE</strong>状态（注意，不是RUNNING）</p></li>
<li><p>当线程进入<strong>synchronized</strong>方法/块或者调用wait后(被notify)重新进入<strong>synchronized</strong>方法/块，但是锁被其他线程占有，这个时候线程就会进入BLOCKED（阻塞）状态</p></li>
<li><p>线程在执行完了<strong>run()</strong>方法之后就会进入到<strong>TERMINATED（终止）</strong>状态</p></li>
<li><p>注意上述，阻塞和等待的区别</p></li>
</ol></li>
</ul></li>
<li><p>什么是上下文切换</p>
<ul>
<li><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文提到的<strong>程序计数器</strong>，<strong>栈信息</strong>等。当出现下面情况时，线程从<strong>占用CPU状态中退出</strong>：</p>
<ol type="1">
<li>主动让出CPU，如sleep(),wait()等</li>
<li>时间片用完了</li>
<li>调用了阻塞类型的系统中断（请求IO，线程被阻塞）</li>
<li>被终止或结束运行</li>
</ol>
<p>前3种会发生<strong>线程切换</strong>：需要保存当前线程上下文，留待线程下次占用CPU的时候恢复，并加载下一个将要占用CPU的线程上下文，即所谓的上下文切换</p></li>
<li><p>是现代系统基本功能，每次都要<strong>保存信息恢复信息</strong>，将会<strong>占用CPU</strong>，<strong>内存</strong>等系统资源，即<strong>效率有一定损耗</strong>，频繁切换会造成<strong>整体效率低下</strong></p></li>
</ul></li>
<li><p>线程死锁是什么？如何避免?</p>
<ul>
<li><p>多个线程同时被阻塞，它们种的一个或者全部，都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止</p></li>
<li><p>前提：线程A持有资源2，线程B持有资源1。现象：线程A在等待申请资源1，线程B在等待申请资源2，所以这两个线程就会互相等待而进入死锁状态
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221028092652845.png"
alt="image-20221028092652845" /> 使用代码描述上述问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 线程A通过synchronized(resource1)获得resource1的监视器锁，然后休眠1s（是为了保证线程B获得执行然后拿到resource2监视器锁）</span></span><br><span class="line"><span class="comment">- 休眠结束了两线程都企图请求获得对方的资源，陷入互相等待的状态，于是产生了死锁</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>死锁产生条件</p>
<ul>
<li>互斥：该资源<strong>任意一个时刻只由一个</strong>线程占有</li>
<li>请求与保持：一线程因请求资源而阻塞时，对<strong>已获得</strong>的资源<strong>保持不放</strong></li>
<li>不剥夺条件：线程<strong>已获得的资源未使用完之前</strong>不能被其他线程强行剥夺，只有自己使用完才释放（资源）</li>
<li>循环等待：若干线程之间形成<strong>头尾相接的循环等待资源</strong>关系</li>
</ul></li>
</ul></li>
<li><p>如何预防死锁---&gt;破坏死锁的必要条件</p>
<ul>
<li>破坏请求与保持条件：一次性申请所有资源</li>
<li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以<strong>主动</strong>释放它占有的资源</li>
<li>破坏循环等待条件：靠按序申请资源来预防（按某顺序申请资源，释放资源时反序）</li>
</ul></li>
<li><p>如何将避免死锁</p>
<ul>
<li><p>在资源分配时，借助于算法（银行家算法)对<strong>资源分配计算评估</strong>，使其进入安全状态</p>
<blockquote>
<p><strong>安全状态</strong>
指的是系统能够按照某种线程推进顺序（P1、P2、P3.....Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称
<code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列</p>
</blockquote></li>
<li><p>修改线程2的代码 原线程1代码不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br></pre></td></tr></table></figure>
<p>线程2代码修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br></pre></td></tr></table></figure>
<p>分析</p>
<blockquote>
<p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2
就获取不到了。然后线程 1 再去获取 resource2
的监视器锁，可以获取到。然后<strong>线程 1 释放了对 resource1、resource2
的监视器锁的占用，线程 2
获取到就可以执行了</strong>。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>
</blockquote></li>
</ul></li>
<li><p>sleep()方法和wait()方法对比</p>
<ul>
<li>共同点： 两者都可暂停线程执行</li>
<li>区别
<ol type="1">
<li>seep() 方法没有释放锁，wait() 方法释放了锁</li>
<li>wait() 通常用于线程间交互/通信，sleep()用于暂停执行</li>
<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象（监视器monitor）的notify()或者notifyAll()方法；sleep()方法执行完成后/或者wait(long
timeout)超时后，线程会自动苏醒</li>
<li>sleep时Thread类的静态本地方法，wait()则是Object类的本地方法</li>
</ol></li>
</ul></li>
<li><p>为什么wait()方法不定义在Thread中</p>
<ul>
<li>wait()
目的是让<strong>获得对象锁的线程</strong>实现等待，会<strong>自动释放当前线程占有的对象锁</strong></li>
<li>每个对象(Object)都拥有对象锁，既然是让获得对象锁的线程等待，所以方法应该出现在对象Object上</li>
<li>sleep()是让当前线程暂停执行，不涉及对象类，也不需要获得对象锁</li>
</ul></li>
<li><p>可以直接调用Thread类的run方法吗</p>
<ul>
<li>new一个Thread之后，线程进入新建状态</li>
<li>调用start()，会启动线程并使他进入就绪状态（Runable，可运行状态，又分为Ready和Running），分配到时间片后就开始运行</li>
<li>start()执行线程相应准备工作，之后自动执行run()方法的内容</li>
<li>如果直接执行run()方法，则会把run()方法当作main线程下普通方法去执行，并不会在某个线程中执行它</li>
<li>只有调用start()方法才可以启动新的线程使他进入就绪状态，等待获取时间片后运行</li>
</ul></li>
<li></li>
</ul>
<blockquote>
<p>大部分转自https://github.com/Snailclimb/JavaGuide</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发02</title>
    <url>/2022/10/28/review/java_guide/java/concurrent/concurrent-02/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="jmmjavamemorymodel">JMM（JavaMemoryModel)</h2>
<p>详见-知识点</p>
<h2 id="volatile关键字">volatile关键字</h2>
<ul>
<li><p>保证变量可见性</p>
<ul>
<li>使用volatile关键字保证变量可见性，如果将变量声明为volatile则<strong>指示JVM该变量是共享且不稳定</strong>的，每次使用它都到<strong>主存</strong>中读取
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221028150859646.png"
alt="image-20221028150859646" /> 原始意义即金庸CPU缓存</li>
<li>volatile关键字只能保证数据可见性，不能保证数据原子性。synchronized关键字两者都能保证</li>
</ul></li>
<li><p>如何禁止指令重排
使用<strong>volatile</strong>关键字，能<strong>防止JVM指令重排</strong>。当我们对这个变量进行读写操作的时候，-会通过插入特定的<strong>内存屏障</strong>来禁止指令重排</p>
<ul>
<li><p>Java中，提供了三个关于<strong>内存屏障</strong>相关的方法，屏蔽了操作系统底层的差异，可以用来实现和volatile禁止重排序的效果</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>; <span class="comment">//读指令屏障</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>; <span class="comment">//写指令屏障</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>; <span class="comment">//读写指令屏障</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>例子（通过双重校验锁实现对象单例），保证线程安全</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，uniqueInstance采用volatile的必要性：主要分析<code>uniqueInstance  = new Singleton();</code>分三步</p>
<ol type="1">
<li>为uniqueInstance分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将uniqueInstance指向被分配的空间</li>
</ol>
<p>由于指令重排的关系，可能会编程1-&gt;3-&gt;2
，指令重排在单线程情况下不会出现问题，而多线程，</p>
<ul>
<li>就会导致可能指针非空的时候，实际该指针所指向的对象（实例）并还没有初始化</li>
<li>例如，线程 T1 执行了 1 和 3，此时 T2 调用
<code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code>
不为空，因此返回 <code>uniqueInstance</code>，但此时
<code>uniqueInstance</code> 还未被初始化</li>
</ul></li>
</ul></li>
<li><p>volatile不能保证原子性</p>
<ul>
<li><p>下面的代码，输出结果小于2500</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatoleAtomicityDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="type">VolatoleAtomicityDemo</span> <span class="variable">volatoleAtomicityDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatoleAtomicityDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">500</span>; j++) &#123;</span><br><span class="line">                    volatoleAtomicityDemo.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待1.5秒，保证上面程序执行完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        System.out.println(inc);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面例子, inc++ 是原子性的，实际上inc ++ 是一个符合操作，即</p>
<ol type="1">
<li>读取inc的值</li>
<li>对inc加1</li>
<li>将加1后的值写回内存</li>
</ol>
<p>这三部操作并不是原子性的，有可能出现：</p>
<ol type="1">
<li>线程1对inc读取后，尚未修改</li>
<li>线程2又读取了，并对他进行+1，然后将+1后的值写回主存</li>
<li>此时线程2操作完毕后，线程1在之前读取的基础上进行一次自增，这将覆盖第2步操作的值，导致inc只增加了1</li>
</ol>
<p>如果要保证上面代码运行正确，可以使用synchronized、Lock或者AtomicInteger，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者AtomicInteger</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">AtomicInteger</span> <span class="variable">inc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    inc.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者ReentrantLock改进</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="synchronized关键字">synchronized关键字</h2>
<ul>
<li><p>说一说自己对synchronized的理解</p>
<ul>
<li>翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，保证<strong>被它修饰的方法/代码块</strong>，在<strong>任一时刻只有一个线程</strong>执行</li>
<li>Java早期版本中，synchronized属于重量级锁；监视器锁（monitor）依赖底层操作系统的<strong>Mutex
Lock</strong>来实现，<strong>Java线程映射到操作系统的原生线程上</strong>
<ul>
<li>挂起或唤醒线程，都需要操作系统帮忙完成，即操作系统实现线程之间切换，需要<strong>从用户态转换到内核态</strong>，这个转换时间成本高</li>
</ul></li>
<li>Java 6
之后，Java官方对synchronized较大优化，引入了大量优化：自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等减少所操作的开销</li>
</ul></li>
<li><p>如何使用synchronized关键字</p>
<ol type="1">
<li>修饰实例方法</li>
<li>修饰静态方法</li>
<li>修饰代码块</li>
</ol>
<ul>
<li><p>修饰实例方法（锁当前对象实例）
给当前对象实例加锁，进入同步代码前要获得<strong>当前对象实例</strong>的锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修饰静态方法（锁当前类）
给当前类枷锁，会作用于类的所有对象实例，进入同步代码前要获得<strong>当前class</strong>的锁;
这是因为静态成员归整个类所有，而<strong>不属于任何一个实例对象</strong>，不依赖于类的特定实例，被类所有实例共享</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态synchronized方法和非静态synchronized方法之间的调用互斥吗：不互斥</p>
<blockquote>
<p>如果线程A调用实例对象的非静态方法，而线程B调用这个实例所属类的静态synchronized方法，是允许的，不会发生互斥；因为访问<strong>静态synchronized</strong>方法占用的锁是<strong>当前类的锁</strong>；<strong>非静态synchronized方法</strong>占用的是<strong>当前实例对象的锁</strong></p>
</blockquote></li>
<li><p>修饰代码块（锁指定对象/类）</p>
<ol type="1">
<li><code>synchronized(object)</code> 表示进入同步代码库前要获得
<strong>给定对象的锁</strong>。</li>
<li><code>synchronized(类.class)</code> 表示进入同步代码前要获得
<strong>给定 Class 的锁</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
<blockquote>
<ul>
<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和
<code>synchronized(class)</code> 代码块上都是是给 Class 类上锁；</li>
<li><code>synchronized</code>
关键字加到实例方法上是给对象实例上锁；</li>
<li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM
中，字符串常量池具有缓存功能。(所以就会导致，容易和其他地方的代码（同样的值的字符串）互斥，因为是缓冲池的同一个对象)</li>
</ul>
</blockquote></li>
</ul></li>
<li><p>将一下synchronized关键字的底层原理
synchronized底层原理是属于JVM层面的</p>
<ul>
<li><p>synchronized + 代码块 例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用javap命令查看SynchronizedDemo类<strong>相关字节码信息</strong>：对编译后的SynchronizedDemo.class文件，使用<code>javap -c -s -v -l SynchronizedDemo.class</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221029185709116.png"
alt="image-20221029185709116" />
<figcaption aria-hidden="true">image-20221029185709116</figcaption>
</figure>
<p>同步代码块的实现，使用的是<strong>monitorenter</strong>和<strong>monitorexit</strong>指令，其中<strong>monitorenter</strong>指令指向<strong>同步代码块开始</strong>的地方，<strong>monitorexit</strong>指向同步代码块结束的结束位置
执行monitorenter指令就是获取<strong>对象监视器monitor</strong>的持有权</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在HotSport虚拟机中，Monitor基于C++实现，由ObjectMonitor实现：每个对象内置了ObjectMonitor对象。wait/notify等方法也基于monitor对象，所以只有在同步块或者方法中（获得锁）才能调用wait/notify方法，否则会抛出java.lang.IllegalMonitorStateException异常的原因</span><br></pre></td></tr></table></figure></p>
<p>执行monitorenter时，尝试获取对象的锁，如果锁计数器为0则表示所可以被获取，获取后锁计数器设为1，简单的流程<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221029190656612.png"
alt="image-20221029190656612" />
<strong>只有拥有者线程</strong>才能执行<strong>monitorexit</strong>来释放锁，执行monitorexit指令后，锁计数器设为0（应该是减一，与可重入锁有关），当计数器为0时，表明锁被释放，其他线程可以尝试获得锁(如果某个线程获取锁失败，那么该线程就会阻塞等待，知道锁被（另一个线程）释放)
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221029190841776.png"
alt="image-20221029190841776" /></p></li>
<li><p>synchronized修饰方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如图 : <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221029191336048.png"
alt="image-20221029191336048" /></p>
<p>对比（下面是对synchronized代码块）：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221029192437491.png"
alt="image-20221029192437491" /></p>
<blockquote>
<p>synchronized修饰的方法没有monitorenter和monitorexit指令，而是ACC_SYNCHRONIZED标识（flags），该标识指明方法是一个同步方法（JVM通过访问标志判断方法是否声明为同步方法），从而执行同步调用
如果是<strong>实例方法</strong>，JVM
会尝试<strong>获取实例对象的锁</strong>。如果是<strong>静态方法</strong>，JVM
会尝试<strong>获取当前 class 的锁</strong>。</p>
</blockquote></li>
<li><p>总结</p>
<ul>
<li><p><code>synchronized</code> 同步语句块的实现使用的是
<strong><code>monitorenter</code> 和 <code>monitorexit</code></strong>
指令，其中 <code>monitorenter</code>
指令指向同步代码块的开始位置，<code>monitorexit</code>
指令则指明同步代码块的结束位置。</p></li>
<li><p><strong><code>synchronized</code> 修饰的方法并没有
<code>monitorenter</code> 指令和 <code>monitorexit</code>
指令</strong>，取得代之的确实是 <strong><code>ACC_SYNCHRONIZED</code>
标识</strong>，该标识指明了该方法是一个同步方法。</p>
<p><strong>不过两者的本质都是对对象监视器 monitor
的获取。</strong></p></li>
</ul></li>
</ul></li>
<li><p>Java1.6之后的synchronized关键字底层做了哪些优化 这是一个链接 <a
href="/2022/11/06/review/java_guide/concurrent/lock_escalation/">详情见另一个文章</a></p>
<ul>
<li>JDK1.6对锁的实现，引入了大量的优化，如<strong>偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化</strong>等技术来减少操作的开销</li>
<li>锁主要存在<strong>四种状态</strong>，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级<strong>锁可以升级但不可以降级，这种策略是为了提高获得锁和释放锁的效率</strong></li>
</ul></li>
<li><p>synchronized和volatile的区别
synchronized和volatile是互补的存在，而非对立</p>
<ul>
<li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字好，但volatile用于变量而synchronized关键字修饰方法及代码块</li>
<li>volatile关键字能保证数据的可见性、有序性，但无法保证原子性；synchronized三者都能保证</li>
<li>volatile主要还是用于解决变量在线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性</li>
</ul></li>
<li><p>synchronized 和 ReentrantLock 的区别</p>
<ol type="1">
<li>两者都是可重入锁
”可重入锁“指的是，自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的<br />
反之，如果是不可重入锁的话，就会造成死锁。
同一个线程，每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁</li>
<li>synchronized依赖于JVM而ReentrantLock依赖于API
synchronized为虚拟机在JDK1.6进行的优化，但这些优化是在虚拟机层面实现的；ReentrantLock是JDK层面实现的，使用时，使用lock()和unlock()并配合try/finally语句块来完成
（Java代码）</li>
</ol></li>
<li><p>ReentrantLock 比 synchronized 增加了一些高级功能
ReentrantLock增加了一些高级功能，主要有</p>
<ol type="1">
<li><p>等待可中断，提供了能够<strong>中断等待锁的线程</strong>的机制，通过lock.lockInterruptibly()来实现该机制。即正在等待的线程可以放弃等待，改为处理其他事情</p></li>
<li><p>可实现公平锁：可以指定是公平锁还是非公平锁，而synchronized只能是非公平锁。
所谓公平锁就是先等待的线程先获得锁。ReentrantLock默认是非公平的，可以通过构造方法指定是否公平</p></li>
<li><p>可实现选择性的通知（锁可以绑定多个条件）
<strong><code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code></strong>方法相结合可以实现等待/通知机制。<strong><code>ReentrantLock</code></strong>类当然也可以实现，但是需要借助于<strong><code>Condition</code>接口与<code>newCondition()</code></strong>方法。</p>
<blockquote>
<ul>
<li><code>Condition</code>是 JDK1.5
之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。
</strong></li>
<li><strong>在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由
JVM
选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong>
，这个功能非常重要，而且是 Condition 接口默认提供的。
<ul>
<li><code>synchronized</code>关键字就相当于整个 Lock
对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，</li>
<li><code>Condition</code>实例的<code>signalAll()</code>方法
只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</li>
</ul></li>
</ul>
</blockquote></li>
</ol></li>
</ul>
<h2 id="threadlocal">ThreadLocal</h2>
<ul>
<li><p>ThreadLocal有什么用</p>
<ol type="1">
<li>通常情况下，创建的变量是可以被<strong>任何一个线程访问并修改</strong>的</li>
<li>JDK自带的ThreadLocal类，该类主要解决的就是让<strong>每个线程绑定自己的值</strong>，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据</li>
<li>对于ThreadLocal变量，访问这个变量的每个线程都会有这个变量的本地副本。使用get()和set()来获取默认值或将其值更改为当前线程所存的副本的值</li>
</ol></li>
<li><p>如何使用ThreadLocal Demo演示实际中如何使用ThreadLocal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMMdd HHmm&quot;</span>));</span><br><span class="line">    <span class="comment">/* 非lambda写法</span></span><br><span class="line"><span class="comment">      private static final ThreadLocal&lt;SimpleDateFormat&gt; formatter = new ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    protected SimpleDateFormat initialValue()&#123;</span></span><br><span class="line"><span class="comment">        return new SimpleDateFormat(&quot;yyyyMMdd HHmm&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ThreadLocalExample</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalExample</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(obj, <span class="string">&quot;&quot;</span>+i);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//formatter.get().toPattern() 同一个对象的线程变量formatter(里面封装了一个simpleDateFormate对象，具有初始值)</span></span><br><span class="line">    <span class="comment">//每个线程访问时，先打印它的初始值，然后休眠1s（1s内的随机数），反正每个线程随机数不同，然后修改它</span></span><br><span class="line">    <span class="comment">//结果：虽然前面执行的线程，修改值，但是后面执行的线程打印的值还是一样的 没有修改</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; default Formatter = &quot;</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won&#x27;t reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; formatter = &quot;</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*虽然前面执行的线程，修改值，但是后面执行的线程打印的值还是一样的 没有修改 , 结果如下：</span></span><br><span class="line"><span class="comment"> Thread Name= 0 default Formatter = yyyyMMdd HHmm</span></span><br><span class="line"><span class="comment">Thread Name= 0 formatter = yy-M-d ah:mm</span></span><br><span class="line"><span class="comment">Thread Name= 1 default Formatter = yyyyMMdd HHmm</span></span><br><span class="line"><span class="comment">Thread Name= 2 default Formatter = yyyyMMdd HHmm</span></span><br><span class="line"><span class="comment">Thread Name= 1 formatter = yy-M-d ah:mm</span></span><br><span class="line"><span class="comment">Thread Name= 3 default Formatter = yyyyMMdd HHmm</span></span><br><span class="line"><span class="comment">Thread Name= 2 formatter = yy-M-d ah:mm</span></span><br><span class="line"><span class="comment">Thread Name= 4 default Formatter = yyyyMMdd HHmm</span></span><br><span class="line"><span class="comment">Thread Name= 3 formatter = yy-M-d ah:mm</span></span><br><span class="line"><span class="comment">Thread Name= 4 formatter = yy-M-d ah:mm</span></span><br><span class="line"><span class="comment">Thread Name= 5 default Formatter = yyyyMMdd HHmm</span></span><br><span class="line"><span class="comment">Thread Name= 5 formatter = yy-M-d ah:mm</span></span><br><span class="line"><span class="comment">Thread Name= 6 default Formatter = yyyyMMdd HHmm</span></span><br><span class="line"><span class="comment">Thread Name= 6 formatter = yy-M-d ah:mm</span></span><br><span class="line"><span class="comment">Thread Name= 7 default Formatter = yyyyMMdd HHmm</span></span><br><span class="line"><span class="comment">Thread Name= 7 formatter = yy-M-d ah:mm</span></span><br><span class="line"><span class="comment">Thread Name= 8 default Formatter = yyyyMMdd HHmm</span></span><br><span class="line"><span class="comment">Thread Name= 9 default Formatter = yyyyMMdd HHmm</span></span><br><span class="line"><span class="comment">Thread Name= 8 formatter = yy-M-d ah:mm</span></span><br><span class="line"><span class="comment">Thread Name= 9 formatter = yy-M-d ah:mm</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>ThreadLocal原理了解吗</p>
<ul>
<li><p>从Thread类源代码入手</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li><p>Thread类中有一个<strong>threadLocals</strong>和一个<strong>inheritableThreadLocals</strong>变量，它们都是ThreadLocalMap类型的变量，ThreadLocalMap可以理解为ThreadLocal类实现的定制化HashMap
( key为threadLocal , value 为值)
默认两个变量都是null，当调用set或get时会创建，实际调用的是ThreadLocalMap类对应的get()、set()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程    </span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        <span class="comment">//★★实际使用的方法</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//★★实际使用的方法</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如上，实际存取都是从Thread的threadLocals
（ThreadLocalMap类）中，并不是存在ThreadLocal上，ThreadLocal用来传递了<strong>变量值</strong>，只是ThreadLocalMap的封装</p></li>
<li><p>ThreadLocal类中通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread
t) 可以访问到该线程的ThreadLocalMap对象</p></li>
<li><p><strong>每个Thread中具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key，Object对象为value的键值对</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，
<code>Thread</code>内部都是使用仅有的那个<code>ThreadLocalMap</code>
存放数据的，<code>ThreadLocalMap</code>的 key 就是
<code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code>
对象调用<code>set</code>方法设置的值</p></li>
</ul></li>
<li><p>ThreadLocal数据结构如下图所示 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221107150751048.png"
alt="image-20221107150751048" /></p>
<p><strong><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221107151155140.png"
alt="image-20221107151155140" /></p></li>
</ol></li>
</ul></li>
<li><p>ThreadLocal内存泄露问题时怎么导致的</p>
<ul>
<li><p>前提知识：强引用、软引用、弱引用和虚引用的区别</p>
<ol type="1">
<li><p>强引用StrongReference<br />
是最普遍的一种引用方式，只要强引用存在，则垃圾回收器就不会回收这个对象</p></li>
<li><p>软引用 SoftReference<br />
如果内存足够不回收，如果内存不足则回收</p></li>
<li><p>弱引用WeakReference
如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它
所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，<strong>不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程，
因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java
虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p></li>
<li><p>虚引用PhantomReference</p>
<ul>
<li>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<strong>虚引用主要用来跟踪对象被垃圾回收器回收的活动</strong></li>
<li>虚引用与软引用和弱引用的一个区别在于：<strong>虚引用必须和引用队列
（ReferenceQueue）联合使用</strong>。当垃圾回收器准备回收一个对象时，如果发现它还有虚引，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</li>
</ul></li>
</ol></li>
<li><p>ThreadLocalMap中，使用的key为ThreadLocal的弱引用（源码中，即Entry），而value是强引用
所以，ThreadLocal没有被外部强引用的情况下，垃圾回收的时候
key会被清理掉，而value不会</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>此时，ThreadLocalMap中就会出现key为null的Entry，如果不做任何措施，value永远无法被GC回收，此时会产生内存泄漏。ThreadLocaMap实现中已经考虑了这种情况，在调用set()、get()、remove()方法时，清理掉key为null的记录
所以使用完ThreadLocal的方法后，最好手动调用remove()方法</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>并发03</title>
    <url>/2022/11/07/review/java_guide/java/concurrent/concurrent-03/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="线程池">线程池</h2>
<ul>
<li><p>为什么要使用线程池</p>
<blockquote>
<ul>
<li>池化技术：线程池、数据库连接池、Http连接池</li>
<li>池化技术思想意义：为了减少每次获取资源的消耗，提高对资源的利用率</li>
</ul>
</blockquote>
<ul>
<li>线程池提供了<strong>限制</strong>和<strong>管理</strong>资源(包括执行一个任务)的方法</li>
<li>每个线程池还维护基本统计信息，例如已完成任务的数量</li>
<li>好处：
<ol type="1">
<li><strong>降低资源消耗</strong>
重复利用已创建线程降低线程创建和销毁造成的消耗</li>
<li>提高响应速度 任务到达时，任务可以不需等到线程创建就能继续执行</li>
<li>提高线程的可管理性
线程是稀缺资源，如果无限制创建，不仅<strong>消耗系统资源</strong>，还会<strong>降低系统的稳定性</strong>，使用线程池统一<strong>管理分配</strong>、<strong>调优</strong>和<strong>监控</strong>。</li>
</ol></li>
</ul></li>
<li><p>实现Runnable接口和Callable接口的区别</p>
<ul>
<li>Runnable接口不会返回接口或抛出检查异常，Callable接口可以</li>
<li>Executors可以实现将Runnable对象转换成Callable对象<br />
Executors.callable(Runnable
task)<code>或</code>Executors.callable(Runnable task, Object result)
//则两个方法，运行的结果是 Callable<Object></li>
</ul>
<p>Runnable和Callable：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Runnable.java</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=========================================</span></span><br><span class="line"><span class="comment">//Callable.java</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>执行execute()和submit()方法的区别是什么</p>
<ol type="1">
<li><p><strong>execute()</strong>
方法用于提交<strong>不需要返回值的任务</strong>，所以<strong>无法判断任务是否被线程池执行成功</strong></p></li>
<li><p><strong>submit()</strong>方法用于提交<strong>需要返回值的任务</strong>，线程池会<strong>返回一个Future类型</strong>的对象，通过这个Future对象<strong>可以判断任务是否返回成功</strong></p>
<ul>
<li><p>这个Future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成；
使用get(long timeout,TimeUnit unit)
方法会在阻塞当前线程一段时间后立即返回(此时任务不一定已经执行完) 注意:
这里的get()不一定会有返回值的，例子如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        Callable&lt;MyClass&gt; myClassCallable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;MyClass&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> MyClass <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">MyClass</span> <span class="variable">myClass1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">                myClass1.setName(<span class="string">&quot;ly-callable-测试&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span> myClass1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Future&lt;?&gt; submit = executorService.submit(myClassCallable);</span><br><span class="line">        <span class="comment">//这里会阻塞</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> submit.get();</span><br><span class="line">        log.info(<span class="string">&quot;ly-callable-打印结果1:&quot;</span> + o);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FutureTask&lt;MyClass&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            <span class="type">MyClass</span> <span class="variable">myClass1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">            myClass1.setName(<span class="string">&quot;ly-FutureTask-测试&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> myClass1;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;?&gt; submit2 = executorService.submit(futureTask);</span><br><span class="line">        <span class="comment">//这里会阻塞</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> submit2.get();</span><br><span class="line">        log.info(<span class="string">&quot;ly-callable-打印结果2:&quot;</span> + o2);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果</span></span><br><span class="line"><span class="comment">2022-11-09 10:19:10 上午 [Thread: main] </span></span><br><span class="line"><span class="comment">INFO:ly-callable-打印结果1:MyClass(name=ly-callable-测试)</span></span><br><span class="line"><span class="comment">2022-11-09 10:19:12 上午 [Thread: main] </span></span><br><span class="line"><span class="comment">INFO:ly-callable-打印结果2:null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>当submit一个Callable对象的时候，能从submit返回的Futureget到返回值；当submit一个FutureTask对象时，没法获取返回值，因为会被当作Runnable对象submit进来</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221109103922513.png"
alt="image-20221109103922513" />
而入参为Runnable时返回值里是get不到结果的</p></li>
</ul></li>
<li><p>下面这段源码，解释了为什么当传入的类型是Runnable对象时，结果为null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码AbstractExecutorService 接口中的一个submit方法</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中的newTaskFor方法</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//execute()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>如何创建线程池</p>
<ul>
<li><p>不允许使用Executors去创建，而是通过new
ThreadPoolExecutor的方式：能让写的同学明确线程池运行规则，规避资源耗尽</p>
<blockquote>
<p>使用Executors返回线程池对象的弊端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#####时间表示keepAliveTime#####</span></span><br><span class="line"><span class="comment">//########线程数量固定，队列长度为Integer.MAX################</span></span><br><span class="line">Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//############线程数量固定，队列长度为Integer.MAX############## </span></span><br><span class="line">Executors.newSingleThreadExecutor(Executors.defaultThreadFactory());</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line"><span class="comment">//############线程数量为Integer.MAX############# </span></span><br><span class="line">Executors.newCachedThreadPool(Executors.defaultThreadFactory());</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//#############线程数量为Integer.MAX############# </span></span><br><span class="line">Executors.newScheduledThreadPool(<span class="number">3</span>, Executors.defaultThreadFactory()); </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="type">int</span> corePoolSize, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line">     ====================&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                       ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>FixedThreadPool</strong>和<strong>SingleThreadExecutor</strong>：这两个方案允许请求的队列长度为Integer.MAX_VALUE，可能<strong>堆积大量请求</strong>，导致OOM</li>
<li><strong>CachedThreadPool</strong>和<strong>ScheduledThreadPool</strong>：允许创建的线程数量为Integer.MAX_VALUE，可能<strong>创建大量线程</strong>，导致OOM</li>
</ul>
</blockquote></li>
<li><p>通过构造方法实现 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221109171604573.png"
alt="image-20221109171604573" /></p></li>
<li><p>通过Executor框架的工具类Executors来实现
以下三个方法，返回的类型都是ThreadPoolExecutor</p>
<ul>
<li>FixedThreadPool :
该方法返回<strong>固定线程数量</strong>的线程池，线程数量<strong>始终不变</strong>。当有新任务提交时，线程池中若有空闲线程则立即执行；若没有，则新任务被暂存到任务队列中，待有线程空闲时，则处理在任务队列中的任务</li>
<li>SingleThreadExecutor：方法返回一个<strong>只有一个线程</strong>的线程池。若多余一个任务被提交到该线程池，任务被保存到一个任务队列中，待线程空闲，按先进先出的顺序执行队列中任务</li>
<li>CachedThreadPool：该方法返回一个<strong>根据实际情况调整线程数量</strong>的线程池。
数量不固定，若有空闲线程可以复用则<strong>优先使用可复用</strong>线程。若<strong>所有线程均工作，此时又有新任务</strong>提交，则<strong>创建新线程</strong>处理任务。所有线程在当前任务执行完毕后返回线程池进行复用</li>
</ul>
<p>Executors工具类中的方法<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221110104950618.png"
alt="image-20221110104950618" /></p></li>
<li><p>ThreadPoolExecutor类分析
该类提供四个构造方法，看最长那个，其余的都是（给定默认值后）调用这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                      <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                      TimeUnit unit,</span></span><br><span class="line"><span class="params">                      BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                      ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                      RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数重要参数分析<br />
corePoolSize :
核心线程数定义<strong>最小可以运行的线程数</strong>量<br />
maximumPoolSize:
当队列中存放的任务<strong>达到队列容量时</strong>，当前可以同时运行的线程数量<strong>变为最大线程数</strong><br />
workQueue：当新线程来的时候先判断当前运行线程数量是否<strong>达到核心</strong>线程数，如果达到的话，<strong>新任务就会被存放在队列</strong>中
ThreadPoolExecutor其他常见参数：</p>
<ol type="1">
<li><p>keepAliveTime：如果线程池中的线程数量大于corePoolSize时，如果这时没有新任务提交，核心线程外的线程不会立即销毁，而是等待，等待的时间超过了keepAliveTime就会被回收</p></li>
<li><p>unit: keepAliveTime参数的时间单位</p></li>
<li><p>threadFactory: executor创建新线程的时候会用到</p></li>
<li><p>handle: 饱和策略</p>
<blockquote>
<p>如果同时运行的线程数量达到最大线程数，且队列已经被放满任务，ThreadPoolTaskExecutor定义该情况下的策略：</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出
<code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong>
调用<strong>执行自己的线程(如果在main方法中，那就是main线程)</strong>运行任务，也就是直接在<strong>调用<code>execute</code>方法的线程</strong>中<strong>运行(<code>run</code>)被拒绝的任务</strong>，如果<strong>执行程序已关闭，则会丢弃该任务</strong>。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong>
不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong>
此策略将丢弃最早的未处理的任务请求。</li>
</ul>
</blockquote>
<p>使用ThreadPoolTaskExecutor或ThreadPoolExecutor构造函数创建线程池时，若不指定RejectExcecutorHandler饱和策略则默认使用ThreadPoolExecutor.AbortPolicy，即抛出RejectedExecution来拒绝新来的任务；对于可伸缩程序，建议使用ThreadPoolExecutor.CallerRunsPolicy，</p></li>
</ol></li>
<li><p>一个简单的线程池Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个Runnable接口实现类</span></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际执行</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;<span class="comment">//核心线程数5</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//最大线程数10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//队列容量100</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;<span class="comment">//等待时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建 MyRunnable 对象（MyRunnable 类实现了Runnable 接口）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------输出</span></span><br><span class="line"><span class="comment">pool-1-thread-3 Start. Time = Sun Apr 12 11:14:37 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-5 Start. Time = Sun Apr 12 11:14:37 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-2 Start. Time = Sun Apr 12 11:14:37 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-1 Start. Time = Sun Apr 12 11:14:37 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-4 Start. Time = Sun Apr 12 11:14:37 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-3 End. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-4 End. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-1 End. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-5 End. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-1 Start. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-2 End. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-5 Start. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-4 Start. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-3 Start. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-2 Start. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-1 End. Time = Sun Apr 12 11:14:47 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-4 End. Time = Sun Apr 12 11:14:47 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-5 End. Time = Sun Apr 12 11:14:47 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-3 End. Time = Sun Apr 12 11:14:47 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-2 End. Time = Sun Apr 12 11:14:47 CST 2020</span></span><br><span class="line"><span class="comment">------ </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>线程池分析原理
由结果可以看出，线程池<strong>先执行5个任务</strong>，此时多出的任务会放到<strong>队列</strong>，那5个任务中<strong>有任务执行完</strong>的话，会拿新的任务执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码分析</span></span><br><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">    <span class="comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span></span><br><span class="line">    <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">    <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line">------ </span><br></pre></td></tr></table></figure>
<p>如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221117140008973.png"
alt="image-20221117140008973" /> 分析上面的例子，</p>
<blockquote>
<p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5
、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5
个任务会被放到等待队列中去。当前的5个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p>
</blockquote></li>
</ul>
<h2 id="atomic原子类">Atomic原子类</h2>
<p>Atomic <code>英[əˈtɒmɪk]</code>原子，即不可分割</p>
<p>线程中，Atomic，指一个操作是不可中断的，即使在多线程一起执行时，一个操作一旦开始，就不会被其他线程干扰</p>
<p>原子类，即具有<strong>原子/原子操作特性</strong>的类。并发包<code>java.util.concurrent</code>原子类都放在<code>java.util.concurrent.atomit</code>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221117152847851.png"
alt="image-20221117152847851" /></p>
<p>Java中存在四种原子类（基本、数组、引用、对象属性）</p>
<ol type="1">
<li>基本类型：AtomicInteger，AtomicLong，AtomicBoolean</li>
<li>数组类型：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</li>
<li>引用类型：AtomicReference，AtomicStampedReference（原子更新带有版本号的引用类型。该类将整数值与引用关联，解决原子的更新数据和数据的版本号，解决使用CAS进行原子更新可能出现的ABA问题），AtomicMarkableReference（原子更新带有标记位的引用类型）</li>
<li>对象属性修改类型：AtomicIntegerFiledUpdater原子更新整型字段的更新器；AtomicLongFiledUpdater；AtomicReferenceFieldUpdater</li>
</ol>
<h3 id="atomicinteger的使用">AtomicInteger的使用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AtomicInteger类常用方法(下面的自增，都使用了CAS，是同步安全的)</span></span><br><span class="line">ublic <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br><span class="line">------</span><br><span class="line"><span class="comment">//使用如下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="comment">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="浅谈atomicinteger实现原理">浅谈AtomicInteger实现原理</h3>
<ol type="1">
<li><p>位于Java.util.concurrent.atomic包下，对int封装，提供<strong>原子性的访问和更新</strong>操作，其原子性操作的实现基于CAS（CompareAndSet）</p>
<ul>
<li>CAS，比较并交换，Java并发中lock-free机制的基础，调用Sun的Unsafe的CompareAndSwapInt完成，为native方法，<strong>基于CPU的CAS</strong>指令来实现的，即无阻塞；且为CAS原语</li>
<li>CAS：三个参数，1. 当前内存值V 2.旧的预期值
3.即将更新的值，当且仅当预期值A和内存值相同时，将内存值改为 8
并返回true；否则返回false
<code>在JAVA中,CAS通过调用C++库实现，由C++库再去调用CPU指令集。</code></li>
<li>CAS确定
<ul>
<li><p>ABA　问题 如果期间发生了 A -&gt; B -&gt; A 的更新，仅仅判断数值是
A，可能导致不合理的修改操作；为此，提供了AtomicStampedReference
工具类，为引用建立类似版本号ｓｔａｍｐ的方式</p></li>
<li><p>循环时间长，开销大。CAS适用于<strong>竞争情况短暂</strong>的情况，有需要的时候要限制自旋次数，以免过度消耗CPU</p></li>
<li><p>只能保证一个共享变量的原子操作
对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁；或者取巧一下，比如
i = 2 , j = a ，合并后为 ij = 2a ，然后cas操作2a</p>
<blockquote>
<p>Java1.5开始JDK提供了<strong>AtomicReference</strong>类来保证引用对象之间的原子性，你可以把<strong>多个变量放在一个对象</strong>里来进行CAS操作，例子如下：
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221118113655799.png"
alt="image-20221118113655799" />
如图，它是同时更新了两个变量，而这两个变量都在新的对象上，所以就能解决多个共享变量的问题，即“将问题转换成，如果变量更新了，则更换一个对象”</p>
</blockquote></li>
</ul></li>
</ul></li>
<li><p>AtomicInteger原理浅析</p>
<p>一些公共属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AtomicInteger，根据<strong>valueOffset</strong>代表的该变量值，<strong>在内存中的偏移地址</strong>，从而获取数据；且value用volatile修饰，保证多线程之间的可见性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unsafe.getAndAddInt</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<span class="comment">//先获取var1对象的偏移量为var2的内存地址上的值，设置为var5</span></span><br><span class="line"><span class="comment">//如果此刻还是var5，+1并赋值，否则重新获取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>假设线程1和线程2通过getIntVolatile拿到value的值都为1，线程1被挂起，线程2继续执行</li>
<li>线程2在compareAndSwapInt操作中由于预期值和内存值都为1，因此成功将内存值更新为2</li>
<li>线程1继续执行，在compareAndSwapInt操作中，预期值是1，而当前的内存值为2，CAS操作失败，什么都不做，返回false</li>
<li>线程1重新通过getIntVolatile拿到最新的value为2，再进行一次compareAndSwapInt操作，这次操作成功，内存值更新为3</li>
</ul></li>
<li><p>原子操作的实现原理</p>
<ul>
<li>Java中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到操作成功为止。</li>
<li>在CAS中有三个操作数：分别是内存地址（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧的预期值A时，处理器才会用新值B更新V的值，否则他就不执行更新，但无论是否更新了V的值，都会返回V的旧值。(<strong>这里说的三个值，指的是逻辑概念，而不是实际概念</strong>)</li>
</ul></li>
</ol>
<h3 id="java实现cas的原理">Java实现CAS的原理</h3>
<p>i++是非线程安全的，因为<strong>i++不是原子</strong>操作；可以使用<strong>synchronized和CAS实现加锁</strong></p>
<p><strong>synchronized是悲观锁</strong>，一旦获得锁，其他线程进入后就会阻塞等待锁；而<strong>CAS是乐观锁</strong>，执行时不会加锁，假设没有冲突，<strong>如果因为冲突失败了就重试</strong>，直到成功</p>
<ul>
<li><p>乐观锁和悲观锁</p>
<ul>
<li>这是一种分类方式</li>
<li><strong>悲观锁</strong>，总是认为<strong>每次访问共享资源会发生冲突</strong>，所以<strong>必须对每次数据操作加锁</strong>，以<strong>保证临界区的程序同一时间只能有一个线程</strong>在执行</li>
<li>乐观锁，又称<strong>“无锁”</strong>，<strong>假设对共享资源访问没有冲突</strong>，线程可以不停的执行，无需加锁无需等待；一旦发生冲突，通常是使用一种称为CAS的技术保证线程执行安全
<ul>
<li>无锁没有锁的存在，因此不可能发生死锁，即乐观锁天生免疫死锁</li>
<li>乐观锁用于“读多写少”的环境，避免加锁频繁影响性能；悲观锁用于“写多读少”，避免频繁失败及重试影响性能</li>
</ul></li>
</ul></li>
<li><p>CAS概念，即CompareAndSwap
，比较和交换，CAS中，有三个值（概念上）<br />
V：要更新的变量(var)；E：期望值（expected）；N：新值（new）
判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。
一般来说，预期值E本质上指的是“旧值”（判断是否修改了）</p>
<blockquote>
<ol type="1">
<li>如果有一个多个线程共享的变量<code>i</code>原本等于5，我现在在线程A中，想把它设置为新的值6;</li>
<li>我们使用CAS来做这个事情；</li>
<li>首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，<code>i</code>的值被设置成了6；</li>
<li>如果不等于5，说明<code>i</code>被其它线程改过了（比如现在<code>i</code>的值为2），那么我就什么也不做，此次CAS失败，<code>i</code>的值仍然为2。</li>
</ol>
<p>其中i为V，5为E，6为N</p>
</blockquote>
<p>CAS是一种原子操作，它是一种系统原语，是一条CPU原子指令，从CPU层面保证它的原子性（<strong>不可能出现说，判断了i为5之后，正准备更新它的值，此时该值被其他线程改了</strong>）</p>
<p>当<strong>多个线程同时使用CAS操作一个变量</strong>时，<strong>只有一个会胜出，并成功更新</strong>，<strong>其余均会失败</strong>，但<strong>失败的线程并不会被挂起</strong>，仅是<strong>被告知失败，并且允许再次尝试</strong>，当然也<strong>允许失败的线程放弃</strong>操作。</p></li>
<li><p>Java实现CAS的原理 - Unsafe类</p>
<ul>
<li><p>在Java中，如果一个方法是native的，那Java就不负责具体实现它，而是交给底层的JVM使用c或者c++去实现</p></li>
<li><p>Java中有一个Unsafe类，在sun.misc包中，里面有一些native方法，其中包括：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset,Object expected, Object x)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset,<span class="type">int</span> expected,<span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset,<span class="type">long</span> expected,<span class="type">long</span> x)</span>;</span><br><span class="line"><span class="comment">//AtomicInteger.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>Unsafe中对CAS的实现是C++</strong>写的，它的具体实现和操作系统、CPU都有关系。Linux的X86中主要通过cmpxchgl这个指令在CPU级完成CAS操作，如果是多处理器则必须使用lock指令加锁</p>
<p>Unsafe类中还有park(线程挂起)和unpark(线程恢复)，LockSupport底层则调用了该方法；还有支持反射操作的allocateInstance()</p></li>
</ul></li>
<li><p>原子操作- AtomicInteger类源码简析
JDK提供了一些原子操作的类，在java.util.concurrent.atomic包下面，JDK11中有如下17个类
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221120182811204.png"
alt="image-20221120182811204" /></p>
<ul>
<li><p>包括
原子更新基本类型，原子更新数组，原子更新引用，原子更新字段(属性)</p></li>
<li><p>其中，AtomicInteger类的getAndAdd(int data)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//unsafe字段</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.<span class="type">Unsafe</span> <span class="variable">U</span> <span class="operator">=</span> jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line"><span class="comment">//上面方法实际调用</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于offset，这是一个对象偏移量，用于获取某个字段相对Java对象的起始地址的偏移量</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个java对象可以看成是一段内存，各个字段都得按照一定的顺序放在这段内存里，同时考虑到对齐要求，可能这些字段不是连续放置的，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用这个方法能准确地告诉你某个字段相对于对象的起始内存地址的字节偏移量，因为是相对偏移量，所以它其实跟某个具体对象又没什么太大关系，跟class的定义和虚拟机的内存模型的实现细节更相关。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再重新看这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里声明了v，即要返回的值，即不论如何都会返回原来的值(更新成功前的值)，然后新的值为v+delta</p>
<p>使用do-while保证所有循环至少执行一遍<br />
循环体的条件是一个CAS方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">weakCompareAndSetInt</span><span class="params">(Object o, <span class="type">long</span> offset,</span></span><br><span class="line"><span class="params">                                          <span class="type">int</span> expected,</span></span><br><span class="line"><span class="params">                                          <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetInt(o, offset, expected, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSetInt</span><span class="params">(Object o, <span class="type">long</span> offset,</span></span><br><span class="line"><span class="params">                                             <span class="type">int</span> expected,</span></span><br><span class="line"><span class="params">                                             <span class="type">int</span> x)</span>;</span><br></pre></td></tr></table></figure>
<p>最终调用了native方法：compareAndSetInt方法</p>
<blockquote>
<p>为甚么要经过一层weakCompareAndSetInt，在JDK
8及之前的版本，这两个方法是一样的。</p>
<p>而在JDK
9开始，这两个方法上面增加了@HotSpotIntrinsicCandidate注解。这个注解允许HotSpot
VM自己来写汇编或IR编译器来实现该方法以提供性能。也就是说虽然外面看到的在JDK9中weakCompareAndSet和compareAndSet底层依旧是调用了一样的代码，但是不排除HotSpot
VM会手动来实现weakCompareAndSet真正含义的功能的可能性。</p>
<p>简单来说，<code>weakCompareAndSet</code>操作仅保留了<code>volatile</code>自身变量的特性，而除去了happens-before规则带来的内存语义。也就是说，<code>weakCompareAndSet</code><strong>无法保证处理操作目标的volatile变量外的其他变量的执行顺序(
编译器和处理器为了优化程序性能而对指令序列进行重新排序
)，同时也无法保证这些变量的可见性。</strong>这在一定程度上可以提高性能。（没看懂）</p>
</blockquote>
<p>CAS如果旧值V不等于预期值E，它就会更新失败。说明旧的值发生了变化。那我们当然需要返回的是被其他线程改变之后的旧值了，因此放在了do循环体内</p></li>
</ul></li>
<li><p>CAS实现原子操作的三大问题</p>
<ul>
<li><p>ABA问题</p>
<ul>
<li><p>就是一个值<strong>原来是A，变成了B，又变回了A</strong>。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次</p></li>
<li><p>在变量前面追加上<strong>版本号或者时间戳</strong>。从JDK
1.5开始，JDK的atomic包里提供了一个类<code>AtomicStampedReference</code>类来解决ABA问题</p></li>
<li><p><code>AtomicStampedReference</code>类的<code>compareAndSet</code>方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用CAS设置为新的值和标志。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(V   expectedReference,</span></span><br><span class="line"><span class="params">                             V   newReference,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> expectedStamp,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> newStamp)</span> &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="type">return</span></span><br><span class="line">        <span class="variable">expectedReference</span> <span class="operator">=</span>= current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote></li>
</ul></li>
<li><p>循环时间长开销大</p>
<ul>
<li><p>CAS多与自旋结合，如果自旋CAS长时间不成功，则会占用大量CPU资源，解决思路是让<strong>JVM支持处理器提供的pause指令</strong></p>
<blockquote>
<p>pause指令能让自旋失败时cpu睡眠一小段时间再继续自旋，从而使得读操作的频率低很多,为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多。</p>
</blockquote></li>
<li><p>限制次数（如果可以放弃操作的话）</p></li>
</ul></li>
<li><p>只能保证一个共享变量的原子操作</p>
<ul>
<li>使用JDK
1.5开始就提供的<code>AtomicReference</code>类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作；</li>
<li>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</li>
</ul></li>
</ul></li>
</ul>
<h2 id="aqs">AQS</h2>
<ul>
<li><p>AQS介绍
全程，AbstractQueuedSynchronizer抽象队列同步器，在java.util.concurrent.locks包下
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221121094942039.png"
alt="image-20221121094942039" /></p>
<p>AQS：用来构建锁和同步器的框架，能<strong>简单且高效</strong>地构造出大量应用广泛的同步器，例如ReentrantLock，Semaphore<code>[ˈseməfɔː(r)]</code>以及ReentrantReadWriteLock，SynchronousQueue，FutureTask都基于AQS</p></li>
<li><p>AQS原理分析</p>
<p><strong>面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来</strong></p>
<p>AQS
核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制
AQS 是用 <strong>CLH
队列锁</strong>实现的，即<strong>将暂时获取不到锁的线程加入到队列</strong>中。</p>
<blockquote>
<p>CLH(Craig,Landin and
Hagersten)队列是一个<strong>虚拟的双向队列</strong>（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS
是<strong>将每条请求共享资源的线程封装成一个 CLH
锁队列的一个结点</strong>（Node）来实现锁的分配。
搜索了一下，CLH好像是人名</p>
</blockquote>
<p>AQS（AbstractQueuedSynchronized）原理图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221120193141243.png"
alt="image-20221120193141243" /></p>
<p>AQS使用一个<strong>int成员变量来表示同步状态</strong>，通过内置的FIFO队列来获取资源线程的排队工作。AQS<strong>使用CAS对同步状态进行原子操作</strong>并实现对其值的修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>
<p>状态信息的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置同步状态的值</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>AQS对资源的共享方式</p>
<ul>
<li>AQS定义两种资源共享方式
<ul>
<li>Exclusive
独占：<strong>只有一个线程</strong>能执行，如ReentrantLock，又分公平锁（按照线程在队列中排队顺序，先到者先拿到锁）及非公平锁（当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的）</li>
<li>Share
共享：<strong>多个线程可同时执行</strong>，如CountDownLatch、Semaphore、CyclicBarrier、ReadWriteLock</li>
</ul></li>
<li>ReentrantReadWriteLock是组合式，读写锁允许<strong>多个线程同时对某一资源</strong>进行读</li>
<li>★不同定义器同步器征用共享资源的方式不同，<strong>自定义同步器在实现时只需要实现共享资源state的获取与释放方法</strong>，至于具体线程等待队列的维护（获取资源失败入队/唤醒出队等），AQS已经在顶层实现好</li>
</ul></li>
<li><p>AQS底层使用了模板方法模式 使用方式</p>
<ol type="1">
<li><p>使用者继承AbstractQueueSynchronizer并重写指定方法（无<strong>非是对于共享资源state的获取和释放</strong>）</p></li>
<li><p>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而<strong>这些模板方法会调用使用者重写的方法</strong></p></li>
<li><p>自定义同步器时，需要重写下面几个AQS提供的钩子方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span>)</span><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。 </span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>什么是钩子方法呢？</strong>
钩子方法是一种被声明在抽象类中的方法，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式<strong>通过钩子方法控制固定步骤的实现</strong>。AQS类中除了钩子方法，其他方法都是final</p></li>
</ol>
<blockquote>
<p>重点：以 <code>ReentrantLock</code> 为例，state 初始化为
0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用
<code>tryAcquire()</code> 独占该锁并将 <code>state+1</code>
。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程
<code>unlock()</code> 到
<code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A
线程自己是可以重复获取此锁的（state
会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证
state 是能回到零态的。</p>
<p>再以 <code>CountDownLatch</code> 以例，任务分为 N
个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N
个子线程是并行执行的，每个子线程执行完后<code>countDown()</code>
一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即
<code>state=0</code> )，会 <code>unpark()</code>
主调用线程，然后主调用线程就会从 <code>await()</code>
函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但
AQS
也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
</blockquote></li>
<li><p>AQS组件总结</p>
<ul>
<li><strong><code>Semaphore</code>(信号量)-允许多个线程同时访问：</strong>
<code>synchronized</code> 和 <code>ReentrantLock</code>
都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong><code>CountDownLatch</code>（倒计时器）：</strong>
<code>CountDownLatch</code>
是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以<strong>让某一个线程等待直到倒计时结束</strong>，再开始执行。</li>
<li><strong><code>CyclicBarrier</code>(循环栅栏)：</strong>
<code>CyclicBarrier</code> 和 <code>CountDownLatch</code>
非常类似，它也可以实现线程间的技术等待，但是它的功能比
<code>CountDownLatch</code> 更加复杂和强大。主要应用场景和
<code>CountDownLatch</code> 类似。<code>CyclicBarrier</code>
的字面意思是可循环使用（<code>Cyclic</code>）的屏障（<code>Barrier</code>）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<code>CyclicBarrier</code>
默认的构造方法是
<code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用
<code>await()</code> 方法告诉 <code>CyclicBarrier</code>
我已经到达了屏障，然后当前线程被阻塞。</li>
</ul></li>
<li><p>用过CountDownLatch么，什么场景下用的</p>
<p>作用：<strong>允许count个线程阻塞在一个地方，直到所有线程的任务都执行完毕</strong>（例子种，需要读取处理6个文件，6个任务没有执行顺序依赖，但是返回的时候，需要将这几个文件的处理结果进行统计整理）</p>
<p>解析：定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象
。使用线程池处理读取任务，<strong>每一个线程处理完之后就将
count-1，调用<code>CountDownLatch</code>对象的
<code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//共享</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample1</span> &#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadCount</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成(将count-1)</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();<span class="comment">//会一直阻塞，直到count为0</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>改进，使用CompletableFuture类改进，该类提供了很多对多线程有好的方式，包括
异步、串行、并行或者等待所有线程执行完任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; task1 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; task6 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; headerFuture=CompletableFuture.allOf(task1,.....,task6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    headerFuture.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;all done. &quot;</span>); </span><br></pre></td></tr></table></figure>
<p>使用循环：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件夹位置</span></span><br><span class="line">List&lt;String&gt; filePaths = Arrays.asList(...)</span><br><span class="line"><span class="comment">// 异步处理所有文件</span></span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; fileFutures = filePaths.stream()</span><br><span class="line">    .map(filePath -&gt; doSomeThing(filePath))</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 将他们合并起来</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(</span><br><span class="line">    fileFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[fileFutures.size()])</span><br><span class="line">); </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="参考">参考</h2>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java常见并发容器</title>
    <url>/2022/11/29/review/java_guide/java/concurrent/concurrent-collections/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<p>JDK提供的容器，大部分在java.util.concurrent包中</p>
<ul>
<li>ConcurrentHashMap：线程安全的<strong>HashMap</strong></li>
<li>CopuOnWriteArrayList：线程安全的<strong>List</strong>，在读多写少的场合性能非常好，远好于Vector</li>
<li><strong>ConcurrentLinkedQueue</strong>：高效的<strong>并发队列</strong>，使用<strong>链表</strong>实现，可以看作一个<strong>线程安全的LinkedList</strong>，是一个<strong>非阻塞队列</strong></li>
<li><strong>BlockingQueue</strong>：这是一个接口，JDK内部通过链表、数组等方式实现了该接口。表示<strong>阻塞队列</strong>，非常适合用于作为数据共享的通道</li>
<li>ConcorrentSkipListMap：<strong>跳表</strong>的实现，是一个Map，使用<strong>跳表的数据结构进行快速查找</strong></li>
</ul>
<h1 id="concurrenthashmap">ConcurrentHashMap</h1>
<ul>
<li>HashMap是线程不安全的，并发场景下要保证线程安全，可以使用Collections.synchronizedMap()方法来包装HashMap，但这是通过<strong>使用一个全局的锁</strong>来<strong>同步不同线程间的并发访问</strong>，因此会带来性能问题</li>
<li>建议使用ConcurrentHashMap，不论是读操作还是写操作都能保证高性能：读操作（几乎）不需要加锁，而写操作时通过锁分段技术，只对<strong>所操作的段加锁</strong>而不影响客户端对其他段的访问</li>
</ul>
<h1 id="copyonwritearraylist">CopyOnWriteArrayList</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, Serializable</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<ul>
<li>在很多应用场景中，<strong>读操作可能会远远大于写操作</strong></li>
<li>我们应该允许多个线程同时访问List内部数据（针对读）</li>
<li>与ReentrantReadWriteLock读写锁思想非常类似，即<strong>读读共享</strong>、<strong>写写互斥</strong>、<strong>读写互斥</strong>、<strong>写读互斥</strong></li>
<li>不一样的是，CopyOnWriteArrayList<strong>读取时完全不需要加锁</strong>，且<strong>写入也不会阻塞读取操作</strong>，只有<strong>写入和写入之间需要同步等待</strong>。</li>
</ul>
<h2
id="copyonwritearraylist是如何做到的">CopyOnWriteArrayList是如何做到的</h2>
<ul>
<li><code>CopyOnWriteArrayList</code> 类的<strong>所有可变操作（add，set
等等）都是通过创建底层数组的新副本</strong>来实现的。当 List
需要被修改的时候，我并不修改原有内容，而是<strong>对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据</strong>，这样就可以保证写操作不会影响读操作了。</li>
<li>从 <code>CopyOnWriteArrayList</code> 的名字就能看出
<code>CopyOnWriteArrayList</code> 是满足
<strong><code>CopyOnWrite</code></strong> 的</li>
<li>在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就<strong>将指向原来内存指针指向新的内存(注意，是指向，而不是重新拷贝)</strong>，原来的内存就可以被回收掉了</li>
</ul>
<h2
id="copyonwritearraylist-读取和写入源码简单分析">CopyOnWriteArrayList
读取和写入源码简单分析</h2>
<ul>
<li><p>CopyOnWriteArrayList读取操作的实现
读取操作没有任何同步控制和锁操作，理由就是内部数组array不会发生修改，只会<strong>被另一个array替换</strong>，因此可以保证数据安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">  <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> E <span class="title function_">get</span><span class="params">(Object[] a, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (E) a[index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>CopyOnWriteArrayList写入操作的实现
在添加集合的时候加了锁，保证同步，<strong>避免多线程写的时候会copy出多个副本</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">        lock.lock();<span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//拷贝新数组</span></span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="concurrentlinkedqueue">ConcurrentLinkedQueue</h1>
<ul>
<li>Java提供的<strong>线程安全的Queue</strong>分为<strong>阻塞队列</strong>和<strong>非阻塞队列</strong></li>
<li>阻塞队列的典型例子是<strong>BlockingQueue</strong>，<strong>非阻塞队列的典型例子是ConcurrentLinkedQueue</strong></li>
<li><strong>阻塞队列通过锁</strong>来实现，<strong>非阻塞队列通过CAS</strong>实现</li>
<li>ConcurrentLinkedQueue使用<strong>链表</strong>作为数据结构，是高并发环境中性能最好的队列</li>
<li><code>ConcurrentLinkedQueue</code>
适合在对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合<strong>使用无锁的
<code>ConcurrentLinkedQueue</code>，即CAS</strong> 来替代</li>
</ul>
<h1 id="blockingqueue">BlockingQueue</h1>
<p>阻塞队列（<code>BlockingQueue</code>）被广泛使用在“<strong>生产者-消费者</strong>”问题中，其原因是
<code>BlockingQueue</code>
提供了<strong>可阻塞的插入和移除</strong>的方法。当<strong>队列容器已满，生产者线程会被阻塞，直到队列未满</strong>；当<strong>队列容器为空时，消费者线程会被阻塞，直至队列非空</strong>时为止</p>
<p>BlockingQueue是一个接口，继承自<strong>Queue</strong>，而<strong>Queue</strong>又继承自Collection接口，下面是BlockingQueue的<strong>相关实现类</strong>：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221130112118211.png"
alt="image-20221130112118211" /></p>
<h2 id="arraybockingqueue">ArrayBockingQueue</h2>
<ul>
<li><p>ArrayBlockingQueue是<strong>BlockingQueue</strong>接口的<strong>有界队列实现类</strong>，底层采用<strong>数组</strong>来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayBlockingQueue</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">AbstractQueue</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">BlockingQueue</span>&lt;E&gt;, Serializable&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>ArrayBlockingQueue</code>
一旦创建，容量不能改变。其并发控制采用<strong>可重入锁
<code>ReentrantLock</code></strong>
，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p></li>
<li><p><code>ArrayBlockingQueue</code>
<strong>默认情况下不能保证线程访问队列的公平性</strong>，所谓<strong>公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到
<code>ArrayBlockingQueue</code></strong>。而非公平性则是指访问
<code>ArrayBlockingQueue</code>
的顺序不是遵守严格的时间顺序，有可能存在，当
<code>ArrayBlockingQueue</code>
可以被访问时，长时间阻塞的线程依然无法访问到
<code>ArrayBlockingQueue</code>。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的
<code>ArrayBlockingQueue</code>，可采用如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Integer&gt;(<span class="number">10</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="linkedbockingqueue">LinkedBockingQueue</h2>
<ul>
<li><p>底层基于<strong>单向链表</strong>实现阻塞队列，可以当作无界队列也可以当作有界队列</p></li>
<li><p>满足FIFO特性，与ArrayBlockingQueue相比有更高吞吐量，为防止LinkedBlockingQueue容量迅速增加，损耗大量内存，一般创建LinkedBlockingQueue对象时会指定大小<strong>；如果未指定则容量等于Integer.MAX_VALUE</strong></p></li>
<li><p>相关构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *某种意义上的无界队列</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with a capacity of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Integer#MAX_VALUE&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *有界队列</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with the given (fixed) capacity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity&#125; is not greater</span></span><br><span class="line"><span class="comment">     *         than zero</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        last = head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="priorityblockingqueue">PriorityBlockingQueue</h2>
<ul>
<li><strong>支持优先级的无界阻塞队列</strong>，默认情况元素采用<strong>自然顺序</strong>进行排序，或通过自定义类实现compareTo()方法指定元素排序，或初始化时通过<strong>构造器参数Comparator</strong>来指定排序规则</li>
<li><code>PriorityBlockingQueue</code> 并发控制采用的是<strong>可重入锁
<code>ReentrantLock</code></strong>，<strong>队列为无界队列</strong>（<code>ArrayBlockingQueue</code>
是有界队列，<code>LinkedBlockingQueue</code> 也可以通过在构造函数中传入
<code>capacity</code> 指定队列最大的容量，但是
<strong><code>PriorityBlockingQueue</code>
只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容</strong>）</li>
<li>它就是 <code>PriorityQueue</code> 的线程安全版本。<strong>不可以插入
null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报
<code>ClassCastException</code> 异常</strong>。它的插入操作 put 方法不会
block(<strong>是block 阻塞，不是lock
锁</strong>)，因为它是无界队列（take 方法在队列为空的时候会阻塞）</li>
</ul>
<h1 id="concurrentskiplistmap">ConcurrentSkipListMap</h1>
<blockquote>
<p>对于一个单链表，即使<strong>链表是有序</strong>的，如果我们想要在其中查找某个数据，也只能<strong>从头到尾遍历链表</strong>，这样效率自然就会很低，跳表就不一样了。<strong>跳表是一种可以用来快速查找的数据结构，有点类似于平衡树</strong>。它们都可以<strong>对元素进行快速的查找</strong>。但一个重要的区别是：对<strong>平衡树的插入和删除</strong>往往很可能<strong>导致平衡树进行一次全局的调整</strong>。而对<strong>跳表的插入和删除</strong>只需要<strong>对整个数据结构的局部进行操作</strong>即可。这样带来的好处是：<strong>在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全</strong>。而对于<strong>跳表，你只需要部分锁</strong>即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，<strong>跳表的时间复杂度也是
O(logn)</strong> 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。</p>
</blockquote>
<p>跳表的本质是维护多个链表，且链表是分层的 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221130144105594.png"
alt="image-20221130144105594" /></p>
<ul>
<li>最低层的链表维护跳表内所有元素，每上面一层链表都是下面一层的子集</li>
<li>跳表内所有链表的元素都是<strong>排序</strong>的</li>
<li>查找时，可以<strong>从顶级链表开始找</strong>。一旦发现<strong>被查找的元素大于当前链表中的取值（这里应该加上一句，小于前一个节点，比如下面如果是查找3，那么就从1跳下去），就会转入下一层链表继续找</strong>。这也就是说在查找过程中，搜索是跳跃式的。如上图所示，在跳表中查找元素
18。</li>
</ul>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221130144439833.png"
alt="image-20221130144439833" /> 查找 18 的时候原来需要遍历 18
次，现在只需要 7
次即可。针对链表长度比较大的时候，构建索引查找效率的提升就会非常明显
（<strong>这里好像不太对，原来也不需要遍历18次,反正大概率是说效率高就是了</strong>）</p>
<p>使用跳表实现 <code>Map</code> 和使用哈希算法实现 <code>Map</code>
的另外一个不同之处是：哈<strong>希并不会保存元素的顺序，而跳表内所有的元素都是排序的</strong>。因此在对跳表进行遍历时，你会得到一个有序的结果。所以，如果你的应用<strong>需要有序性，那么跳表就是你不二的选择</strong>。JDK
中实现这一数据结构的类是
<strong><code>ConcurrentSkipListMap</code></strong>。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java线程池</title>
    <url>/2022/11/23/review/java_guide/java/concurrent/java-thread-pool/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="一-使用线程池的好处">一 使用线程池的好处</h2>
<ul>
<li>池化技术：减少每次获取资源的消耗，提高对资源的利用率</li>
<li>线程池提供一种<strong>限制</strong>和<strong>管理资源（包括执行一个任务）</strong>的方式，每个线程池还维护一些基本统计信息，例如<strong>已完成任务</strong>的数量</li>
<li>线程池的好处
<ul>
<li>降低资源消耗（重复利用，降低线程创建和销毁造成的消耗）</li>
<li>提高响应速度（任务到达直接执行，无需等待线程创建）</li>
<li>提高线程可管理性（避免无休止创建，使用线程池同一分配、调优、监控）</li>
</ul></li>
</ul>
<h2 id="二-executor框架">二 Executor框架</h2>
<p>Java5之后，通过Executor启动线程，比使用Thread的start方法更好，更易于管理，效率高，还能有助于避免this逃逸的问题</p>
<blockquote>
<p>this逃逸，指的是构造函数返回之前，其他线程就持有该对象的引用，会导致调用尚未构造完全的对象</p>
</blockquote>
<p>Executor框架不仅包括<strong>线程池的管理</strong>，提供<strong>线程工厂</strong>、<strong>队列</strong>以及<strong>拒绝策略</strong>。</p>
<h3 id="executor框架结构">Executor框架结构</h3>
<p>主要是三大部分：任务（Runnable/Callable），任务的执行(Executor)，异步计算的结果Future</p>
<ol type="1">
<li><p>任务
执行任务需要的Runnable/Callable接口，他们的实现类，都可以被ThreadPoolExecutor或ScheduleThreadPoolExecutor执行</p></li>
<li><p>任务的执行 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221123163721335.png"
alt="image-20221123163721335" />
我们更多关注的，是ThreadPoolExecutor类。另外，ScheduledThreadPoolExecutor类，继承了ThreadPoolExecutor类，并实现了ScheduledExecutorService接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadPoolExecutor类描述</span></span><br><span class="line"><span class="comment">//AbstractExecutorService实现了ExecutorService接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor类描述</span></span><br><span class="line"><span class="comment">//ScheduledExecutorService继承ExecutorService接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolExecutor</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">ScheduledExecutorService</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>异步计算的结果
<strong>Future接口以及其实现类FutueTask类</strong>都可以代表异步计算的结果(下面就是Future接口)
当我们把<strong>Runnable接口（结果为null）</strong>或<strong>Callable接口</strong>的实现类提交给ThreadPoolExecutor或ScheduledThreadPoolExecutor执行（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        Callable&lt;MyClass&gt; myClassCallable = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;MyClass&gt;() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">public</span> MyClass <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">MyClass</span> <span class="variable">myClass1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">                myClass1.setName(<span class="string">&quot;ly-callable-测试&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span> myClass1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Future&lt;?&gt; submit = executorService.submit(myClassCallable);</span><br><span class="line">        <span class="comment">//这里会阻塞</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> submit.get();</span><br><span class="line">        log.info(<span class="string">&quot;ly-callable-打印结果1:&quot;</span> + o);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FutureTask&lt;MyClass&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            <span class="type">MyClass</span> <span class="variable">myClass1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">            myClass1.setName(<span class="string">&quot;ly-FutureTask-测试&quot;</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> myClass1;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;?&gt; submit2 = executorService.submit(futureTask);</span><br><span class="line">        <span class="comment">//这里会阻塞</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> submit2.get();</span><br><span class="line">        log.info(<span class="string">&quot;ly-callable-打印结果2:&quot;</span> + o2);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*结果</span></span><br><span class="line"><span class="comment">2022-11-09 10:19:10 上午 [Thread: main] </span></span><br><span class="line"><span class="comment">INFO:ly-callable-打印结果1:MyClass(name=ly-callable-测试)</span></span><br><span class="line"><span class="comment">2022-11-09 10:19:12 上午 [Thread: main] </span></span><br><span class="line"><span class="comment">INFO:ly-callable-打印结果2:null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="executor框架的使用示意图">Executor框架的使用示意图</h3>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221123173130638.png"
alt="image-20221123173130638" />
<figcaption aria-hidden="true">image-20221123173130638</figcaption>
</figure>
<ol type="1">
<li><strong>主线程首先要创建实现 <code>Runnable</code> 或者
<code>Callable</code> 接口的任务对象。</strong></li>
<li><strong>把创建完成的实现
<code>Runnable</code>/<code>Callable</code>接口的 对象直接交给
<code>ExecutorService</code> 执行</strong>:
<code>ExecutorService.execute（Runnable command）</code>）或者也可以把
<code>Runnable</code> 对象或<code>Callable</code> 对象提交给
<code>ExecutorService</code>
执行（<code>ExecutorService.submit（Runnable task）</code>或
<code>ExecutorService.submit（Callable &lt;T&gt; task）</code>）。</li>
<li><strong>如果执行
<code>ExecutorService.submit（…）</code>，<code>ExecutorService</code>
将返回一个实现<code>Future</code>接口的对象</strong>（我们刚刚也提到过了执行
<code>execute()</code>方法和
<code>submit()</code>方法的区别，<code>submit()</code>会返回一个
<code>FutureTask 对象）。由于 FutureTask</code> 实现了
<code>Runnable</code>，我们也可以创建
<code>FutureTask</code>，然后直接交给 <code>ExecutorService</code>
执行。</li>
<li><strong>最后，主线程可以执行
<code>FutureTask.get()</code>方法来等待任务执行完成。主线程也可以执行
<code>FutureTask.cancel（boolean mayInterruptIfRunning）</code>来取消此任务的执行。</strong></li>
</ol>
<h2 id="三-重要threadpoolexecutor类简单介绍">三
(重要)ThreadPoolExecutor类简单介绍</h2>
<p><strong>线程池实现类 <code>ThreadPoolExecutor</code> 是
<code>Executor</code> 框架最核心的类。</strong></p>
<h3 id="threadpoolexecutor类分析">ThreadPoolExecutor类分析</h3>
<ul>
<li><p>这里看最长的那个，其余三个都是在该构造方法的基础上产生，即<strong>给定某些默认参数</strong>的构造方法，比如<strong>默认的拒绝策略</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                            <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                            TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                            ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                            RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                             )</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">          keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">      <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">      <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">      <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">      <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">      <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">      <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">      <span class="built_in">this</span>.handler = handler;</span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure></li>
<li><p>ThreadPoolExecutor中，3个最重要的参数</p>
<ol type="1">
<li><strong>corePoolSize</strong>：<strong>核心线程数</strong>，定义了最小可以同时运行的线程数量</li>
<li><strong>maximumPoolSize</strong>：<strong>当队列中存放的任务达到队列容量</strong>时，当前<strong>可以同时运行的线程数量变为最大线程数</strong></li>
<li><strong>workQueue</strong>：当新任务来的时候，会先判断当前运行的线程数量<strong>是否达到核心线程数</strong>，如果<strong>达到</strong>的话，新任务就会被存放在<strong>队列</strong>中</li>
</ol></li>
<li><p>ThreadPoolExecutor其他常见参数</p>
<ol type="1">
<li><strong>keepAliveTime</strong>：当线程池中的<strong>线程数量大于corePoolSize</strong>时，如果此时<strong>没有新任务提交，核心线程外的线程不会立即销毁，而是会等待</strong>，直到等待时间超过了keepAliveTime才会被回收销毁</li>
<li><strong>unit</strong>：keepAliveTime参数的时间单位</li>
<li><strong>threadFactory</strong>：executor创建新线程的时候会用到</li>
<li><strong>handler</strong>：饱和策略</li>
</ol>
<p>线程池各个参数的相互关系的理解<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221124095832400.png"
alt="image-20221124095832400" /></p></li>
<li><p>ThreadPoolExecutor饱和策略定义
如果当前<strong>同时运行的线程数量达到最大线程数量</strong>并且<strong>队列也已经被放满了任务</strong>时，ThreadPoolTaskExecutor定义了一些策略：</p>
<ol type="1">
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code></strong> ：抛出
<code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code></strong>
：调用执行自己的线程运行任务，也就是直接在<strong>调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务</strong>，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code></strong>
：不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code></strong>
： 此策略将丢弃最早的未处理的任务请求。</li>
</ol>
<blockquote>
<p>举例： Spring 通过 <code>ThreadPoolTaskExecutor</code>
或者我们直接通过 <code>ThreadPoolExecutor</code>
的构造函数创建线程池的时候，当我们不指定
<code>RejectedExecutionHandler</code>
饱和策略的话来配置线程池的时候默认使用的是
<code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code>
将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务
，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用
<code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看
<code>ThreadPoolExecutor</code>
的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了。</p>
</blockquote></li>
</ul>
<h3 id="推荐使用-threadpoolexecutor-构造函数创建线程池">推荐使用
<code>ThreadPoolExecutor</code> 构造函数创建线程池</h3>
<blockquote>
<p>阿里巴巴Java开发手册"并发处理"这一章节，明确指出，线程资源必须通过线程池提供，不允许在应用中自行显示创建线程</p>
</blockquote>
<p>原因：使用线程池的好处是<strong>减少在创建和销毁线程上所消耗的时间以及系统资源开销</strong>，<strong>解决资源不足</strong>的问题。如果<strong>不使用线程池</strong>，有可能会<strong>造成系统创建大量同类线程</strong>而导致消耗完内存或者“过度切换”的问题。也<strong>不允许使用Executors去创建，而是通过ThreadPoolExecutor构造方式</strong><br />
Executors返回线程池对象的弊端：</p>
<ul>
<li>FixedThreadPool和SingleThreadExecutor：允许请求的队列长度为Integer.MAV_VALUE
可能堆积大量请求，导致OOM</li>
<li>CachedThreadPool和ScheduledThreadPool，允许创建的线程数量为Integer.MAX_VALUE
可能创建大量线程，从而导致OOM</li>
</ul>
<p>创建线程的几种方法</p>
<ol type="1">
<li>通过ThreadPoolExecutor构造函数实现（推荐） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221124105119802.png"
alt="image-20221124105119802" /></li>
<li>通过Executors框架的工具类Executors来实现，我们可以创建三红类型的ThreadPoolExecutor
FixedThreadPool、SingleThreadExecutor、CachedThreadPool</li>
</ol>
<h2 id="四-threadpoolexecutor使用原理分析">四
ThreadPoolExecutor使用+原理分析</h2>
<h3
id="示例代码runnablethreadpoolexecutor">示例代码：Runnable+ThreadPoolExecutor</h3>
<p>先创建一个Runnable接口的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyRunnable.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processCommand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>使用自定义的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE, <span class="comment">//5</span></span><br><span class="line">                MAX_POOL_SIZE,  <span class="comment">//10</span></span><br><span class="line">                KEEP_ALIVE_TIME, <span class="comment">//1L</span></span><br><span class="line">                TimeUnit.SECONDS, <span class="comment">//单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),<span class="comment">//100</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()); <span class="comment">//主线程中运行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="comment">// isTerminated 判断所有提交的任务是否完成(保证之前调用过shutdown方法) </span></span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//结果：  </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">corePoolSize: 核心线程数为 5。</span></span><br><span class="line"><span class="comment">maximumPoolSize ：最大线程数 10</span></span><br><span class="line"><span class="comment">keepAliveTime : 等待时间为 1L。</span></span><br><span class="line"><span class="comment">unit: 等待时间的单位为 TimeUnit.SECONDS。</span></span><br><span class="line"><span class="comment">workQueue：任务队列为 ArrayBlockingQueue，并且容量为 100;</span></span><br><span class="line"><span class="comment">handler:饱和策略为 CallerRunsPolicy</span></span><br><span class="line"><span class="comment">---output--- </span></span><br><span class="line"><span class="comment">pool-1-thread-3 Start. Time = Sun Apr 12 11:14:37 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-5 Start. Time = Sun Apr 12 11:14:37 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-2 Start. Time = Sun Apr 12 11:14:37 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-1 Start. Time = Sun Apr 12 11:14:37 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-4 Start. Time = Sun Apr 12 11:14:37 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-3 End. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-4 End. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-1 End. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-5 End. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-1 Start. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-2 End. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-5 Start. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-4 Start. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-3 Start. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-2 Start. Time = Sun Apr 12 11:14:42 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-1 End. Time = Sun Apr 12 11:14:47 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-4 End. Time = Sun Apr 12 11:14:47 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-5 End. Time = Sun Apr 12 11:14:47 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-3 End. Time = Sun Apr 12 11:14:47 CST 2020</span></span><br><span class="line"><span class="comment">pool-1-thread-2 End. Time = Sun Apr 12 11:14:47 CST 2020</span></span><br><span class="line"><span class="comment">------ </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="线程池原理分析">线程池原理分析</h3>
<p>如上，<strong>线程池首先会先执行 5
个任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221124133637560.png"
alt="image-20221124133637560" />
<figcaption aria-hidden="true">image-20221124133637560</figcaption>
</figure>
<p>execute方法源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">        <span class="comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span></span><br><span class="line">        <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">        <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">            <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">                <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">        <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">------ </span><br></pre></td></tr></table></figure>
<p>图示：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221124133846191.png"
alt="image-20221124133846191" /></p>
<p>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 全局锁，并发操作必备</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 跟踪线程池的最大大小，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line">    <span class="comment">// 工作线程集合，存放线程池中所有的（活跃的）工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//获取线程池状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">    <span class="comment">//判断线程池的状态是否为 Running</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加新的工作线程到线程池</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask 要执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> core参数为true的话表示使用线程池的基本大小，为false使用线程池最大大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 添加成功就返回true否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//这两句用来获取线程池的状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="comment">//获取线程池中工作的线程的数量</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">                <span class="comment">// core参数为false的话表明队列也满了，线程池大小变为 maximumPoolSize</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               <span class="comment">//原子操作将workcount的数量加1</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                <span class="comment">// 如果线程的状态改变了就再次执行上述操作</span></span><br><span class="line">                c = ctl.get();</span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记工作线程是否启动成功</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 标记工作线程是否创建成功</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 加锁</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//获取线程池状态</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">                   <span class="comment">//rs &lt; SHUTDOWN 如果线程池状态依然为RUNNING,并且线程的状态是存活的话，就会将工作线程添加到工作线程集合中</span></span><br><span class="line">                  <span class="comment">//(rs=SHUTDOWN &amp;&amp; firstTask == null)如果线程池状态小于STOP，也就是RUNNING或者SHUTDOWN状态下，同时传入的任务实例firstTask为null，则需要添加到工作线程集合和启动新的Worker</span></span><br><span class="line">                   <span class="comment">// firstTask == null证明只新建线程而不执行任务</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                        workers.add(w);</span><br><span class="line">                       <span class="comment">//更新当前工作线程的最大容量</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                      <span class="comment">// 工作线程是否启动成功</span></span><br><span class="line">                        workerAdded = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//// 如果成功添加工作线程，则调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                  <span class="comment">/// 标记线程启动成功</span></span><br><span class="line">                    workerStarted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 线程启动失败，需要从工作线程中移除对应的Worker</span></span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br><span class="line">------ </span><br></pre></td></tr></table></figure>
<p>完整源码分析
https://www.throwx.cn/2020/08/23/java-concurrency-thread-pool-executor/</p>
<blockquote>
<p>对于代码中，进行分析：</p>
<p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5
、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5
个任务会被放到等待队列中去。当前的 5
个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p>
</blockquote>
<h3 id="几个常见的对比">几个常见的对比</h3>
<ul>
<li><p>Runnable VS Callable Runnable Java
1.0，不会返回结果或抛出检查异常</p>
<p>Callable Java 1.5 可以</p>
<blockquote>
<p>工具类Executors可以实现，将Runnable对象转换成Callable对象(
Executors.callable(Runnable
task)<code>或</code>Executors.callable(Runnable task, Object result)
)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Runnable</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">------</span><br><span class="line"><span class="comment">//Callable</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>execute() VS submit()</p>
<ul>
<li><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li>
<li><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个
<code>Future</code> 类型的对象，通过这个 <code>Future</code>
对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的
<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用
<code>get（long timeout，TimeUnit unit）</code>方法的话，如果在
<code>timeout</code> 时间内任务还没有执行完，就会抛出
<code>java.util.concurrent.TimeoutException</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//真实使用，建议使用ThreadPoolExecutor构造方法</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> submit.get();</span><br><span class="line">System.out.println(s);</span><br><span class="line">executorService.shutdown();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> abc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>使用抛异常的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> submit.get(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">System.out.println(s);</span><br><span class="line">executorService.shutdown();</span><br><span class="line"><span class="comment">/* 控制台输出</span></span><br><span class="line"><span class="comment"> Exception in thread &quot;main&quot; java.util.concurrent.TimeoutException</span></span><br><span class="line"><span class="comment">	at java.util.concurrent.FutureTask.get(FutureTask.java:205)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>shutdown() VS shutdownNow() <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221124135602080.png"
alt="image-20221124135602080" /></p>
<ul>
<li><strong><code>shutdown（）</code></strong>
:关闭线程池，线程池的状态变为
<code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li>
<li><strong><code>shutdownNow（）</code></strong>
:关闭线程池，线程的状态变为
<code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的
List。</li>
</ul></li>
<li><p>isTerminated() VS isshutdown()</p>
<ul>
<li><strong><code>sShutDown</code></strong> 当调用
<code>shutdown()</code> 方法后返回为 true。</li>
<li><strong><code>isTerminated</code></strong> 当调用
<code>shutdown()</code>
方法后，并且<strong>所有提交的任务完成</strong>后返回为 true</li>
</ul></li>
<li><p>callable+ThreadPoolExecutor示例代码 源代码 //MyCallable.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        List&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//提交任务到线程池</span></span><br><span class="line">            Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">            <span class="comment">//将返回值 future 添加到 list，我们可以通过 future 获得 执行 Callable 得到的返回值</span></span><br><span class="line">            futureList.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; fut : futureList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;::&quot;</span> + fut.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果</span></span><br><span class="line"><span class="comment">Wed Nov 13 13:40:41 CST 2019::pool-1-thread-1</span></span><br><span class="line"><span class="comment">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-2</span></span><br><span class="line"><span class="comment">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-3</span></span><br><span class="line"><span class="comment">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-4</span></span><br><span class="line"><span class="comment">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-5</span></span><br><span class="line"><span class="comment">Wed Nov 13 13:40:42 CST 2019::pool-1-thread-3</span></span><br><span class="line"><span class="comment">Wed Nov 13 13:40:43 CST 2019::pool-1-thread-2</span></span><br><span class="line"><span class="comment">Wed Nov 13 13:40:43 CST 2019::pool-1-thread-1</span></span><br><span class="line"><span class="comment">Wed Nov 13 13:40:43 CST 2019::pool-1-thread-4</span></span><br><span class="line"><span class="comment">Wed Nov 13 13:40:43 CST 2019::pool-1-thread-5</span></span><br><span class="line"><span class="comment">------</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="几种常见的线程池详解">几种常见的线程池详解</h2>
<ol type="1">
<li><p>FixedThreadPool
称之为<strong>可重用固定线程数</strong>的线程池，Executors类中源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个可重用固定数量线程的线程池</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="comment">//================或================</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<p>如上得知，新创建的FixedThreadPool的<strong>corePoolSize</strong>和<strong>maximumPoolSize</strong>都被设置为nThreads</p>
<ul>
<li>执行任务过程介绍 FixedThreadPool的execute()方法运行示意图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221124155404087.png"
alt="image-20221124155404087" /> 上图分析
<ol type="1">
<li>如果当前运行的线程数小于 corePoolSize，
如果再来新任务的话，就创建新的线程来执行任务；</li>
<li>当前运行的线程数等于 corePoolSize 后，
如果再来新任务的话，会将任务加入 <code>LinkedBlockingQueue</code>；</li>
<li>线程池中的线程执行完 手头的任务后，会在循环中反复从
<code>LinkedBlockingQueue</code> 中获取任务来执行；</li>
</ol></li>
<li>为什么不推荐使用FixedThreadPool
主要原因，FixedThreadPool<strong>使用无界队列LinkedBlockingQueue（队列容量为Integer.MAX_VALUE)作为线程池的工作队列</strong>
<ol type="1">
<li>线程池的线程数达到corePoolSize后，新任务在无界队列中等待，因此线程池中线程数不超过corePoolSize</li>
<li>由于使用无界队列时 <code>maximumPoolSize</code>
将是一个无效参数，因为不可能存在任务队列满的情况。所以，【不需要空闲线程，因为corePool，然后Queue，最后才是空闲线程】通过创建
<code>FixedThreadPool</code>的源码可以看出创建的
<code>FixedThreadPool</code> 的 <code>corePoolSize</code> 和
<code>maximumPoolSize</code> 被设置为同一个值。</li>
<li>又由于1、2原因，使用无界队列时，keepAliveTime将是无效参数</li>
<li>运行中的FixedThreadPool（如果未执行shutdown()或shutdownNow()）则不会拒绝任务，因此在任务较多时会导致OOM（内存溢出,Out
Of Memory）</li>
</ol></li>
</ul></li>
<li><p>SingleThreadExecutor</p>
<ul>
<li><p>SingleThreadExecutor是只有一个线程的线程池，源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回只有一个线程的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//另一种构造函数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>新创建的 <code>SingleThreadExecutor</code> 的
<code>corePoolSize</code> 和 <code>maximumPoolSize</code> 都被设置为
1.其他参数和 <code>FixedThreadPool</code> 相同</p></li>
<li><p>执行过程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221124173110534.png"
alt="image-20221124173110534" />
如果当前运行线程数少于corePoolSize（1），则创建一个新的线程执行任务；当前线程池有一个运行的线程后，将任务加入LinkedBlockingQueue；线程执行完当前的任务后，会在循环中反复从LinkedBlockingQueue中获取任务执行</p></li>
<li><p>为什么不推荐使用SingleThreadExecutor
SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列（容量为Integer.MAX_VALUE)
。SingleThreadExecutor使用无界队列作为线程池的工作队列会对线程池带来的影响与FixedThreadPoll相同，即导致OOM</p></li>
</ul></li>
<li><p>CachedThreadPool
CachedThreadPool是一个会根据需要创建新线程的线程池，源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//其他构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<p><code>CachedThreadPool</code> 的<code>corePoolSize</code>
被设置为空（0），<code>maximumPoolSize</code>被设置为
<code>Integer.MAX.VALUE</code>，即它是无界的，这也就意味着如果主线程提交任务的速度高于
<code>maximumPool</code>
中线程处理任务的速度时，<code>CachedThreadPool</code>
会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源</p>
<p>★：SynchronousQueue队列只能容纳单个元素
执行过程（execute()示意图）</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221128163237634.png"
alt="image-20221128163237634" /> 上图说明：</p>
<ol type="1">
<li>首先执行 <code>SynchronousQueue.offer(Runnable task)</code>
提交任务到任务队列。如果当前 <code>maximumPool</code> 中有闲线程正在执行
<code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>，那么主线程执行
offer 操作与空闲线程执行的 <code>poll</code>
操作配对成功，主线程把任务交给空闲线程执行，<code>execute()</code>方法执行完成，否则执行下面的步骤
2；</li>
<li>当初始 <code>maximumPool</code> 为空，或者 <code>maximumPool</code>
中没有空闲线程时，将没有线程执行
<code>SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)</code>。这种情况下，步骤
1 将失败，此时 <code>CachedThreadPool</code>
会创建新线程执行任务，execute 方法执行完成；</li>
</ol>
<p>不推荐使用CachedThreadPool?
因为它允许创建的线程数量为Integer.MAX_VALUE,可能创建大量线程，从而导致OOM</p></li>
</ol>
<h2
id="scheduledthreadpoolexecutor详解">ScheduledThreadPoolExecutor详解</h2>
<p>项目中基本不会用到，主要用来在给定的延迟后运行任务，或者定期执行任务
它使用的<strong>任务队列DelayQueue封装了一个PriorityQueue</strong>，PriorityQueue会<strong>对队列中的任务进行排序</strong>，执行<strong>所需时间（第一次执行的时间）短</strong>的放在前面先被执行(<strong>ScheduledFutureTask的time</strong>变量小的先执行)，如果一致则先提交的先执行(<strong>ScheduleFutureTask的sequenceNumber变量</strong>)</p>
<ul>
<li><p>ScheduleFutureTask</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 其中, triggerTime(initialDelay, unit) 的结果即上面说的time，说的应该是第一次执行的时间，而不是整个任务的执行时间</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException   &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                 <span class="type">long</span> initialDelay,</span><br><span class="line">                                                 <span class="type">long</span> period,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="literal">null</span> || unit == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">       <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">       ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">ScheduledFutureTask</span>&lt;Void&gt;(command,</span><br><span class="line">                                         <span class="literal">null</span>,</span><br><span class="line">                                         triggerTime(initialDelay, unit),</span><br><span class="line">                                         unit.toNanos(period));</span><br><span class="line">       RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">       sft.outerTask = t;</span><br><span class="line">       delayedExecute(t);</span><br><span class="line">       <span class="keyword">return</span> t;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代码，TimerTask</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTimerTask</span> <span class="keyword">extends</span> <span class="title class_">TimerTask</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerTaskTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.set(Calendar.HOUR_OF_DAY, <span class="number">17</span>);<span class="comment">//控制小时</span></span><br><span class="line">        calendar.set(Calendar.MINUTE, <span class="number">1</span>);<span class="comment">//控制分钟</span></span><br><span class="line">        calendar.set(Calendar.SECOND, <span class="number">0</span>);<span class="comment">//控制秒</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();<span class="comment">//执行任务时间为17:01:00</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//每天定时17:02执行操作，每5秒执行一次</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">MyTimerTask</span>(), time, <span class="number">5000</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代码，ScheduleThreadPoolExecutor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleTask</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">5</span>, TimeUnit.SECONDS);<span class="comment">//10表示首次执行任务的延迟时间，5表示每次执行任务的间隔时间，Thread.sleep(10000);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Shutting down executor...&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//线程池一关闭，定时器就不会再执行</span></span><br><span class="line">        scheduledExecutorService.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果</span></span><br><span class="line"><span class="comment">Shutting down executor...</span></span><br><span class="line"><span class="comment">2022-11-28 17:25:06 下午 [Thread: pool-1-thread-1] </span></span><br><span class="line"><span class="comment">INFO:hello world!</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">不会再执行定时任务，因为线程池已经关了*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>ScheduleThreadPoolExecutor和Timer的比较 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221129092155589.png"
alt="image-20221129092155589" /><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221129092022551.png"
alt="image-20221129092022551" /></p>
<ul>
<li><p>Timer对系统时钟变化敏感，ScheduledThreadPoolExecutor不是</p>
<p>Timer使用的是<strong>System.currentTime()</strong>，而ScheduledThreadPoolExecutor使用的是<strong>System.nanoTime()</strong></p></li>
<li><p>Timer只有一个线程（导致长时间运行的任务延迟其他任务），ScheduleThreadPoolExecutor可以配置任意数量线程</p></li>
<li><p>TimerTask中抛出运行时异常会杀死一个线程，从而导致Timer死机（即计划任务将不在运行）；而<strong>ScheduleThreadExecutor</strong>不仅<strong>捕获运行时异常</strong>，还允许<strong>需要时处理（afterExecute方法）</strong>，抛出异常的任务会被取消而<strong>其他任务将继续运行</strong></p></li>
</ul>
<p>JDK1.5 之后，没有理由再使用Timer进行任务调度</p></li>
<li><p>运行机制 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221129103700454.png"
alt="image-20221129103700454" />
ScheduledThreadPoolExecutor的执行分为：</p>
<ol type="1">
<li>当调用scheduleAtFixedRate()或scheduleWithFixedDelay()方法时，会向ScheduleThreadPoolExector的DelayQueue添加一个<strong>实现了RunnableScheduleFuture接口的ScheduleFutureTask(私有内部类)</strong></li>
<li>线程池中的线程<strong>从DelayQueue中获取ScheduleFutureTask</strong>，然后执行任务</li>
</ol>
<p>为了执行周期性任务，对ThreadPoolExecutor做了如下修改：</p>
<ul>
<li>使用DelayQueue作为任务队列</li>
<li>获取任务的方式不同</li>
<li>获取周期任务<strong>后做了额外处理</strong></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221129104234412.png"
alt="image-20221129104234412" />
获取任务，执行任务，修改任务(time)，回放任务</p>
<blockquote>
<ol type="1">
<li>线程 1 从 <code>DelayQueue</code> 中获取已到期的
<code>ScheduledFutureTask（DelayQueue.take()）</code>。到期任务是指
<code>ScheduledFutureTask</code>的 time 大于等于当前系统的时间；</li>
<li>线程 1 执行这个 <code>ScheduledFutureTask</code>；</li>
<li>线程 1 修改 <code>ScheduledFutureTask</code> 的 time
变量为下次将要被执行的时间；</li>
<li>线程 1 把这个修改 time 之后的 <code>ScheduledFutureTask</code> 放回
<code>DelayQueue</code> 中（<code>DelayQueue.add()</code>)。</li>
</ol>
</blockquote></li>
</ul>
<h2 id="线程池大小确定">线程池大小确定</h2>
<ul>
<li><p>如果线程池中的线程太多，就会增加<strong>上下文切换</strong>的成本</p>
<blockquote>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU
核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU
采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完
CPU
时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，<strong>上下文切换对系统来说意味着消耗大量的
CPU 时间</strong>，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p><strong>Linux</strong> 相比与其他操作系统（包括其他类 Unix
系统）有很多的优点，其中有一项就是，其<strong>上下文切换和模式切换的时间消耗非常少</strong>。</p>
</blockquote></li>
<li><p>过大跟过小都不行</p>
<ul>
<li>如果我们设置的<strong>线程池数量太小</strong>的话，如果同一时间有大量任务/请求需要处理，可能会导致大<strong>量的请求/任务在任务队列中排队等待执行</strong>，甚至会出现<strong>任务队列满了</strong>之后任务/请求<strong>无法处理</strong>的情况，或者大量任<strong>务堆积在任务队列导致
OOM</strong></li>
<li>设置线程<strong>数量太大</strong>，<strong>大量线程可能会同时在争取
CPU
资源</strong>，这样会导致<strong>大量的上下文切换</strong>，从而<strong>增加线程的执行时间</strong>，影响了整体执行效率</li>
</ul></li>
<li><p>简单且适用面较广的公式</p>
<ul>
<li><p><strong>CPU 密集型任务(N+1)：</strong>
这种<strong>任务消耗的主要是 CPU 资源</strong>，可以将线程数设置为
N（CPU 核心数）+1，比 CPU
核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU
就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU
的空闲时间。</p></li>
<li><p><strong>I/O 密集型任务(2N)：</strong>
这种任务应用起来，系统会用<strong>大部分的时间来处理 I/O
交互</strong>，而<strong>线程在处理 I/O 的时间段内不会占用 CPU
来处理</strong>，这时就可以将 CPU 交出给其它线程使用。因此<strong>在 I/O
密集型任务的应用中，我们可以多配置一些线程</strong>，具体的计算方法是
2N。</p></li>
<li><blockquote>
<p>如何判断是CPU密集任务还是IO密集任务</p>
<p>CPU 密集型简单理解就是利用 CPU
计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是
IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO
操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
</blockquote></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存模型</title>
    <url>/2022/11/21/review/java_guide/java/concurrent/jmm/</url>
    <content><![CDATA[<blockquote>
<p>引用自https://github.com/Snailclimb/JavaGuide</p>
</blockquote>
<h2 id="从cpu缓存模型说起">从CPU缓存模型说起</h2>
<ul>
<li><p>redis是为了解决<strong>程序处理速度和访问常规关系型数据库速度不对等</strong>的问题，<strong>CPU缓存则是为了解决CPU处理速度和内存处理速度不对等的问题</strong></p></li>
<li><p>把内存看作外存的高速缓存，程序运行时把外存的数据复制到内存，由于<strong>内存的处理速度远高于外存</strong>，这样提高了处理速度</p></li>
<li><p>总结，<strong>CPU
Cache缓存的是内存数据</strong>，用于解决<strong>CPU处理速度和内存不匹配</strong>的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题
CPU Cache示意图：</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221121161418654.png"
alt="image-20221121161418654" /> CPU Cache通常分为三层，分别叫L1，L2，L3
Cache 工作方式：
<strong>先复制一份数据到CPUCache中，当CPU需要用的时候就可以从CPUCache中读取数据，运算完成后，将运算得到的数据，写回MainMemory中</strong>，此时，会出现<strong>内存缓存不一致的问题</strong>，例子：执行了i++，如果两个线程同时执行，假设两个线程从CPUCach中读取的i=1，两个线程做了1++运算完之后再写回MainMemory，此时i=2
而正确结果为3</p></li>
<li><p>CPU为了解决内存缓存不一致问题，可以通过制定<strong>缓存一致协议（比如MESI协议）或其他手段</strong>。这个<strong>缓存一致协议</strong>，指的是在
<strong>CPU 高速缓存与主内存交互的时候需要遵守的原则和规范</strong> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221121163447850.png"
alt="image-20221121163447850" />
操作系统，通过<strong>内存模型MemoryModel</strong>定义一系列规范来解决这个问题</p></li>
</ul>
<h2 id="指令重排序">指令重排序</h2>
<ul>
<li><p><strong>什么是指令重排序？</strong>
简单来说就是系统在<strong>执行代码的时候并不一定是按照你写的代码的顺序</strong>依次执行</p></li>
<li><p>指令重排有下面2种</p>
<ul>
<li><strong>编译器优化重排</strong>：编译器（包括 JVM、JIT
编译器等）在不改变<strong>单线程程序语义</strong>的前提下，重新安排语句的执行顺序。</li>
<li><strong>指令并行重排</strong>：现代处理器采用了<strong>指令级并行技术(Instruction-Level
Parallelism，ILP)来将多条指令重叠执行</strong>。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序</li>
<li><strong>内存系统</strong>也会有“重排序”，在JMM表现为主存和本地内存可能不一致</li>
</ul>
<p>即Java源代码会经历
<strong>编译器优化重排</strong>---&gt;<strong>指令并行重排</strong>---&gt;<strong>内存系统重排</strong>，最终编程操作系统可执行的<strong>指令序列</strong></p>
<p>极其重要★：指令重排序可以<strong>保证串行语义一致</strong>，但是<strong>没有义务保证多线程间的语义也一致</strong>，所以在多线程下指令重排可能导致一些问题</p>
<blockquote>
<p>编译器和处理器的指令重排序的处理方式不一样。对于<strong>编译器</strong>，通过<strong>禁止特定类型的编译器重排序</strong>的方式来禁止重排序。对于<strong>处理器</strong>，通过<strong>插入内存屏障（Memory
Barrier，或有时叫做内存栅栏，Memory
Fence）</strong>的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序。</p>
<p>内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种
CPU
指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障指令执行的有序性。另外，为了达到屏障的效果，它也会使<strong>处理器写入、读取值之前</strong>，将<strong>主内存的值写入高速缓存</strong>，<strong>清空无效队列</strong>，从而保障变量的可见性。</p>
</blockquote></li>
</ul>
<h2 id="jmmjavamemorymode">JMM（JavaMemoryMode）</h2>
<h3 id="什么是-jmm为什么需要-jmm">什么是 JMM？为什么需要 JMM？</h3>
<blockquote>
<p>一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。<strong>Java
语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</strong></p>
</blockquote>
<p>实际上，对于Java来说，可以<strong>把JMM看作是Java定义的并发编程相关的一组规范</strong>，除了抽象了线程和主内存之间的关系之外，还规定了<strong>从Java源代码到CPU可执行指令的转化过程</strong>要遵守哪些和并发相关的原则和规范，主要目的是为了<strong>简化多线程编程</strong>，<strong>增强程序可移植性</strong>。</p>
<p>为什么要遵守这些并发相关的原则和规范呢？因为在并发编程下，CPU多级缓存和指令重排这类设计会导致程序运行出问题，比如<strong>指令重排</strong>，为此JMM抽象了<strong>happens-before</strong>原则</p>
<blockquote>
<p>JMM
说白了就是定义了一些规范来解决这些问题，开发者可以利用这些规范更方便地开发多线程程序。对于
Java
开发者说，你不需要了解底层原理，直接使用并发相关的一些关键字和类（比如
<code>volatile</code>、<code>synchronized</code>、各种
<code>Lock</code>）即可开发出并发安全的程序。</p>
</blockquote>
<h3 id="jmm-是如何抽象线程和主内存之间的关系">JMM
是如何抽象线程和主内存之间的关系？</h3>
<p><strong>Java内存模型(JMM)</strong>，抽象了<strong>线程和主内存之间的关系</strong>，比如线程之间的<strong>共享变量必须存储在主内存</strong>中</p>
<blockquote>
<p>JDK1.2之前，Java内存模型总是从主存(共享内存)读取变量；而当前的Java内存模型下，线程可以把变量保存<strong>本地内存（机器的寄存器）</strong>中，而<strong>不直接在主存中读写</strong>。这可能造成，一个线程在主存中修改了一个变量的值，而在另一个线程继续使用它<strong>在寄存器中</strong>的变量值的拷贝，造成数据不一致</p>
<p>上面所述跟CPU缓存模型非常相似</p>
</blockquote>
<p>什么是主内存？什么是本地内存？</p>
<p><strong>主内存</strong>：所有<strong>线程创建的实例对象都存放在主内存中</strong>（感觉这里说的是堆？），不管该实例对象是<strong>成员变量</strong>还是方法中的<strong>本地变量</strong>（也称局部变量）<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221122143524756.png"
alt="image-20221122143524756" /> 如上，若线程1和线程2之间要通信，则</p>
<ol type="1">
<li><strong>线程1把本地内存中修改过的共享变量副本的值，同步到主内存中</strong></li>
<li><strong>线程2到主存中，读取对应的共享变量的值</strong></li>
</ol>
<p>即，JMM为共享变量提供了可见性的保障</p>
<blockquote>
<p>多线程下，主内存中一个共享变量进行操作引发的线程安全问题：</p>
<ol type="1">
<li>线程1、2分别对同一个共享变量操作，一个执行修改，一个执行读取</li>
<li>线程2读取到的是线程1修改之前的还是修改之后的值，不确定</li>
</ol>
</blockquote>
<p>主内存和工作内存<strong>直接的具体交互协议</strong>，即一个变量，如何从主内存拷贝到工作内存，如何从工作内存同步到主内存，JMM定义八种同步操作：</p>
<blockquote>
<p><strong>锁定（lock）</strong>:
作用于主内存中的变量，将他标记为一个线程独享变量。</p>
<p><strong>解锁（unlock）</strong>:
作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。</p>
<p><strong>read（读取）</strong>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的
load 动作使用。</p>
<p><strong>load(载入)</strong>：把 read
操作从主内存中得到的变量值放入工作内存的变量的副本中。</p>
<p><strong>use(使用)</strong>：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</p>
<p><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p>
<p><strong>store（存储）</strong>：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的
write 操作使用。</p>
<p><strong>write（写入）</strong>：作用于主内存的变量，它把 store
操作从工作内存中得到的变量的值放入主内存的变量中</p>
<p>下面的同步规则，保证这些同步操作的正确执行：</p>
<ul>
<li><p>不允许一个线程无原因地（没有发生过任何 assign
操作）把数据从线程的工作内存同步回主内存中。</p></li>
<li><p>一个新的变量只能在主内存中
“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或
assign）的变量，换句话说就是对一个变量实施 use 和 store
操作之前，必须先执行过了 assign 和 load 操作。</p></li>
<li><p>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock
操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的
unlock 操作，变量才会被解锁。</p></li>
<li><p>如果对一个变量执行 lock
操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行
load 或 <a
href="..........\themes\next\source\css\main.styl">main.styl</a> assign
操作初始化变量的值。</p></li>
<li><p>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock
操作，也不允许去 unlock 一个被其他线程锁定住的变量。</p>
<p>......</p></li>
</ul>
</blockquote>
<h3 id="java-内存区域和-jmm-有何区别">Java 内存区域和 JMM
有何区别？</h3>
<ul>
<li>JVM 内存结构和 <strong>Java 虚拟机的运行时区域</strong>相关，定义了
JVM
在运<strong>行时如何分区存储程序数据</strong>，就比如说堆主要用于存放对象实例。</li>
<li>Java 内存模型和 <strong>Java
的并发编程</strong>相关，<strong>抽象了线程和主内存之间的关系</strong>就比如说线程之间的共享变量必须存储在主内存中，规定了从
<strong>Java 源代码到 CPU
可执行指令的这个转化过程</strong>要遵守哪些<strong>和并发相关的原则和规范</strong>，其主要目的是为了<strong>简化多线程编程</strong>，增强程序可移植性的。</li>
</ul>
<h3 id="happens-before-原则是什么">happens-before 原则是什么？</h3>
<ul>
<li><p>逻辑时钟：对分布式系统中的事件的先后关系进行判断</p></li>
<li><p>JSR
133引入happens-before这个概念来描述<strong>两个操作之间的内存可见性</strong></p></li>
<li><p><strong>为什么需要 happens-before 原则？</strong> happens-before
原则的诞生是为了程序员和编译器、处理器之间的平衡。<strong>程序员</strong>追求的是<strong>易于理解和编程的强内存模型</strong>，遵守既定规则编码即可。<strong>编译器和处理器</strong>追求的是<strong>较少约束的弱内存模型</strong>，让它们尽己所能地去优化性能，让性能最大化。</p></li>
<li><p>happens-before原则的<strong>设计思想</strong></p>
<ul>
<li>为了对编译器和处理器的约束尽可能少，<strong>只要不改变程序</strong>的执行结果（单线程程序和正确执行的多线程程序），<strong>编译器和处理器怎么进行重排序优化都行</strong>。</li>
<li>对于<strong>会改变</strong>程序执行结果的重排序，<strong>JMM
要求编译器和处理器必须禁止这种重排序</strong>。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221122155046471.png"
alt="image-20221122155046471" />
<figcaption aria-hidden="true">image-20221122155046471</figcaption>
</figure>
<p>JSR-133对happens-before原则的定义：</p>
<ul>
<li>如果<strong>一个操作happens-before另一个操作</strong>，那么<strong>第一个操作的执行结果将对第二个操作可见</strong>，并且<strong>第一个操作的执行顺序排在第二个操作之前</strong></li>
</ul>
<blockquote>
<p>这是 JMM 对程序员强内存模型的承诺。从程序员的角度来说，可以这样理解
Happens-before 关系：如果 A Happens-before B，那么 JMM 将向程序员保证 —
A 操作的结果将对 B 可见，且 A 的执行顺序排在 B 之前。注意，这只是
Java内存模型向程序员做出的保证，即Happens-before提供<strong>跨线程的内存可见性保证</strong></p>
<p>对于这条定义，举个例子（不代表代码就是这样的，这是一个概括性的假设情况）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下操作在线程 A 中执行</span></span><br><span class="line">i = <span class="number">1</span>; <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作在线程 B 中执行</span></span><br><span class="line">j = i; <span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下操作在线程 C 中执行</span></span><br><span class="line">i = <span class="number">2</span>; <span class="comment">// c</span></span><br></pre></td></tr></table></figure>
<p>假设线程 A 中的操作 a Happens-before 线程 B 的操作
b，那我们就可以确定操作 b 执行后，变量 j 的值一定是等于 1。</p>
<p>得出这个结论的依据有两个：一是根据 Happens-before 原则，a
操作的结果对 b 可见，即 “i=1” 的结果可以被观察到；二是线程 C
还没运行，线程 A 操作结束之后没有其他线程会修改变量 i 的值。</p>
<p>现在再来考虑线程 C，我们依然保持 a Happens-before b ，而 c 出现在 a
和 b 的操作之间，但是 c 与 b 没有 Happens-before 关系，也就是说 b
并不一定能看到 c 的操作结果。那么 b 操作的结果也就是 j
的值就不确定了，可能是 1 也可能是 2，那这段代码就是线程不安全的。</p>
</blockquote>
<ul>
<li>两个操作之间存在 happens-before 关系，并不意味着 Java
平台的具体实现必须要按照 happens-before
关系指定的顺序来执行。如果<strong>重排序之后的执行结果，与按
happens-before 关系来执行的结果一致，那么 JMM
也允许这样的重排序</strong></li>
</ul>
<blockquote>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">userNum</span> <span class="operator">=</span> getUserNum(); 	<span class="comment">// 1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">teacherNum</span> <span class="operator">=</span> getTeacherNum();	 <span class="comment">// 2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">totalNum</span> <span class="operator">=</span> userNum + teacherNum;	<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>如上，1 happens-before 2，2 happens-before 3，1 happens-before 3</p>
<p>虽然 1 happens-before 2，但对 1 和 2
进行重排序不会影响代码的执行结果，所以 JMM
是允许编译器和处理器执行这种重排序的。但 1 和 2 必须是在 3
执行之前，也就是说 1,2 happens-before 3 。</p>
<p><strong>happens-before
原则表达的意义其实并不是一个操作发生在另外一个操作的前面，虽然这从程序员的角度上来说也并无大碍。更准确地来说，它更想表达的意义是前一个操作的结果对于后一个操作是可见的，无论这两个操作是否在同一个线程里。</strong></p>
<p>举个例子：操作 1 happens-before 操作 2，即使操作 1 和操作 2
不在同一个线程内，JMM 也会保证操作 1 的结果对操作 2 是可见的。</p>
</blockquote></li>
</ul>
<h3 id="happens-before-常见规则有哪些谈谈你的理解">happens-before
常见规则有哪些？谈谈你的理解？</h3>
<p>主要的5条规则：</p>
<ol type="1">
<li>程序顺序规则：<strong>一个线程内</strong>，按照代码顺序，书写在前面的操作happens-before于书写在后面的操作</li>
<li>解锁规则：解锁happens-before于加锁</li>
<li>volatile变量规则：<strong>对一个 volatile 变量的写操作
happens-before 于后面对这个 volatile 变量的读操作</strong>。说白了就是对
volatile
变量的<strong>写操作的结果</strong>对于<strong>发生于其后的任何操作都是可见</strong>的。</li>
<li>传递规则：如果A happens-before B，且B happens-before C ，那么A
happens-before C</li>
<li>线程启动规则：Thread对象的start() 方法 happens-before
于此线程的每一个操作</li>
</ol>
<p>如果两个操作，不满足于上述任何一个happens-before规则，那么这两个操作就没有顺序的保障，<strong>JVM可以对这两个操作进行重排序</strong></p>
<h3 id="happens-before-和jmm什么关系">happens-before 和JMM什么关系</h3>
<ol type="1">
<li><p>根据happens-before规则，告诉程序员，有哪些happens-before规则（哪些情况不会被重排序）</p>
<blockquote>
<p>为了避免 Java 程序员为了理解 JMM
提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法，JMM
就出了这么一个简单易懂的 Happens-before 原则，<strong>一个
Happens-before
规则就对应于一个或多个编译器和处理器的重排序规则</strong></p>
</blockquote></li>
<li><ul>
<li>as-if-serial 语义保证单线程内程序的执行结果不被改变，Happens-before
关系保证正确同步的多线程程序的执行结果不被改变。</li>
<li>as-if-serial
语义给编写单线程程序的程序员创造了一个幻境：<strong>单线程程序是按程序的顺序来执行的。Happens-before
关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按
Happens-before 指定的顺序来执行的。</strong></li>
</ul></li>
<li><p>JMM定义的</p></li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221123111533905.png"
alt="image-20221123111533905" />
<figcaption aria-hidden="true">image-20221123111533905</figcaption>
</figure>
<h2 id="再看并发编程三个重要特性">再看并发编程三个重要特性</h2>
<p>原子性，可见性，有序性</p>
<ul>
<li><p>原子性
一次操作或多次操作，<strong>要么所有的操作，全部都得到执行</strong>并且不会受到任何因素的干扰而中断，<strong>要么都不执行</strong></p>
<blockquote>
<p>Java中，使用synchronized、各种Lock以及各种原子类实现原子性(AtomicInteger等)</p>
<p><code>synchronized</code> 和各种 <code>Lock</code>
可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性。各种原子类是利用
CAS (compare and swap) 操作（可能也会用到
<code>volatile</code>或者<code>final</code>关键字）来保证原子操作。</p>
</blockquote></li>
<li><p>可见性
当<strong>一个线程对共享变量进行了修改</strong>，那么<strong>另外的线程</strong>都是<strong>立即可以看到</strong>修改后的最新值。</p>
<blockquote>
<p>在 Java 中，可以借助<code>synchronized</code> 、<code>volatile</code>
以及各种 <code>Lock</code> 实现可见性。</p>
<p>如果我们将变量声明为 <code>volatile</code> ，这就指示
JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
</blockquote></li>
<li><p>有序性
由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序</p>
<blockquote>
<p><strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>
，所以在多线程下，指令重排序可能会导致一些问题。</p>
<p>Java中，volatile关键字可以禁止指令进行重排序优化（注意，synchronized也可以）</p>
</blockquote></li>
</ul>
<h2 id="总结">总结</h2>
<p>补充：线程join()方法，导致调用线程暂停，直到xx.join()中的xx线程执行完，调用join方法的线程才继续执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;暂停5s&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;暂停3s&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        log.info(<span class="string">&quot;主线程执行&quot;</span>);</span><br><span class="line"><span class="comment">/*结果</span></span><br><span class="line"><span class="comment">2022-11-23 13:57:06 下午 [Thread: Thread-1] </span></span><br><span class="line"><span class="comment">INFO:暂停5s</span></span><br><span class="line"><span class="comment">2022-11-23 13:57:06 下午 [Thread: Thread-2] </span></span><br><span class="line"><span class="comment">INFO:暂停3s</span></span><br><span class="line"><span class="comment">2022-11-23 13:57:11 下午 [Thread: main] </span></span><br><span class="line"><span class="comment">INFO:主线程执行</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>指令重排的影响，举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            x = <span class="number">0</span>; y = <span class="number">0</span>;</span><br><span class="line">            a = <span class="number">0</span>; b = <span class="number">0</span>;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                x = b;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">other</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">                y = a;</span><br><span class="line">            &#125;);</span><br><span class="line">            one.start(); other.start();;</span><br><span class="line">            one.join(); other.join();</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次（&quot;</span> + x + <span class="string">&quot;, &quot;</span> + y + <span class="string">&quot;）&quot;</span>;</span><br><span class="line">                System.out.println(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因为线程one中，a和x并不存在依赖关系，因此可能会先执行x=b;而这个时候，b=0。因此x会被赋值为0，而a=1这条语句还没有被执行的时候，线程other先执行了y=a这条语句，这个时候a还是a=0;因此y被赋值为了0。所以存在情况x=0;y=0。这就是指令重排导致的多线程问题。</span></span><br><span class="line"><span class="comment">原文链接：https://blog.csdn.net/qq_45948401/article/details/124973903</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Java
是最早尝试提供内存模型的语言，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>
<li>CPU 可以通过制定缓存一致协议（比如 <a
href="https://zh.wikipedia.org/wiki/MESI协议">MESI 协议open in new
window</a>）来解决内存缓存不一致性问题。</li>
<li>为了提升执行速度/性能，计算机在执行程序代码的时候，会对指令进行重排序。
简单来说就是系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行。<strong>指令重排序可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>
，所以在多线程下，指令重排序可能会导致一些问题。</li>
<li>你可以把 JMM 看作是 Java
定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从
Java 源代码到 CPU
可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。</li>
<li>JSR 133 引入了 happens-before
这个概念来描述两个操作之间的内存可见性。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>锁升级</title>
    <url>/2022/11/06/review/java_guide/java/concurrent/lock_escalation/</url>
    <content><![CDATA[<blockquote>
<p>以下内容均转自
https://www.cnblogs.com/wuqinglong/p/9945618.html，部分疑惑参考自另一作者
https://github.com/farmerjohngit/myblog/issues/12 ，感谢原作者。</p>
</blockquote>
<h2 id="概述">概述</h2>
<p>传统的synchronized为重量级锁，但是随着JavaSE1.6对synchronized优化后，部分情况下他就没有那么重了。本文介绍了JavaSE1.6为了减少获得锁和释放锁带来的性能消耗而引入的<strong>偏向锁</strong>和<strong>轻量级锁</strong>，以及<strong>锁结构</strong>、及<strong>锁升级</strong>过程</p>
<h2 id="实现同步的基础">实现同步的基础</h2>
<p>Java中每个对象都可以作为锁，具体变现形式</p>
<ol type="1">
<li>对于普通同步方法，锁是当前实例对象</li>
<li>对于静态同步方法，锁是当前类的Class对象</li>
<li>对于同步方法块，锁是synchronized括号里配置的对象</li>
</ol>
<p>一个线程试图访问同步代码块时，必须获取锁；在退出或者抛出异常时，必须释放锁</p>
<h2 id="实现方式">实现方式</h2>
<p>JVM 基于<strong>进入和退出 Monitor
对象</strong>来实现<strong>方法同步</strong>和<strong>代码块同步</strong>，但是两者的<strong>实现细节不一样</strong></p>
<ol type="1">
<li><strong>代码块同步</strong>：通过使用 <strong>monitorenter</strong>
和 <strong>monitorexit</strong> 指令实现的</li>
<li>同步方法：<strong>ACC_SYNCHRONIZED</strong> 修饰</li>
</ol>
<p>monitorenter
指令是在<strong>编译后插入到同步代码块的开始位置</strong>，而
monitorexit
指令是在<strong>编译后插入到同步代码块的结束处或异常处</strong></p>
<p>对于同步方法，<strong>进入方法前</strong>添加一个 monitorenter
指令，<strong>退出方法后</strong>添加一个 monitorexit 指令。</p>
<p>demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Demo.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后的字节码（使用 javap )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// class me/snail/base/Demo</span></span><br><span class="line">       <span class="number">2</span>: dup</span><br><span class="line">       <span class="number">3</span>: astore_1</span><br><span class="line">       <span class="number">4</span>: monitorenter</span><br><span class="line">       <span class="number">5</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">8</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String Hello World.</span></span><br><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">13</span>: aload_1</span><br><span class="line">      <span class="number">14</span>: monitorexit</span><br><span class="line">      <span class="number">15</span>: goto          <span class="number">23</span></span><br><span class="line">      <span class="number">18</span>: astore_2</span><br><span class="line">      <span class="number">19</span>: aload_1</span><br><span class="line">      <span class="number">20</span>: monitorexit</span><br><span class="line">      <span class="number">21</span>: aload_2</span><br><span class="line">      <span class="number">22</span>: athrow</span><br><span class="line">      <span class="number">23</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">5</span>    <span class="number">15</span>    <span class="number">18</span>   any</span><br><span class="line">          <span class="number">18</span>    <span class="number">21</span>    <span class="number">18</span>   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">7</span>: <span class="number">5</span></span><br><span class="line">      line <span class="number">8</span>: <span class="number">13</span></span><br><span class="line">      line <span class="number">9</span>: <span class="number">23</span></span><br><span class="line">    StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">      frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">        offset_delta = <span class="number">18</span></span><br><span class="line">        locals = [ <span class="keyword">class</span> <span class="title class_">me</span>/snail/base/Demo, <span class="keyword">class</span> <span class="title class_">java</span>/lang/Object ]</span><br><span class="line">        stack = [ <span class="keyword">class</span> <span class="title class_">java</span>/lang/Throwable ]</span><br><span class="line">      frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">        offset_delta = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">3</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String Hello World.</span></span><br><span class="line">       <span class="number">5</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">13</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>先说 <strong>f1() 方法</strong>，发现其中<strong>一个 monitorenter
对应了两个 monitorexit</strong>，这是不对的。<strong>但是</strong>仔细看
#15: goto 语句，直接跳转到了 #23: return 处，再看 #22: athrow
语句发现，原来<strong>第二个 monitorexit</strong>
是<strong>保证同步代码块抛出异常</strong>时锁能<strong>得到正确的释放</strong>而存在的，这就理解了。</p>
<h2 id="java对象头存储锁类型">Java对象头（存储锁类型）</h2>
<p>HotSpot虚拟机中，对象在内存中的布局分为三块区域：<strong>对象头</strong>、<strong>实例数据</strong>、<strong>对齐填充</strong></p>
<p>对象头又包括两部分：<strong>MarkWord</strong>和<strong>类型指针</strong>，对于<strong>数组对象</strong>，对象头中还有一部分时存储<strong>数组的长度</strong></p>
<p><strong>多线程下synchronized的加锁，就是对同一个对象的对象头中的MarkWord中的变量进行CAS操作</strong></p>
<ol type="1">
<li><p>MarkWord</p></li>
<li><p>类型指针 虚拟机通过这个指针确定该对象是哪个类的实例</p></li>
<li><p>对象头的长度</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">长度</th>
<th style="text-align: left;"><strong>内容</strong></th>
<th style="text-align: left;"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">32/64bit</td>
<td style="text-align: left;">MarkWord</td>
<td style="text-align: left;">存储对象的hashCode或锁信息等</td>
</tr>
<tr class="even">
<td style="text-align: left;">32/64bit</td>
<td style="text-align: left;">Class Metadada Address</td>
<td style="text-align: left;">存储对象类型数据的指针</td>
</tr>
<tr class="odd">
<td style="text-align: left;">32/64bit</td>
<td style="text-align: left;">Array Length</td>
<td style="text-align: left;">数组的长度(如果当前对象是数组)</td>
</tr>
</tbody>
</table>
<p>如果是数组对象的话，虚拟机用3个字宽(32/64bit + 32/64bit +
32/64bit)存储对象头，如果是普通对象的话，虚拟机用2字宽存储对象头(32/64bit
+ 32/64bit)。</p></li>
</ol>
<h2 id="优化后synchronized锁的分类">优化后synchronized锁的分类</h2>
<p>级别从低到高依次是：无锁状态 -&gt; 偏向锁状态 -&gt; 轻量级锁状态
-&gt; 重量级锁状态</p>
<p>锁可以升级，但不能降级，即顺序为单向</p>
<p>下面以32位系统为例，每个锁状态下，每个字宽中的内容</p>
<ol type="1">
<li><p>无锁状态</p>
<table>
<thead>
<tr class="header">
<th>25bit</th>
<th>4bit</th>
<th>1bit(是否是偏向锁)</th>
<th>2bit(锁标志位)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>对象的hashCode</td>
<td>对象分代年龄</td>
<td>0</td>
<td>01</td>
</tr>
</tbody>
</table>
<p>这里的 hashCode 是 <strong>Object#hashCode</strong> 或者
<strong>System#identityHashCode</strong>
计算出来的值，不是用户覆盖产生的 hashCode。</p></li>
<li><p>偏向锁状态</p>
<table>
<thead>
<tr class="header">
<th>25bit</th>
<th>4bit</th>
<th>1bit(是否是偏向锁)</th>
<th>2bit(锁标志位)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>线程ID</td>
<td>epoch</td>
<td>1</td>
<td>01</td>
</tr>
</tbody>
</table>
<p>这里 <strong>线程ID 和 epoch 占用了 hashCode</strong>
的位置，所以，如果对象如果<strong>计算过 identityHashCode</strong>
后，便<strong>无法进入偏向锁</strong>状态，反过来，如果对象<strong>处于偏向锁状态</strong>，并且<strong>需要计算其
identityHashCode</strong>
的话，则偏向锁会被撤销，<strong>升级为重量级锁</strong>。
对于偏向锁，如果线程ID=0 表示为加锁</p>
<blockquote>
<p>什么时候会计算 HashCode 呢？比如：<strong>将对象作为 Map 的 Key
时会自动触发计算</strong>，List
就不会计算，日常创建一个对象，持久化到库里，进行 json
序列化，或者作为临时对象等，这些情况下，并不会触发计算
hashCode，所以大部分情况不会触发计算 hashCode。</p>
</blockquote>
<p>Identity hash code是未被覆写的 java.lang.Object.hashCode() 或者
java.lang.System.identityHashCode(Object) 所返回的值。</p></li>
<li><p>轻量级锁状态</p>
<table>
<thead>
<tr class="header">
<th>30bit</th>
<th><strong>2bit</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>指向线程栈锁记录的指针</td>
<td>00</td>
</tr>
</tbody>
</table>
<p>这里指向栈帧中的LockRecord记录，里面当然可以记录对象的identityHashCode</p></li>
<li><p>重量级锁状态</p>
<table>
<thead>
<tr class="header">
<th>30bit</th>
<th>2bit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>指向锁监视器的指针</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>这里指向了<strong>内存中对象的 ObjectMonitor</strong> 对象，而
<strong>ObectMontitor</strong> 对象可以<strong>存储对象的
identityHashCode</strong> 的值。</p></li>
</ol>
<h2 id="锁的升级">锁的升级</h2>
<h3 id="偏向锁">偏向锁</h3>
<p>偏向锁是<strong>针对于一个线程</strong>而言的，线程获得锁之后就不会再有解锁等操作了，这样可以<strong>省略很多开销</strong>。<strong>假如有两个线程来竞争该锁话，那么偏向锁就失效了，进而升级成轻量级锁</strong>了【注意这段解释，网上很多都错了，没有什么CAS失败才升级，只要有线程来抢，就直接升级为轻量级锁】</p>
<blockquote>
<p><em>为什么要这样做呢？因为经验表明，其实大部分情况下，都会是同一个线程进入同一块同步代码块的。这也是为什么会有偏向锁出现的原因。</em></p>
</blockquote>
<p>如果支持偏向锁（没有计算
hashCode），那么在分配(创建)对象时，分配一个可偏向而未偏向的对象（MarkWord的最后
3 位为 101，并且 Thread Id 字段的值为 0）</p>
<h4 id="偏向锁的加锁">1. 偏向锁的加锁</h4>
<ul>
<li><p>偏向锁标志是<strong>未偏向状态</strong>，使用 <strong>CAS 将
MarkWord 中的线程ID</strong>设置为<strong>自己的线程ID</strong></p>
<ul>
<li>如果成功，则获取偏向锁成功</li>
<li>如果失败，则进行<strong>锁升级</strong>（也就是被别人抢了，没抢过）</li>
</ul></li>
<li><p>偏向锁状态是已偏向状态</p>
<ul>
<li><p>MarkWord中的线程ID<strong>是自己的线程ID，则成功获取锁</strong></p></li>
<li><p>MarkWord中的线程ID<strong>不是自己的线程ID，则需要进行锁升级</strong></p></li>
</ul></li>
</ul>
<p>注意，这里说的锁升级，需要进行<strong>偏向锁的撤销</strong></p>
<h4 id="偏向锁的撤销">2. 偏向锁的撤销</h4>
<p>前提：<strong>撤销偏向的操作需要在全局检查点执行</strong>
。我们假设线程A曾经拥有锁（不确定是否释放锁），
线程B来竞争锁对象，如果当<strong>线程A不在拥有锁时或者死亡时，线程B直接去尝试获得锁</strong>（根据是否
允许重偏向（<code>rebiasing</code>），获得偏向锁或者轻量级锁）；如果<strong>线程A仍然拥有锁，那么锁
升级为轻量级锁，线程B自旋请求获得锁</strong>。</p>
<ul>
<li><p>对象是不可偏向状态 不需要撤销</p></li>
<li><p>对象是可偏向状态</p>
<ul>
<li>如果MarkWord中指向的线程<strong>不存活</strong>
（这里说的是拥有偏向锁的<strong>线程正常执行完毕后释放锁</strong>）
如果允许重偏向，则退回到可偏向但未偏向的状态；如果不允许重偏向，则变为无锁状态</li>
<li>如果MarkWord中的线程仍然存活
（这里说的是拥有偏向锁的<strong>线程未执行完毕但进行了锁撤销：（包括释放锁及未释放锁(有线程来抢)两种情形）</strong>）
如果线程ID指向的线程<strong>仍然拥有锁</strong>，则<strong>★★升级为轻量级锁，MarkWord复制到线程栈中★★</strong>；如果线程ID<strong>不再拥有锁</strong>（那个线程已经释放了锁），则同样是退回到可偏向(如果允许)但未偏向的状态（即线程ID未空），如果不允许重偏向，则变为无锁状态</li>
</ul></li>
</ul>
<p>偏向锁的撤销流程如图：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221106144334151.png"
alt="image-20221106144334151" /></p>
<h3 id="轻量级锁">轻量级锁</h3>
<p>之所以称为轻量级，是因为它仅仅使用CAS进行操作，实现获取锁</p>
<h4 id="加锁流程">1. 加锁流程</h4>
<ul>
<li><p>如果线程发现<strong>对象头中Mark
Word已经存在指向自己栈帧的指针</strong>，即<strong>线程已经获得轻量级锁</strong>，那么只需要将0存储在自己的栈帧中（此过程称为递归加锁）；在解锁的时候，如果发现锁记录的内容为0，
那么只需要移除栈帧中的锁记录即可，而不需要更新Mark Word。 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221106145155638.png"
alt="image-20221106145155638" /></p>
<p>线程尝试<strong>使用 CAS 将对象头中的 Mark Word
替换为指向锁记录（<code>Lock Record</code>）的指针（这里说的是，MarkWord中并没有指向其他线程栈帧）</strong>，
如上图所示。（我觉得<strong>★这里的CAS，原值为原来的markword，而不是指向其他线程的线程栈地址，这样意义就不对了，会导致别的线程执行到一半失去锁★</strong>）</p>
<ul>
<li>如果成功，当前线程获得轻量级锁</li>
<li>如果失败，虚拟机<strong>先检查当前对象头的 Mark Word
是否指向当前线程的栈帧</strong>
<ul>
<li>如果指向，则说明当前线程已经拥有这个对象的锁，则可以直接进入同步块
执行操作</li>
<li>否则表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。当竞争线程的自旋次数
达到界限值（<code>threshold</code>），轻量级锁将会膨胀为重量级锁。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="撤销流程">2. 撤销流程</h4>
<p>轻量级锁解锁时，如果对象的Mark
Word仍然指向着线程的锁记录，会使用CAS操作， 将Dispalced Mark
Word替换到对象头，如果成功，则表示没有竞争发生。如果失败，
表示当前锁存在锁竞争，锁就会膨胀为重量级锁。</p>
<h3 id="重量级锁">重量级锁</h3>
<p>重量级锁（<code>heavy weight lock</code>），是<strong>使用操作系统互斥量（<code>mutex</code>）来实现的传统锁</strong>。
当所有对锁的优化都失效时，将退回到重量级锁。它与轻量级锁不同竞争的线程<strong>不再通过自旋来竞争线程，
而是直接进入堵塞状态</strong>，此时<strong>不消耗CPU</strong>，然后等拥有锁的线程释放锁后，唤醒堵塞的线程，
然后线程再次竞争锁。但是注意，当<strong>锁膨胀（<code>inflate</code>）为重量锁时，就不能再退回到轻量级锁</strong>。</p>
<h2 id="总结">总结</h2>
<p>首先要明确一点是引入这些锁是为了提高获取锁的效率,
要明白每种锁的使用场景,
比如<strong>偏向锁</strong>适合<strong>一个线程对一个锁的多次获取</strong>的情况;
<strong>轻量级锁</strong>适合<strong>锁执行体比较简单(即减少锁粒度或时间)</strong>,
自旋一会儿就可以成功获取锁的情况.</p>
<p>要明白MarkWord中的内容表示的含义.</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>(该文弃用)锁升级</title>
    <url>/2022/10/31/review/java_guide/java/concurrent/lock_escalation_deprecated/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<p>无锁 =&gt; 偏向锁 =&gt; 轻量锁 =&gt; 重量锁</p>
<p>复习Class类锁和实例对象锁，说明Class类锁和实例对象锁不是同一把锁，互相不影响</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123; </span><br><span class="line">        Object object=<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Customer.class)&#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName()+<span class="string">&quot;Object.class类锁&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;结束并释放锁&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="comment">//保证线程1已经获得类锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;获得object实例对象锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;结束并释放锁&quot;</span>);</span><br><span class="line">        &#125;,<span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">线程1Object.class类锁</span></span><br><span class="line"><span class="comment">线程2获得object实例对象锁</span></span><br><span class="line"><span class="comment">线程2结束并释放锁</span></span><br><span class="line"><span class="comment">线程1结束并释放锁</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>总结图 , 00 , 01 , 10 ，没有11</p>
<p>001（无锁）和101（偏向锁），00（轻量级锁），10（重量级锁）</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221031112225665.png"
alt="image-20221031112225665" />
<figcaption aria-hidden="true">image-20221031112225665</figcaption>
</figure>
<h2 id="背景">背景</h2>
<p>下面这部分，其实在io模块有提到过</p>
<blockquote>
<ul>
<li>为了保证系统稳定性和安全性，一个进程的地址空间划分为<strong>用户空间User
space</strong>和<strong>内核空间Kernel space</strong></li>
<li>平常运行的应用程序都运行在用户空间，只有内核空间才能进行系统态级别的资源有关操作---文件管理、进程通信、内存管理</li>
</ul>
</blockquote>
<p>如果直接synchronized加锁，会有下面图的流程出现，频繁进行用户态和内核态的切换(阻塞和唤醒线程[线程通信]，需要频繁切换cpu的状态)<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221031112946966.png"
alt="image-20221031112946966" /></p>
<ul>
<li>为什么每一个对象都可以成为一个锁 markOop.hpp （对应对象标识）
每一个java对象里面，有一个Monitor对象（ObjectMonitor.cpp)关联
如图，_owner指向持有ObjectMonitor对象的线程 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221031114235312.png"
alt="image-20221031114235312" />
Monitor本质依赖于底层操作系统的MutexLock实现，操作系统实现线程之间的切换，需要从用户态到内核态的切换，成本极高</li>
<li>★★ 重点：Monitor与Java对象以及线程是如何关联
<ul>
<li>如果一个java对象被某个线程锁住，则该对象的MarkWord字段中，LockWord指向monitor的起始地址（这里说的应该是重量级锁）</li>
<li>Monitor的Owner字段会存放拥有相关联对象锁的线程id</li>
<li>图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221031132702183.png"
alt="image-20221031132702183" /></li>
</ul></li>
</ul>
<h2 id="锁升级">锁升级</h2>
<ul>
<li><p>synchronized用的锁，存在Java对象头里的MarkWord中，锁升级功能主要依赖MarkWord中<strong>锁标志位(后2位)</strong>和<strong>释放偏向锁标志位(无锁和偏向锁，倒数第3位)</strong></p></li>
<li><p>对于锁的指向</p>
<ol type="1">
<li>无锁情况：（放hashcode(调用了Object.hashcode才有))</li>
<li>偏向锁：MarkWord存储的是偏向的线程ID</li>
<li>轻量锁：MarkWord存储的是指向线程栈中LockRecord的指针</li>
<li>重量锁：MarkWord存储的是指向堆中的monitor对象的指针</li>
</ol></li>
</ul>
<h2
id="从这之后往下是有误的的">=================================从这之后往下，是有误的的=============================</h2>
<ul>
<li><p>无锁状态
初始状态，一个对象被实例化后，如果还没有任何线程竞争锁，那么它就为无锁状态（001）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable()); <span class="comment">//16字节</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 输出( 这里的mark,VALUE为0x0000000000000001，没有hashCode的值):</span></span><br><span class="line"><span class="comment">java.lang.Object object internals:</span></span><br><span class="line"><span class="comment">OFF  SZ   TYPE DESCRIPTION               VALUE</span></span><br><span class="line"><span class="comment">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span></span><br><span class="line"><span class="comment">  8   4        (object header: class)    0xf80001e5</span></span><br><span class="line"><span class="comment"> 12   4        (object alignment gap)    </span></span><br><span class="line"><span class="comment">Instance size: 16 bytes</span></span><br><span class="line"><span class="comment">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>下面是调用了hashCode()这个方法的情形:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(Integer.toHexString(o.hashCode()));</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable()); <span class="comment">//16字节</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**输出:</span></span><br><span class="line"><span class="comment">74a14482</span></span><br><span class="line"><span class="comment">java.lang.Object object internals:</span></span><br><span class="line"><span class="comment">OFF  SZ   TYPE DESCRIPTION               VALUE</span></span><br><span class="line"><span class="comment">  0   8        (object header: mark)     0x00000074a1448201 (hash: 0x74a14482; age: 0)</span></span><br><span class="line"><span class="comment">  8   4        (object header: class)    0xf80001e5</span></span><br><span class="line"><span class="comment"> 12   4        (object alignment gap)    </span></span><br><span class="line"><span class="comment">Instance size: 16 bytes</span></span><br><span class="line"><span class="comment">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>偏向锁：单线程竞争</p>
<ul>
<li><p>当线程A第一次竞争到锁时，通过操作修改MarkWord中的偏向线程ID、偏向模式。如果不存在其他线程竞争，那么持有偏向锁的线程将永远不需要同步</p></li>
<li><p>如果没有偏向锁，那么就会频繁出现<strong>用户态</strong>到<strong>内核态</strong>的切换</p></li>
<li><p>意义：当一段同步代码，一直<strong>被同一个线程</strong>多次访问，由于<strong>只有一个线程</strong>那么该线程在后续访问时便会<strong>自动获得锁</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221031172548988.png"
alt="image-20221031172548988" /></p></li>
<li><p>锁在<strong>第一次被拥有</strong>的时候，记录下<strong>偏向线程ID</strong>（后续这个线程进入和退出这段加了同步锁的代码块时，不需要再次加锁和释放锁，只需要<strong>直接检查锁的MarkWord</strong>是不是放的<strong>自己的线程ID</strong>）</p>
<ul>
<li>如果相等，表示<strong>偏向锁是偏向于当前线程</strong>的，不需要再尝试获得锁，<strong>直到竞争才会释放锁</strong>；以后每次同步，检查<strong>锁的偏向线程ID与当前线程ID</strong>是否一致，若一致则进入同步，无需每次都加锁解锁去CAS更新对象头；如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销</li>
<li>如果不等，表示<strong>发生了竞争</strong>，锁已经<strong>不偏向于同一个线程</strong>，此时会尝试<strong>使用CAS来替换MarkWord里面的线程ID</strong>为新线程的ID
<ul>
<li><strong>竞争成功</strong>，说明之前线程不存在了，MarkWord里的线程ID为新线程ID，所不会升级，<strong>仍然为偏向锁</strong></li>
<li><strong>竞争失败</strong>，需要升级为<strong>轻量级锁</strong>，才能保证线程间公平竞争锁</li>
</ul></li>
</ul></li>
<li><p>偏向锁只有遇到<strong>其他线程尝试竞争偏向锁</strong>时，持有偏向锁的线程才会释放锁，<strong>线程是不会主动释放锁的</strong>（尽量不会涉及用户到内核态转换）</p></li>
</ul></li>
<li><p>一个<strong>synchronized方法被一个线程抢到锁</strong>时，这个方法所在的对象，就会在<strong>其所在的MarkWord</strong>中**将偏向锁修改状态位</p>
<ul>
<li><p>如图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221031174605461.png"
alt="image-20221031174605461" /></p></li>
<li><p>JVM不用和操作系统协商设置Mutex（争取内核），不需要操作系统介入</p></li>
<li><p>偏向锁相关参数</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -XX:+PrintFlagsInitial | grep BiasedLock*</span><br><span class="line">     intx BiasedLockingBulkRebiasThreshold          = 20</span><br><span class="line">    &#123;product&#125;</span><br><span class="line">     intx BiasedLockingBulkRevokeThreshold          = 40</span><br><span class="line">    &#123;product&#125;</span><br><span class="line">     intx BiasedLockingDecayTime                    = 25000</span><br><span class="line">    &#123;product&#125;</span><br><span class="line">   intx BiasedLockingStartupDelay                 = 4000 #偏向锁启动延迟 4s</span><br><span class="line">    &#123;product&#125;</span><br><span class="line">   bool TraceBiasedLocking                        = false</span><br><span class="line">    &#123;product&#125;</span><br><span class="line">     bool UseBiasedLocking                          = true #默认开启偏向锁</span><br><span class="line">    &#123;product&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用-XX:UseBiasedLocking 关闭偏向锁</span></span><br></pre></td></tr></table></figure></p>
<p>例子：</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">5</span>); <span class="comment">//1 如果1跟下面的2兑换，则就不是偏向锁，是否是偏向锁，在创建对象的时候，就已经确认了</span></span><br><span class="line">          <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();   <span class="comment">//2</span></span><br><span class="line">          <span class="comment">//System.out.println(Integer.toHexString(o.hashCode()));</span></span><br><span class="line">          <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">  </span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(ClassLayout.parseInstance(o).toPrintable()); <span class="comment">//16字节</span></span><br><span class="line">      &#125;</span><br><span class="line">  <span class="comment">//延迟5秒(&gt;4)后，就会看到偏向锁</span></span><br><span class="line">  <span class="comment">/* 打印，005，即二进制101</span></span><br><span class="line"><span class="comment">  java.lang.Object object internals:</span></span><br><span class="line"><span class="comment">OFF  SZ   TYPE DESCRIPTION               VALUE</span></span><br><span class="line"><span class="comment">    0   8        (object header: mark)     0x0000000002f93005 (biased: 0x000000000000be4c; epoch: 0; age: 0)</span></span><br><span class="line"><span class="comment">    8   4        (object header: class)    0xf80001e5</span></span><br><span class="line"><span class="comment">   12   4        (object alignment gap)    </span></span><br><span class="line"><span class="comment">  Instance size: 16 bytes</span></span><br><span class="line"><span class="comment">  Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>偏向锁的升级</p>
<ul>
<li>是一种等到<strong>竞争出现</strong>才释放锁的机制，只有当其他线程竞争锁时，持有偏向锁的原来线程才会被撤销；撤销需要等待全局安全点（该时间点没有字节码在执行），同时检查持有偏向锁的线程是否还在执行
<ul>
<li>如果此时第一个线程<strong>正在</strong>执行synchronized方法（处于同步块），还没执行完其他线程来抢，该偏向锁被取消并出现<strong>锁升级</strong>；此时<strong>轻量级锁</strong>由<strong>原持有偏向锁的线程</strong>持有，<strong>继续执行其同步代码</strong>，而<strong>正在竞争</strong>的线程会进入<strong>自旋等待</strong>获得该轻量级锁</li>
<li>如果第一个线程执行完成synchronized方法（<strong>退出同步块</strong>），而将<strong>对象头</strong>设置成<strong>无锁状态</strong>并撤销偏向锁，重新偏向</li>
<li><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221101171515521.png"
title="fig:" alt="image-20221101171515521" /></li>
</ul></li>
</ul></li>
<li><p>Java15之后，HotSpot不再默认开启偏向锁，使用<code>+XX:UseBiasedLocking</code>手动开启</p></li>
<li><p>偏向锁流程总结
(转自https://blog.csdn.net/MariaOzawa/article/details/107665689) <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/20221102153032.png" /></p></li>
</ul></li>
<li><p>轻量级锁 主要是为了在线程近乎交替执行同步块时提高性能
升级时机，当关闭偏向锁或多线程竞争偏向锁会导致偏向锁升级为轻量级锁
标志位为00</p></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>对象内存布局和对象头</title>
    <url>/2022/10/30/review/java_guide/java/concurrent/object-concurrent/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="对象布局">对象布局</h2>
<ul>
<li><p>heap （where）: new (eden ,s0 ,s1) ,old, metaspace</p></li>
<li><p>对象的构成元素（that）
HotSpot虚拟机里，对象在<strong>堆内存中的存储布局</strong>分为三个部分
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221030175640211.png"
alt="image-20221030175640211" /></p>
<ul>
<li>对象头（Header）
<ul>
<li><strong>对象标记 MarkWord</strong></li>
<li><strong>类元信息</strong>（类型指针 Class
Pointer，指向方法区的地址）</li>
<li>对象头多大 <strong>length</strong>（数组才有）</li>
</ul></li>
<li>实例数据（Instance Data）</li>
<li>对其填充（Padding，保证整个对象大小，是8个字节的倍数）</li>
</ul></li>
</ul>
<h3 id="对象头">对象头</h3>
<ul>
<li><p>对象标记 &gt; 1. Object o= new Object();
//new一个对象，占内存多少 &gt; 2. o.hashCode()
//hashCode存在对象哪个地方 &gt; 3. synchronized(o){ }
//对象被锁了多少次（可重入锁） &gt; 4. System.gc();
//躲过了几次gc（次数）</p>
<p>上面这些，哈希码、gc标记、gc次数、同步锁标记、偏向锁持有者，都保存在<strong>对象标记</strong>里面
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221030175315204.png"
alt="image-20221030175315204" /></p>
<ol type="1">
<li>如果在64位系统中，对象头中，<strong>mark
word（对象标记）</strong>占用8个字节（64位）；<strong>class
pointer（类元信息）</strong>占用8个字节，总共16字节（忽略压缩指针）</li>
<li>无锁的时候， <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221030172439113.png"
alt="image-20221030172439113" /></li>
</ol></li>
<li><p>类型指针 注意下图，指向方法区中（模板）的地址 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221030173518629.png"
alt="image-20221030173518629" /></p></li>
</ul>
<h3 id="实例数据和对齐填充">实例数据和对齐填充</h3>
<ul>
<li><p>实例数据</p></li>
<li><p>用来存放类的属性（Filed）数据信息，包括父类的属性信息</p></li>
<li><p>对齐填充</p></li>
<li><p>填充到长度为8字节，因为虚拟机要求对象起始地址必须是8字节的整数倍（对齐填充不一定存在）</p></li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;<span class="comment">//4字节</span></span><br><span class="line">    <span class="type">boolean</span> flag=<span class="literal">false</span>; <span class="comment">//1字节</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Customer customer=new Customer();</span></span><br><span class="line"><span class="comment">//该对象大小：对象头（对象标记8+类型指针8）+实例数据（4+1）=21字节 ===&gt; 为了对齐填充，则为24字节</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="源码查看">源码查看</h3>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221030175807777.png"
alt="image-20221030175807777" />
<figcaption aria-hidden="true">image-20221030175807777</figcaption>
</figure>
<h2 id="具体的64位虚拟机为主">具体的（64位虚拟机为主）</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221030180026580.png"
alt="image-20221030180026580" />
<figcaption aria-hidden="true">image-20221030180026580</figcaption>
</figure>
<ol type="1">
<li>无锁和偏向锁的锁标志位(最后2位)都是01
<ul>
<li>无锁的倒数第3位，为0，表示非偏向锁</li>
<li>偏向锁的倒数第3位，为1，表示偏向锁</li>
</ul></li>
<li>轻量级锁的锁标志位（最后2位）是00</li>
<li>重量级锁的锁标志位（最后2位）是10</li>
<li>GC标志（最后2位）是11</li>
</ol>
<p>如上所示，对象<strong>分代年龄4位</strong>，即<strong>最大值为15</strong>（十进制）</p>
<p>源码中<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221030180821194.png"
alt="image-20221030180821194" /></p>
<h2 id="使用代码演示上述理论jol">使用代码演示上述理论（JOL)</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入依赖，用来分析对象在JVM中的大小和分布--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>//使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//VM的细节详细情况</span></span><br><span class="line">System.out.println(VM.current().details());</span><br><span class="line"><span class="comment">//所有对象分配字节都是8的整数倍</span></span><br><span class="line">System.out.println(VM.current().objectAlignment());</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment"># Running 64-bit HotSpot VM.</span></span><br><span class="line"><span class="comment"># Using compressed oop with 3-bit shift.</span></span><br><span class="line"><span class="comment"># Using compressed klass with 3-bit shift.</span></span><br><span class="line"><span class="comment"># Objects are 8 bytes aligned.</span></span><br><span class="line"><span class="comment"># Field sizes by type: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class="line"><span class="comment"># Array element sizes: 4, 1, 1, 2, 2, 4, 4, 8, 8 [bytes]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>简单的情形 注意，下面的<strong>8 4 (object header: class)
0xf80001e5</strong>，由于开启了类型指针压缩，只用了4个字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable()); <span class="comment">//16字节</span></span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(customer).toPrintable()); <span class="comment">//16字节</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123; &#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">java.lang.Object object internals:</span></span><br><span class="line"><span class="comment">OFF  SZ   TYPE DESCRIPTION               VALUE</span></span><br><span class="line"><span class="comment">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span></span><br><span class="line"><span class="comment">  8   4        (object header: class)    0xf80001e5</span></span><br><span class="line"><span class="comment"> 12   4        (object alignment gap)    </span></span><br><span class="line"><span class="comment">Instance size: 16 bytes</span></span><br><span class="line"><span class="comment">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">com.ly.Customer object internals:</span></span><br><span class="line"><span class="comment">OFF  SZ   TYPE DESCRIPTION               VALUE</span></span><br><span class="line"><span class="comment">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span></span><br><span class="line"><span class="comment">  8   4        (object header: class)    0xf800cc94</span></span><br><span class="line"><span class="comment"> 12   4        (object alignment gap)    </span></span><br><span class="line"><span class="comment">Instance size: 16 bytes</span></span><br><span class="line"><span class="comment">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Process finished with exit code 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>带有实例数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123; </span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(customer).toPrintable()); <span class="comment">//16字节</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">com.ly.Customer object internals:</span></span><br><span class="line"><span class="comment">OFF  SZ      TYPE DESCRIPTION               VALUE</span></span><br><span class="line"><span class="comment">  0   8           (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span></span><br><span class="line"><span class="comment">  8   4           (object header: class)    0xf800cc94</span></span><br><span class="line"><span class="comment"> 12   4       int Customer.a                0</span></span><br><span class="line"><span class="comment"> 16   1   boolean Customer.b                false</span></span><br><span class="line"><span class="comment"> 17   7           (object alignment gap)    </span></span><br><span class="line"><span class="comment">Instance size: 24 bytes</span></span><br><span class="line"><span class="comment">Space losses: 0 bytes internal + 7 bytes external = 7 bytes total</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>java 运行中添加参数 -XX:MaxTenuringThreshold = 16
，则会出现下面错误，即分代gc最大年龄为15 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221030184043505.png"
alt="image-20221030184043505" /></p></li>
<li><p>压缩指针的相关说明</p>
<ul>
<li><p>使用 java -XX:+PrintComandLineFlags -version ，打印参数</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221030184523659.png"
alt="image-20221030184523659" /> 其中有一个,
<strong>-XX:+UseCompressedClassPointers</strong>
，即开启了<strong>类型指针压缩</strong>，只需要<strong>4字节</strong></p></li>
<li><p>当使用了类型指针压缩（默认）时，一个无任何属性对象是
8字节(markWord) + 4字节（classPointer) + 4字节(对齐填充) =
16字节</p></li>
<li><p>下面代码，使用了
<code>-XX:-UseCompressedClassPointers</code>进行关闭压缩指针
一个无任何属性对象是 8字节(markWord) + 8字节（classPointer) = 16字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable()); <span class="comment">//16字节 //16字节</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">java.lang.Object object internals:</span></span><br><span class="line"><span class="comment">OFF  SZ   TYPE DESCRIPTION               VALUE</span></span><br><span class="line"><span class="comment">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span></span><br><span class="line"><span class="comment">  8   8        (object header: class)    0x000000001dab1c00</span></span><br><span class="line"><span class="comment">Instance size: 16 bytes</span></span><br><span class="line"><span class="comment">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池最佳实践</title>
    <url>/2022/11/29/review/java_guide/java/concurrent/thread-pool-best/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="线程池知识回顾">线程池知识回顾</h2>
<h3 id="为什么要使用线程池">1. 为什么要使用线程池</h3>
<ul>
<li>池化技术的思想，主要是为了减少每次获取资源的消耗，提高对资源的利用率</li>
<li>线程池提供了一种限制和管理资源（包括执行一个任务）的方法，每个线程池还维护一些基本统计信息，例如已完成任务的数量</li>
</ul>
<p>好处：</p>
<ol type="1">
<li>降低资源消耗</li>
<li>提高响应速度</li>
<li>提高线程的可管理性</li>
</ol>
<h3 id="线程池在实际项目的使用场景">2. 线程池在实际项目的使用场景</h3>
<p>线程池一般用于执行<strong>多个不相关联的耗时任务</strong>，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务<strong>同时执行</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221129144110632.png"
alt="image-20221129144110632" />
<figcaption aria-hidden="true">image-20221129144110632</figcaption>
</figure>
<h3 id="如何使用线程池">3. 如何使用线程池</h3>
<p>一般是通过 <code>ThreadPoolExecutor</code>
的构造函数来创建线程池，然后提交任务给线程池执行就可以了。构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                            <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                            TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                            ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                            RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                             )</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">          maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">          keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">      <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">      <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">      <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">      <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">      <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">      <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">      <span class="built_in">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;CurrentThread name:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;date：&quot;</span> + Instant.now());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            awaitTermination()方法的作用:</span></span><br><span class="line"><span class="comment">			当前线程阻塞，直到</span></span><br><span class="line"><span class="comment">			1. 等所有已提交的任务（包括正在跑的和队列中等待的）执行完</span></span><br><span class="line"><span class="comment">			2. 或者等超时时间到</span></span><br><span class="line"><span class="comment">			3. 或者线程被中断，抛出InterruptedException 然后返回true（shutdown请求后所有任务执行完毕）或false（已超时）</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            executor.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment"> CurrentThread name:pool-1-thread-5date：2020-06-06T11:45:31.639Z</span></span><br><span class="line"><span class="comment">CurrentThread name:pool-1-thread-3date：2020-06-06T11:45:31.639Z</span></span><br><span class="line"><span class="comment">CurrentThread name:pool-1-thread-1date：2020-06-06T11:45:31.636Z</span></span><br><span class="line"><span class="comment">CurrentThread name:pool-1-thread-4date：2020-06-06T11:45:31.639Z</span></span><br><span class="line"><span class="comment">CurrentThread name:pool-1-thread-2date：2020-06-06T11:45:31.639Z</span></span><br><span class="line"><span class="comment">CurrentThread name:pool-1-thread-2date：2020-06-06T11:45:33.656Z</span></span><br><span class="line"><span class="comment">CurrentThread name:pool-1-thread-4date：2020-06-06T11:45:33.656Z</span></span><br><span class="line"><span class="comment">CurrentThread name:pool-1-thread-1date：2020-06-06T11:45:33.656Z</span></span><br><span class="line"><span class="comment">CurrentThread name:pool-1-thread-3date：2020-06-06T11:45:33.656Z</span></span><br><span class="line"><span class="comment">CurrentThread name:pool-1-thread-5date：2020-06-06T11:45:33.656Z</span></span><br><span class="line"><span class="comment">Finished all threads </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="线程池最佳实践">线程池最佳实践</h2>
<h3 id="使用threadpoolexecutor的构造函数声明线程池">1.
使用ThreadPoolExecutor的构造函数声明线程池</h3>
<p>线程池必须手动通过 <code>ThreadPoolExecutor</code>
的构造函数来声明，避免使用<code>Executors</code> 类的
<strong><code>newFixedThreadPool</code></strong> 和
<strong><code>newCachedThreadPool</code></strong> ，因为可能会有 OOM
的风险。</p>
<blockquote>
<p><strong><code>FixedThreadPool</code> 和
<code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为
<code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</p>
<p><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ：
允许创建的线程数量为 <code>Integer.MAX_VALUE</code>
，可能会创建大量线程，从而导致 OOM。</p>
</blockquote>
<p>总结：使用有界队列，控制线程创建数量</p>
<p>其他原因：</p>
<ol type="1">
<li>实际中要根据自己机器的性能、业务场景来手动配置线程池参数，比如<strong>核心线程数</strong>、<strong>使用的任务队列</strong>、<strong>饱和策略</strong></li>
<li>给<strong>线程池命名</strong>，方便定位问题</li>
</ol>
<h3 id="监测线程池运行状态">2. 监测线程池运行状态</h3>
<p>可以通过一些手段检测线程池运行状态，比如SpringBoot中的Actuator组件</p>
<p>或者利用ThreadPoolExecutor相关的API做简陋监控，ThreadPoolExecutor提供了<strong>获取线程池当前的线程数</strong>和<strong>活跃线程数</strong>、<strong>已经执行完成的任务数</strong>，<strong>正在排队中的任务数</strong>等</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221129151614427.png"
alt="image-20221129151614427" />
<figcaption aria-hidden="true">image-20221129151614427</figcaption>
</figure>
<p>简单的demo，使用ScheduleExecutorService定时打印线程池信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印线程池的状态</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadPool 线程池对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printThreadPoolStatus</span><span class="params">(ThreadPoolExecutor threadPool)</span> &#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>, createThreadFactory(<span class="string">&quot;print-images/thread-pool-status&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">    scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;ThreadPool Size: [&#123;&#125;]&quot;</span>, threadPool.getPoolSize());</span><br><span class="line">        log.info(<span class="string">&quot;Active Threads: &#123;&#125;&quot;</span>, threadPool.getActiveCount());</span><br><span class="line">        log.info(<span class="string">&quot;Number of Tasks : &#123;&#125;&quot;</span>, threadPool.getCompletedTaskCount());</span><br><span class="line">        log.info(<span class="string">&quot;Number of Tasks in Queue: &#123;&#125;&quot;</span>, threadPool.getQueue().size());</span><br><span class="line">        log.info(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建议不同类别的业务用不同的线程池">3.
建议不同类别的业务用不同的线程池</h3>
<blockquote>
<p>建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务</p>
</blockquote>
<p>极端情况导致死锁：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221129153400643.png"
alt="image-20221129153400643" /></p>
<p>假如我们线程池的核心线程数为
<strong>n</strong>，父任务（扣费任务）数量为
<strong>n</strong>，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了
<strong>"死锁"</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221129154616346.png"
alt="image-20221129154616346" />
<figcaption aria-hidden="true">image-20221129154616346</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221129154543256.png"
alt="image-20221129154543256" />
<figcaption aria-hidden="true">image-20221129154543256</figcaption>
</figure>
<h3 id="别忘记给线程池命名">4. 别忘记给线程池命名</h3>
<p>初始化线程池时显示命名（设置线程池名称前缀），有利于定位问题</p>
<ul>
<li><p>利用guava的ThreadFactoryBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                        .setNameFormat(threadNamePrefix + <span class="string">&quot;-%d&quot;</span>)</span><br><span class="line">                        .setDaemon(<span class="literal">true</span>).build();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)</span><br></pre></td></tr></table></figure></li>
<li><p>自己实现ThreadFactor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NamingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory delegate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个带名字的线程池生产工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NamingThreadFactory</span><span class="params">(ThreadFactory delegate, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// TODO consider uniquifying this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> delegate.newThread(r);</span><br><span class="line">        t.setName(name + <span class="string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="正确配置线程池参数">5. 正确配置线程池参数</h3>
<ul>
<li><p>如果线程池中的线程太多，就会增加<strong>上下文切换</strong>的成本</p>
<blockquote>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU
核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU
采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是：当前任务在执行完
CPU
时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，<strong>上下文切换对系统来说意味着消耗大量的
CPU 时间</strong>，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p><strong>Linux</strong> 相比与其他操作系统（包括其他类 Unix
系统）有很多的优点，其中有一项就是，其<strong>上下文切换和模式切换的时间消耗非常少</strong>。</p>
</blockquote></li>
<li><p>过大跟过小都不行</p>
<ul>
<li>如果我们设置的<strong>线程池数量太小</strong>的话，如果同一时间有大量任务/请求需要处理，可能会导致大<strong>量的请求/任务在任务队列中排队等待执行</strong>，甚至会出现<strong>任务队列满了</strong>之后任务/请求<strong>无法处理</strong>的情况，或者大量任<strong>务堆积在任务队列导致
OOM</strong></li>
<li>设置线程<strong>数量太大</strong>，<strong>大量线程可能会同时在争取
CPU
资源</strong>，这样会导致<strong>大量的上下文切换</strong>，从而<strong>增加线程的执行时间</strong>，影响了整体执行效率</li>
</ul></li>
<li><p>简单且适用面较广的公式</p>
<ul>
<li><p><strong>CPU 密集型任务(N+1)：</strong>
这种<strong>任务消耗的主要是 CPU 资源</strong>，可以将线程数设置为
N（CPU 核心数）+1，比 CPU
核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU
就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU
的空闲时间。</p></li>
<li><p><strong>I/O 密集型任务(2N)：</strong>
这种任务应用起来，系统会用<strong>大部分的时间来处理 I/O
交互</strong>，而<strong>线程在处理 I/O 的时间段内不会占用 CPU
来处理</strong>，这时就可以将 CPU 交出给其它线程使用。因此<strong>在 I/O
密集型任务的应用中，我们可以多配置一些线程</strong>，具体的计算方法是
2N。</p></li>
<li><blockquote>
<p>如何判断是CPU密集任务还是IO密集任务</p>
<p>CPU 密集型简单理解就是利用 CPU
计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是
IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO
操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
</blockquote></li>
</ul></li>
<li><p>美团线程池的处理 主要对线程池的核心参数实现自定义可配置</p>
<ul>
<li><strong><code>corePoolSize</code> :</strong>
核心线程数线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong>
当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong>
当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中</li>
</ul>
<p>参数动态配置 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221129154916589.png"
alt="image-20221129154916589" /></p>
<ol type="1">
<li>格外需要注意的是<code>corePoolSize</code>，
程序运行期间的时候，我们调用
<code>setCorePoolSize（）</code>这个方法的话，线程池会首先判断当前工作线程数是否大于<code>corePoolSize</code>，如果大于的话就会回收工作线程。</li>
<li>另外，你也看到了上面并没有动态指定队列长度的方法，美团的方式是自定义了一个叫做
<code>ResizableCapacityLinkedBlockIngQueue</code>
的队列（主要就是把<code>LinkedBlockingQueue</code>的 capacity 字段的
final 关键字修饰给去掉了，让它变为可变的）</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221129155849107.png"
alt="image-20221129155849107" />
<figcaption aria-hidden="true">image-20221129155849107</figcaption>
</figure></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal详解</title>
    <url>/2022/12/05/review/java_guide/java/concurrent/threadlocal/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
<p>本文来自一枝花算不算浪漫投稿， 原文地址：<a
href="https://juejin.cn/post/6844904151567040519">https://juejin.cn/post/6844904151567040519open
in new window</a>。 感谢作者!</p>
</blockquote>
<p>思维导图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1.af0577dc.png"
alt="img" /></p>
<h1 id="目录">目录</h1>
<h1 id="threadlocal代码演示">ThreadLocal代码演示</h1>
<p>简单使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; messages = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ThreadLocalTest&gt; holder = ThreadLocal.withInitial(ThreadLocalTest::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        holder.get().messages.add(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; messages = holder.get().messages;</span><br><span class="line">        holder.remove();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;size: &quot;</span> + holder.get().messages.size());</span><br><span class="line">        <span class="keyword">return</span> messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadLocalTest.add(<span class="string">&quot;一枝花算不算浪漫&quot;</span>);</span><br><span class="line">        System.out.println(holder.get().messages);</span><br><span class="line">        ThreadLocalTest.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果 </span></span><br><span class="line"><span class="comment">[一枝花算不算浪漫]</span></span><br><span class="line"><span class="comment">size: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong><code>ThreadLocal</code></strong>对象可以提供<strong>线程局部变量</strong>，<strong>每个线程<code>Thread</code>拥有一份自己的副本变量</strong>，多个线程互不干扰。</p>
<blockquote>
<p>回顾之前的知识点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程    </span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        <span class="comment">//★★实际使用的方法</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//★★实际使用的方法</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如上，实际存取都是从Thread的threadLocals
（ThreadLocalMap类）中，并不是存在ThreadLocal上，ThreadLocal用来传递了变量值，只是ThreadLocalMap的封装</li>
<li>ThreadLocal类中通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread
t) 可以访问到该线程的ThreadLocalMap对象</li>
<li>每个Thread中具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key，Object对象为value的键值对</li>
</ul>
</blockquote>
<h1 id="threadlocal的数据结构">ThreadLocal的数据结构</h1>
<p>由上面回顾的知识点可知，value实际上都是保存在<strong>线程类(Thread类)中的某个属性(ThreadLocalMap类)</strong>中
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221206091635103.png"
alt="image-20221206091635103" /></p>
<p><code>Thread</code>类有一个类型为<strong><code>ThreadLocal.ThreadLocalMap</code></strong>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。
ThreadLocalMap是一个静态内部类</p>
<blockquote>
<p>没有修饰符，为包可见。比如父类有一个protected修饰的方法f()，不同包下存在子类A和其他类X，在子类中可以访问方法f()，即使在其他类X创建子类A实例a1，也不能调用a1.f()</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221206092433827.png"
alt="image-20221206092433827" />
<figcaption aria-hidden="true">image-20221206092433827</figcaption>
</figure>
</blockquote>
<p>ThreadLocalMap有自己独立实现，简单地将它的<strong>key视作ThreadLocal</strong>，<strong>value为代码中放入的值</strong>，（看底层代码可知，实际key不是ThreadLocal本身，而是它的一个弱引用）</p>
<p><strong>★每个线程</strong>在往<code>ThreadLocal</code>里放值的时候，都会往<strong>自己的<code>ThreadLocalMap</code></strong>里存，读也是<strong>以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code></strong>，从而实现了<strong>线程隔离</strong>。</p>
<p><code>ThreadLocalMap</code>有点类似<code>HashMap</code>的结构，只是<code>HashMap</code>是由<strong>数组+链表</strong>实现的，而<code>ThreadLocalMap</code>中并没有<strong>链表</strong>结构。其中，还要注意<code>Entry</code>类，
它的<code>key</code>是<code>ThreadLocal&lt;?&gt; k</code>
，(Entry类)继承自<code>WeakReference</code>，
也就是我们常说的弱引用类型。</p>
<blockquote>
<p>如下，有个数组存放Entry(弱引用类，且有属性value)，且</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221206094304751.png"
alt="image-20221206094304751" />
<figcaption aria-hidden="true">image-20221206094304751</figcaption>
</figure>
<hr />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123; </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="为上面的知识点总结一张图">为上面的知识点总结一张图</h1>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221206095002176.png"
alt="image-20221206095002176" />
<figcaption aria-hidden="true">image-20221206095002176</figcaption>
</figure>
<h1 id="gc之后key是否为null">GC之后key是否为null</h1>
<blockquote>
<p>WeakReference的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;Car&gt; weakCar = <span class="keyword">new</span> <span class="title class_">WeakReference</span>(Car)(car); </span><br><span class="line">weakCar.get();  <span class="comment">//如果值为null表示已经被回收了</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>问题：
ThreadLocal的key为弱引用，那么在ThreadLocal.get()的时候，发生GC之后，key是否为null</p>
<ul>
<li>Java的四种引用类型
<ul>
<li>强引用：通常情况new出来的为强引用，只要强引用存在，垃圾回收器<strong>永远不会</strong>回收被引用的对象（即使内存不足）</li>
<li>软引用：使用SoftReference修饰的对象称软引用，软引用指向的对象在<strong>内存要溢出的时候</strong>被回收</li>
<li>弱引用：使用WeakReference修饰的对象称为弱引用，只要发生垃圾回收，如果这个对象只被弱引用指向，那么就会被回收</li>
<li>虚引用：虚引用是最弱的引用，用PhantomReference定义。唯一的作用就是<strong>用队列接收对象即将死亡的通知</strong></li>
</ul></li>
</ul>
<p>使用反射方式查看GC后ThreadLocal中的数据情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">t.join()方法阻塞调用此方法的线程(calling thread)进入 TIMED_WAITING 状态，直到线程t完成，此线程再继续</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;test(<span class="string">&quot;abc&quot;</span>,<span class="literal">false</span>));</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;--gc后--&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; test(<span class="string">&quot;def&quot;</span>, <span class="literal">true</span>));</span><br><span class="line">        t2.start();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String s,<span class="type">boolean</span> isGC)</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;().set(s);</span><br><span class="line">            <span class="keyword">if</span> (isGC) &#123;</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">Thread</span>&gt; clz = t.getClass();</span><br><span class="line">            <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clz.getDeclaredField(<span class="string">&quot;threadLocals&quot;</span>);</span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">ThreadLocalMap</span> <span class="operator">=</span> field.get(t);</span><br><span class="line">            Class&lt;?&gt; tlmClass = ThreadLocalMap.getClass();</span><br><span class="line">            <span class="type">Field</span> <span class="variable">tableField</span> <span class="operator">=</span> tlmClass.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">            tableField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            Object[] arr = (Object[]) tableField.get(ThreadLocalMap);</span><br><span class="line">            <span class="keyword">for</span> (Object o : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; entryClass = o.getClass();</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">valueField</span> <span class="operator">=</span> entryClass.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                    <span class="type">Field</span> <span class="variable">referenceField</span> <span class="operator">=</span> entryClass.getSuperclass().getSuperclass().getDeclaredField(<span class="string">&quot;referent&quot;</span>);</span><br><span class="line">                    valueField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    referenceField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;弱引用key:%s,值:%s&quot;</span>, referenceField.get(o), valueField.get(o)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 结果如下</span></span><br><span class="line"><span class="comment">弱引用key:java.lang.ThreadLocal@433619b6,值:abc</span></span><br><span class="line"><span class="comment">弱引用key:java.lang.ThreadLocal@418a15e3,值:java.lang.ref.SoftReference@bf97a12</span></span><br><span class="line"><span class="comment">--gc后--</span></span><br><span class="line"><span class="comment">弱引用key:null,值:def </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>gc之后的图：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/3.a63c3de1.png"
alt="img" /> <figure class="highlight plaintext"><figcaption><span>ThreadLocal<>().set(s);```  GC之后，key就会被回收，我们看到上面的debug中referent</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果这里修改代码，</span><br><span class="line"></span><br></pre></td></tr></table></figure> ThreadLocal<Object> threadLocal=new
ThreadLocal&lt;&gt;(); threadLocal.set(s); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![img](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/4.c4285c13.png)</span><br><span class="line"></span><br><span class="line">使用弱引用+垃圾回收</span><br><span class="line"></span><br><span class="line">**如上，垃圾回收前，ThreadLoal是存在强引用的，因此如果如上修改代码，则key不为null**  </span><br><span class="line"></span><br><span class="line">**当不存在强引用时，key会被回收**，即出现**value没被回收，key被回收，导致key永远存在，内存泄漏**</span><br><span class="line"></span><br><span class="line">![img](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/5.deed12c8.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ThreadLocal.set()方法源码详解</span><br><span class="line"></span><br><span class="line">如图所示  </span><br><span class="line">![image-20221206134817533](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221206134817533.png)</span><br><span class="line"></span><br><span class="line">ThreadLocal中的set()方法原理如上，先取出线程Thread中的threadLocals，判断是否存在，然后使用ThreadLocal中的set方法进行数据处理</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public void set(T value) &#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    if (map != null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h1 id="threadlocalmap-hash算法">ThreadLocalMap Hash算法</h1>
<p>ThreadLocalMap实现了自己的hash算法来解决<strong>散列表数组冲突</strong>问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i为当前key在散列表中对应的数组下标位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>threadLocalHashCode值的计算，ThreadLocal中有一个<strong>属性为HASH_INCREMENT
= 0x61c88647</strong></p>
<p>0x61c88647，又称为<strong>斐波那契数</strong>也叫<strong>黄金分割数</strong>，hash增量为这个数，好处是<strong>hash
分布非常均匀</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hashCode增加</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>例子如下，产生的哈希码分布十分均匀<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221206135759498.png"
alt="image-20221206135759498" /></p>
<p>★★
说明，下面的所有示例图中，<strong>绿色块Entry</strong>代表为<strong>正常数据</strong>，<strong>灰色块</strong>代表Entry的<strong>key为null</strong>，已被垃圾回收。白色块代表Entry为null（或者说数组那个位置为null(没有指向)）</p>
<h1 id="threadlocalmap-hash冲突">ThreadLocalMap Hash冲突</h1>
<ul>
<li>ThreadLocalMap
中使用<strong>黄金分割数</strong>作为<strong>hash计算因子</strong>，大大减少Hash冲突的概率</li>
<li>HashMap中解决冲突的方法，是在数组上构造一个<strong>链表</strong>结构，冲突的数据<strong>挂载</strong>到链表上，如果链表长度超过一定数量则会<strong>转化为红黑树</strong></li>
<li>ThreadLocalMap中没有链表结构（使用<strong>线性向后查找</strong>）
<ul>
<li>如图 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/7.5b9136ff.png"
alt="img" /></li>
<li>假设需要插入value = 27
的数据，hash后应该落入槽位4，而槽位已经有了Entry数据</li>
<li>此时<strong>线性向后查找</strong>，一直找到Entry为null的操作才会停止查找，将当前元素放入该槽位中</li>
<li>线性向后查找<strong>迭代</strong>中，会遇到<strong>Entry不为null且key值相等</strong>，以及<strong>Entry中的key为null（图中Entry
为 2）</strong>的情况，处理方式不同
<ul>
<li>set过程中如果遇到了<strong>key过期(key为null)的Entry数据</strong>，实际上会进行一轮<strong>探测式清理</strong>操作</li>
</ul></li>
</ul></li>
</ul>
<h1 id="threadlocalmap.set-详解">ThreadLocalMap.set() 详解</h1>
<p>ThreadLocalMap.set() 原理图解</p>
<p>往ThreadLocalMap中set数据（新增或更新数据）分为好几种</p>
<ol type="1">
<li><p>通过<strong>hash计算后</strong>的槽位对应的<strong>Entry数据为空</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/9.3269651c.png"
alt="img" /> 直接将数据放到该槽位即可</p></li>
<li><p>槽位数据不为空，<strong>key值与当前ThreadLocal通过hash</strong>计算获取的<strong>key值一致</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/10.706954d1.png"
alt="img" /> 直接更新该槽位的数据</p></li>
<li><p>槽位数据不为空，往后<strong>遍历</strong>过程中，在找到Entry为null的槽位之前，<strong>没有遇到过期的Entry</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/11.bb4e1504.png"
alt="img" />
遍历散列数组的过程中，线性往后查找，如果找到Entry为null的槽位则将数据放入槽位中；或者往后遍历过程中遇到key值相等的数据则更新</p></li>
<li><p>槽位数据不为空，在找到Entry为null的槽位之前，遇到了过期的Entry，如下图
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/12.7f276023.png"
alt="img" />
此时会执行replaceStableEntry()方法，该方法含义是<strong>替换过期数据的逻辑</strong></p>
<blockquote>
<p>... 以下省略，太复杂</p>
</blockquote>
<p>替换完成后也是进行过期元素清理工作，清理工作主要是有两个方法：<code>expungeStaleEntry()</code>和<code>cleanSomeSlots()</code></p>
<p><strong>经过迭代处理后，有过<code>Hash</code>冲突数据的<code>Entry</code>位置会更靠近正确位置，这样的话，查询的时候
效率才会更高。</strong></p></li>
</ol>
<h1
id="threadlocalmap过期-key-的探测式清理流程略过"><code>ThreadLocalMap</code>过期
key 的探测式清理流程(略过)</h1>
<h1 id="threadlocalmap扩容机制">ThreadLocalMap扩容机制</h1>
<p>在<code>ThreadLocalMap.set()</code>方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中<code>Entry</code>的数量已经达到了<strong>列表的扩容阈值<code>(len*2/3)</code></strong>，就开始执行<code>rehash()</code>逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></figure>
<p>rehash()的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol type="1">
<li><p>threshold <code>[ˈθreʃhəʊld], 门槛</code> = length * 2/3</p></li>
<li><p>rehash之前进行一次容量判断( 是否 &gt; threshold ,
是则rehash)</p></li>
<li><p>rehash时先进行expungeStaleEntries()
（探索式清理，从table起始为止）</p>
<blockquote>
<p>这里首先是会进行探测式清理工作，从<code>table</code>的起始位置往后清理，上面有分析清理的详细流程。清理完成之后，<code>table</code>中可能有一些<code>key</code>为<code>null</code>的<code>Entry</code>数据被清理掉，所以此时通过判断<code>size &gt;= threshold - threshold / 4</code>
也就是<code>size &gt;= threshold * 3/4</code> 来决定是否扩容。</p>
</blockquote></li>
<li><p>清理后如果大于 threshold 的3/4 ，则进行扩容 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/24.ec7f7610.png"
alt="img" /></p></li>
<li><p>具体的resize()方法 以oldTab .len = 8</p>
<ol type="1">
<li><p>容后的<code>tab</code>的大小为<code>oldLen * 2</code>
=16</p></li>
<li><p>遍历老的散列表，重新计算<code>hash</code>位置，然后放到新的<code>tab</code>数组中，如果出现<code>hash</code>冲突则往后寻找最近的<code>entry</code>为<code>null</code>的槽位</p></li>
<li><p>遍历完成之后，<code>oldTab</code>中所有的<code>entry</code>数据都已经放入到新的<code>tab</code>中了。重新计算<code>tab</code>下次扩容的<strong>阈值</strong>
代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                e.value = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol></li>
</ol>
<h1 id="threadlocalmap.get-详解">ThreadLocalMap.get() 详解</h1>
<ol type="1">
<li><p>通过查找<code>key</code>值计算出散列表中<code>slot</code>位置，然后该<code>slot</code>位置中的<code>Entry.key</code>和查找的<code>key</code>一致，则直接返回
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/26.ff0553de.png"
alt="img" /></p></li>
<li><p><code>slot</code>位置中的<code>Entry.key</code>和要查找的<code>key</code>不一致，之后<strong>清理</strong>+<strong>遍历</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/27.9c78c2a2.png"
alt="img" /></p>
<blockquote>
<p>我们以<code>get(ThreadLocal1)</code>为例，通过<code>hash</code>计算后，正确的<code>slot</code>位置应该是
4，而<code>index=4</code>的槽位已经有了数据，且<code>key</code>值不等于<code>ThreadLocal1</code>，所以需要继续往后迭代查找。</p>
<p>迭代到<code>index=5</code>的数据时，此时<code>Entry.key=null</code>，触发一次探测式数据回收操作，执行<code>expungeStaleEntry()</code>方法，执行完后，<code>index 5,8</code>的数据都会被回收，而<code>index 6,7</code>的数据都会前移。<code>index 6,7</code>前移之后，继续从
<code>index=5</code> 往后迭代，于是就在 <code>index=5</code>
找到了<code>key</code>值相等的<code>Entry</code>数据，如下图所示： <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/28.ea7d5196.png"
alt="img" /></p>
</blockquote></li>
<li><p><code>ThreadLocalMap.get()</code>源码详解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<h1
id="threadlocalmap过期key的启发式清理流程略过跟移位运算符有关">ThreadLocalMap过期key的启发式清理流程(略过，跟移位运算符有关)</h1>
<blockquote>
<p>上面多次提及到<code>ThreadLocalMap</code>过期key的两种清理方式：<strong>探测式清理(expungeStaleEntry())</strong>、<strong>启发式清理(cleanSomeSlots())</strong></p>
<p>探测式清理是以当前<code>Entry</code>
往后清理，遇到值为<code>null</code>则结束清理，属于<strong>线性探测清理</strong>。</p>
<p>而启发式清理被作者定义为：<strong>Heuristically scan some cells
looking for stale entries</strong>.</p>
</blockquote>
<h1 id="inheritable-threadlocal">Inheritable ThreadLocal</h1>
<p>使用<code>ThreadLocal</code>的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。JDK中存在InheritableThreadLocal类可以解决处理这个问题</p>
<blockquote>
<p>原理： 子线程是通过在父线程中通过new
Thread()方法创建子线程，Thread#init
方法在Thread的构造方法中被调用，<strong>init</strong>方法中拷贝父线程数据到子线程中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="built_in">this</span>.stackSize = stackSize;</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritableThreadLocalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ThreadLocal&lt;String&gt; ThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">        ThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">        ThreadLocal.set(<span class="string">&quot;父类数据:threadLocal&quot;</span>);</span><br><span class="line">        inheritableThreadLocal.set(<span class="string">&quot;父类数据:inheritableThreadLocal&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程获取父类ThreadLocal数据：&quot;</span> + ThreadLocal.get());</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程获取父类inheritableThreadLocal数据：&quot;</span> + inheritableThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果</span></span><br><span class="line"><span class="comment">子线程获取父类ThreadLocal数据：null</span></span><br><span class="line"><span class="comment">子线程获取父类inheritableThreadLocal数据：父类数据:inheritableThreadLocal</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>但是如果不是直接new()，也就是实际中我们都是通过使用线程池来获取新线程的，那么可以使用阿里开源的一个组件解决这个问题
<code>TransmittableThreadLocal</code></p>
<h1 id="threadlocal项目中使用实战">ThreadLocal项目中使用实战</h1>
<p><strong>这里涉及到requestId，没用过，不是很懂，略过</strong></p>
<h2 id="threadlocal使用场景">ThreadLocal使用场景</h2>
<h2 id="feign远程调用解决方案">Feign远程调用解决方案</h2>
<h2 id="线程池异步调用requestid-传递">线程池异步调用,requestId 传递</h2>
<h2 id="使用mq发送消息给第三方系统">使用MQ发送消息给第三方系统</h2>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>io设计模式</title>
    <url>/2022/10/24/review/java_guide/java/io/io-design-patterns/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="装饰器模式">装饰器模式</h2>
<ul>
<li><p>装饰器，Decorator，装饰器模式可以在不改变原有对象的情况下拓展其功能</p></li>
<li><p>★装饰器模式，通过组合替代继承来扩展原始类功能，在一些继承关系较复杂的场景（IO这一场景各种类的继承关系就比较复杂）下更加实用</p></li>
<li><p>对于字节流，<strong>FilterInputStream（对应输入流）和FilterOutputStream（对应输出流）</strong>是装饰器模式的核心，分别用于增强（继承了）InputStream和OutputStream子类对象的功能
Filter （过滤的意思） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221026092700367.png"
alt="image-20221026092700367" /></p></li>
<li><p>其中BufferedInputStream（字节缓冲输入流）、DataInputStream等等都是FilterInputStream的子类，对应的BufferedOutputStream和DataOutputStream都是FilterOutputStream的子类</p></li>
<li><p>例子，使用BufferedInputStream（字节缓冲输入流）来增强FileInputStream功能</p>
<ul>
<li><p>BufferedInputStream源码（构造函数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEFAULT_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(in);</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">int</span> content;</span><br><span class="line">    <span class="type">long</span> <span class="variable">skip</span> <span class="operator">=</span> bis.skip(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> ((content = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>ZipInputStream和ZipOutputStream还可以用来增强BufferedInputStream和BufferedOutputStream的能力</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line"><span class="type">ZipInputStream</span> <span class="variable">zis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(bis);</span><br><span class="line"></span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName));</span><br><span class="line"><span class="type">ZipOutputStream</span> <span class="variable">zipOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(bos);</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221026093724390.png"
alt="image-20221026093724390" />
<figcaption aria-hidden="true">image-20221026093724390</figcaption>
</figure></li>
<li><p>装饰器模式重要的一点，就是可以对原始类嵌套使用多个装饰器，所以装饰器需要跟原始类继承相同的抽象类或实现相同接口，上面介绍的IO相关装饰器和原始类共同父类都是InputStream和OutputStream
而对于字符流来说，BufferedReader用来增强Reader（字符输入流）子类功能，BufferWriter用来增加Writer（字符输出流）子类功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(fileName), <span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>IO流中大量使用了装饰器模式，不需要特意记忆</p></li>
</ul>
<h2 id="适配器模式">适配器模式</h2>
<ul>
<li><p>适配器（Adapter
Pattern）模式：主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常使用的电源适配器</p>
<ul>
<li>其中被适配的对象/类称为适配者（Adaptee），作用于适配者的对象或者类称为适配器（Adapter）。<strong>对象适配器</strong>使用<strong>组合</strong>关系实现，<strong>类适配器</strong>使用<strong>继承</strong>关系实现</li>
</ul></li>
<li><p>IO中<strong>字符流</strong>和<strong>字节流</strong>接口不同，而他们能协调工作就是基于适配器模式来做的，具体的，是对象适配器：将<strong>字节流对象适配成字符流对象</strong>，然后通过<strong>字节流对象</strong>，<strong>读取/写入字符</strong>数据</p></li>
<li><p>InputStreamReader和OutputStreamWriter为两个适配器，也是字节流和字符流之间的桥梁</p></li>
<li><p>InputStreamReader使用StreamDecode（流解码器）对字节进行解码，实现字节流到字符流的转换</p></li>
<li><p>OutputStreamWriter使用StreamEncoder（流编码器）对字符进行编码，实现字符到字节流的转换</p></li>
<li><p>InputStream和OutputStream的子类是被适配者，InputStreamReader和OutputStreamWriter是适配器
使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InputStreamReader 是适配器，FileInputStream 是被适配的类</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="comment">// BufferedReader 增强 InputStreamReader 的功能（装饰器模式）</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br></pre></td></tr></table></figure>
<p>fileReader的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其父类InputStreamReader</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">	<span class="comment">//用于解码的对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> StreamDecoder sd;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InputStreamReader</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 StreamDecoder 对象</span></span><br><span class="line">            sd = StreamDecoder.forInputStreamReader(in, <span class="built_in">this</span>, (String)<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 StreamDecoder 对象做具体的读取工作</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> sd.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，java.io.OutputStreamWriter部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">    <span class="comment">// 用于编码的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StreamEncoder se;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OutputStreamWriter</span><span class="params">(OutputStream out)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(out);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 获取 StreamEncoder 对象</span></span><br><span class="line">            se = StreamEncoder.forOutputStreamWriter(out, <span class="built_in">this</span>, (String)<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    使用 StreamEncoder 对象做具体的写入工作</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        se.write(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>适配器模式和装饰器模式区别</p>
<ul>
<li><p>装饰器模式更侧重于<strong>动态增强原始类</strong>的功能，（为了嵌套）装饰器类需要跟原始类继承相同抽象类/或实现相同接口。装饰器模式支持对原始类嵌套</p></li>
<li><p>适配器模式侧重于<strong>让接口不兼容而不能交互的类一起工作</strong>，当调用适配器方法时，适配器<strong>内部会调用适配者类或者和适配者类相关类</strong>的方法（例如StreamDecoder
流解码器和StreamEncoder流编码器）基于InputStream和OutputStream来获取FileChannel对象并调用read/write进行字节数据读取/写入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StreamDecoder(InputStream in, Object lock, CharsetDecoder dec) &#123;</span><br><span class="line">    <span class="comment">// 省略大部分代码</span></span><br><span class="line">    <span class="comment">// 根据 InputStream 对象获取 FileChannel 对象</span></span><br><span class="line">    ch = getChannel((FileInputStream)in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>适配器和适配者两者不需要继承相同抽象类/不需要实现相同接口</p></li>
<li><p>FutureTask使用了适配器模式 直接调用(构造器)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Runnable runnable, V result)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 Executors 类的 callable 方法</span></span><br><span class="line">    <span class="built_in">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>间接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际调用的是 Executors 的内部类 RunnableAdapter 的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="title function_">callable</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RunnableAdapter</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ul>
<h2 id="工厂模式">工厂模式</h2>
<p>NIO中大量出现，例如Files类的newInputStream，Paths类中的get方法，ZipFileSystem类中的getPath</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream is Files.newInputStream(Paths.get(generatorLogoPath))</span><br></pre></td></tr></table></figure>
<h2 id="观察者模式">观察者模式</h2>
<ul>
<li><p>比如NIO中的文件目录监听服务
该服务基于WatchService接口（观察者）和Watchable接口（被观察者）</p></li>
<li><p>Watchable接口其中有一个register方法，用于将对象注册到WatchService（监控服务）并绑定监听事件的方法</p></li>
<li><p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 WatchService 对象</span></span><br><span class="line"><span class="type">WatchService</span> <span class="variable">watchService</span> <span class="operator">=</span> FileSystems.getDefault().newWatchService();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个被监控文件夹的 Path 类:</span></span><br><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;workingDirectory&quot;</span>);</span><br><span class="line"><span class="comment">// 将这个 path 对象注册到 WatchService（监控服务） 中去</span></span><br><span class="line"><span class="type">WatchKey</span> <span class="variable">watchKey</span> <span class="operator">=</span> path.register(</span><br><span class="line">watchService, StandardWatchEventKinds...);</span><br></pre></td></tr></table></figure></li>
<li><p>可以通过WatchKey对象获取事件具体信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WatchKey key;</span><br><span class="line"><span class="keyword">while</span> ((key = watchService.take()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;</span><br><span class="line">      <span class="comment">// 可以调用 WatchEvent 对象的方法做一些事情比如输出事件的具体上下文信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    key.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的代码应该是如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建 WatchService 对象</span></span><br><span class="line">        <span class="type">WatchService</span> <span class="variable">watchService</span> <span class="operator">=</span> FileSystems.getDefault().newWatchService();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个被监控文件夹的 Path 类:</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;F:\\java_test\\git\\hexo\\review_demo\\src\\com\\hp&quot;</span>);</span><br><span class="line"><span class="comment">// 将这个 path 对象注册到 WatchService（监控服务） 中去</span></span><br><span class="line">        <span class="type">WatchKey</span> <span class="variable">key</span> <span class="operator">=</span> path.register(</span><br><span class="line">                watchService, StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE</span><br><span class="line">                ,StandardWatchEventKinds.ENTRY_MODIFY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((key = watchService.take()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;检测到了事件--start--&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123;</span><br><span class="line">                <span class="comment">// 可以调用 WatchEvent 对象的方法做一些事情比如输出事件的具体上下文信息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;event.kind().name()&quot;</span>+event.kind().name());</span><br><span class="line">            &#125;</span><br><span class="line">            key.reset();</span><br><span class="line">            System.out.println(<span class="string">&quot;检测到了事件--end--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Path</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Path&gt;, Iterable&lt;Path&gt;, Watchable&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Watchable</span> &#123;</span><br><span class="line">    WatchKey <span class="title function_">register</span><span class="params">(WatchService watcher,</span></span><br><span class="line"><span class="params">                      WatchEvent.Kind&lt;?&gt;[] events,</span></span><br><span class="line"><span class="params">                      WatchEvent.Modifier... modifiers)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="comment">//events，需要监听的事件，包括创建、删除、修改。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    WatchKey <span class="title function_">register</span><span class="params">(WatchService watcher,</span></span><br><span class="line"><span class="params">                      WatchEvent.Kind&lt;?&gt;... events)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中events包括下面3种:</p>
<ul>
<li><code>StandardWatchEventKinds.ENTRY_CREATE</code> ：文件创建。</li>
<li><code>StandardWatchEventKinds.ENTRY_DELETE</code> : 文件删除。</li>
<li><code>StandardWatchEventKinds.ENTRY_MODIFY</code> : 文件修改。</li>
</ul></li>
<li><p>WatchService内部通过一个daemon thread
（守护线程），采用定期轮询的方式检测文件变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PollingWatchService</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractWatchService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个 daemon thread（守护线程）轮询检测文件变化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutor;</span><br><span class="line"></span><br><span class="line">    PollingWatchService() &#123;</span><br><span class="line">        scheduledExecutor = Executors</span><br><span class="line">            .newSingleThreadScheduledExecutor(<span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                     <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                     t.setDaemon(<span class="literal">true</span>);</span><br><span class="line">                     <span class="keyword">return</span> t;</span><br><span class="line">                 &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">enable</span><span class="params">(Set&lt;? extends WatchEvent.Kind&lt;?&gt;&gt; events, <span class="type">long</span> period)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="comment">// 更新监听事件</span></span><br><span class="line">      <span class="built_in">this</span>.events = events;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启定期轮询</span></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">thunk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; poll(); &#125;&#125;;</span><br><span class="line">      <span class="built_in">this</span>.poller = scheduledExecutor</span><br><span class="line">        .scheduleAtFixedRate(thunk, period, period, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>大部分转自https://github.com/Snailclimb/JavaGuide</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-io</tag>
      </tags>
  </entry>
  <entry>
    <title>io模型</title>
    <url>/2022/10/26/review/java_guide/java/io/io-model/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="io">I/O</h2>
<h3 id="何为io">何为I/O</h3>
<ul>
<li>I/O(Input/Output)，即输入/输出
从计算机结构的角度来解读一下I/O，根据冯诺依曼结构，计算机结构分为5大部分：运算器、控制器、存储器、输入设备、输出设备
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221026153939710.png"
alt="image-20221026153939710" /> 其中，输入设备：键盘；输出设备：显示器
网卡、硬盘既属于输入设备也属于输出设备</li>
<li>输入设备<strong>向计算机输入（内存）</strong>数据，输出设备<strong>接收计算机（内存）</strong>输出的数据，即I/O描述了计算机系统与外部设备之间通信的过程</li>
<li>从应用程序的角度解读I/O
<ul>
<li>为了保证系统稳定性和安全性，一个进程的地址空间划分为<strong>用户空间User
space</strong>和<strong>内核空间Kernel space</strong></li>
<li>平常运行的应用程序都运行在用户空间，只有内核空间才能进行系统态级别的资源有关操作---<strong>文件管理、进程通信、内存管理</strong></li>
<li>如果要进行IO操作，就得依赖<strong>内核空间</strong>的能力，<strong>用户空间的程序</strong>不能直接访问<strong>内核空间</strong></li>
<li>用户进程要想执行IO操作，必须通过<strong>系统调用</strong>来间接访问内核空间</li>
</ul></li>
<li>对于<strong>磁盘IO（读写文件）</strong>和<strong>网络IO（网络请求和响应）</strong>，从应用程序视角来看，<strong>应用程序</strong>对操作系统的<strong>内核</strong>发起<strong>IO调用（系统调用）</strong>，操作系统负责的<strong>内核</strong>执行具体<strong>IO</strong>操作
<ul>
<li>应用程序只是发起了IO操作调用，而具体的IO执行则由操作系统内核完成</li>
</ul></li>
<li>应用程序<strong>发起I/O后</strong>，经历两个步骤
<ul>
<li>内核<strong>等待I/O设备</strong>准备好数据</li>
<li>内核将数据<strong>从内核空间</strong>拷贝<strong>到用户空间</strong></li>
</ul></li>
</ul>
<h3 id="有哪些常见的io模型">有哪些常见的IO模型</h3>
<p>UNIX系统下，包括5种：同步阻塞I/O，同步非阻塞I/O，I/O多路复用、信号驱动I/O和异步I/O</p>
<h2 id="java中3中常见io模型">Java中3中常见I/O模型</h2>
<h3 id="bio-blocking-io">BIO (Blocking I/O )</h3>
<ul>
<li>应用程序发起read调用后，会一直阻塞，<strong>直到内核把数据拷贝到用户空间</strong>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221026162316247.png"
alt="image-20221026162316247" /></li>
</ul>
<h3 id="nio-non-blockingnew-io">NIO (Non-blocking/New I/O)</h3>
<ul>
<li>对于java.nio包，提供了Channel、Selector、Buffer等抽象概念，对于高负载高并发，应使用NIO</li>
<li>NIO是I/O多路复用模型，属于同步非阻塞IO模型
<ul>
<li>普通的同步非阻塞：应用程序会一直发起read调用，等待数据从内核空间拷贝到用户空间的这段时间，线程依然是阻塞的，知道内核把数据拷贝到用户空间（这里是通过不断轮询操作去数据）</li>
<li>I/O多路复用
线程首先发起select调用，询问内核数据是否准备就绪，等准备好了，用户线程再发起read调用，read调用的过程（数据从内核空间--&gt;用户空间）还是阻塞的</li>
<li>Selector，即多路复用器，一个线程管理多个客户端连接 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221026163835033.png"
alt="image-20221026163835033" /></li>
</ul></li>
</ul>
<h3 id="aioasynchronous-io">AIO(Asynchronous I/O )</h3>
<ul>
<li>异步 IO
是基于<strong>事件和回调</strong>机制实现的，也就是<strong>应用操作之后会直接返回</strong>，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作
如图<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221026164006797.png"
alt="image-20221026164006797" /></li>
</ul>
<h2 id="三者区别">三者区别</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221026164100906.png"
alt="image-20221026164100906" />
<figcaption aria-hidden="true">image-20221026164100906</figcaption>
</figure>
<blockquote>
<p>大部分转自https://github.com/Snailclimb/JavaGuide</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-io</tag>
      </tags>
  </entry>
  <entry>
    <title>io基础</title>
    <url>/2022/10/23/review/java_guide/java/io/io/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="简介">简介</h2>
<ul>
<li><p>IO，即Input/Output，输入和输出，输入就是数据输入到计算机内存；输出则是输出到外部存储（如数据库、文件、远程主机）</p></li>
<li><p>根据数据处理方式，又分为字节流和字符流</p></li>
<li><p>基类</p>
<ul>
<li>字节输入流 InputStream，字符输入流 Reader</li>
<li>字节输出流 OutputStream, 字符输出流 Writer</li>
</ul></li>
</ul>
<h2 id="字节流">字节流</h2>
<ul>
<li><p>字节输入流 InputStream
InputStream用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream抽象类是<strong>所有字节输入流的父类</strong></p>
<ul>
<li><p>常用方法</p>
<blockquote>
<ul>
<li><code>read()</code> ：返回输入流中下一个字节的数据。返回的值介于 0
到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code>
，表示文件结束。</li>
<li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组
<code>b</code> 中。如果数组 <code>b</code>
的长度为零，则不读取。如果没有可用字节读取，返回
<code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于
<code>b.length</code> ， 返回读取的字节数。这个方法等价于
<code>read(b, 0, b.length)</code>。</li>
<li><code>read(byte b[], int off, int len)</code>
：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code> ：忽略输入流中的 n 个字节
,返回实际忽略的字节数。</li>
<li><code>available()</code> ：返回输入流中可以读取的字节数。</li>
<li><code>close()</code> ：关闭输入流释放相关的系统资源。</li>
</ul>
</blockquote></li>
<li><p>Java9 新增了多个实用方法</p>
<blockquote>
<ul>
<li><code>readAllBytes()</code>
：读取输入流中的所有字节，返回字节数组。</li>
<li><code>readNBytes(byte[] b, int off, int len)</code> ：阻塞直到读取
<code>len</code> 个字节。</li>
<li><code>transferTo(OutputStream out)</code> ：
将所有字节从一个输入流传递到一个输出流。</li>
</ul>
</blockquote></li>
<li><p>FileInputStream --&gt;
字节输入流对象，可直接指定文件路径：用来读取单字节数据/或读取至字节数组中，示例如下：<br />
input.txt中的字符为LLJavaGuide</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Number of remaining bytes:&quot;</span></span><br><span class="line">            + fis.available());</span><br><span class="line">    <span class="type">int</span> content;</span><br><span class="line">    <span class="type">long</span> <span class="variable">skip</span> <span class="operator">=</span> fis.skip(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;The actual number of bytes skipped:&quot;</span> + skip);</span><br><span class="line">    System.out.print(<span class="string">&quot;The content read from file:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((content = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">/**Number of remaining bytes:11</span></span><br><span class="line"><span class="comment">The actual number of bytes skipped:2</span></span><br><span class="line"><span class="comment">The content read from file:JavaGuide</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<p>一般不会单独使用FileInputStream，而是配合BufferdInputStream(字节缓冲输入流)，下面代码转为String
较为常见：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 读取文件的内容并复制到 String 对象中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bufferedInputStream.readAllBytes());</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure></li>
<li><p>DataInputStream
用于读取指定类型数据，不能单独使用，必须结合FileInputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line"><span class="comment">//必须将fileInputStream作为构造参数才能使用</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fileInputStream);</span><br><span class="line"><span class="comment">//可以读取任意具体的类型数据</span></span><br><span class="line">dataInputStream.readBoolean();</span><br><span class="line">dataInputStream.readInt();</span><br><span class="line">dataInputStream.readUTF();</span><br></pre></td></tr></table></figure></li>
<li><p>ObjectInputStream
用于从输入流读取Java对象（一般是被反序列化到文件中，或者其他介质的数据），ObjectOutputStream用于将对象写入到输出流（[将对象]序列化）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.data&quot;</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">object</span> <span class="operator">=</span> (MyClass) input.readObject();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>
<p>用于序列化和反序列化的类必须实现Serializable接口，不想被序列化的属性用<code>transizent</code>修饰</p></li>
</ul></li>
<li><p>字节输出流 OutputStream</p>
<ul>
<li><p>OutputStream用于将字节数据（字节信息）写入到目的地（通常是文件），java.io.OutputStream抽象类是<strong>所有字节输出流的父类</strong></p>
<blockquote>
<p>//常用方法</p>
<ul>
<li><code>write(int b)</code> ：将特定字节写入输出流。</li>
<li><code>write(byte b[ ])</code> : 将数组<code>b</code>
写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>
<li><code>write(byte[] b, int off, int len)</code> :
在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字节。
//相比输入流多出的方法</li>
<li><code>close()</code> ：关闭输出流释放相关的系统资源。</li>
</ul>
</blockquote></li>
</ul></li>
<li><p>示例代码：<br />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="string">&quot;JavaGuide&quot;</span>.getBytes();</span><br><span class="line">    output.write(array);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">/**output.txt文件中内容为:</span></span><br><span class="line"><span class="comment">JavaGuide</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileOutputStream一般也是配合BufferedOutputStream （字节缓冲输出流）： </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">FileOutputStream fileOutputStream = new FileOutputStream(&quot;output.txt&quot;);</span><br><span class="line">  BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream)</span><br></pre></td></tr></table></figure></p></li>
<li><p>DataOutputStream用于写入指定类型数据，不能单独使用，必须结合FileOutputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出流</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fileOutputStream);</span><br><span class="line"><span class="comment">// 输出任意数据类型</span></span><br><span class="line">dataOutputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">dataOutputStream.writeByte(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>ObjectInputStream用于从输入流中读取<strong>Java对象</strong>（ObjectInputStream，反序列化）；ObjectOutputStream用于将对象写入到输出流（ObjectOutputStream，序列化）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Guide哥&quot;</span>, <span class="string">&quot;JavaGuide作者&quot;</span>);</span><br><span class="line">output.writeObject(person);</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="字符流">字符流</h2>
<ul>
<li><p>简介
文件读写或者网络发送接收，信息的最小存储单元都是字节，为什么I/O流操作要分为字节流操作和字符流操作呢</p>
<ul>
<li><p>字符流是由Java虚拟机将字节转换得到的，过程相对耗时</p></li>
<li><p>如果不知道编码类型，容易出现乱码 如上面的代码，将文件内容改为 ：
你好，我是Guide</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Number of remaining bytes:&quot;</span></span><br><span class="line">            + fis.available());</span><br><span class="line">    <span class="type">int</span> content;</span><br><span class="line">    <span class="type">long</span> <span class="variable">skip</span> <span class="operator">=</span> fis.skip(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;The actual number of bytes skipped:&quot;</span> + skip);</span><br><span class="line">    System.out.print(<span class="string">&quot;The content read from file:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((content = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">/**Number of remaining bytes:9</span></span><br><span class="line"><span class="comment">The actual number of bytes skipped:2</span></span><br><span class="line"><span class="comment">The content read from file:§å®¶å¥½</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<p>为了解决乱码问题，I/O流提供了一个直接操作字符的接口，方便对字符进行流操作；但如果音频文件、图片等媒体文件用字节流比较好，涉及字符的话使用字符流</p>
<blockquote>
<p>★ 重要：</p>
<p>字符流默认采用的是 <code>Unicode</code>
编码，我们可以通过构造方法自定义编码。顺便分享一下之前遇到的笔试题：常用字符编码所占字节数？<code>utf8</code>
:英文占 1 字节，中文占 3 字节，<code>unicode</code>：任何字符都占 2
个字节，<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p>
</blockquote></li>
</ul></li>
<li><p>Reader（字符输入流）</p>
<ul>
<li><p>用于从源头（通常是文件）读取数据（字符信息）到内存中，java.io.Reader抽象类是<strong>所有字符输入流的父类</strong></p>
<p>注意：InputStream和Reader都是类，再往上就是接口了；Reader用于读取文本，InputStream用于读取原始字节
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221024095605757.png"
alt="image-20221024095605757" /></p>
<blockquote>
<p>常用方法：</p>
<ul>
<li><code>read()</code> : 从输入流读取一个字符。</li>
<li><code>read(char[] cbuf)</code> :
从输入流中读取一些字符，并将它们存储到字符数组
<code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code>
。</li>
<li><code>read(char[] cbuf, int off, int len)</code>
：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code> ：忽略输入流中的 n 个字符
,返回实际忽略的字符数。</li>
<li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li>
</ul>
</blockquote></li>
<li><p>InputStreamReader是<strong>字节流转换为字符流</strong>的桥梁，子类FileReader基于该基础上的封装，可以<strong>直接操作</strong>字符文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字节流转换为字符流的桥梁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于读取字符文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：input.txt中内容为"你好，我是Guide"</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>);) &#123;</span><br><span class="line">    <span class="type">int</span> content;</span><br><span class="line">    <span class="type">long</span> <span class="variable">skip</span> <span class="operator">=</span> fileReader.skip(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;The actual number of bytes skipped:&quot;</span> + skip);</span><br><span class="line">    System.out.print(<span class="string">&quot;The content read from file:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((content = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">The actual number of bytes skipped:3</span></span><br><span class="line"><span class="comment">The content read from file:我是Guide。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>Write（字符输出流）
用于将数据（字符信息）写到目的地（通常是文件），java.io.Writer抽象类是<strong>所有字节输出流</strong>的父类</p>
<blockquote>
<ul>
<li><code>write(int c)</code> : 写入单个字符。</li>
<li><code>write(char[] cbuf)</code> ：写入字符数组
<code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li>
<li><code>write(char[] cbuf, int off, int len)</code>
：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>write(String str)</code> ：写入字符串，等价于
<code>write(str, 0, str.length())</code> 。</li>
<li><code>write(String str, int off, int len)</code>
：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>append(CharSequence csq)</code> ：将指定的字符序列附加到指定的
<code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>append(char c)</code> ：将指定的字符附加到指定的
<code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>flush()</code>
：刷新此输出流并强制写出所有缓冲的输出字符。//相对于Reader增加的</li>
<li><code>close()</code>:关闭输出流释放相关的系统资源。</li>
</ul>
</blockquote>
<ul>
<li><p>OutputStreamWriter是<strong>字符流转换为字节流</strong>的桥梁（注意，这里没有错），其子类FileWriter是基于该基础上的封装，可以直接将字符写入到文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符流转换为字节流的桥梁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于写入字符到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriter</span> <span class="keyword">extends</span> <span class="title class_">OutputStreamWriter</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FileWriter代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    output.write(<span class="string">&quot;你好，我是Guide。&quot;</span>); <span class="comment">//字符流，转为字节流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果：output.txt中</span></span><br><span class="line"><span class="comment">你好，我是Guide</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>InputStreamWriter和OutputStreamWriter 比较</p>
<ul>
<li>前者InputStreamWriter，是需要从文件中读数据出来，而文件是通过二进制（字节）保存的，所以InputStreamWriter是将（看不懂的）字节流转换为（看得懂的）字符流</li>
<li>后者OutputStreamWriter，是需要将（看得懂的）字符流转换为（看不懂的）字节流并保存到介质中</li>
</ul></li>
</ul>
<h2 id="字节缓冲流">字节缓冲流</h2>
<ul>
<li><p>简介</p>
<ul>
<li><p>IO操作是很消耗性能的，缓冲流<strong>将数据加载至缓冲区</strong>，一次性读取/写入多个字节，从而避免频繁的IO操作，提高流的效率</p></li>
<li><p>采用装饰器模式来增强InputStream和OutputStream子类对象的功能</p></li>
<li><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>字节流和字节缓冲流的性能差别主要体现在：当使用两者时都调用的是write(int
b)和read()
这两个一次只读取一个字节的方法的时候，由于字节缓冲流内部有缓冲区（字节数组），因此字节缓冲流会将读取到的字节存放在缓存区，大幅减少IO次数，提高读取效率</p>
<blockquote>
<p>对比：复制524.9mb文件，缓冲流15s，普通字节流2555s(30min)</p>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_buffer_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>));</span><br><span class="line">         <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">int</span> content;</span><br><span class="line">        <span class="keyword">while</span> ((content = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>);</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> content;</span><br><span class="line">        <span class="keyword">while</span> ((content = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>但是如果是使用普通字节流的 read(byte b[] )和write(byte b[] , int
off, int len)
这两个写入一个字节数组的方法的话，只要字节数组大小合适，差距性能不大
同理，使用read(byte b[]) 和write(byte b[] ,int off, int
len)方法(字节流及缓冲字节流)，分别复制524mb文件，缓冲流需要0.7s ,
普通字节流需要1s 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_with_byte_array_buffer_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>));</span><br><span class="line">         <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_with_byte_array_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>);</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>字节缓冲输入流 BufferedInputStream</p>
<ul>
<li><p><code>BufferedInputStream</code>
从源头（通常是文件）读取数据（字节信息）到内存的过程中<strong>不会一个字节一个字节的读取</strong>，而是会先<strong>将读取到的字节存放在缓存区</strong>，并从内部缓冲区中单独读取字节。这样大幅减少了
IO 次数，提高了读取效率。</p>
<p><code>BufferedInputStream</code>
<strong>内部维护了一个缓冲区</strong>，这个<strong>缓冲区实际就是一个字节数组</strong>，通过阅读
<code>BufferedInputStream</code> 源码即可得到这个结论。</p></li>
<li><p>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">    <span class="comment">// 内部缓冲区数组</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">byte</span> buf[];</span><br><span class="line">    <span class="comment">// 缓冲区的默认大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEFAULT_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line">    <span class="comment">// 使用默认的缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>字节缓冲输出流 BufferedOutputStream
<code>BufferedOutputStream</code>
将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了
IO 次数，提高了读取效率 使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="string">&quot;JavaGuide&quot;</span>.getBytes();</span><br><span class="line">    bos.write(array);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字符缓冲流">字符缓冲流</h2>
<p><strong><code>BufferedReader</code> （字符缓冲输入流）和
<code>BufferedWriter</code>（字符缓冲输出流）</strong>类似于
<code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p>
<blockquote>
<p>这里表述好像不太对，应该是维护了字符数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Reader in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> cb[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="打印流">打印流</h2>
<ul>
<li><p>PrintStream属于字节打印流，对应的是PrintWriter（字符打印流）</p></li>
<li><p>System.out
实际上获取了一个PrintStream，print方法调用的是PrintStream的write方法</p></li>
<li><p><code>PrintStream</code> 是 <code>OutputStream</code>
的子类，<code>PrintWriter</code> 是 <code>Writer</code>
的子类。</p></li>
<li><p>```java public class PrintStream extends FilterOutputStream
implements Appendable, Closeable { } public class PrintWriter extends
Writer { } <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 随机访问流 RandomAccessFile</span><br><span class="line"></span><br><span class="line">- 指的是支持随意跳转到文件的任意位置进行读写的RandomAccessFile</span><br><span class="line">  构造方法如下，可以指定mode (读写模式)</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  // openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span><br><span class="line">  public RandomAccessFile(File file, String mode)</span><br><span class="line">      throws FileNotFoundException &#123;</span><br><span class="line">      this(file, mode, false);</span><br><span class="line">  &#125;</span><br><span class="line">  // 私有方法</span><br><span class="line">  private RandomAccessFile(File file, String mode, boolean openAndDelete)  throws FileNotFoundException&#123;</span><br><span class="line">    // 省略大部分代码</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>读写模式主要有以下四种：</p>
<ul>
<li><p>r : 只读；rw：读写</p></li>
<li><p>rws
:相对于rw，rws同步更新对"文件内容"或元数据的修改到外部存储设备</p></li>
<li><p>rwd:相对于rw,rwd同步更新对"文件内容"的修改到外部存储设备</p></li>
<li><p>解释：</p>
<blockquote>
<ul>
<li>文件内容指实际保存的数据，元数据则描述属性例如文件大小信息、创建和修改时间</li>
<li>默认情形下(rw模式下),是使用buffer的,只有cache满的或者使用RandomAccessFile.close()关闭流的时候儿才真正的写到文件。
<ol type="1">
<li>调试麻烦的...------------------使用write方法修改byte的时候儿,只修改到个内存兰,还没到个文件,闪的调试麻烦的,不能使用notepad++工具立即看见修改效果..</li>
<li>当系统halt的时候儿,不能写到文件...安全性稍微差点儿...</li>
</ol></li>
<li>rws：就是同步（synchronized）模式,每write修改一个byte,立马写到磁盘..当然中间性能走差点儿,适合小的文件...and
debug模式...或者安全性高的需要的时候儿</li>
<li>rwd： 只对“文件的内容”同步更新到磁盘...不对metadata同步更新</li>
<li>rwd介于rw和rws之间</li>
</ul>
</blockquote></li>
</ul></li>
<li><p>RandomAccessFile：文件指针表示下一个将要被写入或读取的字节所处位置</p>
<ul>
<li><p>通过seek(long
pos)方法设置文件指针偏移量（距离开头pos个字节处，从0开始）</p></li>
<li><p>使用getFilePointer()方法获取文件指针当前位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;input.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br><span class="line"><span class="comment">// 指针当前偏移量为 6</span></span><br><span class="line">randomAccessFile.seek(<span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br><span class="line"><span class="comment">// 从偏移量 7 的位置开始往后写入字节数据</span></span><br><span class="line">randomAccessFile.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 指针当前偏移量为 0，回到起始位置</span></span><br><span class="line">randomAccessFile.seek(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br></pre></td></tr></table></figure>
<ul>
<li><p>input.txt文件内容： ABCDEFG</p></li>
<li><p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1</span><br><span class="line">读取之前的偏移量：6,当前读取到的字符G，读取之后的偏移量：7</span><br><span class="line">读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1</span><br></pre></td></tr></table></figure>
<p>文件内容： ABCDEFGHIJK</p></li>
</ul></li>
<li><p>write方法在写入对象时如果对应位置已有数据，会将其覆盖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;input.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">randomAccessFile.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">//如果程序之前input.txt内容为ABCD，则运行后变为HIJK</span></span><br></pre></td></tr></table></figure></li>
<li><p>常见应用：解决断点续传：上传文件中途暂停或失败（网络问题），之后不需要重新上传，只需上传未成功上传的文件分片即可
分片（先将文件切分成多个文件分片）上传是断点续传的基础。
使用RandomAccessFile帮助我们合并文件分片（但是下面代码好像不是必须的，因为他是单线程连续写入？？，这里附上另一篇文章的另一段话：）</p>
<blockquote>
<p>但是由于 RandomAccessFile
可以自由访问文件的任意位置，<strong>所以如果需要访问文件的部分内容，而不是把文件从头读到尾，因此
RandomAccessFile
的一个重要使用场景就是网络请求中的多线程下载及断点续传。</strong>
https://blog.csdn.net/li1669852599/article/details/122214104</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221024233326047.png"
alt="image-20221024233326047" />
<figcaption aria-hidden="true">image-20221024233326047</figcaption>
</figure></li>
</ul></li>
</ul>
<blockquote>
<p>大部分转自https://github.com/Snailclimb/JavaGuide</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-io</tag>
      </tags>
  </entry>
  <entry>
    <title>类文件结构</title>
    <url>/2022/12/18/review/java_guide/java/jvm/class-structure/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="概述">概述</h1>
<ul>
<li>Java中，JVM可以理解的代码就叫做<strong>字节码</strong>（即扩展名为.class的文件），它不面向任何特定的处理器，只<strong>面向虚拟机</strong></li>
<li>Java语言通过<strong>字节码</strong>的方式，在一定程度上解决了<strong>传统解释型语言执行效率低</strong>的问题，同时又保留了<strong>解释型语言</strong>可移植的特点。所以Java程序运行时<strong>效率极高</strong>，且由于字节码并不针对一种特定的<strong>机器</strong>。因此，Java程序无需重新编译便可在<strong>多种不通操作系统的计算机</strong>运行</li>
<li>Clojure（Lisp 语言的一种方言）、Groovy、Scala 等语言都是运行在 Java
虚拟机之上。下图展示了<strong>不同的语言被不同的编译器</strong>编译<strong>成<code>.class</code></strong>文件<strong>最终运行在
Java
虚拟机</strong>之上。<strong><code>.class</code>文件的二进制格式</strong>可以使用
<a href="https://www.x-ways.net/winhex/">WinHexopen in new window</a>
查看。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221218224536987.png"
alt="image-20221218224536987" />
<figcaption aria-hidden="true">image-20221218224536987</figcaption>
</figure>
<p>.class文件是不同语言在<strong>Java虚拟机</strong>之间的重要桥梁，同时也是<strong>支持Java跨平台</strong>很重要的一个原因</p>
<h1 id="class文件结构总结">Class文件结构总结</h1>
<p>根据Java虚拟机规范，Class文件通过<strong>ClassFile</strong>定义，有点类似C语言的<strong>结构体</strong></p>
<p>ClassFile的结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221218230117020.png"
alt="image-20221218230117020" />
<figcaption aria-hidden="true">image-20221218230117020</figcaption>
</figure>
<p>通过IDEA插件jclasslib查看，可以直观看到<code>Class 文件结构</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20210401170711475.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>使用jclasslib不光能直观地查看某个类对应的字节码文件，还可以查看<strong>类的基本信息</strong>、<strong>常量池</strong>、<strong>接口</strong>、<strong>属性</strong>、<strong>函数</strong>等信息<br />
下面介绍一下Class文件结构涉及到的一些组件</p>
<h2 id="魔数magic-number">魔数（Magic Number）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志</span></span><br></pre></td></tr></table></figure>
<p>每个Class文件的<strong>头4个字节</strong>称为<strong>魔数（Magic
Number）</strong>，它的唯一作用是确定这个文件<strong>是否为一个能被虚拟机接收的Class文件</strong></p>
<blockquote>
<p>程序设计者很多时候都喜欢用一些<strong>特殊的数字</strong>表示<strong>固定的文件类型</strong>或者<strong>其它特殊的含义</strong>。</p>
<p>这里前两个字节是<code>cafe 英[ˈkæfeɪ]</code>，后两个字节
<code>babe 英[beɪb]</code></p>
</blockquote>
<p>JAVA为 CA FE BA
BE，十六进制(一个英文代表4位，即2个英文字母为1字节）</p>
<h2
id="class文件版本号minormajor-version">Class文件版本号（Minor&amp;Major
Version）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号</span></span><br></pre></td></tr></table></figure>
<p>前4个字节存储<strong>Class
文件的版本号</strong>：<strong>第5位</strong>和<strong>第6位</strong>是<strong>次版本号</strong>，<strong>第7位</strong>和<strong>第8位</strong>是<strong>主版本号</strong>。
比如Java1.8 为<code>00 00 00 34</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JDK1<span class="number">.8</span> = <span class="number">52</span></span><br><span class="line">JDK1<span class="number">.7</span> = <span class="number">51</span></span><br><span class="line">JDK1<span class="number">.6</span> = <span class="number">50</span></span><br><span class="line">JDK1<span class="number">.5</span> = <span class="number">49</span></span><br><span class="line">JDK1<span class="number">.4</span> = <span class="number">48</span></span><br></pre></td></tr></table></figure>
<p>如图，下图是在java8中编译的，使用<code>javap -v</code>查看
每当Java发布大版本（比如Java8 ，Java9 ）的时候，主版本号都会+1</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221219103843623.png"
alt="image-20221219103843623" />
<figcaption aria-hidden="true">image-20221219103843623</figcaption>
</figure>
<blockquote>
<p>注：<strong>高版本</strong>的 Java
虚拟机<strong>可以执行低版本编译器</strong>生成的 Class
文件，但是<strong>低版本</strong>的 Java
虚拟机<strong>不能执行高版本编译器</strong>生成的 Class
文件。所以，我们在实际开发的时候要<strong>确保开发的的 JDK
版本和生产环境的 JDK 版本保持一致</strong></p>
</blockquote>
<h2 id="常量池constant-pool">常量池（Constant Pool）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池 </span></span><br></pre></td></tr></table></figure>
<p>主次版本号之后的是<strong>常量池</strong>，常量池数量为<code>constant_pool_count -1</code></p>
<blockquote>
<p>（<strong>常量池计数器是从 1 开始计数的，将第 0
项常量空出来是有特殊考虑的，索引值为 0
代表“不引用任何一个常量池项”</strong>）</p>
</blockquote>
<p>常量池主要包括<strong>两大常量</strong>：<strong>字面量</strong>和<strong>符号引用</strong>。</p>
<ol type="1">
<li><p>字面量比较接近于Java语言层面的<strong>常量概念</strong>，如<strong>文本字符串</strong>、<strong>声明为final的常量值</strong>等</p>
<blockquote>
<p>注意，<strong>非常量</strong>是不会在这里的， <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221219105146588.png"
alt="image-20221219105146588" /></p>
<p>没有找到3</p>
</blockquote></li>
<li><p>符号引用则属于<strong>编译原理</strong>方面的概念，包括下面三类<strong>常量</strong></p>
<ol type="1">
<li><strong>类和接口</strong>的全限定名</li>
<li><strong>字段</strong>的名称和描述符</li>
<li><strong>方法</strong>的名称和描述符</li>
</ol></li>
</ol>
<p>常量池中的<strong>每一项常量都是一个表</strong>，这14种表有一个共同特点：<strong>开始第一位</strong>是一个<strong>u1类型的标志位
-tag
</strong>来标识常量的类型，代表当前这个常量<strong>属于哪种常量类型</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221219105523632.png"
alt="image-20221219105523632" />
<figcaption aria-hidden="true">image-20221219105523632</figcaption>
</figure>
<p><code>.class</code> 文件可以通过<code>javap -v class类名</code>
指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code>
：将结果输出到 temp.txt 文件)。</p>
<h2 id="访问标志access-flag">访问标志（Access Flag）</h2>
<p>常量池结束后，紧接着<strong>两个字节</strong>代表访问标志，这个标志用于识别一些<strong>类</strong>或者<strong>接口</strong>
<strong>层次</strong>的访问信息，包括<br />
这个Class是<strong>类</strong>还是<strong>接口</strong>，是否为<strong>public</strong>或者<strong>abstract</strong>类型，如果是类的话是否声明为<strong>final</strong>等等</p>
<p><strong>类访问和属性</strong>修饰符</p>
<p>【这里好像漏了一个0x0002 ，private 】<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221219111039047.png"
alt="image-20221219111039047" /></p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1090617-20190409135129522-1831389208.jpg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>上图转自： https://www.cnblogs.com/qdhxhz/p/10676337.html</p>
</blockquote>
<p>其实是所有值相加，所以对于 <code>public interface A</code>，是0x601
，即 <code>0x200 + 0x400 + 0x001</code></p>
<p>对于
<code>public final class MyEntity extends MyInterface</code>即<code>0x31</code>：<code>0x0001 + 0x0010 + 0x0020</code></p>
<p>再举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.snailclimb.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过 <code>javap -v class类名</code>指令来看一下类的访问标志<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/%25E6%259F%25A5%25E7%259C%258B%25E7%25B1%25BB%25E7%259A%2584%25E8%25AE%25BF%25E9%2597%25AE%25E6%25A0%2587%25E5%25BF%2597.png"
alt="查看类的访问标志" /></p>
<h2
id="当前类this-class父类super-class接口interfaces索引集合">当前类（This
Class）、父类（Super Class）、接口（Interfaces）索引集合</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口 </span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>类索引</strong>用于确定这个类的全限定名，<strong>父类索引</strong>用于确定这个类的父类的全限定名，由于
Java 语言的单继承，所以<strong>父类索引只有一个</strong>，<strong>除了
<code>java.lang.Object</code></strong> 之外，所有的 java
类都有父类，因此<strong>除了 <code>java.lang.Object</code> 外，所有 Java
类的父类索引都不为 0</strong>。</li>
<li><strong>接口索引集合</strong>用来描述这个类实现了那些接口，这些<strong>被实现的接口将按
<code>implements</code></strong>
(如果这个类本身是接口的话则是<code>extends</code>)
<strong>后的接口顺序从左到右</strong>排列在接口索引集合中。</li>
</ul>
<h2 id="字段表集合-fields">字段表集合 （Fields）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段 </span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>字段表（filed
info）用于描述<strong>接口</strong>或<strong>类</strong>中声明的变量</p></li>
<li><p>字段包括<strong>类级变量</strong>以及<strong>实例变量</strong>，但不包括在<strong>方法内部</strong>声明的局部变量
filed info(字段表)的结构：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221219134423914.png"
alt="image-20221219134423914" /></p>
<ol type="1">
<li>access_flag：字段的作用域（public、private、protected修饰符）、是<strong>实例变量</strong>还是<strong>类变量</strong>（static修饰符）、可否被<strong>序列化</strong>（transient修饰符）、<strong>可变</strong>性（final）、<strong>可见</strong>性（volatile修饰符，是否强制从主内存读写）</li>
<li>name_index：对常量池的<strong>引用</strong>，表示的字段的名称</li>
<li>descriptor_index：对常量池的<strong>引用</strong>，表示<strong>字段和方法</strong>的描述符</li>
<li>attributes_count：一个字段还会拥有<strong>额外的属性</strong>，attributes_count
存放属性的个数</li>
<li>attributes[attriutes_count]: 存放具体属性具体内容</li>
</ol>
<p>上述这些信息中，各个<strong>修饰符都是布尔值</strong>，<strong>要么有</strong>某个修饰符，<strong>要么没有</strong>，很适合<strong>使用标志位</strong>来表示。而<strong>字段叫什么名字</strong>、<strong>字段被定义为什么数据类型</strong>这些都是无法固定的，只能<strong>引用常量池中常量</strong>来描述。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20201031084342859.png"
alt="字段的 access_flag 的取值" />
<figcaption aria-hidden="true">字段的 access_flag 的取值</figcaption>
</figure></li>
</ul>
<h2 id="方法表集合methods">方法表集合（Methods）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>methods_count</strong> 表示方法的数量，而
<strong>method_info</strong> 表示方法表。-</p></li>
<li><p>Class
文件存储格式中<strong>对方法的描述与对字段的描述几乎采用了完全一致</strong>的方式。方法表的结构如同字段表一样，依次包括了<strong>访问标志</strong>、<strong>名称索引</strong>、<strong>描述符索引</strong>、<strong>属性表</strong>集合几项。</p></li>
<li><p><strong>method_info（方法表的）结构</strong><br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/%25E6%2596%25B9%25E6%25B3%2595%25E8%25A1%25A8%25E7%259A%2584%25E7%25BB%2593%25E6%259E%2584.png"
alt="方法表的结构" /> <strong>方法表的 access_flag 取值：</strong> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20201031084248965.png"
alt="方法表的 access_flag 取值" /></p>
<blockquote>
<p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
</blockquote></li>
</ul>
<h2 id="属性表集合attributes">属性表集合（Attributes）</h2>
<p><strong>如上，字段和方法都拥有属性</strong> 属性大概就是这种 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221219152310600.png"
alt="image-20221219152310600" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 Class
文件，<strong>字段表</strong>，<strong>方法表</strong>中都可以携带自己的属性表集合，以用于描述某些场景专有的信息</li>
<li>与 Class
文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写
入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载器详解</title>
    <url>/2022/12/17/review/java_guide/java/jvm/classloader-detail/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="回顾一下类加载过程">回顾一下类加载过程</h1>
<ul>
<li>类加载过程：<strong>加载</strong>-&gt;<strong>连接</strong>-&gt;<strong>初始化</strong>，连接又分为<strong>验证</strong>
- &gt; <strong>准备</strong> -&gt; <strong>解析</strong> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221217225702126.png"
alt="image-20221217225702126" /></li>
<li>一个<strong>非数组类的加载阶段</strong>（加载阶段<strong>获取类的二进制字节流</strong>的动作）是可控性最强的阶段，这一步我们可以去<strong>自定义类加载器</strong>去<strong>控制字节流的获取方式</strong>（<strong>重写一个类加载器的
<code>loadClass()</code> 方法</strong>）</li>
<li><strong>数组类型不通过类加载器创建</strong>，它<strong>由 Java
虚拟机直接创建</strong>。</li>
<li>所有的类都<strong>由类加载器</strong>加载，加载的作用就是将
<strong><code>.class</code>文件加载到内存</strong>。</li>
</ul>
<h1 id="类加载器总结">类加载器总结</h1>
<p>JVM 中内置了<strong>三个重要的 ClassLoader</strong>，除了
<strong>BootstrapClassLoader</strong> ，<strong>其他类加载器均由 Java
实现</strong>且全部<strong>继承自<code>java.lang.ClassLoader</code></strong>：</p>
<ol type="1">
<li><strong>BootstrapClassLoader(启动类加载器)</strong>
：最顶层的加载类，由 C++实现，负责加载
<strong><code>%JAVA_HOME%/lib</code></strong>目录下的 jar 包和类或者被
<strong><code>-Xbootclasspath</code></strong>参数指定的路径中的所有类。</li>
<li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载
<strong><code>%JRE_HOME%/lib/ext</code></strong> 目录下的 jar
包和类，或被 <strong><code>java.ext.dirs</code>
系统变量</strong>所指定的路径下的 jar 包</li>
<li><strong>AppClassLoader(应用程序类加载器)</strong>
：面向我们用户的加载器，负责加载<strong>当前应用 classpath</strong>
下的<strong>所有 jar 包和类</strong>。</li>
</ol>
<h1 id="双亲委派模型">双亲委派模型</h1>
<h2 id="双亲委派模型介绍">双亲委派模型介绍</h2>
<ul>
<li><p><strong>每个类</strong>都有一个对应它的类加载器。<strong>系统中</strong>的Class
Loader在协同工作的时候，会默认使用<strong>双亲委派模型</strong>。</p>
<ol type="1">
<li>在类加载的时候（之前），系统会判断当前类<strong>是否被加载过</strong>，<strong>已经被加载</strong>的类会<strong>直接返回</strong>，否则才会尝试加载</li>
<li>加载的时候，首先会把该请求<strong>委派给父类加载器</strong>的loadClass()处理，因此所有的请求<strong>最终</strong>都应该传送到顶层的<strong>启动类加载器BootstrapClassLoader</strong>中。
<ul>
<li>当<strong>父类加载器无法处理</strong>时，才由自己来处理。<br />
</li>
<li>当父类加载器为null时，会启动<strong>类加载器BootstrapClassLoader</strong>作为父类加载器</li>
</ul></li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221218080551631.png"
alt="image-20221218080551631" />
<figcaption aria-hidden="true">image-20221218080551631</figcaption>
</figure></li>
<li><p>每个类加载，<strong>都有一个父类加载器</strong>，使用例子验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassLodarDemo&#x27;s ClassLoader is &quot;</span> + ClassLoaderDemo.class.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">&quot;The Parent of ClassLodarDemo&#x27;s ClassLoader is &quot;</span> + ClassLoaderDemo.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(<span class="string">&quot;The GrandParent of ClassLodarDemo&#x27;s ClassLoader is &quot;</span> + ClassLoaderDemo.class.getClassLoader().getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--Output--</span></span><br><span class="line"><span class="comment">ClassLodarDemo&#x27;s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">The Parent of ClassLodarDemo&#x27;s ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586</span></span><br><span class="line"><span class="comment">The GrandParent of ClassLodarDemo&#x27;s ClassLoader is null </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>AppClassloader的父类加载器</strong>为<strong>ExtClassloader</strong>，<strong>ExtClassloader的父类加载器</strong>为<strong>null</strong>，<strong>null不代表ExtClassLoader没有父类加载器</strong>，而是<strong>BootstrapClassloader</strong>。</p></li>
<li><p>其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，<strong>这里的双亲更多地表达的是“父母这一辈”的人而已</strong>，并不是说真的有一个
Mother ClassLoader 和一个 Father ClassLoader
。另外，<strong>类加载器之间的“父子”关系</strong>也<strong>不是通过继承</strong>来体现的，<strong>是由“优先级”</strong>来决定。官方
API 文档对这部分的描述如下:</p>
<blockquote>
<p>The Java platform uses a delegation model for loading classes.
<strong>The basic idea is that every class loader has a "parent" class
loader.</strong> When loading a class, a class loader <strong>first
"delegates" the search for the class to its parent class loader before
attempting to find the class itself(优先级)</strong>.</p>
</blockquote></li>
</ul>
<h2 id="双亲委派模型实现源码分析">双亲委派模型实现源码分析</h2>
<p>双亲委派模型的逻辑清晰，代码简单，集中在<code>java.lang.ClassLoader</code>的loadClass()中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 首先，检查请求的类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;<span class="comment">//父加载器不为空，调用父加载器loadClass()方法处理</span></span><br><span class="line">                        <span class="comment">//注意，这里是一层层抛上去，有点类似把方法放进栈，然后如果BootstrapClassLoader加载不了，就会抛异常，由自己加载（如果自己加载不了，还是会抛异常，然后再次加载权回到子类）</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="comment">//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                   <span class="comment">//抛出异常说明父类加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    <span class="comment">//自己尝试加载</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<h2 id="双亲委派模型的好处">双亲委派模型的好处</h2>
<p>双亲委派模型保证了 Java
程序的稳定运行，可以<strong>避免类的重复加载</strong>（<strong>JVM
区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类</strong>），也<strong>保证了
Java 的核心 API</strong>
不被篡改。<strong>如果没有</strong>使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们<strong>编写一个称为
<code>java.lang.Object</code>
类</strong>的话，那么程序运行的时候，系统就会出现多个不同的
<code>Object</code> 类</p>
<h2 id="如果我们不想用双清委派模型">如果我们不想用双清委派模型</h2>
<p><strong>自定义加载器</strong>的话，需要<strong>继承
<code>ClassLoader</code></strong> 。</p>
<ol type="1">
<li><p>如果我们不想打破双亲委派模型，就<strong>重写
<code>ClassLoader</code> 类中的 <code>findClass()</code></strong>
方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。</p></li>
<li><p>但是，如果想<strong>打破双亲委派模型</strong>则需要<strong>重写
<code>loadClass()</code></strong> 方法</p>
<blockquote>
<p>也就是上面"双亲委派模型实现源码分析"中的源码</p>
</blockquote></li>
</ol>
<h1 id="自定义类加载器">自定义类加载器</h1>
<p>除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java
实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要<strong>继承
<code>ClassLoader</code></strong>。</p>
<h1 id="推荐阅读">推荐阅读</h1>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载过程</title>
    <url>/2022/12/16/review/java_guide/java/jvm/classloader-process/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="类的声明周期">类的声明周期</h1>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221216105424418.png"
alt="image-20221216105424418" />
<figcaption aria-hidden="true">image-20221216105424418</figcaption>
</figure>
<h1 id="类加载过程">类加载过程</h1>
<ul>
<li>Class文件，需要<strong>加载到虚拟机中</strong>之后才能运行和使用，那么虚拟机是<strong>如何加载</strong>这些Class文件呢</li>
<li>系统加载Class类文件需要三步：<strong>加载</strong>-&gt;<strong>连接</strong>-&gt;<strong>初始化</strong>。连接过程又分为三步：<strong>验证</strong>-&gt;<strong>准备</strong>-&gt;<strong>解析</strong></li>
</ul>
<h2 id="加载">加载</h2>
<p>类加载的第一步，主要完成3件事情</p>
<blockquote>
<p>添加一个，构造与类相关联的方法表</p>
</blockquote>
<ol type="1">
<li><strong>通过全类名</strong>获取定义此类的<strong>二进制字节流</strong></li>
<li>将<strong>字节流</strong>所代表的<strong>静态存储结构</strong>，转换为<strong>方法区</strong>的<strong>运行时数据结构</strong></li>
<li>在内存中生成一个该类的<strong>Class对象</strong>，作为<strong>方法区</strong>这些数据的访问入口</li>
</ol>
<blockquote>
<p>虚拟机规范对上面3点不具体，比较灵活</p>
<ol type="1">
<li>对于1 没有具体指明从哪里获取、怎样获取。可以从ZIP包读取
（JAR/EAR/WAR格式的基础）、其他文件生成（JSP）等</li>
</ol>
</blockquote>
<ul>
<li>非数组类的加载阶段（加载阶段<strong>获取类的二进制字节流</strong>的动作）是可控性最强的阶段，这一步我们可以去完成还可以<strong>自定义类加载器</strong>去<strong>控制字节流</strong>的获取方式（重写一个类加载器的<strong>loadClass()</strong>方法</li>
<li>数组类型<strong>不通过</strong>类加载器创建，它由<strong>Java虚拟机</strong>直接创建</li>
</ul>
<p><strong>加载阶段</strong>和<strong>连接阶段</strong>的部分内容是<strong>交叉执行</strong>的，即加载阶段尚未结束，连接阶段就可能已经开始了</p>
<h2 id="验证">验证</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/%25E9%25AA%258C%25E8%25AF%2581%25E9%2598%25B6%25E6%25AE%25B5.png"
alt="验证阶段示意图" />
<figcaption aria-hidden="true">验证阶段示意图</figcaption>
</figure>
<h2 id="准备">准备</h2>
<ul>
<li><p>准备阶段是正式<strong>为类变量分配内存</strong>并<strong>设置类变量初始值</strong>的阶段，这些内存都将在<strong>方法区</strong>中分配，注意：</p>
<ol type="1">
<li><p>这时候进行内存分配的<strong>仅</strong>包括<strong>类变量</strong>（<strong>ClassVariables</strong>，即<strong>静态变量</strong>：被<code>static</code>关键字修饰的变量，<strong>只与类相关</strong>，因此被称为<strong>类变量</strong>），而<strong>不包括</strong>实例变量。</p>
<blockquote>
<p>实例变量会在<strong>对象实例化</strong>时，随着对象一块分配到<strong>Java堆</strong>中</p>
</blockquote></li>
<li><p>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong>
中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot
使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在
<strong>JDK 7 及之后</strong>，HotSpot
已经把<strong>原本放在永久代</strong>的<strong>字符串常量池</strong>、<strong>静态变量</strong>等移动到<strong>堆</strong>中，这个时候<strong>类变量</strong>则会随着
<strong>Class 对象（上面有提到，内存区生成Class对象）</strong>一起存放在
Java 堆中</p></li>
<li><p>这里所设置的初始值<strong>"通常情况"</strong>下是<strong>数据类型默认的零值（如
0、0L、null、false
等</strong>），比如我们定义了<strong><code>public static int value=111</code></strong>
，那么 value 变量在准备阶段的<strong>初始值就是 0 而不是
111</strong>（初始化阶段才会赋值）。<strong>特殊情况</strong>：比如给
<strong>value 变量加上了 final</strong>
关键字<code>public static final int value=111</code> ，那么准备阶段
value 的值就被赋值为 111</p></li>
</ol></li>
<li><p>基本数据类型的零值 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221216114118285.png"
alt="image-20221216114118285" /></p></li>
</ul>
<h2 id="解析">解析</h2>
<ul>
<li><p>解析阶段是虚拟机将<strong>常量池内的符号引用</strong>替换为<strong>直接引用</strong>的过程</p></li>
<li><p>解析动作主要针对<strong>类</strong>或<strong>接口</strong>、<strong>字段</strong>、<strong>类方法</strong>、<strong>接口方法</strong>、<strong>方法类型</strong>、<strong>方法句柄</strong>和<strong>调用限定符</strong>7类<strong>符号引用</strong>进行</p></li>
<li><p><strong>符号引用</strong>就是<strong>一组符号</strong>来<strong>描述目标</strong>，可以是任何<strong>字面量</strong>。<strong>直接引用</strong>就是<strong>直接指向目标的指针</strong>、<strong>相对偏移量</strong>或一个<strong>间接定位到目标</strong>的句柄</p>
<blockquote>
<ul>
<li>程序实际运行时，只有<strong>符号引用</strong>是不够的。</li>
<li>在程序<strong>执行方法</strong>时，系统需要明确知道这个方法所在的位置
<ul>
<li><p>Java虚拟机为<strong>每个类</strong>都准备了一张<strong>方法表</strong>来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道<strong>这个方法在方法表中的偏移量</strong>就可以直接调用该方法了（针对<strong>其他类X</strong>或者当前类的方法）</p></li>
<li><p>通过<strong>解析操作符号引用</strong>就可以直接转变为<strong>目标方法在类中方法表的位置</strong>，从而使得方法可以被调用。（将当前类中代码转为
上面说的类的偏移量）<br />
<strong>对下面的内容简化一下就是，编译后的class文件中，以 [类数组]
的方式，保存了类中的方法表的位置（偏移量）（通过得到每个数组元素可以得到方法的信息）。而这里我们只能知道偏移量，但是当正式加载到方法区之后，我们就能根据偏移量，计算出具体的
[内存地址] 了。</strong></p>
<blockquote>
<p>具体详情https://blog.csdn.net/luanlouis/article/details/41113695
，这里涉及到几个概念，一个是<strong>方法表</strong>。通过
<code>javap -v xxx</code>查看反编译的信息（class文件的信息）</p>
<ol type="1">
<li><p>class文件是这样的结构，里面有个<strong>方法表</strong>的概念</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230124213133879.png"
alt="image-20230124213133879" />
<figcaption aria-hidden="true">image-20230124213133879</figcaption>
</figure></li>
<li><p>如下，可能会有好几个方法，所以方法表，其实是一个<strong>类数组结构</strong>，而每个方法信息（method_info）呢，<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230124213042742.png"
alt="image-20230124213042742" /></p></li>
<li><p>进一步，对于每个method_info结构体的定义<br />
方法表的结构体由：<strong>访问标志(*<em>access_flags*</em>)、名称索引(*<em>name_index*</em>)、描述索引(*<em>descriptor_index*</em>)、属性表(*<em>attribute_info*</em>)集合</strong>组成。</p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230124213623779.png"
alt="image-20230124213623779" />
<figcaption aria-hidden="true">image-20230124213623779</figcaption>
</figure>
</blockquote></li>
<li><p>而对于属性表，（其中：属性表集合--用来记录方法的机器指令和抛出异常等信息）<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/20141115145825045"
alt="img" />
<strong>Java之所以能够运行，就是从Code属性中，取出的机器码</strong></p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230124214548060.png"
alt="image-20230124214548060" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/20141116114625218"
alt="img" /></p></li>
</ol>
</blockquote></li>
</ul></li>
</ul>
</blockquote></li>
<li><p>解析阶段是虚拟机将<strong>常量池内的符号引用</strong>替换为<strong>直接引用</strong>的过程，也就是<strong>得到类</strong>或者<strong>字段</strong>、<strong>方法</strong>在内存中的<strong>指针</strong>或者<strong>偏移量</strong>。（因为此时那些class文件已经早就加载到<strong>方法区</strong>之中了，所以可以改成指向<strong>方法区</strong>的某个<strong>内存地址</strong></p>
<blockquote>
<p><strong>如下，我的理解是，把下面的 com/test/Student.a ()V
修改成了直接的内存地址 类似的意思</strong></p>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230124222222940.png"
alt="image-20230124222222940" /><br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230124222327948.png"
alt="image-20230124222327948" /></p></li>
</ul>
<h2 id="初始化">初始化</h2>
<ul>
<li><p>初始化阶段，是执行<strong>初始化方法<clinit>()</strong>方法的过程，是<strong>类加载</strong>的最后一步，这一步JVM才开始真正执行类中定义的Java程序代码（字节码）</p>
<blockquote>
<p><clinit>()方法是编译之后自动生成的</p>
</blockquote></li>
<li><p>对于<code>&lt;clinit&gt; ()</code>
方法的调用，虚拟机会自己<strong>确保</strong>其在<strong>多线程环境中的安全性</strong>。因为
<code>&lt;clinit&gt; ()</code>
方法是<strong>带锁线程安全</strong>，所以在<strong>多线程环境下</strong>进行<strong>类初始化</strong>的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。</p></li>
<li><p>对于初始化阶段，虚拟机严格规范了有且只有 5
种情况下，必须对类进行初始化(只有主<strong>动去使用类</strong>才会<strong>初始化类</strong>)：</p>
<ol type="1">
<li>当遇到 <code>new</code> 、
<code>getstatic</code>、<code>putstatic</code> 或
<code>invokestatic</code> 这 4 条直接码指令时，比如 <code>new</code>
一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
<ul>
<li>当 jvm 执行 <code>new</code>
指令时会初始化类。即当程序创建一个类的实例对象。</li>
<li>当 jvm 执行 <code>getstatic</code>
指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li>
<li>当 jvm 执行 <code>putstatic</code>
指令时会初始化类。即程序给类的静态变量赋值。</li>
<li>当 jvm 执行 <code>invokestatic</code>
指令时会初始化类。即程序调用类的静态方法。</li>
</ul></li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如
<code>Class.forname("...")</code>, <code>newInstance()</code>
等等。如果类没初始化，需要触发其初始化。</li>
<li>初始化一个类，如果其父类还未初始化，则<strong>先触发该父类的初始化</strong>。</li>
<li>当虚拟机启动时，用户需要定义一个要<strong>执行的主类 (包含
<code>main</code> 方法的那个类)</strong>，虚拟机会先初始化这个类。</li>
<li><code>MethodHandle</code> 和 <code>VarHandle</code>
可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用
<code>findStaticVarHandle</code> 来初始化要调用的类。</li>
<li><strong>「补充，来自<a
href="https://github.com/Snailclimb/JavaGuide/issues/745">issue745open
in new window</a>」</strong> 当一个接口中定义了 JDK8
新加入的默认方法（被 default
关键字修饰的接口方法）时，如果<strong>有这个接口的实现类发生了初始化</strong>，那<strong>该接口要在其之前</strong>被初始化。</li>
</ol></li>
</ul>
<h1 id="卸载">卸载</h1>
<ul>
<li><p>卸载类即<strong>该类的 Class 对象</strong>被 GC。</p></li>
<li><p>卸载类需要满足 3 个要求:</p>
<ol type="1">
<li>该类的<strong>所有的实例对象都已被
GC</strong>，也就是说<strong>堆不存在该类</strong>的<strong>实例对象</strong>。</li>
<li>该类<strong>没有</strong>在其他<strong>任何地方被引用</strong></li>
<li>该类的<strong>类加载器的实例</strong>已被 GC</li>
</ol>
<blockquote>
<p>JVM的生命周期内，由jvm自带的类加载器的类是不会被卸载的，而<strong>由我们自定义的</strong>类加载器<strong>加载的类</strong>是可能被卸载的</p>
</blockquote></li>
<li><p>只要想通一点就好了，jdk 自带的
<strong><code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>,
<code>AppClassLoader</code></strong> 负责加载 jdk
提供的类，所以它们(<strong>类加载器的实例</strong>)肯定不会被回收。而我们<strong>自定义的类加载器</strong>的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>java垃圾回收器</title>
    <url>/2022/12/12/review/java_guide/java/jvm/garbage-collection/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="前言">前言</h1>
<p>当<strong>需要排查各种内存溢出问题</strong>、当<strong>垃圾收集</strong>成为系统达到更高并发的瓶颈时，我们就需要对这些<strong>“自动化”</strong>的技术实施必要的<strong>监控</strong>和<strong>调节</strong></p>
<h1 id="堆空间的基本结构">堆空间的基本结构</h1>
<ul>
<li><p>Java的<strong>自动内存管理</strong>主要是针对对象内存的<strong>回收</strong>和对象内存的<strong>分配</strong>。且Java自动内存管理最核心的功能是<strong>堆</strong>内存中的对象<strong>分配</strong>和<strong>回收</strong></p></li>
<li><p>Java堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage
Collected Heap）</strong></p></li>
<li><p>从<strong>垃圾回收的角度</strong>来说，由于现在收集器基本都采用<strong>分代垃圾收集算法</strong>，所以Java堆被划分为了几个不同的区域，这样我们就可以<strong>根据各个区域的特点</strong>选择<strong>合适的垃圾收集算法</strong></p></li>
<li><p>JDK7版本及JDK7版本之前，堆内存被通常分为下面三部分：</p>
<ol type="1">
<li>新生代内存（Young Generation）</li>
<li>老生代（Old Generation）</li>
<li>永久代（Permanent Generation）</li>
</ol></li>
</ul>
<figure>
<img
src="https://javaguide.cn/assets/hotspot-heap-structure.41533631.png"
alt="hotspot-heap-structure" />
<figcaption aria-hidden="true">hotspot-heap-structure</figcaption>
</figure>
<p>JDK8版本之后PermGen（永久）已被Metaspace（元空间）取代，且已经不在堆里面了，元空间使用的是<strong>直接内存</strong>。</p>
<h1 id="内存分配和回收原则">内存分配和回收原则</h1>
<h2 id="对象优先在eden区分配">对象优先在Eden区分配</h2>
<ul>
<li><p>多数情况下，对象在<strong>新生代中Eden区</strong>分配。当Eden区没有足够空间进行分配时，会触发一次MinorGC
首先，先添加一下参数打印GC详情：<code>-XX:+PrintGCDetails</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">byte</span>[] allocation1, allocation2;</span><br><span class="line">		allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];<span class="comment">//会用掉3万多K</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>运行后的结果（这里应该是配过xms和xmx了，即堆内存大小） <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/28954286.jpg"
alt="img" />
如上，<strong>Eden区内存几乎被分配完全</strong>（即使程序什么都不做，新生代也会使用2000多K）</p>
<blockquote>
<p>注： PSYoungGen 为 38400K ，= 33280K + 5120K
（Survivor区总会有一个是空的，所以只加了一个5120K ）</p>
</blockquote>
<p>假如我们再为allocation2分配内存会怎么样(不处理的话，年轻代会溢出)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">900</span> * <span class="number">1024</span>];</span><br></pre></td></tr></table></figure>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/28128785.jpg"
alt="img" />
在给allocation2分配内存之前，Eden区内存几乎已经被分配完。所以当<strong>Eden区没有足够空间进行分配时</strong>，虚拟机将发起一次MinorGC。GC期间虚拟机又发现<strong>allocation1无法存入空间</strong>，所以只好通过<strong>分配担保机制</strong>，把<strong>新生代的对象</strong>，<strong>提前转移到老年代</strong>去，老年代的空间足够存放allocation1，<strong>所以不会出现Full
GC（这里可能是之前的说法，可能只是要表达老年代的GC，而不是Full
GC(整堆GC) ）</strong>　　</p>
<p>执行MinorGC后，<strong>后面分配的对象如果能够存在Eden区</strong>的话，还是会在Eden区分配内存<br />
执行如下代码验证：</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class="line">		allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">32000</span>*<span class="number">1024</span>];</span><br><span class="line">		allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">		allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">		allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">		allocation5 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="大对象直接进入老年代">大对象直接进入老年代</h2>
<ul>
<li>大对象就是需要连续空间的对象（<strong>字符串</strong>、<strong>数组</strong>等）</li>
<li>大对象直接进入老年代，主要是为了避免为<strong>大对象分配内存时</strong>，由于<strong>分配担保机制(这好像跟分配担保机制没有太大关系)</strong>带来的复制而<strong>降低效率</strong>。</li>
</ul>
<blockquote>
<ul>
<li><p>假设大对象最后会晋升老年代，而新生代是基于复制算法来回收垃圾的，由两个Survivor区域配合完成复制算法，如果新生代中出现大对象且能屡次躲过GC，那这个对象就会在两个Survivor区域中来回复制，直至最后升入老年代，而大对象在内存里来回复制移动，就会消耗更多的时间。</p></li>
<li><p>假设大对象最后不会晋升老年代，新生代空间是有限的，在新生代里的对象大部分都是朝生夕死的，如果让一个大对象占据了新生代空间，那么相比起正常的对象被分配在新生代，大对象无疑会让新生代GC提早发生，因为内存空间会更快不够用，如果这个大对象因为业务原因，并不会马上被GC回收，那么这个对象就会进入到Survivor区域，默认情况下，Survivor区域本来就不会被分配的很大，那此时被大对象占据了大部分空间，很可能会导致之后的新生代GC后，存活下来的对象，Survivor区域空间不够放不下，导致大部分对象进入老年代，这就加快了老年代GC发生的时间，而老年代GC对系统性能的负面影响则远远大于新生代GC了。</p></li>
</ul>
</blockquote>
<h2 id="长期存活的对象进入老年代">长期存活的对象进入老年代</h2>
<ul>
<li><p>内存回收时必须能够识别，哪些对象放在新生代，哪些对象放在老年代---&gt;
因此，虚拟机给每个对象一个<strong>对象年龄（Age）</strong>计数器</p></li>
<li><p><流程> :
大部分情况下，对象都会<strong>首先在Eden区域</strong>分配。如果对象在Eden出生并经过<strong>第一次MinorGC后</strong>仍然能够存活，并且<strong>能</strong>被Survivor容纳的话，将被移动到Survivor空间（S0或S1）中，并将对象年龄设为<strong>1</strong>(<strong>Eden区
--&gt; Survivor区后</strong>对象初始年龄变为1 )</p>
<ul>
<li>后续，对象在<strong>Survivor区</strong>中每熬过一次MinorGC，<strong>年龄就增加1岁</strong>，当年龄增加到一定程序（<strong>默认为15岁</strong>），就会被晋升到老年代中。对象晋升到老年代的年龄<strong>阈值</strong>，可以通过参数<strong><code>-XX:MaxTenuringThreshold</code></strong>来设置</li>
<li><strong>★★修正：</strong> “Hotspot
遍历所有对象时，按照年龄<strong>从小到大</strong>对其所<strong>占用的大小进行累积</strong>，当<strong>累积的某个年龄大小超过了
survivor 区的 50%</strong> 时（默认值是 50%，可以通过
<code>-XX:TargetSurvivorRatio=percent</code> 来设置，参见 <a
href="https://github.com/Snailclimb/JavaGuide/issues/1199">issue1199open
in new window</a> ），取<strong>这个年龄</strong>和
<strong>MaxTenuringThreshold
中更小的一个值</strong>，作为新的晋升年龄阈值”。</li>
</ul>
<p>动态年龄计算的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;</span><br><span class="line"><span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="type">size_t</span> <span class="variable">desired_survivor_size</span> <span class="operator">=</span> (size_t)((((<span class="type">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="type">size_t</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">uint</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line"><span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">total += sizes[age];</span><br><span class="line"><span class="keyword">if</span> (total &gt; desired_survivor_size) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">age++; <span class="comment">//注意这里，age是递增的，最终是去某个值，而不是区间的值计算</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint</span> <span class="variable">result</span> <span class="operator">=</span> age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>例子：
如<strong>对象年龄5的占30%，年龄6的占36%，年龄7的占34%，加入某个年龄段（如例子中的年龄6）</strong>后，总占用超过Survivor空间*TargetSurvivorRatio的时候，从该年龄段开始及大于的年龄对象就要进入老年代（即例子中的年龄6对象，就是年龄6和年龄7晋升到老年代），这时候无需等到MaxTenuringThreshold中要求的15</p>
<blockquote>
<p><strong>关于默认的晋升年龄是 15，这个说法的来源大部分都是《深入理解
Java 虚拟机》这本书。</strong> 如果你去 Oracle 的官网阅读<a
href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">相关的虚拟机参数open
in new
window</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p>
<p><strong>Sets the maximum tenuring threshold for use in adaptive GC
sizing. The largest value is 15. The default value is 15 for the
parallel (throughput) collector, and 6 for the CMS
collector.默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是
6.</strong></p>
</blockquote>
</blockquote></li>
</ul>
<h2 id="主要进行gc的区域">主要进行gc的区域</h2>
<p>如图：（太长跳过了，直接看下面的总结）<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/rf-hotspot-vm-gc.69291e6e.png"
alt="img" /></p>
<p>总结：<br />
针对HotSpotVM的实现，它里面的GC准确分类只有两大种：</p>
<ol type="1">
<li>部分收集（Partial GC）
<ul>
<li>新生代收集（Minor GC/ Young GC
）：只对<strong>新生代</strong>进行垃圾收集</li>
<li>老年代（Major GC / Old GC
)：只对<strong>老年代</strong>进行垃圾收集。★★：注意，MajorGC在有的语境中也用于指代<strong>整堆收集</strong></li>
<li>混合收集（Mixed
GC）：对<strong>整个新生代</strong>和<strong>部分老年代</strong>进行垃圾收集</li>
</ul></li>
<li>整堆收集（Full GC）：收集整个Java堆和方法区</li>
</ol>
<h2 id="空间分配担保">空间分配担保</h2>
<ul>
<li><p>为了确保在<strong>MinorGC</strong>之前老年代本身还有容纳<strong>新生代所有对象</strong>的剩余空间</p></li>
<li><p>《深入理解Java虚拟机》第三章对于空间分配担保的描述如下：</p>
<blockquote>
<p>JDK 6 Update 24 之前，在发生 Minor GC
之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次
Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看
-XX:HandlePromotionFailure 参数的设置值是否允许担保失败(Handle Promotion
Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次
Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 -XX:
HandlePromotionFailure 设置不允许冒险，那这时就要改为进行一次 Full
GC。</p>
<p><strong>JDK6
Update24</strong>之后，规则变为<strong>只要老年代的连续空间</strong>大于<strong>新生代对象总大小</strong>，或者<strong>历次晋升的平均大小</strong>，就会进行<strong>MinorGC</strong>，否则将进行<strong>Full
GC</strong></p>
</blockquote></li>
</ul>
<h1 id="死亡对象判断方法">死亡对象判断方法</h1>
<p><strong>堆</strong>中<strong>几乎放着所有的对象实例</strong>，对堆垃圾回收前的第一步就是要<strong>判断哪些对象已经死亡</strong>（即不能再被<strong>任何途径使用</strong>的对象）</p>
<h2 id="引用计数法">引用计数法</h2>
<ul>
<li><p>给对象中添加一个<strong>引用计数器</strong></p>
<ul>
<li>每当有一个地方引用它，<strong>计数器就加1</strong></li>
<li>当引用失效，<strong>计数器就减1</strong></li>
<li>任何时候<strong>计数器为0的对象</strong>就是<strong>不可能再被使用</strong>的</li>
</ul></li>
<li><p>这个方法实现<strong>简单，效率高</strong>，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它<strong>很难解决对象之间相互循环引用</strong>的问题。</p></li>
</ul>
<blockquote>
<p>除了对象 <code>objA</code> 和 <code>objB</code>
相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为
0，于是引用计数算法无法通知 GC 回收器回收他们</p>
</blockquote>
<p>★其实我觉得只跟相互有关，跟是不是<strong>循环</strong>关系不会太大</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGc</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGc</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGc</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="literal">null</span>;</span><br><span class="line">        objB = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h2 id="可达性分析算法">可达性分析算法</h2>
<ul>
<li><p>该算法的基本思想就是通过一系列称为<strong>“GC
Roots"</strong>的对象作为起点，从这些节点开始<strong>向下搜索</strong>，节点所走过的<strong>路径</strong>
称为<strong>引用链</strong>，当一个对象到GC
Roots<strong>没有任何引用链</strong>相连的话，证明该对象不可用，需要<strong>被回收</strong>
下图中由于Object 6 ~ Object
10之间有引用关系，但它们到GC不可达，所以需要被回收 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/jvm-gc-roots.d187e957.png"
alt="可达性分析算法" /></p></li>
<li><p>哪些对象可以作为GC Roots呢</p>
<ol type="1">
<li>虚拟机栈（栈帧中的<strong>本地变量表</strong>）中引用的对象</li>
<li>本地方法栈（<strong>Native方法</strong>）中引用的对象</li>
<li>方法区中<strong>类静态属性</strong>引用的对象</li>
<li>方法区中<strong>常量</strong>引用的变量</li>
<li>所有被<strong>同步锁持有的对象</strong></li>
</ol></li>
<li><p>对象可以被回收，就代码一定会被回收吗
即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们<strong>暂时处于“缓刑阶段”</strong>，要真正宣告一个对象死亡，至少要经历两次标记过程：</p>
<ol type="1">
<li><p>可达性分析中<strong>不可达的对象被第一次标记</strong>并且进行<strong>一次筛选</strong>：筛选的条件是此对象是否有必要执行finalize方法（有必要则放入）<br />
当对象<strong>没有覆盖finalize</strong>方法，或<strong>finalize方法已经被虚拟机调用</strong>过，则虚拟机将两种情况视为<strong>没有必要</strong>执行，该对象会被<strong>直接回收</strong></p></li>
<li><p>如果这个对象被判定为<strong>有必要执行finalize()</strong>方法，那么这个对象将会被<strong>放置在一个叫做F-Queue的队列</strong>中，然后由Finalizer线程去执行。GC将会<strong>对F-Queue中的对象进行第二次标记</strong>，如果对象<strong>在finalize()方法中重新与引用链上的任何一个对象建立关联</strong>，那么在<strong>第二次标记时将会被移除“即将回收”的集合</strong>，否则该对象将会被回收。</p>
<p>（比如：把自己（this关键字）赋值给某个类变量(static修饰)或者对象的成员变量）</p></li>
</ol>
<blockquote>
<p><code>Object</code> 类中的 <code>finalize</code>
方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java
语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的
<code>finalize</code> 方法会被逐渐弃用移除。忘掉它的存在吧！</p>
</blockquote></li>
</ul>
<h2 id="引用类型总结">引用类型总结</h2>
<ul>
<li>不论是通过<strong>引用计数法</strong>判断对象引用数量，还是通过<strong>可达性分析法</strong>判断对象的引用链是否可达，判定对象的存活都与<strong>”引用“</strong>有关</li>
<li>JDK1.2
之前，Java中<strong>引用</strong>的定义很传统：如果<strong>reference类型的数据存储</strong>的数值代表的是<strong>另一块内存的起始地址</strong>，就称这块内存代表<strong>一个引用</strong></li>
<li>JDK1.2
之后，Java对引用的概念进行了扩充，将引用(具体)分为<strong>强引用</strong>、<strong>软引用</strong>、<strong>弱引用</strong>、<strong>虚引用</strong>四种（引用强度<strong>逐渐减弱</strong>）
<ol type="1">
<li><p><strong>强引用</strong>（Strong Reference）</p>
<blockquote>
<ul>
<li>大部分引用实际上是<strong>强引用</strong>。如果对象具有强引用，那么类似于生活中<strong>必不可少</strong>，垃圾回收器<strong>绝不会回收</strong>它</li>
<li>内存空间不足时，宁愿抛出<strong>OutOfMemoryErro</strong>错误，使程序异常终止，也不会回收<strong>强引用</strong>对象解决<strong>对象内存不足</strong></li>
</ul>
</blockquote></li>
<li><p><strong>软引用</strong>（SoftReference）</p>
<blockquote>
<ul>
<li>如果对象<strong>只</strong>具有软引用，那就类似<strong>可有可无</strong>的生活用品。</li>
<li>内存够则不会回收；内存不足则回收这些对象。只要垃圾回收器没有回收，那么对象就可以<strong>被程序使用</strong>。</li>
<li>软引用可用来实现<strong>内存敏感</strong>的高速缓存</li>
<li>软引用可以和一个<strong>引用队列（ReferenceQueue）</strong>联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到<strong>与之关联</strong>的引用队列中</li>
</ul>
</blockquote></li>
<li><p><strong>弱引用</strong>（WeakReference）</p>
<blockquote>
<ul>
<li>如果对象<strong>只</strong>具有弱引用，则类似于<strong>可有可无</strong>的生活用品</li>
<li>弱引用和软引用的区别：只具有弱引用的对象拥有<strong>更短暂</strong>的生命周期</li>
<li>垃圾回收器线程<strong>扫描</strong>它所管辖的内存区域的<strong>过程中</strong>，一旦发现只具有<strong>弱引用</strong>的对象，不管当前内存<strong>足够与否</strong>，都会回收它的内存。不过垃圾回收器是一个<strong>优先级很低</strong>的线程，因此不一定会很快发现那些<strong>只具有弱引用</strong>的对象</li>
<li>弱引用可以和一个<strong>引用队列（ReferenceQueue）</strong>联合使用，如果<strong>弱引用所引用的对象</strong>被垃圾回收，Java虚拟机就会把这个弱引用<strong>加入到与之关联的引用队列</strong>中</li>
</ul>
</blockquote></li>
<li><p><strong>虚引用</strong>（PhantomReference）</p>
<blockquote>
<p>与其他引用不同，<strong>虚引用并不会决定对象声明周期</strong>。如果一个<strong>仅持有</strong>虚拟引用，那么它就跟<strong>没有任何</strong>引用一样，在任何时候都可能被垃圾回收</p>
</blockquote>
<p>虚引用主要用来<strong>跟踪对象被垃圾回收的活动</strong></p></li>
<li><p>虚引用、软引用和弱引用的区别：<strong>虚引用必须和引用队列（ReferenceQueue）联合使用</strong>。</p>
<ul>
<li>当垃圾回收器<strong>准备回收</strong>一个对象时，如果发现它还有虚引用，就会在回收对象的内存<strong>之前</strong>，把这个虚引用加入到<strong>与之关联</strong>的引用队列。</li>
<li>程序可以通过<strong>判断引用队列是否加入虚引用</strong>，来了解被引用的对象是否<strong>将</strong>被垃圾回收</li>
<li>如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象<strong>被回收之前</strong>采取必要的行动</li>
</ul></li>
<li><p>在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速
JVM
对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong></p></li>
</ol></li>
</ul>
<h2 id="如何判断一个常量是废弃常量">如何判断一个常量是废弃常量</h2>
<p>运行时常量池主要是回收<strong>废弃的常量</strong></p>
<blockquote>
<ol type="1">
<li>JDK1.7
之前，<strong>运行时常量池逻辑</strong>，包括字符串常量池，存放在<strong>方法区</strong>，此时hotspot虚拟机对<strong>方法区</strong>的实现为<strong>永久代</strong></li>
<li>JDK1.7字符串常量池被<strong>从方法区</strong>拿到了<strong>堆</strong>中，这里没有提到运行时常量池，也就是说<strong>字符串常量池</strong>被单独拿到堆，运行时常量池剩下的东西，<strong>还在方法区</strong>。即hotspot中的<strong>永久代</strong></li>
<li>JDK1.8
hotspot移除了永久代，用<strong>元空间Metaspace</strong>取代之，这时候<strong>字符串常量池</strong>还在堆，<strong>运行时常量池</strong>还在方法区，只不过<strong>方法区的实现</strong>从永久代变成了<strong>元空间Metaspace</strong></li>
</ol>
</blockquote>
<p>★★
假如<strong>字符串常量池</strong>存在字符串“abc”，如果当前没有任何String对象<strong>引用该字符串常量</strong>的话，就说明常量“abc”是废弃常量。如果这时发生内存回收并且<strong>有必要</strong>的话，“abc”就会被系统<strong>清理出</strong>常量池</p>
<h2 id="如何判断一个类是无用类">如何判断一个类是无用类</h2>
<ul>
<li><p><strong>方法区</strong>主要回收<strong>无用的类</strong>，判断一个类是否是<strong>无用的类</strong>相对苛刻，需要同时满足下面<strong>条件</strong></p>
<ul>
<li>该类所有实例都已经被回收，即<strong>Java堆中不存在该类的任何实例</strong></li>
<li>加载该类的<strong>ClassLoader</strong>已经被回收</li>
<li>该类对应的<strong>java.lang.Class</strong>对象没有在任何地方被引用，<strong>无法</strong>在任何地方<strong>通过反射</strong>访问该类方法</li>
</ul>
<p>Java虚拟机<strong>可以</strong>对<strong>满足上述3个条件</strong>的无用类进行回收，是<strong>“可以”</strong>，而<strong>不是必然</strong></p></li>
</ul>
<h1 id="垃圾收集算法">垃圾收集算法</h1>
<h2 id="标记-清除算法">标记-清除算法</h2>
<p>该算法分为<strong>“标记”</strong>和<strong>“清除”</strong>阶段：<br />
标记出所有<strong>不需要回收的对象</strong>，在标记完成后<strong>统一回收掉所有没有被标记</strong>的对象</p>
<p>这是<strong>最基础</strong>的<strong>收集算法</strong>，后续的算法都是对其不足进行改进得到，有两个明显问题：</p>
<ol type="1">
<li><strong>效率问题</strong></li>
<li><strong>空间问题</strong>（标记清除后会产生<strong>大量不连续碎片</strong>）</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/%25E6%25A0%2587%25E8%25AE%25B0-%25E6%25B8%2585%25E9%2599%25A4%25E7%25AE%2597%25E6%25B3%2595.c1fbd0fe.jpeg"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="标记-复制算法">标记-复制算法</h2>
<ul>
<li>将内存分为<strong>大小相同的两块</strong>，每次<strong>使用其中一块</strong></li>
<li>当这块<strong>内存使用完后</strong>，就将还存活的对象<strong>复制到另一块</strong>去，然后再把<strong>使用的空间一次清理掉</strong></li>
<li>这样每次内存<strong>回收</strong>都是对内存区间的一半<strong>进行回收</strong></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/90984624.e8c186ae.png"
alt="复制算法" />
<figcaption aria-hidden="true">复制算法</figcaption>
</figure>
<h2 id="标记-整理算法">标记-整理算法</h2>
<p>根据老年代特点提出的一种<strong>标记算法</strong>，<strong>标记过程</strong>仍然与<strong>“标记-清除”</strong>算法一样，但后续不是直接对可回收对象回收，而是让<strong>所有存活对象向一端移动</strong>，然后直接<strong>清理掉端边界以外的内存</strong></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/94057049.22c58294.png"
alt="标记-整理算法" />
<figcaption aria-hidden="true">标记-整理算法</figcaption>
</figure>
<h2 id="分代收集算法">分代收集算法</h2>
<ul>
<li>当前虚拟机的垃圾收集都采用<strong>分代收集算法</strong>，没有新的思想，只是<strong>根据对象存活周期的不同</strong>将内存分为几块。</li>
<li>一般将Java堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样就可以<strong>根据各个年代的特点</strong>，选择合适的<strong>垃圾收集算法</strong>
<ul>
<li><strong>新生代</strong>中，每次收集都会有大量对象死去，所以可以选择<strong>“标记-复制”</strong>算法，只需要付出少量<strong>对象的复制成本</strong>就可以完成<strong>每次垃圾收集</strong></li>
<li><strong>老年代</strong>对象存活几率是比较高的，而且<strong>没有额外的空间对它进行分配担保</strong>，所以必须选择<strong>标记-清除</strong>或者<strong>“标记-整理”</strong>算法进行垃圾收集</li>
</ul></li>
</ul>
<h1 id="垃圾收集器">垃圾收集器</h1>
<ul>
<li><strong>收集算法</strong>是内存回收的<strong>方法论</strong>，而<strong>垃圾收集器</strong>则是内存回收的<strong>具体实现</strong></li>
<li>没有<strong>最好的</strong>垃圾收集器，也没有<strong>万能的</strong>，应该<strong>根据具体应用场景</strong>，选择适合自己的<strong>垃圾收集器</strong></li>
</ul>
<h2 id="汇总">汇总</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/11e9dcd0f1ee4f25836e6f1c47104c51-new-image69e1c56a-1d40-493a-9901-6efc647a01f3.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<blockquote>
<ul>
<li>新生代的垃圾回收器：Serial（串行--复制），ParNew（并行--复制），ParallelScavenge（并行--复制）</li>
<li>老年代的垃圾回收器：SerialOld（串行--标记整理），ParallelOld（并行--标记整理），CMS（并发--标记清除）</li>
<li>只有CMS和G1是并发，且CMS只作用于老年代，而G1都有</li>
<li>JDK8为止，默认垃圾回收器是Parallel Scavenge和Parallel
Old【并行--复制和并行--标记整理】</li>
<li>JDK9开始，G1收集器成为默认的垃圾收集器，目前来看，G1回收期停顿时间最短且没有明显缺点，偏适合Web应用</li>
</ul>
<blockquote>
<p>jdk8中测试Web应用，堆内存6G中新生代4.5G的情况下</p>
<ul>
<li>ParallelScavenge回收新生代停顿长达1.5秒。</li>
<li>G1回收器回收同样大小的新生代只停顿0.2秒</li>
</ul>
</blockquote>
</blockquote>
<h2 id="serial-收集器">Serial 收集器</h2>
<ul>
<li><p>Serial 串行
收集器是<strong>最基本</strong>、<strong>历史最悠久</strong>的垃圾收集器</p></li>
<li><p>这是一个<strong>单线程收集器</strong>，它的<strong>单线程</strong>意义不仅意味着它只会使用<strong>一条垃圾收集线程</strong>去完成垃圾收集工作，更重要的是它在<strong>进行垃圾收集工作时</strong>必须暂停其他所有的工作线程<strong>（”Stop
The World“）</strong>，直到它<strong>收集结束</strong>。</p>
<ul>
<li>新生代采用<strong>标记-复制</strong>算法，老年代采用<strong>标记-整理</strong>算法
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/46873026.3a9311ec.png"
alt="Serial 收集器" /></li>
<li>StopTheWorld会带来<strong>不良用户体验</strong>，所以在后续垃圾收集器设计中<strong>停顿时间不断缩短</strong>。（仍然有停顿，垃圾收集器的过程仍然在继续）</li>
<li>优点：<strong>简单而高效</strong>（与其他收集器的单线程相比）
<ol type="1">
<li>且由于其<strong>没有线程交互</strong>的开销，自然可以获得<strong>很高的单线程收集效率</strong></li>
<li>Serial收集器对于<strong>运行在Client模式</strong>下的虚拟机来说是个不错的选择</li>
</ol></li>
</ul></li>
<li><p>```shell -XX:+UseSerialGC
#虚拟机运行在Client模式下的默认值，Serial+Serial Old。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## ParNew 收集器</span><br><span class="line"></span><br><span class="line">- **ParNew**收集器其实就是**Serial收集器**的**多线程版本**，除了使用**多线程**进行垃圾收集外，其余行为（**控制参数**、**收集算法**、**回收策略**等等）和**Serial收集器**完全一样</span><br><span class="line"></span><br><span class="line">- **新生代**采用**标记-复制**算法，**老年代**采用**标记-整理**算法</span><br><span class="line"></span><br><span class="line">  ![ParNew 收集器 ](https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/22018368.df835851.png)</span><br><span class="line">  ★★★  这是许多运行在Server模式下的虚拟机的首要选择，除了**Serial收集器**外，只有它能与**CMS收集器**（真正意义上的**并发**收集器）配合工作（**ParNew是并行**）</span><br><span class="line"></span><br><span class="line">- **并行和并发**概念补充</span><br><span class="line"></span><br><span class="line">  - **并行（Parallel）**：指**多条垃圾收集线程**并行工作，但此时用户线程仍然处于**等待**状态</span><br><span class="line">  - **并发（Concurrent）**：指**用户线程**与**垃圾收集线程** **同时**执行（不一定并行，可能会交替执行），**用户程序在继续执行**，而**收集收集器**运行在另一个CPU上</span><br><span class="line"></span><br><span class="line">- ```shell</span><br><span class="line">  -XX:+UseParNewGC  #ParNew+Serial Old，在JDK1.8被废弃，在JDK1.7还可以使用。</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="parallelscavenge-收集器">ParallelScavenge 收集器</h2>
<ul>
<li><p>它也是<strong>标记-复制</strong>算法的多线程收集器，看上去几乎和<strong>ParNew</strong>一样，<strong>区别</strong></p>
<ul>
<li><p>部分<strong>参数</strong> (有点争议，先以下面为准)</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+UseParallelGC  # 虚拟机运行在Server模式下的默认值(1.8) 新生代使用ParallelGC，老年代使用回收器 ; ★★ JDK1.7之后，能达到UseParallelOldGC 的效果 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 参考自 https://zhuanlan.zhihu.com/p/353458348</span></span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC # 新生代使用ParallelGC，老年代使用ParallelOldGC</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>Parallel
Scavenge</strong>收集器关注点是<strong>吞吐量（高效率利用CPU）</strong>，<strong>CMS</strong>等垃圾收集器关注点是用户的<strong>停顿时间</strong>（提高用户体验）</p>
<blockquote>
<p>所谓<strong>吞吐量</strong>就是CPU中用于<strong>运行用户代码的时间</strong>与<strong>CPU</strong>总消耗时间的<strong>比值</strong>
（也就是<strong>希望</strong>消耗少量CPU就能<strong>运行更多代码</strong>）</p>
</blockquote></li>
<li><p>Parallel Scavenge
收集器提供了很多参数供用户找到<strong>最合适的停顿时间</strong>或<strong>最大吞吐量</strong>，如果对于收集器运作不太了解，手工优化存在困难的时候，使用
<strong>Parallel Scavenge
收集器</strong>配合<strong>自适应调节策略</strong>，把<strong>内存管理优化</strong>交给虚拟机去完成也是一个不错的选择。</p></li>
<li><p>新生代采用<strong>标记-复制</strong>，老年代采用<strong>标记-整理</strong>算法
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221215170900774.png"
alt="image-20221215170900774" /></p></li>
</ul></li>
<li><p>这是JDK1.8 的默认收集器 使用 java -XX:+PrintCommandLineFlags
-version 命令查看 如下，两种情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">默认</span></span><br><span class="line">λ java -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=531924800 -XX:MaxHeapSize=8510796800 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class="line">java version &quot;1.8.0_202&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_202-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)</span><br></pre></td></tr></table></figure>
<p>第二种情况：(注意：<code>-XX:-UseParallelOldGC</code>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ java -XX:-UseParallelOldGC -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=531924800 -XX:MaxHeapSize=8510796800 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC -XX:-UseParallelOldGC</span><br><span class="line"></span><br><span class="line">java version &quot;1.8.0_202&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_202-b08)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.202-b08, mixed mode)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="serialold-收集器">SerialOld 收集器</h2>
<ul>
<li>Serial收集器的<strong>老年代版本</strong>，是一个<strong>单线程</strong>收集器
<ol type="1">
<li>在JDK1.5以及以前的版本中，<strong>与Parallel
Scavenge收集器搭配</strong>时候</li>
<li>作为CMS收集器的<strong>后备方案</strong></li>
</ol></li>
</ul>
<h2 id="parallelold-收集器">ParallelOld 收集器</h2>
<ul>
<li>Parallel
Scavenge收集器的老年代版本，使用<strong>多线程</strong>和<strong>标记-整理</strong>算法
<ol type="1">
<li>在注重<strong>吞吐量</strong>以及<strong>CPU资源</strong>的场合，都可以考虑<strong>ParallelScavenge</strong>和<strong>ParallelOld</strong>收集器</li>
</ol></li>
</ul>
<h2 id="cms-收集器">CMS 收集器</h2>
<ul>
<li><p>CMS，Concurrent Mark
Sweep，是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，非常符合<strong>注重用户体验</strong>的引用上使用</p></li>
<li><p>CMS收集器是HotSpot虚拟机上<strong>第一款</strong>真正意义上的<strong>并发</strong>收集器，第一次实现了<strong>让垃圾收集线程</strong>与<strong>用户线程</strong>（基本上）同时工作</p></li>
<li><p>Mark-Sweep，是一种“<strong>标记-清除</strong>”算法，运作过程相比前面几种垃圾收集器来说更加复杂，步骤：</p>
<ol type="1">
<li><p>初始标记：暂停所有其他线程，<strong>记录直接与root相连的对象</strong>，速度很快</p></li>
<li><p>并发标记：<strong>同时</strong> 开启GC和用户线程
，用一个<strong>闭包结构记录可达对象</strong>。但这个阶段结束，这个闭包结构并<strong>不能保证包含当前所有的可达对象</strong>。</p>
<blockquote>
<p>因为用户线程会不断更新引用域，所以GC线程<strong>无法保证可达性分析的实时性</strong></p>
</blockquote>
<p>所以这个算法里会<strong>跟踪记录</strong>这些发生引用更新的地方</p></li>
<li><p>重新标记：目的是<strong>修正并发标记期间</strong>因为用户程序继续运行而<strong>导致标记产生变动</strong>的那一部分对象的<strong>标记记录</strong>。</p>
<blockquote>
<p>这个阶段<strong>停顿时间</strong>一般会被初始标记阶段<strong>时间稍长</strong>，远远比<strong>并发标记阶段</strong>时间短</p>
</blockquote></li>
<li><p>并发清除：<strong>开启用户线程</strong>，同时<strong>GC线程</strong>开始对未扫描的区域做清扫</p></li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/CMS%25E6%2594%25B6%25E9%259B%2586%25E5%2599%25A8.8a4d0487.png"
alt="CMS 垃圾收集器" />
<figcaption aria-hidden="true">CMS 垃圾收集器</figcaption>
</figure></li>
<li><p>从名字可以看出这是一款优秀的收集器：<strong>并发收集</strong>、<strong>低停顿</strong>。但有三个明显缺点</p>
<ol type="1">
<li><p><strong>对CPU资源敏感</strong></p></li>
<li><p>无法处理浮动垃圾</p>
<blockquote>
<p>浮动垃圾的解释：就是之前被gc 标记为 可达对象，也就是
存活对象，在两次gc线程之间被业务线程删除了引用，那么颜色不会更改，还是之前的颜色（黑色or灰色），但是其实是白色，所以这一次gc
无法对其回收，需要等下一次gc初始标记启动才会被刷成白色 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/13864094-053f50032b4cdfad.png"
alt="img" /></p>
<p>作者：Yellowtail 链接：https://www.jianshu.com/p/6590aaad82f7
来源：简书</p>
</blockquote></li>
<li><p>它使用的收集算法<strong>“标记-清除”</strong>算法会导致收集结束时会有<strong>大量空间碎片产生</strong></p></li>
</ol></li>
</ul>
<h2 id="g1-收集器">G1 收集器</h2>
<p>G1(Garbage-First)，是一款<strong>面向服务器</strong>的垃圾收集器，主要针对<strong>配备多颗处理器</strong>以及<strong>大容量内存</strong>的极其，以<strong>极高概率</strong>满足GC停顿时间要求的同时，还具备<strong>高吞吐量性能</strong>特征</p>
<ul>
<li><p><strong>JDK1.7</strong>中HotSpot虚拟机的一个<strong>重要进化特征</strong>，具备特点：</p>
<ol type="1">
<li><p>并行与并发：</p>
<blockquote>
<p>G1 能充分利用 CPU、多核环境下的硬件优势，<strong>使用多个 CPU（CPU
或者 CPU 核心）来缩短 Stop-The-World
停顿时间</strong>。部分其他收集器原本需要停顿 Java 线程执行的 GC
动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行</p>
</blockquote></li>
<li><p>分代收集：</p>
<blockquote>
<p>虽然 G1 可以<strong>不需要其他收集器配合</strong>就能独立管理整个 GC
堆，但是还是保留了分代的概念。</p>
</blockquote></li>
<li><p>空间整合：</p>
<blockquote>
<p>与 CMS 的“标记-清理”算法不同，G1
<strong>从整体来看</strong>是基于<strong>“标记-整理”</strong>算法实现的收集器；从<strong>局部</strong>上来看是基于<strong>“标记-复制”</strong>算法实现的。</p>
</blockquote></li>
<li><p>可预测的停顿：</p>
<blockquote>
<p>这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS
共同的关注点，但 G1
除了追求低停顿外，还能建立可预测的停顿时间模型，能<strong>让使用者明确指定在一个长度为
M 毫秒的时间片段</strong>内。</p>
</blockquote></li>
</ol></li>
<li><p>G1 收集器的运作大致分为以下几个步骤</p>
<ol type="1">
<li><strong>初始标记</strong></li>
<li><strong>并发标记</strong></li>
<li><strong>最终标记</strong></li>
<li><strong>筛选回收</strong></li>
</ol></li>
<li><p>G1
收集器在后台<strong>维护了一个优先列表</strong>，每次<strong>根据允许的收集时间</strong>，<strong>优先选择回收价值最大的
Region</strong>(这也就是它的名字 <strong>Garbage-First 的由来</strong>)
。这种<strong>使用 Region
划分内存空间</strong>以及<strong>有优先级的区域回收方式</strong>，，保证了
G1
收集器在<strong>有限时间内</strong>可以尽可能高的收集效率（<strong>把内存化整为零</strong>）</p></li>
</ul>
<h2 id="zgc-收集器">ZGC 收集器</h2>
<p><code>The Z Garbage Collector</code></p>
<p><strong>与 CMS 中的 ParNew 和 G1 类似，ZGC
也采用标记-复制算法</strong>，不过 ZGC 对该算法做了重大改进。</p>
<p>在 ZGC 中出现 Stop The World 的情况会更少！</p>
<p>JDK11，相关文章
https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm监控和故障处理工具 总结</title>
    <url>/2022/12/19/review/java_guide/java/jvm/jdk-monitoring-and-troubleshooting-tools/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h1 id="jdk-命令行工具">JDK 命令行工具</h1>
<p>这些命令在 JDK 安装目录下的 bin 目录下：</p>
<ul>
<li><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX
的 <code>ps</code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java
虚拟机参数等信息；</li>
<li><strong><code>jstat</code></strong>（JVM Statistics Monitoring
Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li>
<li><strong><code>jinfo</code></strong> (Configuration Info for Java) :
Configuration Info for Java,显示虚拟机配置信息;</li>
<li><strong><code>jmap</code></strong> (Memory Map for Java) :
生成堆转储快照;</li>
<li><strong><code>jhat</code></strong> (JVM Heap Dump Browser) :
用于分析 heapdump 文件，它会建立一个 HTTP/HTML
服务器，让用户可以在浏览器上查看分析结果;</li>
<li><strong><code>jstack</code></strong> (Stack Trace for Java) :
生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li>
</ul>
<h2 id="jps-查看所有-java-进程">jps: 查看所有 Java 进程</h2>
<p><code>jps</code>(JVM Process Status) 命令类似 UNIX 的 <code>ps</code>
命令。</p>
<p><code>jps</code>：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一
ID（Local Virtual Machine Identifier,LVMID）。<code>jps -q</code>
：只输出进程的本地虚拟机唯一 ID。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line"><span class="number">7360</span> NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> Launcher</span><br><span class="line"><span class="number">16504</span> Jps</span><br><span class="line"><span class="number">17340</span> NettyServer</span><br></pre></td></tr></table></figure>
<p><code>jps -l</code>:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar
路径。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps <span class="literal">-l</span></span><br><span class="line"><span class="number">7360</span> firstNettyDemo.NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class="line"><span class="number">16492</span> sun.tools.jps.Jps</span><br><span class="line"><span class="number">17340</span> firstNettyDemo.NettyServer</span><br></pre></td></tr></table></figure>
<p><code>jps -v</code>：输出虚拟机进程启动时 JVM 参数。</p>
<p><code>jps -m</code>：输出传递给 Java 进程 main() 函数的参数。</p>
<h2
id="jstat监视虚拟机各种运行状态信息">jstat：监视虚拟机各种运行状态信息</h2>
<ul>
<li><p>jstat ( JVM Statistics Monitoring Tool )
使用于<strong>监视虚拟机</strong>各种<strong>运行状态信息</strong>的命令行工具。</p>
<blockquote>
<p>可以显示<strong>本地</strong>或者<strong>远程（需要远程主机提供RMI支持）</strong>虚拟机进程中的<strong>类信息</strong>、<strong>内存</strong>、<strong>垃圾收集</strong>、<strong>JIT编译</strong>等运行数据，在<strong>没有GUI</strong>，只提供了<strong>纯文本</strong>控制台环境的服务器上，它将是运行期间<strong>定位虚拟机性能问题</strong>的首选工具</p>
</blockquote></li>
<li><p>jstat 命令使用格式</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-<span class="type">t</span>] [-<span class="type">h</span>&lt;<span class="type">lines</span>&gt;] &lt;vmid&gt; [&lt;<span class="built_in">int</span><span class="type">erval</span>&gt; [&lt;<span class="type">count</span>&gt;]]</span><br></pre></td></tr></table></figure>
<p>比如 <code>jstat -gc -h3 31736 1000 10</code>表示分析进程 id 为 31736
的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3
行后打印指标头部。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">λ jstat -gc -h3 12224 1000 10  </span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221219210349920.png"
alt="image-20221219210349920" />
<figcaption aria-hidden="true">image-20221219210349920</figcaption>
</figure>
<p>常见的option如下 , 下面的vmid，即vm的id （id值）</p>
<ul>
<li><code>jstat -class vmid</code> ：显示 ClassLoader 的相关信息；</li>
<li><code>jstat -compiler vmid</code> ：显示 JIT 编译的相关信息；</li>
<li><code>jstat -gc vmid</code> ：显示与 GC 相关的堆信息；</li>
<li><code>jstat -gccapacity vmid</code>
：显示各个代的容量及使用情况；</li>
<li><code>jstat -gcnew vmid</code> ：显示新生代信息；</li>
<li><code>jstat -gcnewcapcacity vmid</code>
：显示新生代大小与使用情况；</li>
<li><code>jstat -gcold vmid</code>
：显示老年代和永久代的行为统计，从jdk1.8开始,该选项仅表示老年代，因为永久代被移除了；</li>
<li><code>jstat -gcoldcapacity vmid</code> ：显示老年代的大小；</li>
<li><code>jstat -gcpermcapacity vmid</code>
：显示永久代大小，从jdk1.8开始,该选项不存在了，因为永久代被移除了；</li>
<li><code>jstat -gcutil vmid</code> ：显示垃圾收集信息</li>
</ul>
<p>使用<code>jstat -gcutil -h3 12224 1000 10</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221219210934394.png"
alt="image-20221219210934394" />
<figcaption aria-hidden="true">image-20221219210934394</figcaption>
</figure>
<p>另外，加上 <code>-t</code>参数可以在输出信息上加一个 Timestamp
列，显示程序的运行时间。 各个参数的含义<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221219211407363.png"
alt="image-20221219211407363" /></p></li>
</ul>
<h2
id="jinfo实时地查看和调整虚拟机各项参数">jinfo：实时地查看和调整虚拟机各项参数</h2>
<p><code>jinfo vmid</code> :输出当前 jvm 进程的全部参数和系统属性
(第一部分是系统的属性，第二部分是 JVM 的参数)。 如下图： <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221219211745724.png"
alt="image-20221219211745724" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221219211839945.png"
alt="image-20221219211839945" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221219211712746.png"
alt="image-20221219211712746" />
<figcaption aria-hidden="true">image-20221219211712746</figcaption>
</figure>
<ul>
<li><p><code>jinfo -flag name vmid</code>
:输出<strong>对应名称</strong>的参数的<strong>具体值</strong>。比如输出
<strong>MaxHeapSize</strong>、查看当前 jvm 进程<strong>是否开启打印 GC
日志</strong> ( <code>-XX:PrintGCDetails</code> :详细 GC
日志模式，这两个都是默认关闭的)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  -flag MaxHeapSize 17340</span><br><span class="line">-XX:MaxHeapSize=2124414976</span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  -flag PrintGC 17340</span><br><span class="line">-XX:-PrintGC</span><br></pre></td></tr></table></figure></li>
<li><p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm
的参数。尤其在线上的环境特别有用,请看下面的例子： 使用```jinfo -flag
[+|-]name vmid 开启或者关闭对应名称的参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  -flag  PrintGC 17340</span><br><span class="line">-XX:-PrintGC</span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  -flag  +PrintGC 17340</span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  -flag  PrintGC 17340</span><br><span class="line">-XX:+PrintGC</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="jmap生成堆转储快照">jmap：生成堆转储快照</h2>
<ul>
<li><p><strong>jmap(Memory Map for Java
)</strong>命令用于生成<strong>堆转储</strong>快照。如果不使用jmap命令，要想获取java<strong>堆转储</strong>，可以使用<code>-XX:+HeapDumpOutOfMemoryError</code>参数，可以让虚拟机在<strong>OOM</strong>异常出现<strong>之后</strong>，自动生成dump文件，Linux命令下通过<code>kill -3</code>发送进程推出信号也能拿到dump文件</p></li>
<li><p><code>jmap</code> 的作用并不仅仅是为了<strong>获取 dump</strong>
文件，它还可以<strong>查询 finalizer 执行队列</strong>、<strong>Java
堆</strong>和<strong>永久代</strong>的详细信息，如<strong>空间使用率</strong>、当前使用的是<strong>哪种收集器</strong>等。和<code>jinfo</code>一样，<code>jmap</code>有不少功能在
Windows 平台下也是受限制的。</p></li>
<li><p>将指定应用程序的<strong>堆
快照</strong>输出到桌面，后面可以通过<strong>jhat</strong>、<strong>Visual
VM</strong>等工具分析该堆文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jmap -dump:format=b,file=C:\Users\SnailClimb\Desktop\heap.hprof <span class="number">17340</span></span><br><span class="line">Dumping heap to C:\Users\SnailClimb\Desktop\heap.hprof ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="jhat分析heapdump文件">jhat：分析heapdump文件</h2>
<p><strong><code>jhat</code></strong> 用于分析 heapdump
文件，它会建立一个 HTTP/HTML
服务器，让用户可以在浏览器上查看分析结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jhat C:\Users\SnailClimb\Desktop\heap.hprof</span><br><span class="line">Reading from C:\Users\SnailClimb\Desktop\heap.hprof...</span><br><span class="line">Dump file created Sat May 04 12:30:31 CST 2019</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 131419 objects...</span><br><span class="line">Chasing references, expect 26 dots..........................</span><br><span class="line">Eliminating duplicate references..........................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready. </span><br></pre></td></tr></table></figure>
<p>之后访问 http://localhost:7000/ 即可，如下： 进入/histo
会发现，有这个东西 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221220094041210.png"
alt="image-20221220094041210" />
这个对象创建了9次，因为我是在第9次循环后dump堆快照的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] x = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10M</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始循环--&quot;</span>);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (++i&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            String a=<span class="keyword">new</span> <span class="title class_">Date</span>().toString();</span><br><span class="line">            <span class="type">MyMain</span> <span class="variable">myMain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyMain</span>();</span><br><span class="line">            System.out.println(i+<span class="string">&quot;循环中---&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="jstack-生成虚拟机当前时刻的线程快照">jstack：
生成虚拟机当前时刻的线程快照</h2>
<ul>
<li><p><strong>jstack (Stack Trace for Java )</strong>
命令用于生成<strong>虚拟机当前时刻</strong>的<strong>线程快照</strong>。线程快照就是当前虚拟机内<strong>每一条线程正在执行</strong>的<strong>方法堆栈</strong>的集合</p></li>
<li><p>生成线程快照的目的主要是<strong>定位线程长时间出现停顿的原因</strong>，如<strong>线程间死锁</strong>、<strong>死循环</strong>、<strong>请求外部资源导致的长时间等待</strong>等都是导致线程长时间停顿的原因。<strong>线程出现停顿</strong>的时候<strong>通过<code>jstack</code>来查看各个线程的调用堆栈</strong>，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p></li>
<li><p>线程死锁的代码，通过<strong>jstack</strong>
命令进行<strong>死锁检查</strong>，输出<strong>死锁信息</strong>，找到<strong>发生死锁的线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;get resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;waiting get resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">&quot;get resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------</span></span><br><span class="line"><span class="comment">Thread[线程 1,5,main]get resource1</span></span><br><span class="line"><span class="comment">Thread[线程 2,5,main]get resource2</span></span><br><span class="line"><span class="comment">Thread[线程 2,5,main]waiting get resource1</span></span><br><span class="line"><span class="comment">Thread[线程 1,5,main]waiting get resource2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li><p>分析 线程 A 通过 synchronized (resource1) 获得 resource1
的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s
为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B
休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p></li>
<li><p>通过jstack 命令分析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先使用jps 找到思索地那个类</span></span><br><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line">13792 KotlinCompileDaemon</span><br><span class="line">7360 NettyClient2</span><br><span class="line">17396</span><br><span class="line">7972 Launcher</span><br><span class="line">8932 Launcher</span><br><span class="line">9256 DeadLockDemo</span><br><span class="line">10764 Jps</span><br><span class="line">17340 NettyServer</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 然后使用jstack命令分析</span></span></span><br><span class="line">C:\Users\SnailClimb&gt;jstack 9256 </span><br></pre></td></tr></table></figure>
<p>输出的部分如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;线程 2&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000000333e668 (object 0x00000000d5efe1c0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;线程 1&quot;</span><br><span class="line">&quot;线程 1&quot;:</span><br><span class="line">  waiting to lock monitor 0x000000000333be88 (object 0x00000000d5efe1d0, a java.lang.Object),</span><br><span class="line">  which is held by &quot;线程 2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;线程 2&quot;:</span><br><span class="line">        at DeadLockDemo.lambda$main$1(DeadLockDemo.java:31)</span><br><span class="line">        - waiting to lock &lt;0x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo$$Lambda$2/1078694789.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;线程 1&quot;:</span><br><span class="line">        at DeadLockDemo.lambda$main$0(DeadLockDemo.java:16)</span><br><span class="line">        - waiting to lock &lt;0x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo$$Lambda$1/1324119927.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>
<p>找到了发生死锁的线程的具体信息</p></li>
</ul>
<h1 id="jdk可视化分析工具">JDK可视化分析工具</h1>
<h2
id="jconsolejava监视与管理控制台">JConsole：Java监视与管理控制台</h2>
<p>JConsole 是<strong>基于 JMX
的可视化监视</strong>、<strong>管理工具</strong>。可以很方便的<strong>监视本地及远程服务器的
java
进程的内存使用情况</strong>。你可以在控制台输出<strong><code>console</code></strong>命令启动或者在
JDK 目录下的 bin
目录<strong>找到<code>jconsole.exe</code>然后双击启动</strong>. <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1JConsole%25E8%25BF%259E%25E6%258E%25A5.7490f097.png"
alt="连接 Jconsole" /></p>
<p>对于远程连接</p>
<ol type="1">
<li><p>在启动方</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Djava.rmi.server.hostname=外网访问 ip 地址 </span><br><span class="line">-Dcom.sun.management.jmxremote.port=60001   //监控的端口号</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false   //关闭认证</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false </span><br></pre></td></tr></table></figure>
<p>实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=192.168.200.200  -Dcom.sun.management.jmxremote  -Dcom.sun.management.jmxremote.port=60001  -Dcom.sun.management.jmxremote.ssl=false  -Dcom.sun.management.jmxremote.authenticate=false  com.jvm.DeadLockDemo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中 192.168.200.200 为启动该类的机器的ip，而不是谁要连接</span> </span><br></pre></td></tr></table></figure>
<p>在使用 JConsole 连接时，远程进程地址如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外网访问 ip 地址:60001</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221220103410971.png"
alt="image-20221220103410971" />
<figcaption aria-hidden="true">image-20221220103410971</figcaption>
</figure>
</blockquote></li>
<li><p>注意，虚拟机中（这里ip
xxx.200是虚拟机ip），需要开放的端口不只是60001，还要通过
<code>netstat -nltp</code>开放另外两个端口 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221220104157529.png"
alt="image-20221220104157529" /> centos中使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=45443/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=36521/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=60001/tcp --permanent</span><br><span class="line">firewall-cmd --reload #重启firewall</span><br></pre></td></tr></table></figure>
<p>之后才能连接上</p>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221220104326724.png"
alt="image-20221220104326724" /> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/2%25E6%259F%25A5%25E7%259C%258BJava%25E7%25A8%258B%25E5%25BA%258F%25E6%25A6%2582%25E5%2586%25B5.9c949b67.png"
alt="查看 Java 程序概况" /></p></li>
</ol>
<h3 id="内存监控">内存监控</h3>
<p>JConsole
可以显示<strong>当前内存的详细信息</strong>。不仅包括<strong>堆内存/非堆内存</strong>的整体信息，还可以细化到
<strong>eden 区</strong>、<strong>survivor
区</strong>等的使用情况，如下图所示。</p>
<p>点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。</p>
<blockquote>
<p><strong>新生代 GC（Minor
GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC
非常频繁，回收速度一般也比较快。</p>
<p><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的
GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC
的速度一般会比 Minor GC 的慢 10 倍以上。</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/3%25E5%2586%2585%25E5%25AD%2598%25E7%259B%2591%25E6%258E%25A7.4f4b8a7f.png"
alt="内存监控" />
<figcaption aria-hidden="true">内存监控</figcaption>
</figure>
<h3 id="线程监控">线程监控</h3>
<p>类似我们前面讲的 <code>jstack</code> 命令，不过这个是可视化的。</p>
<p>最下面有一个"检测死锁
(D)"按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息
。 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/4%25E7%25BA%25BF%25E7%25A8%258B%25E7%259B%2591%25E6%258E%25A7.4364833a.png"
alt="线程监控" /></p>
<h2 id="visualvm-多合一故障处理工具">VisualVM： 多合一故障处理工具</h2>
<p>VisualVM 提供在 Java 虚拟机 (Java Virutal Machine, JVM) 上运行的 Java
应用程序的详细信息。在 VisualVM
的图形用户界面中，您可以方便、快捷地查看多个 Java
应用程序的相关信息。Visual VM 官网：<a
href="https://visualvm.github.io/">https://visualvm.github.io/open in
new window</a> 。Visual VM 中文文档:<a
href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.htmlopen
in new window</a>。</p>
<p>下面这段话摘自《深入理解 Java 虚拟机》。</p>
<blockquote>
<p>VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK
发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM
的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM
的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling
工具都不会逊色多少，而且 VisualVM
还有一个很大的优点：不需要被监视的程序基于特殊 Agent
运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是
JProfiler、YourKit 等工具无法与之媲美的。</p>
</blockquote>
<p>VisualVM 基于 NetBeans
平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM
可以做到：</p>
<ul>
<li><strong>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</strong></li>
<li><strong>监视应用程序的
CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</strong></li>
<li><strong>dump 以及分析堆转储快照（jmap、jhat）。</strong></li>
<li><strong>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。</strong></li>
<li><strong>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump
等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</strong></li>
<li><strong>其他 plugins 的无限的可能性......</strong></li>
</ul>
<p>这里就不具体介绍 VisualVM 的使用，如果想了解的话可以看:</p>
<ul>
<li><a
href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.htmlopen
in new window</a></li>
<li>https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm-intro</title>
    <url>/2022/12/09/review/java_guide/java/jvm/jvm-intro/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
<p>原文地址： https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28
感谢原作者分享！！</p>
</blockquote>
<h1 id="jvm的基本介绍">JVM的基本介绍</h1>
<ul>
<li>JVM，JavaVirtualMachine的缩写，虚拟出来的计算机，通过在实际的计算机上<strong>仿真模拟</strong>各类计算机功能实现</li>
<li>JVM类似一台小电脑，运行在windows或者linux这些<strong>真实操作系统环境下</strong>，<strong>直接</strong>和操作系统交互，<strong>与硬件不直接交互</strong>，操作系统帮我们完成和硬件交互的工作</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/d947f91e44c44c6c80222b49c2dee859-new-image19a36451-d673-486e-9c8e-3c7d8ab66929.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="java文件是如何运行的">Java文件是如何运行的</h2>
<p>场景假设：我们写了一个HelloWorld.java，这是一个文本文件。JVM不认识文本文件，所以<strong>需要一个编译</strong>，让其(xxx.java)成为一个<strong>JVM会读的二进制文件---&gt;
HelloWorld.class</strong></p>
<ol type="1">
<li><p>类加载器
如果JVM想要执行这个.class文件，需要将其<strong>(这里应该指的二进制文件)</strong>装进<strong>类加载器</strong>中，它就像一个搬运工一样，会把所有的.class文件全部搬进JVM里面
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/81f1813f371c40ffa1c1f6d78bc49ed9-new-image28314ec8-066f-451e-8373-4517917d6bf7.png"
alt="img" /></p></li>
<li><p>方法区</p>
<blockquote>
<p>类加载器将.class文件搬过来，就是先丢到这一块上</p>
</blockquote>
<p>方法区是用于<strong>存放类似于元数据信息方面的数据</strong>的，比如<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>编译后代码</strong>...等</p></li>
<li><p>堆
堆主要放一些<strong>存储的数据</strong>，比如<strong>对象实例</strong>、<strong>数组</strong>...等，它和<strong>方法区</strong>都同属于<strong>线程共享区域</strong>，即它们都是<strong>线程不安全</strong>的</p></li>
<li><p>栈</p>
<p>线程独享<br />
栈是我们<strong>代码运行空间</strong>，我们编写的<strong>每一个方法</strong>都会放到<strong>栈</strong>里面运行。<br />
名词：<strong>本地方法栈</strong>或<strong>本地方法接口</strong>，不过我们基本不会涉及这两块内容，这<strong>两底层使用C</strong>进行工作，<strong>和Java没有太大关系</strong></p></li>
<li><p>程序计数器
主要就是完成一个加载工作，类似于一个指针一样的，<strong>指向下一行我们需要执行的代码</strong>。和栈一样，都是<strong>线程独享</strong>的，就是<strong>每一个线程都会自己对应的一块区域</strong>而不会存在并发和多线程问题。</p></li>
<li><p>小总结 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/897863ee5ecb4d92b9119d065f468262-new-imagef7287f0b-c9f0-4f22-9eb4-6968bbaa5a82.png"
alt="img" /></p>
<ol type="1">
<li>Java文件经过编译后编程.class字节码文件</li>
<li>字节码文件通过类加载器被搬运到 JVM虚拟机中</li>
<li>虚拟机主要的5大块：<strong>方法区、堆</strong>
都为<strong>线程共享</strong>区域，有线程安全问题；<strong>栈</strong>和<strong>本地方法栈</strong>和<strong>计数器</strong>都是<strong>独享</strong>区域，不存在线程安全问题，而JVM的调优主要就是围绕<strong>堆</strong>、<strong>栈</strong>两大块进行</li>
</ol></li>
</ol>
<h2 id="简单的代码例子">简单的代码例子</h2>
<p>一个简单的学生类及main方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;student&#x27;s name is : &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;tellUrDream&quot;</span>);</span><br><span class="line">        student.sayName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>★★ 执行main方法的步骤如下</p>
<ol type="1">
<li>编译好App.java后得到App.class后，执行APP.class，<strong>系统会启动一个JVM进程</strong>，从<strong>classpath类路径中找到一个名为APP.class的二进制文件</strong>，将<strong>APP的类信息加载到运行时数据区的方法区</strong>内，这个过程叫做<strong>APP类的加载</strong></li>
<li>JVM找到<strong>APP的主程序入口</strong>，<strong>执行main</strong>方法</li>
<li>这个main的第一条语句<strong>(指令)</strong>为
<code>Student student = new Student("tellUrDream")</code>，就是让JVM创建一个Student对象，但是这个时候方法区是没有Student类的信息的，所以JVM马上加载Student类，<strong>把Student类的信息放到方法区中</strong></li>
<li>加载完Student类后，<strong>JVM在堆中为一个新的Student实例分配内存</strong>，然后<strong>调用构造函数初始化Student实例</strong>，这个Student实例<strong>(对象)</strong>持有<strong>指向方法区中的Student类的类型信息</strong>的引用</li>
<li>执行<code>student.sayName;</code>时，JVM根据student的引用<strong>找到student对象</strong>，然后根据student对象<strong>持有的引用</strong>定位到<strong>方法区中student类的类型信息的方法表</strong>，获得<strong>sayName()的字节码地址</strong>。</li>
<li>执行sayName()</li>
</ol>
<p>其实也不用管太多，只需要知道<strong>对象实例初始化时</strong>，会<strong>去方法区中找到类信息</strong>（没有的话先加载），完成后再到<strong>栈那里去运行方法</strong></p>
<h1 id="类加载器的介绍">类加载器的介绍</h1>
<p><strong>类加载器</strong>负责<strong>加载.class</strong>文件，.class文件的开头会有<strong>特定的文件标识</strong>，将<strong>class文件字节码内容</strong>加载到内存中，并<strong>将这些内容</strong>转换成<strong>方法区</strong>中的<strong>运行时数据结构</strong>，并且ClassLoader只<strong>负责class文件的加载</strong>，而能否运行则由<strong>Execution
Engine</strong>来决定</p>
<h2 id="类加载器的流程">类加载器的流程</h2>
<p>从<strong>类被加载到虚拟机内存</strong>中开始，到<strong>释放内存</strong>总共有7个步骤：<br />
<strong>加载</strong>，<strong>验证</strong>，<strong>准备</strong>，<strong>解析</strong>，<strong>初始化</strong>，<strong>使用</strong>，<strong>卸载</strong>。<br />
其中<strong>验证</strong>，<strong>准备</strong>，<strong>解析</strong>三个部分统称为<strong>链接</strong></p>
<h3 id="加载">加载</h3>
<ol type="1">
<li>将class文件<strong>加载到内存</strong></li>
<li>将<strong>静态数据结构</strong>转化成<strong>方法区中运行的数据结构</strong></li>
<li>在<strong>堆</strong>中生成一个代表这个类的<strong>java.lang.Class对象</strong>作为数据访问的入口</li>
</ol>
<h3 id="链接">链接</h3>
<ol type="1">
<li>验证：确保加载的类<strong>符合JVM规范和安全</strong>，保证<strong>被校验类的方法</strong>在运行时不会做出<strong>危害虚拟机</strong>的事件，其实就是一个<strong>安全检查</strong></li>
<li>准备：为<strong>static变量</strong>在<strong>方法区分配内存空间</strong>，<strong>设置</strong>变量的<strong>初始值</strong>，例如<code>static int = 3</code>（注意：准备阶段只设置<strong>类中的静态变量</strong>（<strong>方法区</strong>中），<strong>不包括实例变量（堆内存中）</strong>，实例变量是<strong>对象初始化时赋值的</strong>）</li>
<li>解析：虚拟机将<strong>常量池内的符号引用</strong>，替换为<strong>直接引用</strong>的过程（符号引用比如我现在
<code>import java.util.ArrayList</code>
这就算<strong>符号引用</strong>，<strong>直接引用就是指针或者对象地址</strong>，注意<strong>引用对象一定是在内存进行</strong>）</li>
</ol>
<h3 id="初始化">初始化</h3>
<ul>
<li>初始化就是<strong>执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程</strong>，而且要<strong>保证执行前父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕</strong>。</li>
<li>这个方法由编译器<strong>收集(也就是编译时产生)</strong>，<strong>顺序执行所有类变量</strong>(static
修饰的成员变量)
<strong>显示初始化</strong>和静<strong>态代码块中</strong>语句</li>
<li>此时准备阶段时的那个static int a
由默认初始化的0<strong>变成了显示初始化的3</strong>。由于执行顺序缘故，<strong>初始化阶段类变量</strong>如果在静态代码中<strong>又</strong>进行更改，则会覆盖类变量的<strong>显式初始化</strong>，最终<strong>值</strong>会为静态代码块中的<strong>赋值</strong></li>
</ul>
<blockquote>
<ol type="1">
<li>字节码文件中初始化方法有两种，<strong>非静态资源初始化</strong>的<init>和<strong>静态资源初始化</strong>的<clinit></li>
<li>类构造器方法<clinit>()
<strong>不同于</strong>类的构造器，这些方法都是<strong>字节码文件中</strong>只能给<strong>JVM</strong>识别的特殊方法</li>
</ol>
</blockquote>
<h3 id="卸载">卸载</h3>
<p><strong>GC将无用对象从内存中卸载</strong></p>
<h2 id="类加载器的加载顺序">类加载器的加载顺序</h2>
<p>加载一个Class类的顺序也是有优先级的<strong>(加载，也可以称"查找")</strong>
，<strong>类加载器</strong>
<strong>从最底层开始往上</strong>的顺序：</p>
<ol type="1">
<li>BootStrap ClassLoader： rt.jar <strong>(lib/rt.jar)</strong></li>
<li>Extension ClassLoader: 加载扩展的jar包
<strong>(lib/ext/xxx.jar)</strong></li>
<li>APP ClassLoader： 指定的classpath下面的jar包<br />
</li>
<li>Custom ClassLoader： 自定义的类加载器</li>
</ol>
<h2 id="双亲委派机制">双亲委派机制</h2>
<ul>
<li><p>当一个类收到了加载请求时，它是<strong>不会先自己去尝试加载</strong>的，而是<strong>委派给父类</strong>去完成，比如我现在要
new 一个 Person，这个 Person
是我们自定义的类，如果我们要加载它，就会<strong>先委派 App
ClassLoader</strong>
，只有<strong>当父类加载器都反馈自己无法完成</strong>这个请求（也就是<strong>父类加载器都没有找到加载所需的
Class</strong>）时，子类加载器才会自行尝试加载。</p></li>
<li><p>好处：加载<strong>位于 rt.jar
包中的类</strong>时<strong>不管是哪个加载器加载</strong>，<strong>最终都会委托到
BootStrap ClassLoader</strong>
进行加载，这样保证了<strong>使用不同的类加载器得到的都是同一个结果</strong>。</p></li>
<li><p>其实这起了一个隔离的作用，避免自己写的代码影响<strong>JDK的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>尝试运行当前类的 <code>main</code>
函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了
rt.jar 中的<code>java.lang.String</code>，然而发现这个里面并没有
<code>main</code> 方法。</p>
</blockquote></li>
</ul>
<h1 id="运行时数据区">运行时数据区</h1>
<h2 id="本地方法栈和程序计数器">本地方法栈和程序计数器</h2>
<ul>
<li>比如说我们现在点开Thread类的源码，会看到它的start0方法带有一个native关键字修饰，而且<strong>不存在方法体</strong>，这种<strong>用native修饰的方法</strong>就是<strong>本地方法</strong>，这是使用C来实现的，然后一般这些方法都会放到一个叫做<strong>本地方法栈</strong>的区域。</li>
<li><strong>程序计数器</strong>其实就是<strong>一个指针</strong>，它<strong>指向了我们程序中下一句需要执行的指令</strong>，它也是<strong>内存区域中唯一一个不会出现OutOfMemoryError</strong>的区域，而且<strong>占用内存空间小到基本可以忽略不计</strong>。这个<strong>内存仅代表当前线程所执行的字节码的行号指示器</strong>，字节码解析器通过<strong>改变这个计数器的值选取下一条需要执行的字节码指令</strong>。
<ul>
<li>如果执行的是native方法，那这个指针就不工作了</li>
</ul></li>
</ul>
<h2 id="方法区">方法区</h2>
<ul>
<li>主要存放<strong>类的元数据信息</strong>、<strong>常量</strong>和<strong>静态变量</strong>...等。</li>
<li>存储过大时，会在无法满足内存分配时报错</li>
</ul>
<h2 id="虚拟机栈和虚拟机堆">虚拟机栈和虚拟机堆</h2>
<ul>
<li><strong>栈管运行</strong>，<strong>堆管存储</strong></li>
<li>虚拟机栈负责运行代码，虚拟机堆负责存储数据</li>
</ul>
<h3 id="虚拟机栈的概念">虚拟机栈的概念</h3>
<ul>
<li>虚拟机栈是Java<strong>方法执行的内存模型</strong></li>
<li>对<strong>局部变量</strong>、<strong>动态链表</strong>、<strong>方法出口</strong>、<strong>栈的操作(入栈和出栈)</strong>进行<strong>存储</strong>，且<strong>线程独享</strong>。</li>
<li>如果我们听到<strong>局部变量表</strong>，就是在说<strong>虚拟机栈</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="虚拟机栈存在的异常">虚拟机栈存在的异常</h3>
<ul>
<li>如果线程请求的栈的深度，<strong>大于虚拟机栈的最大深度</strong>，就会报<strong>StackOverflowError</strong>(比如递归)</li>
<li>Java虚拟机也可以<strong>动态扩展</strong>，但<strong>随着扩展会不断地申请内存</strong>，当无法申请足够内存时就会报错
<strong>OutOfMemoryError</strong></li>
</ul>
<h3 id="虚拟机栈的生命周期">虚拟机栈的生命周期</h3>
<ul>
<li>栈<strong>不存在垃圾回收</strong>，只要程序运行结束，栈的空间自然释放</li>
<li>栈的<strong>生命周期和所处的线程</strong>一致</li>
<li><strong>8种基本类型的变量+对象的引用变量+实例方法</strong>，都是在栈里面分配内存</li>
</ul>
<h3 id="虚拟机栈的执行">虚拟机栈的执行</h3>
<ul>
<li><strong>栈帧</strong>数据，在JVM中叫<strong>栈帧</strong>，Java中叫<strong>方法</strong>，它也是放在栈中</li>
<li>栈中的数据以<strong>栈帧</strong>的格式存在，它是一个<strong>关于方法</strong>和<strong>运行期数据</strong>的数据集</li>
</ul>
<blockquote>
<p>比如我们执行一个方法a，就会对应产生一个栈帧A1，然后A1会被压入栈中。同理方法b会有一个B1，方法c会有一个C1，等到这个线程执行完毕后，栈会先弹出C1，后B1,A1。它是一个先进后出，后进先出原则。</p>
</blockquote>
<h3 id="局部变量的复用">局部变量的复用</h3>
<ul>
<li><p>用于<strong>存放方法参数</strong>和<strong>方法内部所定义的局部变量</strong></p></li>
<li><p>容量以<strong>Slot</strong>为最小单位，一个slot可以存放32以内的数据类型。</p>
<blockquote>
<p>在局部变量表里，<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型（long和double）占两个slot</strong>。</p>
</blockquote></li>
<li><p>虚拟机通过索引方式使用局部变量表，范围为 <strong>[ 0 ,
局部变量表的slot的数量
]</strong>。方法中的<strong>参数</strong>就会<strong>按一定顺序排列</strong>在这个局部变量表中</p></li>
<li><p>为了节省栈帧空间，这些<strong>slot</strong>是可以复用的。当方法<strong>执行位置超过了某个变量（这里意思应该是用过了这个变量）</strong>，那么<strong>这个变量的slot可以被其它变量复用</strong>。当然如果需要复用，那我们的<strong>垃圾回收自然就不会去动这些内存</strong></p></li>
</ul>
<h3 id="虚拟机堆的概念">虚拟机堆的概念</h3>
<ul>
<li><p>JVM内存会划分为<strong>堆内存</strong>和<strong>非堆内存</strong>，<strong>堆内存</strong>也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而<strong>非堆内存</strong>则为<strong>永久代</strong>。</p></li>
<li><p>年轻代又分为<strong>Eden</strong>和<strong>Survivor</strong>区，Survivor还分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace的survivor区域是空的</p></li>
<li><p><strong>Eden：FromPlace：ToPlace</strong>的默认占比是8：1：1，当然这个东西也可以通过一个<code>-XX:+UsePSAdaptiveSurvivorSizePolicy</code>参数来<strong>根据生成对象的速率动态调整</strong><br />
（因为存活的对象相对较少）</p></li>
<li><p>堆内存中<strong>存放的是对象</strong>，垃圾收集就是<strong>收集这些对象然后交给GC算法进行回收</strong>。非堆内存其实我们已经说过了，就是<strong>方法区</strong>。在<strong>1.8中已经移除永久代</strong>，替代品是一个<strong>元空间(MetaSpace)</strong>，最大区别是<strong>metaSpace是不存在于JVM</strong>中的，它<strong>使用的是本地内存</strong>。并有两个参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MetaspaceSize：初始化元空间大小，控制发生GC</span><br><span class="line">MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。</span><br></pre></td></tr></table></figure></li>
<li><p>移除的原因<br />
融合<strong>HotSpot JVM和JRockit
VM</strong>而做出的改变，因为<strong>JRockit是没有永久代</strong>的，不过这也<strong>间接性地解决了永久代的OOM</strong>问题。</p></li>
</ul>
<h3 id="eden年轻代的介绍">Eden年轻代的介绍</h3>
<ul>
<li><p>当new一个对象后，会放到<strong>Eden划分出来的一块作为存储空间的内存</strong>，由于堆内存共享，所以<strong>可能出现两个对象共用一个内存的情况</strong>。</p>
<blockquote>
<p>JVM的处理：<strong>为每个内存</strong>都<strong>预先申请</strong>好一块连续的内存空间并<strong>规定对象存放的位置</strong>，如果空间不足会再申请多块内存空间。这个操作称为TLAB</p>
</blockquote></li>
<li><p>Eden空间满了之后，会触发<strong>MinorGC（发生在年轻代的GC）</strong>操作，<strong>存活下来的对象</strong>移动到<strong>Survivor0区</strong>。<strong>Survivor0满后会触发MInorGC</strong>，将<strong>存活对象（这里应该包括Eden的存活对象?）移动到Survivor1区</strong>，此时还会<strong>把from和to两个指针交换</strong>，这样<strong>保证</strong>一段时间内<strong>总有一个survivor区为空且所指向的survivor区为空</strong>。</p></li>
<li><p>经过<strong>多次的MinorGC后仍然存活的对象</strong>(这里存活判断是15次，对应的虚拟机参数为<code>-XX:MaxTenuringThreshold</code>
。HotSpot会在对象中的<strong>标记字段</strong>里记录年龄，分配到的空间<strong>仅有4位</strong>，所以<strong>最多记录到15</strong>)会移动到老年代。</p></li>
<li><p>老年代是存储长期存活对象的，<strong>占满</strong>时就会触发我们常说的FullGC，期间会<strong>停止所有线程</strong>等待GC的完成。所以对于<strong>响应要求高</strong>的应用，应该尽量去<strong>减少</strong>发生FullGC从而避免响应超时的问题</p></li>
<li><p>当老年区<strong>执行full
gc周仍然无法进行对象保存</strong>操作，就会产生<strong>OOM</strong>。这时候就是虚拟机中堆内存不足，<strong>原因可能会是</strong>堆内存设置大小过小，可以通过参数<strong>-Xms、-Xmx</strong>来调整。也可能是<strong>代码中创建对象大且多</strong>，而且它们<strong>一直在被引用</strong>从而<strong>长时间垃圾收集无法收集</strong>它们</p></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/c02ecba3c33f43429a765987b928e423-new-image93b46f3d-33f9-46f9-a825-ec7129b004f6.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<blockquote>
<p>关于-XX:TargetSurvivorRatio参数的问题。其实也不一定是要满足-XX:MaxTenuringThreshold才移动到老年代。可以举个例子：如<strong>对象年龄5的占30%，年龄6的占36%，年龄7的占34%，加入某个年龄段（如例子中的年龄6）</strong>后，总占用超过Survivor空间*TargetSurvivorRatio的时候，从该年龄段开始及大于的年龄对象就要进入老年代（即例子中的年龄6对象，就是年龄6和年龄7晋升到老年代），这时候无需等到MaxTenuringThreshold中要求的15</p>
</blockquote>
<h3 id="如何判断一个对象需要被干掉">如何判断一个对象需要被干掉</h3>
<p>首先看一下对象的虚拟机的一些流程</p>
<p>图例有点问题，<strong>橙色是线程共享，青绿色是线程独享</strong> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1c1d85b5fb8b47239af2a5c0436eb2d7-new-image0cd10827-2f96-433c-9b16-93d4fe491d88.png"
alt="img" /></p>
<ul>
<li><p>图中<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>，3个区域随着线程生存而生存。<strong>内存分配</strong>和<strong>回收</strong>都是确定的，<strong>随着线程的结束</strong>内存自然就被回收了，因此不需要考虑垃圾回收问题。</p></li>
<li><p><strong>Java堆和方法区</strong>则不一样，各线程共享，内存的分配和回收都是动态的，垃圾收集器所关注的就是<strong>堆</strong>和<strong>方法区</strong>这部分内存</p></li>
<li><p>垃圾回收前，判断<strong>哪些对象还存活</strong>，<strong>哪些已经死去</strong>。下面介绍连个基础计算方法：</p>
<ol type="1">
<li><p><strong>引用计数器</strong>计算：给对象添加一个<strong>引用计数器</strong>，每次<strong>引用这个对象时计数器加一</strong>，<strong>引用失效时减一</strong>，<strong>计数器等于0</strong>就是不会再次使用的。不过有一种情况，就是
出现<strong>对象的循环引用时GC没法回收</strong>（我觉得不是非得循环，如果一个对象a中有属性引用另一个对象b，而a指向null，那么按这种方式，b就没有办法被回收）。</p></li>
<li><p>可达性分析计算：一种类似<strong>二叉树</strong>的实现，将一系列的<strong>GC
ROOTS作为起始的存活对象集</strong>，从这个结点往下搜索，<strong>搜索所走过的路径成为引用链</strong>，把<strong>能被该集合引用到的对象加入该集合</strong>中。</p>
<blockquote>
<p><strong>当一个对象到GC
Roots没有使用任何引用链</strong>时，则说明<strong>该对象是不可用的</strong>。Java，C#都是用这个方法判断对象是否存活</p>
</blockquote>
<p>Java语言汇总作为GCRoots的对象分为以下几种：</p>
<ol type="1">
<li><p><strong>虚拟机栈</strong>（栈帧中的<strong>本地方法表</strong>）中引用的对象（局部变量）</p></li>
<li><p><strong>方法区中静态变量</strong>所引用的对象（静态变量）</p></li>
<li><p><strong>方法区中常量</strong>引用的变量</p></li>
<li><p>本地方法栈（即native修饰的方法）中JNI引用的对象</p>
<blockquote>
<p>（JNI是Java虚拟机调用对应的C函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）</p>
</blockquote></li>
<li><p>已启动的且未终止的Java线程【这个描述好像是有问题的(不全)，应该是<strong>用作同步监视器的对象</strong>】</p></li>
</ol>
<p>这种方法的优点是，<strong>能够解决循环引用</strong>的问题，可它的实现<strong>耗费大量资源</strong>和时间，也需要GC(<strong>分析过程引用关系不能发生变化</strong>，所以需要停止所有进程)</p></li>
</ol></li>
</ul>
<h3 id="如何宣告一个对象的真正死亡">如何宣告一个对象的真正死亡</h3>
<ul>
<li><p>首先，需要提到finalize()方法，是Object类的一个方法，一个<strong>对象的finalize()</strong>方法<strong>只会被</strong>系统<strong>自动调用一次</strong>，<strong>经过finalize()方法逃脱死亡的对象(比如在方法中，其他变量又一次引用了该对象)</strong>，第二次不会再被调用</p>
<blockquote>
<p>并不提倡在程序中调用finalize()来进行自救。建议忘掉Java程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在Java9中已经被标记为
<strong>deprecated</strong> ，且
<code>java.lang.ref.Cleaner</code>（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比
<code>finalize</code> 来<br />
<code>deprecated英[ˈdeprəkeɪtɪd]美[ˈdeprəkeɪtɪd]</code></p>
</blockquote></li>
<li><p>判断一个对象的死亡至少需要两次标记</p>
<ol type="1">
<li>如果对象可达性分析之后没发现<strong>与GC
Roots相连的引用链</strong>，那它将会被第一次标记并且进行一次筛选，<strong>判断条件是</strong>是决定<strong>这个对象是否有必要执行finalize()</strong>方法。如果对象有必要执行finalize()，则被放入F-Queue队列</li>
<li>GC堆F-Queue队列中的对象<strong>进行二次标记</strong>。如果对象在finalize()方法中<strong>重新与引用链上的任何一个对象建立了关联</strong>，那么二<strong>次标记时则会将它移出“即将回收”集合</strong>。<strong>如果</strong>此时对象<strong>还没成功逃脱</strong>，那么<strong>只能被回收</strong>了。</li>
</ol></li>
</ul>
<h2 id="垃圾回收算法">垃圾回收算法</h2>
<p>确定对象已经死亡，此刻需要回收这些垃圾。常用的有<strong>标记清除</strong>、<strong>复制</strong>、<strong>标记整理</strong>、和<strong>分代收集算法</strong>。</p>
<h3 id="标记清除算法">标记清除算法</h3>
<ul>
<li>标记清除算法就是分为<strong>”标记“</strong>和<strong>”清除“</strong>两个阶段。标记出所有需要回收的对象，标记结束后统一回收。<strong>后续算法都根据这个基础来加以改进</strong></li>
<li>即：把已死亡的对象标记为空闲内存，然后记录在空闲列表中，当我们需要new一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象
<ul>
<li>不足方面：标记和清除<strong>效率比较低</strong>，且这种做法让<strong>内存中碎片非常多</strong>
。导致如果我们需要使用较大内存卡时，无法分配到足够的连续内存</li>
</ul></li>
<li>如图，可使用的内存都是零零散散的，导致大内存对象问题 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/01605d96d85f4daab9bfa5e7000f0d31-new-image78e03b85-fbef-4df9-b41e-2b63d78d119f.png"
alt="img" /></li>
</ul>
<h3 id="复制算法">复制算法</h3>
<ul>
<li><p>为了解决效率问题，出现了<strong>复制</strong>算法。将内存<strong>按容量</strong>划分成两等份，每次只使用其中的一块，<strong>和survivor一样</strong>用from和to两个指针。fromPlace存满了，就把存活对象copy到另一块toPlace上，然后交换指针内容，就解决了碎片问题</p>
<ul>
<li>代价：内存缩水，即堆内存的<strong>使用效率</strong>变低了</li>
</ul>
<blockquote>
<p>默认情况Eden和Survivor 为 8: 2 （Eden : S0 : S1 = 8：1：1）</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/fc349fbb9b204495a5321febe27818d4-new-image45920a9a-552c-4656-94d6-e3ca45ff9b76.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
</ul>
<h3 id="标记整理">标记整理</h3>
<ul>
<li>复制算法在<strong>对象存活率高</strong>的时候，仍然有效率问题（要复制的多）。</li>
<li>标记整理--&gt;
标记过程与<strong>标记-清除</strong>一样，但后续<strong>不是直接对可回收对象进行清理</strong>，而是让所有<strong>存活对象都向一端移动</strong>，然后直接<strong>清理掉边界以外</strong>内存</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/2599e9f722074d34a3f7fd9f0076f121-new-imagec76192ec-b63a-43e3-a6d6-cf01f749953f.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="分代收集算法">分代收集算法</h3>
<ul>
<li>这种算法并没有什么新的思想，只是<strong>根据对象存活周期的不同将内存划分为几块</strong></li>
<li>一般是将<strong>Java堆分为新生代和老年代</strong>，即可根据各个年代特点采用最适当的收集算法
<ul>
<li><strong>新生代</strong>中，每次垃圾收集时会有大批对象死去，<strong>只有少量存活</strong>，就采用复制算法，只需要付出<strong>少量存活对象的复制成本</strong>即可完成收集</li>
<li><strong>老年代</strong>中，因为存活对象存活率高，也没有<strong>额外空间</strong>对它进行分配担保（<code>新生代如果不够可以放老年代，而老年代清理失败就会OutOfMemory，不像新生代可以移动到老年代</code>），所以必须使用<strong>“标记-清理”</strong>或者<strong>“标记-整理”</strong>来进行回收</li>
</ul></li>
<li>即：具体问题具体分析</li>
</ul>
<h2 id="了解各种各样的垃圾回收器">（了解）各种各样的垃圾回收器</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/11e9dcd0f1ee4f25836e6f1c47104c51-new-image69e1c56a-1d40-493a-9901-6efc647a01f3.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li><p>新生代的垃圾回收器：Serial（串行--复制），ParNew（并行--复制），ParallelScavenge（并行--复制）</p></li>
<li><p>老年代的垃圾回收器：SerialOld（串行--标记整理），ParallelOld（并行--标记整理），CMS（并发--标记清除）</p></li>
<li><p>只有CMS和G1是并发，且CMS只作用于老年代，而G1都有</p></li>
<li><p>JDK8为止，默认垃圾回收器是Parallel Scavenge和Parallel
Old【<strong>并行--复制</strong>和<strong>并行--标记整理</strong>】</p></li>
<li><p>JDK9开始，<strong>G1收集器成为默认的垃圾收集器</strong>，目前来看，<strong>G1回收期停顿时间最短</strong>且没有明显缺点，偏适合Web应用</p></li>
</ul>
<blockquote>
<p>jdk8中测试Web应用，堆内存6G中新生代4.5G的情况下</p>
<ul>
<li>ParallelScavenge回收新生代停顿长达1.5秒。</li>
<li>G1回收器回收同样大小的新生代只停顿0.2秒</li>
</ul>
</blockquote>
<h2 id="了解-jvm的常用参数">（了解） JVM的常用参数</h2>
<p>JVM的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th>参数名称</th>
<th>含义</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-Xms</td>
<td>初始堆大小</td>
<td>物理内存的1/64(&lt;1GB)</td>
<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td>
</tr>
<tr class="even">
<td>-Xmx</td>
<td>最大堆大小</td>
<td>物理内存的1/4(&lt;1GB)</td>
<td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到
-Xms的最小限制</td>
</tr>
<tr class="odd">
<td>-Xmn</td>
<td>年轻代大小(1.4or later)</td>
<td></td>
<td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New
gen是不同的。整个堆大小=年轻代大小 + 老年代大小 +
持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td>
</tr>
<tr class="even">
<td>-XX:NewSize</td>
<td>设置年轻代大小(for 1.3/1.4)</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>-XX:MaxNewSize</td>
<td>年轻代最大值(for 1.3/1.4)</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>-XX:PermSize</td>
<td>设置持久代(perm gen)初始值</td>
<td>物理内存的1/64</td>
<td></td>
</tr>
<tr class="odd">
<td>-XX:MaxPermSize</td>
<td>设置持久代最大值</td>
<td>物理内存的1/4</td>
<td></td>
</tr>
<tr class="even">
<td>-Xss</td>
<td>每个线程的堆栈大小</td>
<td></td>
<td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行
调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用，
如果栈不是很深， 应该是128k够用的
大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss
is translated in a VM flag named
ThreadStackSize”一般设置这个值就可以了</td>
</tr>
<tr class="odd">
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>
<td></td>
<td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td>
</tr>
<tr class="even">
<td>-XX:SurvivorRatio</td>
<td>Eden区与Survivor区的大小比值</td>
<td></td>
<td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>
</tr>
<tr class="odd">
<td>-XX:+DisableExplicitGC</td>
<td>关闭System.gc()</td>
<td></td>
<td>这个参数需要严格的测试</td>
</tr>
<tr class="even">
<td>-XX:PretenureSizeThreshold</td>
<td>对象超过多大是直接在旧生代分配</td>
<td>0</td>
<td>单位字节 新生代采用Parallel
ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td>
</tr>
<tr class="odd">
<td>-XX:ParallelGCThreads</td>
<td>并行收集器的线程数</td>
<td></td>
<td>此值最好配置与处理器数目相等 同样适用于CMS</td>
</tr>
<tr class="even">
<td>-XX:MaxGCPauseMillis</td>
<td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td>
<td></td>
<td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td>
</tr>
</tbody>
</table>
<p>其实还有一些打印及CMS方面的参数，这里就不以一一列举了</p>
<h1 id="关于jvm调优的一些方面">关于JVM调优的一些方面</h1>
<ul>
<li>默认
<ul>
<li>年轻代：老年代 = 1: 2</li>
<li>年轻代中 Eden : S0 : S 1 = 8 : 1 ：1</li>
</ul></li>
<li>根据刚刚涉及的jvm知识点，可以尝试对JVM进行调优，<strong>主要是堆内存</strong>那块</li>
<li><strong>所有线程共享数据区大小</strong>=<strong>新生代大小</strong>+<strong>老年代大小</strong>+<strong>持久代大小</strong>
（即 堆 + 方法区）</li>
<li>持久代一般固定大小为64m，</li>
<li>java堆中增大年轻代后，会减少老年代大小（因为老年代的清理使用fullgc，所以老年代过小的话反而会增多fullgc）。
年轻代 <code>-Xmn</code>的值推荐配置为<strong>java堆的3/8</strong></li>
</ul>
<h2 id="调整最大堆内存和最小堆内存">调整最大堆内存和最小堆内存</h2>
<ul>
<li><p>-Xmx -Xms：指定java堆最大值（默认 物理内存的1/4 (&lt;1 GB ) ) 和
初始java堆最小值（默认值是物理内存的1/64 (&lt;1GB) ）</p></li>
<li><p>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到
-Xms的最小限制。</p>
<blockquote>
<p>简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于40%了，JVM就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于70%，又会动态缩小不过不会小于–Xms。就这么简单</p>
</blockquote></li>
<li><p>开发过程中，通常会将 -Xms 与 Xmx 两个参数设置成相同的值</p>
<blockquote>
<p>为的是能够在java垃圾回收机制清理完堆区后，<strong>不需要重新分隔计算堆区的大小而浪费资源（向系统请求/释放内存资源）</strong></p>
</blockquote></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);    <span class="comment">//系统的最大空间-Xmx--运行几次都不变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//系统的空闲空间--每次运行都变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//当前可用的总空间 与Xms有关--运行几次都不变</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* -----</span></span><br><span class="line"><span class="comment">Xmx=7389184.0KB</span></span><br><span class="line"><span class="comment">free mem=493486.0546875KB</span></span><br><span class="line"><span class="comment">total mem=498688.0KB</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol type="1">
<li>maxMemory()这个方法返回的是java虚拟机(这个进程)能构从操纵系统那里挖到的最大的内存</li>
<li>freeMemory：挖过来而又没有用上的内存，实际上就是
freeMemory()，所以freeMemory()的值一般情况下都是很小的(totalMemory一般比需要用得多一点，剩下的一点就是freeMemory)</li>
<li>totalMemory：程序运行的过程中，内存总是慢慢的从操纵系统那里挖的，基本上是用多少挖多少，直
挖到maxMemory()为止，所以totalMemory()是慢慢增大的
原文链接：https://blog.csdn.net/weixin_35671171/article/details/114189796</li>
</ol>
</blockquote></li>
<li><p>编辑VM options参数后再看效果：<br />
<figure class="highlight plaintext"><figcaption><span>-Xms5m -XX:+PrintGCDetails```，堆最大以及堆初始值  20m和5m</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">/* 效果</span><br><span class="line"> [GC (Allocation Failure) [PSYoungGen: 1024K-&gt;488K(1536K)] 1024K-&gt;608K(5632K), 0.0007606 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Xmx=18432.0KB</span><br><span class="line">free mem=4249.90625KB</span><br><span class="line">total mem=5632.0KB</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 1536K, used 1326K [0x00000000ff980000, 0x00000000ffb80000, 0x0000000100000000)</span><br><span class="line">  eden space 1024K, 81% used [0x00000000ff980000,0x00000000ffa51ad0,0x00000000ffa80000)</span><br><span class="line">  from space 512K, 95% used [0x00000000ffa80000,0x00000000ffafa020,0x00000000ffb00000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000ffb00000,0x00000000ffb00000,0x00000000ffb80000)</span><br><span class="line"> ParOldGen       total 4096K, used 120K [0x00000000fec00000, 0x00000000ff000000, 0x00000000ff980000)</span><br><span class="line">  object space 4096K, 2% used [0x00000000fec00000,0x00000000fec1e010,0x00000000ff000000)</span><br><span class="line"> Metaspace       used 3164K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 344K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>如上， <strong>Allocation Failure</strong>
因为分配失败导致YoungGen</li>
<li>total mem (此时申请到的总内存)：<br />
PSYoungGen + ParOldGen = 1536 + 4096 = 5632 KB</li>
<li>freeMemory (申请后没有使用的内存)<br />
1324 + 120 = 1444 KB 5632 - 4249 = 1383 KB 差不多</li>
</ol></li>
<li><p>使用1M后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);    <span class="comment">//系统的最大空间-Xmx--运行几次都不变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//系统的空闲空间--每次运行都变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//当前可用的总空间 与Xms有关--运行几次都不变</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;分配了1M空间给数组&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> [GC (Allocation Failure) [PSYoungGen: 1024K-&gt;488K(1536K)] 1024K-&gt;608K(5632K), 0.0007069 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">Xmx=18432.0KB</span></span><br><span class="line"><span class="comment">free mem=4270.15625KB</span></span><br><span class="line"><span class="comment">total mem=5632.0KB</span></span><br><span class="line"><span class="comment">分配了1M空间给数组</span></span><br><span class="line"><span class="comment">Xmx=18.0M</span></span><br><span class="line"><span class="comment">free mem=3.1700592041015625M  //少了1M</span></span><br><span class="line"><span class="comment">total mem=5.5M</span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> PSYoungGen      total 1536K, used 1270K [0x00000000ff980000, 0x00000000ffb80000, 0x0000000100000000)</span></span><br><span class="line"><span class="comment">  eden space 1024K, 76% used [0x00000000ff980000,0x00000000ffa43aa0,0x00000000ffa80000)</span></span><br><span class="line"><span class="comment">  from space 512K, 95% used [0x00000000ffa80000,0x00000000ffafa020,0x00000000ffb00000)</span></span><br><span class="line"><span class="comment">  to   space 512K, 0% used [0x00000000ffb00000,0x00000000ffb00000,0x00000000ffb80000)</span></span><br><span class="line"><span class="comment"> ParOldGen       total 4096K, used 1144K [0x00000000fec00000, 0x00000000ff000000, 0x00000000ff980000)</span></span><br><span class="line"><span class="comment">  object space 4096K, 27% used [0x00000000fec00000,0x00000000fed1e020,0x00000000ff000000)</span></span><br><span class="line"><span class="comment"> Metaspace       used 3155K, capacity 4496K, committed 4864K, reserved 1056768K</span></span><br><span class="line"><span class="comment">  class space    used 344K, capacity 388K, committed 512K, reserved 1048576K</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>此时free memory就又缩水了，不过<strong>total
memory是没有变化</strong>的。Java会尽可能将<strong>total
mem的值维持在最小堆内存大小</strong></p></li>
<li><p>这时候我们创建了一个10M的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的total
memory已经变成了15M，这就是已经申请了一次内存的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);    <span class="comment">//系统的最大空间-Xmx--运行几次都不变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//系统的空闲空间--每次运行都变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//当前可用的总空间 与Xms有关--运行几次都不变</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;分配了1M空间给数组&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] c = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;分配了10M空间给数组&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//当前可用的总空间</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**  ----</span></span><br><span class="line"><span class="comment">[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;488K(1536K)] 1024K-&gt;600K(5632K), 0.0006681 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">Xmx=18432.0KB</span></span><br><span class="line"><span class="comment">free mem=4257.953125KB</span></span><br><span class="line"><span class="comment">total mem=5632.0KB</span></span><br><span class="line"><span class="comment">分配了1M空间给数组</span></span><br><span class="line"><span class="comment">Xmx=18.0M</span></span><br><span class="line"><span class="comment">free mem=3.1153564453125M</span></span><br><span class="line"><span class="comment">total mem=5.5M</span></span><br><span class="line"><span class="comment">分配了10M空间给数组</span></span><br><span class="line"><span class="comment">Xmx=18.0M</span></span><br><span class="line"><span class="comment">free mem=2.579681396484375M</span></span><br><span class="line"><span class="comment">total mem=15.0M</span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> PSYoungGen      total 1536K, used 1363K [0x00000000ff980000, 0x00000000ffb80000, 0x0000000100000000)</span></span><br><span class="line"><span class="comment">  eden space 1024K, 85% used [0x00000000ff980000,0x00000000ffa5acc0,0x00000000ffa80000)</span></span><br><span class="line"><span class="comment">  from space 512K, 95% used [0x00000000ffa80000,0x00000000ffafa020,0x00000000ffb00000)</span></span><br><span class="line"><span class="comment">  to   space 512K, 0% used [0x00000000ffb00000,0x00000000ffb00000,0x00000000ffb80000)</span></span><br><span class="line"><span class="comment"> ParOldGen       total 13824K, used 11376K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000)</span></span><br><span class="line"><span class="comment">  object space 13824K, 82% used [0x00000000fec00000,0x00000000ff71c020,0x00000000ff980000)</span></span><br><span class="line"><span class="comment"> Metaspace       used 3242K, capacity 4500K, committed 4864K, reserved 1056768K</span></span><br><span class="line"><span class="comment">  class space    used 351K, capacity 388K, committed 512K, reserved 1048576K</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>此时我们再跑一下这个代码</p>
<p>此时要调整垃圾收集器(<code>-XX:+UseG1GC</code>)且b、c要指向null，才能让系统回收这部分内存，即<code>-Xmx20m -Xms5m -XX:+PrintGCDetails -XX:+UseG1GC</code>
<strong>注：使用<code>-XX: +UseSerialGC</code>或者<code>-XX:+UseParallelGC</code>都是不能达到效果的</strong></p>
<blockquote>
<p>此时我们手动执行了一次fullgc，此时total
memory的内存空间又变回6.0M了，此时又是把申请的内存释放掉的结果。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);    <span class="comment">//系统的最大空间-Xmx--运行几次都不变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//系统的空闲空间--每次运行都变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//当前可用的总空间 与Xms有关--运行几次都不变</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;分配了1M空间给数组&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] c = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;分配了10M空间给数组&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//当前可用的总空间</span></span><br><span class="line"></span><br><span class="line">        b=<span class="literal">null</span>;</span><br><span class="line">        c=<span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;进行了gc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);    <span class="comment">//系统的最大空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//当前可用的总空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------</span></span><br><span class="line"><span class="comment">Xmx=20480.0KB</span></span><br><span class="line"><span class="comment">free mem=4290.3671875KB</span></span><br><span class="line"><span class="comment">total mem=6144.0KB</span></span><br><span class="line"><span class="comment">分配了1M空间给数组</span></span><br><span class="line"><span class="comment">Xmx=20.0M</span></span><br><span class="line"><span class="comment">free mem=3.1897964477539062M</span></span><br><span class="line"><span class="comment">total mem=6.0M</span></span><br><span class="line"><span class="comment">[GC pause (G1 Humongous Allocation) (young) (initial-mark), 0.0014754 secs]</span></span><br><span class="line"><span class="comment">   [Parallel Time: 1.1 ms, GC Workers: 8]</span></span><br><span class="line"><span class="comment">      [GC Worker Start (ms): Min: 105.0, Avg: 105.1, Max: 105.3, Diff: 0.3]</span></span><br><span class="line"><span class="comment">      [Ext Root Scanning (ms): Min: 0.5, Avg: 0.5, Max: 0.8, Diff: 0.4, Sum: 4.4]</span></span><br><span class="line"><span class="comment">      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span><br><span class="line"><span class="comment">         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]</span></span><br><span class="line"><span class="comment">      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span><br><span class="line"><span class="comment">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span><br><span class="line"><span class="comment">      [Object Copy (ms): Min: 0.1, Avg: 0.3, Max: 0.4, Diff: 0.2, Sum: 2.5]</span></span><br><span class="line"><span class="comment">      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.3]</span></span><br><span class="line"><span class="comment">         [Termination Attempts: Min: 1, Avg: 6.0, Max: 9, Diff: 8, Sum: 48]</span></span><br><span class="line"><span class="comment">      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.2]</span></span><br><span class="line"><span class="comment">      [GC Worker Total (ms): Min: 0.8, Avg: 0.9, Max: 1.0, Diff: 0.3, Sum: 7.4]</span></span><br><span class="line"><span class="comment">      [GC Worker End (ms): Min: 106.0, Avg: 106.1, Max: 106.1, Diff: 0.0]</span></span><br><span class="line"><span class="comment">   [Code Root Fixup: 0.0 ms]</span></span><br><span class="line"><span class="comment">   [Code Root Purge: 0.0 ms]</span></span><br><span class="line"><span class="comment">   [Clear CT: 0.1 ms]</span></span><br><span class="line"><span class="comment">   [Other: 0.3 ms]</span></span><br><span class="line"><span class="comment">      [Choose CSet: 0.0 ms]</span></span><br><span class="line"><span class="comment">      [Ref Proc: 0.1 ms]</span></span><br><span class="line"><span class="comment">      [Ref Enq: 0.0 ms]</span></span><br><span class="line"><span class="comment">      [Redirty Cards: 0.1 ms]</span></span><br><span class="line"><span class="comment">      [Humongous Register: 0.0 ms]</span></span><br><span class="line"><span class="comment">      [Humongous Reclaim: 0.0 ms]</span></span><br><span class="line"><span class="comment">      [Free CSet: 0.0 ms]</span></span><br><span class="line"><span class="comment">   [Eden: 2048.0K(3072.0K)-&gt;0.0B(1024.0K) Survivors: 0.0B-&gt;1024.0K Heap: 2877.6K(6144.0K)-&gt;1955.9K(6144.0K)]</span></span><br><span class="line"><span class="comment"> [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">[GC concurrent-root-region-scan-start]</span></span><br><span class="line"><span class="comment">[GC concurrent-root-region-scan-end, 0.0005373 secs]</span></span><br><span class="line"><span class="comment">[GC concurrent-mark-start]</span></span><br><span class="line"><span class="comment">[GC concurrent-mark-end, 0.0000714 secs]</span></span><br><span class="line"><span class="comment">[GC remark [Finalize Marking, 0.0001034 secs] [GC ref-proc, 0.0000654 secs] [Unloading, 0.0005193 secs], 0.0007843 secs]</span></span><br><span class="line"><span class="comment"> [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">[GC cleanup 11M-&gt;11M(17M), 0.0003613 secs]</span></span><br><span class="line"><span class="comment"> [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">分配了10M空间给数组</span></span><br><span class="line"><span class="comment">Xmx=20.0M</span></span><br><span class="line"><span class="comment">free mem=5.059120178222656M</span></span><br><span class="line"><span class="comment">total mem=17.0M</span></span><br><span class="line"><span class="comment">[Full GC (System.gc())  11M-&gt;654K(6144K), 0.0031959 secs]</span></span><br><span class="line"><span class="comment">   [Eden: 1024.0K(1024.0K)-&gt;0.0B(2048.0K) Survivors: 1024.0K-&gt;0.0B Heap: 11.9M(17.0M)-&gt;654.4K(6144.0K)], [Metaspace: 3152K-&gt;3152K(1056768K)]</span></span><br><span class="line"><span class="comment"> [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">进行了gc</span></span><br><span class="line"><span class="comment">Xmx=20.0M</span></span><br><span class="line"><span class="comment">free mem=5.2661590576171875M</span></span><br><span class="line"><span class="comment">total mem=6.0M</span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> garbage-first heap   total 6144K, used 654K [0x00000000fec00000, 0x00000000fed00030, 0x0000000100000000)</span></span><br><span class="line"><span class="comment">  region size 1024K, 1 young (1024K), 0 survivors (0K)</span></span><br><span class="line"><span class="comment"> Metaspace       used 3243K, capacity 4500K, committed 4864K, reserved 1056768K</span></span><br><span class="line"><span class="comment">  class space    used 351K, capacity 388K, committed 512K, reserved 1048576K</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="调整新生代和老年代的比值">调整新生代和老年代的比值</h2>
<p>-XX:NewRatio ---
新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p>
<blockquote>
<p>例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的1/5。在Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。
注：Xmn为直接设置大小，如<code>-Xmn2G</code></p>
</blockquote>
<h2 id="调整survivor区和eden区的比值">调整Survivor区和Eden区的比值</h2>
<p>-XX:SurvivorRatio（幸存代）--- 设置两个Survivor区和eden的比值</p>
<p>例如：8，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10</p>
<h2 id="设置年轻代和老年代的大小">设置年轻代和老年代的大小</h2>
<p>-XX:NewSize --- 设置年轻代大小</p>
<p>-XX:MaxNewSize --- 设置年轻代最大值</p>
<blockquote>
<p>可以通过设置不同参数来测试不同的情况，反正<strong>最优解</strong>当然就是<strong>官方的Eden和Survivor的占比为8:1:1</strong>，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正<strong>最大堆内存和最小堆内存如果数值不同会导致多次的gc</strong>，需要注意。</p>
<blockquote>
<p>我的理解是<strong>会经常调整totalMemory而导致多次gc</strong>，避免临界条件下的<a
href="https://so.csdn.net/so/search?q=垃圾回收&amp;spm=1001.2101.3001.7020">垃圾回收</a>和内存申请和分配</p>
</blockquote>
<p>注：
<strong>最大堆内存和最小堆内存</strong>设置成一样，为的是能够在java垃圾回收机制清理完堆区后，<strong>不需要重新分隔计算堆区的大小而浪费资源（向系统请求/释放内存资源）</strong></p>
</blockquote>
<h2 id="小总结">小总结</h2>
<p>根据实际事情调整新生代和幸存代的大小，官方推荐<strong>新生代占java堆的3/8</strong>，<strong>幸存代</strong>占<strong>新生代</strong>的1/10</p>
<blockquote>
<p>Java堆：新生代 <strong>(3/8)</strong>，老年代</p>
<p>新生代：SO <strong>(1/10)</strong> ，S1 ，Eden</p>
</blockquote>
<p>在OOM时，记得Dump出堆，确保可以排查现场问题，通过下面命令可以输出一个.dump
文件，该文件用<strong>VisualVM</strong>或Java自带的JavaVisualVM 工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径</span><br></pre></td></tr></table></figure>
<p>一般我们也可以通过<strong>编写脚本的方式来让OOM出现时给我们报个信</strong>，可以<strong>通过发送邮件</strong>或者<strong>重启程序</strong>等来解决</p>
<h2 id="永久区的设置">永久区的设置</h2>
<ul>
<li><p><code>-XX:PermSize -XX:MaxPermSize</code>，应该说的是永久代</p></li>
<li><p>初始空间（默认为物理内存的1/64）和最大空间（默认为物理内存的1/4）。也就是说，jvm启动时，永久区一开始就占用了PermSize大小的空间，如果空间还不够，可以继续扩展，但是不能超过MaxPermSize，否则会OOM。</p></li>
<li><p>如果堆空间没有用完也抛出了OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出
一样抛出OOM</p></li>
</ul>
<h2 id="jvm的栈参数调优">JVM的栈参数调优</h2>
<h3 id="调整每个线程栈空间的大小">调整每个线程栈空间的大小</h3>
<p>可以通过<strong>-Xss</strong>：调整每个线程栈空间的大小</p>
<blockquote>
<p>JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右</p>
</blockquote>
<h3 id="设置线程栈的大小">设置线程栈的大小</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XXThreadStackSize：</span><br><span class="line">    #设置线程栈的大小(0 means use default stack size)</span><br></pre></td></tr></table></figure>
<p>补充：</p>
<blockquote>
<p>-Xss是OpenJDK和Oracle JDK的-XX:ThreadStackSize的别名。</p>
<p>尽管他们对参数的解析不同： -Xss可以接受带K，M或G后缀的数字；
-XX:ThreadStackSize=需要一个整数(无后缀)-堆栈大小(以千字节为单位)</p>
</blockquote>
<h2
id="可以直接跳过了jvm其他参数介绍">(可以直接跳过了)JVM其他参数介绍</h2>
<p>形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。</p>
<h3 id="设置内存页的大小">设置内存页的大小</h3>
<pre><code>-XXThreadStackSize：
    设置内存页的大小，不可设置过大，会影响Perm的大小</code></pre>
<h3 id="设置原始类型的快速优化">设置原始类型的快速优化</h3>
<pre><code>-XX:+UseFastAccessorMethods：
    设置原始类型的快速优化</code></pre>
<h3 id="设置关闭手动gc">设置关闭手动GC</h3>
<pre><code>-XX:+DisableExplicitGC：
    设置关闭System.gc()(这个参数需要严格的测试)</code></pre>
<h3 id="设置垃圾最大年龄">设置垃圾最大年龄</h3>
<pre><code>-XX:MaxTenuringThreshold
    设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.
    对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,
    则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,
    增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.</code></pre>
<h3 id="加快编译速度">加快编译速度</h3>
<pre><code>-XX:+AggressiveOpts</code></pre>
<p>加快编译速度</p>
<h3 id="改善锁机制性能">改善锁机制性能</h3>
<pre><code>-XX:+UseBiasedLocking</code></pre>
<h3 id="禁用垃圾回收">禁用垃圾回收</h3>
<pre><code>-Xnoclassgc</code></pre>
<h3 id="设置堆空间存活时间">设置堆空间存活时间</h3>
<pre><code>-XX:SoftRefLRUPolicyMSPerMB
    设置每兆堆空闲空间中SoftReference的存活时间，默认值是1s。</code></pre>
<h3 id="设置对象直接分配在老年代">设置对象直接分配在老年代</h3>
<pre><code>-XX:PretenureSizeThreshold
    设置对象超过多大时直接在老年代分配，默认值是0。</code></pre>
<h3 id="设置tlab占eden区的比例">设置TLAB占eden区的比例</h3>
<pre><code>-XX:TLABWasteTargetPercent
    设置TLAB占eden区的百分比，默认值是1% 。 </code></pre>
<h3 id="设置是否优先ygc">设置是否优先YGC</h3>
<pre><code>-XX:+CollectGen0First
    设置FullGC时是否先YGC，默认值是false。</code></pre>
<h1 id="finally">finally</h1>
<p>附录：</p>
<blockquote>
<p>真的扯了很久这东西，参考了多方的资料，有极客时间的《深入拆解虚拟机》和《Java核心技术面试精讲》，也有百度，也有自己在学习的一些线上课程的总结。希望对你有所帮助，谢谢。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm参数</title>
    <url>/2022/12/19/review/java_guide/java/jvm/jvm-params/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<blockquote>
<p>本文由 JavaGuide 翻译自 <a
href="https://www.baeldung.com/jvm-parameters">https://www.baeldung.com/jvm-parametersopen
in new
window</a>，并对文章进行了大量的完善补充。翻译不易，如需转载请注明出处，作者：<a
href="https://www.baeldung.com/author/baeldung/">baeldungopen in new
window</a> 。</p>
</blockquote>
<h1 id="概述">概述</h1>
<p>本篇文章中，将掌握最常用的<strong>JVM参数配置</strong>。下面提到了一些概念，<strong>堆</strong>、<strong>方法区</strong>、<strong>垃圾回收</strong>等。</p>
<h1 id="堆内存相关">堆内存相关</h1>
<p>Java 虚拟机所管理的<strong>内存中最大的一块</strong>，<strong>Java
堆</strong>是<strong>所有线程共享的一块内存区域</strong>，在虚拟机<strong>启动时创建</strong>。此内存区域的<strong>唯一目的就是存放对象实例</strong>，<strong>几乎</strong>
<strong>所有的对象实例</strong>以及<strong>数组</strong>都在这里分配内存。</p>
<h2 id="显式指定堆内存-xms和-xmx">显式指定堆内存-Xms和-Xmx</h2>
<ul>
<li><p>与<strong>性能相关</strong>的最常见实践之一是根据应用程序要求<strong>初始化堆内存</strong>。</p></li>
<li><p>如果我们需要指定<strong>最小</strong>和<strong>最大堆</strong>大小（推荐显示指定大小）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xms&lt;heap size&gt;[unit] </span><br><span class="line">-Xmx&lt;heap size&gt;[unit]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>heap size</strong> 表示要初始化内存的具体大小。</li>
<li><strong>unit</strong> 表示要初始化内存的单位。单位为<strong><em>“
g”</em></strong> (GB) 、<strong><em>“
m”</em></strong>（MB）、<strong><em>“ k”</em></strong>（KB）。</li>
</ul></li>
<li><p>举例，为JVM分配最小2GB和最大5GB的堆内存大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xms2G -Xmx5G</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="显示新生代内存young-generation">显示新生代内存（Young
Generation）</h2>
<ul>
<li><p>在堆总可用内存配置完成之后，第二大影响因素是为
<strong><code>Young Generation</code></strong>
在堆内存所占的比例。默认情况下，<strong>YG 的最小大小为 1310
<em>MB</em></strong>，最大大小为<em>无限制</em>。</p></li>
<li><p>两种指定 <strong>新生代内存(Young Generation)</strong>
大小的方法</p>
<ol type="1">
<li><p>通过 <code>-XX:NewSize</code> 和 <code>-XX:MaxNewSize</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:NewSize=&lt;young size&gt;[unit] </span><br><span class="line">-XX:MaxNewSize=&lt;young size&gt;[unit]</span><br></pre></td></tr></table></figure>
<p>如，为新生代分配<strong>最小256m</strong>的内存，<strong>最大1024m</strong>的内存我们的参数为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:NewSize=256m</span><br><span class="line">-XX:MaxNewSize=1024m</span><br></pre></td></tr></table></figure></li>
<li><p>通过<code>-Xmn&lt;young size&gt;[unit]</code>指定
举例，为新生代分配256m的内存（NewSize与MaxNewSize设为一致）
<code>-Xmn256m</code></p>
<blockquote>
<p>将新对象预留在新生代，由于 <strong>Full GC 的成本远高于 Minor
GC</strong>，因此尽可能<strong>将对象分配在新生代</strong>是明智的做法，实际项目中<strong>根据
GC
日志分析新生代空间大小分配是否合理</strong>，适当通过“-Xmn”命令调节新生代大小，<strong>最大限度降低新对象直接进入老年代</strong>的情况。</p>
</blockquote>
<p>另外，你还可以通过
<strong><code>-XX:NewRatio=&lt;int&gt;</code></strong>
来设置老年代与新生代内存的比值。</p>
<blockquote>
<p>下面的参数，设置<strong>老年代</strong>与<strong>新生代</strong>内存的比例为1，即
老年代：新生代 = 1：1，新生代占整个堆栈的1/2
<code>-XX:NewRadio=1</code></p>
</blockquote></li>
</ol></li>
</ul>
<h2 id="显示指定永久代元空间的大小">显示指定永久代/元空间的大小</h2>
<p>从Java 8开始，<strong>如果我们没有指定 Metaspace(元空间)</strong>
的大小，随着更多类的创建，<strong>虚拟机会耗尽</strong>所有<strong>可用的系统内存</strong>（永久代并不会出现这种情况）</p>
<ul>
<li><p><strong>JDK 1.8
之前永久代还没被彻底移除</strong>的时候通常通过下面这些参数来调节方法区大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen </span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>相对</strong>而言，垃圾收集行为在这个区域是<strong>比较少出现</strong>的，但<strong>并非数据进入方法区后就“永久存在”</strong>了。</p></li>
<li><p><strong>JDK 1.8 的时候，方法区（HotSpot
的永久代）被彻底移除了（JDK1.7
就已经开始了），取而代之是元空间，元空间使用的是本地内存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="垃圾收集相关">垃圾收集相关</h1>
<h2 id="垃圾回收器">垃圾回收器</h2>
<p>为了提高应用程序的稳定性，选择正确的<strong>垃圾收集算法</strong>至关重要<br />
JVM具有<strong>四种类型</strong>的GC实现：</p>
<ol type="1">
<li>串行垃圾收集器</li>
<li>并行垃圾收集器</li>
<li>CMS垃圾收集器（并发）</li>
<li>G1垃圾收集器（并发）</li>
</ol>
<p>使用下列参数实现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure>
<h2 id="gc记录">GC记录</h2>
<p>为了严格<strong>监控应用程序</strong>的<strong>运行状况</strong>，应该始终<strong>检查JVM的垃圾回收性能</strong>。最简单的方法是<strong>以人类可读的格式记录GC活动</strong><br />
通过以下参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:+UseGCLogFileRotation </span><br><span class="line">-XX:NumberOfGCLogFiles=&lt; number of log files &gt; </span><br><span class="line">-XX:GCLogFileSize=&lt; file size &gt;[ unit ]</span><br><span class="line">-Xloggc:/path/to/gc.log </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>memory-area</title>
    <url>/2022/12/07/review/java_guide/java/jvm/memory-area/</url>
    <content><![CDATA[<blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
<p>如果没有特殊说明，针对的都是HotSpot虚拟机</p>
</blockquote>
<h1 id="前言">前言</h1>
<ul>
<li>对于Java程序员，虚拟机自动管理机制，不需要像C/C++程序员为每一个new
操作去写对应的delete/free 操作，不容易出现<strong>内存泄漏</strong> 和
<strong>内存溢出</strong>问题</li>
<li>但由于内存控制权交给Java虚拟机，一旦出现内存泄漏和溢出方面问题，如果不了解虚拟机是怎么样使用内存，那么很难<strong>排查任务</strong></li>
</ul>
<h1 id="运行时数据区域">运行时数据区域</h1>
<p><strong>Java虚拟机</strong>在执行Java程序的过程中，会把它管理的内存，<strong>划分成若干个</strong>不同的数据区域</p>
<p>JDK1.8之前：</p>
<ol type="1">
<li>线程共享 堆，方法区【永久代】(包括运行时常量池)</li>
<li>线程私有 虚拟机栈、本地方法栈、程序计数器</li>
<li>本地内存(包括直接内存)</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221208144045407.png"
alt="image-20221208144045407" />
<figcaption aria-hidden="true">image-20221208144045407</figcaption>
</figure>
<p>JDK1.8之后：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/java-runtime-data-areas-jdk1.8.png"
alt="Java 运行时数据区域（JDK1.8 之后）" />
1.8之后整个永久代改名叫"元空间"，且移到了本地内存中</p>
<p>规范（概括）：<br />
<strong>线程私有</strong>：程序计数器，虚拟机栈，本地方法栈</p>
<p><strong>线程共享</strong>：堆，方法区，直接内存（非运行时数据区的一部分）</p>
<blockquote>
<p>Java虚拟机规范对于运行时数据区域的规定是相当宽松的，以堆为例：</p>
<ol type="1">
<li>堆可以是连续，也可以不连续</li>
<li>大小可以固定，也可以运行时按需扩展</li>
<li>虚拟机实现者可以使用任何<strong>垃圾回收算法管理堆</strong>，设置不进行垃圾收集</li>
</ol>
</blockquote>
<h2 id="程序计数器">程序计数器</h2>
<ul>
<li><p>是一块较小内存空间，看作是<strong>当前线程所执行的字节码</strong>的<strong>行号指示器</strong></p></li>
<li><p>字节码解释器，工作时通过<strong>改变这个计数器的值</strong>来选取下一条需要执行的<strong>字节码指令</strong></p>
<blockquote>
<p>分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器</p>
</blockquote></li>
<li><p>而且，为了<strong>线程切换后恢复到正确执行位置</strong>，每条线程需要一个独立程序计数器，各线程计数器互不影响，独立存储，我们称这类内存区域为<strong>"线程私有"</strong>的内存</p></li>
<li><p>总结，<strong>程序计数器</strong>的作用</p>
<ul>
<li>字节码解释器通过<strong>改变程序计数器来依次读取指令</strong>，从而实现代码的流程控制</li>
<li>多线程情况下，<strong>程序计数器用于记录当前线程执行的位置</strong>，从而当线程被切回来的时候能够知道该线程上次运行到哪</li>
</ul>
<blockquote>
<p>程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随线程创建而创建，线程结束而死亡</p>
</blockquote></li>
</ul>
<h2 id="java虚拟机栈">Java虚拟机栈</h2>
<ul>
<li>Java虚拟机栈，<strong>简称"栈"</strong>，也是线程私有的，生命周期和线程相同，随线程创建而创建，线程死亡而死亡</li>
<li>除了<strong>Native方法</strong>调用的是<strong>通过本地方法栈实现</strong>的，其他所有的Java方法调用都是通过<strong>栈</strong>来实现的（需要和其他运行时数据区域比如<strong>程序计数器</strong>配合）</li>
<li><strong>方法调用的数据</strong>需要通过栈进行<strong>传递</strong>，<strong>每一次方法调用</strong>都会有一个对应的<strong>栈帧被压入栈</strong>，每一个<strong>方法调用结束后</strong>，都会有一个<strong>栈帧被弹出</strong>。</li>
<li>栈由一个个栈帧组成，每个栈帧包括<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法返回地址</strong>。
栈为<strong>先进后出</strong>，且只支持<strong>出栈</strong>和<strong>入栈</strong></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/stack-area.png"
alt="Java 虚拟机栈" />
<figcaption aria-hidden="true">Java 虚拟机栈</figcaption>
</figure>
<ul>
<li><p>局部变量表：存放<strong>编译器可知</strong>的各种<strong>数据类型</strong>(boolean、byte、char、short、int、float、long、double)、对象引用(reference
类型，不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是一个<strong>指向一个代表对象的句柄或其他与此对象相关的位置</strong>)
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/local-variables-table.png"
alt="局部变量表" /></p></li>
<li><p>操作数栈
作为方法调用的<strong>中转站</strong>使用，用于存放方法执行过程中产生的<strong>中间计算结果</strong>。计算过程中产生的临时变量也放在操作数栈中</p></li>
<li><p>动态链接
主要服务<strong>一个方法需要调用其他方法</strong>的场景。</p>
<blockquote>
<p>在 Java
源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic
Reference）保存在 Class
文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用。</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/jvmimage-20220331175738692.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
<li><p>如果函数调用陷入<strong>无限循环</strong>，会导致栈中被压入太多栈帧而占用太多空间，导致<strong>栈空间过深</strong>。当<strong>线程请求栈的深度超过当前Java虚拟机栈的最大深度</strong>时，就会抛出<strong>StackOverError</strong>错误</p></li>
<li><p>Java 方法有两种返回方式，一种是 return
语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说，
<strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p></li>
<li><p>除了 <code>StackOverFlowError</code>
错误之外，栈还可能会出现<code>OutOfMemoryError</code>错误，这是因为如果<strong>栈的内存大小可以动态扩展</strong>，
如果虚拟机在<strong>动态扩展栈时无法申请到足够的内存空间</strong>，则抛出<strong><code>OutOfMemoryError</code></strong>异常。</p></li>
<li><p>总结，程序运行中栈可能出现的两种错误</p>
<ul>
<li><strong>StackOverFlowError</strong>：若<strong>栈的内存大小不允许动态扩展</strong>，那么当<strong>线程请求栈的深度超过当前
Java 虚拟机栈的最大深度</strong>的时候，就抛出
<code>StackOverFlowError</code> 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong>
如果栈的内存大小<strong>可以动态扩展</strong>，
如果虚拟机在<strong>动态扩展栈时无法申请到足够的内存空间</strong>，则抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/%25E3%2580%258A%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3%25E8%2599%259A%25E6%258B%259F%25E6%259C%25BA%25E3%2580%258B%25E7%25AC%25AC%25E4%25B8%2589%25E7%2589%2588%25E7%259A%2584%25E7%25AC%25AC2%25E7%25AB%25A0-%25E8%2599%259A%25E6%258B%259F%25E6%259C%25BA%25E6%25A0%2588.f4f863a2.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
</blockquote></li>
</ul>
<h2 id="本地方法栈">本地方法栈</h2>
<p><code>和虚拟机栈作用相似</code>，区别：<strong>虚拟机栈为虚拟机执行Java方法（字节码）服务，本地方法栈则为虚拟机使用到的Native方法服务</strong>。HotSpot虚拟机中和Java虚拟机栈合二为一</p>
<blockquote>
<p>同上，本地方法被执行时，本地方法栈会创建一个栈帧，用于存放本地方法的局部变量表、操作数栈、动态链接、出口信息</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现StackOverFlowError和OutOfMemoryError两种错误</p>
</blockquote>
<h2 id="堆">堆</h2>
<ul>
<li><p>Java虚拟机所管理的内存中最大的一块，Java堆是<strong>所有线程共享</strong>的一块区域，在虚拟机启动时创建</p></li>
<li><p>此内存区域唯一目的是<strong>存放对象实例</strong>，<strong>几乎</strong>所有的<strong>对象实例及数组</strong>，都在这里分配内存</p>
<blockquote>
<p>“几乎”，因为随着<strong>JIT</strong>编译器的发展与逃逸分析技术逐渐成熟，<strong>栈上分配</strong>、<strong>标量替换</strong>导致微妙变化。从JDK1.7开始已经默认<strong>逃逸分析</strong>，如果某些方法的对象引用<strong>没有被返回或者未被外面使用（未逃逸出去）</strong>，那么对象可以<strong>直接在栈上分配内存</strong>。</p>
</blockquote></li>
<li><p>Java堆是<strong>垃圾收集器</strong>管理的主要区域，因此也称GC堆（Garbage
Collected Heap）</p></li>
<li><p>现在收集器基本都采用<strong>分代垃圾收集算法</strong>，从垃圾回收的角度，Java堆还细分为：新生代和老年代。再细致：Eden，Survivor，Old等空间。&gt;
目的是更好的回收内存，或更快地分配内存</p></li>
<li><p>JDK7及JDK7之前，堆内存被分为三部分</p>
<ol type="1">
<li>新生代内存(Young
Generation)，包括Eden区、两个Survivor区S0和S1【8:1:1】</li>
<li>老生代(Old Generation) 【新生代 : 老年代= 1: 2】</li>
<li>永久代(Permanent Generation)</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/hotspot-heap-structure.41533631.png"
alt="hotspot-heap-structure" />
<figcaption aria-hidden="true">hotspot-heap-structure</figcaption>
</figure></li>
<li><p>JDK8之后<strong>PermGen（永久）</strong>已被<strong>Metaspace（元空间）</strong>取代，且<strong>元空间</strong>使用直接内存</p></li>
<li><p>大部分情况，对象都会首先在 Eden
区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者
S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为
1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。</p>
<blockquote>
<p>对象晋升到老年代的年龄阈值，可以通过参数
<code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<p><strong>修正（参见：<a
href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552open
in new window</a>）</strong> ：“Hotspot
遍历所有对象时，按照<strong>年龄从小到大对其所占用的大小进行累积</strong>，当<strong>累积的某个年龄大小超过了
survivor 区的一半</strong>时，<strong>取这个年龄和 MaxTenuringThreshold
中更小的一个值</strong>，作为新的晋升年龄阈值”。图解：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221208105755268.png"
alt="image-20221208105755268" /></p>
<hr />
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;</span><br><span class="line">	<span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="type">size_t</span> <span class="variable">desired_survivor_size</span> <span class="operator">=</span> (size_t)((((<span class="type">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="type">size_t</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">uint</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line"><span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">age++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint</span> <span class="variable">result</span> <span class="operator">=</span> age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">	...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</blockquote></li>
<li><p>堆里最容易出现OutOfMemoryError错误，出现这个错误之后的表现形式：</p>
<ol type="1">
<li><p><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong>
： 当 JVM
<strong>花太多时间执行垃圾回收并且只能回收很少的堆空间</strong>时，就会发生此错误。</p></li>
<li><p><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong>
:假如在<strong>创建新的对象</strong>时,
<strong>堆内存中的空间不足以存放新创建的对象</strong>,
就会引发此错误。</p>
<blockquote>
<p>(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值，详见：<a
href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size">Default
Java 8 max heap sizeopen in new window</a>)</p>
</blockquote></li>
<li><p>...</p></li>
</ol></li>
</ul>
<h2 id="方法区">方法区</h2>
<ul>
<li><p>方法区属于<strong>JVM运行时数据区域</strong>的一块<strong>逻辑区域</strong>，是各线程共享的内存区域</p>
<blockquote>
<p>“逻辑”，《Java虚拟机规范》规定了有方法区这么个概念和它的作用，方法区如何实现是虚拟机的事。即，不同虚拟机实现上，方法区的实现是不同的</p>
</blockquote></li>
<li><p>当虚拟机要使用一个类时，它需要<strong>读取并解析Class文件获取相关信息</strong>，再将<strong>信息存入方法区</strong>。方法区会存储已被虚拟机加载的<strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据</p></li>
<li><p><strong>方法区和永久代以及元空间有什么关系呢？</strong></p>
<ol type="1">
<li>方法区和永久代以及元空间的关系很像Java中接口和类的关系，类实现了接口，这里的类就可以看作是<strong>永久代</strong>和<strong>元空间</strong>，接口则看作是<strong>方法区</strong></li>
<li>永久代及元空间，是HotSpot虚拟机对虚拟机规范中方法区的<strong>两种实现方式</strong></li>
<li>永久代是JDK1.8之前的方法区实现，元空间是JDK1.8及之后方法区的实现</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/method-area-implementation.png"
alt="HotSpot 虚拟机方法区的两种实现" />
<figcaption aria-hidden="true">HotSpot
虚拟机方法区的两种实现</figcaption>
</figure></li>
<li><p>为什么将永久代（PermGen）替换成元空间（MetaSpace）呢</p>
<blockquote>
<p>下图来自《深入理解Java虚拟机》第3版</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/20210425134508117.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
</blockquote>
<ol type="1">
<li><p>整个永久代有一个<strong>JVM本身设置的固定大小上限（也就是参数指定）</strong>，无法进行调整，而元空间使用的是<strong>直接内存</strong>，受本机可用内存的限制。<code>虽然元空间仍旧可能溢出，但比原来出现的机率会更小</code></p>
<blockquote>
<p>元空间溢出将得到错误： java.lang.OutOfMemoryError: MetaSpace</p>
</blockquote>
<ul>
<li><code>-XX: MaxMetaspaceSize</code>设置最大元空间大小，默认为unlimited，即只受系统内存限制</li>
<li><code>-XX: MetaspaceSize</code>调整标志定义元空间的<strong>初始大小</strong>，如果未指定此标志，则Metaspace将<strong>根据运行时应用程序需求，动态地重新调整大小</strong>。</li>
</ul></li>
<li><p>元空间里存放的是<strong>类的元数据</strong>，这样加载多少<strong>类的元数据就不由MaxPermSize控制</strong>了，而<strong>由系统的实际可用空间控制</strong>，这样加载的类就更多了</p></li>
<li><p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit
从来没有一个叫永久代的东西,
合并之后就没有必要额外的设置这么一个永久代的地方了</p></li>
</ol></li>
<li><p>方法区常用参数有哪些
JDK1.8之前永久代还没有被彻底移除时通过下面参数调节方法区大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:PermSize=N<span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line"></span><br><span class="line">-XX:MaxPermSize=N<span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但<strong>并非数据进入方法区后就“永久存在”</strong>了。</p>
</blockquote>
<p>JDK1.7方法区(HotSpot的永久代)被移除一部分，JDK1.8时方法区被彻底移除，取而代之的是<strong>元空间</strong>，元空间使用直接内存，下面是常用参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure>
<p>与永久代不同，如果不指定大小，随着更多类的创建，<strong>虚拟机会耗尽所有可用的系统内存</strong>。</p></li>
</ul>
<h2 id="运行时常量池">运行时常量池</h2>
<ul>
<li><p>Class文件中除了有<strong>类的版本</strong>、<strong>字段</strong>、<strong>方法</strong>、<strong>接口</strong>等描述信息外，还有用于存放编译器期生成的<strong>各种字面量（Literal）</strong>和<strong>符号引用（Symbolic
Reference）</strong>的<strong>常量池表（注意，这里的常量池表，说的是刚刚编译后的那个class文件字节码代表的含义）</strong></p>
<blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230124213133879.png"
alt="image-20230124213133879" />
<figcaption aria-hidden="true">image-20230124213133879</figcaption>
</figure>
</blockquote></li>
<li><p><strong>字面量</strong>是源代码中的<strong>固定值表示法</strong>，即通过字面我们就知道其值的含义。字面量包括<strong>整数</strong>、<strong>浮点数</strong>和<strong>字符串字面量</strong>；<strong>符号引用</strong>包括<strong>类符号引用</strong>、<strong>字段符号引用</strong>、<strong>方法符号引用</strong>和<strong>接口方法符号引用</strong>。</p></li>
<li><p><strong>常量池表</strong>会在类加载后存放到<strong>方法区</strong>的<strong>运行时常量池</strong>中</p></li>
<li><p>运行时常量池的功能类似于传统编程语言的<strong>符号表(但是包含了比典型符号表更广泛的数据)</strong></p></li>
<li><p>运行时常量池是方法区的一部分，所以<strong>受到方法区内存的限制</strong>，当常量池无法再申请到内存时会抛出<strong>OutOfMemoryError</strong>的错误</p></li>
</ul>
<h2 id="字符串常量池">字符串常量池</h2>
<p><strong>字符串常量池</strong>是JVM为了<strong>提升性能和减少内存消耗针对字符串(String类)专门</strong>开辟的一块区域，主要目的是为了避免字符串得重复创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true </span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>HotSpot 虚拟机中字符串常量池的实现是
<code>src/hotspot/share/classfile/stringTable.cpp</code>
,<code>StringTable</code>
本质上就是一个<code>HashSet&lt;String&gt;</code> ,容量为
<code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code>
参数来设置）。</p>
<p><code>StringTable</code>
中保存的是<strong>字符串对象的引用</strong>，字符串对象的引用<strong>指向堆中的字符串对象</strong>。</p>
</blockquote>
<p>JDK1.7之前，<strong>运行时常量池(字符串常量池、静态变量)</strong>存放在<strong>永久代</strong>。JDK1.7<strong>字符串常量池和静态变量</strong>从永久代移动到了Java堆中
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/method-area-jdk1.6.png"
alt="method-area-jdk1.6" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/method-area-jdk1.7.png"
alt="method-area-jdk1.7" />
<figcaption aria-hidden="true">method-area-jdk1.7</figcaption>
</figure>
<p><strong>JDK1.7为什么要将字符串常量池移动到堆中</strong></p>
<ul>
<li><p>因为<strong>永久代（方法区实现）的GC回收效率太低</strong>，只有在整堆收集（Full
GC）的时候才会被执行GC。Java程序中通常有<strong>大量的被创建的字符串等待回收</strong>，将字符串常量池放到堆中，能够高效及时地回收字符串内存。</p></li>
<li><p>JVM常量池中存储的是对象还是引用</p>
<blockquote>
<p>如果您说的确实是runtime constant pool（而不是interned string pool /
StringTable之类的其他东西）的话，其中的引用类型常量（例如CONSTANT_String、CONSTANT_Class、CONSTANT_MethodHandle、CONSTANT_MethodType之类）都存的是引用，实际的对象还是存在Java
heap上的。</p>
</blockquote></li>
<li><blockquote>
<p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap
是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p>
</blockquote></li>
</ul>
<h2 id="总结">总结</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221209084421539.png"
alt="image-20221209084421539" />
<figcaption aria-hidden="true">image-20221209084421539</figcaption>
</figure>
<hr />
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221209084450069.png"
alt="image-20221209084450069" />
<figcaption aria-hidden="true">image-20221209084450069</figcaption>
</figure>
<hr />
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221209084515658.png"
alt="image-20221209084515658" />
<figcaption aria-hidden="true">image-20221209084515658</figcaption>
</figure>
<h2 id="直接内存">直接内存</h2>
<ul>
<li>直接内存并<strong>不是虚拟机运行时数据区</strong>的一部分，也<strong>不是虚拟机规范中定义的内存</strong>区域，但是这部分内存也被频繁使用，也可能导致OutOfMemoryError错误出现</li>
<li>JDK1.4中新加入的NIO(New
Input/Output)类，引入一种基于<strong>通道（Channel）</strong>与<strong>缓冲区（Buffer）</strong>的I/O方式，它可以直接使用<strong>Native函数库直接分配堆外内存</strong>，然后通过一个<strong>存储在Java堆中的DirectByteBuffer对象作为这块内存的引用</strong>进行操作。这样就能在一些场景中<strong>显著提高性能</strong>，因为避免了在<strong>Java堆和Native堆</strong>之间来回复制数据</li>
<li>本机直接内存的分配不会受到Java堆的限制，但是，既然是内存就会<strong>受到本机总内存大小</strong>以及<strong>处理器寻址空间</strong>的限制</li>
</ul>
<h1 id="hotspot虚拟机对象探秘">HotSpot虚拟机对象探秘</h1>
<p><strong>了解一下HotSport虚拟机</strong>在<strong>Java堆中对象分配、布局和访问</strong>的全过程</p>
<h2 id="对象的创建">对象的创建</h2>
<p>默认：</p>
<ol type="1">
<li><p>类加载检查
虚拟机遇到一条<strong>new指令</strong>时，首先将去检查这个指令的<strong>参数</strong>是否能在<strong>常量池中</strong>定位到这个<strong>类的符号引用</strong>，并且检查这个符号引用代表的类<strong>是否已被加载过</strong>、<strong>解析和初始化</strong>过。<strong>如果没有</strong>，那必须先执行相应的<strong>类加载</strong>过程</p></li>
<li><p>分配内存
<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内容</strong>。<strong>对象所需内存大小</strong>在类加载后便可确定，为对象分配空间的任务，等同于<strong>把一块确定大小的内存</strong>从<strong>Java堆中划分出来</strong>。
分配方式有<strong>”指针碰撞“</strong>和<strong>”空闲列表“</strong>两种，选择哪种分配方式由<strong>Java堆是否规整决定</strong>，而<strong>Java堆是否规整</strong>又由<strong>所采用的垃圾收集器是否带有压缩整理功能决定</strong>
<strong>内存分配的两种方式</strong>：</p>
<ul>
<li><p>指针碰撞</p>
<ul>
<li>适用场合：<strong>堆内存规整（即没有内存碎片）</strong>的情况下</li>
<li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，<strong>中间有一个分界指针</strong>只需要<strong>向着没用过的内存方向</strong>，将该指针<strong>移动对象内存的大小的位置</strong>即可</li>
<li>使用该分配方式的GC收集器：Serial，PartNew</li>
</ul></li>
<li><p>空闲列表</p>
<ul>
<li>适合场合：<strong>堆内存不规整的情况下</strong></li>
<li>原理：虚拟机会维护一个列表，该列表中会<strong>记录哪些内存块是可用</strong>的，在分配的时候，找一块<strong>足够大的内存块</strong>来划分给对象实例，最后<strong>更新列表记录</strong></li>
<li>使用该分配方式的GC收集器：CMS</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java
堆内存是否规整，取决于 <strong>GC
收集器的算法</strong>是<strong>"标记-清除"</strong>，还是<strong>"标记-整理"</strong>（也称作<strong>"标记-压缩"</strong>），值得注意的是，<strong>复制算法内存也是规整</strong>的</p></li>
</ul>
<p><strong>内存分配并发问题</strong>：</p>
<p>创建对象时的重要问题---线程安全，因为在实际开发过程中，<strong>创建对象是很频繁的事</strong>，作为虚拟机来说，必须要保证线城市安全的，虚拟机采用<strong>两种方式保证线程安全</strong>：</p>
<ol type="1">
<li><p>CAS+失败重试:</p>
<blockquote>
<p>CAS
是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止</p>
</blockquote>
<p>虚拟机采用<strong>CAS+失败重试</strong>的方式保证更新操作的原子性</p></li>
<li><p>TLAB：为<strong>每一个线程</strong> <strong>预先</strong>
<strong>在Eden区分配一块内存</strong>，JVM在<strong>给线程中的对象分配内存</strong>时，首先在TLAB（该内存区域）分配，当对象大于TLAB中的<strong>剩余内存</strong>或TLAB的内存<strong>已用尽</strong>时，再采用上述的<strong>CAS</strong>进行内存分配</p>
<blockquote>
<p>在预留这个操作发生的时候，需要进行加锁或者采用CAS等操作进行保护，避免多个线程预留同一个区域</p>
</blockquote></li>
</ol></li>
<li><p>初始化零值
内存分配完成后，虚拟机需要将<strong>分配到的内存空间</strong>都<strong>初始化为零值（不包括对象头）</strong>，这一步操作<strong>保证了对象的实例字段</strong>在
<strong>Java
代码中可以不赋初始值就直接使用</strong>，程序能访问到这些<strong>字段的数据类型所对应的零值</strong>。</p></li>
<li><p>设置对象头<br />
初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的
GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong>
另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p></li>
<li><p>执行init方法<br />
在上面工作都完成之后，<strong>从虚拟机的视角来看，一个新的对象已经产生了</strong>，但从
Java 程序的视角来看，对象创建才刚开始，<strong><code>&lt;init&gt;</code>
方法还没有执行，所有的字段都还为零</strong>。所以一般来说，执行 new
指令之后会接着执行 <strong><code>&lt;init&gt;</code>
方法</strong>，把对象<strong>按照程序员的意愿进行初始化</strong>，这样一个真正可用的对象才算完全产生出来。</p>
<blockquote>
<p>附： Java 在编译之后会在字节码文件中生成 <strong>init
方法，称之为实例构造器</strong>，该实例构造器会将语句块，变量初始化，调用父类的构造器等操作<strong>收敛到
init 方法中</strong>，收敛顺序为：</p>
<ol type="1">
<li>父类变量初始化</li>
<li>父类语句块</li>
<li>父类构造函数</li>
<li>子类变量初始化</li>
<li>子类语句块</li>
<li>子类构造函数</li>
</ol>
<ul>
<li>收敛到 init 方法的意思是：<strong>将这些操作放入到 init
中</strong>去执行。</li>
</ul>
<p>转自： https://juejin.cn/post/6844903957836333063</p>
</blockquote></li>
</ol>
<h2 id="对象的内存布局">对象的内存布局</h2>
<ul>
<li>Hotspot虚拟机中，对象在内存中的布局分为3块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>
<ul>
<li>对象头又包括<strong>两部分信息</strong>，第一部分用于<strong>存储对象自身的运行时数据（哈希码、GC分代年龄、锁状态标志等等）</strong>，即markword；第二部分是<strong>类型指针</strong>，即对象指向它的<strong>类元数据的指针</strong>，虚拟机通过这个指针来确定<strong>这个对象是哪个类的实例</strong>。</li>
<li>实例数据部分是对象<strong>真正存储的有效信息</strong>，也是在程序中所定义的各种类型的<strong>字段</strong>内容</li>
<li>对齐填充部分<strong>不是必然存在的，没特别含义，只起占位作用</strong>。因为Hotspot虚拟机的<strong>自动内存管理系统</strong>要求<strong>对象起始地址必须是8字节的整数倍</strong>，即<strong>对象的大小必须是8字节的整数倍</strong>。而对象头部分正好是8字节的倍数（1倍或2倍），因此当<strong>对象实例数据部分没有对齐</strong>时，就需要通过<strong>对齐填充</strong>来补全</li>
</ul></li>
</ul>
<h2 id="对象的访问定位">对象的访问定位</h2>
<p>建立对象就是为了<strong>使用对象</strong>，我们的 Java
程序通过<strong>栈上的 reference
数据</strong>来<strong>操作堆上的具体对象</strong>。对象的访问方式由虚拟机实现而定，目前<strong>主流的访问方式</strong>有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p>
<ol type="1">
<li><p>句柄 如果使用句柄的话，那么 Java
堆中将会划分出<strong>一块内存来作为句柄池</strong>，<strong>reference
中存储的就是对象的句柄地址</strong>，而<strong>句柄</strong>中包含了<strong>对象实例数据</strong>与<strong>对象类型数据各自的具体地址信息</strong>。</p>
<p>【也就是多了一层】<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/access-location-of-object-handle.png"
alt="对象的访问定位-使用句柄" /></p></li>
<li><p>直接指针 如果使用<strong>直接指针</strong>访问，<strong>reference
中存储的直接就是对象的地址</strong>。 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/access-location-of-object-handle-direct-pointer.png"
alt="对象的访问定位-直接指针" /></p></li>
</ol>
<p>这两种对象访问方式各有优势。<strong>使用句柄来访问</strong>的最大好处是
<strong>reference
中存储的是稳定的句柄地址</strong>，在<strong>对象被移动时只会改变句柄中的实例数据指针，而
reference
本身不需要修改</strong>。使用直接指针访问方式最大的好处就是<strong>速度快，它节省了一次指针定位的时间开销</strong>。</p>
<p>HotSpot
虚拟机主要使用的就是这种方式<strong>(直接指针</strong>)来进行对象访问。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
  <entry>
    <title>(该文弃用)锁升级</title>
    <url>/2022/11/03/review/java_guide/java/concurrent/lock_escalation_deprecated2/</url>
    <content><![CDATA[<p>本文主要讲解synchronized原理和偏向锁、轻量级锁、重量级锁的升级过程，基本都转自</p>
<p>https://blog.csdn.net/MariaOzawa/article/details/107665689 原作者:<a
href="https://blog.csdn.net/MariaOzawa">MariaOzawa</a></p>
<h2 id="简介">简介</h2>
<ul>
<li><p>为什么需要锁<br />
并发编程中，多个线程访问同一共享资源时，必须考虑如何维护数据的<strong>原子性</strong></p></li>
<li><p>历史</p>
<ul>
<li>JDK1.5之前，Java依靠Synchronized关键字实现锁功能，Synchronized是<strong>Jvm</strong>实现的<strong>内置锁</strong>，锁的<strong>获取与释放</strong>由JVM隐式实现</li>
<li>JDK1.5，并发包新增Lock接口实现锁功能，提供同步功能，使用时<strong>显式获取和释放锁</strong></li>
</ul></li>
<li><p>区别</p>
<ul>
<li>Lock同步锁基于Java实现，Synchronized基于底层操作系统的MutexLock实现
<figure class="highlight plaintext"><figcaption><span>```，每次**获取和释放锁**都会带来**用户态和内核态的切换**，从而**增加系统性能开销**，性能糟糕，又称**重量级锁**</span></figcaption><table><tr><td class="code"><pre><span class="line">  - JDK1.6之后，对**Synchronized同步锁**做了**充分优化**</span><br><span class="line"></span><br><span class="line">## Synchronized同步锁实现原理</span><br><span class="line"></span><br><span class="line">- Synchronized实现同步锁的两种方式：修饰方法；修饰方法块</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">    // 关键字在实例方法上，锁为当前实例</span><br><span class="line">    public synchronized void method1() &#123;</span><br><span class="line">        // code</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 关键字在代码块上，锁为括号里面的对象</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        Object o = new Object();</span><br><span class="line">        synchronized (o) &#123;</span><br><span class="line">            // code</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<p>这里使用编译--及javap 打印字节文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac -encoding UTF-8 SyncTest.java  //先运行编译class文件命令</span><br><span class="line"></span><br><span class="line">javap -v SyncTest.class //再通过javap打印出字节文件</span><br></pre></td></tr></table></figure>
<p>结果如下，Synchronized修饰代码块时，由monitorenter和monitorexist指令实现同步。进入monitorenter指令后线程持有Monitor对象；退出monitorenter指令后，线程释放该Monitor对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  </span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">1</span>                  </span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       <span class="number">9</span>: dup</span><br><span class="line">      <span class="number">10</span>: astore_2</span><br><span class="line">      <span class="number">11</span>: monitorenter <span class="comment">//monitorenter 指令</span></span><br><span class="line">      <span class="number">12</span>: aload_2</span><br><span class="line">      <span class="number">13</span>: monitorexit  <span class="comment">//monitorexit  指令</span></span><br><span class="line">      <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">      <span class="number">17</span>: astore_3</span><br><span class="line">      <span class="number">18</span>: aload_2</span><br><span class="line">      <span class="number">19</span>: monitorexit</span><br><span class="line">      <span class="number">20</span>: aload_3</span><br><span class="line">      <span class="number">21</span>: athrow</span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">          <span class="number">12</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">          <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">18</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">19</span>: <span class="number">8</span></span><br><span class="line">      line <span class="number">21</span>: <span class="number">12</span></span><br><span class="line">      line <span class="number">22</span>: <span class="number">22</span></span><br><span class="line">    StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">      frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">        offset_delta = <span class="number">17</span></span><br><span class="line">        locals = [ <span class="keyword">class</span> <span class="title class_">com</span>/demo/io/SyncTest, <span class="keyword">class</span> <span class="title class_">java</span>/lang/Object, <span class="keyword">class</span> <span class="title class_">java</span>/lang/Object ]</span><br><span class="line">        stack = [ <span class="keyword">class</span> <span class="title class_">java</span>/lang/Throwable ]</span><br><span class="line">      frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">        offset_delta = <span class="number">4</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>如果Synchronized修饰同步方法，代替monitorenter和monitorexit的是
<code>ACC_SYNCHRONIZED</code>标志，即：JVM使用该访问标志区分方法是否为同步方法。方法调用时，调用指令检查是否设置ACC_SYNCHRONIZED标志，如有，则执行线程<strong>先持有</strong>该Monitor对象，再执行该方法；<strong>运行期间</strong>，<strong>其他线程无法获取到该Monitor</strong>对象；方法<strong>执行完成</strong>后，<strong>释放该Monitor</strong>对象
javap -v xx.class 字节文件查看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line"> descriptor: ()V</span><br><span class="line"> flags: ACC_PUBLIC, ACC_SYNCHRONIZED <span class="comment">// ACC_SYNCHRONIZED 标志</span></span><br><span class="line"> Code:</span><br><span class="line">   stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">      <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">   LineNumberTable:</span><br><span class="line">     line <span class="number">8</span>: <span class="number">0</span> </span><br></pre></td></tr></table></figure></li>
<li><p>Monitor：JVM中的同步是基于<strong>进入和退出管程（Monitor）</strong>对象实现的。每个对象实例都会有一个Monitor，<strong>Monitor</strong>可以和对象一起<strong>创建</strong>、<strong>销毁</strong>。Monitor由ObjectMonitor实现，而ObjectMonitor由C++的ObjectMonitor.hpp文件实现，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">   _header = NULL;</span><br><span class="line">   _count = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">   _waiters = <span class="number">0</span>,</span><br><span class="line">   _recursions = <span class="number">0</span>;</span><br><span class="line">   _object = NULL;</span><br><span class="line">   _owner = NULL;</span><br><span class="line">   _WaitSet = NULL; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">   _WaitSetLock = <span class="number">0</span> ;</span><br><span class="line">   _Responsible = NULL ;</span><br><span class="line">   _succ = NULL ;</span><br><span class="line">   _cxq = NULL ;</span><br><span class="line">   FreeNext = NULL ;</span><br><span class="line">   _EntryList = NULL ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表(Contention List中那些有资格成为候选资源的线程被移动到Entry List中；)</span></span><br><span class="line">   _SpinFreq = <span class="number">0</span> ;</span><br><span class="line">   _SpinClock = <span class="number">0</span> ;</span><br><span class="line">   OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如上，多个线程同时访问一段同步代码时，多个线程会<strong>先被</strong>存放在<strong>ContentionList</strong>和**_EntryList**集合中，处于block状态的线程都会加入该列表。</li>
<li>当线程获取到对象的Monitor时，Monitor依靠底层操作系统的MutexLock实现互斥，线程申请Mutex成功，则持有该Mutex，其他线程无法获取；竞争失败的线程再次进入ContentionList被挂起</li>
<li>如果线程调用wait()方法，则会释放当前持有的Mutex，并且该线程进入WaitSet集合中，等待下一次被唤醒（或者顺利执行完方法也会释放Mutex）
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221103162008164.png"
alt="image-20221103162008164" /></li>
</ul></li>
</ul>
<h2 id="锁升级">锁升级</h2>
<ul>
<li>为了提升性能，Java1.6，引入了<strong>偏向锁、轻量级锁、重量级锁</strong>，来<strong>减少</strong>锁竞争带来的上下文切换，由新增的<strong>Java对象头</strong>实现了<strong>锁升级</strong>。锁只能升级不能降级，目的是<strong>提高获得锁和释放锁的效率</strong></li>
<li>当Java对象<strong>被Synchronized</strong>关键字修饰为同步锁后，围绕这个锁的一系列升级操作都和<strong>Java对象头</strong>有关</li>
<li>JDK1.6
JVM中，对象实例在堆内存中被分为三个部分：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。其中<strong>对象头</strong>由<strong>MarkWord</strong>、<strong>指向类的指针</strong>以及数组长度三部分组成</li>
<li>MarkWord记录了对象和锁相关的信息，它在64为JVM的长度是64bit，下图为<strong>64位JVM的存储结构</strong>：
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221103172236691.png"
alt="image-20221103172236691" /> 32位如下 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221106120357729.png"
alt="image-20221106120357729" />
<ul>
<li>锁标志位是两位，<strong>无锁</strong>和<strong>偏向锁</strong>的锁标志位实际为<strong>01</strong>，轻量级锁的锁标志位为<strong>00</strong></li>
<li>锁升级功能，主要依赖于MarkWord中的<strong>锁标志位</strong>和<strong>释放偏向锁标志位</strong>，Synchronized同步锁，是从<strong>偏向锁</strong>开始的，随着竞争越来越激烈，<strong>偏向锁</strong>升级到<strong>轻量级锁</strong>，最终升级到<strong>重量级锁</strong></li>
</ul></li>
</ul>
<h2
id="从这之后往下是有误的的">=================================从这之后往下，是有误的的=============================</h2>
<h3 id="偏向锁">偏向锁</h3>
<ul>
<li><p>JVM会为每个当前线程的栈帧中，创建用于<strong>存储锁记录</strong>的空间，官方称为<strong>Displaced
Mark Word</strong>（<strong>轻量级锁</strong>会用到）</p></li>
<li><p>为什么引入偏向锁</p></li>
<li><p>多数情况，<strong>锁不仅不存在多线程竞争，且经常由同一线程获得</strong>，为了在这种情况让线程<strong>获得锁的代价更低</strong>而<strong>引入了偏向锁</strong>。例如：线程操作一个线程安全集合时，同一线程每次都需要获取和释放锁，则每次操作都会发生<strong>用户态和内核态的切换（重量级锁）</strong></p></li>
<li><p>解决方案（偏向锁的作用）</p>
<ul>
<li>当一个线程再次访问这个同步代码或方法时，<strong>该线程</strong>只需去<strong>对象头的MarkWord</strong>中，判断一下是否有<strong>偏向锁指向该线程的ID</strong>，而无需再进入Monitor去竞争对象</li>
<li>当<strong>对象被当作同步锁</strong>并<strong>有一个线程抢到了锁</strong>，<strong>锁标志位</strong>还是<strong>01</strong>，<strong>是否偏向锁标志位</strong>为1，并且记录抢到锁的<strong>线程ID</strong>，表示进入<strong>偏向锁状态</strong></li>
</ul></li>
<li><p>偏向锁的撤销
一旦出现其他线程<strong>竞争锁资源（竞争且CAS失败）</strong>时，偏向锁就会被撤销。偏向锁的撤销需要<strong>等待全局安全点</strong>，暂停持有该锁的线程，<strong>同时</strong>检查该线程是否还在执行该方法，如果<strong>是升级锁</strong>，<strong>反之(该锁)被其他线程抢占</strong></p>
<blockquote>
<p>注：对于“CAS操作替换线程ID”这个解释，我的理解是：</p>
<ol type="1">
<li>偏向锁是不会被主动释放的</li>
<li></li>
</ol>
</blockquote>
<p><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221104105511181.png"
alt="image-20221104105511181" />
<strong>偏向锁默认开启</strong>（JDK15默认关闭)，如果<strong>应用程序里所有的锁通常情况下处于竞争</strong>状态，此时可以添加JVM参数关闭偏向锁来调优系统性能</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XX:-UseBiasedLocking //关闭偏向锁（默认打开）</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="轻量级锁">轻量级锁</h3>
<ul>
<li>何时升级为轻量级锁
当有另外一个线程获取这个锁，由于该锁已经是偏向锁，当发现对象头MarkWord中的线程ID不是自己的线程ID，就会进行CAS操作获取锁
<ul>
<li>如果<strong>获取成功</strong>，<strong>直接替换MarkWord中的线程ID为自己ID</strong>，该锁把持偏向锁状态</li>
<li>如果<strong>获取失败</strong>，代表<strong>当前锁有一定的竞争</strong>，偏向锁将升级为轻量级锁</li>
</ul></li>
<li>适用场景
<strong>”绝大部分的锁，在整个同步周期内都不存在长时间的竞争“</strong>的场景</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>复习</tag>
        <tag>复习-javaGuide</tag>
        <tag>复习-javaGuide-并发</tag>
      </tags>
  </entry>
</search>
