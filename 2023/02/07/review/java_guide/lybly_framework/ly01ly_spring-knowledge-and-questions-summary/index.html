<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="spring 常见面试题总结">
<meta property="og:type" content="article">
<meta property="og:title" content="spring 常见面试题总结">
<meta property="og:url" content="http://example.com/2023/02/07/review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:description" content="spring 常见面试题总结">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-07T16:48:03.000Z">
<meta property="article:modified_time" content="2023-02-07T16:48:03.000Z">
<meta property="article:author" content="刘易">
<meta property="article:tag" content="复习">
<meta property="article:tag" content="复习-javaGuide">
<meta property="article:tag" content="复习-javaGuide-framwork">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/02/07/review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>spring 常见面试题总结 | 随记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">随记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/07/review/java_guide/lybly_framework/ly01ly_spring-knowledge-and-questions-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/avatar.png">
      <meta itemprop="name" content="刘易">
      <meta itemprop="description" content="知命不惧 日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          spring 常见面试题总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-07 16:48:03" itemprop="dateCreated datePublished" datetime="2023-02-07T16:48:03+00:00">2023-02-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>46 分钟</span>
            </span>
            <div class="post-description">spring 常见面试题总结</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<p>这篇文章主要是想通过一些问题，加深大家对于 Spring
的理解，所以不会涉及太多的代码！</p>
<p>下面的很多问题我自己在使用 Spring
的过程中也并没有注意，自己也是临时查阅了很多资料和书籍补上的。网上也有一些很多关于
Spring 常见问题/面试题整理的文章，我感觉大部分都是互相
copy，而且很多问题也不是很好，有些回答也存在问题。所以，自己花了一周的业余时间整理了一下，希望对大家有帮助。</p>
<h2 id="spring-基础">Spring 基础</h2>
<h3 id="什么是-spring-框架">什么是 Spring 框架?</h3>
<p>Spring 是一款<strong>开源</strong>的<strong>轻量级 Java
开发框架</strong>，旨在提高开发人员的<strong>开发效率</strong>以及系统的<strong>可维护性</strong>。</p>
<p>我们一般说 Spring 框架指的都是 Spring
Framework，它是很<strong>多模块的集合</strong>，使用这些模块可以很方便地协助我们进行开发，比如说
Spring 支持 <strong>IoC</strong>（<strong>Inversion of
Control:控制反转</strong>） 和
<strong>AOP</strong>(<strong>Aspect-Oriented
Programming:面向切面编程</strong>)、可以很方便地<strong>对数据库进行访问</strong>、可以很<strong>方便地集成第三方组件</strong>（<strong>电子邮件</strong>，<strong>任务</strong>，<strong>调度</strong>，缓存等等）、对<strong>单元测试</strong>支持比较好、支持
<strong>RESTful Java 应用程序</strong>的开发。</p>
<p>[<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f33386566313232313232646534333735616263643237633364653866363062342e706e67"
alt="img" /></p>
<p>Spring
最核心的思想就是不重新造轮子，<strong>开箱即用</strong>，提高开发效率。</p>
<p>Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java
程序员带来春天啊！感动！</p>
<p>🤐 多提一嘴 ： <strong>语言的流行通常需要一个杀手级的应用，Spring
就是 Java 生态的一个杀手级的应用框架。</strong></p>
<p>Spring 提供的核心功能主要是 <strong>IoC</strong> 和
<strong>AOP</strong>。学习 Spring ，一定要把 IoC 和 AOP
的核心思想搞懂！</p>
<ul>
<li>Spring 官网：https://spring.io/</li>
<li>Github 地址：
https://github.com/spring-projects/spring-framework</li>
</ul>
<h3 id="spring-包含的模块有哪些">Spring 包含的模块有哪些？</h3>
<p><strong>Spring4.x 版本</strong> ：</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230207165448412.png"
alt="image-20230207165448412" />
<figcaption aria-hidden="true">image-20230207165448412</figcaption>
</figure>
<p><strong>Spring5.x 版本</strong> ：</p>
<p><a
target="_blank" rel="noopener" href="https://camo.githubusercontent.com/29c4744c19142975a5205c977bc6b322591549d3b80ca429655bc9cae073cc05/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f6672616d65776f726b2f737072696e672f32303230303833313137353730382e706e67"><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f6672616d65776f726b2f737072696e672f32303230303833313137353730382e706e67"
alt="Spring5.x主要模块" /></a></p>
<p>Spring5.x 版本中 Web 模块的 Sertlet (<strong>应该是Servlet
吧</strong>)组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux
组件。</p>
<p>Spring 各个模块的依赖关系如下： <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230207165524155.png"
alt="image-20230207165524155" /></p>
<h4 id="core-container">Core Container</h4>
<p>Spring 框架的核心模块，也可以说是<strong>基础模块</strong>，主要提供
<strong>IoC 依赖注入</strong>功能的支持。Spring
其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring
各个模块的依赖关系图就可以看出来。</p>
<ul>
<li><strong>spring-core</strong> ：Spring
框架<strong>基本的核心工具</strong>类。</li>
<li><strong>spring-beans</strong> ：提供对 <strong>bean
的创建</strong>、<strong>配置</strong>和<strong>管理</strong>等功能的支持。</li>
<li><strong>spring-context</strong>
：提供对<strong>国际化</strong>、事件传播、资源加载等功能的支持。</li>
<li><strong>spring-expression</strong>
：提供对<strong>表达式语言（Spring Expression Language） SpEL</strong>
的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li>
</ul>
<h4 id="aop">AOP</h4>
<ul>
<li><strong>spring-aspects</strong> ：该模块为<strong>与 AspectJ
的集成</strong>提供支持。</li>
<li><strong>spring-aop</strong>
：提供了<strong>面向切面</strong>的编程实现。</li>
<li><strong>spring-instrument</strong> ：提供了为 JVM
添加代理（agent）的功能。 具体来讲，它为 Tomcat
提供了一个织入代理，能够为 Tomcat 传递类文
件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。</li>
</ul>
<h4 id="data-accessintegration">Data Access/Integration</h4>
<ul>
<li><strong>spring-jdbc</strong> ：提供了<strong>对数据库访问的抽象
JDBC</strong>。不同的数据库都有自己独立的 API 用于操作数据库，而
<strong>Java 程序只需要和 JDBC API
交互</strong>，这样就屏蔽了数据库的影响。</li>
<li><strong>spring-tx</strong>
：提供对<strong>事务</strong>的支持。</li>
<li><strong>spring-orm</strong> ： 提供对
<strong>Hibernate</strong>、<strong>JPA</strong>
、<strong>iBatis</strong> 等 ORM 框架的支持。</li>
<li><strong>spring-oxm</strong> ：提供一个抽象层支撑
OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和
XStream 等。</li>
<li><strong>spring-jms</strong> : <strong>消息</strong>服务。自 Spring
Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li>
</ul>
<h4 id="spring-web">Spring Web</h4>
<ul>
<li><strong>spring-web</strong> ：对 Web
功能的实现提供一些最基础的支持。</li>
<li><strong>spring-webmvc</strong> ： 提供对 <strong>Spring MVC</strong>
的实现。</li>
<li><strong>spring-websocket</strong> ： 提供了对
<strong>WebSocket</strong> 的支持，WebSocket
可以让客户端和服务端进行双向通信。</li>
<li><strong>spring-webflux</strong> ：提供对 WebFlux 的支持。WebFlux 是
Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC
不同，它不需要 Servlet API，是完全异步。</li>
</ul>
<h4 id="messaging">Messaging</h4>
<p><strong>spring-messaging</strong> 是从 Spring4.0
开始新加入的一个模块，主要职责是为 Spring
框架集成一些<strong>基础的报文传送</strong>应用。</p>
<h4 id="spring-test">Spring Test</h4>
<p>Spring 团队提倡<strong>测试驱动开发</strong>（TDD）。有了控制反转
(IoC)的帮助，<strong>单元测试</strong>和<strong>集成测试</strong>变得更简单。</p>
<p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似
JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito
的问题比如无法模拟 final, static， private
方法）等等<strong>常用的测试框架</strong>支持的都比较好。</p>
<h3 id="springspring-mvcspring-boot-之间什么关系">Spring,Spring
MVC,Spring Boot 之间什么关系?</h3>
<p>很多人对 Spring,Spring MVC,Spring Boot
这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。</p>
<p>Spring 包含了多个功能模块（上面刚刚提到过），其中最重要的是
<strong>Spring-Core（主要提供 IoC 依赖注入功能的支持）</strong> 模块，
Spring 中的其他模块（比如 <strong>Spring
MVC</strong>）的功能实现基本都需要依赖于该模块。</p>
<p>下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet
组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f6a766d65306336306234363036373131666334613062366661663033323330323437612e706e67"
alt="Spring主要模块" />
<figcaption aria-hidden="true">Spring主要模块</figcaption>
</figure>
<p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 <strong>Spring
快速构建 MVC 架构的 Web 程序的能力</strong>。MVC
是<strong>模型(Model)</strong>、<strong>视图(View)</strong>、<strong>控制器(Controller)</strong>的简写，其核心思想是通过将<strong>业务逻辑</strong>、<strong>数据</strong>、<strong>显示</strong>分离来组织代码。</p>
<p>使用 Spring 进行开发各种<strong>配置过于麻烦</strong>比如开启某些
Spring 特性时，需要用 <strong>XML</strong> 或 <strong>Java</strong>
进行显式配置。于是，Spring Boot 诞生了！</p>
<p>Spring 旨在<strong>简化 J2EE 企业应用程序</strong>开发。Spring Boot
旨在<strong>简化 Spring
开发</strong>（<strong>减少配置文件</strong>，开箱即用！）。</p>
<p>Spring Boot 只是<strong>简化了配置</strong>，如果你需要构建 MVC
架构的 Web 程序，你<strong>还是需要使用 Spring MVC</strong> 作为 MVC
框架，只是说 Spring Boot 帮你<strong>简化了 Spring MVC
的很多配置</strong>，真正做到开箱即用！</p>
<h2 id="spring-ioc">Spring IoC</h2>
<h3 id="谈谈自己对于-spring-ioc-的了解">谈谈自己对于 Spring IoC
的了解</h3>
<p><strong>IoC（Inversion of Control:控制反转）</strong>
是一种<strong>设计</strong>思想，而不是一个具体的技术实现。IoC
的思想就是将<strong>原本在程序中手动创建对象</strong>的控制权，<strong>交由
Spring 框架</strong>来管理。不过， IoC 并非 Spring
特有，在其他语言中也有应用。</p>
<p><strong>为什么叫控制反转？</strong></p>
<ul>
<li><strong>控制</strong>
：指的是<strong>对象创建（实例化、管理）的权力</strong></li>
<li><strong>反转</strong>
：<strong>控制权交给外部环境</strong>（<strong>Spring
框架</strong>、<strong>IoC 容器</strong>）</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6a6176612d67756964652d626c6f672f6672632d33363566616365623536393766303466333133393939333763303539633136322e706e67"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>将<strong>对象之间的相互依赖关系交给 IoC
容器</strong>来管理，并<strong>由 IoC
容器完成对象的注入</strong>。这样可以很大程度上<strong>简化</strong>应用的开发，把应用<strong>从复杂的依赖关系中解放</strong>出来。
IoC
容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要<strong>配置好配置文件/注解</strong>即可，完全<strong>不用考虑</strong>对象是<strong>如何被创建</strong>出来的。</p>
<p>在实际项目中一个 Service
类可能依赖了很多其他的类，假如我们需要实例化这个
Service，你可能要每次都要搞清这个 Service
所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC
的话，你<strong>只需要配置</strong>好，然后<strong>在需要的地方引用</strong>就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>在 Spring 中， <strong>IoC 容器</strong>是 <strong>Spring 用来实现
IoC 的载体</strong>， IoC 容器<strong>实际上就是个
Map（key，value）</strong>，Map
中<strong>存放的是各种对象</strong>。</p>
<p>Spring 时代我们<strong>一般通过 XML</strong> 文件来<strong>配置
Bean</strong>，后来开发人员觉得 XML 文件来配置不太好，于是
<strong>SpringBoot 注解配置</strong>就慢慢开始流行起来。</p>
<p>相关阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">IoC 源码阅读</a></li>
<li><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486938&amp;idx=1&amp;sn=c99ef0233f39a5ffc1b98c81e02dfcd4&amp;chksm=cea24211f9d5cb07fa901183ba4d96187820713a72387788408040822ffb2ed575d28e953ce7&amp;token=1736772241&amp;lang=zh_CN#rd">面试被问了几百遍的
IoC 和 AOP ，还在傻傻搞不清楚？</a></li>
</ul>
<h3 id="什么是-spring-bean">什么是 Spring Bean？</h3>
<p>简单来说，Bean 代指的就是<strong>那些被 IoC
容器所管理的对象</strong>。</p>
<p>我们需要告诉 IoC
容器帮助我们管理哪些对象，这个是<strong>通过配置元数据</strong>来定义的。配置元数据可以是
<strong>XML 文件</strong>、<strong>注解</strong>或者 <strong>Java
配置类</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- Constructor-arg with &#x27;value&#x27; attribute --&gt;</span><br><span class="line">&lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;</span><br><span class="line">   &lt;constructor-arg value=&quot;...&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>下图简单地展示了 IoC
容器如何使用<strong>配置元数据</strong>来管理对象。</p>
<p><code>org.springframework.beans</code>和
<code>org.springframework.context</code> 这两个包是 IoC
实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看</p>
<h3 id="将一个类声明为-bean-的注解有哪些">将一个类声明为 Bean
的注解有哪些?</h3>
<ul>
<li><code>@Component</code>
：<strong>通用</strong>的注解，可标注任意类为 <code>Spring</code>
组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code>
注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao
层，主要用于<strong>数据库</strong>相关操作。</li>
<li><code>@Service</code> :
对应服务层，主要<strong>涉及一些复杂的逻辑</strong>，需要用到 Dao
层。</li>
<li><code>@Controller</code> : 对应 <strong>Spring MVC
控制层</strong>，主要用户<strong>接受用户请求</strong>并<strong>调用
Service 层返回数据</strong>给前端页面。</li>
</ul>
<h3 id="component-和-bean-的区别是什么"><span class="citation"
data-cites="Component">@Component</span> 和 <span class="citation"
data-cites="Bean">@Bean</span> 的区别是什么？</h3>
<ul>
<li><code>@Component</code>
注解作用于<strong>类</strong>，而<code>@Bean</code>注解作用于<strong>方法</strong>。</li>
<li><code>@Component</code>通常是<strong>通过类路径扫描</strong>来<strong>自动侦测</strong>以及<strong>自动装配到
Spring 容器</strong>中（我们可以使用
<strong><code>@ComponentScan</code></strong>
注解<strong>定义要扫描的路径</strong>从中找出标识了需要装配的类自动装配到
Spring 的 bean 容器中）。<code>@Bean</code>
注解通常是我们在<strong>标有该注解的方法中定义产生这个
bean</strong>,<code>@Bean</code><strong>告诉了 Spring
这是某个类的实例</strong>，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>@Component</code>
注解的自定义性更强，而且<strong>很多地方我们只能通过 <code>@Bean</code>
注解来注册
bean</strong>。比如当我们<strong>引用第三方库</strong>中的类需要装配到
<code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ul>
<p><code>@Bean</code>注解使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public TransferService transferService() &#123;</span><br><span class="line">        return new TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码相当于下面的 xml 配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;transferService&quot; class=&quot;com.acme.TransferServiceImpl&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>下面这个例子是通过 <strong><code>@Component</code>
无法实现</strong>的。（<strong>带有逻辑</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public OneService getService(status) &#123;</span><br><span class="line">    case (status)  &#123;</span><br><span class="line">        when 1:</span><br><span class="line">                return new serviceImpl1();</span><br><span class="line">        when 2:</span><br><span class="line">                return new serviceImpl2();</span><br><span class="line">        when 3:</span><br><span class="line">                return new serviceImpl3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注入-bean-的注解有哪些">注入 Bean 的注解有哪些？</h3>
<p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的
<code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>
<table>
<thead>
<tr class="header">
<th>Annotaion</th>
<th>Package</th>
<th>Source</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>@Autowired</code></td>
<td><code>org.springframework.bean.factory</code></td>
<td>Spring 2.5+</td>
</tr>
<tr class="even">
<td><code>@Resource</code></td>
<td><code>javax.annotation</code></td>
<td>Java JSR-250</td>
</tr>
<tr class="odd">
<td><code>@Inject</code></td>
<td><code>javax.inject</code></td>
<td>Java JSR-330</td>
</tr>
</tbody>
</table>
<p><code>@Autowired</code>
和<code>@Resource</code>使用的比较多一些。</p>
<h3 id="autowired-和-resource-的区别是什么"><span class="citation"
data-cites="Autowired">@Autowired</span> 和 <span class="citation"
data-cites="Resource">@Resource</span> 的区别是什么？</h3>
<p><code>Autowired</code> 属于 Spring
内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入
Bean （接口的实现类）。</p>
<p><strong>这会有什么问题呢？</strong>
当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了，因为这个时候
Spring
会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p>
<p>这种情况下，注入方式会变为
<code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的
<code>smsService</code>
就是我这里所说的名称，这样应该比较好理解了吧。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// smsService 就是我们上面所说的名称</span><br><span class="line">@Autowired</span><br><span class="line">private SmsService smsService;</span><br></pre></td></tr></table></figure>
<p>举个例子，<code>SmsService</code> 接口有两个实现类:
<code>SmsServiceImpl1</code>和
<code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="line">@Autowired</span><br><span class="line">private SmsService smsService;</span><br><span class="line">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="line">@Autowired</span><br><span class="line">private SmsService smsServiceImpl1;</span><br><span class="line">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><br><span class="line">// smsServiceImpl1 就是我们上面所说的名称</span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span><br><span class="line">private SmsService smsService;</span><br></pre></td></tr></table></figure>
<p>我们还是<strong>建议通过 <code>@Qualifier</code>
注解来显式指定名称</strong>而<strong>不是依赖变量的名称</strong>。</p>
<p><strong><code>@Resource</code>属于 JDK
提供的注解</strong>，默认注入方式为
<code>byName</code>。如果无法通过名称匹配到对应的 Bean
的话，注入方式会变为<code>byType</code>。</p>
<p><code>@Resource</code>
有两个比较重要且日常开发常用的属性：<code>name</code>（名称）、<code>type</code>（类型）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public @interface Resource &#123;</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line">    Class&lt;?&gt; type() default Object.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果仅指定 <code>name</code>
属性则注入方式为<code>byName</code>，如果仅指定<code>type</code>属性则注入方式为<code>byType</code>，如果同时指定<code>name</code>
和<code>type</code>属性（不建议这么做）则注入方式为<code>byType</code>+<code>byName</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="line">@Resource</span><br><span class="line">private SmsService smsService;</span><br><span class="line">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="line">@Resource</span><br><span class="line">private SmsService smsServiceImpl1;</span><br><span class="line">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span><br><span class="line">@Resource(name = &quot;smsServiceImpl1&quot;)</span><br><span class="line">private SmsService smsService;</span><br></pre></td></tr></table></figure>
<p>简单总结一下：</p>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code>
是 JDK 提供的注解。</li>
<li><code>Autowired</code>
<strong>默认</strong>的注入方式为<strong><code>byType</code>（根据类型进行匹配）</strong>，<code>@Resource</code><strong>默认</strong>注入方式为
<strong><code>byName</code>（根据名称进行匹配）</strong>。</li>
<li>当一个接口存在多个实现类的情况下，<code>@Autowired</code>
和<code>@Resource</code>都<strong>需要通过名称</strong>才能正确匹配到对应的
Bean。<strong><code>Autowired</code> 可以通过 <code>@Qualifier</code>
注解来显式指定名称</strong>，<strong><code>@Resource</code>可以通过
<code>name</code> 属性来显式指定名称</strong>。</li>
</ul>
<h3 id="bean-的作用域有哪些">Bean 的作用域有哪些?</h3>
<p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li><strong>singleton</strong> : IoC 容器中只有<strong>唯一</strong>的
bean 实例。Spring 中的 bean
默认都是单例的，是对单例设计模式的应用。</li>
<li><strong>prototype</strong> :
<strong>每次获取都会创建一个新的</strong> bean 实例。也就是说，连续
<code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong> （仅 Web 应用可用）: <strong>每一次 HTTP
请求</strong>都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP
request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : <strong>每一次来自新
session 的 HTTP 请求</strong>都会产生一个新的 bean（会话 bean），该 bean
仅在当前 HTTP session 内有效。</li>
<li><strong>application/global-session</strong> （仅 Web 应用可用）：
<strong>每个 Web 应用在启动时</strong>创建一个 Bean（应用 Bean），该
bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用可用）：<strong>每一次
WebSocket 会话</strong>产生一个新的 bean。</li>
</ul>
<p><strong>如何配置 bean 的作用域呢？</strong></p>
<p>xml 方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>注解方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">public Person personPrototype() &#123;</span><br><span class="line">    return new Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单例-bean-的线程安全问题了解吗">单例 Bean
的线程安全问题了解吗？</h3>
<p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例
Bean
存在线程问题，主要是因为当<strong>多个线程操作同一个对象</strong>的时候是存在资源竞争的。</p>
<p>常见的有两种解决办法：</p>
<ol type="1">
<li>在 Bean 中<strong>尽量避免定义可变的成员变量</strong>。</li>
<li>在类中定义一个 <strong><code>ThreadLocal</code>
成员变量</strong>，将需要的可变成员变量保存在 <code>ThreadLocal</code>
中（推荐的一种方式）。</li>
</ol>
<p>不过，<strong>大部分 Bean
实际都是无状态</strong>（<strong>没有实例变量</strong>）的（比如
Dao、Service），这种情况下， Bean 是<strong>线程安全</strong>的。</p>
<h3 id="bean-的生命周期了解么">Bean 的生命周期了解么?</h3>
<blockquote>
<p>下面的内容整理自：https://yemengying.com/2016/07/14/spring-bean-life-cycle/
，除了这篇文章，再推荐一篇很不错的文章
：https://www.cnblogs.com/zrtqsk/p/3735273.html 。</p>
</blockquote>
<ul>
<li>Bean 容器<strong>找到配置文件</strong>中 Spring Bean
的<strong>定义</strong>。</li>
<li>Bean 容器<strong>利用 Java Reflection API</strong> 创建一个 Bean
的实例。【<strong>反射</strong>】
<ul>
<li>如果涉及到一些属性值 <strong>利用
<code>set()</code>方法设置</strong>一些属性值。</li>
</ul></li>
</ul>
<blockquote>
<p>aware 英[əˈweə(r)] adj. 意识到的,发觉,发现`</p>
</blockquote>
<ul>
<li>如果 Bean 实现了 <strong><code>BeanNameAware</code></strong>
接口，调用 <code>setBeanName()</code>方法，传入 <strong>Bean
的名字</strong>。</li>
<li>如果 Bean 实现了 <strong><code>BeanClassLoaderAware</code></strong>
接口，调用 <code>setBeanClassLoader()</code>方法，传入
<strong><code>ClassLoader</code>对象的实例</strong>。</li>
<li>如果 Bean 实现了 <strong><code>BeanFactoryAware</code></strong>
接口，调用 <code>setBeanFactory()</code>方法，传入
<strong><code>BeanFactory</code>对象的实例</strong>。</li>
<li>与上面的类似，如果实现了其他
<code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的
<strong><code>BeanPostProcessor</code></strong>
对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果 Bean
实现了<strong><code>InitializingBean</code></strong>接口，执行<strong><code>afterPropertiesSet()</code></strong>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 <strong>init-method</strong>
属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的
<strong><code>BeanPostProcessor</code></strong>
对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了
<strong><code>DisposableBean</code></strong> 接口，执行
<strong><code>destroy()</code></strong> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含
<strong>destroy-method</strong> 属性，执行指定的方法。</li>
</ul>
<p>图示：</p>
<p><a
target="_blank" rel="noopener" href="https://camo.githubusercontent.com/70ba44111686c9f9a4fcac62d8ae01fd23e3e707d91fbce4af1205856dcd458f/68747470733a2f2f696d616765732e7869616f7a6875616e6c616e2e636f6d2f70686f746f2f323031392f32346263326261643363653238313434643630643965306132656466366337662e6a7067"><img
src="https://camo.githubusercontent.com/70ba44111686c9f9a4fcac62d8ae01fd23e3e707d91fbce4af1205856dcd458f/68747470733a2f2f696d616765732e7869616f7a6875616e6c616e2e636f6d2f70686f746f2f323031392f32346263326261643363653238313434643630643965306132656466366337662e6a7067"
alt="Spring Bean 生命周期" /></a></p>
<p>与之比较类似的中文版本:</p>
<p><a
target="_blank" rel="noopener" href="https://camo.githubusercontent.com/9efd4a1a6c11ebb15c61a022e93bb20934a85a72d95194cf59402421c09191a9/68747470733a2f2f696d616765732e7869616f7a6875616e6c616e2e636f6d2f70686f746f2f323031392f62356432363435363536353761353339356332373831303831613734383365312e6a7067"><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f696d616765732e7869616f7a6875616e6c616e2e636f6d2f70686f746f2f323031392f62356432363435363536353761353339356332373831303831613734383365312e6a7067"
alt="Spring Bean 生命周期" /></a> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/20230321121040.png"
alt="image.png" /></p>
<h2 id="spring-aop">Spring AoP</h2>
<h3 id="谈谈自己对于-aop-的了解">谈谈自己对于 AOP 的了解</h3>
<blockquote>
<p><code>aspect  英[ˈæspekt] 方位 n.</code></p>
<p><code>oriented  英[ˈɔːrientɪd] 朝向 v.</code></p>
</blockquote>
<p>AOP(<strong>Aspect-Oriented
Programming:面向切面编程</strong>)能够将那些与业务无关，却为业务模块所<strong>共同调用</strong>的逻辑或责任（例如<strong>事务处理</strong>、<strong>日志管理</strong>、<strong>权限控制</strong>等）封装起来，便于<strong>减少系统的重复代码</strong>，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP
就是<strong>基于动态代理</strong>的，如果要代理的对象，实现了某个接口，那么
Spring AOP 会使用 <strong>JDK
Proxy</strong>，去<strong>创建代理对象</strong>，而对于没有实现接口的对象，就无法使用
JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong>
生成一个<strong>被代理对象的子类</strong>来作为代理，如下图所示：</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230208093647267.png"
alt="image-20230208093647267" />
<figcaption aria-hidden="true">image-20230208093647267</figcaption>
</figure>
<p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了
AspectJ ，<strong>AspectJ</strong> 应该算的上是 <strong>Java
生态系统中最完整的 AOP 框架</strong>了。</p>
<p>AOP 切面编程设计到的一些专业术语：</p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th>术语</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>目标(<strong>Target</strong>)</td>
<td><strong>被通知的对象</strong></td>
</tr>
<tr class="even">
<td>代理(<strong>Proxy</strong>)</td>
<td>向目标对象应用通知之后创建的<strong>代理对象</strong></td>
</tr>
<tr class="odd">
<td>连接点(JoinPoint)</td>
<td><strong>目标对象的所属类</strong>中，定义的<strong>所有方法</strong>均为连接点</td>
</tr>
<tr class="even">
<td>切入点(Pointcut)</td>
<td>被切面拦截 /
增强的连接点（<strong>切入点一定是连接点，连接点不一定是切入点</strong>）</td>
</tr>
<tr class="odd">
<td>通知(Advice)</td>
<td>增强的<strong>逻辑</strong> /
<strong>代码</strong>，也即拦截到目标对象的连接点之后要做的事情</td>
</tr>
<tr class="even">
<td>切面(Aspect)</td>
<td><strong>切入点(Pointcut)+通知(Advice)</strong></td>
</tr>
<tr class="odd">
<td>Weaving(织入)</td>
<td>将<strong>通知应用</strong>到目标对象，进而生成代理对象的<strong>过程动作</strong></td>
</tr>
</tbody>
</table>
<h3 id="spring-aop-和-aspectj-aop-有什么区别">Spring AOP 和 AspectJ AOP
有什么区别？</h3>
<p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong>
Spring AOP 基于<strong>代理</strong>(Proxying)，而 AspectJ
基于<strong>字节码</strong>操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java
生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP
功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当<strong>切面太多</strong>的话，最好选择
<strong>AspectJ</strong> ，它比 Spring AOP 快很多。</p>
<h3 id="aspectj-定义的通知类型有哪些">AspectJ
定义的通知类型有哪些？</h3>
<ul>
<li><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li>
<li><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li>
<li><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li>
<li><strong>AfterThrowing</strong>（异常通知）
：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和
AfterThrowing
两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li>
<li><strong>Around</strong>
（环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li>
</ul>
<h3 id="多个切面的执行顺序如何控制">多个切面的执行顺序如何控制？</h3>
<p>1、通常使用<strong><code>@Order</code>
注解</strong>直接定义切面顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 值越小优先级越高</span><br><span class="line">@Order(3)</span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class LoggingAspect implements Ordered &#123;</span><br></pre></td></tr></table></figure>
<p><strong>2、实现<code>Ordered</code> 接口重写 <code>getOrder</code>
方法。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class LoggingAspect implements Ordered &#123;</span><br><span class="line"></span><br><span class="line">    // ....</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        // 返回值越小优先级越高</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spring-mvc">Spring MVC</h2>
<h3 id="说说自己对于-spring-mvc-了解">说说自己对于 Spring MVC 了解?</h3>
<p>MVC
是<strong>模型(Model)</strong>、<strong>视图(View)</strong>、<strong>控制器(Controller)</strong>的简写，其核心思想是通过将<strong>业务逻辑</strong>、<strong>数据</strong>、<strong>显示</strong>分离来组织代码。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6a6176612d67756964652d626c6f672f696d6167652d32303231303830393138313435323432312e706e67"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>网上有很多人说 MVC 不是设计模式，只是软件设计规范，我个人更倾向于
<strong>MVC 同样是众多设计模式中的一种</strong>。<strong><a
target="_blank" rel="noopener" href="https://github.com/iluwatar/java-design-patterns">java-design-patterns</a></strong>
项目中就有关于 MVC 的相关介绍。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f31353962336433653730646434356536616661383162663036643039323634652e706e67"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>想要真正理解 Spring MVC，我们先来看看 Model 1 和 Model 2 这两个没有
Spring MVC 的时代。</p>
<p><strong>Model 1 时代</strong></p>
<p>很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb
应用开发。在 Model1 模式下，整个 Web 应用几<strong>乎全部用 JSP
页面</strong>组成，<strong>只用少量的 JavaBean</strong>
来<strong>处理数据库连接</strong>、<strong>访问</strong>等操作。</p>
<p>这个模式下 <strong>JSP</strong>
即是<strong>控制层（Controller）</strong>又是<strong>表现层（View）</strong>。显而易见，这种模式存在很多问题。比如<strong>控制逻辑</strong>和<strong>表现逻辑</strong>混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。</p>
<p><strong>Model 2 时代</strong></p>
<p>学过 Servlet 并做过相关 Demo 的朋友应该了解“<strong>Java
Bean(Model)</strong>+
<strong>JSP（View）</strong>+<strong>Servlet（Controller）</strong>
”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。</p>
<ul>
<li>Model:系统涉及的数据，也就是 <strong>dao</strong> 和
<strong>bean</strong>。</li>
<li>View：<strong>展示模型中的数据</strong>，只是用来展示。</li>
<li>Controller：<strong>处理用户请求</strong>都发送给
<strong>Servlet</strong>，返回数据给 JSP 并展示给用户。</li>
</ul>
<p><a
target="_blank" rel="noopener" href="https://camo.githubusercontent.com/b36a90d56dae552146126cf76f8de218f5d545d9df9d65a7eb84283157f46475/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6a6176612d67756964652d626c6f672f6d76632d6d6f64656c322e706e67"><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6a6176612d67756964652d626c6f672f6d76632d6d6f64656c322e706e67"
alt="img" /></a></p>
<p>Model2 模式下还存在很多问题，<strong>Model2
的抽象</strong>和<strong>封装程度</strong>还远远不够，使用 Model2
进行开发时不可避免地会<strong>重复造轮子</strong>，这就大大降低了程序的<strong>可维护性</strong>和<strong>复用性</strong>。</p>
<p>于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如
<strong>Struts2</strong>，但是 Struts2 比较笨重。</p>
<p><strong>Spring MVC 时代</strong></p>
<p>随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC
框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC
使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p>
<p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC
可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring
框架集成。Spring MVC 下我们一般把后端项目分为 <strong>Service
层（处理业务）</strong>、<strong>Dao
层（数据库操作）</strong>、<strong>Entity
层（实体类）</strong>、<strong>Controller
层(控制层</strong>，返回数据给前台页面)。</p>
<h3 id="spring-mvc-的核心组件有哪些">Spring MVC 的核心组件有哪些？</h3>
<p>记住了下面这些组件，也就记住了 SpringMVC 的工作原理。</p>
<ul>
<li><strong><code>DispatcherServlet</code></strong>
：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li>
<li><strong><code>HandlerMapping</code></strong>
：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的
<code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code>
一起封装。</li>
<li><strong><code>HandlerAdapter</code></strong>
：<strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的
<code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li>
<li><strong><code>Handler</code></strong>
：<strong>请求处理器</strong>，处理实际请求的处理器。</li>
<li><strong><code>ViewResolver</code></strong>
：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图
/ 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code>
响应客户端</li>
</ul>
<h3 id="springmvc-工作原理了解吗">SpringMVC 工作原理了解吗?</h3>
<p><strong>Spring MVC 原理如下图所示：</strong></p>
<blockquote>
<p>SpringMVC
工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f696d675f636f6e766572742f64653664326232313366313132323937323938663365323233626630386632382e706e67"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>流程说明（重要）：</strong></p>
<ol type="1">
<li>客户端（浏览器）发送请求，
<strong><code>DispatcherServlet</code>拦截</strong>请求。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用
<strong><code>HandlerMapping</code></strong>
。<strong><code>HandlerMapping</code> 根据 uri
去匹配</strong>查找能处理的 <code>Handler</code>（也就是我们平常说的
<code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和
<code>Handler</code> 一起封装。</li>
<li><code>DispatcherServlet</code> 调用
<strong><code>HandlerAdapter</code></strong>适配执行
<code>Handler</code> 。</li>
<li><code>Handler</code> 完成对用户请求的处理后，会<strong>返回一个
<code>ModelAndView</code></strong>
对象给<code>DispatcherServlet</code>，<code>ModelAndView</code>
顾名思义，包含了<strong>数据模型</strong>以及<strong>相应的视图的信息</strong>。<code>Model</code>
是返回的数据对象，<code>View</code> 是个逻辑上的
<code>View</code>。</li>
<li><code>ViewResolver</code> 会<strong>根据逻辑 <code>View</code>
查找实际的 <code>View</code></strong>。</li>
<li><code>DispaterServlet</code> 把<strong>返回的 <code>Model</code>
传给 <code>View</code>（视图渲染</strong>）。</li>
<li>把 <strong><code>View</code> 返回</strong>给请求者（浏览器）<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/20230321141002.png"
alt="image.png" /></li>
</ol>
<h3 id="统一异常处理怎么做">统一异常处理怎么做？</h3>
<p>推荐使用注解的方式统一异常处理，具体会使用到
<code>@ControllerAdvice</code> + <code>@ExceptionHandler</code>
这两个注解 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ControllerAdvice</span><br><span class="line">@ResponseBody</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(BaseException.class)</span><br><span class="line">    public ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) &#123;</span><br><span class="line">      //......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(value = ResourceNotFoundException.class)</span><br><span class="line">    public ResponseEntity&lt;ErrorReponse&gt; handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) &#123;</span><br><span class="line">      //......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种异常处理方式下，会给<strong>所有</strong>或者<strong>指定</strong>的
<code>Controller</code> <strong>织入异常处理的逻辑</strong>（AOP），当
<code>Controller</code>
中的方法抛出异常的时候，由被<code>@ExceptionHandler</code>
注解修饰的方法进行处理。</p>
<p><code>ExceptionHandlerMethodResolver</code> 中
<code>getMappedMethod</code> 方法<strong>决定了异常具体被哪个</strong>被
<code>@ExceptionHandler</code>
注解修饰的方法处理异常。【<strong>这个是框架里的源码，不是自己写的</strong>】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">	private Method getMappedMethod(Class&lt;? extends Throwable&gt; exceptionType) &#123;</span><br><span class="line">		List&lt;Class&lt;? extends Throwable&gt;&gt; matches = new ArrayList&lt;&gt;();</span><br><span class="line">    //找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系</span><br><span class="line">		for (Class&lt;? extends Throwable&gt; mappedException : this.mappedMethods.keySet()) &#123;</span><br><span class="line">			if (mappedException.isAssignableFrom(exceptionType)) &#123;</span><br><span class="line">				matches.add(mappedException);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    // 不为空说明有方法处理异常</span><br><span class="line">		if (!matches.isEmpty()) &#123;</span><br><span class="line">      // 按照匹配程度从小到大排序</span><br><span class="line">			matches.sort(new ExceptionDepthComparator(exceptionType));</span><br><span class="line">      // 返回处理异常的方法</span><br><span class="line">			return this.mappedMethods.get(matches.get(0));</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>从源代码看出：
<strong><code>getMappedMethod()</code>会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。</strong></p>
<h2 id="spring-框架中用到了哪些设计模式">Spring
框架中用到了哪些设计模式？</h2>
<blockquote>
<p>关于下面这些设计模式的详细介绍，可以看我写的 <a
target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html">Spring
中的设计模式详解</a> 这篇文章。</p>
</blockquote>
<ul>
<li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过
<strong><code>BeanFactory</code></strong>、<strong><code>ApplicationContext</code></strong>
创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring <strong>AOP</strong>
功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 <strong>Bean
默认都是单例</strong>的。</li>
<li><strong>模板方法模式</strong> : Spring 中
<strong><code>jdbcTemplate</code></strong>、<strong><code>hibernateTemplate</code></strong>
等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> :
我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够<strong>动态切换不同的数据源</strong>。</li>
<li><strong>观察者模式:</strong> Spring
<strong>事件驱动</strong>模型就是<strong>观察者模式</strong>很经典的一个应用。</li>
<li><strong>适配器模式</strong> : Spring AOP
的<strong>增强或通知(Advice)</strong>使用到了适配器模式、spring MVC
中也是用到了适配器模式<strong>适配<code>Controller</code></strong>。</li>
<li>......</li>
</ul>
<h2 id="spring-事务">Spring 事务</h2>
<p>关于 Spring 事务的详细介绍，可以看我写的 <a
target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-transaction.html">Spring
事务详解</a> 这篇文章。</p>
<h3 id="spring-管理事务的方式有几种">Spring 管理事务的方式有几种？</h3>
<ul>
<li><strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过
<strong><code>TransactionTemplate</code></strong>或者
<strong><code>TransactionManager</code></strong>
<strong>手动管理</strong>事务，实际应用中很少使用，但是对于你理解 Spring
事务管理原理有帮助。</li>
<li><strong>声明式事务</strong> ： 在 <strong>XML
配置文件中配置</strong>或者<strong>直接基于注解</strong>（推荐使用） :
实际是通过 AOP 实现（基于<code>@**Transactional</code>**
的全注解方式使用最多）</li>
</ul>
<h3
id="spring事务失效的几种情况非javaguide">Spring事务失效的几种情况（非javaguide）</h3>
<h4 id="spring事务实现方式及原理">1.spring事务实现方式及原理</h4>
<p>Spring
事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring
是无法提供事务功能的。真正的数据库层的事务提交和回滚是在binlog提交之后进行提交的
通过 redo log 来重做， undo log来回滚。</p>
<p>一般我们在程序里面使用的都是在方法上面加<code>@Transactional</code>
注解，这种属于<strong>声明式事务</strong>。</p>
<p><strong>声明式事务本质是通过 AOP
功能</strong>，<strong>对方法前后进行拦截</strong>，将事务处理的功能<strong>编织</strong>到拦截的<strong>方法中</strong>，也就是<strong>在目标方法开始之前加入一个事务</strong>，在<strong>执行完目标方法之后根据执行情况提交</strong>或者<strong>回滚</strong>事务。</p>
<h4 id="数据库本身不支持事务">2.数据库本身不支持事务</h4>
<p>这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB
才是支持事务的引擎，一般要支持事务都会使用 InnoDB</p>
<h4 id="当前类的调用">3.当前类的调用</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        updateUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上面的这种情况下是不会有事务管理操作的。</p>
<p>通过看声明式事务的原理可知，spring使用的是AOP切面的方式，本质上使用的是动态代理来达到事务管理的目的，当前类调用的方法上面加<code>@Transactional</code>
这个是没有任何作用的，因为调用这个方法的是<code>this</code>.</p>
<p>OK， 我们在看下面的一种例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        updateUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这次在 update 方法上加了 <code>@Transactional</code>，updateUser 加了
<code>REQUIRES_NEW</code> 新开启一个事务，那么新开的事务管用么？</p>
<p>答案是：不管用！</p>
<p>因为它们<strong>发生了自身调用</strong>，就<strong>调该类自己的方法</strong>，而<strong>没有经过
Spring
的代理类</strong>，默认<strong>只有在外部调用事务才会生效</strong>，这也是老生常谈的经典问题了。</p>
<h4 id="方法不是public的">4.方法不是public的</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong><code>private</code>
方法是不会被spring代理</strong>的，因此是不会有事务产生的，这种做法是无效的。</p>
<h4 id="没有被spring管理">5.没有被spring管理</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>没有被spring管理的bean， spring连代理对象都无法生成，当然无效咯。</p>
<h4 id="配置的事务传播性有问题">6.配置的事务传播性有问题</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>回顾一下spring的事务传播行为</p>
<p>Spring 事务的传播行为说的是，当多个事务同时存在的时候， Spring
如何处理这些事务的行为。</p>
<ol type="1">
<li>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</li>
<li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行</li>
<li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</li>
<li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER：
以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按
REQUIRED 属性执行</li>
</ol>
<p>当传播行为设置了PROPAGATION_NOT_SUPPORTED，PROPAGATION_NEVER，PROPAGATION_SUPPORTS这三种时，就有可能存在事务不生效</p>
<h4 id="异常被你-抓住了">7.异常被你 "抓住"了</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line">      &#125;<span class="keyword">catch</span>(Execption e)&#123;</span><br><span class="line">         log.error(<span class="string">&quot;异常&quot;</span>,e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>异常被抓了，这样子代理类就没办法知道你到底有没有错误，需不需要回滚，所以这种情况也是没办法回滚的哦。</p>
<h4
id="接口层声明式事务使用cglib代理">8.接口层声明式事务使用cglib代理</h4>
<blockquote>
<p>注意，这是个前后关系，说的是：如果在接口层使用了<strong>声明式事务</strong>，结果用的是cglib代理，那么事务就不会生效</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span>   &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span>  </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>通过元素的 "proxy-target-class"
属性值来控制是基于接口的还是基于类的代理被创建。如果
"proxy-target-class" 属值被设置为
"true"，那么<strong>基于类的代理</strong>将起作用（这时需要CGLIB库cglib.jar在CLASSPATH中）。如果
"proxy-target-class" 属值被设置为 "false"
或者这个属性被省略，那么<strong>标准的JDK基于接口</strong>的代理将起作用</p>
<p>注解@Transactional
cglib与java动态代理最大区别是<strong>代理目标对象不用实现接口</strong>,那么注解要是写到接口方法上，要是使用cglib代理，这时注解事务就失效了，为了保持兼容注解最好<strong>都写到实现类方法</strong>上。</p>
<h4 id="rollbackfor异常指定错误">9.rollbackFor异常指定错误</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// update user</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上面这种没有指定回滚异常，这个时候默认的回滚异常是<code>RuntimeException</code>
，如果出现其他异常那么就不会回滚事务</p>
<h3 id="spring-事务中哪几种事务传播行为">Spring
事务中哪几种事务传播行为?</h3>
<p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p>
<p>当事务方法被另一个事务方法(也可能非事务)调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<blockquote>
<p>注意几点，下面这个值都是<strong>内方法</strong>上的注解的值，且两个方法必须属于不同类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;MyClassMapper, MyClass&gt; <span class="keyword">implements</span> <span class="title class_">MyClassService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//外方法 </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodOuter</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//新增一条记录</span></span><br><span class="line">        MyClass myClass=<span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        myClass.setName(<span class="string">&quot;class_name&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.saveOrUpdate(myClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用内方法</span></span><br><span class="line">        userService.methodInner();</span><br><span class="line">        <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="comment">//throw new Exception(&quot;hello&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内方法</span></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">            rollbackFor = Exception.class</span></span><br><span class="line"><span class="meta">            ,propagation = Propagation.REQUIRED</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodInner</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//新增一条记录</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;outer_name&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.saveOrUpdate(user);</span><br><span class="line">        <span class="comment">//抛出异常</span></span><br><span class="line">        <span class="comment">//throw new Exception(&quot;hello&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>正确的事务传播行为可能的值如下:</p>
<blockquote>
<p>注：<strong>如果外方法不存在事务，则内外方法完全独立，自己(方法内)抛异常不影响另一方法</strong></p>
</blockquote>
<p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解<strong>默认</strong>使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p>
<blockquote>
<p>如果外方法存在事务，则不论
外方法或内方法抛出异常，都会导致外内所在事务（同一个）回滚</p>
</blockquote>
<p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<blockquote>
<p>如果外方法存在事务，如果仅内方法抛异常，会导致外方法回滚；如果仅外方法抛异常，则不会回滚内方法</p>
</blockquote>
<p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p>
<p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p>
<blockquote>
<p>如果外方法存在事务，<strong>（效果和1一样）</strong>， 不论
外方法或内方法抛出异常，都会导致外内所在事务（<strong>和1唯一不同的是，他们是不同事务</strong>）回滚</p>
</blockquote>
<p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p>
<p>这个使用的很少。</p>
<blockquote>
<p>如果外方法存在事务，<strong>（效果和1一样）</strong>， 不论
外方法或内方法抛出异常，都会导致外内所在事务（<strong>和1唯一不同的是，如果外方法不存在事务，调用该方法前就直接抛异常</strong>）回滚</p>
</blockquote>
<p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p>
<ul>
<li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>:
如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>:
以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>:
以非事务方式运行，如果当前存在事务，则抛出异常。 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/20230321162427.png"
alt="image.png" /></li>
</ul>
<h3 id="spring-事务中的隔离级别有哪几种">Spring
事务中的隔离级别有哪几种?</h3>
<p><strong>//这个注解应该是用来修改session级别的隔离级别</strong></p>
<p>和事务传播行为这块一样，为了方便使用，Spring
也相应地定义了一个枚举类：<code>Isolation</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Isolation &#123;</span><br><span class="line"></span><br><span class="line">    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line">    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line">    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line">    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line">    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line">    private final int value;</span><br><span class="line"></span><br><span class="line">    Isolation(int value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int value() &#123;</span><br><span class="line">        return this.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我依次对每一种事务隔离级别进行介绍：</p>
<ul>
<li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong>
:使用后端数据库默认的隔离级别，MySQL 默认采用的
<code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的
<code>READ_COMMITTED</code> 隔离级别.</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong>
:最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong>
:
允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong>
:
对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong>
: 最高的隔离级别，完全服从 ACID
的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<blockquote>
<p>注意，这个注解的使用方法，下面写了两个方法分别模拟两个不同的线程操作（供不同的controller使用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        isolation = Isolation.READ_COMMITTED</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">isolation1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//读取userid=1的值</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">byId</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(<span class="number">1L</span>);</span><br><span class="line">    <span class="keyword">return</span> byId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">isolation2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//10s后修改</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;1被修改了&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.saveOrUpdate(user);</span><br><span class="line">    <span class="comment">//10s后提交</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>当isolation1为读已提交时，只要isolation2方法没有执行完毕（没有提交），那么isolation1只会读取到未修改的值；</li>
<li>当isolation1为读为提交时，即使isolation2方法没有执行完毕（没有提交），那么isolation1也会立马读取到最新的值；</li>
</ol>
</blockquote>
<h3 id="transactionalrollbackfor-exception.class注解了解吗"><span
class="citation"
data-cites="Transactional">@Transactional</span>(rollbackFor =
Exception.class)注解了解吗？</h3>
<p><code>Exception</code> 分为运行时异常
<strong><code>RuntimeException</code></strong>
和<strong>非运行时异常</strong>。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public
方法将都具有该类型的事务属性，同时，我们也可以在方法级别<strong>使用该标注来覆盖类级别的定义</strong>。如果类或者方法加了这个注解，那么这个类里面的方法<strong>抛出异常</strong>，<strong>就会回滚</strong>，数据库里面的数据也会回滚。</p>
<p>在 <code>@Transactional</code>
注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<strong><code>RuntimeException</code></strong>的时候才会回滚，加上
<code>rollbackFor=Exception.class</code>,可以让事务在遇到<strong>非运行时异常时</strong>也回滚。</p>
<h2 id="spring-data-jpa">Spring Data JPA</h2>
<p>JPA 重要的是实战，这里仅对小部分知识点进行总结。</p>
<h3 id="如何使用-jpa-在数据库中非持久化一个字段">如何使用 JPA
在数据库中非持久化一个字段？</h3>
<p>假如我们有下面一个类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Entity(name=&quot;USER&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    @Column(name = &quot;ID&quot;)</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    @Column(name=&quot;USER_NAME&quot;)</span><br><span class="line">    private String userName;</span><br><span class="line"></span><br><span class="line">    @Column(name=&quot;PASSWORD&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    private String secrect;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想让<code>secrect</code>
这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static String transient1; // not persistent because of static</span><br><span class="line">final String transient2 = &quot;Satish&quot;; // not persistent because of final</span><br><span class="line">transient String transient3; // not persistent because of transient</span><br><span class="line">@Transient</span><br><span class="line">String transient4; // not persistent because of @Transient</span><br></pre></td></tr></table></figure>
<p>一般使用后面两种方式比较多，我个人使用注解的方式比较多。</p>
<h3 id="jpa-的审计功能是做什么的有什么用">JPA
的审计功能是做什么的？有什么用？</h3>
<p>审计功能主要是帮助我们记录数据库操作的具体行为比如<strong>某条记录是谁创建的</strong>、<strong>什么时间创建的</strong>、<strong>最后修改人</strong>是谁、<strong>最后修改时间</strong>是什么时候。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@MappedSuperclass</span><br><span class="line">@EntityListeners(value = AuditingEntityListener.class)</span><br><span class="line">public abstract class AbstractAuditBase &#123;</span><br><span class="line"></span><br><span class="line">    @CreatedDate</span><br><span class="line">    @Column(updatable = false)</span><br><span class="line">    @JsonIgnore</span><br><span class="line">    private Instant createdAt;</span><br><span class="line"></span><br><span class="line">    @LastModifiedDate</span><br><span class="line">    @JsonIgnore</span><br><span class="line">    private Instant updatedAt;</span><br><span class="line"></span><br><span class="line">    @CreatedBy</span><br><span class="line">    @Column(updatable = false)</span><br><span class="line">    @JsonIgnore</span><br><span class="line">    private String createdBy;</span><br><span class="line"></span><br><span class="line">    @LastModifiedBy</span><br><span class="line">    @JsonIgnore</span><br><span class="line">    private String updatedBy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>@CreatedDate</code>: 表示该字段为创建时间字段，在这个实体被
insert 的时候，会设置值</p></li>
<li><p><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert
的时候，会设置值</p>
<p><code>@LastModifiedDate</code>、<code>@LastModifiedBy</code>同理。</p></li>
</ul>
<h3
id="实体之间的关联关系注解有哪些">实体之间的关联关系注解有哪些？</h3>
<ul>
<li><code>@OneToOne</code> : 一对一。</li>
<li><code>@ManyToMany</code> ：多对多。</li>
<li><code>@OneToMany</code> : 一对多。</li>
<li><code>@ManyToOne</code> ：多对一。</li>
</ul>
<p>利用 <code>@ManyToOne</code> 和 <code>@OneToMany</code>
也可以表达多对多的关联关系。</p>
<h2 id="spring-security">Spring Security</h2>
<p>Spring Security 重要的是实战，这里仅对小部分知识点进行总结。</p>
<h3
id="有哪些控制请求访问权限的方法">有哪些控制请求访问权限的方法？</h3>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f6672616d65776f7216b2f737072696e672f696d6167652d323.png"
alt="68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f6672616d65776f7216b2f737072696e672f696d6167652d323.png" />
<figcaption
aria-hidden="true">68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f6672616d65776f7216b2f737072696e672f696d6167652d323.png</figcaption>
</figure>
<ul>
<li><code>permitAll()</code>
：无条件允许任何形式访问，不管你登录还是没有登录。</li>
<li><code>anonymous()</code>
：允许匿名访问，也就是没有登录才可以访问。</li>
<li><code>denyAll()</code> ：无条件决绝任何形式的访问。</li>
<li><code>authenticated()</code>：只允许已认证的用户访问。</li>
<li><code>fullyAuthenticated()</code> ：只允许已经登录或者通过
remember-me 登录的用户访问。</li>
<li><code>hasRole(String)</code> : 只允许指定的角色访问。</li>
<li><code>hasAnyRole(String)</code> :
指定一个或者多个角色，满足其一的用户即可访问。</li>
<li><code>hasAuthority(String)</code>
：只允许具有指定权限的用户访问</li>
<li><code>hasAnyAuthority(String)</code>
：指定一个或者多个权限，满足其一的用户即可访问。</li>
<li><code>hasIpAddress(String)</code> : 只允许指定 ip 的用户访问。</li>
</ul>
<h3 id="hasrole-和-hasauthority-有区别吗">hasRole 和 hasAuthority
有区别吗？</h3>
<p>可以看看松哥的这篇文章：<a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GTNOa2k9_n_H0w24upClRw">Spring Security
中的 hasRole 和 hasAuthority 有区别吗？</a>，介绍的比较详细。</p>
<h3 id="如何对密码进行加密">如何对密码进行加密？</h3>
<p>如果我们需要保存密码这类敏感数据到数据库的话，需要<strong>先加密再保存</strong>。</p>
<p>Spring Security
提供了多种加密算法的实现，开箱即用，非常方便。这些加密算法实现类的父类是
<code>PasswordEncoder</code>
，如果你想要自己实现一个加密算法的话，也需要继承
<code>PasswordEncoder</code>。</p>
<p><code>PasswordEncoder</code> 接口一共也就 3 个必须实现的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface PasswordEncoder &#123;</span><br><span class="line">    // 加密也就是对原始密码进行编码</span><br><span class="line">    String encode(CharSequence var1);</span><br><span class="line">    // 比对原始密码和数据库中保存的密码</span><br><span class="line">    boolean matches(CharSequence var1, String var2);</span><br><span class="line">    // 判断加密密码是否需要再次进行加密，默认返回 false</span><br><span class="line">    default boolean upgradeEncoding(String encodedPassword) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f6672616d65776f726b2f737072696e672f696d6167652d323.png"
alt="68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f6672616d65776f726b2f737072696e672f696d6167652d323.png" />
<figcaption
aria-hidden="true">68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f6672616d65776f726b2f737072696e672f696d6167652d323.png</figcaption>
</figure>
<p>官方推荐使用基于 bcrypt 强哈希函数的加密算法实现类。</p>
<h3
id="如何优雅更换系统使用的加密算法">如何优雅更换系统使用的加密算法？</h3>
<p>如果我们在开发过程中，突然发现现有的加密算法无法满足我们的需求，需要更换成另外一个加密算法，这个时候应该怎么办呢？</p>
<p>推荐的做法是<strong>通过 <code>DelegatingPasswordEncoder</code>
兼容多种不同的密码加密</strong>方案，以适应不同的业务需求。</p>
<p>从名字也能看出来，<code>DelegatingPasswordEncoder</code>
其实就是一个代理类，并非是一种全新的加密算法，它做的事情就是<strong>代理上面提到的加密算法实现类</strong>。在
Spring Security 5.0之后，默认就是基于
<code>DelegatingPasswordEncoder</code> 进行密码加密的。</p>
<h2 id="参考">参考</h2>
<ul>
<li>《Spring 技术内幕》</li>
<li>《从零开始深入学习
Spring》：https://juejin.cn/book/6857911863016390663</li>
<li>http://www.cnblogs.com/wmyskxz/p/8820371.html</li>
<li>https://www.journaldev.com/2696/spring-interview-questions-and-answers</li>
<li>https://www.edureka.co/blog/interview-questions/spring-interview-questions/</li>
<li>https://www.cnblogs.com/clwydjgs/p/9317849.html</li>
<li>https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/</li>
<li>http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/</li>
<li>https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%8D%E4%B9%A0/" rel="tag"># 复习</a>
              <a href="/tags/%E5%A4%8D%E4%B9%A0-javaGuide/" rel="tag"># 复习-javaGuide</a>
              <a href="/tags/%E5%A4%8D%E4%B9%A0-javaGuide-framwork/" rel="tag"># 复习-javaGuide-framwork</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/07/review/java_guide/lyaly_dev_tools/git/" rel="prev" title="git">
      <i class="fa fa-chevron-left"></i> git
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/08/review/java_guide/lybly_framework/ly02ly_spring-annotations/" rel="next" title="Spring/SpringBoot常用注解">
      Spring/SpringBoot常用注解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="lwmfjc/lwmfjc.github.io.comment" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">Spring 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-spring-%E6%A1%86%E6%9E%B6"><span class="nav-number">1.1.</span> <span class="nav-text">什么是 Spring 框架?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-%E5%8C%85%E5%90%AB%E7%9A%84%E6%A8%A1%E5%9D%97%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.2.</span> <span class="nav-text">Spring 包含的模块有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#core-container"><span class="nav-number">1.2.1.</span> <span class="nav-text">Core Container</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#aop"><span class="nav-number">1.2.2.</span> <span class="nav-text">AOP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#data-accessintegration"><span class="nav-number">1.2.3.</span> <span class="nav-text">Data Access&#x2F;Integration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-web"><span class="nav-number">1.2.4.</span> <span class="nav-text">Spring Web</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#messaging"><span class="nav-number">1.2.5.</span> <span class="nav-text">Messaging</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring-test"><span class="nav-number">1.2.6.</span> <span class="nav-text">Spring Test</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#springspring-mvcspring-boot-%E4%B9%8B%E9%97%B4%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.</span> <span class="nav-text">Spring,Spring
MVC,Spring Boot 之间什么关系?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-ioc"><span class="nav-number">2.</span> <span class="nav-text">Spring IoC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-spring-ioc-%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">2.1.</span> <span class="nav-text">谈谈自己对于 Spring IoC
的了解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-spring-bean"><span class="nav-number">2.2.</span> <span class="nav-text">什么是 Spring Bean？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BA-bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.3.</span> <span class="nav-text">将一个类声明为 Bean
的注解有哪些?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#component-%E5%92%8C-bean-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.4.</span> <span class="nav-text">@Component 和 @Bean 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5-bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.5.</span> <span class="nav-text">注入 Bean 的注解有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autowired-%E5%92%8C-resource-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.6.</span> <span class="nav-text">@Autowired 和 @Resource 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.7.</span> <span class="nav-text">Bean 的作用域有哪些?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B-bean-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%90%97"><span class="nav-number">2.8.</span> <span class="nav-text">单例 Bean
的线程安全问题了解吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%86%E8%A7%A3%E4%B9%88"><span class="nav-number">2.9.</span> <span class="nav-text">Bean 的生命周期了解么?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-aop"><span class="nav-number">3.</span> <span class="nav-text">Spring AoP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-aop-%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">3.1.</span> <span class="nav-text">谈谈自己对于 AOP 的了解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-aop-%E5%92%8C-aspectj-aop-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.</span> <span class="nav-text">Spring AOP 和 AspectJ AOP
有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aspectj-%E5%AE%9A%E4%B9%89%E7%9A%84%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.3.</span> <span class="nav-text">AspectJ
定义的通知类型有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E5%88%87%E9%9D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6"><span class="nav-number">3.4.</span> <span class="nav-text">多个切面的执行顺序如何控制？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-mvc"><span class="nav-number">4.</span> <span class="nav-text">Spring MVC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-spring-mvc-%E4%BA%86%E8%A7%A3"><span class="nav-number">4.1.</span> <span class="nav-text">说说自己对于 Spring MVC 了解?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-mvc-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">4.2.</span> <span class="nav-text">Spring MVC 的核心组件有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#springmvc-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97"><span class="nav-number">4.3.</span> <span class="nav-text">SpringMVC 工作原理了解吗?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%80%8E%E4%B9%88%E5%81%9A"><span class="nav-number">4.4.</span> <span class="nav-text">统一异常处理怎么做？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">Spring
框架中用到了哪些设计模式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-%E4%BA%8B%E5%8A%A1"><span class="nav-number">6.</span> <span class="nav-text">Spring 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="nav-number">6.1.</span> <span class="nav-text">Spring 管理事务的方式有几种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E9%9D%9Ejavaguide"><span class="nav-number">6.2.</span> <span class="nav-text">Spring事务失效的几种情况（非javaguide）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="nav-number">6.2.1.</span> <span class="nav-text">1.spring事务实现方式及原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%AC%E8%BA%AB%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1"><span class="nav-number">6.2.2.</span> <span class="nav-text">2.数据库本身不支持事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E7%B1%BB%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">6.2.3.</span> <span class="nav-text">3.当前类的调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8D%E6%98%AFpublic%E7%9A%84"><span class="nav-number">6.2.4.</span> <span class="nav-text">4.方法不是public的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E8%A2%ABspring%E7%AE%A1%E7%90%86"><span class="nav-number">6.2.5.</span> <span class="nav-text">5.没有被spring管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%80%A7%E6%9C%89%E9%97%AE%E9%A2%98"><span class="nav-number">6.2.6.</span> <span class="nav-text">6.配置的事务传播性有问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E8%A2%AB%E4%BD%A0-%E6%8A%93%E4%BD%8F%E4%BA%86"><span class="nav-number">6.2.7.</span> <span class="nav-text">7.异常被你 &quot;抓住&quot;了</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%B1%82%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8cglib%E4%BB%A3%E7%90%86"><span class="nav-number">6.2.8.</span> <span class="nav-text">8.接口层声明式事务使用cglib代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rollbackfor%E5%BC%82%E5%B8%B8%E6%8C%87%E5%AE%9A%E9%94%99%E8%AF%AF"><span class="nav-number">6.2.9.</span> <span class="nav-text">9.rollbackFor异常指定错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-%E4%BA%8B%E5%8A%A1%E4%B8%AD%E5%93%AA%E5%87%A0%E7%A7%8D%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="nav-number">6.3.</span> <span class="nav-text">Spring
事务中哪几种事务传播行为?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="nav-number">6.4.</span> <span class="nav-text">Spring
事务中的隔离级别有哪几种?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transactionalrollbackfor-exception.class%E6%B3%A8%E8%A7%A3%E4%BA%86%E8%A7%A3%E5%90%97"><span class="nav-number">6.5.</span> <span class="nav-text">@Transactional(rollbackFor &#x3D;
Exception.class)注解了解吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-data-jpa"><span class="nav-number">7.</span> <span class="nav-text">Spring Data JPA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-jpa-%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%9D%9E%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5"><span class="nav-number">7.1.</span> <span class="nav-text">如何使用 JPA
在数据库中非持久化一个字段？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jpa-%E7%9A%84%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="nav-number">7.2.</span> <span class="nav-text">JPA
的审计功能是做什么的？有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BD%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">7.3.</span> <span class="nav-text">实体之间的关联关系注解有哪些？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spring-security"><span class="nav-number">8.</span> <span class="nav-text">Spring Security</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8E%A7%E5%88%B6%E8%AF%B7%E6%B1%82%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">8.1.</span> <span class="nav-text">有哪些控制请求访问权限的方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hasrole-%E5%92%8C-hasauthority-%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97"><span class="nav-number">8.2.</span> <span class="nav-text">hasRole 和 hasAuthority
有区别吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E5%AF%86%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86"><span class="nav-number">8.3.</span> <span class="nav-text">如何对密码进行加密？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%9B%B4%E6%8D%A2%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">8.4.</span> <span class="nav-text">如何优雅更换系统使用的加密算法？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">9.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="刘易"
      src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/avatar.png">
  <p class="site-author-name" itemprop="name">刘易</p>
  <div class="site-description" itemprop="description">知命不惧 日日自新</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">199</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lwmfjc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lwmfjc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘易</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">43:05</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
