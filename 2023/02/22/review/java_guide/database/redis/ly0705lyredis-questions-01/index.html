<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lwmfjc.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="redis面试题01">
<meta property="og:type" content="article">
<meta property="og:title" content="redis面试题01">
<meta property="og:url" content="https://lwmfjc.github.io/2023/02/22/review/java_guide/database/redis/ly0705lyredis-questions-01/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:description" content="redis面试题01">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-22T11:31:11.000Z">
<meta property="article:modified_time" content="2023-02-22T11:31:11.000Z">
<meta property="article:author" content="刘易">
<meta property="article:tag" content="复习">
<meta property="article:tag" content="复习-javaGuide">
<meta property="article:tag" content="复习-javaGuide-database">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://lwmfjc.github.io/2023/02/22/review/java_guide/database/redis/ly0705lyredis-questions-01/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>redis面试题01 | 随记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">随记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lwmfjc.github.io/2023/02/22/review/java_guide/database/redis/ly0705lyredis-questions-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/avatar.png">
      <meta itemprop="name" content="刘易">
      <meta itemprop="description" content="知命不惧 日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis面试题01
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-22 11:31:11" itemprop="dateCreated datePublished" datetime="2023-02-22T11:31:11+00:00">2023-02-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>29 分钟</span>
            </span>
            <div class="post-description">redis面试题01</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="redis-基础">Redis 基础</h2>
<h3 id="什么是-redis">什么是 Redis？</h3>
<p><a target="_blank" rel="noopener" href="https://redis.io/">Redis</a> 是一个基于 C
语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis
的数据是存在<strong>内存</strong>中的（内存数据库），<strong>读写</strong>速度非常<strong>快</strong>，被广泛应用于<strong>缓存方向</strong>。并且，Redis
存储的是 <strong>KV 键值对</strong>数据。</p>
<p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如
<strong>String</strong>、<strong>Hash</strong>、【<strong>List</strong>、<strong>Set</strong>、】<strong>Sorted
Set</strong>、<strong>Bitmap</strong>）。并且，Redis
还支持<strong>事务</strong> 、<strong>持久化</strong>、<strong>Lua
脚本</strong>、多种开箱即用的<strong>集群</strong>方案（<strong>Redis
Sentinel</strong>、<strong>Redis Cluster</strong>）。</p>
<p>Redis 没有外部依赖，Linux 和 OS X 是 Redis
开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署
Redis。</p>
<p>个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的<a
target="_blank" rel="noopener" href="https://try.redis.io/">在线 Redis 环境</a>来实际体验 Redis。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230222135114608.png"
alt="image-20230222135114608" />
<figcaption aria-hidden="true">image-20230222135114608</figcaption>
</figure>
<p>全世界有非常多的网站使用到了 Redis ，<a
target="_blank" rel="noopener" href="https://techstacks.io/">techstacks.io</a> 专门维护了一个<a
target="_blank" rel="noopener" href="https://techstacks.io/tech/redis">使用 Redis 的热门站点列表</a>
，感兴趣的话可以看看。</p>
<h3 id="redis-为什么这么快">Redis 为什么这么快？</h3>
<p>Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：</p>
<ul>
<li>Redis 基于<strong>内存</strong>，内存的访问速度是磁盘的上千倍；</li>
<li>Redis <strong>基于 Reactor
模式</strong>设计开发了一套<strong>高效的事件处理模型</strong>，主要是<strong>单线程事件循环</strong>和
<strong>IO 多路复用</strong>（Redis 线程模式后面会详细介绍到）；</li>
<li>Redis
内置了多种<strong>优化过后的数据结构</strong>实现，性能非常高。</li>
</ul>
<p>下面这张图片总结的挺不错的，分享一下，出自 <a
target="_blank" rel="noopener" href="https://twitter.com/alexxubyte/status/1498703822528544770">Why is
Redis so fast?</a> 。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230222135233844.png"
alt="image-20230222135233844" />
<figcaption aria-hidden="true">image-20230222135233844</figcaption>
</figure>
<h3
id="分布式缓存常见的技术选型方案有哪些">分布式缓存常见的技术选型方案有哪些？</h3>
<p>分布式缓存的话，比较老牌同时也是使用的比较多的还是
<strong>Memcached</strong> 和
<strong>Redis</strong>。不过，现在基本没有看过还有项目使用
<strong>Memcached</strong> 来做缓存，都是直接用
<strong>Redis</strong>。</p>
<p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis
的发展，大家慢慢都转而使用更加强大的 Redis 了。</p>
<p>另外，腾讯也开源了一款类似于 Redis 的分布式高性能 KV
存储数据库，基于知名的开源项目 <a
target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb">RocksDB</a> 作为存储引擎
，100% 兼容 Redis 协议和 Redis4.0 所有数据模型，名为 <a
target="_blank" rel="noopener" href="https://github.com/Tencent/Tendis">Tendis</a> （腾讯的）。</p>
<p>关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章：<a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ">Redis vs
Tendis：冷热混合存储版架构揭秘</a> ，可以简单参考一下。</p>
<p>从这个项目的 Github 提交记录可以看出，Tendis
开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少。因此，不建议你使用
Tendis 来实现分布式缓存。</p>
<h3 id="说一下-redis-和-memcached-的区别和共同点">说一下 Redis 和
Memcached 的区别和共同点</h3>
<p>现在公司一般都是用 Redis 来实现缓存，而且 Redis
自身也越来越强大了！不过，了解 Redis 和 Memcached
的区别和共同点，有助于我们在做相应的<strong>技术选型</strong>的时候，能够做到有理有据！</p>
<p><strong>共同点</strong> ：</p>
<ol type="1">
<li>都是<strong>基于内存</strong>的数据库，一般都用来当做缓存使用。</li>
<li>都有<strong>过期策略</strong>。</li>
<li>两者的<strong>性能都非常高</strong>。</li>
</ol>
<p><strong>区别</strong> ：</p>
<ol type="1">
<li><p><strong>Redis
支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis
不仅仅支持<strong>简单（string）的 k/v 类型</strong>的数据，同时还提供
<strong>list</strong>，<strong>set</strong>，<strong>zset</strong>，<strong>hash</strong>
等数据结构的存储。Memcached 只支持<strong>最简单的 k/v</strong>
数据类型。</p></li>
<li><p><strong>Redis
支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而
Memcached 把数据全部存在内存之中。</strong></p></li>
<li><p><strong>Redis 有灾难恢复机制。</strong>
因为可以把缓存中的数据持久化到磁盘上。</p></li>
<li><p><strong>Redis
在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached
在服务器内存使用完之后，就会直接报异常。</strong></p></li>
<li><p><strong>Memcached
没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis
目前是原生支持 cluster 模式的。</strong></p></li>
<li><p><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis
使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO
）</p>
<blockquote>
<p>非阻塞的 IO复用<br />
单线程的多路IO复用</p>
</blockquote></li>
<li><p><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而
Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></p></li>
<li><p><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis
同时使用了惰性删除与定期删除。</strong></p></li>
</ol>
<p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached
来作为自己项目的分布式缓存了。</p>
<h3 id="为什么要用-redis为什么要用缓存">为什么要用
Redis/为什么要用缓存？</h3>
<p>下面我们主要从“高性能”和“高并发”这两点来回答这个问题。</p>
<p><strong>高性能</strong></p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，<strong>用户访问的数据属于高频数据并且不会经常改变</strong>的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p>
<p><strong>这样有什么好处呢？</strong>
那就是保证用户下一次再访问这些数据的时候就可以<strong>直接从缓存中获取</strong>了。操作缓存就是<strong>直接操作内存</strong>，所以速度相当快。</p>
<p><strong>高并发</strong></p>
<p>一般像 <strong>MySQL</strong> 这类的数据库的 <strong>QPS</strong>
大概都在 <strong>1w</strong> 左右（4 核 8g） ，但是使用 Redis
缓存之后很容易达到 <strong>10w+</strong>，甚至最高能达到
<strong>30w+</strong>（就单机 Redis 的情况，Redis 集群的话会更高）。</p>
<blockquote>
<p>QPS（<strong>Query Per
Second</strong>）：服务器<strong>每秒</strong>可以执行的<strong>查询次数</strong>；</p>
</blockquote>
<p>由此可见，直接操作缓存能够承受的数据库请求数量是<strong>远远大于直接访问数据库</strong>的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了<strong>系统整体的并发</strong>。</p>
<h3 id="redis-除了做缓存还能做什么">Redis 除了做缓存，还能做什么？</h3>
<ul>
<li><strong>分布式锁</strong> ： 通过 Redis
来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于
<strong>Redisson</strong> 来实现<strong>分布式锁</strong>。关于 Redis
实现分布式锁的详细介绍，可以看我写的这篇文章：<a
target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-lock.html">分布式锁详解</a>
。</li>
<li><strong>限流</strong> ：一般是通过 <strong>Redis + Lua
脚本</strong>的方式来实现<strong>限流</strong>。相关阅读：<a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA">《我司用了 6
年的 Redis 分布式限流器，可以说是非常厉害了！》</a>。</li>
<li><strong>消息队列</strong> ：Redis 自带的 <strong>list
数据结构可以作为一个简单的队列</strong>使用。Redis 5.0 中增加的
<strong>Stream</strong>
类型的数据结构更加适合用来做消息队列。它比较类似于
Kafka，有<strong>主题</strong>和<strong>消费组</strong>的概念，支持消息<strong>持久化</strong>以及
<strong>ACK</strong> 机制。</li>
<li><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如
Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过
<strong>bitmap 统计活跃用户</strong>、通过 <strong>sorted set
维护排行榜</strong>。</li>
<li>......</li>
</ul>
<h3 id="redis-可以做消息队列么">Redis 可以做消息队列么？</h3>
<p>Redis 5.0 新增加的一个数据结构 <code>Stream</code>
可以用来做消息队列，<code>Stream</code> 支持：</p>
<ul>
<li><strong>发布 / 订阅</strong>模式</li>
<li>按照<strong>消费者组</strong>进行消费</li>
<li><strong>消息持久化</strong>（ <strong>RDB</strong> 和
<strong>AOF</strong>）</li>
</ul>
<p>不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常<strong>建议是不使用
Redis
来做消息队列</strong>的，你完全可以选择市面上比较成熟的一些消息队列比如
RocketMQ、Kafka。</p>
<p>相关文章推荐：<a
target="_blank" rel="noopener" href="https://javakeeper.starfish.ink/data-management/Redis/Redis-MQ.html">Redis
消息队列的三种方案（List、Streams、Pub/Sub）</a>。</p>
<h3 id="如何基于-redis-实现分布式锁">如何基于 Redis 实现分布式锁？</h3>
<p>关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a
target="_blank" rel="noopener" href="https://javaguide.cn/distributed-system/distributed-lock.html">分布式锁详解</a>
。</p>
<h2 id="redis-数据结构">Redis 数据结构</h2>
<h3 id="redis-常用的数据结构有哪些">Redis 常用的数据结构有哪些？</h3>
<ul>
<li><strong>5 种基础数据结构</strong>
：<strong>String</strong>（字符串）、<strong>List</strong>（列表）、<strong>Set</strong>（集合）、<strong>Hash</strong>（散列）、<strong>Zset</strong>（有序集合）。</li>
<li><strong>3 种特殊数据结构</strong>
：<strong>HyperLogLogs</strong>（基数统计）、<strong>Bitmap</strong>
（位存储）、<strong>Geospatial</strong> (地理位置)。</li>
</ul>
<p>关于 5 种基础数据结构的详细介绍请看这篇文章：<a
target="_blank" rel="noopener" href="https://javaguide.cn/database/redis/redis-data-structures-01.html">Redis
5 种基本数据结构详解</a>。</p>
<p>关于 3 种特殊数据结构的详细介绍请看这篇文章：<a
target="_blank" rel="noopener" href="https://javaguide.cn/database/redis/redis-data-structures-02.html">Redis
3 种特殊数据结构详解</a>。</p>
<h3 id="string-的应用场景有哪些">String 的应用场景有哪些？</h3>
<ul>
<li>常规数据（比如
<strong>session</strong>、<strong>token</strong>、、<strong>序列化后的对象</strong>）的缓存；</li>
<li>计数比如<strong>用户单位时间的请求数</strong>（简单限流可以用到）、<strong>页面单位时间的访问数</strong>；</li>
<li>分布式锁(利用 <code>SETNX key value</code>
命令可以实现一个<strong>最简易的分布式锁</strong>)；</li>
<li>......</li>
</ul>
<p>关于 String 的详细介绍请看这篇文章：<a
target="_blank" rel="noopener" href="https://javaguide.cn/database/redis/redis-data-structures-01.html">Redis
5 种基本数据结构详解</a>。</p>
<h3 id="string-还是-hash-存储对象数据更好呢">String 还是 Hash
存储对象数据更好呢？</h3>
<ul>
<li>String
存储的是<strong>序列化后的对象数据</strong>，存放的是<strong>整个对象</strong>。Hash
是<strong>对对象的每个字段单独存储</strong>，可以<strong>获取部分字段的信息</strong>，也可以修改或者添加<strong>部分</strong>字段，节省网络流量。如果对象中<strong>某些字段</strong>需要<strong>经常</strong>变动或者<strong>经</strong>常需要单独查询对象中的<strong>个别字段</strong>信息，Hash
就非常适合。</li>
<li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String
消耗的内存约是 Hash
的一半。并且，<strong>存储具有多层嵌套的对象时也方便很多</strong>。如果系统对<strong>性能</strong>和<strong>资源</strong>消耗非常敏感的话，String
就非常适合。</li>
</ul>
<p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p>
<h3 id="string-的底层实现是什么">String 的底层实现是什么？</h3>
<p>Redis 是基于 C 语言编写的，但 Redis 的 String
类型的底层实现并<strong>不是</strong> C
语言中的字符串（即以<strong>空字符 <code>\0</code>
结尾</strong>的字符数组），而是自己编写了 <a
target="_blank" rel="noopener" href="https://github.com/antirez/sds">SDS</a>（<strong>Simple Dynamic
String，简单动态字符串</strong>） 来作为底层实现。</p>
<blockquote>
<p><code>[daɪˈnæmɪk] 动态的</code></p>
</blockquote>
<p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C
字符串，后来被应用到了 Redis
上，并经过了大量的修改完善以适合高性能操作。</p>
<p>Redis7.0 的 SDS
的部分源码如下（https://github.com/redis/redis/blob/7.0/src/sds.h）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span><br><span class="line"> * However is here to document the layout of type 5 SDS strings. */</span><br><span class="line">struct __attribute__ ((__packed__)) sdshdr5 &#123;</span><br><span class="line">    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br><span class="line">struct __attribute__ ((__packed__)) sdshdr8 &#123;</span><br><span class="line">    uint8_t len; /* used */</span><br><span class="line">    uint8_t alloc; /* excluding the header and null terminator */</span><br><span class="line">    unsigned char flags; /* 3 lsb of type, 5 unused bits */</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br><span class="line">struct __attribute__ ((__packed__)) sdshdr16 &#123;</span><br><span class="line">    uint16_t len; /* used */</span><br><span class="line">    uint16_t alloc; /* excluding the header and null terminator */</span><br><span class="line">    unsigned char flags; /* 3 lsb of type, 5 unused bits */</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br><span class="line">struct __attribute__ ((__packed__)) sdshdr32 &#123;</span><br><span class="line">    uint32_t len; /* used */</span><br><span class="line">    uint32_t alloc; /* excluding the header and null terminator */</span><br><span class="line">    unsigned char flags; /* 3 lsb of type, 5 unused bits */</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br><span class="line">struct __attribute__ ((__packed__)) sdshdr64 &#123;</span><br><span class="line">    uint64_t len; /* used */</span><br><span class="line">    uint64_t alloc; /* excluding the header and null terminator */</span><br><span class="line">    unsigned char flags; /* 3 lsb of type, 5 unused bits */</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过源码可以看出，SDS 共有五种实现方式
SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis
会根据初始化的长度决定使用哪种类型，从而减少内存的使用。</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>字节</th>
<th>位</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sdshdr5</td>
<td>&lt; 1</td>
<td>&lt;8</td>
</tr>
<tr class="even">
<td>sdshdr8</td>
<td>1</td>
<td>8</td>
</tr>
<tr class="odd">
<td>sdshdr16</td>
<td>2</td>
<td>16</td>
</tr>
<tr class="even">
<td>sdshdr32</td>
<td>4</td>
<td>32</td>
</tr>
<tr class="odd">
<td>sdshdr64</td>
<td>8</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>对于后四种实现都包含了下面这 4 个属性：</p>
<ul>
<li><code>len</code>
：字符串的长度也就是<strong>已经使用</strong>的字节数</li>
<li><code>alloc</code>：<strong>总共可用</strong>的字符空间大小，<strong>alloc-len</strong>
就是 SDS 剩余的空间大小</li>
<li><code>buf[]</code> ：<strong>实际存储字符串</strong>的数组</li>
<li><code>flags</code> ：低三位保存<strong>类型标志</strong></li>
</ul>
<p>SDS 相比于 C 语言中的字符串有如下提升：</p>
<ol type="1">
<li><strong>可以避免缓冲区溢出</strong> ：C
语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS
被修改时，会先<strong>根据 len
属性检查空间大小</strong>是否满足要求，如果不满足，则先<strong>扩展</strong>至所需大小再进行修改操作。</li>
<li><strong>获取字符串长度的复杂度较低</strong> ： C
语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS
的长度获取<strong>直接读取 len 属性</strong>即可，时间复杂度为
O(1)。</li>
<li><strong>减少内存分配次数</strong> ：
为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C
语言的字符串是这样的），SDS
实现了<strong>空间预分配</strong>和<strong>惰性空间释放</strong>两种优化策略。当
SDS 需要增加字符串时，Redis 会为 SDS
分配好内存，并且根据特定的算法分配多余的内存，这样可以<strong>减少连续执行字符串增长操作所需的内存重分配次数</strong>。当
SDS
需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待<strong>后续使用</strong>（支持手动释放，有对应的
API）。</li>
<li><strong>二进制安全</strong> ：C 语言中的字符串以空字符
<code>\0</code>
作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能<strong>包括空字符</strong>，C
字符串无法正确保存。SDS <strong>使用 len
属性判断字符串是否结束</strong>，不存在这个问题。</li>
</ol>
<p>多提一嘴，很多文章里 SDS 的定义是下面这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    unsigned int len;</span><br><span class="line">    unsigned int free;</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个也没错，Redis 3.2
之前就是这样定义的。后来，由于这种方式的定义存在问题，<code>len</code>
和 <code>free</code> 的定义用了 4 个字节，造成了浪费。Redis 3.2
之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。</p>
<h3 id="购物车信息用-string-还是-hash-存储更好呢">购物车信息用 String
还是 Hash 存储更好呢?</h3>
<p>由于购物车中的商品<strong>频繁修改</strong>和<strong>变动</strong>，购物车信息建议使用
Hash 存储：</p>
<ul>
<li>用户 id 为 key</li>
<li>商品 id 为 field，商品数量为 value</li>
</ul>
<p><a
target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/database/redis/images/hash-shopping-cart.png"><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/hash-shopping-cart.png"
alt="Hash维护简单的购物车信息" /></a></p>
<p>那用户购物车信息的维护具体应该怎么操作呢？</p>
<ul>
<li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li>
<li>查询购物车信息就是遍历对应的 Hash；</li>
<li>更改商品数量直接修改对应的 value 值（直接 set
或者做运算皆可）；</li>
<li>删除商品就是删除 Hash 中对应的 field；</li>
<li>清空购物车直接删除对应的 key 即可。</li>
</ul>
<p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field
只保存一个商品 id 是没办法满足需求的。</p>
<h3 id="使用-redis-实现一个排行榜怎么做">使用 Redis
实现一个排行榜怎么做？</h3>
<p>Redis 中有一个叫做 <code>sorted set</code>
的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p>
<p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序) 、
<code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code>
(指定元素排名)。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032313036303731343139353338352e706e67"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><a
target="_blank" rel="noopener" href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java
面试指北》</a> 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set
来设计制作一个排行榜。 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230222144701328.png"
alt="image-20230222144701328" /></p>
<h3 id="使用-set-实现抽奖系统需要用到什么命令">使用 Set
实现抽奖系统需要用到什么命令？</h3>
<ul>
<li><p><code>SPOP key count</code> ：
随机<strong>移除</strong>并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</p></li>
<li><p><code>SRANDMEMBER key count</code> :
随机<strong>获取</strong>指定集合中指定数量的元素，适合允许<strong>重复中奖</strong>的场景。</p>
<blockquote>
<p>重复中奖，这里说的是第一次中的是a，第二次可能也是a。而不是说一次中将的人有两个a</p>
</blockquote></li>
</ul>
<h3 id="使用-bitmap-统计活跃用户怎么做">使用 Bitmap
统计活跃用户怎么做？</h3>
<p>使用日期（精确到天）作为 key，然后用户 ID 为
offset，如果当日活跃过就设置为 1。</p>
<p>初始化数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SETBIT 20210308 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; SETBIT 20210308 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; SETBIT 20210309 1 1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
<p>统计 20210308~20210309 总活跃用户数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; BITOP and desk1 20210308 20210309</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; BITCOUNT desk1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>统计 20210308~20210309 在线活跃用户数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; BITOP or desk2 20210308 20210309</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; BITCOUNT desk2</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>
<h3 id="使用-hyperloglog-统计页面-uv-怎么做">使用 HyperLogLog 统计页面
UV 怎么做？</h3>
<blockquote>
<p>Unique Visitor，即有多少个用户访问了我们的网站</p>
</blockquote>
<p>1、将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code>
中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PFADD PAGE_1:UV USER1 USER2 ...... USERn</span><br></pre></td></tr></table></figure>
<p>2、统计指定页面的 UV。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PFCOUNT PAGE_1:UV</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">会自动扣除重复的</span></span><br></pre></td></tr></table></figure>
<h2 id="redis-线程模型">Redis 线程模型</h2>
<p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0
版本之后引入了多线程来执行一些<strong>大键值对的异步删除</strong>操作，
Redis 6.0
版本之后引入了<strong>多线程来处理网络请求</strong>（提高<strong>网络 IO
读写性能</strong>）。</p>
<h3 id="redis-单线程模型了解吗">Redis 单线程模型了解吗？</h3>
<p><strong>Redis 基于 Reactor
模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于
Reactor 模式，Reactor 模式不愧是高性能 IO
的基石），这套事件处理模型对应的是 Redis
中的<strong>文件事件处理器</strong>（file event
handler）。由于<strong>文件事件处理器（file event
handler）</strong>是单线程方式运行的，所以我们一般都说 Redis
是单线程模型。</p>
<p>《Redis
设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。</p>
<blockquote>
<p>Redis 基于 Reactor
模式开发了自己的<strong>网络事件处理器</strong>：这个处理器被称为<strong>文件事件处理器（file
event handler）</strong>。</p>
<ul>
<li>文件事件处理器使用 <strong>I/O
多路复用（multiplexing）</strong>程序来同时监听多个套接字，并根据<strong>套接字</strong>目前执行的<strong>任务</strong>来<strong>为套接字关联不同的事件处理器</strong>。</li>
<li>当被监听的套接字<strong>准备好执行连接应答</strong>（accept）、<strong>读取</strong>（read）、<strong>写入</strong>（write）、<strong>关
闭</strong>（close）等操作时，与操作相对应的<strong>文件事件</strong>就会产生，这时文件事件处理器就会<strong>调用套接字之前关联好的事件处理器</strong>来处理这些事件。</li>
</ul>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O
多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与
Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis
内部单线程设计的简单性。</p>
</blockquote>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过 <strong>IO 多路复用程序</strong>
来监听来自客户端的大量连接（或者说是监听<strong>多个
socket</strong>），它会<strong>将感兴趣的事件</strong>及<strong>类型（读、写）</strong>注册到内核中并<strong>监听每个事件是否发生</strong>。</p>
<p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis
不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和
NIO 中的 <code>Selector</code> 组件很像）。</p>
<p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li><p>多个 socket（客户端连接）</p></li>
<li><p>IO 多路复用程序（支持多个客户端连接的关键）</p></li>
<li><p>文件事件分派器（将 socket 关联到相应的事件处理器）</p></li>
<li><p>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230222231224666.png"
alt="image-20230222231224666" />
<figcaption aria-hidden="true">image-20230222231224666</figcaption>
</figure></li>
</ul>
<p>相关阅读：<a target="_blank" rel="noopener" href="http://remcarpediem.net/article/1aa2da89/">Redis
事件机制详解</a> 。</p>
<h3 id="redis6.0-之前为什么不使用多线程">Redis6.0
之前为什么不使用多线程？</h3>
<p>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0
之后的版本中就已经加入了对多线程的支持。</strong></p>
<p>不过，Redis 4.0
增加的多线程主要是<strong>针对一些大键值对的删除</strong>操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。</p>
<p>为此，Redis 4.0
之后新增了<strong><code>UNLINK</code></strong>（可以看作是
<code>DEL</code>
的异步版本）、<strong><code>FLUSHALL ASYNC</code></strong>（清空所有数据库的所有
key，不仅仅是当前 <code>SELECT</code>
的数据库）、<strong><code>FLUSHDB ASYNC</code></strong>（清空当前
<code>SELECT</code> 数据库中的所有 key）等异步命令。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230222231413647.png"
alt="image-20230222231413647" />
<figcaption aria-hidden="true">image-20230222231413647</figcaption>
</figure>
<p>大体上来说，Redis 6.0 之前主要还是单线程处理。</p>
<p><strong>那 Redis6.0 之前为什么不使用多线程？</strong>
我觉得主要原因有 3 点：</p>
<ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的<strong>性能瓶颈不在 CPU</strong>
，主要在<strong>内存</strong>和<strong>网络</strong>；</li>
<li>多线程就会存在<strong>死锁</strong>、线程<strong>上下文切换</strong>等问题，甚至会影响<strong>性能</strong>。</li>
</ul>
<p>相关阅读：<a
target="_blank" rel="noopener" href="https://draveness.me/whys-the-design-redis-single-thread/">为什么
Redis 选择单线程模型</a> 。</p>
<h3 id="redis6.0-之后为何引入了多线程">Redis6.0
之后为何引入了多线程？</h3>
<p><strong>Redis6.0 引入多线程主要是为了提高网络 IO
读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis
的瓶颈主要受限于内存和网络）。</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis
的多线程只是在<strong>网络数据的读写这类耗时操作</strong>上使用了，<strong>执行命令仍然是单线程顺序</strong>执行。因此，你也不需要担心线程安全问题。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置IO线程数
&gt; 1，需要修改 redis 配置文件 <code>redis.conf</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io-threads 4 #设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span><br></pre></td></tr></table></figure>
<p>另外：</p>
<ul>
<li>io-threads的个数<strong>一旦</strong>设置，<strong>不能通过config动态设置</strong></li>
<li>当设置ssl后，io-threads将不工作</li>
</ul>
<p>开启多线程后，默认只会使用多线程进行IO<strong>写入</strong>writes，即发送数据给客户端，如果需要开启多线程IO<strong>读取</strong>reads，同样需要修改
redis 配置文件 <code>redis.conf</code> :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io-threads-do-reads yes</span><br></pre></td></tr></table></figure>
<p>但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</p>
<p>相关阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw">Redis
6.0 新特性-多线程连环 13 问！</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039223696">Redis
多线程网络模型全面揭秘</a>（推荐）</li>
</ul>
<h2 id="redis-内存管理">Redis 内存管理</h2>
<h3 id="redis-给缓存数据设置过期时间有啥用">Redis
给缓存数据设置过期时间有啥用？</h3>
<p><strong>一般</strong>情况下，我们设置保存的缓存数据的时候都会设置一个<strong>过期时间</strong>。为什么呢？</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接
Out of memory。</p>
<p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire key 60 # 数据在 60s 后过期</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key # 查看数据还有多久过期</span><br><span class="line">(integer) 56</span><br></pre></td></tr></table></figure>
<p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令
<code>setex</code> 外，其他方法都需要依靠 <code>expire</code>
命令来设置过期时间 。另外， <code>persist</code>
命令可以移除一个键的过期时间。</strong></p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在
1 分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，<strong>一般都是自己判断过期</strong>，这样<strong>更麻烦</strong>并且<strong>性能要差很多</strong>。</p>
<h3 id="redis-是如何判断数据是否过期的呢">Redis
是如何判断数据是否过期的呢？</h3>
<p>Redis 通过一个叫做<strong>过期字典</strong>（可以看作是 <strong>hash
表</strong>）来保存数据过期的时间。过期字典的键指向 Redis
数据库中的<strong>某个 key</strong>(键)，过期字典的值是一个 <strong>long
long</strong> 类型的整数，这个整数保存了 key
所指向的数据库键的<strong>过期时间</strong>（毫秒精度的 UNIX
时间戳）。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f64617461626173652f72656469732f72656469732d657870697265642d64696374696f6e6172792e706e67"
alt="redis过期字典" />
<figcaption aria-hidden="true">redis过期字典</figcaption>
</figure>
<p>过期字典是存储在 redisDb 这个结构里的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dict *dict;     //数据库键空间,保存着数据库中所有键值对</span><br><span class="line">    dict *expires   // 过期字典,保存着键的过期时间</span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<h3 id="过期的数据的删除策略了解么">过期的数据的删除策略了解么？</h3>
<p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis
是怎么对这批 key 进行删除的呢？</p>
<p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ol type="1">
<li><strong>惰性删除</strong> ：<strong>只会在取出 key</strong>
的时候才对数据进行<strong>过期检查</strong>。这样<strong>对 CPU
最友好</strong>，但是可能会造成<strong>太多过期 key
没有被删除</strong>。</li>
<li><strong>定期删除</strong> ： <strong>每隔一段时间抽取一批
key</strong> 执行删除过期 key 操作。并且，Redis
底层会通过<strong>限制删除操作执行的时长</strong>和<strong>频率</strong>来减少删除操作对
CPU 时间的影响。</li>
</ol>
<p><strong>定期</strong>删除对<strong>内存</strong>更加友好，<strong>惰性</strong>删除对
<strong>CPU</strong> 更加友好。两者各有千秋，所以 Redis 采用的是
<strong>定期删除+惰性/懒汉式删除</strong> 。</p>
<p>但是，仅仅通过给 key
设置过期时间还是有问题的。因为还是可能存在<strong>定期删除</strong>和<strong>惰性删除</strong>漏掉了很多过期
key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 <strong>Out of
memory</strong> 了。</p>
<p>怎么解决这个问题呢？答案就是：<strong>Redis
内存淘汰机制。</strong></p>
<h3 id="redis-内存淘汰机制了解么">Redis 内存淘汰机制了解么？</h3>
<blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证
Redis 中的数据都是热点数据?</p>
</blockquote>
<blockquote>
<p>当缓存数据越来越多，Redis 不可避免的会被写满，这时候就涉及到 Redis
的内存淘汰机制了</p>
</blockquote>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol type="1">
<li><strong>volatile-lru（least recently
used）</strong>：从<strong>已设置过期时间的数据集</strong>（server.db[i].expires）中挑选<strong>最近最少使用的数据淘汰</strong></li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选<strong>将要过期的数据</strong>淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中<strong>任意选择数据淘汰</strong></li>
<li><strong>allkeys-lru（least recently
used）</strong>：当内存不足以容纳新写入数据时，在键空间中，<strong>移除最近最少使用</strong>的
key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中<strong>任意选择数据淘汰</strong></li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会<strong>报错</strong>。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol type="1">
<li><strong>volatile-lfu（least frequently
used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently
used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的
key</li>
</ol>
<blockquote>
<p>关于最近最少使用：<br />
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/v2-71b21233c615b1ce899cd4bd3122cbab_720w.webp"
alt="img" /></p>
<ol type="1">
<li><p>链表尾部的数据会被丢弃</p></li>
<li><p>长期不被使用的数据，在未来被用到的几率也不大。因此，当数据所占<a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020">内存</a>达到一定阈值时，要移除掉最近最少使用的数据。</p></li>
<li><p>关于翻译问题：least，程度最轻的。recently，最近的。其实翻译应该是“非最近的，越远越要淘汰”</p></li>
<li><p>java算法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> _key, <span class="type">int</span> _value)</span> &#123;key = _key; value = _value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, DLinkedNode&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedNode head, tail;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h2 id="redis-持久化机制">Redis 持久化机制</h2>
<h3 id="怎么保证-redis-挂掉之后再重启数据可以进行恢复">怎么保证 Redis
挂掉之后再重启数据可以进行恢复？</h3>
<p>很多时候我们需要持久化数据也就是将<strong>内存中的数据写入到硬盘</strong>里面，大部分原因是为了之后<strong>重用数据</strong>（比如<strong>重启</strong>机器、机器<strong>故障之后恢复</strong>数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<p>Redis 不同于 Memcached 的很重要一点就是，Redis
支持持久化，而且支持两种不同的持久化操作。<strong>Redis
的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only
file,
AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p>
<h3 id="什么是-rdb-持久化">什么是 RDB 持久化？</h3>
<p>Redis
可以通过创建快照来获得<strong>存储在内存里面的数据在某个时间点上的副本</strong>。Redis
创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建<strong>具有相同数据的服务器副本</strong>（Redis
<strong>主从</strong>结构，主要用来提高 Redis
性能），还可以将<strong>快照留在原地以便重启服务器的时候</strong>使用。</p>
<p>快照持久化是 Redis <strong>默认采用的持久化</strong>方式，在
<code>redis.conf</code> 配置文件中默认有此下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br></pre></td></tr></table></figure>
<h3 id="rdb-创建快照时会阻塞主线程吗">RDB
创建快照时会阻塞主线程吗？</h3>
<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><strong><code>save</code></strong> :
<strong>主线程</strong>执行，<strong>会阻塞</strong>主线程；</li>
<li><strong><code>bgsave</code></strong> :
<strong>子线程</strong>执行，<strong>不会阻塞</strong>主线程，默认选项。</li>
</ul>
<h3 id="什么是-aof-持久化">什么是 AOF 持久化？</h3>
<p>与快照持久化相比，AOF
持久化的<strong>实时性更好</strong>，因此已成为主流的持久化方案。默认情况下
Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly
参数开启：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<p>开启 AOF 持久化后<strong>每执行一条会更改 Redis
中的数据</strong>的命令，Redis 就会<strong>将该命令写入到内存缓存
<code>server.aof_buf</code> 中</strong>，然后再根据
<strong><code>appendfsync</code></strong>
配置来决定何时将其<strong>同步到硬盘</strong>中的 AOF 文件。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir
参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>
<p>在 Redis 的配置文件中存在<strong>三种</strong>不同的 AOF
持久化方式，它们分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure>
<p>为了兼顾数据和写入性能，用户可以考虑
<code>appendfsync everysec</code> 选项 ，让 Redis <strong>每秒同步一次
AOF</strong> 文件，Redis
性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会<strong>丢失一秒之内产生的数据</strong>。当硬盘忙于执行写入操作的时候，Redis
还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p><strong>相关 issue</strong> ：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/783">Redis
的 AOF 方式 #783</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/1439">Redis
AOF 重写描述不准确 #1439</a></li>
</ul>
<h3 id="aof-日志是如何实现的">AOF 日志是如何实现的？</h3>
<p>关系型数据库（如
MySQL）通常都是<strong>执行命令之前记录日志</strong>（方便故障恢复），而
Redis AOF 持久化机制是在<strong>执行完命令之后再记</strong>录日志。</p>
<p><a
target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/database/redis/images/redis-aof-write-log-disc.png"><img
src="https://github.com/Snailclimb/JavaGuide/raw/main/docs/database/redis/images/redis-aof-write-log-disc.png"
alt="AOF 记录日志过程" /></a></p>
<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>
<ul>
<li>避免<strong>额外的检查</strong>开销，AOF
记录日志<strong>不会对命令进行语法检查</strong>；</li>
<li>在命令执行完之后再记录，<strong>不会阻塞当前的命令执行</strong>。</li>
</ul>
<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>
<ul>
<li>如果刚执行完命令 Redis
就宕机会导致对应的<strong>修改丢失</strong>；</li>
<li>可能会<strong>阻塞后续其他命令</strong>的执行（AOF 记录日志是在
Redis 主线程中进行的）。</li>
</ul>
<h3 id="aof-重写了解吗">AOF 重写了解吗？</h3>
<p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF
文件，这个新的 AOF 文件和原有的 AOF
文件<strong>所保存的数据库状态一样</strong>，<strong>但体积更小</strong>。</p>
<p>AOF
重写是一个有<strong>歧义</strong>的名字，该功能是<strong>通过读取数据库中的键值对来实现</strong>的，程序<strong>无须对现有
AOF
文件进行任何读入</strong>、<strong>分析</strong>或者<strong>写入</strong>操作。</p>
<p>在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个
<strong>AOF 重写缓冲区</strong>，该缓冲区会在<strong>子进程创建新 AOF
文件期间</strong>，<strong>记录服务器执行的所有写命令</strong>。当<strong>子进程完成创建新
AOF
文件的工作之后</strong>，服务器会<strong>将重写缓冲区中的所有内容追加到新
AOF 文件的末尾</strong>，使得新的 AOF
文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF
文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<p>Redis 7.0 版本之前，如果在<strong>重写期间有写入命令，AOF
可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次</strong>。</p>
<blockquote>
<p>aof 文件重写是将 <strong>redis 中的数据转换为
写命令</strong>同步更新到 aof 文件的过程。</p>
<p><strong>重写 aof 后 为什么么可以变小</strong></p>
<ul>
<li>清除了一些无效命令 eg. del srem</li>
<li>进程内超时的数据不再写入 aof 文件</li>
<li>多条写命令可以合并为批量写命令 eg.
<code>lpush list v1 lpush list v2 lpush list v3 合并为一条写入命令 lpush list v1 v2 v3</code></li>
</ul>
</blockquote>
<h3 id="如何选择-rdb-和-aof">如何选择 RDB 和 AOF？</h3>
<p>关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明<a
target="_blank" rel="noopener" href="https://redis.io/docs/manual/persistence/">Redis
persistence</a>，这里结合自己的理解简单总结一下。</p>
<p><strong>RDB 比 AOF 优秀的地方</strong> ：</p>
<ul>
<li>RDB 文件存储的内容是<strong>经过压缩的二进制</strong>数据，
保存着<strong>某个时间点</strong>的数据集，文件很小，适合做数据的备份，灾难恢复。AOF
文件存储的是<strong>每一次写</strong>命令，类似于 MySQL 的
<strong>binlog 日志</strong>，通常会必 RDB
文件<strong>大很多</strong>。当 AOF 变得太大时，Redis 能够在后台自动重写
AOF。新的 AOF 文件和原有的 AOF
文件所保存的数据库状态一样，但<strong>体积更小</strong>。不过， Redis
7.0 版本之前，如果在重写期间有写入命令，AOF
可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li>
<li>使用 RDB
文件恢复数据，<strong>直接解析还原数据即可，不需要一条一条地执行命令</strong>，速度非常快。而
AOF 则需要依次执行每个写命令，<strong>速度非常慢</strong>。也就是说，与
AOF 相比，恢复大数据集的时候，RDB 速度更快。</li>
</ul>
<p><strong>AOF 比 RDB 优秀的地方</strong> ：</p>
<ul>
<li>RDB 的数据<strong>安全性</strong>不如
AOF，没有办法<strong>实时</strong>或者<strong>秒级持久化</strong>数据。生成
RDB 文件的过程是比繁重的， 虽然 BGSAVE 子进程写入 RDB
文件的工作不会阻塞主线程，但会对机器的 <strong>CPU
资源</strong>和<strong>内存资源</strong>产生影响，严重的情况下甚至会直接把
Redis 服务干宕机。<strong>AOF 支持秒级数据丢失</strong>（取决 fsync
策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF
文件，操作轻量。</li>
<li>RDB 文件是以<strong>特定的二进制格式</strong>保存的，并且在 Redis
版本演进中有<strong>多个版本的 RDB</strong>，所以存在老版本的 Redis
服务不兼容新版本的 RDB 格式的问题。</li>
<li>AOF
以一种<strong>易于理解和解析</strong>的格式包含所有操作的日志。你可以轻松地导出
AOF 文件进行分析，你也可以直接操作 AOF
文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要
AOF
文件没有被重写，<strong>删除最新命令并重启</strong>即可恢复之前的状态。</li>
</ul>
<h3 id="redis-4.0-对于持久化机制做了什么优化">Redis 4.0
对于持久化机制做了什么优化？</h3>
<p>由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF
的<strong>混合持久化</strong>（默认关闭，可以通过配置项
<code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就<strong>直接把 RDB 的内容写到
AOF 文件开头</strong>。这样做的好处是可以结合 RDB 和 AOF 的优点,
<strong>快速加载</strong>同时避<strong>免丢失过多</strong>的数据。当然缺点也是有的，
<strong>AOF 里面的 RDB 部分是压缩格式不再是 AOF
格式</strong>，可读性较差。</p>
<p>官方文档地址：https://redis.io/topics/persistence</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f64617461626173652f72656469732f7265646973342e302d706572736974656e63652e706e67"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="参考">参考</h2>
<ul>
<li>《Redis 开发与运维》</li>
<li>《Redis 设计与实现》</li>
<li>Redis 命令手册：https://www.redis.com.cn/commands.html</li>
<li>WHY Redis choose single thread (vs multi threads):
https://medium.com/<span class="citation"
data-cites="jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153">@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153</span></li>
<li>The difference between AOF and RDB
persistence：https://www.sobyte.net/post/2022-04/redis-rdb-and-aof/</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%8D%E4%B9%A0/" rel="tag"># 复习</a>
              <a href="/tags/%E5%A4%8D%E4%B9%A0-javaGuide/" rel="tag"># 复习-javaGuide</a>
              <a href="/tags/%E5%A4%8D%E4%B9%A0-javaGuide-database/" rel="tag"># 复习-javaGuide-database</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/21/review/java_guide/lycly_system-design/web-real-time-message-push/" rel="prev" title="web-real-time-message-push">
      <i class="fa fa-chevron-left"></i> web-real-time-message-push
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/23/review/java_guide/database/redis/ly0706lyredis-questions-02/" rel="next" title="redis面试题02">
      redis面试题02 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="lwmfjc/lwmfjc.github.io.comment" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">Redis 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-redis"><span class="nav-number">1.1.</span> <span class="nav-text">什么是 Redis？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="nav-number">1.2.</span> <span class="nav-text">Redis 为什么这么快？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.3.</span> <span class="nav-text">分布式缓存常见的技术选型方案有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-redis-%E5%92%8C-memcached-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">1.4.</span> <span class="nav-text">说一下 Redis 和
Memcached 的区别和共同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98"><span class="nav-number">1.5.</span> <span class="nav-text">为什么要用
Redis&#x2F;为什么要用缓存？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E9%99%A4%E4%BA%86%E5%81%9A%E7%BC%93%E5%AD%98%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="nav-number">1.6.</span> <span class="nav-text">Redis 除了做缓存，还能做什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E5%8F%AF%E4%BB%A5%E5%81%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B9%88"><span class="nav-number">1.7.</span> <span class="nav-text">Redis 可以做消息队列么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E-redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">1.8.</span> <span class="nav-text">如何基于 Redis 实现分布式锁？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">Redis 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.1.</span> <span class="nav-text">Redis 常用的数据结构有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.2.</span> <span class="nav-text">String 的应用场景有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-%E8%BF%98%E6%98%AF-hash-%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E6%9B%B4%E5%A5%BD%E5%91%A2"><span class="nav-number">2.3.</span> <span class="nav-text">String 还是 Hash
存储对象数据更好呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.4.</span> <span class="nav-text">String 的底层实现是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%BF%A1%E6%81%AF%E7%94%A8-string-%E8%BF%98%E6%98%AF-hash-%E5%AD%98%E5%82%A8%E6%9B%B4%E5%A5%BD%E5%91%A2"><span class="nav-number">2.5.</span> <span class="nav-text">购物车信息用 String
还是 Hash 存储更好呢?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-redis-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8E%92%E8%A1%8C%E6%A6%9C%E6%80%8E%E4%B9%88%E5%81%9A"><span class="nav-number">2.6.</span> <span class="nav-text">使用 Redis
实现一个排行榜怎么做？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-set-%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4"><span class="nav-number">2.7.</span> <span class="nav-text">使用 Set
实现抽奖系统需要用到什么命令？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-bitmap-%E7%BB%9F%E8%AE%A1%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%E6%80%8E%E4%B9%88%E5%81%9A"><span class="nav-number">2.8.</span> <span class="nav-text">使用 Bitmap
统计活跃用户怎么做？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-hyperloglog-%E7%BB%9F%E8%AE%A1%E9%A1%B5%E9%9D%A2-uv-%E6%80%8E%E4%B9%88%E5%81%9A"><span class="nav-number">2.9.</span> <span class="nav-text">使用 HyperLogLog 统计页面
UV 怎么做？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">Redis 线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BA%86%E8%A7%A3%E5%90%97"><span class="nav-number">3.1.</span> <span class="nav-text">Redis 单线程模型了解吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis6.0-%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">Redis6.0
之前为什么不使用多线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis6.0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.3.</span> <span class="nav-text">Redis6.0
之后为何引入了多线程？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">Redis 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E7%BB%99%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%9C%89%E5%95%A5%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text">Redis
给缓存数据设置过期时间有啥用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F%E7%9A%84%E5%91%A2"><span class="nav-number">4.2.</span> <span class="nav-text">Redis
是如何判断数据是否过期的呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E4%B9%88"><span class="nav-number">4.3.</span> <span class="nav-text">过期的数据的删除策略了解么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88"><span class="nav-number">4.4.</span> <span class="nav-text">Redis 内存淘汰机制了解么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">Redis 持久化机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81-redis-%E6%8C%82%E6%8E%89%E4%B9%8B%E5%90%8E%E5%86%8D%E9%87%8D%E5%90%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E6%81%A2%E5%A4%8D"><span class="nav-number">5.1.</span> <span class="nav-text">怎么保证 Redis
挂掉之后再重启数据可以进行恢复？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-rdb-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">5.2.</span> <span class="nav-text">什么是 RDB 持久化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rdb-%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7%E6%97%B6%E4%BC%9A%E9%98%BB%E5%A1%9E%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%90%97"><span class="nav-number">5.3.</span> <span class="nav-text">RDB
创建快照时会阻塞主线程吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-aof-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">5.4.</span> <span class="nav-text">什么是 AOF 持久化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aof-%E6%97%A5%E5%BF%97%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">5.5.</span> <span class="nav-text">AOF 日志是如何实现的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aof-%E9%87%8D%E5%86%99%E4%BA%86%E8%A7%A3%E5%90%97"><span class="nav-number">5.6.</span> <span class="nav-text">AOF 重写了解吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-rdb-%E5%92%8C-aof"><span class="nav-number">5.7.</span> <span class="nav-text">如何选择 RDB 和 AOF？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-4.0-%E5%AF%B9%E4%BA%8E%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96"><span class="nav-number">5.8.</span> <span class="nav-text">Redis 4.0
对于持久化机制做了什么优化？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="刘易"
      src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/avatar.png">
  <p class="site-author-name" itemprop="name">刘易</p>
  <div class="site-description" itemprop="description">知命不惧 日日自新</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">250</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lwmfjc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lwmfjc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘易</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">45:41</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
