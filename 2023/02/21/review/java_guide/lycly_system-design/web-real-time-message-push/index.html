<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="web-real-time-message-push">
<meta property="og:type" content="article">
<meta property="og:title" content="web-real-time-message-push">
<meta property="og:url" content="http://example.com/2023/02/21/review/java_guide/lycly_system-design/web-real-time-message-push/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:description" content="web-real-time-message-push">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-21T09:26:53.000Z">
<meta property="article:modified_time" content="2023-02-21T09:26:53.000Z">
<meta property="article:author" content="刘易">
<meta property="article:tag" content="复习">
<meta property="article:tag" content="复习-javaGuide">
<meta property="article:tag" content="复习-javaGuide-distributed_system">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/02/21/review/java_guide/lycly_system-design/web-real-time-message-push/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>web-real-time-message-push | 随记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">随记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/21/review/java_guide/lycly_system-design/web-real-time-message-push/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/avatar.png">
      <meta itemprop="name" content="刘易">
      <meta itemprop="description" content="知命不惧 日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          web-real-time-message-push
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-21 09:26:53" itemprop="dateCreated datePublished" datetime="2023-02-21T09:26:53+00:00">2023-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>
            <div class="post-description">web-real-time-message-push</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<blockquote>
<p>原文地址：https://juejin.cn/post/7122014462181113887，JavaGuide
对本文进行了完善总结。</p>
</blockquote>
<p>我有一个朋友做了一个小破站，现在要实现一个站内信 Web
消息推送的功能，对，就是下图这个小红点，一个很常用的功能。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1460000042192380.png"
alt="站内信 Web 消息推送" />
<figcaption aria-hidden="true">站内信 Web 消息推送</figcaption>
</figure>
<p>不过他还没想好用什么方式做，这里我帮他整理了一下几种方案，并简单做了实现。</p>
<h2 id="什么是消息推送"><a href="#什么是消息推送">#</a>
什么是消息推送？</h2>
<p>推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。</p>
<p>消息推送通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备
APP 进行的主动消息推送。</p>
<p>消息推送一般又分为 Web 端消息推送和移动端消息推送。</p>
<p>移动端消息推送示例 ：</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/IKleJ9auR1Ojdicyr0bH.png"
alt="移动端消息推送示例" />
<figcaption aria-hidden="true">移动端消息推送示例</figcaption>
</figure>
<p>Web 端消息推送示例：</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20220819100512941.png"
alt="Web 端消息推送示例" />
<figcaption aria-hidden="true">Web 端消息推送示例</figcaption>
</figure>
<p>在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，<strong>只要触发某个事件（主动分享了资源或者后台主动推送消息）</strong>，<strong>Web
页面的通知小红点就会实时的 <code>+1</code></strong> 就可以了。</p>
<p>通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230221092850800.png"
alt="image-20230221092850800" />
<figcaption aria-hidden="true">image-20230221092850800</figcaption>
</figure>
<p>消息推送无非是推（push）和拉（pull）两种形式，下边我们逐个了解下。</p>
<h2 id="消息推送常见方案"><a href="#消息推送常见方案">#</a>
消息推送常见方案</h2>
<h3 id="短轮询"><a href="#短轮询">#</a> 短轮询</h3>
<p><strong>轮询(polling)</strong>
应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为<strong>短轮询</strong>和<strong>长轮询</strong>。</p>
<p>短轮询很好理解，<strong>指定的时间间隔</strong>，<strong>由浏览器向服务器发出
HTTP
请求</strong>，<strong>服务器实时返回未读消息数据给客户端，浏览器再做渲染显示</strong>。</p>
<p>一个简单的 JS
定时器就可以搞定，<strong>每秒钟请求一次未读消息数接口</strong>，返回的数据展示即可。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 方法请求</span></span><br><span class="line">  <span class="title function_">messageCount</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">messageCount</span> = res.<span class="property">data</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，<strong>由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求</strong>，势必会对服务端造成很大压力，浪费带宽和服务器资源。</p>
<h3 id="长轮询"><a href="#长轮询">#</a> 长轮询</h3>
<p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如
Nacos 和 Apollo 配置中心，消息队列 Kafka、RocketMQ
中都有用到长轮询。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg">Nacos
配置中心交互模型是 push 还是 pull？open in new
window</a>一文中我详细介绍过 Nacos
长轮询的实现原理，感兴趣的小伙伴可以瞅瞅。</p>
<p>长轮询其实原理跟轮询差不多，都是采用轮询的方式。不过，<strong>如果服务端的数据没有发生变更，会
一直 hold
住请求，直到服务端的数据发生变化</strong>，或者<strong>等待一定时间超时才会返回</strong>。返回后，客户端又会立即再次发起下一次长轮询。</p>
<p>这次我使用 Apollo
配置中心实现长轮询的方式，应用了一个类<code>DeferredResult</code>，它是在
Servelet3.0 后经过 Spring
封装提供的一种异步请求机制，直意就是延迟结果。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230221093050633.png"
alt="image-20230221093050633" />
<figcaption aria-hidden="true">image-20230221093050633</figcaption>
</figure>
<p><code>DeferredResult</code>可以<strong>允许容器线程快速释放占用的资源，不阻塞请求线程</strong>，以此接受更多的请求提升系统的吞吐量，然后启动异步工作线程处理真正的业务逻辑，处理完成调用<code>DeferredResult.setResult(200)</code>提交响应结果。</p>
<p>下边我们用长轮询来实现消息推送。</p>
<p>因为一个 ID 可能会被多个长轮询请求监听，所以我采用了 Guava
包提供的<code>Multimap</code>结构存放长轮询，一个 key 可以对应多个
value。一旦监听到 key
发生变化，对应的所有长轮询都会响应。前端得到非请求超时的状态码，知晓数据变更，主动查询未读消息数接口，更新页面数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/polling&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PollingController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放监听某个Id的长轮询集合</span></span><br><span class="line">    <span class="comment">// 线程同步结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Multimap&lt;String, DeferredResult&lt;String&gt;&gt; watchRequests = Multimaps.synchronizedMultimap(HashMultimap.create());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置监听</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(path = &quot;watch/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title function_">watch</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> &#123;</span><br><span class="line">        <span class="comment">// 延迟对象设置超时时间</span></span><br><span class="line">        DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> <span class="title class_">DeferredResult</span>&lt;&gt;(TIME_OUT);</span><br><span class="line">        <span class="comment">// 异步请求完成时移除 key，防止内存溢出</span></span><br><span class="line">        deferredResult.onCompletion(() -&gt; &#123;</span><br><span class="line">            watchRequests.remove(id, deferredResult);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 注册长轮询请求</span></span><br><span class="line">        watchRequests.put(id, deferredResult);</span><br><span class="line">        <span class="keyword">return</span> deferredResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变更数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(path = &quot;publish/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">publish</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> &#123;</span><br><span class="line">        <span class="comment">// 数据变更 取出监听ID的所有长轮询请求，并一一响应处理</span></span><br><span class="line">        <span class="keyword">if</span> (watchRequests.containsKey(id)) &#123;</span><br><span class="line">            Collection&lt;DeferredResult&lt;String&gt;&gt; deferredResults = watchRequests.get(id);</span><br><span class="line">            <span class="keyword">for</span> (DeferredResult&lt;String&gt; deferredResult : deferredResults) &#123;</span><br><span class="line">                deferredResult.setResult(<span class="string">&quot;我更新了&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当请求超过设置的超时时间，会抛出<code>AsyncRequestTimeoutException</code>异常，这里直接用<code>@ControllerAdvice</code>全局捕获统一返回即可，前端获取约定好的状态码后再次发起长轮询请求，如此往复调用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncRequestTimeoutHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.NOT_MODIFIED)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(AsyncRequestTimeoutException.class)</span></span><br><span class="line">    <span class="keyword">public</span> String asyncRequestTimeoutHandler(AsyncRequestTimeoutException e) &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;异步请求超时&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;304&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来测试一下，首先页面发起长轮询请求<code>/polling/watch/10086</code>监听消息更变，请求被挂起，不变更数据直至超时，再次发起了长轮询请求；紧接着手动变更数据<code>/polling/publish/10086</code>，长轮询得到响应，前端处理业务逻辑完成后再次发起请求，如此循环往复。</p>
<p>长轮询相比于短轮询在性能上提升了很多，但依然会产生较多的请求，这是它的一点不完美的地方。</p>
<h3 id="iframe-流"><a href="#iframe-流">#</a> iframe 流</h3>
<p>iframe
流就是在页面中插入一个隐藏的<code>&lt;iframe&gt;</code>标签，通过在<code>src</code>中请求消息数量
API
接口，由此在服务端和客户端之间创建一条长连接，服务端持续向<code>iframe</code>传输数据。</p>
<p>传输的数据通常是 HTML、或是内嵌的JavaScript
脚本，来达到实时更新页面的效果。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1460000042192388.png"
alt="iframe 流示意图" />
<figcaption aria-hidden="true">iframe 流示意图</figcaption>
</figure>
<p>这种方式实现简单，前端只要一个<code>&lt;iframe&gt;</code>标签搞定了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;/iframe/message&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务端直接组装 HTML、JS 脚本数据向 response 写入就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/iframe&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IframeController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(path = &quot;message&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">message</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            response.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">            response.setDateHeader(<span class="string">&quot;Expires&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache,no-store&quot;</span>);</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">            response.getWriter().print(<span class="string">&quot; &lt;script type=\&quot;text/javascript\&quot;&gt;\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;parent.document.getElementById(&#x27;clock&#x27;).innerHTML = \&quot;&quot;</span> + count.get() + <span class="string">&quot;\&quot;;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;parent.document.getElementById(&#x27;count&#x27;).innerHTML = \&quot;&quot;</span> + count.get() + <span class="string">&quot;\&quot;;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;&lt;/script&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iframe 流的服务器开销很大，而且IE、Chrome等浏览器一直会处于 loading
状态，图标会不停旋转，简直是强迫症杀手。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1460000042192389.png"
alt="iframe 流效果" />
<figcaption aria-hidden="true">iframe 流效果</figcaption>
</figure>
<p>iframe 流非常不友好，强烈不推荐。</p>
<h3 id="sse-我的方式"><a href="#sse-我的方式">#</a> SSE (我的方式)</h3>
<p>很多人可能不知道，服务端向客户端推送消息，其实除了可以用<code>WebSocket</code>这种耳熟能详的机制外，还有一种服务器发送事件(Server-Sent
Events)，简称 SSE。这是一种服务器端到客户端(浏览器)的单向消息推送。</p>
<p>SSE 基于 HTTP 协议的，我们知道一般意义上的 HTTP
协议是无法做到服务端主动向客户端推送消息的，但 SSE
是个例外，它变换了一种思路。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1460000042192390.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>SSE
在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是<code>text/event-stream</code>类型的数据流信息，在有数据变更时从服务器流式传输到客户端。</p>
<p>整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1460000042192391.png"
alt="SSE 示意图" />
<figcaption aria-hidden="true">SSE 示意图</figcaption>
</figure>
<p>SSE 与 WebSocket
作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：</p>
<ul>
<li>SSE 是基于 HTTP
协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket
需单独服务器来处理协议。</li>
<li>SSE 单向通信，只能由服务端向客户端单向通信；WebSocket
全双工通信，即通信的双方可以同时发送和接受信息。</li>
<li>SSE 实现简单开发成本低，无需引入其他组件；WebSocket
传输数据需做二次解析，开发门槛高一些。</li>
<li>SSE 默认支持断线重连；WebSocket 则需要自己实现。</li>
<li>SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket
默认支持传送二进制数据。</li>
</ul>
<p><strong>SSE 与 WebSocket 该如何选择？</strong></p>
<blockquote>
<p>技术并没有好坏之分，只有哪个更合适</p>
</blockquote>
<p>SSE 好像一直不被大家所熟知，一部分原因是出现了
WebSocket，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。</p>
<p>但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE
不管是从实现的难易和成本上都更加有优势。此外，SSE 具有 WebSocket
在设计上缺乏的多种功能，例如：自动重新连接、事件 ID
和发送任意事件的能力。</p>
<p>前端只需进行一次 HTTP 请求，带上唯一
ID，打开事件流，监听服务端推送的事件就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> source = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> userId = <span class="number">7777</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">EventSource</span>) &#123;</span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        source = <span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&#x27;http://localhost:7777/sse/sub/&#x27;</span>+userId);</span><br><span class="line">        <span class="title function_">setMessageInnerHTML</span>(<span class="string">&quot;连接用户=&quot;</span> + userId);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 连接一旦建立，就会触发open事件</span></span><br><span class="line"><span class="comment">         * 另一种写法：source.onopen = function (event) &#123;&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        source.<span class="title function_">addEventListener</span>(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">            <span class="title function_">setMessageInnerHTML</span>(<span class="string">&quot;建立连接。。。&quot;</span>);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 客户端收到服务器发来的数据</span></span><br><span class="line"><span class="comment">         * 另一种写法：source.onmessage = function (event) &#123;&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        source.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">            <span class="title function_">setMessageInnerHTML</span>(e.<span class="property">data</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">setMessageInnerHTML</span>(<span class="string">&quot;你的浏览器不支持SSE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>服务端的实现更简单，创建一个<code>SseEmitter</code>对象放入<code>sseEmitterMap</code>进行管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, SseEmitter&gt; sseEmitterMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SseEmitter <span class="title function_">connect</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 设置超时时间，0表示不过期。默认30秒</span></span><br><span class="line">        <span class="type">SseEmitter</span> <span class="variable">sseEmitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SseEmitter</span>(<span class="number">0L</span>);</span><br><span class="line">        <span class="comment">// 注册回调</span></span><br><span class="line">        sseEmitter.onCompletion(completionCallBack(userId));</span><br><span class="line">        sseEmitter.onError(errorCallBack(userId));</span><br><span class="line">        sseEmitter.onTimeout(timeoutCallBack(userId));</span><br><span class="line">        sseEmitterMap.put(userId, sseEmitter);</span><br><span class="line">        count.getAndIncrement();</span><br><span class="line">        <span class="keyword">return</span> sseEmitter;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;创建新的sse连接异常，当前用户：&#123;&#125;&quot;</span>, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给指定用户发送消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String userId, String message)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sseEmitterMap.containsKey(userId)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sseEmitterMap.get(userId).send(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;用户[&#123;&#125;]推送异常:&#123;&#125;&quot;</span>, userId, e.getMessage());</span><br><span class="line">            removeUser(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> SSE 不支持 IE
浏览器，对其他主流浏览器兼容性做的还不错。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1460000042192393.png"
alt="SSE 兼容性" />
<figcaption aria-hidden="true">SSE 兼容性</figcaption>
</figure>
<h3 id="websocket"><a href="#websocket">#</a> Websocket</h3>
<p>Websocket 应该是大家都比较熟悉的一种实现消息推送的方式，上边我们在讲
SSE 的时候也和 Websocket 进行过比较。</p>
<p>是一种在 TCP
连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器<strong>仅需一次握手</strong>，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1460000042192394.png"
alt="1460000042192394" />
<figcaption aria-hidden="true">1460000042192394</figcaption>
</figure>
<p>SpringBoot 整合 Websocket，先引入 Websocket 相关的工具包，和 SSE
相比额外的开发成本。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入websocket --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!--可能需要排除springboot自带的tomcat--&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务端使用<code>@ServerEndpoint</code>注解标注当前类为一个 WebSocket
服务器，客户端可以通过<code>ws://localhost:7777/webSocket/10086</code>来连接到
WebSocket 服务器端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/websocket/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebSocket</span> &#123;</span><br><span class="line">    <span class="comment">//与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;MyWebSocket&gt; webSockets = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 用来存在线连接数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Session&gt; sessionPool = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Session&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接成功调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(value = &quot;userId&quot;)</span> String userId)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.session = session;</span><br><span class="line">            webSockets.add(<span class="built_in">this</span>);</span><br><span class="line">            sessionPool.put(userId, session);</span><br><span class="line">            log.info(<span class="string">&quot;websocket消息: 有新的连接，总数为:&quot;</span> + webSockets.size());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;websocket消息: 收到客户端消息:&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此为单点消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOneMessage</span><span class="params">(String userId, String message)</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionPool.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="literal">null</span> &amp;&amp; session.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;websocket消: 单点消息:&quot;</span> + message);</span><br><span class="line">                session.getAsyncRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前端初始化打开 WebSocket
连接，并监听连接状态，接收服务端数据或向服务端发送数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>websocket测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;sendMessage()&quot;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//注意，地址不要填错了</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8089/websocket/10086&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 获取连接状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ws连接状态：&#x27;</span> + ws.<span class="property">readyState</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//监听是否连接成功</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ws.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ws连接状态：&#x27;</span> + ws.<span class="property">readyState</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//连接成功则发送一个数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        ws.<span class="title function_">send</span>(<span class="string">&#x27;test1&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 接听服务器发回的信息并处理展示</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ws.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;接收到来自服务器的消息：&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//完成通信后关闭WebSocket连接(这里不要关闭，让他持续发）</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//ws.close();</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 监听连接关闭事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ws.<span class="property">onclose</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 监听整个过程中websocket的状态</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ws连接状态：&#x27;</span> + ws.<span class="property">readyState</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 监听并处理error事件</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    ws.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//如果新开一个窗口，可以手动访问http://192.168.2.26:8089/socket/publish?userId=10086&amp;message=abcde,那么就可以发送消息啦（原窗口可以继续接收消息）</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">sendMessage</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> content = $(<span class="string">&quot;#message&quot;</span>).<span class="title function_">val</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//这里需要后台提供/socket/publish接口</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $.<span class="title function_">ajax</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">url</span>: <span class="string">&#x27;http://192.168.2.26:8089/socket/publish?userId=10086&amp;message=&#x27;</span> + content,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">type</span>: <span class="string">&#x27;GET&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">data</span>: &#123; <span class="string">&quot;id&quot;</span>: <span class="string">&quot;7777&quot;</span>, <span class="string">&quot;content&quot;</span>: content &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>页面初始化建立 WebSocket
连接，之后就可以进行双向通信了，效果还不错。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230221105627358.png"
alt="image-20230221105627358" />
<figcaption aria-hidden="true">image-20230221105627358</figcaption>
</figure>
<h3 id="mqtt"><a href="#mqtt">#</a> MQTT</h3>
<p><strong>什么是 MQTT 协议？</strong></p>
<p>MQTT (Message Queue Telemetry
Transport)是一种基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息，是物联网（Internet
of Thing）中的一个标准传输协议。</p>
<p>该协议将消息的发布者（publisher）与订阅者（subscriber）进行分离，因此可以在不可靠的网络环境中，为远程连接的设备提供可靠的消息服务，使用方式与传统的
MQ 有点类似。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1460000022986325.png"
alt="MQTT 协议示例" />
<figcaption aria-hidden="true">MQTT 协议示例</figcaption>
</figure>
<p>TCP 协议位于传输层，MQTT 协议位于应用层，MQTT 协议构建于 TCP/IP
协议上，也就是说只要支持 TCP/IP 协议栈的地方，都可以使用 MQTT 协议。</p>
<p><strong>为什么要用 MQTT 协议？</strong></p>
<p>MQTT
协议为什么在物联网（IOT）中如此受偏爱？而不是其它协议，比如我们更为熟悉的
HTTP 协议呢？</p>
<ul>
<li>首先 HTTP
协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（IOT）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合
IOT 应用程序。</li>
<li>HTTP
是单向的，如果要获取消息客户端必须发起连接，而在物联网（IOT）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。</li>
<li>通常需要将一条命令或者消息，发送到网络上的所有设备上。HTTP
要实现这样的功能不但很困难，而且成本极高。</li>
</ul>
<p>具体的 MQTT
协议介绍和实践，这里我就不再赘述了，大家可以参考我之前的两篇文章，里边写的也都很详细了。</p>
<ul>
<li>MQTT 协议的介绍：<a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/udFE6k9pPetIWsa6KeErrA">我也没想到
SpringBoot + RabbitMQ 做智能家居，会这么简单open in new window</a></li>
<li>MQTT 实现消息推送：<a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/U-fUGr9i1MVa4PoVyiDFCg">未读消息（小红点），前端
与 RabbitMQ 实时消息推送实践，贼简单~open in new window</a></li>
</ul>
<h2 id="总结"><a href="#总结">#</a> 总结</h2>
<blockquote>
<p>以下内容为 JavaGuide 补充</p>
</blockquote>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 41%" />
<col style="width: 15%" />
<col style="width: 36%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>介绍</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>短轮询</td>
<td>客户端定时向服务端发送请求，服务端直接返回响应数据（即使没有数据更新）</td>
<td>简单、易理解、易实现</td>
<td>实时性太差，无效请求太多，频繁建立连接太耗费资源</td>
</tr>
<tr class="even">
<td>长轮询</td>
<td>与短轮询不同是，长轮询接收到客户端请求之后等到有数据更新才返回请求</td>
<td>减少了无效请求</td>
<td>挂起请求会导致资源浪费</td>
</tr>
<tr class="odd">
<td>iframe 流</td>
<td>服务端和客户端之间创建一条长连接，服务端持续向<code>iframe</code>传输数据。</td>
<td>简单、易理解、易实现</td>
<td>维护一个长连接会增加开销，效果太差（图标会不停旋转）</td>
</tr>
<tr class="even">
<td>SSE</td>
<td>一种服务器端到客户端(浏览器)的单向消息推送。</td>
<td>简单、易实现，功能丰富</td>
<td>不支持双向通信</td>
</tr>
<tr class="odd">
<td>WebSocket</td>
<td>除了最初建立连接时用 HTTP 协议，其他时候都是直接基于 TCP
协议进行通信的，可以实现客户端和服务端的全双工通信。</td>
<td>性能高、开销小</td>
<td>对开发人员要求更高，实现相对复杂一些</td>
</tr>
<tr class="even">
<td>MQTT</td>
<td>基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息。</td>
<td>成熟稳定，轻量级</td>
<td>对开发人员要求更高，实现相对复杂一些</td>
</tr>
</tbody>
</table>
<hr />
<p>著作权归所有
原文链接：https://javaguide.cn/system-design/web-real-time-message-push.html</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%8D%E4%B9%A0/" rel="tag"># 复习</a>
              <a href="/tags/%E5%A4%8D%E4%B9%A0-javaGuide/" rel="tag"># 复习-javaGuide</a>
              <a href="/tags/%E5%A4%8D%E4%B9%A0-javaGuide-distributed-system/" rel="tag"># 复习-javaGuide-distributed_system</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/21/review/java_guide/lycly_system-design/schedule-task/" rel="prev" title="Java定时任务详解">
      <i class="fa fa-chevron-left"></i> Java定时任务详解
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/22/review/java_guide/database/redis/ly0705lyredis-questions-01/" rel="next" title="redis面试题01">
      redis面试题01 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="lwmfjc/lwmfjc.github.io.comment" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81"><span class="nav-number">1.</span> <span class="nav-text">
什么是消息推送？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E5%B8%B8%E8%A7%81%E6%96%B9%E6%A1%88"><span class="nav-number">2.</span> <span class="nav-text">
消息推送常见方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%AD%E8%BD%AE%E8%AF%A2"><span class="nav-number">2.1.</span> <span class="nav-text"> 短轮询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%95%BF%E8%BD%AE%E8%AF%A2"><span class="nav-number">2.2.</span> <span class="nav-text"> 长轮询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iframe-%E6%B5%81"><span class="nav-number">2.3.</span> <span class="nav-text"> iframe 流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sse-%E6%88%91%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text"> SSE (我的方式)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#websocket"><span class="nav-number">2.5.</span> <span class="nav-text"> Websocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mqtt"><span class="nav-number">2.6.</span> <span class="nav-text"> MQTT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text"> 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="刘易"
      src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/avatar.png">
  <p class="site-author-name" itemprop="name">刘易</p>
  <div class="site-description" itemprop="description">知命不惧 日日自新</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">194</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lwmfjc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lwmfjc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘易</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">41:24</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
