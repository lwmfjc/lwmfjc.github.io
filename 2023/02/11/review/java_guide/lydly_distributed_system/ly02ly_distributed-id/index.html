<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="分布式id">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式id">
<meta property="og:url" content="http://example.com/2023/02/11/review/java_guide/lydly_distributed_system/ly02ly_distributed-id/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:description" content="分布式id">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-11T13:00:31.000Z">
<meta property="article:modified_time" content="2023-02-11T13:00:31.000Z">
<meta property="article:author" content="刘易">
<meta property="article:tag" content="复习">
<meta property="article:tag" content="复习-javaGuide">
<meta property="article:tag" content="复习-javaGuide-distributed_system">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/02/11/review/java_guide/lydly_distributed_system/ly02ly_distributed-id/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>分布式id | 随记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">随记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/11/review/java_guide/lydly_distributed_system/ly02ly_distributed-id/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/avatar.png">
      <meta itemprop="name" content="刘易">
      <meta itemprop="description" content="知命不惧 日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          分布式id
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-11 13:00:31" itemprop="dateCreated datePublished" datetime="2023-02-11T13:00:31+00:00">2023-02-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>
            <div class="post-description">分布式id</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="分布式-id-介绍">分布式 ID 介绍</h2>
<h3 id="什么是-id">什么是 ID？</h3>
<p>日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID
对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID
对应且仅对应一个订单。</p>
<p>我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人、地址 ID
对应且仅对应</p>
<p>简单来说，<strong>ID 就是数据的唯一标识</strong>。</p>
<h3 id="什么是分布式-id">什么是分布式 ID？</h3>
<p>分布式 ID 是<strong>分布式系统下的 ID</strong>。分布式 ID
<strong>不存在与现实生活中(属于技术上的问题，跟业务无关)</strong>，属于计算机系统中的一个概念。</p>
<p>我简单举一个<strong>分库分表</strong>的例子。</p>
<p>我司的一个项目，使用的是单机 MySQL
。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。单机
MySQL 已经没办法支撑了，需要进行分库分表（推荐
<strong>Sharding-JDBC</strong>）。</p>
<p>在分库之后，
<strong>数据遍布在不同服务器上的数据库</strong>，数据库的自增主键已经没办法满足生成的主键唯一了。<strong>我们如何为不同的数据节点生成全局唯一主键呢？</strong></p>
<p>这个时候就需要生成<strong>分布式 ID</strong>了。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230211131540513.png"
alt="image-20230211131540513" />
<figcaption aria-hidden="true">image-20230211131540513</figcaption>
</figure>
<h3 id="分布式-id-需要满足哪些要求">分布式 ID 需要满足哪些要求?</h3>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230211131556246.png"
alt="image-20230211131556246" />
<figcaption aria-hidden="true">image-20230211131556246</figcaption>
</figure>
<p>分布式 ID 作为分布式系统中必不可少的一环，很多地方都要用到分布式
ID。</p>
<p>一个最基本的分布式 ID 需要满足下面这些要求：</p>
<ul>
<li><strong>全局唯一</strong> ：ID
的<strong>全局唯一性</strong>肯定是首先要满足的！</li>
<li><strong>高性能</strong> ： 分布式 ID
的<strong>生成速度要快</strong>，对本地资源消耗要小。</li>
<li><strong>高可用</strong> ：生成分布式 ID
的服务要保证<strong>可用性无限接近于 100%</strong>。</li>
<li><strong>方便易用</strong>
：拿来即用，<strong>使用方便，快速接入</strong>！</li>
</ul>
<p>除了这些之外，一个比较好的分布式 ID 还应保证：</p>
<ul>
<li><strong>安全</strong> ：ID 中<strong>不包含敏感信息</strong>。</li>
<li><strong>有序递增</strong> ：如果要把 ID 存放在数据库的话，ID
的<strong>有序性可以提升数据库写入</strong>速度。并且，很多时候
，我们还很有可能会直接<strong>通过 ID 来进行排序</strong>。</li>
<li><strong>有具体的业务含义</strong> ：生成的 ID
如果能<strong>有具体的业务含义</strong>，可以让定位问题以及开发更透明化（通过
ID 就能确定是哪个业务）。</li>
<li><strong>独立部署</strong>
：也就是<strong>分布式系统单独</strong>有一个<strong>发号器</strong>服务，专门用来<strong>生成分布式
ID</strong>。这样就<strong>生成 ID
的服务</strong>可以和<strong>业务相关的服务解耦</strong>。不过，这样同样带来了网络调用消耗增加的问题。总的来说，<strong>如果需要用到分布式
ID 的场景比较多</strong>的话，独立部署的发号器服务还是很有必要的。</li>
</ul>
<h2 id="分布式-id-常见解决方案">分布式 ID 常见解决方案</h2>
<blockquote>
<p>这里说的是<strong>如何获取到一个分布式ID</strong>，而不是具体分布式ID的使用</p>
</blockquote>
<h3 id="数据库">数据库</h3>
<h4 id="数据库主键自增">数据库主键自增</h4>
<p>这种方式就比较简单直白了，就是通过<strong>关系型数据库的自增主键产生来唯一的
ID</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230211131616499.png"
alt="image-20230211131616499" />
<figcaption aria-hidden="true">image-20230211131616499</figcaption>
</figure>
<p>以 MySQL 举例，我们通过下面的方式即可。</p>
<p><strong>1.创建一个数据库表。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `sequence_id` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `stub` char(10) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `stub` (`stub`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>
<p><code>stub</code>
字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给
<code>stub</code>
字段创建了<strong>唯一索引</strong>，保证其唯一性。</p>
<p><strong>2.通过 <code>replace into</code> 来插入数据。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">REPLACE INTO sequence_id (stub) VALUES (&#x27;stub&#x27;);</span><br><span class="line">SELECT LAST_INSERT_ID();</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<p>插入数据这里，我们<strong>没有使用 <code>insert into</code> 而是使用
<code>replace into</code></strong> 来插入数据，具体步骤是这样的：</p>
<p>1)第一步： 尝试把数据插入到表中。</p>
<p>2)第二步：
如果<strong>主键或唯一索引字段出现重复数据错误而插入失败</strong>时，<strong>先从表中删除含有重复关键字值的冲突行</strong>，然后再次尝试把数据插入到表中。<br />
&gt; 使用replace只是用来删除行，没有什么特殊含义</p>
<p>这种方式的优缺点也比较明显：</p>
<ul>
<li><strong>优点</strong> ：实现起来比较简单、ID
有序递增、存储消耗空间小</li>
<li><strong>缺点</strong> ：
支持的<strong>并发量不大</strong>、存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID
没有具体业务含义、安全问题（比如<strong>根据订单 ID
的递增规律就能推算出每天的订单量</strong>，商业机密啊！ ）、每次获取 ID
都要访问一次数据库（增加了对数据库的压力，获取速度也慢）</li>
</ul>
<h4 id="数据库号段模式">数据库号段模式</h4>
<p>数据库主键自增这种模式，每次获取 ID 都要访问一次数据库，ID
需求比较大的时候，肯定是不行的。</p>
<p>如果我们可以<strong>批量获取</strong>，然后<strong>存在在内存里面</strong>，<strong>需要用到的时候，直接从内存里面拿</strong>就舒服了！这也就是我们说的
<strong>基于数据库的号段模式来生成分布式 ID。</strong></p>
<p>数据库的号段模式也是目前比较主流的一种分布式 ID
生成方式。像滴滴开源的<a
target="_blank" rel="noopener" href="https://github.com/didi/tinyid/wiki/tinyid原理介绍">Tinyid</a>
就是基于这种方式来做的。不过，TinyId 使用了双号段缓存、增加多 db
支持等方式来进一步优化。</p>
<p>以 MySQL 举例，我们通过下面的方式即可。</p>
<p><strong>1.创建一个数据库表。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `sequence_id_generator` (</span><br><span class="line">  `id` int(10) NOT NULL,</span><br><span class="line">  `current_max_id` bigint(20) NOT NULL COMMENT &#x27;当前最大id&#x27;,</span><br><span class="line">  `step` int(10) NOT NULL COMMENT &#x27;号段的长度&#x27;,</span><br><span class="line">  `version` int(20) NOT NULL COMMENT &#x27;版本号&#x27;,</span><br><span class="line">  `biz_type`    int(20) NOT NULL COMMENT &#x27;业务类型&#x27;,</span><br><span class="line">   PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>
<p><code>current_max_id</code>
字段和<code>step</code>字段主要用于获取批量 ID，获取的批量 id 为：
<code>current_max_id ~ current_max_id+step</code>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f64697374726962757465642d73797374656d2f64617461626.png"
alt="68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f64697374726962757465642d73797374656d2f64617461626.png" />
<figcaption
aria-hidden="true">68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f64697374726962757465642d73797374656d2f64617461626.png</figcaption>
</figure>
<p><code>version</code>
字段主要用于解决并发问题（乐观锁）,<code>biz_type</code>
主要用于表示<strong>业务类型</strong>。</p>
<p><strong>2.先插入一行数据。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO `sequence_id_generator` (`id`, `current_max_id`, `step`, `version`, `biz_type`)</span><br><span class="line">VALUES</span><br><span class="line">	(1, 0, 100, 0, 101);</span><br></pre></td></tr></table></figure>
<p><strong>3.通过 SELECT 获取指定业务下的批量唯一 ID</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	current_max_id	step	version	biz_type</span><br><span class="line">1	0	100	0	101</span><br></pre></td></tr></table></figure>
<p><strong>4.不够用的话，更新之后重新 SELECT 即可。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE sequence_id_generator SET current_max_id = 0+100, version=version+1 WHERE version = 0  AND `biz_type` = 101</span><br><span class="line">SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id	current_max_id	step	version	biz_type</span><br><span class="line">1	100	100	1	101</span><br></pre></td></tr></table></figure>
<p>相比于数据库主键自增的方式，<strong>数据库的号段模式对于数据库的访问次数更少，数据库压力更小。</strong></p>
<p>另外，为了避免单点问题，你可以从使用主从模式来提高可用性。</p>
<p><strong>数据库号段模式的优缺点:</strong></p>
<ul>
<li><strong>优点</strong> ：<strong>ID
有序递增</strong>、<strong>存储消耗空间小</strong></li>
<li><strong>缺点</strong>
：存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID
没有具体业务含义、安全问题（比如根据订单 ID
的递增规律就能推算出每天的订单量，商业机密啊！ ）</li>
</ul>
<h4 id="nosql">NoSQL</h4>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230211131732241.png"
alt="image-20230211131732241" />
<figcaption aria-hidden="true">image-20230211131732241</figcaption>
</figure>
<p>一般情况下，NoSQL 方案<strong>使用 Redis</strong> 多一些。我们通过
Redis 的 <code>incr</code> 命令即可实现对 id 原子顺序递增。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set sequence_id_biz_type 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr sequence_id_biz_type</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; get sequence_id_biz_type</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure>
<p>为了提高可用性和并发，我们可以使用 <strong>Redis
Cluster</strong>。Redis Cluster 是 Redis 官方提供的 <strong>Redis
集群解决</strong>方案（3.0+版本）。</p>
<p>除了 Redis Cluster 之外，你也可以使用开源的 Redis 集群方案<a
target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis">Codis</a>
（大规模集群比如上百个节点的时候比较推荐）。</p>
<p>除了高可用和并发之外，我们知道 Redis
基于内存，我们需要持久化数据，避免重启机器或者机器故障后数据丢失。Redis
支持两种不同的持久化方式：<strong>快照（snapshotting，RDB）</strong>、<strong>只追加文件（append-only
file, AOF）</strong>。 并且，Redis 4.0 开始支持 <strong>RDB 和 AOF
的混合持久化</strong>（默认关闭，可以通过配置项
<code>aof-use-rdb-preamble</code> 开启）。</p>
<p>关于 Redis
持久化，我这里就不过多介绍。不了解这部分内容的小伙伴，可以看看 <a
target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-all">JavaGuide
对于 Redis 知识点的总结</a>。</p>
<p><strong>Redis 方案的优缺点：</strong></p>
<ul>
<li><strong>优点</strong> ： <strong>性能不错</strong>并且<strong>生成的
ID 是有序递增</strong>的</li>
<li><strong>缺点</strong> ： 和数据库主键自增方案的缺点类似</li>
</ul>
<p>除了 Redis 之外，MongoDB ObjectId 经常也会被拿来当做分布式 ID
的解决方案。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230211131748560.png"
alt="image-20230211131748560" />
<figcaption aria-hidden="true">image-20230211131748560</figcaption>
</figure>
<p>MongoDB ObjectId 一共需要 12 个字节存储：</p>
<ul>
<li>0~3：时间戳</li>
<li>3~6： 代表机器 ID</li>
<li>7~8：机器进程 ID</li>
<li>9~11 ：自增值</li>
</ul>
<p><strong>MongoDB 方案的优缺点：</strong></p>
<ul>
<li><strong>优点</strong> ： 性能不错并且生成的 ID 是有序递增的</li>
<li><strong>缺点</strong> ： <strong>需要解决重复 ID
问题</strong>（<strong>当机器时间不对</strong>的情况下，可能导致会产生重复
ID） 、有安全性问题（ID 生成有规律性）</li>
</ul>
<h3 id="算法">算法</h3>
<h4 id="uuid">UUID</h4>
<p>UUID 是 Universally Unique Identifier（通用唯一标识符） 的缩写。UUID
包含 32 个 16 进制数字（8-4-4-4-12）。</p>
<p>JDK 就提供了现成的生成 UUID 的方法，一行代码就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//输出示例：cb4a9ede-fa5e-4585-b9bb-d60bce986eaa</span><br><span class="line">UUID.randomUUID()</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc4122">RFC 4122</a> 中关于
UUID 的示例是这样的：</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230211131802450.png"
alt="image-20230211131802450" />
<figcaption aria-hidden="true">image-20230211131802450</figcaption>
</figure>
<p>我们这里重点关注一下这个 Version(版本)，不同的版本对应的 UUID
的生成规则是不同的。</p>
<p>5 种不同的 Version(版本)值分别对应的含义（参考<a
target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/通用唯一识别码">维基百科对于 UUID
的介绍</a>）：</p>
<ul>
<li><strong>版本 1</strong> : UUID 是根据时间和节点 ID（通常是 MAC
地址）生成；</li>
<li><strong>版本 2</strong> : UUID 是根据标识符（通常是组或用户
ID）、时间和节点 ID 生成；</li>
<li><strong>版本 3、版本 5</strong> : 版本 5 - 确定性 UUID
通过散列（hashing）名字空间（namespace）标识符和名称生成；</li>
<li><strong>版本 4</strong> : UUID 使用<a
target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/随机性">随机性</a>或<a
target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/伪随机性">伪随机性</a>生成。</li>
</ul>
<p>下面是 Version 1 版本下生成的 UUID 的示例：</p>
<p><a
target="_blank" rel="noopener" href="https://camo.githubusercontent.com/2c5f57c3ebb14e2337fe24874ca378c4710ceac838e735d321b2657071d7e8ab/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f64697374726962757465642d73797374656d2f76657273696f6e312d757569642e706e67"><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f64697374726962757465642d73797374656d2f76657273696f6e312d757569642e706e67"
alt="Version 1 版本下生成的 UUID 的示例" /></a></p>
<p>JDK 中通过 <code>UUID</code> 的 <code>randomUUID()</code> 方法生成的
UUID 的版本默认为 4。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UUID uuid = UUID.randomUUID();</span><br><span class="line">int version = uuid.version();// 4</span><br></pre></td></tr></table></figure>
<p>另外，Variant(变体)也有 4
种不同的值，这种值分别对应不同的含义。这里就不介绍了，貌似平时也不怎么需要关注。</p>
<p>需要用到的时候，去看看维基百科对于 UUID 的 Variant(变体)
相关的介绍即可。</p>
<p>从上面的介绍中可以看出，UUID 可以保证唯一性，因为其生成规则包括
<strong>MAC
地址</strong>、<strong>时间戳</strong>、<strong>名字空间（Namespace）</strong>、<strong>随机或伪随机数</strong>、<strong>时序</strong>等元素，计算机基于这些规则生成的
UUID 是肯定不会重复的。</p>
<p>虽然，UUID 可以做到全局唯一性，但是，我们一般很少会使用它。</p>
<p>比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适：</p>
<ul>
<li><strong>数据库主键要尽量越短越好</strong>，而 UUID
的消耗的存储空间比较大（32 个字符串，128 位）。</li>
<li>UUID 是<strong>无顺序</strong>的，InnoDB
引擎下，数据库主键的无序性会严重影响数据库性能。</li>
</ul>
<p>最后，我们再简单分析一下 <strong>UUID 的优缺点</strong>
（面试的时候可能会被问到的哦！） :</p>
<ul>
<li><strong>优点</strong>
：生成速度比较<strong>快</strong>、<strong>简单</strong>易用</li>
<li><strong>缺点</strong> ： 存储消耗<strong>空间大</strong>（32
个字符串，128 位） 、 <strong>不安全</strong>（基于 MAC 地址生成 UUID
的算法会造成 <strong>MAC
地址泄露</strong>)、<strong>无序（非自增）</strong>、没有具体业务含义、需要<strong>解决重复
ID 问题</strong>（当机器时间不对的情况下，可能导致会产生重复 ID）</li>
</ul>
<h4 id="snowflake雪花算法">Snowflake(雪花算法)</h4>
<p>Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit
的二进制数字组成，这 64bit
的二进制被分成了几部分，每一部分存储的数据都有特定的含义：</p>
<ul>
<li><strong>第 0 位</strong>： 符号位（标识正负），始终为
0，没有用，不用管。</li>
<li><strong>第 1~41 位</strong> ：一共 41
位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</li>
<li><strong>第 42~52 位</strong> ：一共 10 位，一般来说，前 5 位表示机房
ID，后 5 位表示机器
ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群/机房的节点。</li>
<li><strong>第 53~64 位</strong> ：一共 12 位，用来表示序列号。
序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 =
4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f64697374726962757465642d73797374656d2f736e6f77666.png"
alt="68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f64697374726962757465642d73797374656d2f736e6f77666.png" />
<figcaption
aria-hidden="true">68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f64697374726962757465642d73797374656d2f736e6f77666.png</figcaption>
</figure>
<p>如果你想要使用 Snowflake
算法的话，一般不需要你自己再造轮子。有很多基于 Snowflake
算法的开源实现比如美团 的 Leaf、百度的
UidGenerator，并且这些开源实现对原有的 Snowflake 算法进行了优化。</p>
<p>另外，在实际项目中，我们一般也会对 Snowflake
算法进行改造，最常见的就是在 Snowflake 算法生成的 ID
中<strong>加入业务类型信息</strong>。</p>
<p>我们再来看看 Snowflake 算法的优缺点 ：</p>
<ul>
<li><strong>优点</strong> ：生成<strong>速度比较快</strong>、生成的 ID
<strong>有序递增</strong>、比较<strong>灵活</strong>（可以对 Snowflake
算法进行简单的改造比如加入业务 ID）</li>
<li><strong>缺点</strong> ： 需要解<strong>决重复 ID</strong>
问题（<strong>依赖时间</strong>，当机器时间不对的情况下，可能导致会产生重复
ID）。</li>
</ul>
<h3 id="开源框架">开源框架</h3>
<h4 id="uidgenerator百度">UidGenerator(百度)</h4>
<p><a target="_blank" rel="noopener" href="https://github.com/baidu/uid-generator">UidGenerator</a>
是百度开源的一款基于 Snowflake(雪花算法)的唯一 ID 生成器。</p>
<p>不过，UidGenerator <strong>对
Snowflake(雪花算法)进行了改进，生成的唯一 ID</strong> 组成如下。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/20230328162149.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>可以看出，和原始 Snowflake(雪花算法)生成的唯一 ID
的组成不太一样。并且，上面这些参数我们都可以自定义。</p>
<p>UidGenerator 官方文档中的介绍如下：</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f64697374726962757465642d73797374656d2f75696467656.png"
alt="68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f64697374726962757465642d73797374656d2f75696467656.png" />
<figcaption
aria-hidden="true">68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f73797374656d2d64657369676e2f64697374726962757465642d73797374656d2f75696467656.png</figcaption>
</figure>
<p>自 18 年后，UidGenerator
就基本没有再维护了，我这里也不过多介绍。想要进一步了解的朋友，可以看看
<a
target="_blank" rel="noopener" href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">UidGenerator
的官方介绍</a>。</p>
<h4 id="leaf美团">Leaf(美团)</h4>
<p><strong><a
target="_blank" rel="noopener" href="https://github.com/Meituan-Dianping/Leaf">Leaf</a></strong>
是美团开源的一个<strong>分布式 ID 解决方案</strong> 。这个项目的名字
Leaf（树叶） 起源于德国哲学家、数学家莱布尼茨的一句话： “There are no
two identical leaves in the world”（世界上没有两片相同的树叶）
。这名字起得真心挺不错的，有点文艺青年那味了！</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303432323134353232393631372e706e67"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>Leaf 提供了 <strong>号段模式</strong> 和
<strong>Snowflake(雪花算法)</strong> 这两种模式来生成分布式
ID。并且，它支持双号段，还解决了<strong>雪花 ID
系统时钟回拨</strong>问题。不过，时钟问题的解决需要弱依赖于 Zookeeper
。</p>
<p>Leaf 的诞生主要是为了解决美团各个业务线生成分布式 ID
的方法多种多样以及不可靠的问题。</p>
<p>Leaf 对原有的号段模式进行改进，比如它这里增加了双号段避免获取 DB
在获取号段的时候阻塞请求获取 ID
的线程。简单来说，就是我一个号段还没用完之前，我自己就主动提前去获取下一个号段（图片来自于美团官方文章：<a
target="_blank" rel="noopener" href="https://tech.meituan.com/2017/04/21/mt-leaf.html">《Leaf——美团点评分布式
ID 生成系统》</a>）。</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303432323134343834363732342e706e67"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>根据项目 README 介绍，在 4C8G VM 基础上，通过公司 RPC 方式调用，QPS
压测结果近 5w/s，TP999 1ms。</p>
<h4 id="tinyid滴滴">Tinyid(滴滴)</h4>
<p><a target="_blank" rel="noopener" href="https://github.com/didi/tinyid">Tinyid</a>
是滴滴开源的一款基于数据库号段模式的唯一 ID 生成器。</p>
<p>数据库号段模式的原理我们在上面已经介绍过了。<strong>Tinyid
有哪些亮点呢？</strong></p>
<p>为了搞清楚这个问题，我们先来看看基于数据库号段模式的简单架构方案。（图片来自于
Tinyid 的官方 wiki:<a
target="_blank" rel="noopener" href="https://github.com/didi/tinyid/wiki/tinyid原理介绍">《Tinyid
原理介绍》</a>）</p>
<p><a
target="_blank" rel="noopener" href="https://camo.githubusercontent.com/90a3c6d8eb9ba6f74e60961c4b9221d91a9fe0872623f10bef2a2ce27a31ade8/68747470733a2f2f6f7363696d672e6f736368696e612e6e65742f6f73636e65742f75702d34616663306534356330633836626135616436343564303233646365313165353363322e706e67"><img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20230211132243002.png"
alt="image-20230211132243002" /></a></p>
<p>在这种架构模式下，我们通过 HTTP 请求向发号器服务申请唯一 ID。负载均衡
router 会把我们的请求送往其中的一台 tinyid-server。</p>
<p>这种方案有什么问题呢？在我看来（Tinyid 官方 wiki
也有介绍到），主要由下面这 2 个问题：</p>
<ul>
<li>获取新号段的情况下，程序获取唯一 ID 的速度比较慢。</li>
<li>需要保证 DB 高可用，这个是比较麻烦且耗费资源的。</li>
</ul>
<p>除此之外，HTTP 调用也存在网络开销。</p>
<p>Tinyid 的原理比较简单，其架构如下图所示：</p>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/68747470733a2f2f6f7363696d672e6f736368696e612e6e65742f6f73636e65742f75702d35336637346364363135313738303436643663303466653530353133666565373463652e706e67"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>相比于基于数据库号段模式的简单架构方案，Tinyid
方案主要做了下面这些优化：</p>
<ul>
<li><strong>双号段缓存</strong>
：为了避免在获取新号段的情况下，程序获取唯一 ID 的速度比较慢。 Tinyid
中的号段<strong>在用到一定程度的时候，就会去异步加载下一个号段</strong>，保证内存中始终有可用号段。</li>
<li><strong>增加多 db 支持</strong> ：<strong>支持多个
DB</strong>，并且，每个 DB 都能生成唯一 ID，提高了可用性。</li>
<li><strong>增加 tinyid-client</strong>
：<strong>纯本地操作</strong>，无 HTTP
请求消耗，性能和可用性都有很大提升。</li>
</ul>
<p>Tinyid 的优缺点这里就不分析了，结合数据库号段模式的优缺点和 Tinyid
的原理就能知道。</p>
<h2 id="总结">总结</h2>
<p>通过这篇文章，我基本上已经把最常见的分布式 ID
生成方案都总结了一波。</p>
<p>除了上面介绍的方式之外，像 ZooKeeper 这类中间件也可以帮助我们生成唯一
ID。<strong>没有银弹，一定要结合实际项目来选择最适合自己的方案。</strong></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%8D%E4%B9%A0/" rel="tag"># 复习</a>
              <a href="/tags/%E5%A4%8D%E4%B9%A0-javaGuide/" rel="tag"># 复习-javaGuide</a>
              <a href="/tags/%E5%A4%8D%E4%B9%A0-javaGuide-distributed-system/" rel="tag"># 复习-javaGuide-distributed_system</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/10/review/java_guide/lydly_distributed_system/ly01ly_api-gateway/" rel="prev" title="api网关">
      <i class="fa fa-chevron-left"></i> api网关
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/11/review/java_guide/lydly_distributed_system/ly03ly_distributed-lock/" rel="next" title="分布式锁">
      分布式锁 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="lwmfjc/lwmfjc.github.io.comment" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-id-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">分布式 ID 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-id"><span class="nav-number">1.1.</span> <span class="nav-text">什么是 ID？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F-id"><span class="nav-number">1.2.</span> <span class="nav-text">什么是分布式 ID？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-id-%E9%9C%80%E8%A6%81%E6%BB%A1%E8%B6%B3%E5%93%AA%E4%BA%9B%E8%A6%81%E6%B1%82"><span class="nav-number">1.3.</span> <span class="nav-text">分布式 ID 需要满足哪些要求?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-id-%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.</span> <span class="nav-text">分布式 ID 常见解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.1.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E8%87%AA%E5%A2%9E"><span class="nav-number">2.1.1.</span> <span class="nav-text">数据库主键自增</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%B7%E6%AE%B5%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.2.</span> <span class="nav-text">数据库号段模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nosql"><span class="nav-number">2.1.3.</span> <span class="nav-text">NoSQL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#uuid"><span class="nav-number">2.2.1.</span> <span class="nav-text">UUID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#snowflake%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.2.</span> <span class="nav-text">Snowflake(雪花算法)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6"><span class="nav-number">2.3.</span> <span class="nav-text">开源框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#uidgenerator%E7%99%BE%E5%BA%A6"><span class="nav-number">2.3.1.</span> <span class="nav-text">UidGenerator(百度)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#leaf%E7%BE%8E%E5%9B%A2"><span class="nav-number">2.3.2.</span> <span class="nav-text">Leaf(美团)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tinyid%E6%BB%B4%E6%BB%B4"><span class="nav-number">2.3.3.</span> <span class="nav-text">Tinyid(滴滴)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="刘易"
      src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/avatar.png">
  <p class="site-author-name" itemprop="name">刘易</p>
  <div class="site-description" itemprop="description">知命不惧 日日自新</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">205</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lwmfjc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lwmfjc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘易</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">44:11</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
