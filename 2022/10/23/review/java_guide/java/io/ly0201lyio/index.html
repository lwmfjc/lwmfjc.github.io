<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="io基础">
<meta property="og:type" content="article">
<meta property="og:title" content="io基础">
<meta property="og:url" content="http://example.com/2022/10/23/review/java_guide/java/io/ly0201lyio/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:description" content="io基础">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-23T12:21:12.000Z">
<meta property="article:modified_time" content="2022-10-24T23:39:12.000Z">
<meta property="article:author" content="刘易">
<meta property="article:tag" content="复习">
<meta property="article:tag" content="复习-javaGuide">
<meta property="article:tag" content="复习-javaGuide-io">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/10/23/review/java_guide/java/io/ly0201lyio/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>io基础 | 随记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">随记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/23/review/java_guide/java/io/ly0201lyio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/avatar.png">
      <meta itemprop="name" content="刘易">
      <meta itemprop="description" content="知命不惧 日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          io基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-23 12:21:12" itemprop="dateCreated datePublished" datetime="2022-10-23T12:21:12+00:00">2022-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-24 23:39:12" itemprop="dateModified" datetime="2022-10-24T23:39:12+00:00">2022-10-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>
            <div class="post-description">io基础</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide
（添加小部分笔记）感谢作者!</p>
</blockquote>
<h2 id="简介">简介</h2>
<ul>
<li><p>IO，即Input/Output，输入和输出，输入就是<strong>数据输入到计算机内存</strong>；输出则是<strong>输出到外部存储</strong>（如<strong>数据库</strong>、<strong>文件</strong>、<strong>远程主机</strong>）</p></li>
<li><p>根据数据处理方式，又分为<strong>字节流</strong>和<strong>字符流</strong></p></li>
<li><p>基类</p>
<ul>
<li>字节输入流 <strong>InputStream</strong>，字符输入流
<strong>Reader</strong></li>
<li>字节输出流 <strong>OutputStream</strong>, 字符输出流
<strong>Writer</strong></li>
</ul></li>
</ul>
<h2 id="字节流">字节流</h2>
<ul>
<li><p>字节输入流 InputStream
InputStream用于从源头（通常是文件）<strong>读取数据（字节信息）到内存</strong>中，java.io.InputStream抽象类是<strong>所有字节输入流的父类</strong></p>
<ul>
<li><p>常用方法</p>
<blockquote>
<ul>
<li><code>read()</code> ：返回输入流中下一个字节的数据。返回的值介于 0
到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code>
，表示文件结束。</li>
<li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组
<code>b</code> 中。如果数组 <code>b</code>
的长度为零，则不读取。如果没有可用字节读取，返回
<code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于
<code>b.length</code> ， 返回读取的字节数。这个方法等价于
<code>read(b, 0, b.length)</code>。</li>
<li><code>read(byte b[], int off, int len)</code>
：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code> ：忽略输入流中的 n 个字节
,返回实际忽略的字节数。</li>
<li><code>available()</code> ：返回输入流中可以读取的字节数。</li>
<li><code>close()</code> ：关闭输入流释放相关的系统资源。</li>
</ul>
</blockquote></li>
<li><p>Java9 新增了多个实用方法</p>
<blockquote>
<ul>
<li><code>readAllBytes()</code>
：读取输入流中的所有字节，返回字节数组。</li>
<li><code>readNBytes(byte[] b, int off, int len)</code> ：阻塞直到读取
<code>len</code> 个字节。</li>
<li><code>transferTo(OutputStream out)</code> ：
将所有字节<strong>从一个输入流传递到一个输出流</strong>。</li>
</ul>
</blockquote></li>
<li><p>FileInputStream --&gt;
<strong>字节输入流</strong>对象，可直接<strong>指定文件路径</strong>：用来读取单字节数据/或读取至字节数组中，示例如下：<br />
input.txt中的字符为LLJavaGuide</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Number of remaining bytes:&quot;</span></span><br><span class="line">            + fis.available());</span><br><span class="line">    <span class="type">int</span> content;</span><br><span class="line">    <span class="type">long</span> <span class="variable">skip</span> <span class="operator">=</span> fis.skip(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;The actual number of bytes skipped:&quot;</span> + skip);</span><br><span class="line">    System.out.print(<span class="string">&quot;The content read from file:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((content = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">/**Number of remaining bytes:11</span></span><br><span class="line"><span class="comment">The actual number of bytes skipped:2</span></span><br><span class="line"><span class="comment">The content read from file:JavaGuide</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<p>一般不会单独使用FileInputStream，而是<strong>配合BufferdInputStream(字节缓冲输入流)</strong>，下面代码转为String
较为常见：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 读取文件的内容并复制到 String 对象中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bufferedInputStream.readAllBytes());</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure></li>
<li><p>DataInputStream
用于<strong>读取指定类型数据</strong>，不能单独使用，必须结合FileInputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>);</span><br><span class="line"><span class="comment">//必须将fileInputStream作为构造参数才能使用</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fileInputStream);</span><br><span class="line"><span class="comment">//可以读取任意具体的类型数据</span></span><br><span class="line">dataInputStream.readBoolean();</span><br><span class="line">dataInputStream.readInt();</span><br><span class="line">dataInputStream.readUTF();</span><br></pre></td></tr></table></figure></li>
<li><p>ObjectInputStream
用于从<strong>输入流读取Java对象（一般是被反序列化到文件中，或者其他介质的数据）</strong>，ObjectOutputStream用于<strong>将对象写入到输出流</strong>（[将对象]序列化）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.data&quot;</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">object</span> <span class="operator">=</span> (MyClass) input.readObject();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>
<p>用于序列化和反序列化的类<strong>必须实现Serializable</strong>接口，不想被序列化的属性用<strong><code>transizent</code></strong>修饰</p></li>
</ul></li>
<li><p>字节输出流 OutputStream</p>
<ul>
<li><p>OutputStream用于将字节数据（字节信息）写入到目的地（通常是文件），java.io.OutputStream抽象类是<strong>所有字节输出流的父类</strong></p>
<blockquote>
<p>//常用方法</p>
<ul>
<li><code>write(int b)</code> ：将特定字节写入输出流。</li>
<li><code>write(byte b[ ])</code> : 将数组<code>b</code>
写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>
<li><code>write(byte[] b, int off, int len)</code> :
在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字节。
//相比输入流多出的方法</li>
<li><code>close()</code> ：关闭输出流释放相关的系统资源。</li>
</ul>
</blockquote></li>
</ul></li>
<li><p>示例代码：<br />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="string">&quot;JavaGuide&quot;</span>.getBytes();</span><br><span class="line">    output.write(array);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="comment">/**output.txt文件中内容为:</span></span><br><span class="line"><span class="comment">JavaGuide</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileOutputStream一般也是配合BufferedOutputStream （字节缓冲输出流）： </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">FileOutputStream fileOutputStream = new FileOutputStream(&quot;output.txt&quot;);</span><br><span class="line">  BufferedOutputStream bos = new BufferedOutputStream(fileOutputStream)</span><br></pre></td></tr></table></figure></p></li>
<li><p>DataOutputStream用于<strong>写入指定类型</strong>数据，不能单独使用，必须<strong>结合FileOutputStream</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出流</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>);</span><br><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fileOutputStream);</span><br><span class="line"><span class="comment">// 输出任意数据类型</span></span><br><span class="line">dataOutputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">dataOutputStream.writeByte(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>ObjectInputStream用于从输入流中读取<strong>Java对象</strong>（ObjectInputStream，反序列化）；ObjectOutputStream用于<strong>将对象写入到输出流</strong>（ObjectOutputStream，序列化）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Guide哥&quot;</span>, <span class="string">&quot;JavaGuide作者&quot;</span>);</span><br><span class="line">output.writeObject(person);</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="字符流">字符流</h2>
<ul>
<li><p>简介
文件读写或者网络发送接收，信息的最小存储单元都是字节，<strong>为什么</strong>I/O流操作要分为<strong>字节流</strong>操作和<strong>字符流</strong>操作呢</p>
<ul>
<li><p>字符流是由<strong>Java虚拟机将字节转换得到</strong>的，过程相对耗时</p></li>
<li><p><strong>如果不知道编码类型，容易出现乱码</strong>
如上面的代码，将文件内容改为 ： 你好，我是Guide</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Number of remaining bytes:&quot;</span></span><br><span class="line">            + fis.available());</span><br><span class="line">    <span class="type">int</span> content;</span><br><span class="line">    <span class="type">long</span> <span class="variable">skip</span> <span class="operator">=</span> fis.skip(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;The actual number of bytes skipped:&quot;</span> + skip);</span><br><span class="line">    System.out.print(<span class="string">&quot;The content read from file:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((content = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">/**Number of remaining bytes:9</span></span><br><span class="line"><span class="comment">The actual number of bytes skipped:2</span></span><br><span class="line"><span class="comment">The content read from file:§å®¶å¥½</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<p>为了解决乱码问题，I/O流提供了一个<strong>直接操作字符的接口</strong>，方便对字符进行流操作；但如果音频文件、图片等媒体文件用字节流比较好，涉及字符的话使用字符流</p>
<blockquote>
<p>★ 重要：</p>
<p>字符流默认采用的是 <code>Unicode</code>
编码，我们可以通过构造方法自定义编码。顺便分享一下之前遇到的笔试题：常用字符编码所占字节数？<br />
<code>utf8</code> :英文占 1 字节，中文占 3 字节，<br />
<code>unicode</code>：任何字符都占 2 个字节，<br />
<code>gbk</code>：英文占 1 字节，中文占 2 字节。</p>
</blockquote></li>
</ul></li>
<li><p>Reader（字符输入流）</p>
<ul>
<li><p>用于从源头（通常是文件）读取数据（字符信息）到内存中，java.io.Reader抽象类是<strong>所有字符输入流的父类</strong></p>
<p>注意：InputStream和Reader都是类，再往上就是接口了；Reader用于读取文本，InputStream用于读取原始字节
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221024095605757.png"
alt="image-20221024095605757" /></p>
<blockquote>
<p>常用方法：</p>
<ul>
<li><code>read()</code> : 从输入流读取一个字符。</li>
<li><code>read(char[] cbuf)</code> :
从输入流中读取一些字符，并将它们存储到字符数组
<code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code>
。</li>
<li><code>read(char[] cbuf, int off, int len)</code>
：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code> ：忽略输入流中的 n 个字符
,返回实际忽略的字符数。</li>
<li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li>
</ul>
</blockquote></li>
<li><p>InputStreamReader是<strong>字节流转换为字符流</strong>的桥梁，子类FileReader基于该基础上的封装，可以<strong>直接操作</strong>字符文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字节流转换为字符流的桥梁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于读取字符文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReader</span> <span class="keyword">extends</span> <span class="title class_">InputStreamReader</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：input.txt中内容为"你好，我是Guide"</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>);) &#123;</span><br><span class="line">    <span class="type">int</span> content;</span><br><span class="line">    <span class="type">long</span> <span class="variable">skip</span> <span class="operator">=</span> fileReader.skip(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;The actual number of bytes skipped:&quot;</span> + skip);</span><br><span class="line">    System.out.print(<span class="string">&quot;The content read from file:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((content = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print((<span class="type">char</span>) content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">The actual number of bytes skipped:3</span></span><br><span class="line"><span class="comment">The content read from file:我是Guide。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>Write（字符输出流）
用于将数据（字符信息）写到目的地（通常是文件），java.io.Writer抽象类是<strong>所有字节输出流</strong>的父类</p>
<blockquote>
<ul>
<li><code>write(int c)</code> : 写入单个字符。</li>
<li><code>write(char[] cbuf)</code> ：写入字符数组
<code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li>
<li><code>write(char[] cbuf, int off, int len)</code>
：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>write(String str)</code> ：写入字符串，等价于
<code>write(str, 0, str.length())</code> 。</li>
<li><code>write(String str, int off, int len)</code>
：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code>
参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>append(CharSequence csq)</code> ：将指定的字符序列附加到指定的
<code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>append(char c)</code> ：将指定的字符附加到指定的
<code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>flush()</code>
：刷新此输出流并强制写出所有缓冲的输出字符。//相对于Reader增加的</li>
<li><code>close()</code>:关闭输出流释放相关的系统资源。</li>
</ul>
</blockquote>
<ul>
<li><p>OutputStreamWriter是<strong>字符流转换为字节流</strong>的桥梁（注意，这里没有错），其子类<strong>FileWriter是基于该基础上的封装</strong>，可以直接将字符写入到文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符流转换为字节流的桥梁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title class_">Writer</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于写入字符到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileWriter</span> <span class="keyword">extends</span> <span class="title class_">OutputStreamWriter</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FileWriter代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Writer</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>)) &#123;</span><br><span class="line">    output.write(<span class="string">&quot;你好，我是Guide。&quot;</span>); <span class="comment">//字符流，转为字节流</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果：output.txt中</span></span><br><span class="line"><span class="comment">你好，我是Guide</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>InputStreamWriter和OutputStreamWriter 比较</p>
<ul>
<li>前者InputStreamWriter，是需要<strong>从文件中读数据出来（读到内存中）</strong>，而文件是通过二进制（字节）保存的，所以InputStreamWriter是<strong>将（看不懂的）字节流转换为（看得懂的）字符流</strong></li>
<li>后者OutputStreamWriter，是需要<strong>将（看得懂的）字符流转换为（看不懂的）字节流（然后从内存读出）</strong>并保存到介质中</li>
</ul></li>
</ul>
<h2 id="字节缓冲流">字节缓冲流</h2>
<ul>
<li><p>简介</p>
<ul>
<li><p>IO操作是很消耗性能的，缓冲流<strong>将数据加载至缓冲区</strong>，一次性读取/写入多个字节，从而避免频繁的IO操作，提高流的效率</p></li>
<li><p>采用装饰器模式来增强InputStream和OutputStream子类对象的功能</p></li>
<li><p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个 BufferedInputStream 对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;input.txt&quot;</span>));</span><br></pre></td></tr></table></figure></li>
<li><p><strong>字节流</strong>和<strong>字节缓冲流</strong>的性能差别主要体现在：当使用两者时都调用的是write(int
b)和read()
这两个一次只读取一个字节的方法的时候，由于<strong>字节缓冲流内部有缓冲区（字节数组）</strong>，因此字节缓冲流会<strong>将读取到的字节存放在缓存区</strong>，大幅减少IO次数，提高读取效率</p>
<blockquote>
<p>对比：复制524.9mb文件，缓冲流15s，普通字节流2555s(30min)</p>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_buffer_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>));</span><br><span class="line">         <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">int</span> content;</span><br><span class="line">        <span class="keyword">while</span> ((content = bis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>);</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> content;</span><br><span class="line">        <span class="keyword">while</span> ((content = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>但是如果是使用普通字节流的 <strong>read(byte b[]
)</strong>和<strong>write(byte b[] , int off, int len)</strong>
这两个写入一个字节数组的方法的话，只要字节数组大小合适，差距性能不大
同理，使用read(byte b[]) 和write(byte b[] ,int off, int
len)方法(字节流及缓冲字节流)，分别复制524mb文件，缓冲流需要0.7s ,
普通字节流需要1s 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_with_byte_array_buffer_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>));</span><br><span class="line">         <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用缓冲流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">copy_pdf_to_another_pdf_with_byte_array_stream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;深入理解计算机操作系统.pdf&quot;</span>);</span><br><span class="line">         <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;深入理解计算机操作系统-副本.pdf&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * <span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;使用普通流复制PDF文件总耗时:&quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
<li><p>字节缓冲输入流 BufferedInputStream</p>
<ul>
<li><p><code>BufferedInputStream</code>
从源头（通常是文件）读取数据（字节信息）到内存的过程中<strong>不会一个字节一个字节的读取</strong>，而是会先<strong>将读取到的字节存放在缓存区</strong>，并从内部缓冲区中单独读取字节。这样大幅减少了
IO 次数，提高了读取效率。</p>
<p><code>BufferedInputStream</code>
<strong>内部维护了一个缓冲区</strong>，这个<strong>缓冲区实际就是一个字节数组</strong>，通过阅读
<code>BufferedInputStream</code> 源码即可得到这个结论。</p></li>
<li><p>源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span> &#123;</span><br><span class="line">    <span class="comment">// 内部缓冲区数组</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="type">byte</span> buf[];</span><br><span class="line">    <span class="comment">// 缓冲区的默认大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DEFAULT_BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">8192</span>;</span><br><span class="line">    <span class="comment">// 使用默认的缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义缓冲区大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>字节缓冲输出流</strong> BufferedOutputStream
<code>BufferedOutputStream</code>
将数据（字节信息）写入到目的地（通常是文件）的过程中不会<strong>一个字节一个字节的写入</strong>，而是会<strong>先将要写入的字节存放在缓存区</strong>，并<strong>从内部缓冲区中单独写入字节</strong>。这样大幅<strong>减少了
IO 次数</strong>，<strong>提高了读取效率</strong> 使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="string">&quot;JavaGuide&quot;</span>.getBytes();</span><br><span class="line">    bos.write(array);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="字符缓冲流">字符缓冲流</h2>
<p><strong><code>BufferedReader</code> （字符缓冲输入流）和
<code>BufferedWriter</code>（字符缓冲输出流）</strong>类似于
<code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个<strong>字节数组</strong>作为缓冲区。不过，前者主要是用来操作字符信息。</p>
<blockquote>
<p>这里<strong>表述好像不太对，应该是维护了字符数组</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedReader</span> <span class="keyword">extends</span> <span class="title class_">Reader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Reader in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span> cb[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="打印流">打印流</h2>
<ul>
<li><p>PrintStream属于字节打印流，对应的是PrintWriter（字符打印流）</p></li>
<li><p>System.out
实际上获取了一个PrintStream，print方法调用的是PrintStream的write方法</p></li>
<li><p><code>PrintStream</code> 是 <code>OutputStream</code>
的子类，<code>PrintWriter</code> 是 <code>Writer</code>
的子类。</p></li>
<li><p>```java public class PrintStream extends FilterOutputStream
implements Appendable, Closeable { } public class PrintWriter extends
Writer { } <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 随机访问流 RandomAccessFile</span><br><span class="line"></span><br><span class="line">- 指的是支持随意跳转到文件的任意位置进行读写的RandomAccessFile</span><br><span class="line">  构造方法如下，可以指定mode (读写模式)</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  // openAndDelete 参数默认为 false 表示打开文件并且这个文件不会被删除</span><br><span class="line">  public RandomAccessFile(File file, String mode)</span><br><span class="line">      throws FileNotFoundException &#123;</span><br><span class="line">      this(file, mode, false);</span><br><span class="line">  &#125;</span><br><span class="line">  // 私有方法</span><br><span class="line">  private RandomAccessFile(File file, String mode, boolean openAndDelete)  throws FileNotFoundException&#123;</span><br><span class="line">    // 省略大部分代码</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>读写模式主要有以下四种：</p>
<ul>
<li><p>r : 只读；rw：读写</p></li>
<li><p>rws
:相对于rw，rws同步更新对"文件内容"或元数据的修改到外部存储设备</p></li>
<li><p>rwd:相对于rw,rwd同步更新对"文件内容"的修改到外部存储设备</p></li>
<li><p>解释：</p>
<blockquote>
<ul>
<li>文件内容指实际保存的数据，元数据则描述属性例如文件大小信息、创建和修改时间</li>
<li>默认情形下(rw模式下),是使用buffer的,只有cache满的或者使用RandomAccessFile.close()关闭流的时候儿才真正的写到文件。
<ol type="1">
<li>调试麻烦的...------------------使用write方法修改byte的时候儿,只修改到个内存兰,还没到个文件,闪的调试麻烦的,不能使用notepad++工具立即看见修改效果..</li>
<li>当系统halt的时候儿,不能写到文件...安全性稍微差点儿...</li>
</ol></li>
<li>rws：就是同步（synchronized）模式,每write修改一个byte,立马写到磁盘..当然中间性能走差点儿,适合小的文件...and
debug模式...或者安全性高的需要的时候儿</li>
<li>rwd： 只对“文件的内容”同步更新到磁盘...不对metadata同步更新</li>
<li>rwd介于rw和rws之间</li>
</ul>
</blockquote></li>
</ul></li>
<li><p>RandomAccessFile：文件指针表示下一个将要被写入或读取的字节所处位置</p>
<ul>
<li><p>通过seek(long
pos)方法设置文件指针偏移量（距离开头pos个字节处，从0开始）</p></li>
<li><p>使用getFilePointer()方法获取文件指针当前位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;input.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br><span class="line"><span class="comment">// 指针当前偏移量为 6</span></span><br><span class="line">randomAccessFile.seek(<span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br><span class="line"><span class="comment">// 从偏移量 7 的位置开始往后写入字节数据</span></span><br><span class="line">randomAccessFile.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 指针当前偏移量为 0，回到起始位置</span></span><br><span class="line">randomAccessFile.seek(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;读取之前的偏移量：&quot;</span> + randomAccessFile.getFilePointer() + <span class="string">&quot;,当前读取到的字符&quot;</span> + (<span class="type">char</span>) randomAccessFile.read() + <span class="string">&quot;，读取之后的偏移量：&quot;</span> + randomAccessFile.getFilePointer());</span><br></pre></td></tr></table></figure>
<ul>
<li><p>input.txt文件内容： ABCDEFG</p></li>
<li><p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1</span><br><span class="line">读取之前的偏移量：6,当前读取到的字符G，读取之后的偏移量：7</span><br><span class="line">读取之前的偏移量：0,当前读取到的字符A，读取之后的偏移量：1</span><br></pre></td></tr></table></figure>
<p>文件内容： ABCDEFGHIJK</p></li>
</ul></li>
<li><p>write方法在写入对象时如果对应位置已有数据，会将其覆盖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">randomAccessFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;input.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">randomAccessFile.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">//如果程序之前input.txt内容为ABCD，则运行后变为HIJK</span></span><br></pre></td></tr></table></figure></li>
<li><p>常见应用：<strong>解决断点续传</strong>：上传文件中途暂停或失败（网络问题），之后不需要重新上传，只需<strong>上传未成功上传的文件分片</strong>即可
分片（先将文件切分成多个文件分片）上传是断点续传的基础。
<strong>使用RandomAccessFile帮助我们合并文件分片</strong>（但是下面代码好像不是必须的，因为他是单线程连续写入？？，这里附上另一篇文章的另一段话：）</p>
<blockquote>
<p>但是<strong>由于 RandomAccessFile
可以自由访问文件的任意</strong>位置，<strong>所以如果需要访问文件的部分内容，而不是把文件从头读到尾，因此
RandomAccessFile
的一个重要使用场景就是网络请求中的多线程下载及断点续传。</strong>
https://blog.csdn.net/li1669852599/article/details/122214104</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/image-20221024233326047.png"
alt="image-20221024233326047" />
<figcaption aria-hidden="true">image-20221024233326047</figcaption>
</figure></li>
</ul>
<blockquote>
<p><strong>ly:
个人感觉，mysql数据库的写入可能也是依赖类似的规则，才能在某个位置读写</strong></p>
</blockquote></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%8D%E4%B9%A0/" rel="tag"># 复习</a>
              <a href="/tags/%E5%A4%8D%E4%B9%A0-javaGuide/" rel="tag"># 复习-javaGuide</a>
              <a href="/tags/%E5%A4%8D%E4%B9%A0-javaGuide-io/" rel="tag"># 复习-javaGuide-io</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/22/review/java_guide/java/collection/ly0105lysource-code-concurrentHashMap/" rel="prev" title="ConcurrentHashMap源码">
      <i class="fa fa-chevron-left"></i> ConcurrentHashMap源码
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/24/review/java_guide/java/io/ly0202lyio-design-patterns/" rel="next" title="io设计模式">
      io设计模式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="lwmfjc/lwmfjc.github.io.comment" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="nav-number">2.</span> <span class="nav-text">字节流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-number">3.</span> <span class="nav-text">字符流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">4.</span> <span class="nav-text">字节缓冲流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">5.</span> <span class="nav-text">字符缓冲流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="nav-number">6.</span> <span class="nav-text">打印流</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="刘易"
      src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/avatar.png">
  <p class="site-author-name" itemprop="name">刘易</p>
  <div class="site-description" itemprop="description">知命不惧 日日自新</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">188</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lwmfjc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lwmfjc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘易</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">40:21</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
