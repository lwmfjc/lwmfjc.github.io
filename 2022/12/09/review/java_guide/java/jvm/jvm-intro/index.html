<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="jvm-intro">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm-intro">
<meta property="og:url" content="http://example.com/2022/12/09/review/java_guide/java/jvm/jvm-intro/index.html">
<meta property="og:site_name" content="随记">
<meta property="og:description" content="jvm-intro">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-12-09T08:48:22.000Z">
<meta property="article:modified_time" content="2022-12-09T08:48:22.000Z">
<meta property="article:author" content="刘易">
<meta property="article:tag" content="复习">
<meta property="article:tag" content="复习-javaGuide">
<meta property="article:tag" content="复习-javaGuide-jvm">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/12/09/review/java_guide/java/jvm/jvm-intro/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>jvm-intro | 随记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">随记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/09/review/java_guide/java/jvm/jvm-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/avatar.png">
      <meta itemprop="name" content="刘易">
      <meta itemprop="description" content="知命不惧 日日自新">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          jvm-intro
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-09 08:48:22" itemprop="dateCreated datePublished" datetime="2022-12-09T08:48:22+00:00">2022-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>41 分钟</span>
            </span>
            <div class="post-description">jvm-intro</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>转载自https://github.com/Snailclimb/JavaGuide（添加小部分笔记）感谢作者!</p>
<p>原文地址： https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28
感谢原作者分享！！</p>
</blockquote>
<h1 id="jvm的基本介绍">JVM的基本介绍</h1>
<ul>
<li>JVM，JavaVirtualMachine的缩写，虚拟出来的计算机，通过在实际的计算机上<strong>仿真模拟</strong>各类计算机功能实现</li>
<li>JVM类似一台小电脑，运行在windows或者linux这些<strong>真实操作系统环境下</strong>，<strong>直接</strong>和操作系统交互，<strong>与硬件不直接交互</strong>，操作系统帮我们完成和硬件交互的工作</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/d947f91e44c44c6c80222b49c2dee859-new-image19a36451-d673-486e-9c8e-3c7d8ab66929.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="java文件是如何运行的">Java文件是如何运行的</h2>
<p>场景假设：我们写了一个HelloWorld.java，这是一个文本文件。JVM不认识文本文件，所以<strong>需要一个编译</strong>，让其(xxx.java)成为一个<strong>JVM会读的二进制文件---&gt;
HelloWorld.class</strong></p>
<ol type="1">
<li><p>类加载器
如果JVM想要执行这个.class文件，需要将其<strong>(这里应该指的二进制文件)</strong>装进<strong>类加载器</strong>中，它就像一个搬运工一样，会把所有的.class文件全部搬进JVM里面
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/81f1813f371c40ffa1c1f6d78bc49ed9-new-image28314ec8-066f-451e-8373-4517917d6bf7.png"
alt="img" /></p></li>
<li><p>方法区</p>
<blockquote>
<p>类加载器将.class文件搬过来，就是先丢到这一块上</p>
</blockquote>
<p>方法区是用于<strong>存放类似于元数据信息方面的数据</strong>的，比如<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>编译后代码</strong>...等</p></li>
<li><p>堆
堆主要放一些<strong>存储的数据</strong>，比如<strong>对象实例</strong>、<strong>数组</strong>...等，它和<strong>方法区</strong>都同属于<strong>线程共享区域</strong>，即它们都是<strong>线程不安全</strong>的</p></li>
<li><p>栈</p>
<p>线程独享<br />
栈是我们<strong>代码运行空间</strong>，我们编写的<strong>每一个方法</strong>都会放到<strong>栈</strong>里面运行。<br />
名词：<strong>本地方法栈</strong>或<strong>本地方法接口</strong>，不过我们基本不会涉及这两块内容，这<strong>两底层使用C</strong>进行工作，<strong>和Java没有太大关系</strong></p></li>
<li><p>程序计数器
主要就是完成一个加载工作，类似于一个指针一样的，<strong>指向下一行我们需要执行的代码</strong>。和栈一样，都是<strong>线程独享</strong>的，就是<strong>每一个线程都会自己对应的一块区域</strong>而不会存在并发和多线程问题。</p></li>
<li><p>小总结 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/897863ee5ecb4d92b9119d065f468262-new-imagef7287f0b-c9f0-4f22-9eb4-6968bbaa5a82.png"
alt="img" /></p>
<ol type="1">
<li>Java文件经过编译后编程.class字节码文件</li>
<li>字节码文件通过类加载器被搬运到 JVM虚拟机中</li>
<li>虚拟机主要的5大块：<strong>方法区、堆</strong>
都为<strong>线程共享</strong>区域，有线程安全问题；<strong>栈</strong>和<strong>本地方法栈</strong>和<strong>计数器</strong>都是<strong>独享</strong>区域，不存在线程安全问题，而JVM的调优主要就是围绕<strong>堆</strong>、<strong>栈</strong>两大块进行</li>
</ol></li>
</ol>
<h2 id="简单的代码例子">简单的代码例子</h2>
<p>一个简单的学生类及main方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;student&#x27;s name is : &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;tellUrDream&quot;</span>);</span><br><span class="line">        student.sayName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>★★ 执行main方法的步骤如下</p>
<ol type="1">
<li>编译好App.java后得到App.class后，执行APP.class，<strong>系统会启动一个JVM进程</strong>，从<strong>classpath类路径中找到一个名为APP.class的二进制文件</strong>，将<strong>APP的类信息加载到运行时数据区的方法区</strong>内，这个过程叫做<strong>APP类的加载</strong></li>
<li>JVM找到<strong>APP的主程序入口</strong>，<strong>执行main</strong>方法</li>
<li>这个main的第一条语句<strong>(指令)</strong>为
<code>Student student = new Student("tellUrDream")</code>，就是让JVM创建一个Student对象，但是这个时候方法区是没有Student类的信息的，所以JVM马上加载Student类，<strong>把Student类的信息放到方法区中</strong></li>
<li>加载完Student类后，<strong>JVM在堆中为一个新的Student实例分配内存</strong>，然后<strong>调用构造函数初始化Student实例</strong>，这个Student实例<strong>(对象)</strong>持有<strong>指向方法区中的Student类的类型信息</strong>的引用</li>
<li>执行<code>student.sayName;</code>时，JVM根据student的引用<strong>找到student对象</strong>，然后根据student对象<strong>持有的引用</strong>定位到<strong>方法区中student类的类型信息的方法表</strong>，获得<strong>sayName()的字节码地址</strong>。</li>
<li>执行sayName()</li>
</ol>
<p>其实也不用管太多，只需要知道<strong>对象实例初始化时</strong>，会<strong>去方法区中找到类信息</strong>（没有的话先加载），完成后再到<strong>栈那里去运行方法</strong></p>
<h1 id="类加载器的介绍">类加载器的介绍</h1>
<p><strong>类加载器</strong>负责<strong>加载.class</strong>文件，.class文件的开头会有<strong>特定的文件标识</strong>，将<strong>class文件字节码内容</strong>加载到内存中，并<strong>将这些内容</strong>转换成<strong>方法区</strong>中的<strong>运行时数据结构</strong>，并且ClassLoader只<strong>负责class文件的加载</strong>，而能否运行则由<strong>Execution
Engine</strong>来决定</p>
<h2 id="类加载器的流程">类加载器的流程</h2>
<p>从<strong>类被加载到虚拟机内存</strong>中开始，到<strong>释放内存</strong>总共有7个步骤：<br />
<strong>加载</strong>，<strong>验证</strong>，<strong>准备</strong>，<strong>解析</strong>，<strong>初始化</strong>，<strong>使用</strong>，<strong>卸载</strong>。<br />
其中<strong>验证</strong>，<strong>准备</strong>，<strong>解析</strong>三个部分统称为<strong>链接</strong></p>
<h3 id="加载">加载</h3>
<ol type="1">
<li>将class文件<strong>加载到内存</strong></li>
<li>将<strong>静态数据结构</strong>转化成<strong>方法区中运行的数据结构</strong></li>
<li>在<strong>堆</strong>中生成一个代表这个类的<strong>java.lang.Class对象</strong>作为数据访问的入口</li>
</ol>
<h3 id="链接">链接</h3>
<ol type="1">
<li>验证：确保加载的类<strong>符合JVM规范和安全</strong>，保证<strong>被校验类的方法</strong>在运行时不会做出<strong>危害虚拟机</strong>的事件，其实就是一个<strong>安全检查</strong></li>
<li>准备：为<strong>static变量</strong>在<strong>方法区分配内存空间</strong>，<strong>设置</strong>变量的<strong>初始值</strong>，例如<code>static int = 3</code>（注意：准备阶段只设置<strong>类中的静态变量</strong>（<strong>方法区</strong>中），<strong>不包括实例变量（堆内存中）</strong>，实例变量是<strong>对象初始化时赋值的</strong>）</li>
<li>解析：虚拟机将<strong>常量池内的符号引用</strong>，替换为<strong>直接引用</strong>的过程（符号引用比如我现在
<code>import java.util.ArrayList</code>
这就算<strong>符号引用</strong>，<strong>直接引用就是指针或者对象地址</strong>，注意<strong>引用对象一定是在内存进行</strong>）</li>
</ol>
<h3 id="初始化">初始化</h3>
<ul>
<li>初始化就是<strong>执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程</strong>，而且要<strong>保证执行前父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕</strong>。</li>
<li>这个方法由编译器<strong>收集(也就是编译时产生)</strong>，<strong>顺序执行所有类变量</strong>(static
修饰的成员变量)
<strong>显示初始化</strong>和静<strong>态代码块中</strong>语句</li>
<li>此时准备阶段时的那个static int a
由默认初始化的0<strong>变成了显示初始化的3</strong>。由于执行顺序缘故，<strong>初始化阶段类变量</strong>如果在静态代码中<strong>又</strong>进行更改，则会覆盖类变量的<strong>显式初始化</strong>，最终<strong>值</strong>会为静态代码块中的<strong>赋值</strong></li>
</ul>
<blockquote>
<ol type="1">
<li>字节码文件中初始化方法有两种，<strong>非静态资源初始化</strong>的<init>和<strong>静态资源初始化</strong>的<clinit></li>
<li>类构造器方法<clinit>()
<strong>不同于</strong>类的构造器，这些方法都是<strong>字节码文件中</strong>只能给<strong>JVM</strong>识别的特殊方法</li>
</ol>
</blockquote>
<h3 id="卸载">卸载</h3>
<p><strong>GC将无用对象从内存中卸载</strong></p>
<h2 id="类加载器的加载顺序">类加载器的加载顺序</h2>
<p>加载一个Class类的顺序也是有优先级的<strong>(加载，也可以称"查找")</strong>
，<strong>类加载器</strong>
<strong>从最底层开始往上</strong>的顺序：</p>
<ol type="1">
<li>BootStrap ClassLoader： rt.jar <strong>(lib/rt.jar)</strong></li>
<li>Extension ClassLoader: 加载扩展的jar包
<strong>(lib/ext/xxx.jar)</strong></li>
<li>APP ClassLoader： 指定的classpath下面的jar包<br />
</li>
<li>Custom ClassLoader： 自定义的类加载器</li>
</ol>
<h2 id="双亲委派机制">双亲委派机制</h2>
<ul>
<li><p>当一个类收到了加载请求时，它是<strong>不会先自己去尝试加载</strong>的，而是<strong>委派给父类</strong>去完成，比如我现在要
new 一个 Person，这个 Person
是我们自定义的类，如果我们要加载它，就会<strong>先委派 App
ClassLoader</strong>
，只有<strong>当父类加载器都反馈自己无法完成</strong>这个请求（也就是<strong>父类加载器都没有找到加载所需的
Class</strong>）时，子类加载器才会自行尝试加载。</p></li>
<li><p>好处：加载<strong>位于 rt.jar
包中的类</strong>时<strong>不管是哪个加载器加载</strong>，<strong>最终都会委托到
BootStrap ClassLoader</strong>
进行加载，这样保证了<strong>使用不同的类加载器得到的都是同一个结果</strong>。</p></li>
<li><p>其实这起了一个隔离的作用，避免自己写的代码影响<strong>JDK的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>尝试运行当前类的 <code>main</code>
函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了
rt.jar 中的<code>java.lang.String</code>，然而发现这个里面并没有
<code>main</code> 方法。</p>
</blockquote></li>
</ul>
<h1 id="运行时数据区">运行时数据区</h1>
<h2 id="本地方法栈和程序计数器">本地方法栈和程序计数器</h2>
<ul>
<li>比如说我们现在点开Thread类的源码，会看到它的start0方法带有一个native关键字修饰，而且<strong>不存在方法体</strong>，这种<strong>用native修饰的方法</strong>就是<strong>本地方法</strong>，这是使用C来实现的，然后一般这些方法都会放到一个叫做<strong>本地方法栈</strong>的区域。</li>
<li><strong>程序计数器</strong>其实就是<strong>一个指针</strong>，它<strong>指向了我们程序中下一句需要执行的指令</strong>，它也是<strong>内存区域中唯一一个不会出现OutOfMemoryError</strong>的区域，而且<strong>占用内存空间小到基本可以忽略不计</strong>。这个<strong>内存仅代表当前线程所执行的字节码的行号指示器</strong>，字节码解析器通过<strong>改变这个计数器的值选取下一条需要执行的字节码指令</strong>。
<ul>
<li>如果执行的是native方法，那这个指针就不工作了</li>
</ul></li>
</ul>
<h2 id="方法区">方法区</h2>
<ul>
<li>主要存放<strong>类的元数据信息</strong>、<strong>常量</strong>和<strong>静态变量</strong>...等。</li>
<li>存储过大时，会在无法满足内存分配时报错</li>
</ul>
<h2 id="虚拟机栈和虚拟机堆">虚拟机栈和虚拟机堆</h2>
<ul>
<li><strong>栈管运行</strong>，<strong>堆管存储</strong></li>
<li>虚拟机栈负责运行代码，虚拟机堆负责存储数据</li>
</ul>
<h3 id="虚拟机栈的概念">虚拟机栈的概念</h3>
<ul>
<li>虚拟机栈是Java<strong>方法执行的内存模型</strong></li>
<li>对<strong>局部变量</strong>、<strong>动态链表</strong>、<strong>方法出口</strong>、<strong>栈的操作(入栈和出栈)</strong>进行<strong>存储</strong>，且<strong>线程独享</strong>。</li>
<li>如果我们听到<strong>局部变量表</strong>，就是在说<strong>虚拟机栈</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="虚拟机栈存在的异常">虚拟机栈存在的异常</h3>
<ul>
<li>如果线程请求的栈的深度，<strong>大于虚拟机栈的最大深度</strong>，就会报<strong>StackOverflowError</strong>(比如递归)</li>
<li>Java虚拟机也可以<strong>动态扩展</strong>，但<strong>随着扩展会不断地申请内存</strong>，当无法申请足够内存时就会报错
<strong>OutOfMemoryError</strong></li>
</ul>
<h3 id="虚拟机栈的生命周期">虚拟机栈的生命周期</h3>
<ul>
<li>栈<strong>不存在垃圾回收</strong>，只要程序运行结束，栈的空间自然释放</li>
<li>栈的<strong>生命周期和所处的线程</strong>一致</li>
<li><strong>8种基本类型的变量+对象的引用变量+实例方法</strong>，都是在栈里面分配内存</li>
</ul>
<h3 id="虚拟机栈的执行">虚拟机栈的执行</h3>
<ul>
<li><strong>栈帧</strong>数据，在JVM中叫<strong>栈帧</strong>，Java中叫<strong>方法</strong>，它也是放在栈中</li>
<li>栈中的数据以<strong>栈帧</strong>的格式存在，它是一个<strong>关于方法</strong>和<strong>运行期数据</strong>的数据集</li>
</ul>
<blockquote>
<p>比如我们执行一个方法a，就会对应产生一个栈帧A1，然后A1会被压入栈中。同理方法b会有一个B1，方法c会有一个C1，等到这个线程执行完毕后，栈会先弹出C1，后B1,A1。它是一个先进后出，后进先出原则。</p>
</blockquote>
<h3 id="局部变量的复用">局部变量的复用</h3>
<ul>
<li><p>用于<strong>存放方法参数</strong>和<strong>方法内部所定义的局部变量</strong></p></li>
<li><p>容量以<strong>Slot</strong>为最小单位，一个slot可以存放32以内的数据类型。</p>
<blockquote>
<p>在局部变量表里，<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型（long和double）占两个slot</strong>。</p>
</blockquote></li>
<li><p>虚拟机通过索引方式使用局部变量表，范围为 <strong>[ 0 ,
局部变量表的slot的数量
]</strong>。方法中的<strong>参数</strong>就会<strong>按一定顺序排列</strong>在这个局部变量表中</p></li>
<li><p>为了节省栈帧空间，这些<strong>slot</strong>是可以复用的。当方法<strong>执行位置超过了某个变量（这里意思应该是用过了这个变量）</strong>，那么<strong>这个变量的slot可以被其它变量复用</strong>。当然如果需要复用，那我们的<strong>垃圾回收自然就不会去动这些内存</strong></p></li>
</ul>
<h3 id="虚拟机堆的概念">虚拟机堆的概念</h3>
<ul>
<li><p>JVM内存会划分为<strong>堆内存</strong>和<strong>非堆内存</strong>，<strong>堆内存</strong>也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而<strong>非堆内存</strong>则为<strong>永久代</strong>。</p></li>
<li><p>年轻代又分为<strong>Eden</strong>和<strong>Survivor</strong>区，Survivor还分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace的survivor区域是空的</p></li>
<li><p><strong>Eden：FromPlace：ToPlace</strong>的默认占比是8：1：1，当然这个东西也可以通过一个<code>-XX:+UsePSAdaptiveSurvivorSizePolicy</code>参数来<strong>根据生成对象的速率动态调整</strong><br />
（因为存活的对象相对较少）</p></li>
<li><p>堆内存中<strong>存放的是对象</strong>，垃圾收集就是<strong>收集这些对象然后交给GC算法进行回收</strong>。非堆内存其实我们已经说过了，就是<strong>方法区</strong>。在<strong>1.8中已经移除永久代</strong>，替代品是一个<strong>元空间(MetaSpace)</strong>，最大区别是<strong>metaSpace是不存在于JVM</strong>中的，它<strong>使用的是本地内存</strong>。并有两个参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MetaspaceSize：初始化元空间大小，控制发生GC</span><br><span class="line">MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。</span><br></pre></td></tr></table></figure></li>
<li><p>移除的原因<br />
融合<strong>HotSpot JVM和JRockit
VM</strong>而做出的改变，因为<strong>JRockit是没有永久代</strong>的，不过这也<strong>间接性地解决了永久代的OOM</strong>问题。</p></li>
</ul>
<h3 id="eden年轻代的介绍">Eden年轻代的介绍</h3>
<ul>
<li><p>当new一个对象后，会放到<strong>Eden划分出来的一块作为存储空间的内存</strong>，由于堆内存共享，所以<strong>可能出现两个对象共用一个内存的情况</strong>。</p>
<blockquote>
<p>JVM的处理：<strong>为每个内存</strong>都<strong>预先申请</strong>好一块连续的内存空间并<strong>规定对象存放的位置</strong>，如果空间不足会再申请多块内存空间。这个操作称为TLAB</p>
</blockquote></li>
<li><p>Eden空间满了之后，会触发<strong>MinorGC（发生在年轻代的GC）</strong>操作，<strong>存活下来的对象</strong>移动到<strong>Survivor0区</strong>。<strong>Survivor0满后会触发MInorGC</strong>，将<strong>存活对象（这里应该包括Eden的存活对象?）移动到Survivor1区</strong>，此时还会<strong>把from和to两个指针交换</strong>，这样<strong>保证</strong>一段时间内<strong>总有一个survivor区为空且所指向的survivor区为空</strong>。</p></li>
<li><p>经过<strong>多次的MinorGC后仍然存活的对象</strong>(这里存活判断是15次，对应的虚拟机参数为<code>-XX:MaxTenuringThreshold</code>
。HotSpot会在对象中的<strong>标记字段</strong>里记录年龄，分配到的空间<strong>仅有4位</strong>，所以<strong>最多记录到15</strong>)会移动到老年代。</p></li>
<li><p>老年代是存储长期存活对象的，<strong>占满</strong>时就会触发我们常说的FullGC，期间会<strong>停止所有线程</strong>等待GC的完成。所以对于<strong>响应要求高</strong>的应用，应该尽量去<strong>减少</strong>发生FullGC从而避免响应超时的问题</p></li>
<li><p>当老年区<strong>执行full
gc周仍然无法进行对象保存</strong>操作，就会产生<strong>OOM</strong>。这时候就是虚拟机中堆内存不足，<strong>原因可能会是</strong>堆内存设置大小过小，可以通过参数<strong>-Xms、-Xmx</strong>来调整。也可能是<strong>代码中创建对象大且多</strong>，而且它们<strong>一直在被引用</strong>从而<strong>长时间垃圾收集无法收集</strong>它们</p></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/c02ecba3c33f43429a765987b928e423-new-image93b46f3d-33f9-46f9-a825-ec7129b004f6.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<blockquote>
<p>关于-XX:TargetSurvivorRatio参数的问题。其实也不一定是要满足-XX:MaxTenuringThreshold才移动到老年代。可以举个例子：如<strong>对象年龄5的占30%，年龄6的占36%，年龄7的占34%，加入某个年龄段（如例子中的年龄6）</strong>后，总占用超过Survivor空间*TargetSurvivorRatio的时候，从该年龄段开始及大于的年龄对象就要进入老年代（即例子中的年龄6对象，就是年龄6和年龄7晋升到老年代），这时候无需等到MaxTenuringThreshold中要求的15</p>
</blockquote>
<h3 id="如何判断一个对象需要被干掉">如何判断一个对象需要被干掉</h3>
<p>首先看一下对象的虚拟机的一些流程</p>
<p>图例有点问题，<strong>橙色是线程共享，青绿色是线程独享</strong> <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/1c1d85b5fb8b47239af2a5c0436eb2d7-new-image0cd10827-2f96-433c-9b16-93d4fe491d88.png"
alt="img" /></p>
<ul>
<li><p>图中<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>，3个区域随着线程生存而生存。<strong>内存分配</strong>和<strong>回收</strong>都是确定的，<strong>随着线程的结束</strong>内存自然就被回收了，因此不需要考虑垃圾回收问题。</p></li>
<li><p><strong>Java堆和方法区</strong>则不一样，各线程共享，内存的分配和回收都是动态的，垃圾收集器所关注的就是<strong>堆</strong>和<strong>方法区</strong>这部分内存</p></li>
<li><p>垃圾回收前，判断<strong>哪些对象还存活</strong>，<strong>哪些已经死去</strong>。下面介绍连个基础计算方法：</p>
<ol type="1">
<li><p><strong>引用计数器</strong>计算：给对象添加一个<strong>引用计数器</strong>，每次<strong>引用这个对象时计数器加一</strong>，<strong>引用失效时减一</strong>，<strong>计数器等于0</strong>就是不会再次使用的。不过有一种情况，就是
出现<strong>对象的循环引用时GC没法回收</strong>（我觉得不是非得循环，如果一个对象a中有属性引用另一个对象b，而a指向null，那么按这种方式，b就没有办法被回收）。</p></li>
<li><p>可达性分析计算：一种类似<strong>二叉树</strong>的实现，将一系列的<strong>GC
ROOTS作为起始的存活对象集</strong>，从这个结点往下搜索，<strong>搜索所走过的路径成为引用链</strong>，把<strong>能被该集合引用到的对象加入该集合</strong>中。</p>
<blockquote>
<p><strong>当一个对象到GC
Roots没有使用任何引用链</strong>时，则说明<strong>该对象是不可用的</strong>。Java，C#都是用这个方法判断对象是否存活</p>
</blockquote>
<p>Java语言汇总作为GCRoots的对象分为以下几种：</p>
<ol type="1">
<li><p><strong>虚拟机栈</strong>（栈帧中的<strong>本地方法表</strong>）中引用的对象（局部变量）</p></li>
<li><p><strong>方法区中静态变量</strong>所引用的对象（静态变量）</p></li>
<li><p><strong>方法区中常量</strong>引用的变量</p></li>
<li><p>本地方法栈（即native修饰的方法）中JNI引用的对象</p>
<blockquote>
<p>（JNI是Java虚拟机调用对应的C函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）</p>
</blockquote></li>
<li><p>已启动的且未终止的Java线程【这个描述好像是有问题的(不全)，应该是<strong>用作同步监视器的对象</strong>】</p></li>
</ol>
<p>这种方法的优点是，<strong>能够解决循环引用</strong>的问题，可它的实现<strong>耗费大量资源</strong>和时间，也需要GC(<strong>分析过程引用关系不能发生变化</strong>，所以需要停止所有进程)</p></li>
</ol></li>
</ul>
<h3 id="如何宣告一个对象的真正死亡">如何宣告一个对象的真正死亡</h3>
<ul>
<li><p>首先，需要提到finalize()方法，是Object类的一个方法，一个<strong>对象的finalize()</strong>方法<strong>只会被</strong>系统<strong>自动调用一次</strong>，<strong>经过finalize()方法逃脱死亡的对象(比如在方法中，其他变量又一次引用了该对象)</strong>，第二次不会再被调用</p>
<blockquote>
<p>并不提倡在程序中调用finalize()来进行自救。建议忘掉Java程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在Java9中已经被标记为
<strong>deprecated</strong> ，且
<code>java.lang.ref.Cleaner</code>（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比
<code>finalize</code> 来<br />
<code>deprecated英[ˈdeprəkeɪtɪd]美[ˈdeprəkeɪtɪd]</code></p>
</blockquote></li>
<li><p>判断一个对象的死亡至少需要两次标记</p>
<ol type="1">
<li>如果对象可达性分析之后没发现<strong>与GC
Roots相连的引用链</strong>，那它将会被第一次标记并且进行一次筛选，<strong>判断条件是</strong>是决定<strong>这个对象是否有必要执行finalize()</strong>方法。如果对象有必要执行finalize()，则被放入F-Queue队列</li>
<li>GC堆F-Queue队列中的对象<strong>进行二次标记</strong>。如果对象在finalize()方法中<strong>重新与引用链上的任何一个对象建立了关联</strong>，那么二<strong>次标记时则会将它移出“即将回收”集合</strong>。<strong>如果</strong>此时对象<strong>还没成功逃脱</strong>，那么<strong>只能被回收</strong>了。</li>
</ol></li>
</ul>
<h2 id="垃圾回收算法">垃圾回收算法</h2>
<p>确定对象已经死亡，此刻需要回收这些垃圾。常用的有<strong>标记清除</strong>、<strong>复制</strong>、<strong>标记整理</strong>、和<strong>分代收集算法</strong>。</p>
<h3 id="标记清除算法">标记清除算法</h3>
<ul>
<li>标记清除算法就是分为<strong>”标记“</strong>和<strong>”清除“</strong>两个阶段。标记出所有需要回收的对象，标记结束后统一回收。<strong>后续算法都根据这个基础来加以改进</strong></li>
<li>即：把已死亡的对象标记为空闲内存，然后记录在空闲列表中，当我们需要new一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象
<ul>
<li>不足方面：标记和清除<strong>效率比较低</strong>，且这种做法让<strong>内存中碎片非常多</strong>
。导致如果我们需要使用较大内存卡时，无法分配到足够的连续内存</li>
</ul></li>
<li>如图，可使用的内存都是零零散散的，导致大内存对象问题 <img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/01605d96d85f4daab9bfa5e7000f0d31-new-image78e03b85-fbef-4df9-b41e-2b63d78d119f.png"
alt="img" /></li>
</ul>
<h3 id="复制算法">复制算法</h3>
<ul>
<li><p>为了解决效率问题，出现了<strong>复制</strong>算法。将内存<strong>按容量</strong>划分成两等份，每次只使用其中的一块，<strong>和survivor一样</strong>用from和to两个指针。fromPlace存满了，就把存活对象copy到另一块toPlace上，然后交换指针内容，就解决了碎片问题</p>
<ul>
<li>代价：内存缩水，即堆内存的<strong>使用效率</strong>变低了</li>
</ul>
<blockquote>
<p>默认情况Eden和Survivor 为 8: 2 （Eden : S0 : S1 = 8：1：1）</p>
</blockquote>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/fc349fbb9b204495a5321febe27818d4-new-image45920a9a-552c-4656-94d6-e3ca45ff9b76.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure></li>
</ul>
<h3 id="标记整理">标记整理</h3>
<ul>
<li>复制算法在<strong>对象存活率高</strong>的时候，仍然有效率问题（要复制的多）。</li>
<li>标记整理--&gt;
标记过程与<strong>标记-清除</strong>一样，但后续<strong>不是直接对可回收对象进行清理</strong>，而是让所有<strong>存活对象都向一端移动</strong>，然后直接<strong>清理掉边界以外</strong>内存</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/2599e9f722074d34a3f7fd9f0076f121-new-imagec76192ec-b63a-43e3-a6d6-cf01f749953f.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="分代收集算法">分代收集算法</h3>
<ul>
<li>这种算法并没有什么新的思想，只是<strong>根据对象存活周期的不同将内存划分为几块</strong></li>
<li>一般是将<strong>Java堆分为新生代和老年代</strong>，即可根据各个年代特点采用最适当的收集算法
<ul>
<li><strong>新生代</strong>中，每次垃圾收集时会有大批对象死去，<strong>只有少量存活</strong>，就采用复制算法，只需要付出<strong>少量存活对象的复制成本</strong>即可完成收集</li>
<li><strong>老年代</strong>中，因为存活对象存活率高，也没有<strong>额外空间</strong>对它进行分配担保（<code>新生代如果不够可以放老年代，而老年代清理失败就会OutOfMemory，不像新生代可以移动到老年代</code>），所以必须使用<strong>“标记-清理”</strong>或者<strong>“标记-整理”</strong>来进行回收</li>
</ul></li>
<li>即：具体问题具体分析</li>
</ul>
<h2 id="了解各种各样的垃圾回收器">（了解）各种各样的垃圾回收器</h2>
<figure>
<img
src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/11e9dcd0f1ee4f25836e6f1c47104c51-new-image69e1c56a-1d40-493a-9901-6efc647a01f3.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li><p>新生代的垃圾回收器：Serial（串行--复制），ParNew（并行--复制），ParallelScavenge（并行--复制）</p></li>
<li><p>老年代的垃圾回收器：SerialOld（串行--标记整理），ParallelOld（并行--标记整理），CMS（并发--标记清除）</p></li>
<li><p>只有CMS和G1是并发，且CMS只作用于老年代，而G1都有</p></li>
<li><p>JDK8为止，默认垃圾回收器是Parallel Scavenge和Parallel
Old【<strong>并行--复制</strong>和<strong>并行--标记整理</strong>】</p></li>
<li><p>JDK9开始，<strong>G1收集器成为默认的垃圾收集器</strong>，目前来看，<strong>G1回收期停顿时间最短</strong>且没有明显缺点，偏适合Web应用</p></li>
</ul>
<blockquote>
<p>jdk8中测试Web应用，堆内存6G中新生代4.5G的情况下</p>
<ul>
<li>ParallelScavenge回收新生代停顿长达1.5秒。</li>
<li>G1回收器回收同样大小的新生代只停顿0.2秒</li>
</ul>
</blockquote>
<h2 id="了解-jvm的常用参数">（了解） JVM的常用参数</h2>
<p>JVM的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。</p>
<table style="width:100%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 16%" />
</colgroup>
<thead>
<tr class="header">
<th>参数名称</th>
<th>含义</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-Xms</td>
<td>初始堆大小</td>
<td>物理内存的1/64(&lt;1GB)</td>
<td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td>
</tr>
<tr class="even">
<td>-Xmx</td>
<td>最大堆大小</td>
<td>物理内存的1/4(&lt;1GB)</td>
<td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到
-Xms的最小限制</td>
</tr>
<tr class="odd">
<td>-Xmn</td>
<td>年轻代大小(1.4or later)</td>
<td></td>
<td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New
gen是不同的。整个堆大小=年轻代大小 + 老年代大小 +
持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td>
</tr>
<tr class="even">
<td>-XX:NewSize</td>
<td>设置年轻代大小(for 1.3/1.4)</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>-XX:MaxNewSize</td>
<td>年轻代最大值(for 1.3/1.4)</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>-XX:PermSize</td>
<td>设置持久代(perm gen)初始值</td>
<td>物理内存的1/64</td>
<td></td>
</tr>
<tr class="odd">
<td>-XX:MaxPermSize</td>
<td>设置持久代最大值</td>
<td>物理内存的1/4</td>
<td></td>
</tr>
<tr class="even">
<td>-Xss</td>
<td>每个线程的堆栈大小</td>
<td></td>
<td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.根据应用的线程所需内存大小进行
调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用，
如果栈不是很深， 应该是128k够用的
大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss
is translated in a VM flag named
ThreadStackSize”一般设置这个值就可以了</td>
</tr>
<tr class="odd">
<td>-XX:NewRatio</td>
<td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td>
<td></td>
<td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td>
</tr>
<tr class="even">
<td>-XX:SurvivorRatio</td>
<td>Eden区与Survivor区的大小比值</td>
<td></td>
<td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td>
</tr>
<tr class="odd">
<td>-XX:+DisableExplicitGC</td>
<td>关闭System.gc()</td>
<td></td>
<td>这个参数需要严格的测试</td>
</tr>
<tr class="even">
<td>-XX:PretenureSizeThreshold</td>
<td>对象超过多大是直接在旧生代分配</td>
<td>0</td>
<td>单位字节 新生代采用Parallel
ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td>
</tr>
<tr class="odd">
<td>-XX:ParallelGCThreads</td>
<td>并行收集器的线程数</td>
<td></td>
<td>此值最好配置与处理器数目相等 同样适用于CMS</td>
</tr>
<tr class="even">
<td>-XX:MaxGCPauseMillis</td>
<td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td>
<td></td>
<td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td>
</tr>
</tbody>
</table>
<p>其实还有一些打印及CMS方面的参数，这里就不以一一列举了</p>
<h1 id="关于jvm调优的一些方面">关于JVM调优的一些方面</h1>
<ul>
<li>默认
<ul>
<li>年轻代：老年代 = 1: 2</li>
<li>年轻代中 Eden : S0 : S 1 = 8 : 1 ：1</li>
</ul></li>
<li>根据刚刚涉及的jvm知识点，可以尝试对JVM进行调优，<strong>主要是堆内存</strong>那块</li>
<li><strong>所有线程共享数据区大小</strong>=<strong>新生代大小</strong>+<strong>老年代大小</strong>+<strong>持久代大小</strong>
（即 堆 + 方法区）</li>
<li>持久代一般固定大小为64m，</li>
<li>java堆中增大年轻代后，会减少老年代大小（因为老年代的清理使用fullgc，所以老年代过小的话反而会增多fullgc）。
年轻代 <code>-Xmn</code>的值推荐配置为<strong>java堆的3/8</strong></li>
</ul>
<h2 id="调整最大堆内存和最小堆内存">调整最大堆内存和最小堆内存</h2>
<ul>
<li><p>-Xmx -Xms：指定java堆最大值（默认 物理内存的1/4 (&lt;1 GB ) ) 和
初始java堆最小值（默认值是物理内存的1/64 (&lt;1GB) ）</p></li>
<li><p>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到
-Xms的最小限制。</p>
<blockquote>
<p>简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于40%了，JVM就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于70%，又会动态缩小不过不会小于–Xms。就这么简单</p>
</blockquote></li>
<li><p>开发过程中，通常会将 -Xms 与 Xmx 两个参数设置成相同的值</p>
<blockquote>
<p>为的是能够在java垃圾回收机制清理完堆区后，<strong>不需要重新分隔计算堆区的大小而浪费资源（向系统请求/释放内存资源）</strong></p>
</blockquote></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);    <span class="comment">//系统的最大空间-Xmx--运行几次都不变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//系统的空闲空间--每次运行都变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//当前可用的总空间 与Xms有关--运行几次都不变</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* -----</span></span><br><span class="line"><span class="comment">Xmx=7389184.0KB</span></span><br><span class="line"><span class="comment">free mem=493486.0546875KB</span></span><br><span class="line"><span class="comment">total mem=498688.0KB</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol type="1">
<li>maxMemory()这个方法返回的是java虚拟机(这个进程)能构从操纵系统那里挖到的最大的内存</li>
<li>freeMemory：挖过来而又没有用上的内存，实际上就是
freeMemory()，所以freeMemory()的值一般情况下都是很小的(totalMemory一般比需要用得多一点，剩下的一点就是freeMemory)</li>
<li>totalMemory：程序运行的过程中，内存总是慢慢的从操纵系统那里挖的，基本上是用多少挖多少，直
挖到maxMemory()为止，所以totalMemory()是慢慢增大的
原文链接：https://blog.csdn.net/weixin_35671171/article/details/114189796</li>
</ol>
</blockquote></li>
<li><p>编辑VM options参数后再看效果：<br />
<figure class="highlight plaintext"><figcaption><span>-Xms5m -XX:+PrintGCDetails```，堆最大以及堆初始值  20m和5m</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">/* 效果</span><br><span class="line"> [GC (Allocation Failure) [PSYoungGen: 1024K-&gt;488K(1536K)] 1024K-&gt;608K(5632K), 0.0007606 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Xmx=18432.0KB</span><br><span class="line">free mem=4249.90625KB</span><br><span class="line">total mem=5632.0KB</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 1536K, used 1326K [0x00000000ff980000, 0x00000000ffb80000, 0x0000000100000000)</span><br><span class="line">  eden space 1024K, 81% used [0x00000000ff980000,0x00000000ffa51ad0,0x00000000ffa80000)</span><br><span class="line">  from space 512K, 95% used [0x00000000ffa80000,0x00000000ffafa020,0x00000000ffb00000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000ffb00000,0x00000000ffb00000,0x00000000ffb80000)</span><br><span class="line"> ParOldGen       total 4096K, used 120K [0x00000000fec00000, 0x00000000ff000000, 0x00000000ff980000)</span><br><span class="line">  object space 4096K, 2% used [0x00000000fec00000,0x00000000fec1e010,0x00000000ff000000)</span><br><span class="line"> Metaspace       used 3164K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 344K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li>如上， <strong>Allocation Failure</strong>
因为分配失败导致YoungGen</li>
<li>total mem (此时申请到的总内存)：<br />
PSYoungGen + ParOldGen = 1536 + 4096 = 5632 KB</li>
<li>freeMemory (申请后没有使用的内存)<br />
1324 + 120 = 1444 KB 5632 - 4249 = 1383 KB 差不多</li>
</ol></li>
<li><p>使用1M后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);    <span class="comment">//系统的最大空间-Xmx--运行几次都不变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//系统的空闲空间--每次运行都变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//当前可用的总空间 与Xms有关--运行几次都不变</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;分配了1M空间给数组&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> [GC (Allocation Failure) [PSYoungGen: 1024K-&gt;488K(1536K)] 1024K-&gt;608K(5632K), 0.0007069 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">Xmx=18432.0KB</span></span><br><span class="line"><span class="comment">free mem=4270.15625KB</span></span><br><span class="line"><span class="comment">total mem=5632.0KB</span></span><br><span class="line"><span class="comment">分配了1M空间给数组</span></span><br><span class="line"><span class="comment">Xmx=18.0M</span></span><br><span class="line"><span class="comment">free mem=3.1700592041015625M  //少了1M</span></span><br><span class="line"><span class="comment">total mem=5.5M</span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> PSYoungGen      total 1536K, used 1270K [0x00000000ff980000, 0x00000000ffb80000, 0x0000000100000000)</span></span><br><span class="line"><span class="comment">  eden space 1024K, 76% used [0x00000000ff980000,0x00000000ffa43aa0,0x00000000ffa80000)</span></span><br><span class="line"><span class="comment">  from space 512K, 95% used [0x00000000ffa80000,0x00000000ffafa020,0x00000000ffb00000)</span></span><br><span class="line"><span class="comment">  to   space 512K, 0% used [0x00000000ffb00000,0x00000000ffb00000,0x00000000ffb80000)</span></span><br><span class="line"><span class="comment"> ParOldGen       total 4096K, used 1144K [0x00000000fec00000, 0x00000000ff000000, 0x00000000ff980000)</span></span><br><span class="line"><span class="comment">  object space 4096K, 27% used [0x00000000fec00000,0x00000000fed1e020,0x00000000ff000000)</span></span><br><span class="line"><span class="comment"> Metaspace       used 3155K, capacity 4496K, committed 4864K, reserved 1056768K</span></span><br><span class="line"><span class="comment">  class space    used 344K, capacity 388K, committed 512K, reserved 1048576K</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>此时free memory就又缩水了，不过<strong>total
memory是没有变化</strong>的。Java会尽可能将<strong>total
mem的值维持在最小堆内存大小</strong></p></li>
<li><p>这时候我们创建了一个10M的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的total
memory已经变成了15M，这就是已经申请了一次内存的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);    <span class="comment">//系统的最大空间-Xmx--运行几次都不变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//系统的空闲空间--每次运行都变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//当前可用的总空间 与Xms有关--运行几次都不变</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;分配了1M空间给数组&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] c = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;分配了10M空间给数组&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//当前可用的总空间</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**  ----</span></span><br><span class="line"><span class="comment">[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;488K(1536K)] 1024K-&gt;600K(5632K), 0.0006681 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">Xmx=18432.0KB</span></span><br><span class="line"><span class="comment">free mem=4257.953125KB</span></span><br><span class="line"><span class="comment">total mem=5632.0KB</span></span><br><span class="line"><span class="comment">分配了1M空间给数组</span></span><br><span class="line"><span class="comment">Xmx=18.0M</span></span><br><span class="line"><span class="comment">free mem=3.1153564453125M</span></span><br><span class="line"><span class="comment">total mem=5.5M</span></span><br><span class="line"><span class="comment">分配了10M空间给数组</span></span><br><span class="line"><span class="comment">Xmx=18.0M</span></span><br><span class="line"><span class="comment">free mem=2.579681396484375M</span></span><br><span class="line"><span class="comment">total mem=15.0M</span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> PSYoungGen      total 1536K, used 1363K [0x00000000ff980000, 0x00000000ffb80000, 0x0000000100000000)</span></span><br><span class="line"><span class="comment">  eden space 1024K, 85% used [0x00000000ff980000,0x00000000ffa5acc0,0x00000000ffa80000)</span></span><br><span class="line"><span class="comment">  from space 512K, 95% used [0x00000000ffa80000,0x00000000ffafa020,0x00000000ffb00000)</span></span><br><span class="line"><span class="comment">  to   space 512K, 0% used [0x00000000ffb00000,0x00000000ffb00000,0x00000000ffb80000)</span></span><br><span class="line"><span class="comment"> ParOldGen       total 13824K, used 11376K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000)</span></span><br><span class="line"><span class="comment">  object space 13824K, 82% used [0x00000000fec00000,0x00000000ff71c020,0x00000000ff980000)</span></span><br><span class="line"><span class="comment"> Metaspace       used 3242K, capacity 4500K, committed 4864K, reserved 1056768K</span></span><br><span class="line"><span class="comment">  class space    used 351K, capacity 388K, committed 512K, reserved 1048576K</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>此时我们再跑一下这个代码</p>
<p>此时要调整垃圾收集器(<code>-XX:+UseG1GC</code>)且b、c要指向null，才能让系统回收这部分内存，即<code>-Xmx20m -Xms5m -XX:+PrintGCDetails -XX:+UseG1GC</code>
<strong>注：使用<code>-XX: +UseSerialGC</code>或者<code>-XX:+UseParallelGC</code>都是不能达到效果的</strong></p>
<blockquote>
<p>此时我们手动执行了一次fullgc，此时total
memory的内存空间又变回6.0M了，此时又是把申请的内存释放掉的结果。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);    <span class="comment">//系统的最大空间-Xmx--运行几次都不变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//系统的空闲空间--每次运行都变</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span>   + <span class="string">&quot;KB&quot;</span>);  <span class="comment">//当前可用的总空间 与Xms有关--运行几次都不变</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;分配了1M空间给数组&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] c = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        System.out.println(<span class="string">&quot;分配了10M空间给数组&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//当前可用的总空间</span></span><br><span class="line"></span><br><span class="line">        b=<span class="literal">null</span>;</span><br><span class="line">        c=<span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;进行了gc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Xmx=&quot;</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);    <span class="comment">//系统的最大空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;free mem=&quot;</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total mem=&quot;</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">&quot;M&quot;</span>);  <span class="comment">//当前可用的总空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------</span></span><br><span class="line"><span class="comment">Xmx=20480.0KB</span></span><br><span class="line"><span class="comment">free mem=4290.3671875KB</span></span><br><span class="line"><span class="comment">total mem=6144.0KB</span></span><br><span class="line"><span class="comment">分配了1M空间给数组</span></span><br><span class="line"><span class="comment">Xmx=20.0M</span></span><br><span class="line"><span class="comment">free mem=3.1897964477539062M</span></span><br><span class="line"><span class="comment">total mem=6.0M</span></span><br><span class="line"><span class="comment">[GC pause (G1 Humongous Allocation) (young) (initial-mark), 0.0014754 secs]</span></span><br><span class="line"><span class="comment">   [Parallel Time: 1.1 ms, GC Workers: 8]</span></span><br><span class="line"><span class="comment">      [GC Worker Start (ms): Min: 105.0, Avg: 105.1, Max: 105.3, Diff: 0.3]</span></span><br><span class="line"><span class="comment">      [Ext Root Scanning (ms): Min: 0.5, Avg: 0.5, Max: 0.8, Diff: 0.4, Sum: 4.4]</span></span><br><span class="line"><span class="comment">      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span><br><span class="line"><span class="comment">         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]</span></span><br><span class="line"><span class="comment">      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span><br><span class="line"><span class="comment">      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</span></span><br><span class="line"><span class="comment">      [Object Copy (ms): Min: 0.1, Avg: 0.3, Max: 0.4, Diff: 0.2, Sum: 2.5]</span></span><br><span class="line"><span class="comment">      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.3]</span></span><br><span class="line"><span class="comment">         [Termination Attempts: Min: 1, Avg: 6.0, Max: 9, Diff: 8, Sum: 48]</span></span><br><span class="line"><span class="comment">      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.2]</span></span><br><span class="line"><span class="comment">      [GC Worker Total (ms): Min: 0.8, Avg: 0.9, Max: 1.0, Diff: 0.3, Sum: 7.4]</span></span><br><span class="line"><span class="comment">      [GC Worker End (ms): Min: 106.0, Avg: 106.1, Max: 106.1, Diff: 0.0]</span></span><br><span class="line"><span class="comment">   [Code Root Fixup: 0.0 ms]</span></span><br><span class="line"><span class="comment">   [Code Root Purge: 0.0 ms]</span></span><br><span class="line"><span class="comment">   [Clear CT: 0.1 ms]</span></span><br><span class="line"><span class="comment">   [Other: 0.3 ms]</span></span><br><span class="line"><span class="comment">      [Choose CSet: 0.0 ms]</span></span><br><span class="line"><span class="comment">      [Ref Proc: 0.1 ms]</span></span><br><span class="line"><span class="comment">      [Ref Enq: 0.0 ms]</span></span><br><span class="line"><span class="comment">      [Redirty Cards: 0.1 ms]</span></span><br><span class="line"><span class="comment">      [Humongous Register: 0.0 ms]</span></span><br><span class="line"><span class="comment">      [Humongous Reclaim: 0.0 ms]</span></span><br><span class="line"><span class="comment">      [Free CSet: 0.0 ms]</span></span><br><span class="line"><span class="comment">   [Eden: 2048.0K(3072.0K)-&gt;0.0B(1024.0K) Survivors: 0.0B-&gt;1024.0K Heap: 2877.6K(6144.0K)-&gt;1955.9K(6144.0K)]</span></span><br><span class="line"><span class="comment"> [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">[GC concurrent-root-region-scan-start]</span></span><br><span class="line"><span class="comment">[GC concurrent-root-region-scan-end, 0.0005373 secs]</span></span><br><span class="line"><span class="comment">[GC concurrent-mark-start]</span></span><br><span class="line"><span class="comment">[GC concurrent-mark-end, 0.0000714 secs]</span></span><br><span class="line"><span class="comment">[GC remark [Finalize Marking, 0.0001034 secs] [GC ref-proc, 0.0000654 secs] [Unloading, 0.0005193 secs], 0.0007843 secs]</span></span><br><span class="line"><span class="comment"> [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">[GC cleanup 11M-&gt;11M(17M), 0.0003613 secs]</span></span><br><span class="line"><span class="comment"> [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">分配了10M空间给数组</span></span><br><span class="line"><span class="comment">Xmx=20.0M</span></span><br><span class="line"><span class="comment">free mem=5.059120178222656M</span></span><br><span class="line"><span class="comment">total mem=17.0M</span></span><br><span class="line"><span class="comment">[Full GC (System.gc())  11M-&gt;654K(6144K), 0.0031959 secs]</span></span><br><span class="line"><span class="comment">   [Eden: 1024.0K(1024.0K)-&gt;0.0B(2048.0K) Survivors: 1024.0K-&gt;0.0B Heap: 11.9M(17.0M)-&gt;654.4K(6144.0K)], [Metaspace: 3152K-&gt;3152K(1056768K)]</span></span><br><span class="line"><span class="comment"> [Times: user=0.00 sys=0.00, real=0.00 secs] </span></span><br><span class="line"><span class="comment">进行了gc</span></span><br><span class="line"><span class="comment">Xmx=20.0M</span></span><br><span class="line"><span class="comment">free mem=5.2661590576171875M</span></span><br><span class="line"><span class="comment">total mem=6.0M</span></span><br><span class="line"><span class="comment">Heap</span></span><br><span class="line"><span class="comment"> garbage-first heap   total 6144K, used 654K [0x00000000fec00000, 0x00000000fed00030, 0x0000000100000000)</span></span><br><span class="line"><span class="comment">  region size 1024K, 1 young (1024K), 0 survivors (0K)</span></span><br><span class="line"><span class="comment"> Metaspace       used 3243K, capacity 4500K, committed 4864K, reserved 1056768K</span></span><br><span class="line"><span class="comment">  class space    used 351K, capacity 388K, committed 512K, reserved 1048576K</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="调整新生代和老年代的比值">调整新生代和老年代的比值</h2>
<p>-XX:NewRatio ---
新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p>
<blockquote>
<p>例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的1/5。在Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。
注：Xmn为直接设置大小，如<code>-Xmn2G</code></p>
</blockquote>
<h2 id="调整survivor区和eden区的比值">调整Survivor区和Eden区的比值</h2>
<p>-XX:SurvivorRatio（幸存代）--- 设置两个Survivor区和eden的比值</p>
<p>例如：8，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10</p>
<h2 id="设置年轻代和老年代的大小">设置年轻代和老年代的大小</h2>
<p>-XX:NewSize --- 设置年轻代大小</p>
<p>-XX:MaxNewSize --- 设置年轻代最大值</p>
<blockquote>
<p>可以通过设置不同参数来测试不同的情况，反正<strong>最优解</strong>当然就是<strong>官方的Eden和Survivor的占比为8:1:1</strong>，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正<strong>最大堆内存和最小堆内存如果数值不同会导致多次的gc</strong>，需要注意。</p>
<blockquote>
<p>我的理解是<strong>会经常调整totalMemory而导致多次gc</strong>，避免临界条件下的<a
target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=垃圾回收&amp;spm=1001.2101.3001.7020">垃圾回收</a>和内存申请和分配</p>
</blockquote>
<p>注：
<strong>最大堆内存和最小堆内存</strong>设置成一样，为的是能够在java垃圾回收机制清理完堆区后，<strong>不需要重新分隔计算堆区的大小而浪费资源（向系统请求/释放内存资源）</strong></p>
</blockquote>
<h2 id="小总结">小总结</h2>
<p>根据实际事情调整新生代和幸存代的大小，官方推荐<strong>新生代占java堆的3/8</strong>，<strong>幸存代</strong>占<strong>新生代</strong>的1/10</p>
<blockquote>
<p>Java堆：新生代 <strong>(3/8)</strong>，老年代</p>
<p>新生代：SO <strong>(1/10)</strong> ，S1 ，Eden</p>
</blockquote>
<p>在OOM时，记得Dump出堆，确保可以排查现场问题，通过下面命令可以输出一个.dump
文件，该文件用<strong>VisualVM</strong>或Java自带的JavaVisualVM 工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径</span><br></pre></td></tr></table></figure>
<p>一般我们也可以通过<strong>编写脚本的方式来让OOM出现时给我们报个信</strong>，可以<strong>通过发送邮件</strong>或者<strong>重启程序</strong>等来解决</p>
<h2 id="永久区的设置">永久区的设置</h2>
<ul>
<li><p><code>-XX:PermSize -XX:MaxPermSize</code>，应该说的是永久代</p></li>
<li><p>初始空间（默认为物理内存的1/64）和最大空间（默认为物理内存的1/4）。也就是说，jvm启动时，永久区一开始就占用了PermSize大小的空间，如果空间还不够，可以继续扩展，但是不能超过MaxPermSize，否则会OOM。</p></li>
<li><p>如果堆空间没有用完也抛出了OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出
一样抛出OOM</p></li>
</ul>
<h2 id="jvm的栈参数调优">JVM的栈参数调优</h2>
<h3 id="调整每个线程栈空间的大小">调整每个线程栈空间的大小</h3>
<p>可以通过<strong>-Xss</strong>：调整每个线程栈空间的大小</p>
<blockquote>
<p>JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右</p>
</blockquote>
<h3 id="设置线程栈的大小">设置线程栈的大小</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-XXThreadStackSize：</span><br><span class="line">    #设置线程栈的大小(0 means use default stack size)</span><br></pre></td></tr></table></figure>
<p>补充：</p>
<blockquote>
<p>-Xss是OpenJDK和Oracle JDK的-XX:ThreadStackSize的别名。</p>
<p>尽管他们对参数的解析不同： -Xss可以接受带K，M或G后缀的数字；
-XX:ThreadStackSize=需要一个整数(无后缀)-堆栈大小(以千字节为单位)</p>
</blockquote>
<h2
id="可以直接跳过了jvm其他参数介绍">(可以直接跳过了)JVM其他参数介绍</h2>
<p>形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。</p>
<h3 id="设置内存页的大小">设置内存页的大小</h3>
<pre><code>-XXThreadStackSize：
    设置内存页的大小，不可设置过大，会影响Perm的大小</code></pre>
<h3 id="设置原始类型的快速优化">设置原始类型的快速优化</h3>
<pre><code>-XX:+UseFastAccessorMethods：
    设置原始类型的快速优化</code></pre>
<h3 id="设置关闭手动gc">设置关闭手动GC</h3>
<pre><code>-XX:+DisableExplicitGC：
    设置关闭System.gc()(这个参数需要严格的测试)</code></pre>
<h3 id="设置垃圾最大年龄">设置垃圾最大年龄</h3>
<pre><code>-XX:MaxTenuringThreshold
    设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.
    对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,
    则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,
    增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.</code></pre>
<h3 id="加快编译速度">加快编译速度</h3>
<pre><code>-XX:+AggressiveOpts</code></pre>
<p>加快编译速度</p>
<h3 id="改善锁机制性能">改善锁机制性能</h3>
<pre><code>-XX:+UseBiasedLocking</code></pre>
<h3 id="禁用垃圾回收">禁用垃圾回收</h3>
<pre><code>-Xnoclassgc</code></pre>
<h3 id="设置堆空间存活时间">设置堆空间存活时间</h3>
<pre><code>-XX:SoftRefLRUPolicyMSPerMB
    设置每兆堆空闲空间中SoftReference的存活时间，默认值是1s。</code></pre>
<h3 id="设置对象直接分配在老年代">设置对象直接分配在老年代</h3>
<pre><code>-XX:PretenureSizeThreshold
    设置对象超过多大时直接在老年代分配，默认值是0。</code></pre>
<h3 id="设置tlab占eden区的比例">设置TLAB占eden区的比例</h3>
<pre><code>-XX:TLABWasteTargetPercent
    设置TLAB占eden区的百分比，默认值是1% 。 </code></pre>
<h3 id="设置是否优先ygc">设置是否优先YGC</h3>
<pre><code>-XX:+CollectGen0First
    设置FullGC时是否先YGC，默认值是false。</code></pre>
<h1 id="finally">finally</h1>
<p>附录：</p>
<blockquote>
<p>真的扯了很久这东西，参考了多方的资料，有极客时间的《深入拆解虚拟机》和《Java核心技术面试精讲》，也有百度，也有自己在学习的一些线上课程的总结。希望对你有所帮助，谢谢。</p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A4%8D%E4%B9%A0/" rel="tag"># 复习</a>
              <a href="/tags/%E5%A4%8D%E4%B9%A0-javaGuide/" rel="tag"># 复习-javaGuide</a>
              <a href="/tags/%E5%A4%8D%E4%B9%A0-javaGuide-jvm/" rel="tag"># 复习-javaGuide-jvm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/07/review/java_guide/java/jvm/memory-area/" rel="prev" title="memory-area">
      <i class="fa fa-chevron-left"></i> memory-area
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/12/12/review/java_guide/java/jvm/garbage-collection/" rel="next" title="java垃圾回收器">
      java垃圾回收器 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="lwmfjc/lwmfjc.github.io.comment" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#jvm%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">JVM的基本介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E6%96%87%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84"><span class="nav-number">1.1.</span> <span class="nav-text">Java文件是如何运行的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BE%8B%E5%AD%90"><span class="nav-number">1.2.</span> <span class="nav-text">简单的代码例子</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">类加载器的介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">类加载器的流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-number">2.1.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5"><span class="nav-number">2.1.2.</span> <span class="nav-text">链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.1.3.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD"><span class="nav-number">2.1.4.</span> <span class="nav-text">卸载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">类加载器的加载顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">2.3.</span> <span class="nav-text">双亲委派机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">3.</span> <span class="nav-text">运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">3.1.</span> <span class="nav-text">本地方法栈和程序计数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">3.2.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86"><span class="nav-number">3.3.</span> <span class="nav-text">虚拟机栈和虚拟机堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">3.3.1.</span> <span class="nav-text">虚拟机栈的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%AD%98%E5%9C%A8%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-number">3.3.2.</span> <span class="nav-text">虚拟机栈存在的异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.3.3.</span> <span class="nav-text">虚拟机栈的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-number">3.3.4.</span> <span class="nav-text">虚拟机栈的执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%8D%E7%94%A8"><span class="nav-number">3.3.5.</span> <span class="nav-text">局部变量的复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">3.3.6.</span> <span class="nav-text">虚拟机堆的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eden%E5%B9%B4%E8%BD%BB%E4%BB%A3%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.3.7.</span> <span class="nav-text">Eden年轻代的介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E8%A2%AB%E5%B9%B2%E6%8E%89"><span class="nav-number">3.3.8.</span> <span class="nav-text">如何判断一个对象需要被干掉</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%A3%E5%91%8A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9C%9F%E6%AD%A3%E6%AD%BB%E4%BA%A1"><span class="nav-number">3.3.9.</span> <span class="nav-text">如何宣告一个对象的真正死亡</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.1.</span> <span class="nav-text">标记清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86"><span class="nav-number">3.4.3.</span> <span class="nav-text">标记整理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.4.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">3.5.</span> <span class="nav-text">（了解）各种各样的垃圾回收器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-jvm%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">3.6.</span> <span class="nav-text">（了解） JVM的常用参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Ejvm%E8%B0%83%E4%BC%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E9%9D%A2"><span class="nav-number">4.</span> <span class="nav-text">关于JVM调优的一些方面</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E6%9C%80%E5%A4%A7%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%9C%80%E5%B0%8F%E5%A0%86%E5%86%85%E5%AD%98"><span class="nav-number">4.1.</span> <span class="nav-text">调整最大堆内存和最小堆内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E6%AF%94%E5%80%BC"><span class="nav-number">4.2.</span> <span class="nav-text">调整新生代和老年代的比值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E6%95%B4survivor%E5%8C%BA%E5%92%8Ceden%E5%8C%BA%E7%9A%84%E6%AF%94%E5%80%BC"><span class="nav-number">4.3.</span> <span class="nav-text">调整Survivor区和Eden区的比值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.4.</span> <span class="nav-text">设置年轻代和老年代的大小</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="nav-number">4.5.</span> <span class="nav-text">小总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B0%B8%E4%B9%85%E5%8C%BA%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="nav-number">4.6.</span> <span class="nav-text">永久区的设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm%E7%9A%84%E6%A0%88%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="nav-number">4.7.</span> <span class="nav-text">JVM的栈参数调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.7.1.</span> <span class="nav-text">调整每个线程栈空间的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%A0%88%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.7.2.</span> <span class="nav-text">设置线程栈的大小</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B7%B3%E8%BF%87%E4%BA%86jvm%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="nav-number">4.8.</span> <span class="nav-text">(可以直接跳过了)JVM其他参数介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%86%85%E5%AD%98%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">4.8.1.</span> <span class="nav-text">设置内存页的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BF%AB%E9%80%9F%E4%BC%98%E5%8C%96"><span class="nav-number">4.8.2.</span> <span class="nav-text">设置原始类型的快速优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%B3%E9%97%AD%E6%89%8B%E5%8A%A8gc"><span class="nav-number">4.8.3.</span> <span class="nav-text">设置关闭手动GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%9E%83%E5%9C%BE%E6%9C%80%E5%A4%A7%E5%B9%B4%E9%BE%84"><span class="nav-number">4.8.4.</span> <span class="nav-text">设置垃圾最大年龄</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E5%BF%AB%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6"><span class="nav-number">4.8.5.</span> <span class="nav-text">加快编译速度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%96%84%E9%94%81%E6%9C%BA%E5%88%B6%E6%80%A7%E8%83%BD"><span class="nav-number">4.8.6.</span> <span class="nav-text">改善锁机制性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A6%81%E7%94%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">4.8.7.</span> <span class="nav-text">禁用垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E7%A9%BA%E9%97%B4%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4"><span class="nav-number">4.8.8.</span> <span class="nav-text">设置堆空间存活时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E5%88%86%E9%85%8D%E5%9C%A8%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">4.8.9.</span> <span class="nav-text">设置对象直接分配在老年代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEtlab%E5%8D%A0eden%E5%8C%BA%E7%9A%84%E6%AF%94%E4%BE%8B"><span class="nav-number">4.8.10.</span> <span class="nav-text">设置TLAB占eden区的比例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%98%AF%E5%90%A6%E4%BC%98%E5%85%88ygc"><span class="nav-number">4.8.11.</span> <span class="nav-text">设置是否优先YGC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#finally"><span class="nav-number">5.</span> <span class="nav-text">finally</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="刘易"
      src="https://raw.githubusercontent.com/lwmfjc/lwmfjc.github.io.resource/main/img/avatar.png">
  <p class="site-author-name" itemprop="name">刘易</p>
  <div class="site-description" itemprop="description">知命不惧 日日自新</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">125</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lwmfjc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lwmfjc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘易</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">814k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">24:41</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
